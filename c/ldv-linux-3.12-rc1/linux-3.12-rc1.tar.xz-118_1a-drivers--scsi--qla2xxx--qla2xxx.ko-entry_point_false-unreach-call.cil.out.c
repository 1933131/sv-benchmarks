extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 88 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 144 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 161 "include/linux/init.h"
struct __anonstruct_ldv_1042_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 161 "include/linux/init.h"
struct __anonstruct_ldv_1057_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 161 "include/linux/init.h"
union __anonunion_ldv_1058_8 {
   struct __anonstruct_ldv_1042_9 ldv_1042 ;
   struct __anonstruct_ldv_1057_10 ldv_1057 ;
};
#line 161 "include/linux/init.h"
struct desc_struct {
   union __anonunion_ldv_1058_8 ldv_1058 ;
};
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 385
struct thread_struct;
#line 387
struct mm_struct;
#line 388
struct task_struct;
#line 389
struct cpumask;
#line 390 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1464_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1464_15 ldv_1464 ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_1471_17 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_16 {
   s64 lock ;
   struct __anonstruct_ldv_1471_17 ldv_1471 ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_16 arch_rwlock_t;
#line 354 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 383 "include/linux/kernel.h"
struct pid;
#line 628 "include/linux/kernel.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_19 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_20 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_21 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion_ldv_2616_18 {
   struct __anonstruct_futex_19 futex ;
   struct __anonstruct_nanosleep_20 nanosleep ;
   struct __anonstruct_poll_21 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_2616_18 ldv_2616 ;
};
#line 26 "include/asm-generic/getorder.h"
struct exec_domain;
#line 127 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2764_22 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2764_22 ldv_2764 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 663 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 26 "include/linux/personality.h"
struct map_segment;
#line 26 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 162 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5041_27 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5047_28 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5048_26 {
   struct __anonstruct_ldv_5041_27 ldv_5041 ;
   struct __anonstruct_ldv_5047_28 ldv_5047 ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5057_29 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5048_26 ldv_5048 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5057_29 ldv_5057 ;
};
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 378 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 384 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 439
struct kmem_cache;
#line 440
struct perf_event;
#line 441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 582 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_31 {
   unsigned long seg ;
};
#line 582 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_31 mm_segment_t;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 115 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/barrier.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 533 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6104_33 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6105_32 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6104_33 ldv_6104 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6105_32 ldv_6105 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_34 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_34 rwlock_t;
#line 28 "include/linux/rwlock_types.h"
struct static_key {
   atomic_t enabled ;
};
#line 33 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 38 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 986 "include/linux/wait.h"
struct seqcount {
   unsigned int sequence ;
};
#line 47 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 183 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_35 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 183 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_35 seqlock_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 144 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 223 "include/linux/rcupdate.h"
struct notifier_block;
#line 1028 "include/linux/rcupdate.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 317 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 388
struct tvec_base;
#line 389 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 258 "include/linux/timer.h"
struct hrtimer;
#line 259
enum hrtimer_restart;
#line 270
struct workqueue_struct;
#line 271
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 141 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 888 "include/linux/mmzone.h"
struct ctl_table;
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 506 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 513
struct dev_pm_qos;
#line 513 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 570 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 132 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/xen/hypervisor.h"
struct bio_vec;
#line 339 "include/linux/clocksource.h"
struct device_node;
#line 18 "include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
};
#line 58 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 318 "include/linux/slab.h"
struct sock;
#line 319
struct kobject;
#line 320
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 326 "include/linux/slab.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 24 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_128 {
   uid_t val ;
};
#line 24 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_128 kuid_t;
#line 29 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_129 {
   gid_t val ;
};
#line 29 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_129 kgid_t;
#line 149 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct bin_attribute;
#line 37 "include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 36 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 66 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 129 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 178
struct sysfs_dirent;
#line 251 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 40 "include/linux/kobject.h"
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
#line 50
struct kset;
#line 50
struct kobj_type;
#line 50 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 111 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 119 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 126 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 143 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 248 "include/linux/kobject.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 445 "include/linux/slab.h"
struct __anonstruct_ldv_13198_131 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 445 "include/linux/slab.h"
union __anonunion_ldv_13199_130 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_13198_131 ldv_13198 ;
};
#line 445 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_13199_130 ldv_13199 ;
};
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host;
#line 42
struct qla_hw_data;
#line 62
struct fc_rport;
#line 64
struct fc_bsg_job;
#line 65
struct Scsi_Host;
#line 82
struct fc_port;
#line 102
struct device_attribute;
#line 106
struct inode;
#line 112
struct scsi_device;
#line 122
struct scsi_target;
#line 171
struct scsi_cmnd;
#line 197
struct fc_vport;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_14519_133 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_14521_132 {
   struct __anonstruct_ldv_14519_133 ldv_14519 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_14521_132 ldv_14521 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
struct kernel_param;
#line 53 "include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_14937_138 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14937_138 ldv_14937 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 463
struct tracepoint;
#line 464 "include/linux/moduleparam.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 207
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 214 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 228
struct module_sect_attrs;
#line 228
struct module_notes_attrs;
#line 228
struct ftrace_event_call;
#line 228 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 601
struct klist_node;
#line 602 "include/linux/mod_devicetable.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 59 "include/linux/device.h"
struct driver_attribute;
#line 59 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 141
struct device_type;
#line 198 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 263 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 324
struct class_attribute;
#line 324 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 421 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 477 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 505 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 616 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 625 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 630
struct dma_coherent_mem;
#line 630 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 772 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 180 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 236
struct pcie_link_state;
#line 237
struct pci_vpd;
#line 238
struct pci_sriov;
#line 239
struct pci_ats;
#line 240
struct proc_dir_entry;
#line 240
struct pci_driver;
#line 240 "include/linux/pci.h"
union __anonunion_ldv_16690_142 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 240 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_16690_142 ldv_16690 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 434
struct pci_ops;
#line 434
struct msi_chip;
#line 434 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 526 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 547 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 560 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 570 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 600 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1118 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct dma_pool;
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 60 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 67
struct return_instance;
#line 67
struct uprobe;
#line 67 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct return_instance *return_instances ;
   unsigned int depth ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 83 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 102 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 128
struct address_space;
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_17779_144 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_17789_148 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_17791_147 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_17789_148 ldv_17789 ;
   int units ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_17793_146 {
   union __anonunion_ldv_17791_147 ldv_17791 ;
   atomic_t _count ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_17794_145 {
   unsigned long counters ;
   struct __anonstruct_ldv_17793_146 ldv_17793 ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_17795_143 {
   union __anonunion_ldv_17779_144 ldv_17779 ;
   union __anonunion_ldv_17794_145 ldv_17794 ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_17802_150 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 129
struct slab;
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_17806_149 {
   struct list_head lru ;
   struct __anonstruct_ldv_17802_150 ldv_17802 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_17811_151 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 129 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_17795_143 ldv_17795 ;
   union __anonunion_ldv_17806_149 ldv_17806 ;
   union __anonunion_ldv_17811_151 ldv_17811 ;
   unsigned long debug_flags ;
};
#line 168 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 220 "include/linux/mm_types.h"
struct __anonstruct_linear_153 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 220 "include/linux/mm_types.h"
union __anonunion_shared_152 {
   struct __anonstruct_linear_153 linear ;
   struct list_head nonlinear ;
};
#line 220
struct anon_vma;
#line 220
struct vm_operations_struct;
#line 220
struct mempolicy;
#line 220 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_152 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 292 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 298 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 311 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 324
struct kioctx_table;
#line 325
struct linux_binfmt;
#line 325
struct mmu_notifier_mm;
#line 325 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 171 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 196 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 1836 "include/linux/mm.h"
struct pci_sysdata {
   int domain ;
   int node ;
   void *acpi ;
   void *iommu ;
};
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 350 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct dentry;
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_155 {
   unsigned long sig[1U] ;
};
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_155 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_157 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_158 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_159 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_160 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_161 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_162 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_163 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_156 {
   int _pad[28U] ;
   struct __anonstruct__kill_157 _kill ;
   struct __anonstruct__timer_158 _timer ;
   struct __anonstruct__rt_159 _rt ;
   struct __anonstruct__sigchld_160 _sigchld ;
   struct __anonstruct__sigfault_161 _sigfault ;
   struct __anonstruct__sigpoll_162 _sigpoll ;
   struct __anonstruct__sigsys_163 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_156 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 251 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 265 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 448
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 455
struct pid_namespace;
#line 455 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 441 "include/linux/rculist.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_23135_166 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_23144_167 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_168 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_169 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_23135_166 ldv_23135 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_23144_167 ldv_23144 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_168 type_data ;
   union __anonunion_payload_169 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 344
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 197
struct futex_pi_state;
#line 198
struct robust_list_head;
#line 199
struct bio_list;
#line 200
struct fs_struct;
#line 201
struct perf_event_context;
#line 202
struct blk_plug;
#line 113 "include/linux/sched.h"
struct cfs_rq;
#line 114
struct task_group;
#line 324 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 371 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 379 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 386 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 398 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 418 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 454
struct autogroup;
#line 455
struct tty_struct;
#line 455
struct taskstats;
#line 455
struct tty_audit_buf;
#line 455 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 634 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 678
struct backing_dev_info;
#line 679
struct reclaim_state;
#line 680 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 694 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 877
struct io_context;
#line 905
struct pipe_inode_info;
#line 906
struct uts_namespace;
#line 907 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 913 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 925 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 960 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 991
struct rt_rq;
#line 991 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1015 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1395 "include/linux/sched.h"
struct memcg_oom_info {
   unsigned char may_oom : 1 ;
   unsigned char in_memcg_oom : 1 ;
   unsigned char oom_locked : 1 ;
   int wakeups ;
   struct mem_cgroup *wait_on_memcg ;
};
#line 1403
struct sched_class;
#line 1403
struct files_struct;
#line 1403
struct css_set;
#line 1403
struct compat_robust_list_head;
#line 1403 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 624 "include/linux/interrupt.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 371 "include/scsi/scsi.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 583
struct path;
#line 584 "include/scsi/scsi.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 181
struct request_queue;
#line 182
struct block_device;
#line 183
struct scsi_host_cmd_pool;
#line 184
struct scsi_transport_template;
#line 192
enum blk_eh_timer_return;
#line 192 "include/linux/seq_file.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*transfer_response)(struct scsi_cmnd * , void (*)(struct scsi_cmnd * ) ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  , int  ) ;
   int (*change_queue_type)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
};
#line 520 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 530
struct blk_queue_tag;
#line 530 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   struct blk_queue_tag *bqt ;
   unsigned int host_busy ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int resetting ;
   unsigned long last_reset ;
   unsigned int max_id ;
   unsigned int max_lun ;
   unsigned int max_channel ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char use_blk_tcq : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   unsigned int host_blocked ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 50 "include/linux/genhd.h"
struct hlist_bl_node;
#line 50 "include/linux/genhd.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_27182_176 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_27183_175 {
   struct __anonstruct_ldv_27182_176 ldv_27182 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_27183_175 ldv_27183 ;
};
#line 38 "include/linux/lockref.h"
struct nameidata;
#line 39
struct vfsmount;
#line 40 "include/linux/lockref.h"
struct __anonstruct_ldv_27203_178 {
   u32 hash ;
   u32 len ;
};
#line 40 "include/linux/lockref.h"
union __anonunion_ldv_27205_177 {
   struct __anonstruct_ldv_27203_178 ldv_27203 ;
   u64 hash_len ;
};
#line 40 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_27205_177 ldv_27205 ;
   unsigned char const   *name ;
};
#line 88 "include/linux/dcache.h"
struct dentry_operations;
#line 88
struct super_block;
#line 88 "include/linux/dcache.h"
union __anonunion_d_u_179 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 88 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_179 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 140 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 403 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 26 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 28 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 381 "include/linux/radix-tree.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 27 "include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 30
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 21 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 30 "include/linux/blk_types.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned int bi_phys_segments ;
   unsigned int bi_size ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   struct bio_integrity_payload *bi_integrity ;
   unsigned int bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 57
struct hd_geometry;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct poll_table_struct;
#line 61
struct kstatfs;
#line 62
struct swap_info_struct;
#line 68 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 243 "include/linux/fs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 25 "include/linux/projid.h"
struct __anonstruct_kprojid_t_180 {
   projid_t val ;
};
#line 25 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_180 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_28019_181 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_28019_181 ldv_28019 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
};
#line 333 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 379 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 342 "include/linux/fs.h"
union __anonunion_arg_183 {
   char *buf ;
   void *data ;
};
#line 342 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_182 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_183 arg ;
   int error ;
};
#line 342 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_182 read_descriptor_t;
#line 345 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 405 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 427
struct hd_struct;
#line 427
struct gendisk;
#line 427 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 500
struct posix_acl;
#line 501
struct inode_operations;
#line 501 "include/linux/fs.h"
union __anonunion_ldv_28462_184 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 501 "include/linux/fs.h"
union __anonunion_ldv_28482_185 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 501
struct file_lock;
#line 501
struct cdev;
#line 501 "include/linux/fs.h"
union __anonunion_ldv_28498_186 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 501 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_28462_184 ldv_28462 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_28482_185 ldv_28482 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_28498_186 ldv_28498 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 731 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 739 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 762 "include/linux/fs.h"
union __anonunion_f_u_187 {
   struct list_head fu_list ;
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 762 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_187 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 906 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 907 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 912 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 925
struct net;
#line 930
struct nlm_lockowner;
#line 931 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_189 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_188 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_189 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_188 fl_u ;
};
#line 1033 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1225 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1241
struct file_system_type;
#line 1241
struct super_operations;
#line 1241
struct xattr_handler;
#line 1241
struct mtd_info;
#line 1241 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
};
#line 1475 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1513 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1517
struct block_device_operations;
#line 1518 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1556 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
};
#line 1600 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1814 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 71 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 12 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 29 "include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
   unsigned char for_sync : 1 ;
};
#line 88
struct bdi_writeback;
#line 39 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   struct delayed_work dwork ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 63 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 365 "include/linux/backing-dev.h"
union __anonunion_ldv_31959_190 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 365 "include/linux/backing-dev.h"
union __anonunion_ldv_31963_191 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 365 "include/linux/backing-dev.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_ldv_31959_190 ldv_31959 ;
   union __anonunion_ldv_31963_191 ldv_31963 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 87 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   sector_t bip_sector ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned int bip_size ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_idx ;
   unsigned char bip_owns_buf : 1 ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 399 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 513 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 63 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 25
struct request;
#line 27
struct bsg_job;
#line 28
struct blkcg_gq;
#line 48 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 49 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 68
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 80 "include/linux/blkdev.h"
union __anonunion_ldv_32429_192 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 80 "include/linux/blkdev.h"
struct __anonstruct_elv_194 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 80 "include/linux/blkdev.h"
struct __anonstruct_flush_195 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 80 "include/linux/blkdev.h"
union __anonunion_ldv_32440_193 {
   struct __anonstruct_elv_194 elv ;
   struct __anonstruct_flush_195 flush ;
};
#line 80 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct call_single_data csd ;
   struct request_queue *q ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion_ldv_32429_192 ldv_32429 ;
   union __anonunion_ldv_32440_193 ldv_32440 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   int ref_count ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 72 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 80 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 101 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 218 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 219 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 220 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 221 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 222 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 230 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 232 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 233 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 234 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 235 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 236
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 243 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 249 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 258 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
};
#line 287
struct throtl_data;
#line 287 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   unsigned char flush_queue_delayed : 1 ;
   unsigned char flush_pending_idx : 1 ;
   unsigned char flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2U] ;
   struct list_head flush_data_in_flight ;
   struct request flush_rq ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct list_head all_q_node ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
};
#line 978 "include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head cb_list ;
};
#line 1347 "include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char const   *disk_name ;
};
#line 1379 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1380 "include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1381 "include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1382 "include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1383 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1442 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1532
struct scsi_sense_hdr;
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   unsigned int device_busy ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int lun ;
   unsigned int channel ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char writeable : 1 ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char ordered_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int device_blocked ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 197 "include/scsi/scsi_device.h"
struct scsi_dh_devlist {
   char *vendor ;
   char *model ;
};
#line 204 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   struct scsi_dh_devlist  const  *devlist ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   int (*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 220 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
   char buf[0U] ;
};
#line 227
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 233 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   unsigned int reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   unsigned int target_busy ;
   unsigned int can_queue ;
   unsigned int target_blocked ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   struct execute_work ew ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 519 "include/scsi/scsi_device.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 37 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 53 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   unsigned char tag ;
};
#line 75 "include/linux/random.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 333
enum ldv_25421 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_25421 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   void (*set_peek_off)(struct sock * , int  ) ;
};
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 108 "include/net/checksum.h"
struct sk_buff;
#line 37 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 17 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 117 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 127 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 331 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 332
struct sec_path;
#line 332 "include/linux/skbuff.h"
struct __anonstruct_ldv_35549_201 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 332 "include/linux/skbuff.h"
union __anonunion_ldv_35550_200 {
   __wsum csum ;
   struct __anonstruct_ldv_35549_201 ldv_35549 ;
};
#line 332 "include/linux/skbuff.h"
union __anonunion_ldv_35587_202 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 332 "include/linux/skbuff.h"
union __anonunion_ldv_35593_203 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 332 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   ktime_t tstamp ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_35550_200 ldv_35550 ;
   __u32 priority ;
   unsigned char local_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct sk_buff *nfct_reasm ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 rxhash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_rxhash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   union __anonunion_ldv_35587_202 ldv_35587 ;
   __u32 secmark ;
   union __anonunion_ldv_35593_203 ldv_35593 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 564
struct dst_entry;
#line 632
struct rtable;
#line 105 "include/linux/security.h"
struct xfrm_policy;
#line 106
struct xfrm_state;
#line 124
struct request_sock;
#line 3143
struct mnt_namespace;
#line 3144
struct ipc_namespace;
#line 3145 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 103 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 96 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_netlink.h"
enum fc_port_type {
    FC_PORTTYPE_UNKNOWN = 0,
    FC_PORTTYPE_OTHER = 1,
    FC_PORTTYPE_NOTPRESENT = 2,
    FC_PORTTYPE_NPORT = 3,
    FC_PORTTYPE_NLPORT = 4,
    FC_PORTTYPE_LPORT = 5,
    FC_PORTTYPE_PTP = 6,
    FC_PORTTYPE_NPIV = 7
} ;
#line 107
enum fc_port_state {
    FC_PORTSTATE_UNKNOWN = 0,
    FC_PORTSTATE_NOTPRESENT = 1,
    FC_PORTSTATE_ONLINE = 2,
    FC_PORTSTATE_OFFLINE = 3,
    FC_PORTSTATE_BLOCKED = 4,
    FC_PORTSTATE_BYPASSED = 5,
    FC_PORTSTATE_DIAGNOSTICS = 6,
    FC_PORTSTATE_LINKDOWN = 7,
    FC_PORTSTATE_ERROR = 8,
    FC_PORTSTATE_LOOPBACK = 9,
    FC_PORTSTATE_DELETED = 10
} ;
#line 121
enum fc_vport_state {
    FC_VPORT_UNKNOWN = 0,
    FC_VPORT_ACTIVE = 1,
    FC_VPORT_DISABLED = 2,
    FC_VPORT_LINKDOWN = 3,
    FC_VPORT_INITIALIZING = 4,
    FC_VPORT_NO_FABRIC_SUPP = 5,
    FC_VPORT_NO_FABRIC_RSCS = 6,
    FC_VPORT_FABRIC_LOGOUT = 7,
    FC_VPORT_FABRIC_REJ_WWN = 8,
    FC_VPORT_FAILED = 9
} ;
#line 189 "include/scsi/scsi_transport_fc.h"
struct fc_vport {
   enum fc_vport_state vport_state ;
   enum fc_vport_state vport_last_state ;
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   u32 vport_id ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
   void *dd_data ;
   struct Scsi_Host *shost ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct work_struct vport_delete_work ;
};
#line 288 "include/scsi/scsi_transport_fc.h"
struct fc_rport {
   u32 maxframe_size ;
   u32 supported_classes ;
   u32 dev_loss_tmo ;
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
   enum fc_port_state port_state ;
   u32 scsi_target_id ;
   u32 fast_io_fail_tmo ;
   void *dd_data ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct delayed_work dev_loss_work ;
   struct work_struct scan_work ;
   struct delayed_work fail_io_work ;
   struct work_struct stgt_delete_work ;
   struct work_struct rport_delete_work ;
   struct request_queue *rqst_q ;
};
#line 388 "include/scsi/scsi_transport_fc.h"
struct fc_host_statistics {
   u64 seconds_since_last_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 nos_count ;
   u64 error_frames ;
   u64 dumped_frames ;
   u64 link_failure_count ;
   u64 loss_of_sync_count ;
   u64 loss_of_signal_count ;
   u64 prim_seq_protocol_err_count ;
   u64 invalid_tx_word_count ;
   u64 invalid_crc_count ;
   u64 fcp_input_requests ;
   u64 fcp_output_requests ;
   u64 fcp_control_requests ;
   u64 fcp_input_megabytes ;
   u64 fcp_output_megabytes ;
   u64 fcp_packet_alloc_failures ;
   u64 fcp_packet_aborts ;
   u64 fcp_frame_alloc_failures ;
   u64 fc_no_free_exch ;
   u64 fc_no_free_exch_xid ;
   u64 fc_xid_not_found ;
   u64 fc_xid_busy ;
   u64 fc_seq_not_found ;
   u64 fc_non_bls_resp ;
};
#line 441
enum fc_host_event_code {
    FCH_EVT_LIP = 1,
    FCH_EVT_LINKUP = 2,
    FCH_EVT_LINKDOWN = 3,
    FCH_EVT_LIPRESET = 4,
    FCH_EVT_RSCN = 5,
    FCH_EVT_ADAPTER_CHANGE = 259,
    FCH_EVT_PORT_UNKNOWN = 512,
    FCH_EVT_PORT_OFFLINE = 513,
    FCH_EVT_PORT_ONLINE = 514,
    FCH_EVT_PORT_FABRIC = 516,
    FCH_EVT_LINK_UNKNOWN = 1280,
    FCH_EVT_VENDOR_UNIQUE = 65535
} ;
#line 541 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 626
struct fc_bsg_request;
#line 626
struct fc_bsg_reply;
#line 626 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_job {
   struct Scsi_Host *shost ;
   struct fc_rport *rport ;
   struct device *dev ;
   struct request *req ;
   spinlock_t job_lock ;
   unsigned int state_flags ;
   unsigned int ref_cnt ;
   void (*job_done)(struct fc_bsg_job * ) ;
   struct fc_bsg_request *request ;
   struct fc_bsg_reply *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct fc_bsg_buffer request_payload ;
   struct fc_bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 660 "include/scsi/scsi_transport_fc.h"
struct fc_function_template {
   void (*get_rport_dev_loss_tmo)(struct fc_rport * ) ;
   void (*set_rport_dev_loss_tmo)(struct fc_rport * , u32  ) ;
   void (*get_starget_node_name)(struct scsi_target * ) ;
   void (*get_starget_port_name)(struct scsi_target * ) ;
   void (*get_starget_port_id)(struct scsi_target * ) ;
   void (*get_host_port_id)(struct Scsi_Host * ) ;
   void (*get_host_port_type)(struct Scsi_Host * ) ;
   void (*get_host_port_state)(struct Scsi_Host * ) ;
   void (*get_host_active_fc4s)(struct Scsi_Host * ) ;
   void (*get_host_speed)(struct Scsi_Host * ) ;
   void (*get_host_fabric_name)(struct Scsi_Host * ) ;
   void (*get_host_symbolic_name)(struct Scsi_Host * ) ;
   void (*set_host_system_hostname)(struct Scsi_Host * ) ;
   struct fc_host_statistics *(*get_fc_host_stats)(struct Scsi_Host * ) ;
   void (*reset_fc_host_stats)(struct Scsi_Host * ) ;
   int (*issue_fc_host_lip)(struct Scsi_Host * ) ;
   void (*dev_loss_tmo_callbk)(struct fc_rport * ) ;
   void (*terminate_rport_io)(struct fc_rport * ) ;
   void (*set_vport_symbolic_name)(struct fc_vport * ) ;
   int (*vport_create)(struct fc_vport * , bool  ) ;
   int (*vport_disable)(struct fc_vport * , bool  ) ;
   int (*vport_delete)(struct fc_vport * ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*bsg_request)(struct fc_bsg_job * ) ;
   int (*bsg_timeout)(struct fc_bsg_job * ) ;
   u32 dd_fcrport_size ;
   u32 dd_fcvport_size ;
   u32 dd_bsg_size ;
   unsigned char show_rport_maxframe_size : 1 ;
   unsigned char show_rport_supported_classes : 1 ;
   unsigned char show_rport_dev_loss_tmo : 1 ;
   unsigned char show_starget_node_name : 1 ;
   unsigned char show_starget_port_name : 1 ;
   unsigned char show_starget_port_id : 1 ;
   unsigned char show_host_node_name : 1 ;
   unsigned char show_host_port_name : 1 ;
   unsigned char show_host_permanent_port_name : 1 ;
   unsigned char show_host_supported_classes : 1 ;
   unsigned char show_host_supported_fc4s : 1 ;
   unsigned char show_host_supported_speeds : 1 ;
   unsigned char show_host_maxframe_size : 1 ;
   unsigned char show_host_serial_number : 1 ;
   unsigned char show_host_manufacturer : 1 ;
   unsigned char show_host_model : 1 ;
   unsigned char show_host_model_description : 1 ;
   unsigned char show_host_hardware_version : 1 ;
   unsigned char show_host_driver_version : 1 ;
   unsigned char show_host_firmware_version : 1 ;
   unsigned char show_host_optionrom_version : 1 ;
   unsigned char show_host_port_id : 1 ;
   unsigned char show_host_port_type : 1 ;
   unsigned char show_host_port_state : 1 ;
   unsigned char show_host_active_fc4s : 1 ;
   unsigned char show_host_speed : 1 ;
   unsigned char show_host_fabric_name : 1 ;
   unsigned char show_host_symbolic_name : 1 ;
   unsigned char show_host_system_hostname : 1 ;
   unsigned char disable_target_scan : 1 ;
};
#line 854 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_host_add_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_del_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_els {
   uint8_t command_code ;
   uint8_t port_id[3U] ;
};
#line 133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_rjt_data_204 {
   uint8_t action ;
   uint8_t reason_code ;
   uint8_t reason_explanation ;
   uint8_t vendor_unique ;
};
#line 133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_ctels_reply {
   uint32_t status ;
   struct __anonstruct_rjt_data_204 rjt_data ;
};
#line 178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_ct {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 226 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 233 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_els {
   uint8_t els_code ;
};
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_ct {
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_rqst_data_205 {
   struct fc_bsg_host_add_rport h_addrport ;
   struct fc_bsg_host_del_rport h_delrport ;
   struct fc_bsg_host_els h_els ;
   struct fc_bsg_host_ct h_ct ;
   struct fc_bsg_host_vendor h_vendor ;
   struct fc_bsg_rport_els r_els ;
   struct fc_bsg_rport_ct r_ct ;
};
#line 272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_205 rqst_data ;
};
#line 294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_reply_data_206 {
   struct fc_bsg_host_vendor_reply vendor_reply ;
   struct fc_bsg_ctels_reply ctels_reply ;
};
#line 294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_206 reply_data ;
};
#line 613 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_legacy_intr_set {
   uint32_t int_vec_bit ;
   uint32_t tgt_status_reg ;
   uint32_t tgt_mask_reg ;
   uint32_t pci_int_reg ;
};
#line 815 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct device_reg_82xx {
   uint32_t req_q_out[64U] ;
   uint32_t rsp_q_in[64U] ;
   uint32_t rsp_q_out[64U] ;
   uint16_t mailbox_in[32U] ;
   uint16_t unused_1[32U] ;
   uint32_t hint ;
   uint16_t unused_2[62U] ;
   uint16_t mailbox_out[32U] ;
   uint32_t unused_3[48U] ;
   uint32_t host_status ;
   uint32_t host_int ;
};
#line 865 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct fcp_cmnd {
   struct scsi_lun lun ;
   uint8_t crn ;
   uint8_t task_attribute ;
   uint8_t task_management ;
   uint8_t additional_cdb_len ;
   uint8_t cdb[260U] ;
};
#line 875 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct dsd_dma {
   struct list_head list ;
   dma_addr_t dsd_list_dma ;
   void *dsd_addr ;
};
#line 881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct ct6_dsd {
   uint16_t fcp_cmnd_len ;
   dma_addr_t fcp_cmnd_dma ;
   struct fcp_cmnd *fcp_cmnd ;
   int dsd_use_cnt ;
   struct list_head dsd_list ;
};
#line 1189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla8044_reset_template_hdr {
   uint16_t version ;
   uint16_t signature ;
   uint16_t size ;
   uint16_t entries ;
   uint16_t hdr_size ;
   uint16_t checksum ;
   uint16_t init_seq_offset ;
   uint16_t start_seq_offset ;
};
#line 269 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_reset_template {
   int seq_index ;
   int seq_error ;
   int array_index ;
   uint32_t array[16U] ;
   uint8_t *buff ;
   uint8_t *stop_offset ;
   uint8_t *start_offset ;
   uint8_t *init_offset ;
   struct qla8044_reset_template_hdr *hdr ;
   uint8_t seq_end ;
   uint8_t template_end ;
};
#line 888 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct device_reg_24xx {
   uint32_t flash_addr ;
   uint32_t flash_data ;
   uint32_t ctrl_status ;
   uint32_t ictrl ;
   uint32_t istatus ;
   uint32_t unused_1[2U] ;
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t preq_q_in ;
   uint32_t preq_q_out ;
   uint32_t unused_2[2U] ;
   uint32_t atio_q_in ;
   uint32_t atio_q_out ;
   uint32_t host_status ;
   uint32_t hccr ;
   uint32_t gpiod ;
   uint32_t gpioe ;
   uint32_t iobase_addr ;
   uint32_t unused_3[10U] ;
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
   uint16_t mailbox24 ;
   uint16_t mailbox25 ;
   uint16_t mailbox26 ;
   uint16_t mailbox27 ;
   uint16_t mailbox28 ;
   uint16_t mailbox29 ;
   uint16_t mailbox30 ;
   uint16_t mailbox31 ;
   uint32_t iobase_window ;
   uint32_t iobase_c4 ;
   uint32_t iobase_c8 ;
   uint32_t unused_4_1[6U] ;
   uint32_t iobase_q ;
   uint32_t unused_5[2U] ;
   uint32_t iobase_select ;
   uint32_t unused_6[2U] ;
   uint32_t iobase_sdata ;
};
#line 1412 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_npiv_entry {
   uint16_t flags ;
   uint16_t vf_id ;
   uint8_t q_qos ;
   uint8_t f_qos ;
   uint16_t unused1 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
};
#line 1864 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct ex_init_cb_81xx {
   uint16_t ex_version ;
   uint8_t prio_fcf_matching_flags ;
   uint8_t reserved_1[3U] ;
   uint16_t pri_fcf_vlan_id ;
   uint8_t pri_fcf_fabric_name[8U] ;
   uint16_t reserved_2[7U] ;
   uint8_t spma_mac_addr[6U] ;
   uint16_t reserved_3[14U] ;
};
#line 1875 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fcp_prio_entry {
   uint16_t flags ;
   uint8_t tag ;
   uint8_t reserved ;
   uint32_t src_pid ;
   uint32_t dst_pid ;
   uint16_t lun_beg ;
   uint16_t lun_end ;
   uint8_t src_wwpn[8U] ;
   uint8_t dst_wwpn[8U] ;
};
#line 1910 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fcp_prio_cfg {
   uint8_t signature[4U] ;
   uint16_t version ;
   uint16_t length ;
   uint16_t checksum ;
   uint16_t num_entries ;
   uint16_t size_of_entry ;
   uint8_t attributes ;
   uint8_t reserved ;
   struct qla_fcp_prio_entry entry[1U] ;
};
#line 1926
struct req_que;
#line 281 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb_cmd {
   struct scsi_cmnd *cmd ;
   uint32_t request_sense_length ;
   uint32_t fw_sense_length ;
   uint8_t *request_sense_ptr ;
   void *ctx ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_logio_230 {
   uint16_t flags ;
   uint16_t data[2U] ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_tmf_231 {
   uint32_t flags ;
   uint32_t lun ;
   uint32_t data ;
   struct completion comp ;
   __le16 comp_status ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_fxiocb_232 {
   uint8_t flags ;
   uint32_t req_len ;
   uint32_t rsp_len ;
   void *req_addr ;
   void *rsp_addr ;
   dma_addr_t req_dma_handle ;
   dma_addr_t rsp_dma_handle ;
   __le32 adapter_id ;
   __le32 adapter_id_hi ;
   __le16 req_func_type ;
   __le32 req_data ;
   __le32 req_data_extra ;
   __le32 result ;
   __le32 seq_number ;
   __le16 fw_flags ;
   struct completion fxiocb_comp ;
   __le32 reserved_0 ;
   uint8_t reserved_1 ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_abt_233 {
   uint32_t cmd_hndl ;
   __le16 comp_status ;
   struct completion comp ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_229 {
   struct __anonstruct_logio_230 logio ;
   struct __anonstruct_tmf_231 tmf ;
   struct __anonstruct_fxiocb_232 fxiocb ;
   struct __anonstruct_abt_233 abt ;
};
#line 292 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb_iocb {
   union __anonunion_u_229 u ;
   struct timer_list timer ;
   void (*timeout)(void * ) ;
};
#line 364 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_234 {
   struct srb_iocb iocb_cmd ;
   struct fc_bsg_job *bsg_job ;
   struct srb_cmd scmd ;
};
#line 364 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct srb {
   atomic_t ref_count ;
   struct fc_port *fcport ;
   uint32_t handle ;
   uint16_t flags ;
   uint16_t type ;
   char *name ;
   int iocbs ;
   union __anonunion_u_234 u ;
   void (*done)(void * , void * , int  ) ;
   void (*free)(void * , void * ) ;
};
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct srb srb_t;
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2100_236 {
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t unused_2[59U] ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2300_237 {
   uint16_t req_q_in ;
   uint16_t req_q_out ;
   uint16_t rsp_q_in ;
   uint16_t rsp_q_out ;
   uint32_t host_status ;
   uint16_t host_semaphore ;
   uint16_t unused_3[17U] ;
   uint16_t mailbox0 ;
   uint16_t mailbox1 ;
   uint16_t mailbox2 ;
   uint16_t mailbox3 ;
   uint16_t mailbox4 ;
   uint16_t mailbox5 ;
   uint16_t mailbox6 ;
   uint16_t mailbox7 ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
   uint16_t mailbox24 ;
   uint16_t mailbox25 ;
   uint16_t mailbox26 ;
   uint16_t mailbox27 ;
   uint16_t mailbox28 ;
   uint16_t mailbox29 ;
   uint16_t mailbox30 ;
   uint16_t mailbox31 ;
   uint16_t fb_cmd ;
   uint16_t unused_4[10U] ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_235 {
   struct __anonstruct_isp2100_236 isp2100 ;
   struct __anonstruct_isp2300_237 isp2300 ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_isp2200_239 {
   uint16_t unused_10[8U] ;
   uint16_t mailbox8 ;
   uint16_t mailbox9 ;
   uint16_t mailbox10 ;
   uint16_t mailbox11 ;
   uint16_t mailbox12 ;
   uint16_t mailbox13 ;
   uint16_t mailbox14 ;
   uint16_t mailbox15 ;
   uint16_t mailbox16 ;
   uint16_t mailbox17 ;
   uint16_t mailbox18 ;
   uint16_t mailbox19 ;
   uint16_t mailbox20 ;
   uint16_t mailbox21 ;
   uint16_t mailbox22 ;
   uint16_t mailbox23 ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_end_238 {
   struct __anonstruct_isp2200_239 isp2200 ;
};
#line 423 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_2xxx {
   uint16_t flash_address ;
   uint16_t flash_data ;
   uint16_t unused_1[1U] ;
   uint16_t ctrl_status ;
   uint16_t ictrl ;
   uint16_t istatus ;
   uint16_t semaphore ;
   uint16_t nvram ;
   union __anonunion_u_235 u ;
   uint16_t fpm_diag_config ;
   uint16_t unused_5[4U] ;
   uint16_t risc_hw ;
   uint16_t unused_5_1 ;
   uint16_t pcr ;
   uint16_t unused_6[5U] ;
   uint16_t mctr ;
   uint16_t unused_7[3U] ;
   uint16_t fb_cmd_2100 ;
   uint16_t unused_8[3U] ;
   uint16_t hccr ;
   uint16_t unused_9[5U] ;
   uint16_t gpiod ;
   uint16_t gpioe ;
   union __anonunion_u_end_238 u_end ;
};
#line 578 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_25xxmq {
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t atio_q_in ;
   uint32_t atio_q_out ;
};
#line 587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct device_reg_fx00 {
   uint32_t mailbox0 ;
   uint32_t mailbox1 ;
   uint32_t mailbox2 ;
   uint32_t mailbox3 ;
   uint32_t mailbox4 ;
   uint32_t mailbox5 ;
   uint32_t mailbox6 ;
   uint32_t mailbox7 ;
   uint32_t mailbox8 ;
   uint32_t mailbox9 ;
   uint32_t mailbox10 ;
   uint32_t mailbox11 ;
   uint32_t mailbox12 ;
   uint32_t mailbox13 ;
   uint32_t mailbox14 ;
   uint32_t mailbox15 ;
   uint32_t mailbox16 ;
   uint32_t mailbox17 ;
   uint32_t mailbox18 ;
   uint32_t mailbox19 ;
   uint32_t mailbox20 ;
   uint32_t mailbox21 ;
   uint32_t mailbox22 ;
   uint32_t mailbox23 ;
   uint32_t mailbox24 ;
   uint32_t mailbox25 ;
   uint32_t mailbox26 ;
   uint32_t mailbox27 ;
   uint32_t mailbox28 ;
   uint32_t mailbox29 ;
   uint32_t mailbox30 ;
   uint32_t mailbox31 ;
   uint32_t aenmailbox0 ;
   uint32_t aenmailbox1 ;
   uint32_t aenmailbox2 ;
   uint32_t aenmailbox3 ;
   uint32_t aenmailbox4 ;
   uint32_t aenmailbox5 ;
   uint32_t aenmailbox6 ;
   uint32_t aenmailbox7 ;
   uint32_t req_q_in ;
   uint32_t req_q_out ;
   uint32_t rsp_q_in ;
   uint32_t rsp_q_out ;
   uint32_t initval0 ;
   uint32_t initval1 ;
   uint32_t initval2 ;
   uint32_t initval3 ;
   uint32_t initval4 ;
   uint32_t initval5 ;
   uint32_t initval6 ;
   uint32_t initval7 ;
   uint32_t fwheartbeat ;
   uint32_t pseudoaen ;
};
#line 657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_device_reg_t_240 {
   struct device_reg_2xxx isp ;
   struct device_reg_24xx isp24 ;
   struct device_reg_25xxmq isp25mq ;
   struct device_reg_82xx isp82 ;
   struct device_reg_fx00 ispfx00 ;
};
#line 657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_device_reg_t_240 device_reg_t;
#line 710 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_mbx_cmd_t_241 {
   uint32_t out_mb ;
   uint32_t in_mb ;
   uint16_t mb[32U] ;
   long buf_size ;
   void *bufp ;
   uint32_t tov ;
   uint8_t flags ;
};
#line 710 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_mbx_cmd_t_241 mbx_cmd_t;
#line 708 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct mbx_cmd_32 {
   uint32_t out_mb ;
   uint32_t in_mb ;
   uint32_t mb[32U] ;
   long buf_size ;
   void *bufp ;
   uint32_t tov ;
   uint8_t flags ;
};
#line 1197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_init_cb_t_243 {
   uint8_t version ;
   uint8_t reserved_1 ;
   uint8_t firmware_options[2U] ;
   uint16_t frame_payload_size ;
   uint16_t max_iocb_allocation ;
   uint16_t execution_throttle ;
   uint8_t retry_count ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint16_t hard_address ;
   uint8_t inquiry_data ;
   uint8_t login_timeout ;
   uint8_t node_name[8U] ;
   uint16_t request_q_outpointer ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_length ;
   uint16_t response_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint16_t lun_enables ;
   uint8_t command_resource_count ;
   uint8_t immediate_notify_resource_count ;
   uint16_t timeout ;
   uint8_t reserved_2[2U] ;
   uint8_t add_firmware_options[2U] ;
   uint8_t response_accumulation_timer ;
   uint8_t interrupt_delay_timer ;
   uint8_t special_options[2U] ;
   uint8_t reserved_3[26U] ;
};
#line 1197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_init_cb_t_243 init_cb_t;
#line 1511 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_response_t_245 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint8_t data[52U] ;
   uint32_t signature ;
};
#line 1511 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_response_t_245 response_t;
#line 1511 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct atio {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t data[58U] ;
   uint32_t signature ;
};
#line 1530 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_id_247 {
   uint8_t reserved ;
   uint8_t standard ;
};
#line 1530 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_target_id_t_246 {
   uint16_t extended ;
   struct __anonstruct_id_247 id ;
};
#line 1530 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_target_id_t_246 target_id_t;
#line 1569 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cmd_entry_t_248 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t lun ;
   uint16_t control_flags ;
   uint16_t reserved_1 ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t scsi_cdb[16U] ;
   uint32_t byte_count ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
};
#line 1569 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cmd_entry_t_248 cmd_entry_t;
#line 1593 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_request_t_250 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t lun ;
   uint16_t control_flags ;
   uint16_t reserved_1 ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t scsi_cdb[16U] ;
   uint32_t byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_length ;
};
#line 1593 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_request_t_250 request_t;
#line 1641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_nobundling_254 {
   uint32_t reserved_1 ;
   uint16_t reserved_2 ;
   uint16_t reserved_3 ;
   uint32_t reserved_4 ;
   uint32_t data_address[2U] ;
   uint32_t data_length ;
   uint32_t reserved_5[2U] ;
   uint32_t reserved_6 ;
};
#line 1641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_bundling_255 {
   uint32_t dif_byte_count ;
   uint16_t reserved_1 ;
   uint16_t dseg_count ;
   uint32_t reserved_2 ;
   uint32_t data_address[2U] ;
   uint32_t data_length ;
   uint32_t dif_address[2U] ;
   uint32_t dif_length ;
};
#line 1641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_253 {
   struct __anonstruct_nobundling_254 nobundling ;
   struct __anonstruct_bundling_255 bundling ;
};
#line 1641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct crc_context {
   uint32_t handle ;
   uint32_t ref_tag ;
   uint16_t app_tag ;
   uint8_t ref_tag_mask[4U] ;
   uint8_t app_tag_mask[2U] ;
   uint16_t guard_seed ;
   uint16_t prot_opts ;
   uint16_t blk_size ;
   uint16_t runt_blk_guard ;
   uint32_t byte_count ;
   union __anonunion_u_253 u ;
   struct fcp_cmnd fcp_cmnd ;
   dma_addr_t crc_ctx_dma ;
   struct list_head dsd_list ;
};
#line 1881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ms_iocb_entry_t_261 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle1 ;
   target_id_t loop_id ;
   uint16_t status ;
   uint16_t control_flags ;
   uint16_t reserved2 ;
   uint16_t timeout ;
   uint16_t cmd_dsd_count ;
   uint16_t total_dsd_count ;
   uint8_t type ;
   uint8_t r_ctl ;
   uint16_t rx_id ;
   uint16_t reserved3 ;
   uint32_t handle2 ;
   uint32_t rsp_bytecount ;
   uint32_t req_bytecount ;
   uint32_t dseg_req_address[2U] ;
   uint32_t dseg_req_length ;
   uint32_t dseg_rsp_address[2U] ;
   uint32_t dseg_rsp_length ;
};
#line 1881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_ms_iocb_entry_t_261 ms_iocb_entry_t;
#line 1952 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_b_263 {
   uint8_t al_pa ;
   uint8_t area ;
   uint8_t domain ;
   uint8_t rsvd_1 ;
};
#line 1952 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_port_id_t_262 {
   unsigned int b24 : 24 ;
   struct __anonstruct_b_263 b ;
};
#line 1952 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef union __anonunion_port_id_t_262 port_id_t;
#line 1966
enum ldv_28399 {
    FCT_UNKNOWN = 0,
    FCT_RSCN = 1,
    FCT_SWITCH = 2,
    FCT_BROADCAST = 3,
    FCT_INITIATOR = 4,
    FCT_TARGET = 5
} ;
#line 1982 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef enum ldv_28399 fc_port_type_t;
#line 1983 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct fc_port {
   struct list_head list ;
   struct scsi_qla_host *vha ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   port_id_t d_id ;
   uint16_t loop_id ;
   uint16_t old_loop_id ;
   uint16_t tgt_id ;
   uint16_t old_tgt_id ;
   uint8_t fcp_prio ;
   uint8_t fabric_port_name[8U] ;
   uint16_t fp_speed ;
   fc_port_type_t port_type ;
   atomic_t state ;
   uint32_t flags ;
   int login_retry ;
   struct fc_rport *rport ;
   struct fc_rport *drport ;
   u32 supported_classes ;
   uint8_t fc4_type ;
   uint8_t scan_state ;
   unsigned long last_queue_full ;
   unsigned long last_ramp_up ;
   uint16_t port_id ;
};
#line 2022 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct fc_port fc_port_t;
#line 470 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct mr_data_fx00 {
   uint8_t product_name[256U] ;
   uint8_t symbolic_name[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t hw_version[16U] ;
   uint8_t fw_version[16U] ;
   uint8_t uboot_version[16U] ;
   uint8_t fru_serial_num[32U] ;
   fc_port_t fcport ;
   uint8_t fw_hbt_en ;
   uint8_t fw_hbt_cnt ;
   uint8_t fw_hbt_miss_cnt ;
   uint32_t old_fw_hbt_cnt ;
   uint16_t fw_reset_timer_tick ;
   uint8_t fw_reset_timer_exp ;
   uint16_t fw_critemp_timer_tick ;
   uint32_t old_aenmbx0_state ;
   uint32_t critical_temperature ;
   bool extended_io_enabled ;
};
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_265 {
   uint8_t node_name[8U] ;
   uint8_t manufacturer[32U] ;
   uint8_t serial_num[8U] ;
   uint8_t model[16U] ;
   uint8_t model_desc[80U] ;
   uint8_t hw_version[16U] ;
   uint8_t driver_version[32U] ;
   uint8_t orom_version[16U] ;
   uint8_t fw_version[16U] ;
   uint8_t os_version[128U] ;
   uint8_t max_ct_len[4U] ;
};
#line 2041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_hba_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_265 a ;
};
#line 2151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_hba_attributes {
   uint32_t count ;
   struct ct_fdmi_hba_attr entry[9U] ;
};
#line 2156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_a_266 {
   uint8_t fc4_types[32U] ;
   uint32_t sup_speed ;
   uint32_t cur_speed ;
   uint32_t max_frame_size ;
   uint8_t os_dev_name[32U] ;
   uint8_t host_name[32U] ;
};
#line 2156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_port_attr {
   uint16_t type ;
   uint16_t len ;
   union __anonunion_a_266 a ;
};
#line 2188 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_fdmi_port_attributes {
   uint32_t count ;
   struct ct_fdmi_port_attr entry[6U] ;
};
#line 2196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_cmd_hdr {
   uint8_t revision ;
   uint8_t in_id[3U] ;
   uint8_t gs_type ;
   uint8_t gs_subtype ;
   uint8_t options ;
   uint8_t reserved ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_port_id_268 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gid_pt_269 {
   uint8_t port_type ;
   uint8_t domain ;
   uint8_t area ;
   uint8_t reserved ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rft_id_270 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint8_t fc4_types[32U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rff_id_271 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint16_t reserved2 ;
   uint8_t fc4_feature ;
   uint8_t fc4_type ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rnn_id_272 {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint8_t node_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rsnn_nn_273 {
   uint8_t node_name[8U] ;
   uint8_t name_len ;
   uint8_t sym_node_name[255U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ghat_274 {
   uint8_t hba_indentifier[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rhba_275 {
   uint8_t hba_identifier[8U] ;
   uint32_t entry_count ;
   uint8_t port_name[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rhat_276 {
   uint8_t hba_identifier[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_rpa_277 {
   uint8_t port_name[8U] ;
   struct ct_fdmi_port_attributes attrs ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dhba_278 {
   uint8_t port_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dhat_279 {
   uint8_t port_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dprt_280 {
   uint8_t port_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_dpa_281 {
   uint8_t port_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpsc_282 {
   uint8_t port_name[8U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gff_id_283 {
   uint8_t reserved ;
   uint8_t port_name[3U] ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_req_267 {
   struct __anonstruct_port_id_268 port_id ;
   struct __anonstruct_gid_pt_269 gid_pt ;
   struct __anonstruct_rft_id_270 rft_id ;
   struct __anonstruct_rff_id_271 rff_id ;
   struct __anonstruct_rnn_id_272 rnn_id ;
   struct __anonstruct_rsnn_nn_273 rsnn_nn ;
   struct __anonstruct_ghat_274 ghat ;
   struct __anonstruct_rhba_275 rhba ;
   struct __anonstruct_rhat_276 rhat ;
   struct __anonstruct_rpa_277 rpa ;
   struct __anonstruct_dhba_278 dhba ;
   struct __anonstruct_dhat_279 dhat ;
   struct __anonstruct_dprt_280 dprt ;
   struct __anonstruct_dpa_281 dpa ;
   struct __anonstruct_gpsc_282 gpsc ;
   struct __anonstruct_gff_id_283 gff_id ;
};
#line 2229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_req {
   struct ct_cmd_hdr header ;
   uint16_t command ;
   uint16_t max_rsp_size ;
   uint8_t fragment_id ;
   uint8_t reserved[3U] ;
   union __anonunion_req_267 req ;
};
#line 2325 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_rsp_hdr {
   struct ct_cmd_hdr header ;
   uint16_t response ;
   uint16_t residual ;
   uint8_t fragment_id ;
   uint8_t reason_code ;
   uint8_t explanation_code ;
   uint8_t vendor_unique ;
};
#line 2336 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_gid_pt_data {
   uint8_t control_byte ;
   uint8_t port_id[3U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ga_nxt_285 {
   uint8_t port_type ;
   uint8_t port_id[3U] ;
   uint8_t port_name[8U] ;
   uint8_t sym_port_name_len ;
   uint8_t sym_port_name[255U] ;
   uint8_t node_name[8U] ;
   uint8_t sym_node_name_len ;
   uint8_t sym_node_name[255U] ;
   uint8_t init_proc_assoc[8U] ;
   uint8_t node_ip_addr[16U] ;
   uint8_t class_of_service[4U] ;
   uint8_t fc4_types[32U] ;
   uint8_t ip_address[16U] ;
   uint8_t fabric_port_name[8U] ;
   uint8_t reserved ;
   uint8_t hard_address[3U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gid_pt_286 {
   struct ct_sns_gid_pt_data entries[2048U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpn_id_287 {
   uint8_t port_name[8U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gnn_id_288 {
   uint8_t node_name[8U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gft_id_289 {
   uint8_t fc4_types[32U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_ghat_290 {
   uint32_t entry_count ;
   uint8_t port_name[8U] ;
   struct ct_fdmi_hba_attributes attrs ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gfpn_id_291 {
   uint8_t port_name[8U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gpsc_292 {
   uint16_t speeds ;
   uint16_t speed ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_gff_id_293 {
   uint8_t fc4_features[128U] ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_rsp_284 {
   struct __anonstruct_ga_nxt_285 ga_nxt ;
   struct __anonstruct_gid_pt_286 gid_pt ;
   struct __anonstruct_gpn_id_287 gpn_id ;
   struct __anonstruct_gnn_id_288 gnn_id ;
   struct __anonstruct_gft_id_289 gft_id ;
   struct __anonstruct_ghat_290 ghat ;
   struct __anonstruct_gfpn_id_291 gfpn_id ;
   struct __anonstruct_gpsc_292 gpsc ;
   struct __anonstruct_gff_id_293 gff_id ;
};
#line 2341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_rsp {
   struct ct_rsp_hdr header ;
   union __anonunion_rsp_284 rsp ;
};
#line 2404 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_p_294 {
   struct ct_sns_req req ;
   struct ct_sns_rsp rsp ;
};
#line 2404 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct ct_sns_pkt {
   union __anonunion_p_294 p ;
};
#line 2411 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cmd_296 {
   uint16_t buffer_length ;
   uint16_t reserved_1 ;
   uint32_t buffer_address[2U] ;
   uint16_t subcommand_length ;
   uint16_t reserved_2 ;
   uint16_t subcommand ;
   uint16_t size ;
   uint32_t reserved_3 ;
   uint8_t param[36U] ;
};
#line 2411 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_p_295 {
   struct __anonstruct_cmd_296 cmd ;
   uint8_t rft_data[16U] ;
   uint8_t rnn_data[16U] ;
   uint8_t gan_data[636U] ;
   uint8_t gid_data[2064U] ;
   uint8_t gpn_data[24U] ;
   uint8_t gnn_data[24U] ;
};
#line 2411 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct sns_cmd_pkt {
   union __anonunion_p_295 p ;
};
#line 2465 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct fw_blob {
   char *name ;
   uint32_t segs[4U] ;
   struct firmware  const  *fw ;
};
#line 2471 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct gid_list_info {
   uint8_t al_pa ;
   uint8_t area ;
   uint8_t domain ;
   uint8_t loop_id_2100 ;
   uint16_t loop_id ;
   uint16_t reserved_1 ;
};
#line 2500
struct rsp_que;
#line 2501 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct isp_operations {
   int (*pci_config)(struct scsi_qla_host * ) ;
   void (*reset_chip)(struct scsi_qla_host * ) ;
   int (*chip_diag)(struct scsi_qla_host * ) ;
   void (*config_rings)(struct scsi_qla_host * ) ;
   void (*reset_adapter)(struct scsi_qla_host * ) ;
   int (*nvram_config)(struct scsi_qla_host * ) ;
   void (*update_fw_options)(struct scsi_qla_host * ) ;
   int (*load_risc)(struct scsi_qla_host * , uint32_t * ) ;
   char *(*pci_info_str)(struct scsi_qla_host * , char * ) ;
   char *(*fw_version_str)(struct scsi_qla_host * , char * ) ;
   irqreturn_t (*intr_handler)(int  , void * ) ;
   void (*enable_intrs)(struct qla_hw_data * ) ;
   void (*disable_intrs)(struct qla_hw_data * ) ;
   int (*abort_command)(srb_t * ) ;
   int (*target_reset)(struct fc_port * , unsigned int  , int  ) ;
   int (*lun_reset)(struct fc_port * , unsigned int  , int  ) ;
   int (*fabric_login)(struct scsi_qla_host * , uint16_t  , uint8_t  , uint8_t  ,
                       uint8_t  , uint16_t * , uint8_t  ) ;
   int (*fabric_logout)(struct scsi_qla_host * , uint16_t  , uint8_t  , uint8_t  ,
                        uint8_t  ) ;
   uint16_t (*calc_req_entries)(uint16_t  ) ;
   void (*build_iocbs)(srb_t * , cmd_entry_t * , uint16_t  ) ;
   void *(*prep_ms_iocb)(struct scsi_qla_host * , uint32_t  , uint32_t  ) ;
   void *(*prep_ms_fdmi_iocb)(struct scsi_qla_host * , uint32_t  , uint32_t  ) ;
   uint8_t *(*read_nvram)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*write_nvram)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   void (*fw_dump)(struct scsi_qla_host * , int  ) ;
   int (*beacon_on)(struct scsi_qla_host * ) ;
   int (*beacon_off)(struct scsi_qla_host * ) ;
   void (*beacon_blink)(struct scsi_qla_host * ) ;
   uint8_t *(*read_optrom)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*write_optrom)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ) ;
   int (*get_flash_version)(struct scsi_qla_host * , void * ) ;
   int (*start_scsi)(srb_t * ) ;
   int (*abort_isp)(struct scsi_qla_host * ) ;
   int (*iospace_config)(struct qla_hw_data * ) ;
   int (*initialize_adapter)(struct scsi_qla_host * ) ;
};
#line 2569 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_msix_entry {
   int have_irq ;
   uint32_t vector ;
   uint16_t entry ;
   struct rsp_que *rsp ;
};
#line 2592
enum qla_work_type {
    QLA_EVT_AEN = 0,
    QLA_EVT_IDC_ACK = 1,
    QLA_EVT_ASYNC_LOGIN = 2,
    QLA_EVT_ASYNC_LOGIN_DONE = 3,
    QLA_EVT_ASYNC_LOGOUT = 4,
    QLA_EVT_ASYNC_LOGOUT_DONE = 5,
    QLA_EVT_ASYNC_ADISC = 6,
    QLA_EVT_ASYNC_ADISC_DONE = 7,
    QLA_EVT_UEVENT = 8,
    QLA_EVT_AENFX = 9
} ;
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_aen_298 {
   enum fc_host_event_code code ;
   u32 data ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_idc_ack_299 {
   uint16_t mb[7U] ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_logio_300 {
   struct fc_port *fcport ;
   u16 data[2U] ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_uevent_301 {
   u32 code ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_aenfx_302 {
   uint32_t evtcode ;
   uint32_t mbx[8U] ;
   uint32_t count ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_iosb_303 {
   srb_t *sp ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
union __anonunion_u_297 {
   struct __anonstruct_aen_298 aen ;
   struct __anonstruct_idc_ack_299 idc_ack ;
   struct __anonstruct_logio_300 logio ;
   struct __anonstruct_uevent_301 uevent ;
   struct __anonstruct_aenfx_302 aenfx ;
   struct __anonstruct_iosb_303 iosb ;
};
#line 2605 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_work_evt {
   struct list_head list ;
   enum qla_work_type type ;
   u32 flags ;
   union __anonunion_u_297 u ;
};
#line 2644 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_chip_state_84xx {
   struct list_head list ;
   struct kref kref ;
   void *bus ;
   spinlock_t access_lock ;
   struct mutex fw_update_mutex ;
   uint32_t fw_update ;
   uint32_t op_fw_version ;
   uint32_t op_fw_size ;
   uint32_t op_fw_seq_size ;
   uint32_t diag_fw_version ;
   uint32_t gold_fw_version ;
};
#line 2659 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_statistics {
   uint32_t total_isp_aborts ;
   uint64_t input_bytes ;
   uint64_t output_bytes ;
   uint64_t input_requests ;
   uint64_t output_requests ;
   uint32_t control_requests ;
   uint64_t jiffies_at_last_reset ;
};
#line 2670 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct bidi_statistics {
   unsigned long long io_count ;
   unsigned long long transfer_bytes ;
};
#line 2675 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct rsp_que {
   dma_addr_t dma ;
   response_t *ring ;
   response_t *ring_ptr ;
   uint32_t *rsp_q_in ;
   uint32_t *rsp_q_out ;
   uint16_t ring_index ;
   uint16_t out_ptr ;
   uint16_t length ;
   uint16_t options ;
   uint16_t rid ;
   uint16_t id ;
   uint16_t vp_idx ;
   struct qla_hw_data *hw ;
   struct qla_msix_entry *msix ;
   struct req_que *req ;
   srb_t *status_srb ;
   struct work_struct q_work ;
   dma_addr_t dma_fx00 ;
   response_t *ring_fx00 ;
   uint16_t length_fx00 ;
   uint8_t rsp_pkt[64U] ;
};
#line 2716 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct req_que {
   dma_addr_t dma ;
   request_t *ring ;
   request_t *ring_ptr ;
   uint32_t *req_q_in ;
   uint32_t *req_q_out ;
   uint16_t ring_index ;
   uint16_t in_ptr ;
   uint16_t cnt ;
   uint16_t length ;
   uint16_t options ;
   uint16_t rid ;
   uint16_t id ;
   uint16_t qos ;
   uint16_t vp_idx ;
   struct rsp_que *rsp ;
   srb_t **outstanding_cmds ;
   uint32_t current_outstanding_cmd ;
   uint16_t num_outstanding_cmds ;
   int max_q_depth ;
   dma_addr_t dma_fx00 ;
   request_t *ring_fx00 ;
   uint16_t length_fx00 ;
   uint8_t req_pkt[64U] ;
};
#line 2745 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qlfc_fw {
   void *fw_buf ;
   dma_addr_t fw_dma ;
   uint32_t len ;
};
#line 2752
struct qla_tgt_func_tmpl;
#line 2752
struct qla_tgt;
#line 2752
struct qla_tgt_cmd;
#line 2752
struct qla_tgt_vp_map;
#line 2752 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qlt_hw_data {
   unsigned char enable_class_2 : 1 ;
   unsigned char enable_explicit_conf : 1 ;
   unsigned char ini_mode_force_reverse : 1 ;
   unsigned char node_name_set : 1 ;
   dma_addr_t atio_dma ;
   struct atio *atio_ring ;
   struct atio *atio_ring_ptr ;
   uint16_t atio_ring_index ;
   uint16_t atio_q_length ;
   uint32_t *atio_q_in ;
   uint32_t *atio_q_out ;
   void *target_lport_ptr ;
   struct qla_tgt_func_tmpl *tgt_ops ;
   struct qla_tgt *qla_tgt ;
   struct qla_tgt_cmd *cmds[1024U] ;
   uint16_t current_handle ;
   struct qla_tgt_vp_map *tgt_vp_map ;
   struct mutex tgt_mutex ;
   struct mutex tgt_host_action_mutex ;
   int saved_set ;
   uint16_t saved_exchange_count ;
   uint32_t saved_firmware_options_1 ;
   uint32_t saved_firmware_options_2 ;
   uint32_t saved_firmware_options_3 ;
   uint8_t saved_firmware_options[2U] ;
   uint8_t saved_add_firmware_options[2U] ;
   uint8_t tgt_node_name[8U] ;
};
#line 2788 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_flags_304 {
   unsigned char mbox_int : 1 ;
   unsigned char mbox_busy : 1 ;
   unsigned char disable_risc_code_load : 1 ;
   unsigned char enable_64bit_addressing : 1 ;
   unsigned char enable_lip_reset : 1 ;
   unsigned char enable_target_reset : 1 ;
   unsigned char enable_lip_full_login : 1 ;
   unsigned char enable_led_scheme : 1 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char disable_serdes : 1 ;
   unsigned char gpsc_supported : 1 ;
   unsigned char npiv_supported : 1 ;
   unsigned char pci_channel_io_perm_failure : 1 ;
   unsigned char fce_enabled : 1 ;
   unsigned char fac_supported : 1 ;
   unsigned char chip_reset_done : 1 ;
   unsigned char port0 : 1 ;
   unsigned char running_gold_fw : 1 ;
   unsigned char eeh_busy : 1 ;
   unsigned char cpu_affinity_enabled : 1 ;
   unsigned char disable_msix_handshake : 1 ;
   unsigned char fcp_prio_enabled : 1 ;
   unsigned char isp82xx_fw_hung : 1 ;
   unsigned char nic_core_hung : 1 ;
   unsigned char quiesce_owner : 1 ;
   unsigned char nic_core_reset_hdlr_active : 1 ;
   unsigned char nic_core_reset_owner : 1 ;
   unsigned char isp82xx_no_md_cap : 1 ;
   unsigned char host_shutting_down : 1 ;
   unsigned char idc_compl_status : 1 ;
   unsigned char mr_reset_hdlr_active : 1 ;
   unsigned char mr_intr_valid : 1 ;
};
#line 2788
struct qla2xxx_fw_dump;
#line 2788 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_hw_data {
   struct pci_dev *pdev ;
   mempool_t *srb_mempool ;
   struct __anonstruct_flags_304  volatile  flags ;
   spinlock_t hardware_lock ;
   int bars ;
   int mem_only ;
   device_reg_t *iobase ;
   resource_size_t pio_address ;
   dma_addr_t bar0_hdl ;
   void *cregbase ;
   dma_addr_t bar2_hdl ;
   uint32_t rqstq_intr_code ;
   uint32_t mbx_intr_code ;
   uint32_t req_que_len ;
   uint32_t rsp_que_len ;
   uint32_t req_que_off ;
   uint32_t rsp_que_off ;
   device_reg_t *mqiobase ;
   device_reg_t *msixbase ;
   uint16_t msix_count ;
   uint8_t mqenable ;
   struct req_que **req_q_map ;
   struct rsp_que **rsp_q_map ;
   unsigned long req_qid_map[4U] ;
   unsigned long rsp_qid_map[4U] ;
   uint8_t max_req_queues ;
   uint8_t max_rsp_queues ;
   struct qla_npiv_entry *npiv_info ;
   uint16_t nvram_npiv_size ;
   uint16_t switch_cap ;
   uint8_t port_no ;
   uint8_t loop_down_abort_time ;
   atomic_t loop_down_timer ;
   uint8_t link_down_timeout ;
   uint16_t max_loop_id ;
   uint16_t max_fibre_devices ;
   uint16_t fb_rev ;
   uint16_t min_external_loopid ;
   uint16_t link_data_rate ;
   uint8_t current_topology ;
   uint8_t prev_topology ;
   uint8_t operating_mode ;
   uint8_t interrupts_on ;
   uint32_t isp_abort_cnt ;
   uint32_t device_type ;
   uint8_t serial0 ;
   uint8_t serial1 ;
   uint8_t serial2 ;
   uint16_t nvram_size ;
   uint16_t nvram_base ;
   void *nvram ;
   uint16_t vpd_size ;
   uint16_t vpd_base ;
   void *vpd ;
   uint16_t loop_reset_delay ;
   uint8_t retry_count ;
   uint8_t login_timeout ;
   uint16_t r_a_tov ;
   int port_down_retry_count ;
   uint8_t mbx_count ;
   uint8_t aen_mbx_count ;
   uint32_t login_retry_count ;
   ms_iocb_entry_t *ms_iocb ;
   dma_addr_t ms_iocb_dma ;
   struct ct_sns_pkt *ct_sns ;
   dma_addr_t ct_sns_dma ;
   struct sns_cmd_pkt *sns_cmd ;
   dma_addr_t sns_cmd_dma ;
   void *sfp_data ;
   dma_addr_t sfp_data_dma ;
   void *xgmac_data ;
   dma_addr_t xgmac_data_dma ;
   void *dcbx_tlv ;
   dma_addr_t dcbx_tlv_dma ;
   struct task_struct *dpc_thread ;
   uint8_t dpc_active ;
   dma_addr_t gid_list_dma ;
   struct gid_list_info *gid_list ;
   int gid_list_info_size ;
   struct dma_pool *s_dma_pool ;
   dma_addr_t init_cb_dma ;
   init_cb_t *init_cb ;
   int init_cb_size ;
   dma_addr_t ex_init_cb_dma ;
   struct ex_init_cb_81xx *ex_init_cb ;
   void *async_pd ;
   dma_addr_t async_pd_dma ;
   void *swl ;
   uint16_t mailbox_out[32U] ;
   uint32_t mailbox_out32[32U] ;
   uint32_t aenmb[8U] ;
   mbx_cmd_t *mcp ;
   struct mbx_cmd_32 *mcp32 ;
   unsigned long mbx_cmd_flags ;
   struct mutex vport_lock ;
   spinlock_t vport_slock ;
   struct completion mbx_cmd_comp ;
   struct completion mbx_intr_comp ;
   struct completion dcbx_comp ;
   struct completion lb_portup_comp ;
   int notify_dcbx_comp ;
   int notify_lb_portup_comp ;
   struct mutex selflogin_lock ;
   uint16_t fw_major_version ;
   uint16_t fw_minor_version ;
   uint16_t fw_subminor_version ;
   uint16_t fw_attributes ;
   uint16_t fw_attributes_h ;
   uint16_t fw_attributes_ext[2U] ;
   uint32_t fw_memory_size ;
   uint32_t fw_transfer_size ;
   uint32_t fw_srisc_address ;
   uint16_t fw_xcb_count ;
   uint16_t fw_iocb_count ;
   uint16_t fw_options[16U] ;
   uint8_t fw_seriallink_options[4U] ;
   uint16_t fw_seriallink_options24[4U] ;
   uint8_t mpi_version[3U] ;
   uint32_t mpi_capabilities ;
   uint8_t phy_version[3U] ;
   struct qla2xxx_fw_dump *fw_dump ;
   uint32_t fw_dump_len ;
   int fw_dumped ;
   int fw_dump_reading ;
   dma_addr_t eft_dma ;
   void *eft ;
   dma_addr_t mctp_dump_dma ;
   void *mctp_dump ;
   int mctp_dumped ;
   int mctp_dump_reading ;
   uint32_t chain_offset ;
   struct dentry *dfs_dir ;
   struct dentry *dfs_fce ;
   dma_addr_t fce_dma ;
   void *fce ;
   uint32_t fce_bufs ;
   uint16_t fce_mb[8U] ;
   uint64_t fce_wr ;
   uint64_t fce_rd ;
   struct mutex fce_mutex ;
   uint32_t pci_attr ;
   uint16_t chip_revision ;
   uint16_t product_id[4U] ;
   uint8_t model_number[17U] ;
   char model_desc[80U] ;
   uint8_t adapter_id[17U] ;
   char *optrom_buffer ;
   uint32_t optrom_size ;
   int optrom_state ;
   uint32_t optrom_region_start ;
   uint32_t optrom_region_size ;
   uint8_t bios_revision[2U] ;
   uint8_t efi_revision[2U] ;
   uint8_t fcode_revision[16U] ;
   uint32_t fw_revision[4U] ;
   uint32_t gold_fw_version[4U] ;
   uint32_t flash_conf_off ;
   uint32_t flash_data_off ;
   uint32_t nvram_conf_off ;
   uint32_t nvram_data_off ;
   uint32_t fdt_wrt_disable ;
   uint32_t fdt_wrt_enable ;
   uint32_t fdt_erase_cmd ;
   uint32_t fdt_block_size ;
   uint32_t fdt_unprotect_sec_cmd ;
   uint32_t fdt_protect_sec_cmd ;
   uint32_t fdt_wrt_sts_reg_cmd ;
   uint32_t flt_region_flt ;
   uint32_t flt_region_fdt ;
   uint32_t flt_region_boot ;
   uint32_t flt_region_fw ;
   uint32_t flt_region_vpd_nvram ;
   uint32_t flt_region_vpd ;
   uint32_t flt_region_nvram ;
   uint32_t flt_region_npiv_conf ;
   uint32_t flt_region_gold_fw ;
   uint32_t flt_region_fcp_prio ;
   uint32_t flt_region_bootload ;
   uint16_t beacon_blink_led ;
   uint8_t beacon_color_state ;
   uint16_t zio_mode ;
   uint16_t zio_timer ;
   struct qla_msix_entry *msix_entries ;
   struct list_head vp_list ;
   unsigned long vp_idx_map[4U] ;
   uint16_t num_vhosts ;
   uint16_t num_vsans ;
   uint16_t max_npiv_vports ;
   int cur_vport_count ;
   struct qla_chip_state_84xx *cs84xx ;
   struct qla_statistics qla_stats ;
   struct isp_operations *isp_ops ;
   struct workqueue_struct *wq ;
   struct qlfc_fw fw_buf ;
   struct qla_fcp_prio_cfg *fcp_prio_cfg ;
   struct dma_pool *dl_dma_pool ;
   struct dma_pool *fcp_cmnd_dma_pool ;
   mempool_t *ctx_mempool ;
   unsigned long nx_pcibase ;
   uint8_t *nxdb_rd_ptr ;
   unsigned long nxdb_wr_ptr ;
   uint32_t crb_win ;
   uint32_t curr_window ;
   uint32_t ddr_mn_window ;
   unsigned long mn_win_crb ;
   unsigned long ms_win_crb ;
   int qdr_sn_window ;
   uint32_t fcoe_dev_init_timeout ;
   uint32_t fcoe_reset_timeout ;
   rwlock_t hw_lock ;
   uint16_t portnum ;
   int link_width ;
   struct fw_blob *hablob ;
   struct qla82xx_legacy_intr_set nx_legacy_intr ;
   uint16_t gbl_dsd_inuse ;
   uint16_t gbl_dsd_avail ;
   struct list_head gbl_dsd_list ;
   uint8_t fw_type ;
   __le32 file_prd_off ;
   uint32_t md_template_size ;
   void *md_tmplt_hdr ;
   dma_addr_t md_tmplt_hdr_dma ;
   void *md_dump ;
   uint32_t md_dump_size ;
   void *loop_id_map ;
   uint32_t idc_audit_ts ;
   uint32_t idc_extend_tmo ;
   struct workqueue_struct *dpc_lp_wq ;
   struct work_struct idc_aen ;
   struct workqueue_struct *dpc_hp_wq ;
   struct work_struct nic_core_reset ;
   struct work_struct idc_state_handler ;
   struct work_struct nic_core_unrecoverable ;
   unsigned long host_last_rampdown_time ;
   unsigned long host_last_rampup_time ;
   int cfg_lun_q_depth ;
   struct mr_data_fx00 mr ;
   struct qlt_hw_data tgt ;
};
#line 3316 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_flags_305 {
   unsigned char init_done : 1 ;
   unsigned char online : 1 ;
   unsigned char reset_active : 1 ;
   unsigned char management_server_logged_in : 1 ;
   unsigned char process_response_queue : 1 ;
   unsigned char difdix_supported : 1 ;
   unsigned char delete_progress : 1 ;
   unsigned char fw_tgt_reported : 1 ;
};
#line 3316 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct scsi_qla_host {
   struct list_head list ;
   struct list_head vp_fcports ;
   struct list_head work_list ;
   spinlock_t work_lock ;
   struct Scsi_Host *host ;
   unsigned long host_no ;
   uint8_t host_str[16U] ;
   struct __anonstruct_flags_305  volatile  flags ;
   atomic_t loop_state ;
   unsigned long dpc_flags ;
   uint32_t device_flags ;
   uint16_t loop_id ;
   uint16_t self_login_loop_id ;
   fc_port_t bidir_fcport ;
   port_id_t d_id ;
   uint8_t marker_needed ;
   uint16_t mgmt_svr_loop_id ;
   uint8_t loop_down_abort_time ;
   atomic_t loop_down_timer ;
   uint8_t link_down_timeout ;
   uint32_t timer_active ;
   struct timer_list timer ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint8_t fabric_node_name[8U] ;
   uint16_t fcoe_vlan_id ;
   uint16_t fcoe_fcf_idx ;
   uint8_t fcoe_vn_port_mac[6U] ;
   uint32_t vp_abort_cnt ;
   struct fc_vport *fc_vport ;
   uint16_t vp_idx ;
   unsigned long vp_flags ;
   atomic_t vp_state ;
   uint16_t vp_err_state ;
   uint16_t vp_prev_err_state ;
   struct qla_hw_data *hw ;
   struct req_que *req ;
   int fw_heartbeat_counter ;
   int seconds_since_last_heartbeat ;
   struct fc_host_statistics fc_host_stat ;
   struct qla_statistics qla_stats ;
   struct bidi_statistics bidi_stats ;
   atomic_t vref_count ;
   struct qla8044_reset_template reset_tmplt ;
};
#line 3453 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct scsi_qla_host scsi_qla_host_t;
#line 3454 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct qla_tgt_vp_map {
   uint8_t idx ;
   scsi_qla_host_t *vha ;
};
#line 3463
enum nexus_wait_type {
    WAIT_HOST = 0,
    WAIT_TARGET = 1,
    WAIT_LUN = 2
} ;
#line 738 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
struct qla2300_fw_dump {
   uint16_t hccr ;
   uint16_t pbiu_reg[8U] ;
   uint16_t risc_host_reg[8U] ;
   uint16_t mailbox_reg[32U] ;
   uint16_t resp_dma_reg[32U] ;
   uint16_t dma_reg[48U] ;
   uint16_t risc_hdw_reg[16U] ;
   uint16_t risc_gp0_reg[16U] ;
   uint16_t risc_gp1_reg[16U] ;
   uint16_t risc_gp2_reg[16U] ;
   uint16_t risc_gp3_reg[16U] ;
   uint16_t risc_gp4_reg[16U] ;
   uint16_t risc_gp5_reg[16U] ;
   uint16_t risc_gp6_reg[16U] ;
   uint16_t risc_gp7_reg[16U] ;
   uint16_t frame_buf_hdw_reg[64U] ;
   uint16_t fpm_b0_reg[64U] ;
   uint16_t fpm_b1_reg[64U] ;
   uint16_t risc_ram[63488U] ;
   uint16_t stack_ram[4096U] ;
   uint16_t data_ram[1U] ;
};
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2100_fw_dump {
   uint16_t hccr ;
   uint16_t pbiu_reg[8U] ;
   uint16_t mailbox_reg[32U] ;
   uint16_t dma_reg[48U] ;
   uint16_t risc_hdw_reg[16U] ;
   uint16_t risc_gp0_reg[16U] ;
   uint16_t risc_gp1_reg[16U] ;
   uint16_t risc_gp2_reg[16U] ;
   uint16_t risc_gp3_reg[16U] ;
   uint16_t risc_gp4_reg[16U] ;
   uint16_t risc_gp5_reg[16U] ;
   uint16_t risc_gp6_reg[16U] ;
   uint16_t risc_gp7_reg[16U] ;
   uint16_t frame_buf_hdw_reg[16U] ;
   uint16_t fpm_b0_reg[64U] ;
   uint16_t fpm_b1_reg[64U] ;
   uint16_t risc_ram[61440U] ;
};
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla24xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[7U] ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[16U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[16U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[112U] ;
   uint32_t fpm_hdw_reg[192U] ;
   uint32_t fb_hdw_reg[176U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 89 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla25xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[32U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t aseq_gp_reg[128U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[192U] ;
   uint32_t fb_hdw_reg[192U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla81xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[32U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[128U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t rseq_gp_reg[128U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t aseq_gp_reg[128U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t cmd_dma_reg[16U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[224U] ;
   uint32_t fb_hdw_reg[208U] ;
   uint32_t code_ram[8192U] ;
   uint32_t ext_mem[1U] ;
};
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla83xx_fw_dump {
   uint32_t host_status ;
   uint32_t host_risc_reg[48U] ;
   uint32_t pcie_regs[4U] ;
   uint32_t host_reg[32U] ;
   uint32_t shadow_reg[11U] ;
   uint32_t risc_io_reg ;
   uint16_t mailbox_reg[32U] ;
   uint32_t xseq_gp_reg[256U] ;
   uint32_t xseq_0_reg[48U] ;
   uint32_t xseq_1_reg[16U] ;
   uint32_t xseq_2_reg[16U] ;
   uint32_t rseq_gp_reg[256U] ;
   uint32_t rseq_0_reg[32U] ;
   uint32_t rseq_1_reg[16U] ;
   uint32_t rseq_2_reg[16U] ;
   uint32_t rseq_3_reg[16U] ;
   uint32_t aseq_gp_reg[256U] ;
   uint32_t aseq_0_reg[32U] ;
   uint32_t aseq_1_reg[16U] ;
   uint32_t aseq_2_reg[16U] ;
   uint32_t aseq_3_reg[16U] ;
   uint32_t cmd_dma_reg[64U] ;
   uint32_t req0_dma_reg[15U] ;
   uint32_t resp0_dma_reg[15U] ;
   uint32_t req1_dma_reg[15U] ;
   uint32_t xmt0_dma_reg[32U] ;
   uint32_t xmt1_dma_reg[32U] ;
   uint32_t xmt2_dma_reg[32U] ;
   uint32_t xmt3_dma_reg[32U] ;
   uint32_t xmt4_dma_reg[32U] ;
   uint32_t xmt_data_dma_reg[16U] ;
   uint32_t rcvt0_data_dma_reg[32U] ;
   uint32_t rcvt1_data_dma_reg[32U] ;
   uint32_t risc_gp_reg[128U] ;
   uint32_t lmc_reg[128U] ;
   uint32_t fpm_hdw_reg[256U] ;
   uint32_t rq0_array_reg[256U] ;
   uint32_t rq1_array_reg[256U] ;
   uint32_t rp0_array_reg[256U] ;
   uint32_t rp1_array_reg[256U] ;
   uint32_t queue_control_reg[16U] ;
   uint32_t fb_hdw_reg[432U] ;
   uint32_t at0_array_reg[128U] ;
   uint32_t code_ram[9216U] ;
   uint32_t ext_mem[1U] ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
union __anonunion_isp_306 {
   struct qla2100_fw_dump isp21 ;
   struct qla2300_fw_dump isp23 ;
   struct qla24xx_fw_dump isp24 ;
   struct qla25xx_fw_dump isp25 ;
   struct qla81xx_fw_dump isp81 ;
   struct qla83xx_fw_dump isp83 ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_fw_dump {
   uint8_t signature[4U] ;
   uint32_t version ;
   uint32_t fw_major_version ;
   uint32_t fw_minor_version ;
   uint32_t fw_subminor_version ;
   uint32_t fw_attributes ;
   uint32_t vendor ;
   uint32_t device ;
   uint32_t subsystem_vendor ;
   uint32_t subsystem_device ;
   uint32_t fixed_size ;
   uint32_t mem_size ;
   uint32_t req_q_size ;
   uint32_t rsp_q_size ;
   uint32_t eft_size ;
   uint32_t eft_addr_l ;
   uint32_t eft_addr_h ;
   uint32_t header_size ;
   union __anonunion_isp_306 isp ;
};
#line 19 "include/scsi/scsicam.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "include/linux/attribute_container.h"
struct transport_container;
#line 43 "include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 100 "include/linux/transport_class.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , uint  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 121 "include/scsi/scsi_transport.h"
struct __anonstruct_isp2x_308 {
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint16_t lun ;
   uint8_t target_id ;
   uint8_t reserved_1 ;
   uint16_t status_modifier ;
   uint16_t status ;
   uint16_t task_flags ;
   uint16_t seq_id ;
   uint16_t srr_rx_id ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_ox_id ;
   uint8_t reserved_2[28U] ;
};
#line 121 "include/scsi/scsi_transport.h"
struct __anonstruct_isp24_309 {
   uint32_t reserved ;
   uint16_t nport_handle ;
   uint16_t reserved_2 ;
   uint16_t flags ;
   uint16_t srr_rx_id ;
   uint16_t status ;
   uint8_t status_subcode ;
   uint8_t fw_handle ;
   uint32_t exchange_address ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_ox_id ;
   uint8_t reserved_4[19U] ;
   uint8_t vp_index ;
   uint32_t reserved_5 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_6 ;
};
#line 121 "include/scsi/scsi_transport.h"
union __anonunion_u_307 {
   struct __anonstruct_isp2x_308 isp2x ;
   struct __anonstruct_isp24_309 isp24 ;
};
#line 121 "include/scsi/scsi_transport.h"
struct imm_ntfy_from_isp {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   union __anonunion_u_307 u ;
   uint16_t reserved_7 ;
   uint16_t ox_id ;
};
#line 282 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct fcp_hdr {
   uint8_t r_ctl ;
   uint8_t d_id[3U] ;
   uint8_t cs_ctl ;
   uint8_t s_id[3U] ;
   uint8_t type ;
   uint8_t f_ctl[3U] ;
   uint8_t seq_id ;
   uint8_t df_ctl ;
   uint16_t seq_cnt ;
   uint16_t ox_id ;
   uint16_t rx_id ;
   uint32_t parameter ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct fcp_hdr_le {
   uint8_t d_id[3U] ;
   uint8_t r_ctl ;
   uint8_t s_id[3U] ;
   uint8_t cs_ctl ;
   uint8_t f_ctl[3U] ;
   uint8_t type ;
   uint16_t seq_cnt ;
   uint8_t df_ctl ;
   uint8_t seq_id ;
   uint16_t rx_id ;
   uint16_t ox_id ;
   uint32_t parameter ;
};
#line 337 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct atio7_fcp_cmnd {
   uint64_t lun ;
   uint8_t cmnd_ref ;
   unsigned char task_attr : 3 ;
   unsigned char reserved : 5 ;
   uint8_t task_mgmt_flags ;
   unsigned char wrdata : 1 ;
   unsigned char rddata : 1 ;
   unsigned char add_cdb_len : 6 ;
   uint8_t cdb[16U] ;
   uint8_t add_cdb[4U] ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp2x_314 {
   uint16_t entry_hdr ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint16_t rx_id ;
   uint16_t flags ;
   uint16_t status ;
   uint8_t command_ref ;
   uint8_t task_codes ;
   uint8_t task_flags ;
   uint8_t execution_codes ;
   uint8_t cdb[16U] ;
   uint32_t data_length ;
   uint16_t lun ;
   uint8_t initiator_port_name[8U] ;
   uint16_t reserved_32[6U] ;
   uint16_t ox_id ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp24_315 {
   uint16_t entry_hdr ;
   uint8_t fcp_cmnd_len_low ;
   unsigned char fcp_cmnd_len_high : 4 ;
   unsigned char attr : 4 ;
   uint32_t exchange_addr ;
   struct fcp_hdr fcp_hdr ;
   struct atio7_fcp_cmnd fcp_cmnd ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_raw_316 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t data[58U] ;
   uint32_t signature ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_313 {
   struct __anonstruct_isp2x_314 isp2x ;
   struct __anonstruct_isp24_315 isp24 ;
   struct __anonstruct_raw_316 raw ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct atio_from_isp {
   union __anonunion_u_313 u ;
};
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_recv_from_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint8_t reserved_1[6U] ;
   uint16_t nport_handle ;
   uint8_t reserved_2[2U] ;
   uint8_t vp_index ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   uint8_t reserved_4[16U] ;
   uint32_t exchange_addr_to_abort ;
};
#line 626
struct qla_tgt_mgmt_cmd;
#line 627
struct qla_tgt_sess;
#line 628 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_func_tmpl {
   int (*handle_cmd)(struct scsi_qla_host * , struct qla_tgt_cmd * , unsigned char * ,
                     uint32_t  , int  , int  , int  ) ;
   void (*handle_data)(struct qla_tgt_cmd * ) ;
   int (*handle_tmr)(struct qla_tgt_mgmt_cmd * , uint32_t  , uint8_t  , uint32_t  ) ;
   void (*free_cmd)(struct qla_tgt_cmd * ) ;
   void (*free_mcmd)(struct qla_tgt_mgmt_cmd * ) ;
   void (*free_session)(struct qla_tgt_sess * ) ;
   int (*check_initiator_node_acl)(struct scsi_qla_host * , unsigned char * , void * ,
                                   uint8_t * , uint16_t  ) ;
   void (*update_sess)(struct qla_tgt_sess * , port_id_t  , uint16_t  , bool  ) ;
   struct qla_tgt_sess *(*find_sess_by_loop_id)(struct scsi_qla_host * , uint16_t const    ) ;
   struct qla_tgt_sess *(*find_sess_by_s_id)(struct scsi_qla_host * , uint8_t const   * ) ;
   void (*clear_nacl_from_fcport_map)(struct qla_tgt_sess * ) ;
   void (*put_sess)(struct qla_tgt_sess * ) ;
   void (*shutdown_sess)(struct qla_tgt_sess * ) ;
};
#line 104 "include/linux/in.h"
struct configfs_item_operations;
#line 105
struct configfs_group_operations;
#line 106
struct configfs_attribute;
#line 107
struct configfs_subsystem;
#line 108
struct config_group;
#line 108
struct config_item_type;
#line 108 "include/linux/in.h"
struct config_item {
   char *ci_name ;
   char ci_namebuf[20U] ;
   struct kref ci_kref ;
   struct list_head ci_entry ;
   struct config_item *ci_parent ;
   struct config_group *ci_group ;
   struct config_item_type *ci_type ;
   struct dentry *ci_dentry ;
};
#line 81 "include/linux/configfs.h"
struct config_item_type {
   struct module *ct_owner ;
   struct configfs_item_operations *ct_item_ops ;
   struct configfs_group_operations *ct_group_ops ;
   struct configfs_attribute **ct_attrs ;
};
#line 88 "include/linux/configfs.h"
struct config_group {
   struct config_item cg_item ;
   struct list_head cg_children ;
   struct configfs_subsystem *cg_subsys ;
   struct config_group **default_groups ;
};
#line 121 "include/linux/configfs.h"
struct configfs_attribute {
   char const   *ca_name ;
   struct module *ca_owner ;
   umode_t ca_mode ;
};
#line 129 "include/linux/configfs.h"
struct configfs_item_operations {
   void (*release)(struct config_item * ) ;
   ssize_t (*show_attribute)(struct config_item * , struct configfs_attribute * ,
                             char * ) ;
   ssize_t (*store_attribute)(struct config_item * , struct configfs_attribute * ,
                              char const   * , size_t  ) ;
   int (*allow_link)(struct config_item * , struct config_item * ) ;
   int (*drop_link)(struct config_item * , struct config_item * ) ;
};
#line 231 "include/linux/configfs.h"
struct configfs_group_operations {
   struct config_item *(*make_item)(struct config_group * , char const   * ) ;
   struct config_group *(*make_group)(struct config_group * , char const   * ) ;
   int (*commit_item)(struct config_item * ) ;
   void (*disconnect_notify)(struct config_group * , struct config_item * ) ;
   void (*drop_item)(struct config_group * , struct config_item * ) ;
};
#line 239 "include/linux/configfs.h"
struct configfs_subsystem {
   struct config_group su_group ;
   struct mutex su_mutex ;
};
#line 259
struct percpu_ida_cpu;
#line 260 "include/linux/configfs.h"
struct __anonstruct_ldv_44369_321 {
   spinlock_t lock ;
   unsigned int cpu_last_stolen ;
   wait_queue_head_t wait ;
   unsigned int nr_free ;
   unsigned int *freelist ;
};
#line 260 "include/linux/configfs.h"
struct percpu_ida {
   unsigned int nr_tags ;
   struct percpu_ida_cpu *tag_cpu ;
   cpumask_t cpus_have_tags ;
   struct __anonstruct_ldv_44369_321 ldv_44369 ;
};
#line 59 "include/linux/percpu_ida.h"
struct hlist_nulls_node;
#line 59 "include/linux/percpu_ida.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 80 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 45 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 50
enum dev_pm_qos_req_type {
    DEV_PM_QOS_LATENCY = 1,
    DEV_PM_QOS_FLAGS = 2
} ;
#line 55 "include/linux/pm_qos.h"
union __anonunion_data_322 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 55 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_322 data ;
   struct device *dev ;
};
#line 64
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 70 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 83 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 88 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints latency ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *latency_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 208 "include/linux/pm_qos.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_323 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_323 sync_serial_settings;
#line 50 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_324 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_324 te1_settings;
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_325 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_325 raw_hdlc_proto;
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_326 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_326 fr_proto;
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_327 {
   unsigned int dlci ;
};
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_327 fr_proto_pvc;
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_328 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_328 fr_proto_pvc_info;
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_329 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_329 cisco_proto;
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_330 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_330 ifs_ifsu ;
};
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_331 {
   char ifrn_name[16U] ;
};
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_332 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_331 ifr_ifrn ;
   union __anonunion_ifr_ifru_332 ifr_ifru ;
};
#line 18 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 273 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 277 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 685 "include/linux/compat.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 65 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 105 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 120 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 128 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 137 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 166 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 183 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 281 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 303 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 331 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 382 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 425 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 458 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 474 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 494 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 505 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 524 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 550 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 684 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 692 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 768 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh_indir)(struct net_device * , u32 * ) ;
   int (*set_rxfh_indir)(struct net_device * , u32 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 249
struct prot_inuse;
#line 250 "include/linux/ethtool.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 138 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[96U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[1U] ;
   struct ipstats_mib *ip_statistics[1U] ;
   struct linux_mib *net_statistics[1U] ;
   struct udp_mib *udp_statistics[1U] ;
   struct udp_mib *udplite_statistics[1U] ;
   struct icmp_mib *icmp_statistics[1U] ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[1U] ;
   struct udp_mib *udplite_stats_in6[1U] ;
   struct ipstats_mib *ipv6_statistics[1U] ;
   struct icmpv6_mib *icmpv6_statistics[1U] ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics[1U] ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 176 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 177
struct ipv4_devconf;
#line 178
struct fib_rules_ops;
#line 179
struct fib_table;
#line 180
struct inet_peer_base;
#line 180
struct xt_table;
#line 180 "include/net/inet_frag.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   int sysctl_tcp_ecn ;
   kgid_t sysctl_ping_group_range[2U] ;
   long sysctl_tcp_mem[3U] ;
   atomic_t dev_addr_genid ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 83 "include/net/netns/ipv4.h"
struct neighbour;
#line 83 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int icmpv6_time ;
};
#line 32 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 32
struct rt6_info;
#line 32
struct rt6_statistics;
#line 32
struct fib6_table;
#line 32 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 77 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 83
struct sctp_mib;
#line 84 "include/net/netns/ipv6.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics[1U] ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 78 "include/linux/proc_fs.h"
union __anonunion_in6_u_350 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 78 "include/linux/proc_fs.h"
struct in6_addr {
   union __anonunion_in6_u_350 in6_u ;
};
#line 335 "include/linux/netfilter.h"
struct nf_logger;
#line 336 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 23 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 28 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 42 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 47 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 52 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 63
struct ip_conntrack_stat;
#line 63
struct nf_ct_event_notifier;
#line 63
struct nf_exp_event_notifier;
#line 63 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   int sysctl_events ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_acct ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int sysctl_log_invalid ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
};
#line 489 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   wait_queue_head_t km_waitq ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
};
#line 62
struct net_generic;
#line 63
struct netns_ipvs;
#line 64 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 382 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 200 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 41 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 103 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "include/linux/prio_heap.h"
struct idr_layer {
   int prefix ;
   unsigned long bitmap[4U] ;
   struct idr_layer *ary[256U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 38 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   int cur ;
   spinlock_t lock ;
};
#line 245 "include/linux/idr.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 173
struct cgroupfs_root;
#line 174
struct cgroup_subsys;
#line 175
struct cgroup;
#line 176
struct css_id;
#line 177
struct eventfd_ctx;
#line 63 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   unsigned long flags ;
   struct css_id *id ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 145 "include/linux/cgroup.h"
struct cgroup_name {
   struct callback_head callback_head ;
   char name[] ;
};
#line 163 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   int id ;
   int nr_css ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   u64 serial_nr ;
   struct cgroup_name *name ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct list_head cset_links ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct cgroup_subsys_state dummy_css ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
#line 257 "include/linux/cgroup.h"
struct cgroupfs_root {
   struct super_block *sb ;
   unsigned long subsys_mask ;
   int hierarchy_id ;
   struct list_head subsys_list ;
   struct cgroup top_cgroup ;
   int number_of_cgroups ;
   struct list_head root_list ;
   unsigned long flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 347 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cgrp_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 390 "include/linux/cgroup.h"
struct cgroup_map_cb {
   int (*fill)(struct cgroup_map_cb * , char const   * , u64  ) ;
   void *state ;
};
#line 407 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   int (*open)(struct inode * , struct file * ) ;
   ssize_t (*read)(struct cgroup_subsys_state * , struct cftype * , struct file * ,
                   char * , size_t  , loff_t * ) ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*read_map)(struct cgroup_subsys_state * , struct cftype * , struct cgroup_map_cb * ) ;
   int (*read_seq_string)(struct cgroup_subsys_state * , struct cftype * , struct seq_file * ) ;
   ssize_t (*write)(struct cgroup_subsys_state * , struct cftype * , struct file * ,
                    char const   * , size_t  , loff_t * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   int (*write_string)(struct cgroup_subsys_state * , struct cftype * , char const   * ) ;
   int (*trigger)(struct cgroup_subsys_state * , unsigned int  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*register_event)(struct cgroup_subsys_state * , struct cftype * , struct eventfd_ctx * ,
                         char const   * ) ;
   void (*unregister_event)(struct cgroup_subsys_state * , struct cftype * , struct eventfd_ctx * ) ;
};
#line 527 "include/linux/cgroup.h"
struct cftype_set {
   struct list_head node ;
   struct cftype *cfts ;
};
#line 564
struct cgroup_taskset;
#line 575 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int subsys_id ;
   int disabled ;
   int early_init ;
   bool use_id ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   char const   *name ;
   struct cgroupfs_root *root ;
   struct list_head sibling ;
   struct idr idr ;
   spinlock_t id_lock ;
   struct list_head cftsets ;
   struct cftype *base_cftypes ;
   struct cftype_set base_cftset ;
   struct module *module ;
};
#line 908 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 58 "include/net/netprio_cgroup.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 467 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 tx_rate ;
   __u32 spoofchk ;
   __u32 linkstate ;
};
#line 27 "include/linux/if_link.h"
struct netpoll_info;
#line 28
struct phy_device;
#line 29
struct wireless_dev;
#line 64 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 116 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 135 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 196
struct neigh_parms;
#line 217 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 222 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 251 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 302 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 346
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 394 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 395 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 531
struct Qdisc;
#line 531 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 593 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 605 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 617 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 668 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 678 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 691 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 729 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 740 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * , gfp_t  ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __u16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __u16  ) ;
};
#line 1113
struct iw_handler_def;
#line 1113
struct iw_public_data;
#line 1113
struct vlan_info;
#line 1113
struct in_device;
#line 1113
struct dn_dev;
#line 1113
struct inet6_dev;
#line 1113
struct cpu_rmap;
#line 1113
struct pcpu_lstats;
#line 1113
struct pcpu_tstats;
#line 1113
struct pcpu_dstats;
#line 1113
struct pcpu_vstats;
#line 1113 "include/linux/netdevice.h"
union __anonunion_ldv_50454_359 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_tstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1113
struct garp_port;
#line 1113
struct mrp_port;
#line 1113
struct rtnl_link_ops;
#line 1113 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head upper_dev_list ;
   struct list_head lower_dev_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned char neigh_priv_len ;
   unsigned short dev_id ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_50454_359 ldv_50454 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 677 "include/linux/memcontrol.h"
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
#line 226 "include/linux/res_counter.h"
struct kioctx;
#line 30 "include/linux/aio.h"
typedef int kiocb_cancel_fn(struct kiocb * );
#line 31 "include/linux/aio.h"
union __anonunion_ki_obj_360 {
   void *user ;
   struct task_struct *tsk ;
};
#line 31 "include/linux/aio.h"
struct kiocb {
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void *private ;
   union __anonunion_ki_obj_360 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   size_t ki_nbytes ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 100 "include/linux/aio.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 19 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   unsigned int len ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct sock_filter  const  * ) ;
   struct callback_head rcu ;
   struct sock_filter insns[0U] ;
};
#line 101 "include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 103 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 27 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
};
#line 133
struct neigh_table;
#line 133 "include/net/rtnetlink.h"
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int base_reachable_time ;
   int retrans_time ;
   int gc_staletime ;
   int reachable_time ;
   int delay_probe_time ;
   int queue_len_bytes ;
   int ucast_probes ;
   int app_probes ;
   int mcast_probes ;
   int anycast_delay ;
   int proxy_delay ;
   int proxy_qlen ;
   int locktime ;
};
#line 71 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 90
struct neigh_ops;
#line 90 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 119 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 127 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 137 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 150 "include/net/neighbour.h"
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 407
struct dn_route;
#line 407 "include/net/neighbour.h"
union __anonunion_ldv_53555_365 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 407 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_ldv_53555_365 ldv_53555 ;
};
#line 123 "include/net/sock.h"
struct __anonstruct_socket_lock_t_366 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 123 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_366 socket_lock_t;
#line 123
struct proto;
#line 129 "include/net/sock.h"
typedef __u32 __portpair;
#line 130 "include/net/sock.h"
typedef __u64 __addrpair;
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_53776_368 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_53777_367 {
   __addrpair skc_addrpair ;
   struct __anonstruct_ldv_53776_368 ldv_53776 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_53781_369 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_53787_371 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_53788_370 {
   __portpair skc_portpair ;
   struct __anonstruct_ldv_53787_371 ldv_53787 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_53797_372 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_53804_373 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 131 "include/net/sock.h"
struct sock_common {
   union __anonunion_ldv_53777_367 ldv_53777 ;
   union __anonunion_ldv_53781_369 ldv_53781 ;
   union __anonunion_ldv_53788_370 ldv_53788 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion_ldv_53797_372 ldv_53797 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_ldv_53804_373 ldv_53804 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 210
struct cg_proto;
#line 211 "include/net/sock.h"
struct __anonstruct_sk_backlog_374 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 211 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_374 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct sk_buff_head sk_async_wait_queue ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check : 2 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * , int  ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 865
struct request_sock_ops;
#line 866
struct timewait_sock_ops;
#line 867
struct inet_hashinfo;
#line 868
struct raw_hashinfo;
#line 883
struct udp_table;
#line 883 "include/net/sock.h"
union __anonunion_h_375 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 883 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  , int  ,
                  int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_375 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1008 "include/net/sock.h"
struct cg_proto {
   void (*enter_memory_pressure)(struct sock * ) ;
   struct res_counter *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 169 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
#line 47 "include/net/request_sock.h"
struct request_sock {
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
#line 375 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 166 "include/uapi/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   void *sysctl ;
};
#line 100 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 109 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 141 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 153 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6[1U] ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 164 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   int valid_ll_addr_cnt ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 872 "include/net/ipv6.h"
union __anonunion_ldv_58122_389 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
#line 872 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_ldv_58122_389 ldv_58122 ;
};
#line 24 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_58137_390 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 29 "include/net/inetpeer.h"
struct __anonstruct_ldv_58142_392 {
   atomic_t rid ;
   atomic_t ip_id_count ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_58145_391 {
   struct __anonstruct_ldv_58142_392 ldv_58142 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 29 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[15U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_ldv_58137_390 ldv_58137 ;
   union __anonunion_ldv_58145_391 ldv_58145 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
#line 50 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
#line 327 "include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
   struct hlist_nulls_head twchain ;
};
#line 96 "include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 104 "include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 116 "include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
   atomic_t bsockets ;
};
#line 1604 "include/net/tcp.h"
enum transport_lun_status_table {
    TRANSPORT_LUN_STATUS_FREE = 0,
    TRANSPORT_LUN_STATUS_ACTIVE = 1
} ;
#line 1609
enum transport_tpg_type_table {
    TRANSPORT_TPG_TYPE_NORMAL = 0,
    TRANSPORT_TPG_TYPE_DISCOVERY = 1
} ;
#line 1614
enum transport_state_table {
    TRANSPORT_NO_STATE = 0,
    TRANSPORT_NEW_CMD = 1,
    TRANSPORT_WRITE_PENDING = 3,
    TRANSPORT_PROCESSING = 5,
    TRANSPORT_COMPLETE = 6,
    TRANSPORT_ISTATE_PROCESSING = 11,
    TRANSPORT_COMPLETE_QF_WP = 18,
    TRANSPORT_COMPLETE_QF_OK = 19
} ;
#line 183 "include/target/target_core_base.h"
typedef unsigned int sense_reason_t;
#line 246
struct se_cmd;
#line 247
struct se_device;
#line 247
struct t10_alua_tg_pt_gp;
#line 247 "include/target/target_core_base.h"
struct t10_alua {
   u16 alua_tg_pt_gps_counter ;
   u32 alua_tg_pt_gps_count ;
   spinlock_t tg_pt_gps_lock ;
   struct se_device *t10_dev ;
   struct t10_alua_tg_pt_gp *default_tg_pt_gp ;
   struct config_group alua_tg_pt_gps_group ;
   struct list_head tg_pt_gps_list ;
};
#line 261 "include/target/target_core_base.h"
struct t10_alua_lu_gp {
   u16 lu_gp_id ;
   int lu_gp_valid_id ;
   u32 lu_gp_members ;
   atomic_t lu_gp_ref_cnt ;
   spinlock_t lu_gp_lock ;
   struct config_group lu_gp_group ;
   struct list_head lu_gp_node ;
   struct list_head lu_gp_mem_list ;
};
#line 272 "include/target/target_core_base.h"
struct t10_alua_lu_gp_member {
   bool lu_gp_assoc ;
   atomic_t lu_gp_mem_ref_cnt ;
   spinlock_t lu_gp_mem_lock ;
   struct t10_alua_lu_gp *lu_gp ;
   struct se_device *lu_gp_mem_dev ;
   struct list_head lu_gp_mem_list ;
};
#line 281 "include/target/target_core_base.h"
struct t10_alua_tg_pt_gp {
   u16 tg_pt_gp_id ;
   int tg_pt_gp_valid_id ;
   int tg_pt_gp_alua_access_status ;
   int tg_pt_gp_alua_access_type ;
   int tg_pt_gp_nonop_delay_msecs ;
   int tg_pt_gp_trans_delay_msecs ;
   int tg_pt_gp_implict_trans_secs ;
   int tg_pt_gp_pref ;
   int tg_pt_gp_write_metadata ;
   u32 tg_pt_gp_md_buf_len ;
   u32 tg_pt_gp_members ;
   atomic_t tg_pt_gp_alua_access_state ;
   atomic_t tg_pt_gp_ref_cnt ;
   spinlock_t tg_pt_gp_lock ;
   struct mutex tg_pt_gp_md_mutex ;
   struct se_device *tg_pt_gp_dev ;
   struct config_group tg_pt_gp_group ;
   struct list_head tg_pt_gp_list ;
   struct list_head tg_pt_gp_mem_list ;
};
#line 305
struct se_port;
#line 305 "include/target/target_core_base.h"
struct t10_alua_tg_pt_gp_member {
   bool tg_pt_gp_assoc ;
   atomic_t tg_pt_gp_mem_ref_cnt ;
   spinlock_t tg_pt_gp_mem_lock ;
   struct t10_alua_tg_pt_gp *tg_pt_gp ;
   struct se_port *tg_pt ;
   struct list_head tg_pt_gp_mem_list ;
};
#line 324 "include/target/target_core_base.h"
struct t10_wwn {
   char vendor[8U] ;
   char model[16U] ;
   char revision[4U] ;
   char unit_serial[254U] ;
   spinlock_t t10_vpd_lock ;
   struct se_device *t10_dev ;
   struct config_group t10_wwn_group ;
   struct list_head t10_vpd_list ;
};
#line 335
struct se_node_acl;
#line 335
struct se_dev_entry;
#line 335
struct se_lun;
#line 335 "include/target/target_core_base.h"
struct t10_pr_registration {
   char pr_reg_isid[16U] ;
   unsigned char pr_iport[256U] ;
   unsigned char pr_tport[256U] ;
   u16 pr_aptpl_rpti ;
   u16 pr_reg_tpgt ;
   int pr_reg_all_tg_pt ;
   int pr_reg_aptpl ;
   int pr_res_holder ;
   int pr_res_type ;
   int pr_res_scope ;
   bool isid_present_at_reg ;
   u32 pr_res_mapped_lun ;
   u32 pr_aptpl_target_lun ;
   u32 pr_res_generation ;
   u64 pr_reg_bin_isid ;
   u64 pr_res_key ;
   atomic_t pr_res_holders ;
   struct se_node_acl *pr_reg_nacl ;
   struct se_dev_entry *pr_reg_deve ;
   struct se_lun *pr_reg_tg_pt_lun ;
   struct list_head pr_reg_list ;
   struct list_head pr_reg_abort_list ;
   struct list_head pr_reg_aptpl_list ;
   struct list_head pr_reg_atp_list ;
   struct list_head pr_reg_atp_mem_list ;
};
#line 374 "include/target/target_core_base.h"
struct t10_reservation {
   int pr_all_tg_pt ;
   int pr_aptpl_active ;
   u32 pr_generation ;
   spinlock_t registration_lock ;
   spinlock_t aptpl_reg_lock ;
   struct se_node_acl *pr_res_holder ;
   struct list_head registration_list ;
   struct list_head aptpl_reg_list ;
};
#line 399 "include/target/target_core_base.h"
struct se_tmr_req {
   u8 function ;
   u8 response ;
   int call_transport ;
   u32 ref_task_tag ;
   void *fabric_tmr_ptr ;
   struct se_cmd *task_cmd ;
   struct se_device *tmr_dev ;
   struct se_lun *tmr_lun ;
   struct list_head tmr_list ;
};
#line 414
struct se_session;
#line 414
struct target_core_fabric_ops;
#line 414 "include/target/target_core_base.h"
struct se_cmd {
   u8 scsi_status ;
   u8 scsi_asc ;
   u8 scsi_ascq ;
   u16 scsi_sense_length ;
   int alua_nonop_delay ;
   enum dma_data_direction data_direction ;
   int sam_task_attr ;
   unsigned int map_tag ;
   enum transport_state_table t_state ;
   unsigned char cmd_wait_set : 1 ;
   unsigned char unknown_data_length : 1 ;
   u32 se_cmd_flags ;
   u32 se_ordered_id ;
   u32 data_length ;
   u32 residual_count ;
   u32 orig_fe_lun ;
   u64 pr_res_key ;
   void *sense_buffer ;
   struct list_head se_delayed_node ;
   struct list_head se_lun_node ;
   struct list_head se_qf_node ;
   struct se_device *se_dev ;
   struct se_dev_entry *se_deve ;
   struct se_lun *se_lun ;
   struct se_session *se_sess ;
   struct se_tmr_req *se_tmr_req ;
   struct list_head se_cmd_list ;
   struct completion cmd_wait_comp ;
   struct kref cmd_kref ;
   struct target_core_fabric_ops *se_tfo ;
   sense_reason_t (*execute_cmd)(struct se_cmd * ) ;
   sense_reason_t (*execute_rw)(struct se_cmd * , struct scatterlist * , u32  , enum dma_data_direction  ) ;
   sense_reason_t (*transport_complete_callback)(struct se_cmd * ) ;
   unsigned char *t_task_cdb ;
   unsigned char __t_task_cdb[32U] ;
   unsigned long long t_task_lba ;
   unsigned int t_task_nolb ;
   unsigned int transport_state ;
   spinlock_t t_state_lock ;
   struct completion t_transport_stop_comp ;
   struct completion transport_lun_fe_stop_comp ;
   struct completion transport_lun_stop_comp ;
   struct work_struct work ;
   struct scatterlist *t_data_sg ;
   struct scatterlist *t_data_sg_orig ;
   unsigned int t_data_nents ;
   unsigned int t_data_nents_orig ;
   void *t_data_vmap ;
   struct scatterlist *t_bidi_data_sg ;
   unsigned int t_bidi_data_nents ;
   struct list_head state_list ;
   bool state_active ;
   struct completion task_stop_comp ;
   void *priv ;
};
#line 510
struct se_portal_group;
#line 510 "include/target/target_core_base.h"
struct se_node_acl {
   char initiatorname[224U] ;
   bool dynamic_node_acl ;
   bool acl_stop ;
   u32 queue_depth ;
   u32 acl_index ;
   char acl_tag[64U] ;
   u64 num_cmds ;
   u64 read_bytes ;
   u64 write_bytes ;
   spinlock_t stats_lock ;
   atomic_t acl_pr_ref_count ;
   struct se_dev_entry **device_list ;
   struct se_session *nacl_sess ;
   struct se_portal_group *se_tpg ;
   spinlock_t device_list_lock ;
   spinlock_t nacl_sess_lock ;
   struct config_group acl_group ;
   struct config_group acl_attrib_group ;
   struct config_group acl_auth_group ;
   struct config_group acl_param_group ;
   struct config_group acl_fabric_stat_group ;
   struct config_group *acl_default_groups[5U] ;
   struct list_head acl_list ;
   struct list_head acl_sess_list ;
   struct completion acl_free_comp ;
   struct kref acl_kref ;
};
#line 542 "include/target/target_core_base.h"
struct se_session {
   unsigned char sess_tearing_down : 1 ;
   u64 sess_bin_isid ;
   struct se_node_acl *se_node_acl ;
   struct se_portal_group *se_tpg ;
   void *fabric_sess_ptr ;
   struct list_head sess_list ;
   struct list_head sess_acl_list ;
   struct list_head sess_cmd_list ;
   struct list_head sess_wait_list ;
   spinlock_t sess_cmd_lock ;
   struct kref sess_kref ;
   void *sess_cmd_map ;
   struct percpu_ida sess_tag_pool ;
};
#line 559 "include/target/target_core_base.h"
struct se_ml_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_auth_intr_group ;
   struct config_group scsi_att_intr_port_group ;
};
#line 568 "include/target/target_core_base.h"
struct se_lun_acl {
   char initiatorname[224U] ;
   u32 mapped_lun ;
   struct se_node_acl *se_lun_nacl ;
   struct se_lun *se_lun ;
   struct list_head lacl_list ;
   struct config_group se_lun_group ;
   struct se_ml_stat_grps ml_stat_grps ;
};
#line 578 "include/target/target_core_base.h"
struct se_dev_entry {
   bool def_pr_registered ;
   u32 lun_flags ;
   u32 mapped_lun ;
   u32 total_cmds ;
   u64 pr_res_key ;
   u64 creation_time ;
   u32 attach_count ;
   u64 read_bytes ;
   u64 write_bytes ;
   atomic_t ua_count ;
   atomic_t pr_ref_count ;
   struct se_lun_acl *se_lun_acl ;
   spinlock_t ua_lock ;
   struct se_lun *se_lun ;
   struct list_head alua_port_list ;
   struct list_head ua_list ;
};
#line 599 "include/target/target_core_base.h"
struct se_dev_attrib {
   int emulate_model_alias ;
   int emulate_dpo ;
   int emulate_fua_write ;
   int emulate_fua_read ;
   int emulate_write_cache ;
   int emulate_ua_intlck_ctrl ;
   int emulate_tas ;
   int emulate_tpu ;
   int emulate_tpws ;
   int emulate_caw ;
   int emulate_3pc ;
   int enforce_pr_isids ;
   int is_nonrot ;
   int emulate_rest_reord ;
   u32 hw_block_size ;
   u32 block_size ;
   u32 hw_max_sectors ;
   u32 fabric_max_sectors ;
   u32 optimal_sectors ;
   u32 hw_queue_depth ;
   u32 queue_depth ;
   u32 max_unmap_lba_count ;
   u32 max_unmap_block_desc_count ;
   u32 unmap_granularity ;
   u32 unmap_granularity_alignment ;
   u32 max_write_same_len ;
   struct se_device *da_dev ;
   struct config_group da_group ;
};
#line 630 "include/target/target_core_base.h"
struct se_dev_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_dev_group ;
   struct config_group scsi_tgt_dev_group ;
   struct config_group scsi_lu_group ;
};
#line 637
struct se_hba;
#line 637
struct se_subsystem_api;
#line 637 "include/target/target_core_base.h"
struct se_device {
   u32 dev_link_magic ;
   u16 dev_rpti_counter ;
   u32 dev_cur_ordered_id ;
   u32 dev_flags ;
   u32 dev_port_count ;
   u32 queue_depth ;
   u64 dev_res_bin_isid ;
   u32 dev_index ;
   u64 creation_time ;
   u32 num_resets ;
   u64 num_cmds ;
   u64 read_bytes ;
   u64 write_bytes ;
   spinlock_t stats_lock ;
   atomic_t simple_cmds ;
   atomic_t dev_ordered_id ;
   atomic_t dev_ordered_sync ;
   atomic_t dev_qf_count ;
   int export_count ;
   spinlock_t delayed_cmd_lock ;
   spinlock_t execute_task_lock ;
   spinlock_t dev_reservation_lock ;
   unsigned int dev_reservation_flags ;
   spinlock_t se_port_lock ;
   spinlock_t se_tmr_lock ;
   spinlock_t qf_cmd_lock ;
   struct semaphore caw_sem ;
   struct se_node_acl *dev_reserved_node_acl ;
   struct t10_alua_lu_gp_member *dev_alua_lu_gp_mem ;
   struct t10_pr_registration *dev_pr_res_holder ;
   struct list_head dev_sep_list ;
   struct list_head dev_tmr_list ;
   struct workqueue_struct *tmr_wq ;
   struct work_struct qf_work_queue ;
   struct list_head delayed_cmd_list ;
   struct list_head state_list ;
   struct list_head qf_cmd_list ;
   struct list_head g_dev_node ;
   struct se_hba *se_hba ;
   struct t10_wwn t10_wwn ;
   struct t10_alua t10_alua ;
   struct t10_reservation t10_pr ;
   struct se_dev_attrib dev_attrib ;
   struct config_group dev_group ;
   struct config_group dev_pr_group ;
   struct se_dev_stat_grps dev_stat_grps ;
   unsigned char dev_alias[512U] ;
   unsigned char udev_path[512U] ;
   struct se_subsystem_api *transport ;
   struct list_head dev_list ;
};
#line 715 "include/target/target_core_base.h"
struct se_hba {
   u16 hba_tpgt ;
   u32 hba_id ;
   u32 hba_flags ;
   u32 dev_count ;
   u32 hba_index ;
   void *hba_ptr ;
   struct list_head hba_node ;
   spinlock_t device_lock ;
   struct config_group hba_group ;
   struct mutex hba_access_mutex ;
   struct se_subsystem_api *transport ;
};
#line 732 "include/target/target_core_base.h"
struct se_port_stat_grps {
   struct config_group stat_group ;
   struct config_group scsi_port_group ;
   struct config_group scsi_tgt_port_group ;
   struct config_group scsi_transport_group ;
};
#line 739 "include/target/target_core_base.h"
struct se_lun {
   u32 lun_link_magic ;
   enum transport_lun_status_table lun_status ;
   u32 lun_access ;
   u32 lun_flags ;
   u32 unpacked_lun ;
   atomic_t lun_acl_count ;
   spinlock_t lun_acl_lock ;
   spinlock_t lun_cmd_lock ;
   spinlock_t lun_sep_lock ;
   struct completion lun_shutdown_comp ;
   struct list_head lun_cmd_list ;
   struct list_head lun_acl_list ;
   struct se_device *lun_se_dev ;
   struct se_port *lun_sep ;
   struct config_group lun_group ;
   struct se_port_stat_grps port_stat_grps ;
};
#line 760 "include/target/target_core_base.h"
struct scsi_port_stats {
   u64 cmd_pdus ;
   u64 tx_data_octets ;
   u64 rx_data_octets ;
};
#line 766 "include/target/target_core_base.h"
struct se_port {
   u16 sep_rtpi ;
   int sep_tg_pt_secondary_stat ;
   int sep_tg_pt_secondary_write_md ;
   u32 sep_index ;
   struct scsi_port_stats sep_stats ;
   atomic_t sep_tg_pt_secondary_offline ;
   atomic_t sep_tg_pt_ref_cnt ;
   spinlock_t sep_alua_lock ;
   struct mutex sep_tg_pt_md_mutex ;
   struct t10_alua_tg_pt_gp_member *sep_alua_tg_pt_gp_mem ;
   struct se_lun *sep_lun ;
   struct se_portal_group *sep_tpg ;
   struct list_head sep_alua_list ;
   struct list_head sep_list ;
};
#line 791
struct se_wwn;
#line 791 "include/target/target_core_base.h"
struct se_portal_group {
   enum transport_tpg_type_table se_tpg_type ;
   u32 num_node_acls ;
   atomic_t tpg_pr_ref_count ;
   spinlock_t acl_node_lock ;
   spinlock_t session_lock ;
   spinlock_t tpg_lun_lock ;
   void *se_tpg_fabric_ptr ;
   struct list_head se_tpg_node ;
   struct list_head acl_node_list ;
   struct se_lun **tpg_lun_list ;
   struct se_lun tpg_virt_lun0 ;
   struct list_head tpg_sess_list ;
   struct target_core_fabric_ops *se_tpg_tfo ;
   struct se_wwn *se_tpg_wwn ;
   struct config_group tpg_group ;
   struct config_group *tpg_default_groups[7U] ;
   struct config_group tpg_lun_group ;
   struct config_group tpg_np_group ;
   struct config_group tpg_acl_group ;
   struct config_group tpg_attrib_group ;
   struct config_group tpg_auth_group ;
   struct config_group tpg_param_group ;
};
#line 825
struct target_fabric_configfs;
#line 825 "include/target/target_core_base.h"
struct se_wwn {
   struct target_fabric_configfs *wwn_tf ;
   struct config_group wwn_group ;
   struct config_group *wwn_default_groups[2U] ;
   struct config_group fabric_stat_group ;
};
#line 751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt {
   struct scsi_qla_host *vha ;
   struct qla_hw_data *ha ;
   int irq_cmd_count ;
   int datasegs_per_cmd ;
   int datasegs_per_cont ;
   int sg_tablesize ;
   unsigned char tgt_enable_64bit_addr : 1 ;
   unsigned char link_reinit_iocb_pending : 1 ;
   int tgt_stop ;
   int tgt_stopped ;
   int sess_count ;
   struct list_head sess_list ;
   struct list_head del_sess_list ;
   struct delayed_work sess_del_work ;
   spinlock_t sess_work_lock ;
   struct list_head sess_works_list ;
   struct work_struct sess_work ;
   struct imm_ntfy_from_isp link_reinit_iocb ;
   wait_queue_head_t waitQ ;
   int notify_ack_expected ;
   int abts_resp_expected ;
   int modify_lun_expected ;
   int ctio_srr_id ;
   int imm_srr_id ;
   spinlock_t srr_lock ;
   struct list_head srr_ctio_list ;
   struct list_head srr_imm_list ;
   struct work_struct srr_work ;
   atomic_t tgt_global_resets_count ;
   struct list_head tgt_list_entry ;
};
#line 807 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_sess {
   uint16_t loop_id ;
   port_id_t s_id ;
   unsigned char conf_compl_supported : 1 ;
   unsigned char deleted : 1 ;
   unsigned char local : 1 ;
   struct se_session *se_sess ;
   struct scsi_qla_host *vha ;
   struct qla_tgt *tgt ;
   struct list_head sess_list_entry ;
   unsigned long expires ;
   struct list_head del_list_entry ;
   uint8_t port_name[8U] ;
   struct work_struct free_work ;
};
#line 830 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_cmd {
   struct qla_tgt_sess *sess ;
   int state ;
   struct se_cmd se_cmd ;
   struct work_struct free_work ;
   struct work_struct work ;
   unsigned char sense_buffer[96U] ;
   unsigned char conf_compl_supported : 1 ;
   unsigned char sg_mapped : 1 ;
   unsigned char free_sg : 1 ;
   unsigned char aborted : 1 ;
   unsigned char write_data_transferred : 1 ;
   struct scatterlist *sg ;
   int sg_cnt ;
   int bufflen ;
   int offset ;
   uint32_t tag ;
   uint32_t unpacked_lun ;
   enum dma_data_direction dma_data_direction ;
   uint16_t loop_id ;
   struct qla_tgt *tgt ;
   struct scsi_qla_host *vha ;
   struct list_head cmd_list ;
   struct atio_from_isp atio ;
};
#line 876 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_orig_iocb_396 {
   struct atio_from_isp atio ;
   struct imm_ntfy_from_isp imm_ntfy ;
   struct abts_recv_from_24xx abts ;
};
#line 876 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_mgmt_cmd {
   uint8_t tmr_func ;
   uint8_t fc_tm_rsp ;
   struct qla_tgt_sess *sess ;
   struct se_cmd se_cmd ;
   struct work_struct free_work ;
   unsigned int flags ;
   union __anonunion_orig_iocb_396 orig_iocb ;
};
#line 12653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type;
#line 12664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___0;
#line 12678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___1;
#line 12689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 12708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef struct Scsi_Host *ldv_func_ret_type___3;
#line 12722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 246 "include/scsi/scsi_transport_fc.h"
struct fc_rport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
};
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct nvram_24xx {
   uint8_t id[4U] ;
   uint16_t nvram_version ;
   uint16_t reserved_0 ;
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t login_retry_count ;
   uint16_t link_down_on_nos ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t seriallink_options[4U] ;
   uint16_t reserved_2[16U] ;
   uint16_t reserved_3[16U] ;
   uint16_t reserved_4[16U] ;
   uint16_t reserved_5[16U] ;
   uint16_t reserved_6[16U] ;
   uint16_t reserved_7[16U] ;
   uint32_t host_p ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t boot_port_name[8U] ;
   uint16_t boot_lun_number ;
   uint16_t reserved_8 ;
   uint8_t alt1_boot_port_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint16_t reserved_9 ;
   uint8_t alt2_boot_port_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint16_t reserved_10 ;
   uint8_t alt3_boot_port_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint16_t reserved_11 ;
   uint32_t efi_parameters ;
   uint8_t reset_delay ;
   uint8_t reserved_12 ;
   uint16_t reserved_13 ;
   uint16_t boot_id_number ;
   uint16_t reserved_14 ;
   uint16_t max_luns_per_target ;
   uint16_t reserved_15 ;
   uint16_t port_down_retry_count ;
   uint16_t link_down_timeout ;
   uint16_t fcode_parameter ;
   uint16_t reserved_16[3U] ;
   uint8_t prev_drv_ver_major ;
   uint8_t prev_drv_ver_submajob ;
   uint8_t prev_drv_ver_minor ;
   uint8_t prev_drv_ver_subminor ;
   uint16_t prev_bios_ver_major ;
   uint16_t prev_bios_ver_minor ;
   uint16_t prev_efi_ver_major ;
   uint16_t prev_efi_ver_minor ;
   uint16_t prev_fw_ver_major ;
   uint8_t prev_fw_ver_minor ;
   uint8_t prev_fw_ver_subminor ;
   uint16_t reserved_17[8U] ;
   uint16_t reserved_18[16U] ;
   uint16_t reserved_19[16U] ;
   uint16_t reserved_20[16U] ;
   uint8_t model_name[16U] ;
   uint16_t reserved_21[2U] ;
   uint16_t pcie_table_sig ;
   uint16_t pcie_table_offset ;
   uint16_t subsystem_vendor_id ;
   uint16_t subsystem_device_id ;
   uint32_t checksum ;
};
#line 265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct init_cb_24xx {
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_outpointer ;
   uint16_t login_retry_count ;
   uint16_t prio_request_q_outpointer ;
   uint16_t response_q_length ;
   uint16_t request_q_length ;
   uint16_t link_down_on_nos ;
   uint16_t prio_request_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint32_t prio_request_q_address[2U] ;
   uint16_t msix ;
   uint16_t msix_atio ;
   uint8_t reserved_2[4U] ;
   uint16_t atio_q_inpointer ;
   uint16_t atio_q_length ;
   uint32_t atio_q_address[2U] ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t qos ;
   uint16_t rid ;
   uint8_t reserved_3[20U] ;
};
#line 1096 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mid_conf_entry_24xx {
   uint16_t reserved_1 ;
   uint8_t options ;
   uint8_t hard_address ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
};
#line 1163 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mid_init_cb_24xx {
   struct init_cb_24xx init_cb ;
   uint16_t count ;
   uint16_t options ;
   struct mid_conf_entry_24xx entries[256U] ;
};
#line 1545 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct nvram_81xx {
   uint8_t id[4U] ;
   uint16_t nvram_version ;
   uint16_t reserved_0 ;
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t reserved_2 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t login_retry_count ;
   uint16_t reserved_3 ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint16_t reserved_4[4U] ;
   uint8_t enode_mac[6U] ;
   uint16_t reserved_5[5U] ;
   uint16_t reserved_6[24U] ;
   uint16_t ex_version ;
   uint8_t prio_fcf_matching_flags ;
   uint8_t reserved_6_1[3U] ;
   uint16_t pri_fcf_vlan_id ;
   uint8_t pri_fcf_fabric_name[8U] ;
   uint16_t reserved_6_2[7U] ;
   uint8_t spma_mac_addr[6U] ;
   uint16_t reserved_6_3[14U] ;
   uint16_t reserved_7[32U] ;
   uint32_t host_p ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t boot_port_name[8U] ;
   uint16_t boot_lun_number ;
   uint16_t reserved_8 ;
   uint8_t alt1_boot_port_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint16_t reserved_9 ;
   uint8_t alt2_boot_port_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint16_t reserved_10 ;
   uint8_t alt3_boot_port_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint16_t reserved_11 ;
   uint32_t efi_parameters ;
   uint8_t reset_delay ;
   uint8_t reserved_12 ;
   uint16_t reserved_13 ;
   uint16_t boot_id_number ;
   uint16_t reserved_14 ;
   uint16_t max_luns_per_target ;
   uint16_t reserved_15 ;
   uint16_t port_down_retry_count ;
   uint16_t link_down_timeout ;
   uint16_t fcode_parameter ;
   uint16_t reserved_16[3U] ;
   uint8_t reserved_17[4U] ;
   uint16_t reserved_18[5U] ;
   uint8_t reserved_19[2U] ;
   uint16_t reserved_20[8U] ;
   uint8_t reserved_21[16U] ;
   uint16_t reserved_22[3U] ;
   uint8_t enhanced_features ;
   uint8_t reserved_23 ;
   uint16_t reserved_24[4U] ;
   uint16_t reserved_25[32U] ;
   uint8_t model_name[16U] ;
   uint16_t feature_mask_l ;
   uint16_t feature_mask_h ;
   uint16_t reserved_26[2U] ;
   uint16_t subsystem_vendor_id ;
   uint16_t subsystem_device_id ;
   uint32_t checksum ;
};
#line 1751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct init_cb_81xx {
   uint16_t version ;
   uint16_t reserved_1 ;
   uint16_t frame_payload_size ;
   uint16_t execution_throttle ;
   uint16_t exchange_count ;
   uint16_t reserved_2 ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint16_t response_q_inpointer ;
   uint16_t request_q_outpointer ;
   uint16_t login_retry_count ;
   uint16_t prio_request_q_outpointer ;
   uint16_t response_q_length ;
   uint16_t request_q_length ;
   uint16_t reserved_3 ;
   uint16_t prio_request_q_length ;
   uint32_t request_q_address[2U] ;
   uint32_t response_q_address[2U] ;
   uint32_t prio_request_q_address[2U] ;
   uint8_t reserved_4[8U] ;
   uint16_t atio_q_inpointer ;
   uint16_t atio_q_length ;
   uint32_t atio_q_address[2U] ;
   uint16_t interrupt_delay_timer ;
   uint16_t login_timeout ;
   uint32_t firmware_options_1 ;
   uint32_t firmware_options_2 ;
   uint32_t firmware_options_3 ;
   uint8_t reserved_5[8U] ;
   uint8_t enode_mac[6U] ;
   uint8_t reserved_6[10U] ;
};
#line 1497 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_nvram_t_244 {
   uint8_t id[4U] ;
   uint8_t nvram_version ;
   uint8_t reserved_0 ;
   uint8_t parameter_block_version ;
   uint8_t reserved_1 ;
   uint8_t firmware_options[2U] ;
   uint16_t frame_payload_size ;
   uint16_t max_iocb_allocation ;
   uint16_t execution_throttle ;
   uint8_t retry_count ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint16_t hard_address ;
   uint8_t inquiry_data ;
   uint8_t login_timeout ;
   uint8_t node_name[8U] ;
   uint8_t add_firmware_options[2U] ;
   uint8_t response_accumulation_timer ;
   uint8_t interrupt_delay_timer ;
   uint8_t special_options[2U] ;
   uint8_t reserved_2[22U] ;
   uint8_t seriallink_options[4U] ;
   uint8_t host_p[2U] ;
   uint8_t boot_node_name[8U] ;
   uint8_t boot_lun_number ;
   uint8_t reset_delay ;
   uint8_t port_down_retry_count ;
   uint8_t boot_id_number ;
   uint16_t max_luns_per_target ;
   uint8_t fcode_boot_port_name[8U] ;
   uint8_t alternate_port_name[8U] ;
   uint8_t alternate_node_name[8U] ;
   uint8_t efi_parameters ;
   uint8_t link_down_timeout ;
   uint8_t adapter_id[16U] ;
   uint8_t alt1_boot_node_name[8U] ;
   uint16_t alt1_boot_lun_number ;
   uint8_t alt2_boot_node_name[8U] ;
   uint16_t alt2_boot_lun_number ;
   uint8_t alt3_boot_node_name[8U] ;
   uint16_t alt3_boot_lun_number ;
   uint8_t alt4_boot_node_name[8U] ;
   uint16_t alt4_boot_lun_number ;
   uint8_t alt5_boot_node_name[8U] ;
   uint16_t alt5_boot_lun_number ;
   uint8_t alt6_boot_node_name[8U] ;
   uint16_t alt6_boot_lun_number ;
   uint8_t alt7_boot_node_name[8U] ;
   uint16_t alt7_boot_lun_number ;
   uint8_t reserved_3[2U] ;
   uint8_t model_number[16U] ;
   uint8_t oem_specific[16U] ;
   uint8_t adapter_features[2U] ;
   uint8_t reserved_4[16U] ;
   uint16_t subsystem_vendor_id_2200 ;
   uint16_t subsystem_device_id_2200 ;
   uint8_t reserved_5 ;
   uint8_t checksum ;
};
#line 1497 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_nvram_t_244 nvram_t;
#line 1965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sw_info_t_264 {
   port_id_t d_id ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint8_t fabric_port_name[8U] ;
   uint16_t fp_speed ;
   uint8_t fc4_type ;
};
#line 1965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sw_info_t_264 sw_info_t;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 550 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct port_database_24xx {
   uint16_t flags ;
   uint8_t current_login_state ;
   uint8_t last_login_state ;
   uint8_t hard_address[3U] ;
   uint8_t reserved_1 ;
   uint8_t port_id[3U] ;
   uint8_t sequence_id ;
   uint16_t port_timer ;
   uint16_t nport_handle ;
   uint16_t receive_data_size ;
   uint16_t reserved_2 ;
   uint8_t prli_svc_param_word_0[2U] ;
   uint8_t prli_svc_param_word_3[2U] ;
   uint8_t port_name[8U] ;
   uint8_t node_name[8U] ;
   uint8_t reserved_3[24U] ;
};
#line 543 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct sts_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t ox_id ;
   uint32_t residual_len ;
   uint16_t reserved_1 ;
   uint16_t state_flags ;
   uint16_t reserved_2 ;
   uint16_t scsi_status ;
   uint32_t rsp_residual_count ;
   uint32_t sense_len ;
   uint32_t rsp_data_len ;
   uint8_t data[28U] ;
};
#line 765 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct logio_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t control_flags ;
   uint8_t vp_index ;
   uint8_t reserved_1 ;
   uint8_t port_id[3U] ;
   uint8_t rsp_size ;
   uint32_t io_parameter[11U] ;
};
#line 811 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct tsk_mgmt_entry {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint16_t delay ;
   uint16_t timeout ;
   struct scsi_lun lun ;
   uint32_t control_flags ;
   uint8_t reserved_2[20U] ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint8_t reserved_3[12U] ;
};
#line 862 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct abort_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t options ;
   uint32_t handle_to_abort ;
   uint16_t req_que_no ;
   uint8_t reserved_1[30U] ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint8_t reserved_2[12U] ;
};
#line 1189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_ctrl_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t vp_idx_failed ;
   uint16_t comp_status ;
   uint16_t command ;
   uint16_t vp_count ;
   uint8_t vp_idx_map[16U] ;
   uint16_t flags ;
   uint16_t id ;
   uint16_t reserved_4 ;
   uint16_t hopct ;
   uint8_t reserved_5[24U] ;
};
#line 1225 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_config_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t flags ;
   uint16_t comp_status ;
   uint8_t command ;
   uint8_t vp_count ;
   uint8_t vp_index1 ;
   uint8_t vp_index2 ;
   uint8_t options_idx1 ;
   uint8_t hard_address_idx1 ;
   uint16_t reserved_vp1 ;
   uint8_t port_name_idx1[8U] ;
   uint8_t node_name_idx1[8U] ;
   uint8_t options_idx2 ;
   uint8_t hard_address_idx2 ;
   uint16_t reserved_vp2 ;
   uint8_t port_name_idx2[8U] ;
   uint8_t node_name_idx2[8U] ;
   uint16_t id ;
   uint16_t reserved_4 ;
   uint16_t hopct ;
   uint8_t reserved_5[2U] ;
};
#line 1275 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct vp_rpt_id_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t vp_count ;
   uint16_t vp_idx ;
   uint8_t port_id[3U] ;
   uint8_t format ;
   uint8_t vp_idx_map[16U] ;
   uint8_t reserved_4[32U] ;
};
#line 1422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct verify_chip_entry_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t options ;
   uint16_t reserved_1 ;
   uint16_t data_seg_cnt ;
   uint16_t reserved_2[3U] ;
   uint32_t fw_ver ;
   uint32_t exchange_address ;
   uint32_t reserved_3[3U] ;
   uint32_t fw_size ;
   uint32_t fw_seq_size ;
   uint32_t relative_offset ;
   uint32_t dseg_address[2U] ;
   uint32_t dseg_length ;
};
#line 1472 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct verify_chip_rsp_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t failure_code ;
   uint16_t reserved_1[4U] ;
   uint32_t fw_ver ;
   uint32_t exchange_address ;
   uint32_t reserved_2[6U] ;
};
#line 396 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct msg_echo_lb {
   dma_addr_t send_dma ;
   dma_addr_t rcv_dma ;
   uint16_t req_sg_cnt ;
   uint16_t rsp_sg_cnt ;
   uint16_t options ;
   uint32_t transfer_size ;
   uint32_t iteration_count ;
};
#line 1074 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_port_database_t_242 {
   uint8_t options ;
   uint8_t control ;
   uint8_t master_state ;
   uint8_t slave_state ;
   uint8_t reserved[2U] ;
   uint8_t hard_address ;
   uint8_t reserved_1 ;
   uint8_t port_id[4U] ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
   uint16_t execution_throttle ;
   uint16_t execution_count ;
   uint8_t reset_count ;
   uint8_t reserved_2 ;
   uint16_t resource_allocation ;
   uint16_t current_allocation ;
   uint16_t queue_head ;
   uint16_t queue_tail ;
   uint16_t transmit_execution_list_next ;
   uint16_t transmit_execution_list_previous ;
   uint16_t common_features ;
   uint16_t total_concurrent_sequences ;
   uint16_t RO_by_information_category ;
   uint8_t recipient ;
   uint8_t initiator ;
   uint16_t receive_data_size ;
   uint16_t concurrent_sequences ;
   uint16_t open_sequences_per_exchange ;
   uint16_t lun_abort_flags ;
   uint16_t lun_stop_flags ;
   uint16_t stop_queue_head ;
   uint16_t stop_queue_tail ;
   uint16_t port_retry_timer ;
   uint16_t next_sequence_id ;
   uint16_t frame_count ;
   uint16_t PRLI_payload_length ;
   uint8_t prli_svc_param_word_0[2U] ;
   uint8_t prli_svc_param_word_3[2U] ;
   uint16_t loop_id ;
   uint16_t extended_lun_info_list_pointer ;
   uint16_t extended_lun_stop_list_pointer ;
};
#line 1074 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_port_database_t_242 port_database_t;
#line 1221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct link_statistics {
   uint32_t link_fail_cnt ;
   uint32_t loss_sync_cnt ;
   uint32_t loss_sig_cnt ;
   uint32_t prim_seq_err_cnt ;
   uint32_t inval_xmit_word_cnt ;
   uint32_t inval_crc_cnt ;
   uint32_t lip_cnt ;
   uint32_t unused1[26U] ;
   uint32_t tx_frames ;
   uint32_t rx_frames ;
   uint32_t discarded_frames ;
   uint32_t dropped_frames ;
   uint32_t unused2[1U] ;
   uint32_t nos_rcvd ;
};
#line 1722 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts_entry_t_256 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t scsi_status ;
   uint16_t comp_status ;
   uint16_t state_flags ;
   uint16_t status_flags ;
   uint16_t rsp_info_len ;
   uint16_t req_sense_length ;
   uint32_t residual_length ;
   uint8_t rsp_info[8U] ;
   uint8_t req_sense_data[32U] ;
};
#line 1722 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts_entry_t_256 sts_entry_t;
#line 832 "include/target/target_core_base.h"
struct qla_port_24xx_data {
   uint8_t port_name[8U] ;
   uint16_t loop_id ;
   uint16_t reserved ;
};
#line 2946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
union __anonunion_p_397 {
   struct tsk_mgmt_entry tsk ;
   struct sts_entry_24xx sts ;
};
#line 2946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
struct tsk_mgmt_cmd {
   union __anonunion_p_397 p ;
};
#line 3769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
union __anonunion_p_398 {
   struct verify_chip_entry_84xx req ;
   struct verify_chip_rsp_84xx rsp ;
};
#line 3769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
struct cs84xx_mgmt_cmd {
   union __anonunion_p_398 p ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 381 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_bidir {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t wr_dseg_count ;
   uint16_t rd_dseg_count ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint16_t reserved[2U] ;
   uint32_t rd_byte_count ;
   uint32_t wr_byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t fcp_data_dseg_address[2U] ;
   uint16_t fcp_data_dseg_len ;
};
#line 422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_6 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t fcp_rsp_dsd_len ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint32_t fcp_rsp_dseg_address[2U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t fcp_data_dseg_address[2U] ;
   uint32_t fcp_data_dseg_len ;
};
#line 460 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_7 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t reserved_1 ;
   struct scsi_lun lun ;
   uint16_t task_mgmt_flags ;
   uint8_t task ;
   uint8_t crn ;
   uint8_t fcp_cdb[16U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
};
#line 507 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct cmd_type_crc_2 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint16_t fcp_rsp_dseg_len ;
   struct scsi_lun lun ;
   uint16_t control_flags ;
   uint16_t fcp_cmnd_dseg_len ;
   uint32_t fcp_cmnd_dseg_address[2U] ;
   uint32_t fcp_rsp_dseg_address[2U] ;
   uint32_t byte_count ;
   uint8_t port_id[3U] ;
   uint8_t vp_index ;
   uint32_t crc_context_address[2U] ;
   uint16_t crc_context_len ;
   uint16_t reserved_1 ;
};
#line 577 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct mrk_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint8_t modifier ;
   uint8_t reserved_1 ;
   uint8_t reserved_2 ;
   uint8_t vp_index ;
   uint16_t reserved_3 ;
   uint8_t lun[8U] ;
   uint8_t reserved_4[40U] ;
};
#line 628 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct ct_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t cmd_dsd_count ;
   uint8_t vp_index ;
   uint8_t reserved_1 ;
   uint16_t timeout ;
   uint16_t reserved_2 ;
   uint16_t rsp_dsd_count ;
   uint8_t reserved_3[10U] ;
   uint32_t rsp_byte_count ;
   uint32_t cmd_byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_len ;
};
#line 665 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct els_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t reserved_1 ;
   uint16_t nport_handle ;
   uint16_t tx_dsd_count ;
   uint8_t vp_index ;
   uint8_t sof_type ;
   uint32_t rx_xchg_address ;
   uint16_t rx_dsd_count ;
   uint8_t opcode ;
   uint8_t reserved_2 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_3 ;
   uint16_t reserved_4 ;
   uint16_t control_flags ;
   uint32_t rx_byte_count ;
   uint32_t tx_byte_count ;
   uint32_t tx_address[2U] ;
   uint32_t tx_len ;
   uint32_t rx_address[2U] ;
   uint32_t rx_len ;
};
#line 1619 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cont_entry_t_251 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t reserved ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
   uint32_t dseg_3_address ;
   uint32_t dseg_3_length ;
   uint32_t dseg_4_address ;
   uint32_t dseg_4_length ;
   uint32_t dseg_5_address ;
   uint32_t dseg_5_length ;
   uint32_t dseg_6_address ;
   uint32_t dseg_6_length ;
};
#line 1619 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cont_entry_t_251 cont_entry_t;
#line 1640 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_cont_a64_entry_t_252 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address[2U] ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address[2U] ;
   uint32_t dseg_2_length ;
   uint32_t dseg_3_address[2U] ;
   uint32_t dseg_3_length ;
   uint32_t dseg_4_address[2U] ;
   uint32_t dseg_4_length ;
};
#line 1640 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_cont_a64_entry_t_252 cont_a64_entry_t;
#line 1851 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_mrk_entry_t_260 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint8_t modifier ;
   uint8_t reserved_1 ;
   uint16_t sequence_number ;
   uint16_t lun ;
   uint8_t reserved_2[48U] ;
};
#line 1851 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_mrk_entry_t_260 mrk_entry_t;
#line 1882 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct mbx_entry {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define1 ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t loop_id ;
   uint16_t status ;
   uint16_t state_flags ;
   uint16_t status_flags ;
   uint32_t sys_define2[2U] ;
   uint16_t mb0 ;
   uint16_t mb1 ;
   uint16_t mb2 ;
   uint16_t mb3 ;
   uint16_t mb6 ;
   uint16_t mb7 ;
   uint16_t mb9 ;
   uint16_t mb10 ;
   uint32_t reserved_2[2U] ;
   uint8_t node_name[8U] ;
   uint8_t port_name[8U] ;
};
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct mrk_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t handle_hi ;
   uint16_t tgt_id ;
   uint8_t modifier ;
   uint8_t reserved_1 ;
   uint8_t reserved_2[5U] ;
   uint8_t lun[8U] ;
   uint8_t reserved_3[36U] ;
};
#line 111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct tsk_mgmt_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   uint32_t handle_hi ;
   __le16 tgt_id ;
   uint16_t reserved_1 ;
   uint16_t delay ;
   __le16 timeout ;
   struct scsi_lun lun ;
   __le32 control_flags ;
   uint8_t reserved_2[32U] ;
};
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct abort_iocb_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   __le32 handle_hi ;
   __le16 tgt_id_sts ;
   __le16 options ;
   __le32 abort_handle ;
   __le32 abort_handle_hi ;
   __le16 req_que_no ;
   uint8_t reserved_1[38U] ;
};
#line 182 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct fxdisc_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   __le32 handle ;
   __le32 reserved_0 ;
   __le16 func_num ;
   __le16 req_xfrcnt ;
   __le16 req_dsdcnt ;
   __le16 rsp_xfrcnt ;
   __le16 rsp_dsdcnt ;
   uint8_t flags ;
   uint8_t reserved_1 ;
   __le32 dseg_rq_address[2U] ;
   __le32 dseg_rq_len ;
   __le32 dseg_rsp_address[2U] ;
   __le32 dseg_rsp_len ;
   __le32 dataword ;
   __le32 adapid ;
   __le32 adapid_hi ;
   __le32 dataword_extra ;
};
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
struct fw_dif_context {
   uint32_t ref_tag ;
   uint16_t app_tag ;
   uint8_t ref_tag_mask[4U] ;
   uint8_t app_tag_mask[2U] ;
};
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
struct qla2_sgx {
   dma_addr_t dma_addr ;
   uint32_t dma_len ;
   uint32_t tot_bytes ;
   struct scatterlist *cur_sg ;
   uint32_t bytes_consumed ;
   uint32_t num_bytes ;
   uint32_t tot_partial ;
   uint32_t num_sg ;
   srb_t *sp ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 717 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct els_sts_entry_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t comp_status ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint8_t vp_index ;
   uint8_t sof_type ;
   uint32_t rx_xchg_address ;
   uint16_t reserved_2 ;
   uint8_t opcode ;
   uint8_t reserved_3 ;
   uint8_t port_id[3U] ;
   uint8_t reserved_4 ;
   uint16_t reserved_5 ;
   uint16_t control_flags ;
   uint32_t total_byte_count ;
   uint32_t error_subcode_1 ;
   uint32_t error_subcode_2 ;
};
#line 1927 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct sd_dif_tuple {
   __be16 guard_tag ;
   __be16 app_tag ;
   __be32 ref_tag ;
};
#line 1801 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts_cont_entry_t_257 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint8_t data[60U] ;
};
#line 1801 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts_cont_entry_t_257 sts_cont_entry_t;
#line 1814 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts21_entry_t_258 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint32_t handle[15U] ;
};
#line 1814 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts21_entry_t_258 sts21_entry_t;
#line 1827 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct __anonstruct_sts22_entry_t_259 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   uint16_t handle[30U] ;
};
#line 1827 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
typedef struct __anonstruct_sts22_entry_t_259 sts22_entry_t;
#line 173 "include/scsi/scsi_tcq.h"
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
#line 3073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
struct qla_init_msix_entry {
   char const   *name ;
   irqreturn_t (*handler)(int  , void * ) ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 134 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_netlink.h"
enum fc_tgtid_binding_type {
    FC_TGTID_BIND_NONE = 0,
    FC_TGTID_BIND_BY_WWPN = 1,
    FC_TGTID_BIND_BY_WWNN = 2,
    FC_TGTID_BIND_BY_ID = 3
} ;
#line 456 "include/scsi/scsi_transport_fc.h"
struct fc_host_attrs {
   u64 node_name ;
   u64 port_name ;
   u64 permanent_port_name ;
   u32 supported_classes ;
   u8 supported_fc4s[32U] ;
   u32 supported_speeds ;
   u32 maxframe_size ;
   u16 max_npiv_vports ;
   char serial_number[80U] ;
   char manufacturer[80U] ;
   char model[256U] ;
   char model_description[256U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char firmware_version[64U] ;
   char optionrom_version[64U] ;
   u32 port_id ;
   enum fc_port_type port_type ;
   enum fc_port_state port_state ;
   u8 active_fc4s[32U] ;
   u32 speed ;
   u64 fabric_name ;
   char symbolic_name[256U] ;
   char system_hostname[256U] ;
   u32 dev_loss_tmo ;
   enum fc_tgtid_binding_type tgtid_bind_type ;
   struct list_head rports ;
   struct list_head rport_bindings ;
   struct list_head vports ;
   u32 next_rport_number ;
   u32 next_target_id ;
   u32 next_vport_number ;
   u16 npiv_vports_inuse ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct request_queue *rqst_q ;
};
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c"
struct __va_list_tag;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c"
typedef struct __va_list_tag __va_list_tag;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 53 "include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 215 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_fce_chain {
   uint32_t type ;
   uint32_t chain_size ;
   uint32_t size ;
   uint32_t addr_l ;
   uint32_t addr_h ;
   uint32_t eregs[8U] ;
};
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mq_chain {
   uint32_t type ;
   uint32_t chain_size ;
   uint32_t count ;
   uint32_t qregs[128U] ;
};
#line 242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mqueue_header {
   uint32_t queue ;
   uint32_t number ;
   uint32_t size ;
};
#line 251 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
struct qla2xxx_mqueue_chain {
   uint32_t type ;
   uint32_t chain_size ;
};
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
struct __anonstruct_aq_308 {
   int length ;
   void *ring ;
};
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
struct __anonstruct_aqp_309 {
   int length ;
   void *ring ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 141 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_netlink.h"
struct fc_vport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   bool disable ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
};
#line 1322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_fdt_layout {
   uint8_t sig[4U] ;
   uint16_t version ;
   uint16_t len ;
   uint16_t checksum ;
   uint8_t unused1[2U] ;
   uint8_t model[16U] ;
   uint16_t man_id ;
   uint16_t id ;
   uint8_t flags ;
   uint8_t erase_cmd ;
   uint8_t alt_erase_cmd ;
   uint8_t wrt_enable_cmd ;
   uint8_t wrt_enable_bits ;
   uint8_t wrt_sts_reg_cmd ;
   uint8_t unprotect_sec_cmd ;
   uint8_t read_man_id_cmd ;
   uint32_t block_size ;
   uint32_t alt_block_size ;
   uint32_t flash_size ;
   uint32_t wrt_enable_data ;
   uint8_t read_id_addr_len ;
   uint8_t wrt_disable_bits ;
   uint8_t read_dev_id_len ;
   uint8_t chip_erase_cmd ;
   uint16_t read_timeout ;
   uint8_t protect_sec_cmd ;
   uint8_t unused2[65U] ;
};
#line 1356 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_location {
   uint8_t sig[4U] ;
   uint16_t start_lo ;
   uint16_t start_hi ;
   uint8_t version ;
   uint8_t unused[5U] ;
   uint16_t checksum ;
};
#line 1367 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_header {
   uint16_t version ;
   uint16_t length ;
   uint16_t checksum ;
   uint16_t unused ;
};
#line 1374 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_flt_region {
   uint32_t code ;
   uint32_t size ;
   uint32_t start ;
   uint32_t end ;
};
#line 1402 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct qla_npiv_header {
   uint8_t sig[2U] ;
   uint16_t version ;
   uint16_t entries ;
   uint16_t unused[4U] ;
   uint16_t checksum ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 356 "include/scsi/scsi_transport_fc.h"
struct fc_starget_attrs {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
};
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
struct sysfs_entry {
   char *name ;
   struct bin_attribute *attr ;
   int is4GBp_only ;
};
#line 259 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_mem_208 {
   uint32_t start_addr ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_config_209 {
   uint32_t id ;
   uint32_t param0 ;
   uint32_t param1 ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_info_210 {
   uint32_t type ;
   uint32_t context ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_u_207 {
   struct __anonstruct_mem_208 mem ;
   struct __anonstruct_config_209 config ;
   struct __anonstruct_info_210 info ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/scsi/scsi_bsg_fc.h"
struct qla84_mgmt_param {
   union __anonunion_u_207 u ;
};
#line 101 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla84_msg_mgmt {
   uint16_t cmd ;
   uint16_t rsrvd ;
   struct qla84_mgmt_param mgmtp ;
   uint32_t len ;
   uint8_t payload[0U] ;
};
#line 147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_bsg_a84_mgmt {
   struct qla84_msg_mgmt mgmt ;
};
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_scsi_addr {
   uint16_t bus ;
   uint16_t target ;
};
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
union __anonunion_dest_addr_211 {
   uint8_t wwnn[8U] ;
   uint8_t wwpn[8U] ;
   uint8_t id[4U] ;
   struct qla_scsi_addr scsi_addr ;
};
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_ext_dest_addr {
   union __anonunion_dest_addr_211 dest_addr ;
   uint16_t dest_type ;
   uint16_t lun ;
   uint16_t padding[2U] ;
};
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_port_param {
   struct qla_ext_dest_addr fc_scsi_addr ;
   uint16_t mode ;
   uint16_t speed ;
};
#line 175 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_field_address {
   uint16_t offset ;
   uint16_t device ;
   uint16_t option ;
};
#line 186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_field_info {
   uint8_t version[36U] ;
};
#line 190 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_image_version {
   struct qla_field_address field_address ;
   struct qla_field_info field_info ;
};
#line 195 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_image_version_list {
   uint32_t count ;
   struct qla_image_version version[0U] ;
};
#line 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_status_reg {
   struct qla_field_address field_address ;
   uint8_t status_reg ;
   uint8_t reserved[7U] ;
};
#line 206 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct qla_i2c_access {
   uint16_t device ;
   uint16_t offset ;
   uint16_t option ;
   uint16_t length ;
   uint8_t buffer[64U] ;
};
#line 1498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_fw.h"
struct access_chip_84xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_defined ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t options ;
   uint16_t reserved1 ;
   uint16_t dseg_count ;
   uint16_t reserved2[3U] ;
   uint32_t parameter1 ;
   uint32_t parameter2 ;
   uint32_t parameter3 ;
   uint32_t reserved3[3U] ;
   uint32_t total_byte_cnt ;
   uint32_t reserved4 ;
   uint32_t dseg_address[2U] ;
   uint32_t dseg_length ;
};
#line 340 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qla_mt_iocb_rqst_fx00 {
   __le32 reserved_0 ;
   __le16 func_type ;
   uint8_t flags ;
   uint8_t reserved_1 ;
   __le32 dataword ;
   __le32 adapid ;
   __le32 adapid_hi ;
   __le32 dataword_extra ;
   __le16 req_len ;
   __le16 reserved_2 ;
   __le16 rsp_len ;
   __le16 reserved_3 ;
};
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 47 "include/linux/pinctrl/devinfo.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 214 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_bsg.h"
struct crb_128M_2M_sub_block_map {
   unsigned int valid ;
   unsigned int start_128M ;
   unsigned int end_128M ;
   unsigned int start_2M ;
};
#line 604 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct crb_128M_2M_block_map {
   struct crb_128M_2M_sub_block_map sub_block[16U] ;
};
#line 608 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct crb_addr_pair {
   long addr ;
   long data ;
};
#line 727 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_uri_table_desc {
   uint32_t findex ;
   uint32_t num_entries ;
   uint32_t entry_size ;
   uint32_t reserved[5U] ;
};
#line 809 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_uri_data_desc {
   uint32_t findex ;
   uint32_t size ;
   uint32_t reserved[5U] ;
};
#line 891 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_template_hdr {
   uint32_t entry_type ;
   uint32_t first_entry_offset ;
   uint32_t size_of_template ;
   uint32_t capture_debug_level ;
   uint32_t num_of_entries ;
   uint32_t version ;
   uint32_t driver_timestamp ;
   uint32_t template_checksum ;
   uint32_t driver_capture_mask ;
   uint32_t driver_info[3U] ;
   uint32_t saved_state_array[16U] ;
   uint32_t capture_size_array[8U] ;
   uint32_t markers_array[8U] ;
   uint32_t num_of_free_entries ;
   uint32_t free_entry_offset ;
   uint32_t total_table_size ;
   uint32_t bkup_table_offset ;
};
#line 1021 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_d_ctrl_212 {
   uint8_t entry_capture_mask ;
   uint8_t entry_code ;
   uint8_t driver_code ;
   uint8_t driver_flags ;
};
#line 1021 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_hdr {
   uint32_t entry_type ;
   uint32_t entry_size ;
   uint32_t entry_capture_size ;
   struct __anonstruct_d_ctrl_212 d_ctrl ;
};
#line 1040 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
typedef struct qla82xx_md_entry_hdr qla82xx_md_entry_hdr_t;
#line 1041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_crb_strd_213 {
   uint8_t addr_stride ;
   uint8_t state_index_a ;
   uint16_t poll_timeout ;
};
#line 1041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_crb_ctrl_214 {
   uint8_t opcode ;
   uint8_t state_index_v ;
   uint8_t shl ;
   uint8_t shr ;
};
#line 1041 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_crb {
   qla82xx_md_entry_hdr_t h ;
   uint32_t addr ;
   struct __anonstruct_crb_strd_213 crb_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   struct __anonstruct_crb_ctrl_214 crb_ctrl ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t value_3 ;
};
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_addr_ctrl_215 {
   uint16_t tag_value_stride ;
   uint16_t init_tag_value ;
};
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_cache_ctrl_216 {
   uint16_t write_value ;
   uint8_t poll_mask ;
   uint8_t poll_wait ;
};
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_read_ctrl_217 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_1 ;
};
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_cache {
   qla82xx_md_entry_hdr_t h ;
   uint32_t tag_reg_addr ;
   struct __anonstruct_addr_ctrl_215 addr_ctrl ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t control_addr ;
   struct __anonstruct_cache_ctrl_216 cache_ctrl ;
   uint32_t read_addr ;
   struct __anonstruct_read_ctrl_217 read_ctrl ;
};
#line 1098 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdocm {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd_0 ;
   uint32_t rsvd_1 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_2 ;
   uint32_t rsvd_3 ;
   uint32_t read_addr ;
   uint32_t read_addr_stride ;
   uint32_t read_addr_cntrl ;
};
#line 1116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdmem {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 1126 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_rdrom {
   qla82xx_md_entry_hdr_t h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 1136 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_mux {
   qla82xx_md_entry_hdr_t h ;
   uint32_t select_addr ;
   uint32_t rsvd_0 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t select_value ;
   uint32_t select_value_stride ;
   uint32_t read_addr ;
   uint32_t rsvd_1 ;
};
#line 1150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_q_strd_218 {
   uint16_t queue_id_stride ;
   uint16_t rsvd_0 ;
};
#line 1150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct __anonstruct_rd_strd_219 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_3 ;
};
#line 1150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
struct qla82xx_md_entry_queue {
   qla82xx_md_entry_hdr_t h ;
   uint32_t select_addr ;
   struct __anonstruct_q_strd_218 q_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_1 ;
   uint32_t rsvd_2 ;
   uint32_t read_addr ;
   struct __anonstruct_rd_strd_219 rd_strd ;
};
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
struct crb_addr_pair___0 {
   long addr ;
   long data ;
};
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 1198 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct init_cb_fx {
   uint16_t version ;
   uint16_t reserved_1[13U] ;
   __le16 request_q_outpointer ;
   __le16 response_q_inpointer ;
   uint16_t reserved_2[2U] ;
   __le16 response_q_length ;
   __le16 request_q_length ;
   uint16_t reserved_3[2U] ;
   __le32 request_q_address[2U] ;
   __le32 response_q_address[2U] ;
   uint16_t reserved_4[4U] ;
   uint8_t response_q_msivec ;
   uint8_t reserved_5[19U] ;
   uint16_t interrupt_delay_timer ;
   uint16_t reserved_6 ;
   uint32_t fwoptions1 ;
   uint32_t fwoptions2 ;
   uint32_t fwoptions3 ;
   uint8_t reserved_7[24U] ;
};
#line 2023 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
struct cmd_type_7_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t handle_hi ;
   __le16 tgt_idx ;
   uint16_t timeout ;
   __le16 dseg_count ;
   uint16_t scsi_rsp_dsd_len ;
   struct scsi_lun lun ;
   uint8_t cntrl_flags ;
   uint8_t task_mgmt_flags ;
   uint8_t task ;
   uint8_t crn ;
   uint8_t fcp_cdb[16U] ;
   __le32 byte_count ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_len ;
};
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct sts_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t handle_hi ;
   __le16 comp_status ;
   uint16_t reserved_0 ;
   __le32 residual_len ;
   uint16_t reserved_1 ;
   uint16_t state_flags ;
   uint16_t reserved_2 ;
   __le16 scsi_status ;
   uint32_t sense_len ;
   uint8_t data[32U] ;
};
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct multi_sts_entry_fx00 {
   uint8_t entry_type ;
   uint8_t sys_define ;
   uint8_t handle_count ;
   uint8_t entry_status ;
   __le32 handles[15U] ;
};
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct ioctl_iocb_entry_fx00 {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint32_t reserved_0 ;
   uint16_t comp_func_num ;
   __le16 fw_iotcl_flags ;
   __le32 dataword_r ;
   uint32_t adapid ;
   uint32_t adapid_hi ;
   uint32_t reserved_1 ;
   __le32 seq_no ;
   uint8_t reserved_2[20U] ;
   uint32_t residuallen ;
   __le32 status ;
};
#line 213 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qlafx00_tgt_node_info {
   uint8_t tgt_node_wwpn[8U] ;
   uint8_t tgt_node_wwnn[8U] ;
   uint32_t tgt_node_state ;
   uint8_t reserved[128U] ;
   uint32_t reserved_1[8U] ;
   uint64_t reserved_2[4U] ;
};
#line 222 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct port_info_data {
   uint8_t port_state ;
   uint8_t port_type ;
   uint16_t port_identifier ;
   uint32_t up_port_state ;
   uint8_t fw_ver_num[32U] ;
   uint8_t portal_attrib ;
   uint16_t host_option ;
   uint8_t reset_delay ;
   uint8_t pdwn_retry_cnt ;
   uint16_t max_luns2tgt ;
   uint8_t risc_ver ;
   uint8_t pconn_option ;
   uint16_t risc_option ;
   uint16_t max_frame_len ;
   uint16_t max_iocb_alloc ;
   uint16_t exec_throttle ;
   uint8_t retry_cnt ;
   uint8_t retry_delay ;
   uint8_t port_name[8U] ;
   uint8_t port_id[3U] ;
   uint8_t link_status ;
   uint8_t plink_rate ;
   uint32_t link_config ;
   uint16_t adap_haddr ;
   uint8_t tgt_disc ;
   uint8_t log_tout ;
   uint8_t node_name[8U] ;
   uint16_t erisc_opt1 ;
   uint8_t resp_acc_tmr ;
   uint8_t intr_del_tmr ;
   uint8_t erisc_opt2 ;
   uint8_t alt_port_name[8U] ;
   uint8_t alt_node_name[8U] ;
   uint8_t link_down_tout ;
   uint8_t conn_type ;
   uint8_t fc_fw_mode ;
   uint32_t uiReserved[48U] ;
};
#line 271 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct host_system_info {
   uint32_t os_type ;
   char sysname[128U] ;
   char nodename[64U] ;
   char release[64U] ;
   char version[64U] ;
   char machine[64U] ;
   char domainname[64U] ;
   char hostdriver[64U] ;
   uint32_t reserved[64U] ;
};
#line 295 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct register_host_info {
   struct host_system_info hsi ;
   uint64_t utc ;
   uint32_t reserved[64U] ;
};
#line 301 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct config_info_data {
   uint8_t product_name[256U] ;
   uint8_t symbolic_name[64U] ;
   uint8_t serial_num[32U] ;
   uint8_t hw_version[16U] ;
   uint8_t fw_version[16U] ;
   uint8_t uboot_version[16U] ;
   uint8_t fru_serial_num[32U] ;
   uint8_t fc_port_count ;
   uint8_t iscsi_port_count ;
   uint8_t reserved1[2U] ;
   uint8_t mode ;
   uint8_t log_level ;
   uint8_t reserved2[2U] ;
   uint32_t log_size ;
   uint8_t tgt_pres_mode ;
   uint8_t iqn_flags ;
   uint8_t lun_mapping ;
   uint64_t adapter_id ;
   uint32_t cluster_key_len ;
   uint8_t cluster_key[16U] ;
   uint64_t cluster_master_id ;
   uint64_t cluster_slave_id ;
   uint8_t cluster_flags ;
   uint32_t enabled_capabilities ;
   uint32_t nominal_temp_value ;
};
#line 449 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_mr.h"
struct qla_mt_iocb_rsp_fx00 {
   uint32_t reserved_1 ;
   uint16_t func_type ;
   __le16 ioctl_flags ;
   __le32 ioctl_data ;
   uint32_t adapid ;
   uint32_t adapid_hi ;
   uint32_t reserved_2 ;
   __le32 seq_number ;
   uint8_t reserved_3[20U] ;
   int32_t res_count ;
   __le32 status ;
};
#line 23 "include/uapi/linux/utsname.h"
struct new_utsname {
   char sysname[65U] ;
   char nodename[65U] ;
   char release[65U] ;
   char version[65U] ;
   char machine[65U] ;
   char domainname[65U] ;
};
#line 21 "include/linux/utsname.h"
struct uts_namespace {
   struct kref kref ;
   struct new_utsname name ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 192 "include/linux/seq_file.h"
enum blk_eh_timer_return;
#line 230 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_reset_entry_hdr {
   uint16_t cmd ;
   uint16_t size ;
   uint16_t count ;
   uint16_t delay ;
};
#line 238 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_poll {
   uint32_t test_mask ;
   uint32_t test_value ;
};
#line 244 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_rmw {
   uint32_t test_mask ;
   uint32_t xor_value ;
   uint32_t or_value ;
   uint8_t shl ;
   uint8_t shr ;
   uint8_t index_a ;
   uint8_t rsvd ;
};
#line 255 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_entry {
   uint32_t arg1 ;
   uint32_t arg2 ;
};
#line 261 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_quad_entry {
   uint32_t dr_addr ;
   uint32_t dr_value ;
   uint32_t ar_addr ;
   uint32_t ar_value ;
};
#line 283 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_d_ctrl_220 {
   uint8_t entry_capture_mask ;
   uint8_t entry_code ;
   uint8_t driver_code ;
   uint8_t driver_flags ;
};
#line 283 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_hdr {
   uint32_t entry_type ;
   uint32_t entry_size ;
   uint32_t entry_capture_size ;
   struct __anonstruct_d_ctrl_220 d_ctrl ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_crb_strd_221 {
   uint8_t addr_stride ;
   uint8_t state_index_a ;
   uint16_t poll_timeout ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_crb_ctrl_222 {
   uint8_t opcode ;
   uint8_t state_index_v ;
   uint8_t shl ;
   uint8_t shr ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_crb {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr ;
   struct __anonstruct_crb_strd_221 crb_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   struct __anonstruct_crb_ctrl_222 crb_ctrl ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t value_3 ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_addr_ctrl_223 {
   uint16_t tag_value_stride ;
   uint16_t init_tag_value ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_cache_ctrl_224 {
   uint16_t write_value ;
   uint8_t poll_mask ;
   uint8_t poll_wait ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_read_ctrl_225 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_1 ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_cache {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t tag_reg_addr ;
   struct __anonstruct_addr_ctrl_223 addr_ctrl ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t control_addr ;
   struct __anonstruct_cache_ctrl_224 cache_ctrl ;
   uint32_t read_addr ;
   struct __anonstruct_read_ctrl_225 read_ctrl ;
};
#line 345 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdocm {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd_0 ;
   uint32_t rsvd_1 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_2 ;
   uint32_t rsvd_3 ;
   uint32_t read_addr ;
   uint32_t read_addr_stride ;
};
#line 358 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmem {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 366 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmem_pex_dma {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t desc_card_addr ;
   uint16_t dma_desc_cmd ;
   uint8_t rsvd[2U] ;
   uint32_t start_dma_cmd ;
   uint8_t rsvd2[12U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 378 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdrom {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t rsvd[6U] ;
   uint32_t read_addr ;
   uint32_t read_data_size ;
};
#line 386 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_mux {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   uint32_t rsvd_0 ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t select_value ;
   uint32_t select_value_stride ;
   uint32_t read_addr ;
   uint32_t rsvd_1 ;
};
#line 399 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_q_strd_226 {
   uint16_t queue_id_stride ;
   uint16_t rsvd_0 ;
};
#line 399 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_rd_strd_227 {
   uint8_t read_addr_stride ;
   uint8_t read_addr_cnt ;
   uint16_t rsvd_3 ;
};
#line 399 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_queue {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   struct __anonstruct_q_strd_226 q_strd ;
   uint32_t data_size ;
   uint32_t op_count ;
   uint32_t rsvd_1 ;
   uint32_t rsvd_2 ;
   uint32_t read_addr ;
   struct __anonstruct_rd_strd_227 rd_strd ;
};
#line 419 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_pollrd {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr ;
   uint32_t read_addr ;
   uint32_t select_value ;
   uint16_t select_value_stride ;
   uint16_t op_count ;
   uint32_t poll_wait ;
   uint32_t poll_mask ;
   uint32_t data_size ;
   uint32_t rsvd_1 ;
};
#line 433 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_rdmux2 {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t select_addr_1 ;
   uint32_t select_addr_2 ;
   uint32_t select_value_1 ;
   uint32_t select_value_2 ;
   uint32_t op_count ;
   uint32_t select_value_mask ;
   uint32_t read_addr ;
   uint8_t select_value_stride ;
   uint8_t data_size ;
   uint8_t rsvd[2U] ;
};
#line 448 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_entry_pollrdmwr {
   struct qla8044_minidump_entry_hdr h ;
   uint32_t addr_1 ;
   uint32_t addr_2 ;
   uint32_t value_1 ;
   uint32_t value_2 ;
   uint32_t poll_wait ;
   uint32_t poll_mask ;
   uint32_t modify_mask ;
   uint32_t data_size ;
};
#line 492 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_minidump_template_hdr {
   uint32_t entry_type ;
   uint32_t first_entry_offset ;
   uint32_t size_of_template ;
   uint32_t capture_debug_level ;
   uint32_t num_of_entries ;
   uint32_t version ;
   uint32_t driver_timestamp ;
   uint32_t checksum ;
   uint32_t driver_capture_mask ;
   uint32_t driver_info_word2 ;
   uint32_t driver_info_word3 ;
   uint32_t driver_info_word4 ;
   uint32_t saved_state_array[16U] ;
   uint32_t capture_size_array[8U] ;
   uint32_t ocm_window_reg[16U] ;
};
#line 539 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct __anonstruct_cmd_228 {
   uint32_t read_data_size ;
   uint8_t rsvd[2U] ;
   uint16_t dma_desc_cmd ;
};
#line 539 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
struct qla8044_pex_dma_descriptor {
   struct __anonstruct_cmd_228 cmd ;
   uint64_t src_addr ;
   uint64_t dma_bus_addr ;
   uint8_t rsvd[24U] ;
};
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 366 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 786 "include/target/target_core_base.h"
struct se_tpg_np {
   struct se_portal_group *tpg_np_parent ;
   struct config_group tpg_np_group ;
};
#line 832 "include/target/target_core_base.h"
struct target_core_fabric_ops {
   struct configfs_subsystem *tf_subsys ;
   char *(*get_fabric_name)(void) ;
   u8 (*get_fabric_proto_ident)(struct se_portal_group * ) ;
   char *(*tpg_get_wwn)(struct se_portal_group * ) ;
   u16 (*tpg_get_tag)(struct se_portal_group * ) ;
   u32 (*tpg_get_default_depth)(struct se_portal_group * ) ;
   u32 (*tpg_get_pr_transport_id)(struct se_portal_group * , struct se_node_acl * ,
                                  struct t10_pr_registration * , int * , unsigned char * ) ;
   u32 (*tpg_get_pr_transport_id_len)(struct se_portal_group * , struct se_node_acl * ,
                                      struct t10_pr_registration * , int * ) ;
   char *(*tpg_parse_pr_out_transport_id)(struct se_portal_group * , char const   * ,
                                          u32 * , char ** ) ;
   int (*tpg_check_demo_mode)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_cache)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_write_protect)(struct se_portal_group * ) ;
   int (*tpg_check_prod_mode_write_protect)(struct se_portal_group * ) ;
   int (*tpg_check_demo_mode_login_only)(struct se_portal_group * ) ;
   struct se_node_acl *(*tpg_alloc_fabric_acl)(struct se_portal_group * ) ;
   void (*tpg_release_fabric_acl)(struct se_portal_group * , struct se_node_acl * ) ;
   u32 (*tpg_get_inst_index)(struct se_portal_group * ) ;
   int (*check_stop_free)(struct se_cmd * ) ;
   void (*release_cmd)(struct se_cmd * ) ;
   void (*put_session)(struct se_session * ) ;
   int (*shutdown_session)(struct se_session * ) ;
   void (*close_session)(struct se_session * ) ;
   u32 (*sess_get_index)(struct se_session * ) ;
   u32 (*sess_get_initiator_sid)(struct se_session * , unsigned char * , u32  ) ;
   int (*write_pending)(struct se_cmd * ) ;
   int (*write_pending_status)(struct se_cmd * ) ;
   void (*set_default_node_attributes)(struct se_node_acl * ) ;
   u32 (*get_task_tag)(struct se_cmd * ) ;
   int (*get_cmd_state)(struct se_cmd * ) ;
   int (*queue_data_in)(struct se_cmd * ) ;
   int (*queue_status)(struct se_cmd * ) ;
   void (*queue_tm_rsp)(struct se_cmd * ) ;
   struct se_wwn *(*fabric_make_wwn)(struct target_fabric_configfs * , struct config_group * ,
                                     char const   * ) ;
   void (*fabric_drop_wwn)(struct se_wwn * ) ;
   struct se_portal_group *(*fabric_make_tpg)(struct se_wwn * , struct config_group * ,
                                              char const   * ) ;
   void (*fabric_drop_tpg)(struct se_portal_group * ) ;
   int (*fabric_post_link)(struct se_portal_group * , struct se_lun * ) ;
   void (*fabric_pre_unlink)(struct se_portal_group * , struct se_lun * ) ;
   struct se_tpg_np *(*fabric_make_np)(struct se_portal_group * , struct config_group * ,
                                       char const   * ) ;
   void (*fabric_drop_np)(struct se_tpg_np * ) ;
   struct se_node_acl *(*fabric_make_nodeacl)(struct se_portal_group * , struct config_group * ,
                                              char const   * ) ;
   void (*fabric_drop_nodeacl)(struct se_node_acl * ) ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp2x_385 {
   uint32_t sys_define_2 ;
   target_id_t target ;
   uint8_t target_id ;
   uint8_t reserved_1 ;
   uint16_t flags ;
   uint16_t resp_code ;
   uint16_t status ;
   uint16_t task_flags ;
   uint16_t seq_id ;
   uint16_t srr_rx_id ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_flags ;
   uint16_t srr_reject_code ;
   uint8_t srr_reject_vendor_uniq ;
   uint8_t srr_reject_code_expl ;
   uint8_t reserved_2[24U] ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_isp24_386 {
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint16_t flags ;
   uint16_t srr_rx_id ;
   uint16_t status ;
   uint8_t status_subcode ;
   uint8_t fw_handle ;
   uint32_t exchange_address ;
   uint32_t srr_rel_offs ;
   uint16_t srr_ui ;
   uint16_t srr_flags ;
   uint8_t reserved_4[19U] ;
   uint8_t vp_index ;
   uint8_t srr_reject_vendor_uniq ;
   uint8_t srr_reject_code_expl ;
   uint8_t srr_reject_code ;
   uint8_t reserved_5[5U] ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_384 {
   struct __anonstruct_isp2x_385 isp2x ;
   struct __anonstruct_isp24_386 isp24 ;
};
#line 180 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct nack_to_isp {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   union __anonunion_u_384 u ;
   uint8_t reserved[2U] ;
   uint16_t ox_id ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio_to_2xxx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   target_id_t target ;
   uint16_t rx_id ;
   uint16_t flags ;
   uint16_t status ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint32_t relative_offset ;
   uint32_t residual ;
   uint16_t reserved_1[3U] ;
   uint16_t scsi_status ;
   uint32_t transfer_length ;
   uint32_t dseg_0_address ;
   uint32_t dseg_0_length ;
   uint32_t dseg_1_address ;
   uint32_t dseg_1_length ;
   uint32_t dseg_2_address ;
   uint32_t dseg_2_length ;
};
#line 416 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_status0_392 {
   uint16_t reserved1 ;
   uint16_t flags ;
   uint32_t residual ;
   uint16_t ox_id ;
   uint16_t scsi_status ;
   uint32_t relative_offset ;
   uint32_t reserved2 ;
   uint32_t transfer_length ;
   uint32_t reserved3 ;
   uint32_t dseg_0_address[2U] ;
   uint32_t dseg_0_length ;
};
#line 416 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct __anonstruct_status1_393 {
   uint16_t sense_length ;
   uint16_t flags ;
   uint32_t residual ;
   uint16_t ox_id ;
   uint16_t scsi_status ;
   uint16_t response_len ;
   uint16_t reserved ;
   uint8_t sense_data[24U] ;
};
#line 416 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_u_391 {
   struct __anonstruct_status0_392 status0 ;
   struct __anonstruct_status1_393 status1 ;
};
#line 416 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio7_to_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t nport_handle ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t vp_index ;
   uint8_t add_flags ;
   uint8_t initiator_id[3U] ;
   uint8_t reserved ;
   uint32_t exchange_addr ;
   union __anonunion_u_391 u ;
};
#line 468 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ctio7_from_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t status ;
   uint16_t timeout ;
   uint16_t dseg_count ;
   uint8_t vp_index ;
   uint8_t reserved1[5U] ;
   uint32_t exchange_address ;
   uint16_t reserved2 ;
   uint16_t flags ;
   uint32_t residual ;
   uint16_t ox_id ;
   uint16_t reserved3 ;
   uint32_t relative_offset ;
   uint8_t reserved4[24U] ;
};
#line 544 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ba_acc_le {
   uint16_t reserved ;
   uint8_t seq_id_last ;
   uint8_t seq_id_valid ;
   uint16_t rx_id ;
   uint16_t ox_id ;
   uint16_t high_seq_cnt ;
   uint16_t low_seq_cnt ;
};
#line 558 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct ba_rjt_le {
   uint8_t vendor_uniq ;
   uint8_t reason_expl ;
   uint8_t reason_code ;
   uint8_t reserved ;
};
#line 567 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_payload_394 {
   struct ba_acc_le ba_acct ;
   struct ba_rjt_le ba_rjt ;
};
#line 567 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_resp_to_24xx {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t reserved_1 ;
   uint16_t nport_handle ;
   uint16_t control_flags ;
   uint8_t vp_index ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   union __anonunion_payload_394 payload ;
   uint32_t reserved_4 ;
   uint32_t exchange_addr_to_abort ;
};
#line 596 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct abts_resp_from_24xx_fw {
   uint8_t entry_type ;
   uint8_t entry_count ;
   uint8_t sys_define ;
   uint8_t entry_status ;
   uint32_t handle ;
   uint16_t compl_status ;
   uint16_t nport_handle ;
   uint16_t reserved_1 ;
   uint8_t reserved_2 ;
   unsigned char reserved_3 : 4 ;
   unsigned char sof_type : 4 ;
   uint32_t exchange_address ;
   struct fcp_hdr_le fcp_hdr_le ;
   uint8_t reserved_4[8U] ;
   uint32_t error_subcode1 ;
   uint32_t error_subcode2 ;
   uint32_t exchange_addr_to_abort ;
};
#line 862 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
union __anonunion_ldv_60976_395 {
   struct abts_recv_from_24xx abts ;
   struct imm_ntfy_from_isp tm_iocb ;
   struct atio_from_isp tm_iocb2 ;
};
#line 862 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_sess_work_param {
   struct list_head sess_works_list_entry ;
   int type ;
   union __anonunion_ldv_60976_395 ldv_60976 ;
};
#line 891 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_prm {
   struct qla_tgt_cmd *cmd ;
   struct qla_tgt *tgt ;
   void *pkt ;
   struct scatterlist *sg ;
   int seg_cnt ;
   int req_cnt ;
   uint16_t rq_result ;
   uint16_t scsi_status ;
   unsigned char *sense_buffer ;
   int sense_buffer_len ;
   int residual ;
   int add_status_pkt ;
};
#line 906 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_srr_imm {
   struct list_head srr_list_entry ;
   int srr_id ;
   struct imm_ntfy_from_isp imm_ntfy ;
};
#line 912 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
struct qla_tgt_srr_ctio {
   struct list_head srr_list_entry ;
   int srr_id ;
   struct qla_tgt_cmd *cmd ;
};
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 358 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 70 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 78
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 80
  return;
}
}
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 115
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 117
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 209
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 212
  return (oldbit);
}
}
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 260
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 264
  return (oldbit);
}
}
#line 326 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 328
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 7 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 355 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 358
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2858;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2858;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2858;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2858;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2858: ;
#line 14
  return (pfo_ret__);
}
}
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 62
extern char *strcpy(char * , char const   * ) ;
#line 63
extern char *strcat(char * , char const   * ) ;
#line 113 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , int  ) ;
#line 276 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ 
  int tmp___0 ;

  {
#line 280
  tmp___0 = __bitmap_weight(src, nbits);
#line 280
  return (tmp___0);
}
}
#line 28 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 459 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 461
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nr_cpu_ids);
#line 461
  return ((unsigned int )tmp);
}
}
#line 802 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 804
  if (tmp != 0L) {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
    ldv_4635: ;
#line 804
    goto ldv_4635;
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 34
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 654 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 656
  __asm__  volatile   ("rep; nop": : : "memory");
#line 657
  return;
}
}
#line 659 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
#line 661
  rep_nop();
#line 662
  return;
}
}
#line 11 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 93 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 105 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 109
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 123
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 126
  return ((unsigned int )c != 0U);
}
}
#line 203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 208
  switch (8UL) {
  case 1UL: 
#line 208
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 208
  goto ldv_5675;
  case 2UL: 
#line 208
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 208
  goto ldv_5675;
  case 4UL: 
#line 208
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 208
  goto ldv_5675;
  case 8UL: 
#line 208
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 208
  goto ldv_5675;
  default: 
#line 208
  __bad_percpu_size();
  }
  ldv_5675: 
#line 208
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 210
  return (ti);
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 277
  first = list->next;
#line 278
  last = list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
#line 285
  return;
}
}
#line 292 "include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 295
  tmp = list_empty(list);
#line 295
  if (tmp == 0) {
#line 296
    __list_splice(list, head, head->next);
  } else {

  }
#line 297
  return;
}
}
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
#line 321
  if (tmp == 0) {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
  } else {

  }
#line 325
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 280 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 282
  return (& lock->ldv_6105.rlock);
}
}
#line 346 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 348
  _raw_spin_unlock_irqrestore(& lock->ldv_6105.rlock, flags);
#line 349
  return;
}
}
#line 67 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 94
extern void complete(struct completion * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 175 "include/linux/timer.h"
extern int del_timer(struct timer_list * ) ;
#line 178
int ldv_del_timer_1(struct timer_list *ldv_func_arg1 ) ;
#line 180
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 183
int ldv_mod_timer_3(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 240
extern void add_timer(struct timer_list * ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 248
int ldv_del_timer_sync_4(struct timer_list *ldv_func_arg1 ) ;
#line 192 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 397
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 460
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 467
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 474
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 483
extern bool cancel_work_sync(struct work_struct * ) ;
#line 507 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 510
  tmp = queue_work_on(4096, wq, work);
#line 510
  return (tmp);
}
}
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 54
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
#line 54
  return (ret);
}
}
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
#line 62
  __asm__  volatile   ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
#line 63
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 174
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 184
  tmp = ioremap_nocache(offset, size);
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 79 "include/linux/vmalloc.h"
extern void vfree(void const   * ) ;
#line 108 "include/linux/slab.h"
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 114
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 135
extern void kfree(void const   * ) ;
#line 295
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 84 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 86
  return ((char const   *)kobj->name);
}
}
#line 211
extern int kobject_uevent_env(struct kobject * , enum kobject_action  , char ** ) ;
#line 389 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 406
  tmp___2 = __kmalloc(size, flags);
#line 406
  return (tmp___2);
}
}
#line 636 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 638
  tmp = kmalloc(size, flags | 32768U);
#line 638
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 20
extern loff_t __VERIFIER_nondet_loff_t(void) ;
#line 25
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_fw_dump_attr_group0  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_47  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_20  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla2300_isp_ops_group0  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_3  =    0;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_12  =    0;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla24xx_isp_ops_group2  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_beacon_group0  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla81xx_isp_ops_group0  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_54  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_14  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_37  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_17  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_51  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_11  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qlafx00_isp_ops_group0  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_7  =    0;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_66  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_19  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_27  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_9  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_42  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_7  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_1  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla83xx_isp_ops_group2  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_55  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_rport *qla2xxx_transport_vport_functions_group2  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_6  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_bsg_job *qla2xxx_transport_vport_functions_group1  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_transport_vport_functions_group0  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_64  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_26  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_28  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_17  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla8044_isp_ops_group2  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_58  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_fw_dump_attr_group2  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_31  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_68  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_rport *qla2xxx_transport_functions_group2  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_5  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_8  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_46  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_15  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_11  =    0;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla8044_isp_ops_group1  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_21  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_33  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla25xx_isp_ops_group2  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_69  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla81xx_isp_ops_group1  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_9  =    0;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_65  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_6  =    0;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla82xx_isp_ops_group1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct pci_dev *qla2xxx_pci_driver_group0  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_10  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_optrom_attr_group0  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_70  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qlafx00_isp_ops_group1  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_62  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_41  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_40  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_17  =    0;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_10  =    0;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_zio_group1  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_zio_timer_group1  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_10  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_vpd_attr_group0  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct inode *dfs_fce_ops_group1  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_63  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *sysfs_nvram_attr_group0  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_2  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_25  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_optrom_attr_group1  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_device *qla2xxx_driver_template_group2  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_9  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct pci_dev *qla2xxx_err_handler_group0  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_11  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_18  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device_attribute *dev_attr_beacon_group1  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_13  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_32  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_5  =    0;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla25xx_isp_ops_group1  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_target *qla2xxx_transport_vport_functions_group3  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_4  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla24xx_isp_ops_group0  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_30  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_0  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_45  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_12  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla2100_isp_ops_group1  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_16  =    0;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_22  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_16  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla2300_isp_ops_group2  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_29  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qlafx00_isp_ops_group2  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_transport_functions_group0  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_61  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla82xx_isp_ops_group0  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_8  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ref_cnt  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_23  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_72  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_8  =    0;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_59  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_vpd_attr_group1  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_6  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_12  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_50  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_44  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_38  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_39  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_2  =    0;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_56  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_3  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_nvram_attr_group1  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_52  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_target *qla2xxx_transport_functions_group3  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_4  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *apidev_fops_group2  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_36  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_60  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_zio_timer_group0  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla83xx_isp_ops_group1  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_48  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_3  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_5  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_13  ;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla2300_isp_ops_group1  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla81xx_isp_ops_group2  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla2100_isp_ops_group0  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_cmnd *qla2xxx_driver_template_group0  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_port *qla24xx_isp_ops_group1  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla82xx_isp_ops_group2  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla25xx_isp_ops_group0  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_14  =    0;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_optrom_attr_group2  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_15  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_49  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct device *dev_attr_zio_group0  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_24  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_4  =    0;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct file *dfs_fce_ops_group2  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_1  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_7  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *qla2xxx_driver_template_group1  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_14  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla83xx_isp_ops_group0  ;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_71  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_bsg_job *qla2xxx_transport_functions_group1  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct qla_hw_data *qla2100_isp_ops_group2  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct bin_attribute *sysfs_fw_dump_attr_group1  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_16  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_43  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_vpd_attr_group2  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_57  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct kobject *sysfs_nvram_attr_group2  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fc_vport *qla2xxx_transport_functions_group4  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_53  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_67  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_15  =    0;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_13  =    0;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct timer_list *ldv_timer_list_2  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_timer_state_1  =    0;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_34  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla8044_isp_ops_group0  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void *apidev_fops_group1  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_state_variable_35  ;
#line 211
int reg_timer_7(struct timer_list *timer ) ;
#line 214
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 219
void ldv_initialize_bin_attribute_55(void) ;
#line 221
void ldv_initialize_bin_attribute_58(void) ;
#line 226
void choose_timer_1(struct timer_list *timer ) ;
#line 228
void choose_timer_2(struct timer_list *timer ) ;
#line 229
int reg_timer_2(struct timer_list *timer ) ;
#line 231
void ldv_initialize_isp_operations_65(void) ;
#line 233
void disable_suitable_timer_7(struct timer_list *timer ) ;
#line 236
void ldv_initialize_isp_operations_68(void) ;
#line 239
void ldv_initialize_isp_operations_70(void) ;
#line 244
void ldv_initialize_pci_error_handlers_62(void) ;
#line 247
void ldv_initialize_scsi_host_template_72(void) ;
#line 248
void ldv_initialize_isp_operations_66(void) ;
#line 249
void ldv_initialize_isp_operations_63(void) ;
#line 252
void ldv_initialize_bin_attribute_59(void) ;
#line 253
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 256
void ldv_initialize_isp_operations_64(void) ;
#line 257
void ldv_initialize_fc_function_template_19(void) ;
#line 258
void ldv_initialize_isp_operations_71(void) ;
#line 261
void ldv_file_operations_60(void) ;
#line 263
void ldv_initialize_device_attribute_41(void) ;
#line 265
void ldv_initialize_fc_function_template_20(void) ;
#line 267
int reg_timer_1(struct timer_list *timer ) ;
#line 268
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 275
void ldv_initialize_isp_operations_67(void) ;
#line 281
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 285
void ldv_file_operations_18(void) ;
#line 288
void disable_suitable_timer_1(struct timer_list *timer ) ;
#line 292
void ldv_initialize_pci_driver_61(void) ;
#line 293
void ldv_initialize_device_attribute_40(void) ;
#line 296
void ldv_initialize_device_attribute_39(void) ;
#line 299
void ldv_initialize_bin_attribute_57(void) ;
#line 300
void ldv_initialize_isp_operations_69(void) ;
#line 783 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 786
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 787
    return ((char const   *)dev->init_name);
  } else {

  }
#line 789
  tmp = kobject_name(& dev->kobj);
#line 789
  return (tmp);
}
}
#line 898
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 899
extern int dev_set_drvdata(struct device * , void * ) ;
#line 386 "include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 


  {
#line 388
  return (pdev->error_state != 1U);
}
}
#line 769
extern void pci_dev_put(struct pci_dev * ) ;
#line 803
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
#line 813
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 815
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 827 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 829
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 829
  return (tmp);
}
}
#line 831 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 833
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 833
  return (tmp);
}
}
#line 895
extern int pci_enable_device(struct pci_dev * ) ;
#line 897
extern int pci_enable_device_mem(struct pci_dev * ) ;
#line 912
extern void pci_disable_device(struct pci_dev * ) ;
#line 952
extern int pci_select_bars(struct pci_dev * , unsigned long  ) ;
#line 963
extern int pci_save_state(struct pci_dev * ) ;
#line 964
extern void pci_restore_state(struct pci_dev * ) ;
#line 1040
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1042
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 1071
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1080
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 17 "include/asm-generic/scatterlist.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 20 "include/linux/dmapool.h"
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 22
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 25
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ 
  struct pci_sysdata *sd ;

  {
#line 39
  sd = (struct pci_sysdata *)bus->sysdata;
#line 40
  return (sd->domain);
}
}
#line 63 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 65
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 70 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 50 "include/linux/dma-debug.h"
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 59 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 65
  if (tmp___1 != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
    ldv_21314: ;
#line 65
    goto ldv_21314;
  } else {

  }
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 69
  return;
}
}
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/dma-mapping.h",
                       166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 91 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 93
  tmp = dma_supported(dev, mask);
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 100
extern u64 dma_get_required_mask(struct device * ) ;
#line 110 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 112
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 112
  return (tmp);
}
}
#line 1499 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1501
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1501
  return (tmp);
}
}
#line 1504 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1506
  dev_set_drvdata(& pdev->dev, data);
#line 1507
  return;
}
}
#line 1512 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1514
  tmp = dev_name(& pdev->dev);
#line 1514
  return (tmp);
}
}
#line 1743 "include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1745
  return ((int )dev->pcie_cap);
}
}
#line 302 "include/linux/sched.h"
extern void schedule(void) ;
#line 1889
extern void set_user_nice(struct task_struct * , long  ) ;
#line 1971
extern int wake_up_process(struct task_struct * ) ;
#line 26 "include/linux/mempool.h"
extern mempool_t *mempool_create(int  , mempool_alloc_t * , mempool_free_t * , void * ) ;
#line 33
extern void mempool_destroy(mempool_t * ) ;
#line 34
extern void *mempool_alloc(mempool_t * , gfp_t  ) ;
#line 35
extern void mempool_free(void * , mempool_t * ) ;
#line 41
extern void *mempool_alloc_slab(gfp_t  , void * ) ;
#line 42
extern void mempool_free_slab(void * , void * ) ;
#line 44 "include/linux/mempool.h"
__inline static mempool_t *mempool_create_slab_pool(int min_nr , struct kmem_cache *kc ) 
{ 
  mempool_t *tmp ;

  {
#line 46
  tmp = mempool_create(min_nr, & mempool_alloc_slab, & mempool_free_slab, (void *)kc);
#line 46
  return (tmp);
}
}
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 38 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 39
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 40
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 752 "include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 754
  return ((void *)(& shost->hostdata));
}
}
#line 780
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 783
struct Scsi_Host *ldv_scsi_host_alloc_6(struct scsi_host_template *sht , int privsize ) ;
#line 785
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 790
int ldv_scsi_add_host_with_dma_2(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 792
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 794
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 797
void ldv_scsi_remove_host_5(struct Scsi_Host *shost ) ;
#line 799
extern struct Scsi_Host *scsi_host_get(struct Scsi_Host * ) ;
#line 800
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 807 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ 
  int tmp ;

  {
#line 810
  tmp = ldv_scsi_add_host_with_dma_2(host, dev, dev);
#line 810
  return (tmp);
}
}
#line 856 "include/scsi/scsi_host.h"
__inline static void scsi_host_set_prot(struct Scsi_Host *shost , unsigned int mask ) 
{ 


  {
#line 858
  shost->prot_capabilities = mask;
#line 859
  return;
}
}
#line 914 "include/scsi/scsi_host.h"
__inline static void scsi_host_set_guard(struct Scsi_Host *shost , unsigned char type ) 
{ 


  {
#line 916
  shost->prot_guard_type = type;
#line 917
  return;
}
}
#line 2133 "include/linux/fs.h"
extern int __register_chrdev(unsigned int  , unsigned int  , unsigned int  , char const   * ,
                             struct file_operations  const  * ) ;
#line 2136
extern void __unregister_chrdev(unsigned int  , unsigned int  , unsigned int  , char const   * ) ;
#line 2141 "include/linux/fs.h"
__inline static int register_chrdev(unsigned int major , char const   *name , struct file_operations  const  *fops ) 
{ 
  int tmp ;

  {
#line 2144
  tmp = __register_chrdev(major, 0U, 256U, name, fops);
#line 2144
  return (tmp);
}
}
#line 2150
__inline static int ldv_register_chrdev_7(unsigned int major , char const   *name ,
                                          struct file_operations  const  *fops ) ;
#line 2151 "include/linux/fs.h"
__inline static void unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 2153
  __unregister_chrdev(major, 0U, 256U, name);
#line 2154
  return;
}
}
#line 2165
__inline static void ldv_unregister_chrdev_8(unsigned int major , char const   *name ) ;
#line 2436
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 950 "include/linux/blkdev.h"
extern void blk_queue_update_dma_alignment(struct request_queue * , int  ) ;
#line 1052
extern int blk_queue_init_tags(struct request_queue * , int  , struct blk_queue_tag * ) ;
#line 1053
extern void blk_queue_free_tags(struct request_queue * ) ;
#line 295 "include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 297
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 297
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 330
extern struct scsi_device *__scsi_iterate_devices(struct Scsi_Host * , struct scsi_device * ) ;
#line 363
extern void scsi_adjust_queue_depth(struct scsi_device * , int  , int  ) ;
#line 364
extern int scsi_track_queue_full(struct scsi_device * , int  ) ;
#line 156 "include/scsi/scsi_cmnd.h"
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 246 "include/scsi/scsi_cmnd.h"
__inline static unsigned char scsi_get_prot_op(struct scsi_cmnd *scmd ) 
{ 


  {
#line 248
  return (scmd->prot_op);
}
}
#line 279 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_prot_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 281
  return ((unsigned long )cmd->prot_sdb != (unsigned long )((struct scsi_data_buffer *)0) ? (cmd->prot_sdb)->table.nents : 0U);
}
}
#line 284 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_prot_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 286
  return ((unsigned long )cmd->prot_sdb != (unsigned long )((struct scsi_data_buffer *)0) ? (cmd->prot_sdb)->table.sgl : (struct scatterlist *)0);
}
}
#line 766 "include/scsi/scsi_transport_fc.h"
__inline static int fc_remote_port_chkready(struct fc_rport *rport ) 
{ 
  int result ;

  {
#line 770
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
#line 772
  if ((int )rport->roles & 1) {
#line 773
    result = 0;
  } else
#line 774
  if ((int )rport->flags & 1) {
#line 775
    result = 786432;
  } else {
#line 777
    result = 65536;
  }
#line 778
  goto ldv_38675;
  case 4U: ;
#line 780
  if (((int )rport->flags & 4) != 0) {
#line 781
    result = 983040;
  } else {
#line 783
    result = 786432;
  }
#line 784
  goto ldv_38675;
  default: 
#line 786
  result = 65536;
#line 787
  goto ldv_38675;
  }
  ldv_38675: ;
#line 789
  return (result);
}
}
#line 832
extern struct scsi_transport_template *fc_attach_transport(struct fc_function_template * ) ;
#line 834
extern void fc_release_transport(struct scsi_transport_template * ) ;
#line 835
extern void fc_remove_host(struct Scsi_Host * ) ;
#line 838
extern void fc_remote_port_delete(struct fc_rport * ) ;
#line 840
extern int scsi_is_fc_rport(struct device  const  * ) ;
#line 841
extern u32 fc_get_event_number(void) ;
#line 842
extern void fc_host_post_event(struct Scsi_Host * , u32  , enum fc_host_event_code  ,
                               u32  ) ;
#line 852
extern int fc_vport_terminate(struct fc_vport * ) ;
#line 853
extern int fc_block_scsi_eh(struct scsi_cmnd * ) ;
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla2x00_initialize_adapter(scsi_qla_host_t *vha ) ;
#line 17
int qla2100_pci_config(struct scsi_qla_host *vha ) ;
#line 18
int qla2300_pci_config(struct scsi_qla_host *vha ) ;
#line 19
int qla24xx_pci_config(scsi_qla_host_t *vha ) ;
#line 20
int qla25xx_pci_config(scsi_qla_host_t *vha ) ;
#line 21
void qla2x00_reset_chip(struct scsi_qla_host *vha ) ;
#line 22
void qla24xx_reset_chip(struct scsi_qla_host *vha ) ;
#line 23
int qla2x00_chip_diag(struct scsi_qla_host *vha ) ;
#line 24
int qla24xx_chip_diag(struct scsi_qla_host *vha ) ;
#line 25
void qla2x00_config_rings(struct scsi_qla_host *vha ) ;
#line 26
void qla24xx_config_rings(struct scsi_qla_host *vha ) ;
#line 27
void qla2x00_reset_adapter(struct scsi_qla_host *vha ) ;
#line 28
void qla24xx_reset_adapter(struct scsi_qla_host *vha ) ;
#line 29
int qla2x00_nvram_config(struct scsi_qla_host *vha ) ;
#line 30
int qla24xx_nvram_config(struct scsi_qla_host *vha ) ;
#line 31
int qla81xx_nvram_config(struct scsi_qla_host *vha ) ;
#line 32
void qla2x00_update_fw_options(struct scsi_qla_host *vha ) ;
#line 33
void qla24xx_update_fw_options(scsi_qla_host_t *vha ) ;
#line 34
void qla81xx_update_fw_options(scsi_qla_host_t *vha ) ;
#line 35
int qla2x00_load_risc(struct scsi_qla_host *vha , uint32_t *srisc_addr ) ;
#line 36
int qla24xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 37
int qla81xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 39
int qla2x00_perform_loop_resync(scsi_qla_host_t *ha ) ;
#line 40
int qla2x00_loop_resync(scsi_qla_host_t *vha ) ;
#line 42
int qla2x00_find_new_loop_id(scsi_qla_host_t *vha , fc_port_t *dev ) ;
#line 44
int qla2x00_fabric_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) ;
#line 45
int qla2x00_local_device_login(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 47
void qla2x00_update_fcports(scsi_qla_host_t *base_vha ) ;
#line 49
int qla2x00_abort_isp(scsi_qla_host_t *vha ) ;
#line 50
void qla2x00_abort_isp_cleanup(scsi_qla_host_t *vha ) ;
#line 51
void qla2x00_quiesce_io(scsi_qla_host_t *vha ) ;
#line 53
void qla2x00_update_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 56
void qla2x00_try_to_stop_firmware(scsi_qla_host_t *vha ) ;
#line 60
void qla84xx_put_chip(struct scsi_qla_host *vha ) ;
#line 62
int qla2x00_async_login(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 64
int qla2x00_async_logout(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 65
int qla2x00_async_adisc(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 68
void qla2x00_async_login_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 70
void qla2x00_async_logout_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 72
void qla2x00_async_adisc_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) ;
#line 80
int __qla83xx_set_idc_control(scsi_qla_host_t *vha , uint32_t idc_control ) ;
#line 81
int __qla83xx_get_idc_control(scsi_qla_host_t *vha , uint32_t *idc_control ) ;
#line 82
void qla83xx_idc_audit(scsi_qla_host_t *vha , int audit_type ) ;
#line 83
int qla83xx_nic_core_reset(scsi_qla_host_t *vha ) ;
#line 84
void qla83xx_reset_ownership(scsi_qla_host_t *vha ) ;
#line 85
int qla2xxx_mctp_dump(scsi_qla_host_t *vha ) ;
#line 94 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
char qla2x00_version_str[40U]  ;
#line 96
int ql2xlogintimeout ;
#line 97 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qlport_down_retry  ;
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xplogiabsentdevice  ;
#line 99
int ql2xloginretrycount ;
#line 100
int ql2xfdmienable ;
#line 101
int ql2xmaxqdepth ;
#line 102
int ql2xallocfwdump ;
#line 103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xextended_error_logging  ;
#line 104
int ql2xiidmaenable ;
#line 105
int ql2xmaxqueues ;
#line 106 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xmultique_tag  ;
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xfwloadbin  ;
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xetsenable  ;
#line 109
int ql2xshiftctondsd ;
#line 110
int ql2xdbwr ;
#line 111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xasynctmfenable  ;
#line 112 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xgffidenable  ;
#line 113
int ql2xenabledif ;
#line 114
int ql2xenablehba_err_chk ;
#line 115
int ql2xtargetreset ;
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int ql2xdontresethba  ;
#line 117
unsigned int ql2xmaxlun ;
#line 118
int ql2xmdcapmask ;
#line 119
int ql2xmdenable ;
#line 121
int qla2x00_loop_reset(scsi_qla_host_t *vha ) ;
#line 122
void qla2x00_abort_all_cmds(scsi_qla_host_t *vha , int res ) ;
#line 123
int qla2x00_post_aen_work(struct scsi_qla_host *vha , enum fc_host_event_code code ,
                          u32 data ) ;
#line 125
int qla2x00_post_idc_ack_work(struct scsi_qla_host *vha , uint16_t *mb ) ;
#line 126
int qla2x00_post_async_login_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) ;
#line 128
int qla2x00_post_async_login_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) ;
#line 130
int qla2x00_post_async_logout_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                   uint16_t *data ) ;
#line 132
int qla2x00_post_async_logout_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                        uint16_t *data ) ;
#line 134
int qla2x00_post_async_adisc_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) ;
#line 136
int qla2x00_post_async_adisc_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) ;
#line 141
struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht , struct qla_hw_data *ha ) ;
#line 144
void qla2x00_relogin(struct scsi_qla_host *vha ) ;
#line 145
void qla2x00_do_work(struct scsi_qla_host *vha ) ;
#line 146
void qla2x00_free_fcports(struct scsi_qla_host *vha ) ;
#line 148
void qla83xx_schedule_work(scsi_qla_host_t *base_vha , int work_code ) ;
#line 149
void qla83xx_service_idc_aen(struct work_struct *work ) ;
#line 150
void qla83xx_nic_core_unrecoverable_work(struct work_struct *work ) ;
#line 151
void qla83xx_idc_state_handler_work(struct work_struct *work ) ;
#line 152
void qla83xx_nic_core_reset_work(struct work_struct *work ) ;
#line 154
void qla83xx_idc_lock(scsi_qla_host_t *base_vha , uint16_t requester_id ) ;
#line 155
void qla83xx_idc_unlock(scsi_qla_host_t *base_vha , uint16_t requester_id ) ;
#line 156
int qla83xx_idc_state_handler(scsi_qla_host_t *base_vha ) ;
#line 157
int qla83xx_set_drv_presence(scsi_qla_host_t *vha ) ;
#line 158
int __qla83xx_set_drv_presence(scsi_qla_host_t *vha ) ;
#line 159
int qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) ;
#line 160
int __qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) ;
#line 161
int qla2x00_post_uevent_work(struct scsi_qla_host *vha , u32 code ) ;
#line 166
struct scsi_host_template qla2xxx_driver_template ;
#line 167
struct scsi_transport_template *qla2xxx_transport_vport_template ;
#line 168
void qla2x00_timer(scsi_qla_host_t *vha ) ;
#line 169
__inline void qla2x00_start_timer(scsi_qla_host_t *vha , void *func , unsigned long interval ) ;
#line 175
int qla2x00_send_change_request(scsi_qla_host_t *vha , uint16_t format , uint16_t vp_idx ) ;
#line 180
void qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha ) ;
#line 184
void qla2x00_sp_free_dma(void *vha , void *ptr ) ;
#line 187
void qla2x00_mark_device_lost(scsi_qla_host_t *vha , fc_port_t *fcport , int do_login ,
                              int defer ) ;
#line 188
void qla2x00_mark_all_devices_lost(scsi_qla_host_t *vha , int defer ) ;
#line 190
struct fw_blob *qla2x00_request_firmware(scsi_qla_host_t *vha ) ;
#line 192
int qla2x00_wait_for_hba_online(scsi_qla_host_t *vha ) ;
#line 193
int qla2x00_wait_for_chip_reset(scsi_qla_host_t *vha ) ;
#line 196
void qla2xxx_wake_dpc(struct scsi_qla_host *vha ) ;
#line 200
int qla2x00_vp_abort_isp(scsi_qla_host_t *vha ) ;
#line 206
uint16_t qla2x00_calc_iocbs_32(uint16_t dsds ) ;
#line 207
uint16_t qla2x00_calc_iocbs_64(uint16_t dsds ) ;
#line 208
void qla2x00_build_scsi_iocbs_32(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) ;
#line 209
void qla2x00_build_scsi_iocbs_64(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) ;
#line 210
int qla2x00_start_scsi(srb_t *sp ) ;
#line 211
int qla24xx_start_scsi(srb_t *sp ) ;
#line 215
int qla24xx_dif_start_scsi(srb_t *sp ) ;
#line 253
int qla2x00_abort_command(srb_t *sp ) ;
#line 256
int qla2x00_abort_target(struct fc_port *fcport , unsigned int l , int tag ) ;
#line 259
int qla2x00_lun_reset(struct fc_port *fcport , unsigned int l , int tag ) ;
#line 275
int qla2x00_get_port_database(scsi_qla_host_t *vha , fc_port_t *fcport , uint8_t opt ) ;
#line 287
int qla2x00_lip_reset(scsi_qla_host_t *vha ) ;
#line 293
int qla2x00_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) ;
#line 296
int qla24xx_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) ;
#line 304
int qla2x00_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) ;
#line 307
int qla24xx_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) ;
#line 310
int qla2x00_full_login_lip(scsi_qla_host_t *vha ) ;
#line 330
int qla24xx_abort_command(srb_t *sp ) ;
#line 332
int qla24xx_abort_target(struct fc_port *fcport , unsigned int l , int tag ) ;
#line 334
int qla24xx_lun_reset(struct fc_port *fcport , unsigned int l , int tag ) ;
#line 336
int qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha , unsigned int t , unsigned int l ,
                                         enum nexus_wait_type type ) ;
#line 350
int qla2x00_disable_eft_trace(scsi_qla_host_t *vha ) ;
#line 357
int qla2x00_disable_fce_trace(scsi_qla_host_t *vha , uint64_t *wr , uint64_t *rd ) ;
#line 378
int qla81xx_idc_ack(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 421
irqreturn_t qla2100_intr_handler(int irq , void *dev_id ) ;
#line 422
irqreturn_t qla2300_intr_handler(int irq , void *dev_id ) ;
#line 423
irqreturn_t qla24xx_intr_handler(int irq , void *dev_id ) ;
#line 427
int qla2x00_request_irqs(struct qla_hw_data *ha , struct rsp_que *rsp ) ;
#line 428
void qla2x00_free_irqs(scsi_qla_host_t *vha ) ;
#line 445
uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 447
uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 449
int qla2x00_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 451
int qla24xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 453
uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) ;
#line 455
int qla25xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) ;
#line 459
int qla2x00_beacon_on(struct scsi_qla_host *vha ) ;
#line 460
int qla2x00_beacon_off(struct scsi_qla_host *vha ) ;
#line 461
void qla2x00_beacon_blink(struct scsi_qla_host *vha ) ;
#line 462
int qla24xx_beacon_on(struct scsi_qla_host *vha ) ;
#line 463
int qla24xx_beacon_off(struct scsi_qla_host *vha ) ;
#line 464
void qla24xx_beacon_blink(struct scsi_qla_host *vha ) ;
#line 465
void qla83xx_beacon_blink(struct scsi_qla_host *vha ) ;
#line 466
int qla82xx_beacon_on(struct scsi_qla_host *vha ) ;
#line 467
int qla82xx_beacon_off(struct scsi_qla_host *vha ) ;
#line 468
int qla83xx_wr_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t data ) ;
#line 469
int qla83xx_rd_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t *data ) ;
#line 470
int qla83xx_restart_nic_firmware(scsi_qla_host_t *vha ) ;
#line 471
int qla83xx_access_control(scsi_qla_host_t *vha , uint16_t options , uint32_t start_addr ,
                           uint32_t end_addr , uint16_t *sector_size ) ;
#line 474
uint8_t *qla2x00_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 476
int qla2x00_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 478
uint8_t *qla24xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 480
int qla24xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 482
uint8_t *qla25xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 486
void qla8044_watchdog(struct scsi_qla_host *vha ) ;
#line 488
int qla2x00_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 489
int qla24xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 490
int qla82xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) ;
#line 495
void qla2xxx_flash_npiv_conf(scsi_qla_host_t *vha ) ;
#line 501
void qla2100_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 502
void qla2300_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 503
void qla24xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 504
void qla25xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 505
void qla81xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 517
void *qla2x00_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 518
void *qla24xx_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 528
void *qla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 529
void *qla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) ;
#line 539
struct device_attribute *qla2x00_host_attrs[31U] ;
#line 541
struct fc_function_template qla2xxx_transport_functions ;
#line 542
struct fc_function_template qla2xxx_transport_vport_functions ;
#line 543
void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha ) ;
#line 544
void qla2x00_free_sysfs_attr(scsi_qla_host_t *vha ) ;
#line 545
void qla2x00_init_host_attr(scsi_qla_host_t *vha ) ;
#line 558
int qla2x00_dfs_setup(scsi_qla_host_t *vha ) ;
#line 559
int qla2x00_dfs_remove(scsi_qla_host_t *vha ) ;
#line 565
int qla25xx_create_req_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int rsp_que , uint8_t qos ) ;
#line 567
int qla25xx_create_rsp_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int req ) ;
#line 571
int qla25xx_delete_queues(struct scsi_qla_host *vha ) ;
#line 580
int qlafx00_pci_config(struct scsi_qla_host *vha ) ;
#line 581
int qlafx00_initialize_adapter(struct scsi_qla_host *vha ) ;
#line 582
void qlafx00_soft_reset(scsi_qla_host_t *vha ) ;
#line 583
int qlafx00_chip_diag(scsi_qla_host_t *vha ) ;
#line 584
void qlafx00_config_rings(struct scsi_qla_host *vha ) ;
#line 585
char *qlafx00_pci_info_str(struct scsi_qla_host *vha , char *str ) ;
#line 586
char *qlafx00_fw_version_str(struct scsi_qla_host *vha , char *str ) ;
#line 587
irqreturn_t qlafx00_intr_handler(int irq , void *dev_id ) ;
#line 588
void qlafx00_enable_intrs(struct qla_hw_data *ha ) ;
#line 589
void qlafx00_disable_intrs(struct qla_hw_data *ha ) ;
#line 590
int qlafx00_abort_command(srb_t *sp ) ;
#line 591
int qlafx00_abort_target(fc_port_t *fcport , unsigned int l , int tag ) ;
#line 592
int qlafx00_lun_reset(fc_port_t *fcport , unsigned int l , int tag ) ;
#line 593
int qlafx00_start_scsi(srb_t *sp ) ;
#line 594
int qlafx00_abort_isp(scsi_qla_host_t *vha ) ;
#line 595
int qlafx00_iospace_config(struct qla_hw_data *ha ) ;
#line 597
int qlafx00_driver_shutdown(scsi_qla_host_t *vha , int tmo ) ;
#line 600
int qlafx00_reset_initialize(scsi_qla_host_t *vha ) ;
#line 601
int qlafx00_fx_disc(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t fx_type ) ;
#line 602
int qlafx00_process_aen(struct scsi_qla_host *vha , struct qla_work_evt *evt ) ;
#line 603
int qlafx00_post_aenfx_work(struct scsi_qla_host *vha , uint32_t evtcode , uint32_t *data ,
                            int cnt ) ;
#line 613
void qlafx00_timer_routine(scsi_qla_host_t *vha ) ;
#line 614
int qlafx00_rescan_isp(scsi_qla_host_t *vha ) ;
#line 615
int qlafx00_loop_reset(scsi_qla_host_t *vha ) ;
#line 620
int qla82xx_pci_config(struct scsi_qla_host *vha ) ;
#line 623
int qla82xx_iospace_config(struct qla_hw_data *ha ) ;
#line 626
void qla82xx_reset_chip(struct scsi_qla_host *vha ) ;
#line 627
void qla82xx_config_rings(struct scsi_qla_host *vha ) ;
#line 628
void qla82xx_watchdog(scsi_qla_host_t *vha ) ;
#line 629
int qla82xx_start_firmware(scsi_qla_host_t *vha ) ;
#line 632
int qla82xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) ;
#line 633
uint8_t *qla82xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 635
int qla82xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 639
int qla82xx_abort_isp(scsi_qla_host_t *vha ) ;
#line 640
int qla82xx_restart_isp(scsi_qla_host_t *vha ) ;
#line 643
int qla82xx_start_scsi(srb_t *sp ) ;
#line 651
irqreturn_t qla82xx_intr_handler(int irq , void *dev_id ) ;
#line 655
void qla82xx_enable_intrs(struct qla_hw_data *ha ) ;
#line 656
void qla82xx_disable_intrs(struct qla_hw_data *ha ) ;
#line 658
void qla82xx_init_flags(struct qla_hw_data *ha ) ;
#line 661
void qla82xx_set_drv_active(scsi_qla_host_t *vha ) ;
#line 662
int qla82xx_wr_32(struct qla_hw_data *ha , ulong off , u32 data ) ;
#line 663
int qla82xx_rd_32(struct qla_hw_data *ha , ulong off ) ;
#line 668
void qla82xx_clear_drv_active(struct qla_hw_data *ha ) ;
#line 670
int qla82xx_idc_lock(struct qla_hw_data *ha ) ;
#line 671
void qla82xx_idc_unlock(struct qla_hw_data *ha ) ;
#line 672
int qla82xx_device_state_handler(scsi_qla_host_t *vha ) ;
#line 673
void qla8xxx_dev_failed_handler(scsi_qla_host_t *vha ) ;
#line 674
void qla82xx_clear_qsnt_ready(scsi_qla_host_t *vha ) ;
#line 681
int qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha ) ;
#line 688
void qla82xx_clear_pending_mbx(scsi_qla_host_t *vha ) ;
#line 702
void qla83xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) ;
#line 708
void qla82xx_md_free(scsi_qla_host_t *vha ) ;
#line 715
int qla8044_idc_lock(struct qla_hw_data *ha ) ;
#line 716
void qla8044_idc_unlock(struct qla_hw_data *ha ) ;
#line 722
void qla8044_wr_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg , uint32_t const   value ) ;
#line 726
int qla8044_device_state_handler(struct scsi_qla_host *vha ) ;
#line 727
void qla8044_clear_qsnt_ready(struct scsi_qla_host *vha ) ;
#line 728
void qla8044_clear_drv_active(struct scsi_qla_host *vha ) ;
#line 732
int qla8044_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) ;
#line 734
irqreturn_t qla8044_intr_handler(int irq , void *dev_id ) ;
#line 736
int qla8044_abort_isp(scsi_qla_host_t *vha ) ;
#line 310 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_dbg.h"
int ql_errlev ;
#line 313
void ql_dbg(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) ;
#line 315
void ql_dbg_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) ;
#line 318
void ql_log(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) ;
#line 320
void ql_log_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) ;
#line 94 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_reserved_loop_ids(struct qla_hw_data *ha ) 
{ 
  int i ;

  {
#line 98
  if ((ha->device_type & 134217728U) != 0U) {
#line 99
    return;
  } else {

  }
#line 101
  i = 0;
#line 101
  goto ldv_43381;
  ldv_43380: 
#line 102
  set_bit((long )i, (unsigned long volatile   *)ha->loop_id_map);
#line 101
  i = i + 1;
  ldv_43381: ;
#line 101
  if (i <= 128) {
#line 103
    goto ldv_43380;
  } else {

  }
#line 103
  set_bit(254L, (unsigned long volatile   *)ha->loop_id_map);
#line 104
  set_bit(255L, (unsigned long volatile   *)ha->loop_id_map);
#line 105
  return;
}
}
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_is_reserved_id(scsi_qla_host_t *vha , uint16_t loop_id ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 110
  ha = vha->hw;
#line 111
  if ((ha->device_type & 134217728U) != 0U) {
#line 112
    return ((unsigned int )loop_id > 2031U);
  } else {

  }
#line 114
  return ((((int )ha->max_loop_id < (int )loop_id && (unsigned int )loop_id <= 128U) || (unsigned int )loop_id == 254U) || (unsigned int )loop_id == 255U);
}
}
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_clear_loop_id(fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 120
  ha = (fcport->vha)->hw;
#line 122
  if ((unsigned int )fcport->loop_id == 4096U) {
#line 124
    return;
  } else {
#line 122
    tmp = qla2x00_is_reserved_id(fcport->vha, (int )fcport->loop_id);
#line 122
    if (tmp != 0) {
#line 124
      return;
    } else {

    }
  }
#line 126
  clear_bit((long )fcport->loop_id, (unsigned long volatile   *)ha->loop_id_map);
#line 127
  fcport->loop_id = 4096U;
#line 128
  return;
}
}
#line 131 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_clean_dsd_pool(struct qla_hw_data *ha , srb_t *sp ) 
{ 
  struct dsd_dma *dsd_ptr ;
  struct dsd_dma *tdsd_ptr ;
  struct crc_context *ctx ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 136
  ctx = (struct crc_context *)sp->u.scmd.ctx;
#line 139
  __mptr = (struct list_head  const  *)ctx->dsd_list.next;
#line 139
  dsd_ptr = (struct dsd_dma *)__mptr;
#line 139
  __mptr___0 = (struct list_head  const  *)dsd_ptr->list.next;
#line 139
  tdsd_ptr = (struct dsd_dma *)__mptr___0;
#line 139
  goto ldv_43406;
  ldv_43405: 
#line 141
  dma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr, dsd_ptr->dsd_list_dma);
#line 143
  list_del(& dsd_ptr->list);
#line 144
  kfree((void const   *)dsd_ptr);
#line 139
  dsd_ptr = tdsd_ptr;
#line 139
  __mptr___1 = (struct list_head  const  *)tdsd_ptr->list.next;
#line 139
  tdsd_ptr = (struct dsd_dma *)__mptr___1;
  ldv_43406: ;
#line 139
  if ((unsigned long )(& dsd_ptr->list) != (unsigned long )(& ctx->dsd_list)) {
#line 141
    goto ldv_43405;
  } else {

  }
#line 146
  INIT_LIST_HEAD(& ctx->dsd_list);
#line 147
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 154
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 155
  atomic_set(& fcport->state, state);
#line 158
  if (old_state != 0 && old_state != state) {
#line 159
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str[old_state], port_state_str[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 165
  return;
}
}
#line 210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static srb_t *qla2x00_get_sp(scsi_qla_host_t *vha , fc_port_t *fcport , gfp_t flag ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  uint8_t bail ;
  long tmp ;
  void *tmp___0 ;

  {
#line 212
  sp = (srb_t *)0;
#line 213
  ha = vha->hw;
#line 216
  atomic_inc(& vha->vref_count);
#line 216
  __asm__  volatile   ("mfence": : : "memory");
#line 216
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 216
    atomic_dec(& vha->vref_count);
#line 216
    bail = 1U;
  } else {
#line 216
    bail = 0U;
  }
#line 217
  tmp = ldv__builtin_expect((unsigned int )bail != 0U, 0L);
#line 217
  if (tmp != 0L) {
#line 218
    return ((srb_t *)0);
  } else {

  }
#line 220
  tmp___0 = mempool_alloc(ha->srb_mempool, flag);
#line 220
  sp = (srb_t *)tmp___0;
#line 221
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 222
    goto done;
  } else {

  }
#line 224
  memset((void *)sp, 0, 376UL);
#line 225
  sp->fcport = fcport;
#line 226
  sp->iocbs = 1;
  done: ;
#line 228
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 229
    atomic_dec(& vha->vref_count);
  } else {

  }
#line 230
  return (sp);
}
}
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_rel_sp(scsi_qla_host_t *vha , srb_t *sp ) 
{ 


  {
#line 236
  mempool_free((void *)sp, (vha->hw)->srb_mempool);
#line 237
  atomic_dec(& vha->vref_count);
#line 238
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_gid_list_size(struct qla_hw_data *ha ) 
{ 


  {
#line 257
  if ((ha->device_type & 131072U) != 0U) {
#line 258
    return (128);
  } else {
#line 260
    return ((int )((unsigned int )ha->max_fibre_devices * 8U));
  }
}
}
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 27 "include/scsi/scsi_tcq.h"
__inline static int scsi_get_tag_type(struct scsi_device *sdev ) 
{ 


  {
#line 29
  if ((unsigned int )*((unsigned char *)sdev + 297UL) == 0U) {
#line 30
    return (0);
  } else {

  }
#line 31
  if ((unsigned int )*((unsigned char *)sdev + 297UL) != 0U) {
#line 32
    return (34);
  } else {

  }
#line 33
  if ((unsigned int )*((unsigned char *)sdev + 297UL) != 0U) {
#line 34
    return (32);
  } else {

  }
#line 35
  return (0);
}
}
#line 38 "include/scsi/scsi_tcq.h"
__inline static void scsi_set_tag_type(struct scsi_device *sdev , int tag ) 
{ 


  {
#line 40
  switch (tag) {
  case 34: 
#line 42
  sdev->ordered_tags = 1U;
  case 32: 
#line 45
  sdev->simple_tags = 1U;
#line 46
  goto ldv_43566;
  case 0: ;
  default: 
#line 50
  sdev->ordered_tags = 0U;
#line 51
  sdev->simple_tags = 0U;
#line 52
  goto ldv_43566;
  }
  ldv_43566: ;
#line 55
  return;
}
}
#line 65 "include/scsi/scsi_tcq.h"
__inline static void scsi_activate_tcq(struct scsi_device *sdev , int depth ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 67
  if ((unsigned int )*((unsigned char *)sdev + 297UL) == 0U) {
#line 68
    return;
  } else {

  }
#line 70
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& (sdev->request_queue)->queue_flags));
#line 70
  if (tmp == 0) {
#line 71
    blk_queue_init_tags(sdev->request_queue, depth, (sdev->host)->bqt);
  } else {

  }
#line 74
  tmp___0 = scsi_get_tag_type(sdev);
#line 74
  scsi_adjust_queue_depth(sdev, tmp___0, depth);
#line 75
  return;
}
}
#line 81 "include/scsi/scsi_tcq.h"
__inline static void scsi_deactivate_tcq(struct scsi_device *sdev , int depth ) 
{ 
  int tmp ;

  {
#line 83
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& (sdev->request_queue)->queue_flags));
#line 83
  if (tmp != 0) {
#line 84
    blk_queue_free_tags(sdev->request_queue);
  } else {

  }
#line 85
  scsi_adjust_queue_depth(sdev, 0, depth);
#line 86
  return;
}
}
#line 933 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
int qlt_add_target(struct qla_hw_data *ha , struct scsi_qla_host *base_vha ) ;
#line 934
int qlt_remove_target(struct qla_hw_data *ha , struct scsi_qla_host *vha ) ;
#line 940
void qlt_fc_port_deleted(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 943
int qlt_init(void) ;
#line 944
void qlt_exit(void) ;
#line 959 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static bool qla_ini_mode_enabled(struct scsi_qla_host *ha ) 
{ 


  {
#line 961
  return (((int )(ha->host)->active_mode & 1) != 0);
}
}
#line 1002
void qlt_probe_one_stage1(struct scsi_qla_host *base_vha , struct qla_hw_data *ha ) ;
#line 1003
int qlt_mem_alloc(struct qla_hw_data *ha ) ;
#line 1004
void qlt_mem_free(struct qla_hw_data *ha ) ;
#line 1008
void qlt_83xx_iospace_config(struct qla_hw_data *ha ) ;
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int apidev_major  ;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct kmem_cache *srb_cachep  ;
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct kmem_cache *ctx_cachep  ;
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql_errlev  =    3;
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int ql2xenableclass2  ;
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xlogintimeout  =    20;
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xloginretrycount  =    0;
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xallocfwdump  =    1;
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xshiftctondsd  =    6;
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xfdmienable  =    1;
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xmaxqdepth  =    32;
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xenabledif  =    2;
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xenablehba_err_chk  =    2;
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xiidmaenable  =    1;
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xmaxqueues  =    1;
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xdbwr  =    1;
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xtargetreset  =    1;
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
unsigned int ql2xmaxlun  =    65535U;
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xmdcapmask  =    31;
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ql2xmdenable  =    1;
#line 524
static int qla2xxx_slave_configure(struct scsi_device *sdev ) ;
#line 525
static int qla2xxx_slave_alloc(struct scsi_device *sdev ) ;
#line 526
static int qla2xxx_scan_finished(struct Scsi_Host *shost , unsigned long time ) ;
#line 527
static void qla2xxx_scan_start(struct Scsi_Host *shost ) ;
#line 528
static void qla2xxx_slave_destroy(struct scsi_device *sdev ) ;
#line 529
static int qla2xxx_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *cmd ) ;
#line 530
static int qla2xxx_eh_abort(struct scsi_cmnd *cmd ) ;
#line 531
static int qla2xxx_eh_device_reset(struct scsi_cmnd *cmd ) ;
#line 532
static int qla2xxx_eh_target_reset(struct scsi_cmnd *cmd ) ;
#line 533
static int qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd ) ;
#line 534
static int qla2xxx_eh_host_reset(struct scsi_cmnd *cmd ) ;
#line 536
static int qla2x00_change_queue_depth(struct scsi_device *sdev , int qdepth , int reason ) ;
#line 537
static int qla2x00_change_queue_type(struct scsi_device *sdev , int tag_type ) ;
#line 538
static void qla2x00_free_device(scsi_qla_host_t *vha ) ;
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_host_template qla2xxx_driver_template  = 
#line 540
     {& __this_module, "qla2xxx", 0, 0, 0, 0, 0, & qla2xxx_queuecommand, 0, & qla2xxx_eh_abort,
    & qla2xxx_eh_device_reset, & qla2xxx_eh_target_reset, & qla2xxx_eh_bus_reset,
    & qla2xxx_eh_host_reset, & qla2xxx_slave_alloc, & qla2xxx_slave_configure, & qla2xxx_slave_destroy,
    0, 0, & qla2xxx_scan_finished, & qla2xxx_scan_start, & qla2x00_change_queue_depth,
    & qla2x00_change_queue_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 128U, (unsigned short)0,
    65535U, 0UL, 3, (unsigned char)0, 1U, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, 0U, (struct device_attribute **)(& qla2x00_host_attrs),
    0, {0, 0}, 0ULL};
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct scsi_transport_template *qla2xxx_transport_template  =    (struct scsi_transport_template *)0;
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_transport_template *qla2xxx_transport_vport_template  =    (struct scsi_transport_template *)0;
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline void qla2x00_start_timer(scsi_qla_host_t *vha , void *func , unsigned long interval ) 
{ 


  {
#line 581
  reg_timer_7(& vha->timer);
#line 582
  vha->timer.expires = interval * 250UL + (unsigned long )jiffies;
#line 583
  vha->timer.data = (unsigned long )vha;
#line 584
  vha->timer.function = (void (*)(unsigned long  ))func;
#line 585
  add_timer(& vha->timer);
#line 586
  vha->timer_active = 1U;
#line 587
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void qla2x00_restart_timer(scsi_qla_host_t *vha , unsigned long interval ) 
{ 


  {
#line 593
  if ((vha->device_flags & 32U) != 0U) {
#line 594
    ql_dbg(16777216U, vha, 24589, "Device in a failed state, returning.\n");
#line 596
    return;
  } else {

  }
#line 599
  ldv_mod_timer_3(& vha->timer, interval * 250UL + (unsigned long )jiffies);
#line 600
  return;
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void qla2x00_stop_timer(scsi_qla_host_t *vha ) 
{ 


  {
#line 605
  ldv_del_timer_sync_4(& vha->timer);
#line 606
  vha->timer_active = 0U;
#line 607
  return;
}
}
#line 609
static int qla2x00_do_dpc(void *data ) ;
#line 611
static void qla2x00_rst_aen(scsi_qla_host_t *vha ) ;
#line 613
static int qla2x00_mem_alloc(struct qla_hw_data *ha , uint16_t req_len , uint16_t rsp_len ,
                             struct req_que **req , struct rsp_que **rsp ) ;
#line 615
static void qla2x00_free_fw_dump(struct qla_hw_data *ha ) ;
#line 616
static void qla2x00_mem_free(struct qla_hw_data *ha ) ;
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_alloc_queues(struct qla_hw_data *ha , struct req_que *req , struct rsp_que *rsp ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 622
  tmp = pci_get_drvdata(ha->pdev);
#line 622
  vha = (scsi_qla_host_t *)tmp;
#line 623
  tmp___0 = kzalloc((unsigned long )ha->max_req_queues * 8UL, 208U);
#line 623
  ha->req_q_map = (struct req_que **)tmp___0;
#line 625
  if ((unsigned long )ha->req_q_map == (unsigned long )((struct req_que **)0)) {
#line 626
    ql_log(0U, vha, 59, "Unable to allocate memory for request queue ptrs.\n");
#line 628
    goto fail_req_map;
  } else {

  }
#line 631
  tmp___1 = kzalloc((unsigned long )ha->max_rsp_queues * 8UL, 208U);
#line 631
  ha->rsp_q_map = (struct rsp_que **)tmp___1;
#line 633
  if ((unsigned long )ha->rsp_q_map == (unsigned long )((struct rsp_que **)0)) {
#line 634
    ql_log(0U, vha, 60, "Unable to allocate memory for response queue ptrs.\n");
#line 636
    goto fail_rsp_map;
  } else {

  }
#line 642
  *(ha->rsp_q_map) = rsp;
#line 643
  *(ha->req_q_map) = req;
#line 644
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 645
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 646
  return (1);
  fail_rsp_map: 
#line 649
  kfree((void const   *)ha->req_q_map);
#line 650
  ha->req_q_map = (struct req_que **)0;
  fail_req_map: ;
#line 652
  return (-12);
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_free_req_que(struct qla_hw_data *ha , struct req_que *req ) 
{ 


  {
#line 657
  if ((ha->device_type & 131072U) != 0U) {
#line 658
    if ((unsigned long )req != (unsigned long )((struct req_que *)0) && (unsigned long )req->ring_fx00 != (unsigned long )((request_t *)0)) {
#line 659
      dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length_fx00 + 1) * 64UL,
                     (void *)req->ring_fx00, req->dma_fx00, (struct dma_attrs *)0);
    } else {

    }
  } else
#line 662
  if ((unsigned long )req != (unsigned long )((struct req_que *)0) && (unsigned long )req->ring != (unsigned long )((request_t *)0)) {
#line 663
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                   (void *)req->ring, req->dma, (struct dma_attrs *)0);
  } else {

  }
#line 667
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 668
    kfree((void const   *)req->outstanding_cmds);
  } else {

  }
#line 670
  kfree((void const   *)req);
#line 671
  req = (struct req_que *)0;
#line 672
  return;
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_free_rsp_que(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 


  {
#line 676
  if ((ha->device_type & 131072U) != 0U) {
#line 677
    if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) && (unsigned long )rsp->ring != (unsigned long )((response_t *)0)) {
#line 678
      dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length_fx00 + 1) * 64UL,
                     (void *)rsp->ring_fx00, rsp->dma_fx00, (struct dma_attrs *)0);
    } else {

    }
  } else
#line 681
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0) && (unsigned long )rsp->ring != (unsigned long )((response_t *)0)) {
#line 682
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                   (void *)rsp->ring, rsp->dma, (struct dma_attrs *)0);
  } else {

  }
#line 686
  kfree((void const   *)rsp);
#line 687
  rsp = (struct rsp_que *)0;
#line 688
  return;
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_free_queues(struct qla_hw_data *ha ) 
{ 
  struct req_que *req ;
  struct rsp_que *rsp ;
  int cnt ;

  {
#line 696
  cnt = 0;
#line 696
  goto ldv_61453;
  ldv_61452: 
#line 697
  req = *(ha->req_q_map + (unsigned long )cnt);
#line 698
  qla2x00_free_req_que(ha, req);
#line 696
  cnt = cnt + 1;
  ldv_61453: ;
#line 696
  if ((int )ha->max_req_queues > cnt) {
#line 698
    goto ldv_61452;
  } else {

  }
#line 700
  kfree((void const   *)ha->req_q_map);
#line 701
  ha->req_q_map = (struct req_que **)0;
#line 703
  cnt = 0;
#line 703
  goto ldv_61456;
  ldv_61455: 
#line 704
  rsp = *(ha->rsp_q_map + (unsigned long )cnt);
#line 705
  qla2x00_free_rsp_que(ha, rsp);
#line 703
  cnt = cnt + 1;
  ldv_61456: ;
#line 703
  if ((int )ha->max_rsp_queues > cnt) {
#line 705
    goto ldv_61455;
  } else {

  }
#line 707
  kfree((void const   *)ha->rsp_q_map);
#line 708
  ha->rsp_q_map = (struct rsp_que **)0;
#line 709
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla25xx_setup_mode(struct scsi_qla_host *vha ) 
{ 
  uint16_t options ;
  int ques ;
  int req ;
  int ret ;
  struct qla_hw_data *ha ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  uint8_t tmp___0 ;

  {
#line 713
  options = 0U;
#line 715
  ha = vha->hw;
#line 717
  if (((int )ha->fw_attributes & 64) == 0) {
#line 718
    ql_log(1U, vha, 216, "Firmware is not multi-queue capable.\n");
#line 720
    goto fail;
  } else {

  }
#line 722
  if (ql2xmultique_tag != 0) {
#line 724
    options = (uint16_t )((unsigned int )options | 128U);
#line 725
    req = qla25xx_create_req_que(ha, (int )options, 0, 0, -1, 5);
#line 727
    if (req == 0) {
#line 728
      ql_log(1U, vha, 224, "Failed to create request queue.\n");
#line 730
      goto fail;
    } else {

    }
#line 732
    __lock_name = "qla2xxx_wq";
#line 732
    tmp = __alloc_workqueue_key("qla2xxx_wq", 8U, 1, & __key, __lock_name);
#line 732
    ha->wq = tmp;
#line 733
    vha->req = *(ha->req_q_map + (unsigned long )req);
#line 734
    options = (uint16_t )((unsigned int )options | 2U);
#line 735
    ques = 1;
#line 735
    goto ldv_61472;
    ldv_61471: 
#line 736
    ret = qla25xx_create_rsp_que(ha, (int )options, 0, 0, req);
#line 737
    if (ret == 0) {
#line 738
      ql_log(1U, vha, 232, "Failed to create response queue.\n");
#line 740
      goto fail2;
    } else {

    }
#line 735
    ques = ques + 1;
    ldv_61472: ;
#line 735
    if ((int )ha->max_rsp_queues > ques) {
#line 737
      goto ldv_61471;
    } else {

    }
#line 743
    ha->flags.cpu_affinity_enabled = 1U;
#line 744
    ql_dbg(1048576U, vha, 49159, "CPU affinity mode enalbed, no. of response queues:%d no. of request queues:%d.\n",
           (int )ha->max_rsp_queues, (int )ha->max_req_queues);
#line 748
    ql_dbg(1073741824U, vha, 233, "CPU affinity mode enalbed, no. of response queues:%d no. of request queues:%d.\n",
           (int )ha->max_rsp_queues, (int )ha->max_req_queues);
  } else {

  }
#line 753
  return (0);
  fail2: 
#line 755
  qla25xx_delete_queues(vha);
#line 756
  destroy_workqueue(ha->wq);
#line 757
  ha->wq = (struct workqueue_struct *)0;
#line 758
  vha->req = *(ha->req_q_map);
  fail: 
#line 760
  ha->mqenable = 0U;
#line 761
  kfree((void const   *)ha->req_q_map);
#line 762
  kfree((void const   *)ha->rsp_q_map);
#line 763
  tmp___0 = 1U;
#line 763
  ha->max_rsp_queues = tmp___0;
#line 763
  ha->max_req_queues = tmp___0;
#line 764
  return (1);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static char *qla2x00_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;
  char *pci_bus_modes[4U] ;
  uint16_t pci_bus ;

  {
#line 770
  ha = vha->hw;
#line 771
  pci_bus_modes[0] = (char *)"33";
#line 771
  pci_bus_modes[1] = (char *)"66";
#line 771
  pci_bus_modes[2] = (char *)"100";
#line 771
  pci_bus_modes[3] = (char *)"133";
#line 776
  strcpy(str, "PCI");
#line 777
  pci_bus = (uint16_t )((ha->pci_attr & 1536U) >> 9);
#line 778
  if ((unsigned int )pci_bus != 0U) {
#line 779
    strcat(str, "-X (");
#line 780
    strcat(str, (char const   *)pci_bus_modes[(int )pci_bus]);
  } else {
#line 782
    pci_bus = (uint16_t )((ha->pci_attr & 256U) >> 8);
#line 783
    strcat(str, " (");
#line 784
    strcat(str, (char const   *)pci_bus_modes[(int )pci_bus]);
  }
#line 786
  strcat(str, " MHz)");
#line 788
  return (str);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static char *qla24xx_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  char *pci_bus_modes[4U] ;
  struct qla_hw_data *ha ;
  uint32_t pci_bus ;
  int pcie_reg ;
  char lwstr[6U] ;
  uint16_t pcie_lstat ;
  uint16_t lspeed ;
  uint16_t lwidth ;

  {
#line 794
  pci_bus_modes[0] = (char *)"33";
#line 794
  pci_bus_modes[1] = (char *)"66";
#line 794
  pci_bus_modes[2] = (char *)"100";
#line 794
  pci_bus_modes[3] = (char *)"133";
#line 795
  ha = vha->hw;
#line 799
  pcie_reg = pci_pcie_cap(ha->pdev);
#line 800
  if (pcie_reg != 0) {
#line 804
    pcie_reg = pcie_reg + 12;
#line 805
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, pcie_reg, & pcie_lstat);
#line 806
    lspeed = (unsigned int )pcie_lstat & 15U;
#line 807
    lwidth = (uint16_t )(((int )pcie_lstat & 1008) >> 4);
#line 810
    strcpy(str, "PCIe (");
#line 811
    switch ((int )lspeed) {
    case 1: 
#line 813
    strcat(str, "2.5GT/s ");
#line 814
    goto ldv_61494;
    case 2: 
#line 816
    strcat(str, "5.0GT/s ");
#line 817
    goto ldv_61494;
    case 3: 
#line 819
    strcat(str, "8.0GT/s ");
#line 820
    goto ldv_61494;
    default: 
#line 822
    strcat(str, "<unknown> ");
#line 823
    goto ldv_61494;
    }
    ldv_61494: 
#line 825
    snprintf((char *)(& lwstr), 6UL, "x%d)", (int )lwidth);
#line 826
    strcat(str, (char const   *)(& lwstr));
#line 828
    return (str);
  } else {

  }
#line 831
  strcpy(str, "PCI");
#line 832
  pci_bus = (ha->pci_attr & 3840U) >> 8;
#line 833
  if (pci_bus == 0U || pci_bus == 8U) {
#line 834
    strcat(str, " (");
#line 835
    strcat(str, (char const   *)pci_bus_modes[pci_bus >> 3]);
  } else {
#line 837
    strcat(str, "-X ");
#line 838
    if ((pci_bus & 4U) != 0U) {
#line 839
      strcat(str, "Mode 2");
    } else {
#line 841
      strcat(str, "Mode 1");
    }
#line 842
    strcat(str, " (");
#line 843
    strcat(str, (char const   *)pci_bus_modes[pci_bus & 4294967291U]);
  }
#line 845
  strcat(str, " MHz)");
#line 847
  return (str);
}
}
#line 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static char *qla2x00_fw_version_str(struct scsi_qla_host *vha , char *str ) 
{ 
  char un_str[10U] ;
  struct qla_hw_data *ha ;

  {
#line 854
  ha = vha->hw;
#line 856
  sprintf(str, "%d.%02d.%02d ", (int )ha->fw_major_version, (int )ha->fw_minor_version,
          (int )ha->fw_subminor_version);
#line 860
  if (((int )ha->fw_attributes & 512) != 0) {
#line 861
    strcat(str, "FLX");
#line 862
    return (str);
  } else {

  }
#line 865
  switch ((int )ha->fw_attributes & 255) {
  case 7: 
#line 867
  strcat(str, "EF");
#line 868
  goto ldv_61505;
  case 23: 
#line 870
  strcat(str, "TP");
#line 871
  goto ldv_61505;
  case 55: 
#line 873
  strcat(str, "IP");
#line 874
  goto ldv_61505;
  case 119: 
#line 876
  strcat(str, "VI");
#line 877
  goto ldv_61505;
  default: 
#line 879
  sprintf((char *)(& un_str), "(%x)", (int )ha->fw_attributes);
#line 880
  strcat(str, (char const   *)(& un_str));
#line 881
  goto ldv_61505;
  }
  ldv_61505: ;
#line 883
  if (((int )ha->fw_attributes & 256) != 0) {
#line 884
    strcat(str, "X");
  } else {

  }
#line 886
  return (str);
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static char *qla24xx_fw_version_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 892
  ha = vha->hw;
#line 894
  sprintf(str, "%d.%02d.%02d (%x)", (int )ha->fw_major_version, (int )ha->fw_minor_version,
          (int )ha->fw_subminor_version, (int )ha->fw_attributes);
#line 896
  return (str);
}
}
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_sp_free_dma(void *vha , void *ptr ) 
{ 
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  struct qla_hw_data *ha ;
  void *ctx ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  struct ct6_dsd *ctx1 ;

  {
#line 902
  sp = (srb_t *)ptr;
#line 903
  cmd = sp->u.scmd.cmd;
#line 904
  ha = ((sp->fcport)->vha)->hw;
#line 905
  ctx = sp->u.scmd.ctx;
#line 907
  if ((int )sp->flags & 1) {
#line 908
    scsi_dma_unmap(cmd);
#line 909
    sp->flags = (unsigned int )sp->flags & 65534U;
  } else {

  }
#line 912
  if (((int )sp->flags & 16) != 0) {
#line 913
    tmp = scsi_prot_sg_count(cmd);
#line 913
    tmp___0 = scsi_prot_sglist(cmd);
#line 913
    dma_unmap_sg_attrs(& (ha->pdev)->dev, tmp___0, (int )tmp, cmd->sc_data_direction,
                       (struct dma_attrs *)0);
#line 915
    sp->flags = (unsigned int )sp->flags & 65519U;
  } else {

  }
#line 918
  if (((int )sp->flags & 32) != 0) {
#line 920
    qla2x00_clean_dsd_pool(ha, sp);
#line 921
    sp->flags = (unsigned int )sp->flags & 65503U;
  } else {

  }
#line 924
  if (((int )sp->flags & 4) != 0) {
#line 925
    dma_pool_free(ha->dl_dma_pool, ctx, ((struct crc_context *)ctx)->crc_ctx_dma);
#line 927
    sp->flags = (unsigned int )sp->flags & 65531U;
  } else {

  }
#line 930
  if (((int )sp->flags & 4096) != 0) {
#line 931
    ctx1 = (struct ct6_dsd *)ctx;
#line 933
    dma_pool_free(ha->fcp_cmnd_dma_pool, (void *)ctx1->fcp_cmnd, ctx1->fcp_cmnd_dma);
#line 935
    list_splice((struct list_head  const  *)(& ctx1->dsd_list), & ha->gbl_dsd_list);
#line 936
    ha->gbl_dsd_inuse = (int )ha->gbl_dsd_inuse - (int )((uint16_t )ctx1->dsd_use_cnt);
#line 937
    ha->gbl_dsd_avail = (int )ha->gbl_dsd_avail + (int )((uint16_t )ctx1->dsd_use_cnt);
#line 938
    mempool_free((void *)ctx1, ha->ctx_mempool);
#line 939
    ctx1 = (struct ct6_dsd *)0;
  } else {

  }
#line 942
  cmd->SCp.ptr = (char *)0;
#line 943
  qla2x00_rel_sp((sp->fcport)->vha, sp);
#line 944
  return;
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_sp_compl(void *data , void *ptr , int res ) 
{ 
  struct qla_hw_data *ha ;
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  int tmp ;
  int tmp___0 ;

  {
#line 949
  ha = (struct qla_hw_data *)data;
#line 950
  sp = (srb_t *)ptr;
#line 951
  cmd = sp->u.scmd.cmd;
#line 953
  cmd->result = res;
#line 955
  tmp = atomic_read((atomic_t const   *)(& sp->ref_count));
#line 955
  if (tmp == 0) {
#line 956
    ql_dbg(134217728U, (sp->fcport)->vha, 12309, "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
           sp, sp->u.scmd.cmd);
#line 959
    if ((ql2xextended_error_logging & 134217728) != 0) {
#line 960
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"),
                           "i" (960), "i" (12UL));
      ldv_61532: ;
#line 960
      goto ldv_61532;
    } else {

    }
#line 961
    return;
  } else {

  }
#line 963
  tmp___0 = atomic_dec_and_test(& sp->ref_count);
#line 963
  if (tmp___0 == 0) {
#line 964
    return;
  } else {

  }
#line 966
  qla2x00_sp_free_dma((void *)ha, (void *)sp);
#line 967
  (*(cmd->scsi_done))(cmd);
#line 968
  return;
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___2 ;
  struct fc_rport *tmp___3 ;
  struct scsi_target *tmp___4 ;
  int tmp___5 ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___6 ;
  srb_t *sp ;
  int rval ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 976
  tmp = shost_priv(host);
#line 976
  vha = (scsi_qla_host_t *)tmp;
#line 977
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 978
  tmp___4 = scsi_target(cmd->device);
#line 978
  tmp___5 = scsi_is_fc_rport((struct device  const  *)tmp___4->dev.parent);
#line 978
  if (tmp___5 != 0) {
#line 978
    tmp___2 = scsi_target(cmd->device);
#line 978
    __mptr = (struct device  const  *)tmp___2->dev.parent;
#line 978
    tmp___3 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 978
    tmp___3 = (struct fc_rport *)0;
  }
#line 978
  rport = tmp___3;
#line 979
  ha = vha->hw;
#line 980
  tmp___6 = pci_get_drvdata(ha->pdev);
#line 980
  base_vha = (struct scsi_qla_host *)tmp___6;
#line 984
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 985
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 986
      ql_dbg(2097152U, vha, 36880, "PCI Channel IO permanent failure, exiting cmd=%p.\n",
             cmd);
#line 989
      cmd->result = 65536;
    } else {
#line 991
      ql_dbg(2097152U, vha, 36881, "EEH_Busy, Requeuing the cmd=%p.\n", cmd);
#line 993
      cmd->result = 851968;
    }
#line 995
    goto qc24_fail_command;
  } else {

  }
#line 998
  rval = fc_remote_port_chkready(rport);
#line 999
  if (rval != 0) {
#line 1000
    cmd->result = rval;
#line 1001
    ql_dbg(134250496U, vha, 12291, "fc_remote_port_chkready failed for cmd=%p, rval=0x%x.\n",
           cmd, rval);
#line 1004
    goto qc24_fail_command;
  } else {

  }
#line 1007
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1007
    tmp___7 = scsi_get_prot_op(cmd);
#line 1007
    if ((unsigned int )tmp___7 != 0U) {
#line 1009
      ql_dbg(134217728U, vha, 12292, "DIF Cap not reg, fail DIF capable cmd\'s:%p.\n",
             cmd);
#line 1012
      cmd->result = 65536;
#line 1013
      goto qc24_fail_command;
    } else {

    }
  } else {

  }
#line 1016
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1017
    cmd->result = 65536;
#line 1018
    goto qc24_fail_command;
  } else {

  }
#line 1021
  tmp___12 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1021
  if (tmp___12 != 4) {
#line 1022
    tmp___10 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1022
    if (tmp___10 == 2) {
#line 1024
      tmp___8 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 1024
      tmp___9 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1024
      ql_dbg(134217728U, vha, 12293, "Returning DNC, fcport_state=%d loop_state=%d.\n",
             tmp___9, tmp___8);
#line 1028
      cmd->result = 65536;
#line 1029
      goto qc24_fail_command;
    } else {
#line 1022
      tmp___11 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 1022
      if (tmp___11 == 6) {
#line 1024
        tmp___8 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 1024
        tmp___9 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1024
        ql_dbg(134217728U, vha, 12293, "Returning DNC, fcport_state=%d loop_state=%d.\n",
               tmp___9, tmp___8);
#line 1028
        cmd->result = 65536;
#line 1029
        goto qc24_fail_command;
      } else {

      }
    }
#line 1031
    goto qc24_target_busy;
  } else {

  }
#line 1034
  sp = qla2x00_get_sp(vha, fcport, 32U);
#line 1035
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1036
    set_bit(22L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1037
    goto qc24_host_busy;
  } else {

  }
#line 1040
  sp->u.scmd.cmd = cmd;
#line 1041
  sp->type = 8U;
#line 1042
  atomic_set(& sp->ref_count, 1);
#line 1043
  cmd->SCp.ptr = (char *)sp;
#line 1044
  sp->free = & qla2x00_sp_free_dma;
#line 1045
  sp->done = & qla2x00_sp_compl;
#line 1047
  rval = (*((ha->isp_ops)->start_scsi))(sp);
#line 1048
  if (rval != 0) {
#line 1049
    ql_dbg(134250496U, vha, 12307, "Start scsi failed rval=%d for cmd=%p.\n", rval,
           cmd);
#line 1051
    set_bit(22L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1052
    goto qc24_host_busy_free_sp;
  } else {

  }
#line 1055
  return (0);
  qc24_host_busy_free_sp: 
#line 1058
  qla2x00_sp_free_dma((void *)ha, (void *)sp);
  qc24_host_busy: ;
#line 1061
  return (4181);
  qc24_target_busy: ;
#line 1064
  return (4184);
  qc24_fail_command: 
#line 1067
  (*(cmd->scsi_done))(cmd);
#line 1069
  return (0);
}
}
#line 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_eh_wait_on_command(struct scsi_cmnd *cmd ) 
{ 
  unsigned long wait_iter ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 1089
  wait_iter = 10UL;
#line 1090
  tmp = shost_priv((cmd->device)->host);
#line 1090
  vha = (scsi_qla_host_t *)tmp;
#line 1091
  ha = vha->hw;
#line 1092
  ret = 0;
#line 1094
  tmp___0 = pci_channel_offline(ha->pdev);
#line 1094
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 1094
  if (tmp___1 != 0L || *((unsigned long *)ha + 2UL) != 0UL) {
#line 1095
    ql_dbg(4194304U, vha, 32773, "Return:eh_wait.\n");
#line 1097
    return (ret);
  } else {

  }
#line 1100
  goto ldv_61558;
  ldv_61557: 
#line 1101
  msleep(1000U);
  ldv_61558: ;
#line 1100
  if ((unsigned long )cmd->SCp.ptr != (unsigned long )((char *)0)) {
#line 1100
    tmp___2 = wait_iter;
#line 1100
    wait_iter = wait_iter - 1UL;
#line 1100
    if (tmp___2 != 0UL) {
#line 1102
      goto ldv_61557;
    } else {
#line 1105
      goto ldv_61559;
    }
  } else {

  }
  ldv_61559: ;
#line 1103
  if ((unsigned long )cmd->SCp.ptr != (unsigned long )((char *)0)) {
#line 1104
    ret = 258;
  } else {

  }
#line 1106
  return (ret);
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_wait_for_hba_online(scsi_qla_host_t *vha ) 
{ 
  int return_status ;
  unsigned long wait_online ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1131
  ha = vha->hw;
#line 1132
  tmp = pci_get_drvdata(ha->pdev);
#line 1132
  base_vha = (scsi_qla_host_t *)tmp;
#line 1134
  wait_online = (unsigned long )jiffies + 75000UL;
#line 1135
  goto ldv_61574;
  ldv_61573: 
#line 1140
  msleep(1000U);
  ldv_61574: 
#line 1135
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1138
  if (tmp___0 != 0) {
#line 1138
    goto _L;
  } else {
#line 1135
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1138
    if (tmp___1 != 0) {
#line 1138
      goto _L;
    } else {
#line 1135
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1138
      if (tmp___2 != 0) {
#line 1138
        goto _L;
      } else
#line 1138
      if ((unsigned int )ha->dpc_active != 0U) {
        _L: /* CIL Label */ 
#line 1138
        if ((long )((unsigned long )jiffies - wait_online) < 0L) {
#line 1140
          goto ldv_61573;
        } else {
#line 1143
          goto ldv_61575;
        }
      } else {
#line 1143
        goto ldv_61575;
      }
    }
  }
  ldv_61575: ;
#line 1142
  if (*((unsigned long *)base_vha + 19UL) != 0UL) {
#line 1143
    return_status = 0;
  } else {
#line 1145
    return_status = 258;
  }
#line 1147
  return (return_status);
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_wait_for_reset_ready(scsi_qla_host_t *vha ) 
{ 
  int return_status ;
  unsigned long wait_online ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1173
  ha = vha->hw;
#line 1174
  tmp = pci_get_drvdata(ha->pdev);
#line 1174
  base_vha = (scsi_qla_host_t *)tmp;
#line 1176
  wait_online = (unsigned long )jiffies + 75000UL;
#line 1177
  goto ldv_61590;
  ldv_61589: 
#line 1182
  msleep(1000U);
  ldv_61590: 
#line 1177
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1181
  if (tmp___0 != 0) {
#line 1181
    goto _L;
  } else {
#line 1177
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1181
    if (tmp___1 != 0) {
#line 1181
      goto _L;
    } else {
#line 1177
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1181
      if (tmp___2 != 0) {
#line 1181
        goto _L;
      } else
#line 1181
      if (ha->optrom_state != 0) {
#line 1181
        goto _L;
      } else
#line 1181
      if ((unsigned int )ha->dpc_active != 0U) {
        _L: /* CIL Label */ 
#line 1181
        if ((long )((unsigned long )jiffies - wait_online) < 0L) {
#line 1183
          goto ldv_61589;
        } else {
#line 1186
          goto ldv_61591;
        }
      } else {
#line 1186
        goto ldv_61591;
      }
    }
  }
  ldv_61591: ;
#line 1184
  if (*((unsigned long *)base_vha + 19UL) != 0UL && ha->optrom_state == 0) {
#line 1185
    return_status = 0;
  } else {
#line 1187
    return_status = 258;
  }
#line 1189
  ql_dbg(4194304U, vha, 32793, "%s return status=%d.\n", "qla2x00_wait_for_reset_ready",
         return_status);
#line 1192
  return (return_status);
}
}
#line 1196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_wait_for_chip_reset(scsi_qla_host_t *vha ) 
{ 
  int return_status ;
  unsigned long wait_reset ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1200
  ha = vha->hw;
#line 1201
  tmp = pci_get_drvdata(ha->pdev);
#line 1201
  base_vha = (scsi_qla_host_t *)tmp;
#line 1203
  wait_reset = (unsigned long )jiffies + 75000UL;
#line 1204
  goto ldv_61608;
  ldv_61607: 
#line 1209
  msleep(1000U);
#line 1211
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1211
  if (tmp___0 == 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1213
    goto ldv_61606;
  } else {

  }
  ldv_61608: 
#line 1204
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1207
  if (tmp___1 != 0) {
#line 1207
    goto _L;
  } else {
#line 1204
    tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1207
    if (tmp___2 != 0) {
#line 1207
      goto _L;
    } else {
#line 1204
      tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 1207
      if (tmp___3 != 0) {
#line 1207
        goto _L;
      } else
#line 1207
      if ((unsigned int )ha->dpc_active != 0U) {
        _L: /* CIL Label */ 
#line 1207
        if ((long )((unsigned long )jiffies - wait_reset) < 0L) {
#line 1209
          goto ldv_61607;
        } else {
#line 1212
          goto ldv_61606;
        }
      } else {
#line 1212
        goto ldv_61606;
      }
    }
  }
  ldv_61606: ;
#line 1215
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1216
    return_status = 0;
  } else {
#line 1218
    return_status = 258;
  }
#line 1220
  return (return_status);
}
}
#line 1224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void sp_get(struct srb *sp ) 
{ 


  {
#line 1226
  atomic_inc(& sp->ref_count);
#line 1227
  return;
}
}
#line 1245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_eh_abort(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  srb_t *sp ;
  int ret ;
  unsigned int id ;
  unsigned int lun ;
  unsigned long flags ;
  int wait ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int tmp___3 ;

  {
#line 1247
  tmp = shost_priv((cmd->device)->host);
#line 1247
  vha = (scsi_qla_host_t *)tmp;
#line 1252
  wait = 0;
#line 1253
  ha = vha->hw;
#line 1255
  if ((unsigned long )cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 1256
    return (8194);
  } else {

  }
#line 1258
  ret = fc_block_scsi_eh(cmd);
#line 1259
  if (ret != 0) {
#line 1260
    return (ret);
  } else {

  }
#line 1261
  ret = 8194;
#line 1263
  id = (cmd->device)->id;
#line 1264
  lun = (cmd->device)->lun;
#line 1266
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1266
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1267
  sp = (srb_t *)cmd->SCp.ptr;
#line 1268
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1269
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1270
    return (8194);
  } else {

  }
#line 1273
  ql_dbg(4194304U, vha, 32770, "Aborting from RISC nexus=%ld:%d:%d sp=%p cmd=%p\n",
         vha->host_no, id, lun, sp, cmd);
#line 1278
  sp_get(sp);
#line 1280
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1281
  tmp___1 = (*((ha->isp_ops)->abort_command))(sp);
#line 1281
  if (tmp___1 != 0) {
#line 1282
    ret = 8195;
#line 1283
    ql_dbg(4194304U, vha, 32771, "Abort command mbx failed cmd=%p.\n", cmd);
  } else {
#line 1286
    ql_dbg(4194304U, vha, 32772, "Abort command mbx success cmd=%p.\n", cmd);
#line 1288
    wait = 1;
  }
#line 1291
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 1291
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1292
  (*(sp->done))((void *)ha, (void *)sp, 0);
#line 1293
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1296
  if (ret == 8195 && (unsigned long )cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 1297
    ret = 8194;
  } else {

  }
#line 1300
  if (wait != 0) {
#line 1301
    tmp___3 = qla2x00_eh_wait_on_command(cmd);
#line 1301
    if (tmp___3 != 0) {
#line 1302
      ql_log(1U, vha, 32774, "Abort handler timed out cmd=%p.\n", cmd);
#line 1304
      ret = 8195;
    } else {

    }
  } else {

  }
#line 1308
  ql_log(2U, vha, 32796, "Abort command issued nexus=%ld:%d:%d --  %d %x.\n", vha->host_no,
         id, lun, wait, ret);
#line 1312
  return (ret);
}
}
#line 1316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha , unsigned int t , unsigned int l ,
                                         enum nexus_wait_type type ) 
{ 
  int cnt ;
  int match ;
  int status ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  srb_t *sp ;
  struct scsi_cmnd *cmd ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1321
  ha = vha->hw;
#line 1326
  status = 0;
#line 1328
  tmp = spinlock_check(& ha->hardware_lock);
#line 1328
  flags = _raw_spin_lock_irqsave(tmp);
#line 1329
  req = vha->req;
#line 1330
  cnt = 1;
#line 1330
  goto ldv_61655;
  ldv_61654: 
#line 1332
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 1333
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1334
    goto ldv_61646;
  } else {

  }
#line 1335
  if ((unsigned int )sp->type != 8U) {
#line 1336
    goto ldv_61646;
  } else {

  }
#line 1337
  if ((int )vha->vp_idx != (int )((sp->fcport)->vha)->vp_idx) {
#line 1338
    goto ldv_61646;
  } else {

  }
#line 1339
  match = 0;
#line 1340
  cmd = sp->u.scmd.cmd;
#line 1341
  switch ((unsigned int )type) {
  case 0U: 
#line 1343
  match = 1;
#line 1344
  goto ldv_61648;
  case 1U: 
#line 1346
  match = (cmd->device)->id == t;
#line 1347
  goto ldv_61648;
  case 2U: 
#line 1349
  match = (cmd->device)->id == t && (cmd->device)->lun == l;
#line 1351
  goto ldv_61648;
  }
  ldv_61648: ;
#line 1353
  if (match == 0) {
#line 1354
    goto ldv_61646;
  } else {

  }
#line 1356
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1357
  status = qla2x00_eh_wait_on_command(cmd);
#line 1358
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1358
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_61646: 
#line 1331
  cnt = cnt + 1;
  ldv_61655: ;
#line 1330
  if (status == 0 && (int )req->num_outstanding_cmds > cnt) {
#line 1333
    goto ldv_61654;
  } else {

  }
#line 1360
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1362
  return (status);
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static char *reset_errors[4U]  = {      (char *)"HBA not online",      (char *)"HBA not ready",      (char *)"Task management failed",      (char *)"Waiting for command completions"};
#line 1373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int __qla2xxx_eh_generic_reset(char *name , enum nexus_wait_type type , struct scsi_cmnd *cmd ,
                                      int (*do_reset)(struct fc_port * , unsigned int  ,
                                                      int  ) ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  int err ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1376
  tmp = shost_priv((cmd->device)->host);
#line 1376
  vha = (scsi_qla_host_t *)tmp;
#line 1377
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 1380
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1381
    return (8195);
  } else {

  }
#line 1384
  err = fc_block_scsi_eh(cmd);
#line 1385
  if (err != 0) {
#line 1386
    return (err);
  } else {

  }
#line 1388
  ql_log(2U, vha, 32777, "%s RESET ISSUED nexus=%ld:%d:%d cmd=%p.\n", name, vha->host_no,
         (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1392
  err = 0;
#line 1393
  tmp___0 = qla2x00_wait_for_hba_online(vha);
#line 1393
  if (tmp___0 != 0) {
#line 1394
    ql_log(1U, vha, 32778, "Wait for hba online failed for cmd=%p.\n", cmd);
#line 1396
    goto eh_reset_failed;
  } else {

  }
#line 1398
  err = 2;
#line 1399
  tmp___1 = (*do_reset)(fcport, (cmd->device)->lun, (cmd->request)->cpu + 1);
#line 1399
  if (tmp___1 != 0) {
#line 1401
    ql_log(1U, vha, 32780, "do_reset failed for cmd=%p.\n", cmd);
#line 1403
    goto eh_reset_failed;
  } else {

  }
#line 1405
  err = 3;
#line 1406
  tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, (cmd->device)->id, (cmd->device)->lun,
                                                 type);
#line 1406
  if (tmp___2 != 0) {
#line 1408
    ql_log(1U, vha, 32781, "wait for pending cmds failed for cmd=%p.\n", cmd);
#line 1410
    goto eh_reset_failed;
  } else {

  }
#line 1413
  ql_log(2U, vha, 32782, "%s RESET SUCCEEDED nexus:%ld:%d:%d cmd=%p.\n", name, vha->host_no,
         (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1417
  return (8194);
  eh_reset_failed: 
#line 1420
  ql_log(2U, vha, 32783, "%s RESET FAILED: %s nexus=%ld:%d:%d cmd=%p.\n", name, reset_errors[err],
         vha->host_no, (cmd->device)->id, (cmd->device)->lun, cmd);
#line 1424
  return (8195);
}
}
#line 1428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_eh_device_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1430
  tmp = shost_priv((cmd->device)->host);
#line 1430
  vha = (scsi_qla_host_t *)tmp;
#line 1431
  ha = vha->hw;
#line 1433
  tmp___0 = __qla2xxx_eh_generic_reset((char *)"DEVICE", 2, cmd, (ha->isp_ops)->lun_reset);
#line 1433
  return (tmp___0);
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_eh_target_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1440
  tmp = shost_priv((cmd->device)->host);
#line 1440
  vha = (scsi_qla_host_t *)tmp;
#line 1441
  ha = vha->hw;
#line 1443
  tmp___0 = __qla2xxx_eh_generic_reset((char *)"TARGET", 1, cmd, (ha->isp_ops)->target_reset);
#line 1443
  return (tmp___0);
}
}
#line 1463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  fc_port_t *fcport ;
  int ret ;
  unsigned int id ;
  unsigned int lun ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1465
  tmp = shost_priv((cmd->device)->host);
#line 1465
  vha = (scsi_qla_host_t *)tmp;
#line 1466
  fcport = (fc_port_t *)(cmd->device)->hostdata;
#line 1467
  ret = 8195;
#line 1470
  id = (cmd->device)->id;
#line 1471
  lun = (cmd->device)->lun;
#line 1473
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1474
    return (ret);
  } else {

  }
#line 1477
  ret = fc_block_scsi_eh(cmd);
#line 1478
  if (ret != 0) {
#line 1479
    return (ret);
  } else {

  }
#line 1480
  ret = 8195;
#line 1482
  ql_log(2U, vha, 32786, "BUS RESET ISSUED nexus=%ld:%d:%d.\n", vha->host_no, id,
         lun);
#line 1485
  tmp___0 = qla2x00_wait_for_hba_online(vha);
#line 1485
  if (tmp___0 != 0) {
#line 1486
    ql_log(0U, vha, 32787, "Wait for hba online failed board disabled.\n");
#line 1488
    goto eh_bus_reset_done;
  } else {

  }
#line 1491
  tmp___1 = qla2x00_loop_reset(vha);
#line 1491
  if (tmp___1 == 0) {
#line 1492
    ret = 8194;
  } else {

  }
#line 1494
  if (ret == 8195) {
#line 1495
    goto eh_bus_reset_done;
  } else {

  }
#line 1498
  tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0U, 0);
#line 1498
  if (tmp___2 != 0) {
#line 1500
    ql_log(1U, vha, 32788, "Wait for pending commands failed.\n");
#line 1502
    ret = 8195;
  } else {

  }
  eh_bus_reset_done: 
#line 1506
  ql_log(1U, vha, 32811, "BUS RESET %s nexus=%ld:%d:%d.\n", ret == 8195 ? (char *)"FAILED" : (char *)"SUCCEEDED",
         vha->host_no, id, lun);
#line 1510
  return (ret);
}
}
#line 1529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_eh_host_reset(struct scsi_cmnd *cmd ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  unsigned int id ;
  unsigned int lun ;
  scsi_qla_host_t *base_vha ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1531
  tmp = shost_priv((cmd->device)->host);
#line 1531
  vha = (scsi_qla_host_t *)tmp;
#line 1532
  ha = vha->hw;
#line 1533
  ret = 8195;
#line 1535
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 1535
  base_vha = (scsi_qla_host_t *)tmp___0;
#line 1537
  id = (cmd->device)->id;
#line 1538
  lun = (cmd->device)->lun;
#line 1540
  ql_log(2U, vha, 32792, "ADAPTER RESET ISSUED nexus=%ld:%d:%d.\n", vha->host_no,
         id, lun);
#line 1543
  tmp___1 = qla2x00_wait_for_reset_ready(vha);
#line 1543
  if (tmp___1 != 0) {
#line 1544
    goto eh_host_reset_lock;
  } else {

  }
#line 1546
  if ((unsigned long )vha != (unsigned long )base_vha) {
#line 1547
    tmp___2 = qla2x00_vp_abort_isp(vha);
#line 1547
    if (tmp___2 != 0) {
#line 1548
      goto eh_host_reset_lock;
    } else {

    }
  } else {
#line 1550
    if (((vha->hw)->device_type & 16384U) != 0U || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1551
      tmp___3 = qla82xx_fcoe_ctx_reset(vha);
#line 1551
      if (tmp___3 == 0) {
#line 1553
        ret = 8194;
#line 1554
        goto eh_host_reset_lock;
      } else {

      }
    } else {

    }
#line 1558
    if ((unsigned long )ha->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 1559
      flush_workqueue(ha->wq);
    } else {

    }
#line 1561
    set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1562
    tmp___5 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 1562
    if (tmp___5 != 0) {
#line 1563
      clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1565
      set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 1567
      tmp___4 = qla2x00_wait_for_hba_online(vha);
#line 1567
      if (tmp___4 != 0) {
#line 1568
        ql_log(1U, vha, 32810, "wait for hba online failed.\n");
#line 1570
        goto eh_host_reset_lock;
      } else {

      }
    } else {

    }
#line 1573
    clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  }
#line 1577
  tmp___6 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0U, 0);
#line 1577
  if (tmp___6 == 0) {
#line 1579
    ret = 8194;
  } else {

  }
  eh_host_reset_lock: 
#line 1582
  ql_log(2U, vha, 32791, "ADAPTER RESET %s nexus=%ld:%d:%d.\n", ret == 8195 ? (char *)"FAILED" : (char *)"SUCCEEDED",
         vha->host_no, id, lun);
#line 1586
  return (ret);
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_loop_reset(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct fc_port *fcport ;
  struct qla_hw_data *ha ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1604
  ha = vha->hw;
#line 1606
  if ((ha->device_type & 131072U) != 0U) {
#line 1607
    tmp = qlafx00_loop_reset(vha);
#line 1607
    return (tmp);
  } else {

  }
#line 1610
  if (ql2xtargetreset == 1 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1611
    __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1611
    fcport = (struct fc_port *)__mptr;
#line 1611
    goto ldv_61712;
    ldv_61711: ;
#line 1612
    if ((unsigned int )fcport->port_type != 5U) {
#line 1613
      goto ldv_61710;
    } else {

    }
#line 1615
    ret = (*((ha->isp_ops)->target_reset))(fcport, 0U, 0);
#line 1616
    if (ret != 0) {
#line 1617
      ql_dbg(4194304U, vha, 32812, "Bus Reset failed: Reset=%d d_id=%x.\n", ret, (int )fcport->d_id.b24);
    } else {

    }
    ldv_61710: 
#line 1611
    __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1611
    fcport = (struct fc_port *)__mptr___0;
    ldv_61712: ;
#line 1611
    if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1613
      goto ldv_61711;
    } else {

    }

  } else {

  }
#line 1625
  if (*((unsigned long *)ha + 2UL) != 0UL && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) {
#line 1626
    atomic_set(& vha->loop_state, 2);
#line 1627
    atomic_set(& vha->loop_down_timer, 255);
#line 1628
    qla2x00_mark_all_devices_lost(vha, 0);
#line 1629
    ret = qla2x00_full_login_lip(vha);
#line 1630
    if (ret != 0) {
#line 1631
      ql_dbg(4194304U, vha, 32813, "full_login_lip=%d.\n", ret);
    } else {

    }
  } else {

  }
#line 1636
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1637
    ret = qla2x00_lip_reset(vha);
#line 1638
    if (ret != 0) {
#line 1639
      ql_dbg(4194304U, vha, 32814, "lip_reset failed (%d).\n", ret);
    } else {

    }
  } else {

  }
#line 1644
  vha->marker_needed = 1U;
#line 1646
  return (0);
}
}
#line 1650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_abort_all_cmds(scsi_qla_host_t *vha , int res ) 
{ 
  int que ;
  int cnt ;
  unsigned long flags ;
  srb_t *sp ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;

  {
#line 1655
  ha = vha->hw;
#line 1658
  tmp = spinlock_check(& ha->hardware_lock);
#line 1658
  flags = _raw_spin_lock_irqsave(tmp);
#line 1659
  que = 0;
#line 1659
  goto ldv_61732;
  ldv_61731: 
#line 1660
  req = *(ha->req_q_map + (unsigned long )que);
#line 1661
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 1662
    goto ldv_61727;
  } else {

  }
#line 1663
  if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1664
    goto ldv_61727;
  } else {

  }
#line 1665
  cnt = 1;
#line 1665
  goto ldv_61729;
  ldv_61728: 
#line 1666
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 1667
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1668
    *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 1669
    (*(sp->done))((void *)vha, (void *)sp, res);
  } else {

  }
#line 1665
  cnt = cnt + 1;
  ldv_61729: ;
#line 1665
  if ((int )req->num_outstanding_cmds > cnt) {
#line 1667
    goto ldv_61728;
  } else {

  }

  ldv_61727: 
#line 1659
  que = que + 1;
  ldv_61732: ;
#line 1659
  if ((int )ha->max_req_queues > que) {
#line 1661
    goto ldv_61731;
  } else {

  }
#line 1673
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1674
  return;
}
}
#line 1677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_slave_alloc(struct scsi_device *sdev ) 
{ 
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1679
  tmp___3 = scsi_target(sdev);
#line 1679
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 1679
  if (tmp___4 != 0) {
#line 1679
    tmp___1 = scsi_target(sdev);
#line 1679
    __mptr = (struct device  const  *)tmp___1->dev.parent;
#line 1679
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 1679
    tmp___2 = (struct fc_rport *)0;
  }
#line 1679
  rport = tmp___2;
#line 1681
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 1682
    return (-6);
  } else {
#line 1681
    tmp___5 = fc_remote_port_chkready(rport);
#line 1681
    if (tmp___5 != 0) {
#line 1682
      return (-6);
    } else {

    }
  }
#line 1684
  sdev->hostdata = (void *)*((fc_port_t **)rport->dd_data);
#line 1686
  return (0);
}
}
#line 1690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_slave_configure(struct scsi_device *sdev ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct req_que *req ;

  {
#line 1692
  tmp = shost_priv(sdev->host);
#line 1692
  vha = (scsi_qla_host_t *)tmp;
#line 1693
  req = vha->req;
#line 1695
  if (((vha->hw)->device_type & 33554432U) != 0U) {
#line 1696
    blk_queue_update_dma_alignment(sdev->request_queue, 7);
  } else {

  }
#line 1698
  if ((unsigned int )*((unsigned char *)sdev + 297UL) != 0U) {
#line 1699
    scsi_activate_tcq(sdev, req->max_q_depth);
  } else {
#line 1701
    scsi_deactivate_tcq(sdev, req->max_q_depth);
  }
#line 1702
  return (0);
}
}
#line 1706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2xxx_slave_destroy(struct scsi_device *sdev ) 
{ 


  {
#line 1708
  sdev->hostdata = (void *)0;
#line 1709
  return;
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_handle_queue_full(struct scsi_device *sdev , int qdepth ) 
{ 
  fc_port_t *fcport ;
  int tmp ;

  {
#line 1713
  fcport = (fc_port_t *)sdev->hostdata;
#line 1715
  tmp = scsi_track_queue_full(sdev, qdepth);
#line 1715
  if (tmp == 0) {
#line 1716
    return;
  } else {

  }
#line 1718
  ql_dbg(134217728U, fcport->vha, 12329, "Queue depth adjusted-down to %d for nexus=%ld:%d:%d.\n",
         (int )sdev->queue_depth, (fcport->vha)->host_no, sdev->id, sdev->lun);
#line 1721
  return;
}
}
#line 1723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_adjust_sdev_qdepth_up(struct scsi_device *sdev , int qdepth ) 
{ 
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct req_que *req ;

  {
#line 1725
  fcport = (fc_port_t *)sdev->hostdata;
#line 1726
  vha = fcport->vha;
#line 1727
  req = (struct req_que *)0;
#line 1729
  req = vha->req;
#line 1730
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 1731
    return;
  } else {

  }
#line 1733
  if (req->max_q_depth <= (int )sdev->queue_depth || req->max_q_depth < qdepth) {
#line 1734
    return;
  } else {

  }
#line 1736
  if ((unsigned int )*((unsigned char *)sdev + 297UL) != 0U) {
#line 1737
    scsi_adjust_queue_depth(sdev, 34, qdepth);
  } else {
#line 1739
    scsi_adjust_queue_depth(sdev, 32, qdepth);
  }
#line 1741
  ql_dbg(134217728U, vha, 12330, "Queue depth adjusted-up to %d for nexus=%ld:%d:%d.\n",
         (int )sdev->queue_depth, (fcport->vha)->host_no, sdev->id, sdev->lun);
#line 1744
  return;
}
}
#line 1747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_change_queue_depth(struct scsi_device *sdev , int qdepth , int reason ) 
{ 
  int tmp ;

  {
#line 1749
  switch (reason) {
  case 0: 
#line 1751
  tmp = scsi_get_tag_type(sdev);
#line 1751
  scsi_adjust_queue_depth(sdev, tmp, qdepth);
#line 1752
  goto ldv_61766;
  case 1: 
#line 1754
  qla2x00_handle_queue_full(sdev, qdepth);
#line 1755
  goto ldv_61766;
  case 2: 
#line 1757
  qla2x00_adjust_sdev_qdepth_up(sdev, qdepth);
#line 1758
  goto ldv_61766;
  default: ;
#line 1760
  return (-95);
  }
  ldv_61766: ;
#line 1763
  return ((int )sdev->queue_depth);
}
}
#line 1767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_change_queue_type(struct scsi_device *sdev , int tag_type ) 
{ 


  {
#line 1769
  if ((unsigned int )*((unsigned char *)sdev + 297UL) != 0U) {
#line 1770
    scsi_set_tag_type(sdev, tag_type);
#line 1771
    if (tag_type != 0) {
#line 1772
      scsi_activate_tcq(sdev, (int )sdev->queue_depth);
    } else {
#line 1774
      scsi_deactivate_tcq(sdev, (int )sdev->queue_depth);
    }
  } else {
#line 1776
    tag_type = 0;
  }
#line 1778
  return (tag_type);
}
}
#line 1782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_host_ramp_down_queuedepth(scsi_qla_host_t *vha ) 
{ 
  scsi_qla_host_t *vp ;
  struct Scsi_Host *shost ;
  struct scsi_device *sdev ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1787
  ha = vha->hw;
#line 1790
  ha->host_last_rampdown_time = jiffies;
#line 1792
  if (ha->cfg_lun_q_depth <= (int )(vha->host)->cmd_per_lun) {
#line 1793
    return;
  } else {

  }
#line 1795
  if (ha->cfg_lun_q_depth / 2 < (int )(vha->host)->cmd_per_lun) {
#line 1796
    ha->cfg_lun_q_depth = (int )(vha->host)->cmd_per_lun;
  } else {
#line 1798
    ha->cfg_lun_q_depth = ha->cfg_lun_q_depth / 2;
  }
#line 1804
  tmp = spinlock_check(& ha->vport_slock);
#line 1804
  flags = _raw_spin_lock_irqsave(tmp);
#line 1805
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 1805
  vp = (scsi_qla_host_t *)__mptr;
#line 1805
  goto ldv_61794;
  ldv_61793: 
#line 1806
  shost = vp->host;
#line 1807
  sdev = __scsi_iterate_devices(shost, (struct scsi_device *)0);
#line 1807
  goto ldv_61791;
  ldv_61790: ;
#line 1808
  if ((int )sdev->queue_depth > (int )shost->cmd_per_lun) {
#line 1809
    if ((int )sdev->queue_depth < ha->cfg_lun_q_depth) {
#line 1810
      goto ldv_61789;
    } else {

    }
#line 1811
    ql_dbg(134217728U, vp, 12337, "%ld:%d:%d: Ramping down queue depth to %d", vp->host_no,
           sdev->id, sdev->lun, ha->cfg_lun_q_depth);
#line 1815
    qla2x00_change_queue_depth(sdev, ha->cfg_lun_q_depth, 0);
  } else {

  }
  ldv_61789: 
#line 1807
  sdev = __scsi_iterate_devices(shost, sdev);
  ldv_61791: ;
#line 1807
  if ((unsigned long )sdev != (unsigned long )((struct scsi_device *)0)) {
#line 1809
    goto ldv_61790;
  } else {

  }
#line 1805
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 1805
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_61794: ;
#line 1805
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 1807
    goto ldv_61793;
  } else {

  }
#line 1820
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 1822
  return;
}
}
#line 1826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_host_ramp_up_queuedepth(scsi_qla_host_t *vha ) 
{ 
  scsi_qla_host_t *vp ;
  struct Scsi_Host *shost ;
  struct scsi_device *sdev ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1831
  ha = vha->hw;
#line 1834
  ha->host_last_rampup_time = jiffies;
#line 1835
  ha->cfg_lun_q_depth = ha->cfg_lun_q_depth + 1;
#line 1841
  tmp = spinlock_check(& ha->vport_slock);
#line 1841
  flags = _raw_spin_lock_irqsave(tmp);
#line 1842
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 1842
  vp = (scsi_qla_host_t *)__mptr;
#line 1842
  goto ldv_61816;
  ldv_61815: 
#line 1843
  shost = vp->host;
#line 1844
  sdev = __scsi_iterate_devices(shost, (struct scsi_device *)0);
#line 1844
  goto ldv_61813;
  ldv_61812: ;
#line 1845
  if ((int )sdev->queue_depth > ha->cfg_lun_q_depth) {
#line 1846
    goto ldv_61811;
  } else {

  }
#line 1847
  qla2x00_change_queue_depth(sdev, ha->cfg_lun_q_depth, 2);
  ldv_61811: 
#line 1844
  sdev = __scsi_iterate_devices(shost, sdev);
  ldv_61813: ;
#line 1844
  if ((unsigned long )sdev != (unsigned long )((struct scsi_device *)0)) {
#line 1846
    goto ldv_61812;
  } else {

  }
#line 1842
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 1842
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_61816: ;
#line 1842
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 1844
    goto ldv_61815;
  } else {

  }
#line 1851
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 1853
  return;
}
}
#line 1864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_config_dma_addressing(struct qla_hw_data *ha ) 
{ 
  u64 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1867
  ha->flags.enable_64bit_addressing = 0U;
#line 1869
  tmp___1 = dma_set_mask(& (ha->pdev)->dev, 0xffffffffffffffffULL);
#line 1869
  if (tmp___1 == 0) {
#line 1871
    tmp = dma_get_required_mask(& (ha->pdev)->dev);
#line 1871
    if ((unsigned int )(tmp >> 32ULL) != 0U) {
#line 1871
      tmp___0 = pci_set_consistent_dma_mask(ha->pdev, 0xffffffffffffffffULL);
#line 1871
      if (tmp___0 == 0) {
#line 1874
        ha->flags.enable_64bit_addressing = 1U;
#line 1875
        (ha->isp_ops)->calc_req_entries = & qla2x00_calc_iocbs_64;
#line 1876
        (ha->isp_ops)->build_iocbs = & qla2x00_build_scsi_iocbs_64;
#line 1877
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1881
  dma_set_mask(& (ha->pdev)->dev, 4294967295ULL);
#line 1882
  pci_set_consistent_dma_mask(ha->pdev, 4294967295ULL);
#line 1883
  return;
}
}
#line 1886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1888
  flags = 0UL;
#line 1889
  reg = & (ha->iobase)->isp;
#line 1891
  tmp = spinlock_check(& ha->hardware_lock);
#line 1891
  flags = _raw_spin_lock_irqsave(tmp);
#line 1892
  ha->interrupts_on = 1U;
#line 1894
  writew(32776, (void volatile   *)(& reg->ictrl));
#line 1895
  readw((void const volatile   *)(& reg->ictrl));
#line 1896
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1897
  return;
}
}
#line 1901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1903
  flags = 0UL;
#line 1904
  reg = & (ha->iobase)->isp;
#line 1906
  tmp = spinlock_check(& ha->hardware_lock);
#line 1906
  flags = _raw_spin_lock_irqsave(tmp);
#line 1907
  ha->interrupts_on = 0U;
#line 1909
  writew(0, (void volatile   *)(& reg->ictrl));
#line 1910
  readw((void const volatile   *)(& reg->ictrl));
#line 1911
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1912
  return;
}
}
#line 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla24xx_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1917
  flags = 0UL;
#line 1918
  reg = & (ha->iobase)->isp24;
#line 1920
  tmp = spinlock_check(& ha->hardware_lock);
#line 1920
  flags = _raw_spin_lock_irqsave(tmp);
#line 1921
  ha->interrupts_on = 1U;
#line 1922
  writel(8U, (void volatile   *)(& reg->ictrl));
#line 1923
  readl((void const volatile   *)(& reg->ictrl));
#line 1924
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1925
  return;
}
}
#line 1928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla24xx_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1930
  flags = 0UL;
#line 1931
  reg = & (ha->iobase)->isp24;
#line 1933
  if ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1934
    return;
  } else {

  }
#line 1935
  tmp = spinlock_check(& ha->hardware_lock);
#line 1935
  flags = _raw_spin_lock_irqsave(tmp);
#line 1936
  ha->interrupts_on = 0U;
#line 1937
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1938
  readl((void const volatile   *)(& reg->ictrl));
#line 1939
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1940
  return;
}
}
#line 1943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_iospace_config(struct qla_hw_data *ha ) 
{ 
  resource_size_t pio ;
  uint16_t msix ;
  int cpus ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  uint8_t tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 1949
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 1949
  if (tmp___0 != 0) {
#line 1951
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1951
    ql_log_pci(0U, ha->pdev, 17, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 1954
    goto iospace_error_exit;
  } else {

  }
#line 1956
  if ((ha->bars & 1) == 0) {
#line 1957
    goto skip_pio;
  } else {

  }
#line 1960
  pio = (ha->pdev)->resource[0].start;
#line 1961
  if (((ha->pdev)->resource[0].flags & 256UL) != 0UL) {
#line 1962
    if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 255ULL) {
#line 1963
      tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1963
      ql_log_pci(1U, ha->pdev, 18, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 1966
      pio = 0ULL;
    } else {

    }
  } else {
#line 1969
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1969
    ql_log_pci(1U, ha->pdev, 19, "Region #0 no a PIO resource (%s).\n", tmp___2);
#line 1972
    pio = 0ULL;
  }
#line 1974
  ha->pio_address = pio;
#line 1975
  ql_dbg_pci(1073741824U, ha->pdev, 20, "PIO address=%llu.\n", ha->pio_address);
  skip_pio: ;
#line 1981
  if (((ha->pdev)->resource[1].flags & 512UL) == 0UL) {
#line 1982
    tmp___3 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1982
    ql_log_pci(0U, ha->pdev, 21, "Region #1 not an MMIO resource (%s), aborting.\n",
               tmp___3);
#line 1985
    goto iospace_error_exit;
  } else {

  }
#line 1987
  if (((ha->pdev)->resource[1].start == 0ULL && (ha->pdev)->resource[1].end == (ha->pdev)->resource[1].start) || ((ha->pdev)->resource[1].end - (ha->pdev)->resource[1].start) + 1ULL <= 255ULL) {
#line 1988
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1988
    ql_log_pci(0U, ha->pdev, 22, "Invalid PCI mem region size (%s), aborting.\n",
               tmp___4);
#line 1991
    goto iospace_error_exit;
  } else {

  }
#line 1994
  tmp___5 = ioremap((ha->pdev)->resource[1].start, 256UL);
#line 1994
  ha->iobase = (device_reg_t *)tmp___5;
#line 1995
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 1996
    tmp___6 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1996
    ql_log_pci(0U, ha->pdev, 23, "Cannot remap MMIO (%s), aborting.\n", tmp___6);
#line 1999
    goto iospace_error_exit;
  } else {

  }
#line 2003
  tmp___7 = 1U;
#line 2003
  ha->max_rsp_queues = tmp___7;
#line 2003
  ha->max_req_queues = tmp___7;
#line 2004
  if (((ql2xmaxqueues <= 1 && ql2xmultique_tag == 0) || (ql2xmaxqueues > 1 && ql2xmultique_tag != 0)) || ((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U)) {
#line 2007
    goto mqiobase_exit;
  } else {

  }
#line 2009
  tmp___8 = ioremap((ha->pdev)->resource[3].start, (ha->pdev)->resource[3].start != 0ULL || (ha->pdev)->resource[3].end != (ha->pdev)->resource[3].start ? (unsigned long )(((ha->pdev)->resource[3].end - (ha->pdev)->resource[3].start) + 1ULL) : 0UL);
#line 2009
  ha->mqiobase = (device_reg_t *)tmp___8;
#line 2011
  if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) {
#line 2012
    ql_dbg_pci(1073741824U, ha->pdev, 24, "MQIO Base=%p.\n", ha->mqiobase);
#line 2015
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 162, & msix);
#line 2016
    ha->msix_count = msix;
#line 2019
    if (ql2xmultique_tag != 0) {
#line 2020
      tmp___9 = cpumask_weight(cpu_online_mask);
#line 2020
      cpus = (int )tmp___9;
#line 2021
      ha->max_rsp_queues = (int )ha->msix_count + -1 > cpus ? (unsigned int )((uint8_t )cpus) + 1U : (unsigned int )((uint8_t )ha->msix_count) + 255U;
#line 2023
      ha->max_req_queues = 2U;
    } else
#line 2024
    if (ql2xmaxqueues > 1) {
#line 2025
      ha->max_req_queues = (uint8_t )(32 < ql2xmaxqueues ? 32 : ql2xmaxqueues);
#line 2027
      ql_dbg_pci(1048576U, ha->pdev, 49160, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
#line 2030
      ql_dbg_pci(1073741824U, ha->pdev, 25, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
    } else {

    }
#line 2034
    ql_log_pci(2U, ha->pdev, 26, "MSI-X vector count: %d.\n", (int )msix);
  } else {
#line 2037
    ql_log_pci(2U, ha->pdev, 27, "BAR 3 not enabled.\n");
  }
  mqiobase_exit: 
#line 2041
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 2042
  ql_dbg_pci(1073741824U, ha->pdev, 28, "MSIX Count:%d.\n", (int )ha->msix_count);
#line 2044
  return (0);
  iospace_error_exit: ;
#line 2047
  return (-12);
}
}
#line 2052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla83xx_iospace_config(struct qla_hw_data *ha ) 
{ 
  uint16_t msix ;
  int cpus ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  uint8_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 2057
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 2057
  if (tmp___0 != 0) {
#line 2059
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 2059
    ql_log_pci(0U, ha->pdev, 279, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 2063
    goto iospace_error_exit;
  } else {

  }
#line 2067
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 2068
    tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 2068
    ql_log_pci(1U, ha->pdev, 280, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 2071
    goto iospace_error_exit;
  } else {

  }
#line 2073
  if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 255ULL) {
#line 2074
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 2074
    ql_log_pci(1U, ha->pdev, 281, "Invalid PCI mem region size (%s), aborting\n",
               tmp___2);
#line 2077
    goto iospace_error_exit;
  } else {

  }
#line 2080
  tmp___3 = ioremap((ha->pdev)->resource[0].start, 256UL);
#line 2080
  ha->iobase = (device_reg_t *)tmp___3;
#line 2081
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 2082
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 2082
    ql_log_pci(0U, ha->pdev, 282, "Cannot remap MMIO (%s), aborting.\n", tmp___4);
#line 2085
    goto iospace_error_exit;
  } else {

  }
#line 2091
  tmp___5 = 1U;
#line 2091
  ha->max_rsp_queues = tmp___5;
#line 2091
  ha->max_req_queues = tmp___5;
#line 2092
  tmp___6 = ioremap((ha->pdev)->resource[4].start, (ha->pdev)->resource[4].start != 0ULL || (ha->pdev)->resource[4].end != (ha->pdev)->resource[4].start ? (unsigned long )(((ha->pdev)->resource[4].end - (ha->pdev)->resource[4].start) + 1ULL) : 0UL);
#line 2092
  ha->mqiobase = (device_reg_t *)tmp___6;
#line 2095
  if ((unsigned long )ha->mqiobase == (unsigned long )((device_reg_t *)0)) {
#line 2096
    ql_log_pci(0U, ha->pdev, 285, "BAR2/region4 not enabled\n");
#line 2098
    goto mqiobase_exit;
  } else {

  }
#line 2101
  tmp___7 = ioremap((ha->pdev)->resource[2].start, (ha->pdev)->resource[2].start != 0ULL || (ha->pdev)->resource[2].end != (ha->pdev)->resource[2].start ? (unsigned long )(((ha->pdev)->resource[2].end - (ha->pdev)->resource[2].start) + 1ULL) : 0UL);
#line 2101
  ha->msixbase = (device_reg_t *)tmp___7;
#line 2103
  if ((unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0)) {
#line 2105
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 146, & msix);
#line 2107
    ha->msix_count = msix;
#line 2110
    if (ql2xmultique_tag != 0) {
#line 2111
      tmp___8 = cpumask_weight(cpu_online_mask);
#line 2111
      cpus = (int )tmp___8;
#line 2112
      ha->max_rsp_queues = (int )ha->msix_count + -1 > cpus ? (unsigned int )((uint8_t )cpus) + 1U : (unsigned int )((uint8_t )ha->msix_count) + 255U;
#line 2114
      ha->max_req_queues = 2U;
    } else
#line 2115
    if (ql2xmaxqueues > 1) {
#line 2116
      ha->max_req_queues = (uint8_t )(32 < ql2xmaxqueues ? 32 : ql2xmaxqueues);
#line 2118
      ql_dbg_pci(1048576U, ha->pdev, 49164, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
#line 2121
      ql_dbg_pci(1073741824U, ha->pdev, 283, "QoS mode set, max no of request queues:%d.\n",
                 (int )ha->max_req_queues);
    } else {

    }
#line 2125
    ql_log_pci(2U, ha->pdev, 284, "MSI-X vector count: %d.\n", (int )msix);
  } else {
#line 2128
    ql_log_pci(2U, ha->pdev, 286, "BAR 1 not enabled.\n");
  }
  mqiobase_exit: 
#line 2132
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 2134
  qlt_83xx_iospace_config(ha);
#line 2136
  ql_dbg_pci(1073741824U, ha->pdev, 287, "MSIX Count:%d.\n", (int )ha->msix_count);
#line 2138
  return (0);
  iospace_error_exit: ;
#line 2141
  return (-12);
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla2100_isp_ops  = 
#line 2144
     {& qla2100_pci_config, & qla2x00_reset_chip, & qla2x00_chip_diag, & qla2x00_config_rings,
    & qla2x00_reset_adapter, & qla2x00_nvram_config, & qla2x00_update_fw_options,
    & qla2x00_load_risc, & qla2x00_pci_info_str, & qla2x00_fw_version_str, & qla2100_intr_handler,
    & qla2x00_enable_intrs, & qla2x00_disable_intrs, & qla2x00_abort_command, & qla2x00_abort_target,
    & qla2x00_lun_reset, & qla2x00_login_fabric, & qla2x00_fabric_logout, & qla2x00_calc_iocbs_32,
    & qla2x00_build_scsi_iocbs_32, & qla2x00_prep_ms_iocb, & qla2x00_prep_ms_fdmi_iocb,
    & qla2x00_read_nvram_data, & qla2x00_write_nvram_data, & qla2100_fw_dump, (int (*)(struct scsi_qla_host * ))0,
    (int (*)(struct scsi_qla_host * ))0, (void (*)(struct scsi_qla_host * ))0, & qla2x00_read_optrom_data,
    & qla2x00_write_optrom_data, & qla2x00_get_flash_version, & qla2x00_start_scsi,
    & qla2x00_abort_isp, & qla2x00_iospace_config, & qla2x00_initialize_adapter};
#line 2182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla2300_isp_ops  = 
#line 2182
     {& qla2300_pci_config, & qla2x00_reset_chip, & qla2x00_chip_diag, & qla2x00_config_rings,
    & qla2x00_reset_adapter, & qla2x00_nvram_config, & qla2x00_update_fw_options,
    & qla2x00_load_risc, & qla2x00_pci_info_str, & qla2x00_fw_version_str, & qla2300_intr_handler,
    & qla2x00_enable_intrs, & qla2x00_disable_intrs, & qla2x00_abort_command, & qla2x00_abort_target,
    & qla2x00_lun_reset, & qla2x00_login_fabric, & qla2x00_fabric_logout, & qla2x00_calc_iocbs_32,
    & qla2x00_build_scsi_iocbs_32, & qla2x00_prep_ms_iocb, & qla2x00_prep_ms_fdmi_iocb,
    & qla2x00_read_nvram_data, & qla2x00_write_nvram_data, & qla2300_fw_dump, & qla2x00_beacon_on,
    & qla2x00_beacon_off, & qla2x00_beacon_blink, & qla2x00_read_optrom_data, & qla2x00_write_optrom_data,
    & qla2x00_get_flash_version, & qla2x00_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 2220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla24xx_isp_ops  = 
#line 2220
     {& qla24xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla24xx_nvram_config, & qla24xx_update_fw_options,
    & qla24xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla24xx_read_nvram_data, & qla24xx_write_nvram_data, & qla24xx_fw_dump, & qla24xx_beacon_on,
    & qla24xx_beacon_off, & qla24xx_beacon_blink, & qla24xx_read_optrom_data, & qla24xx_write_optrom_data,
    & qla24xx_get_flash_version, & qla24xx_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 2258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla25xx_isp_ops  = 
#line 2258
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla24xx_nvram_config, & qla24xx_update_fw_options,
    & qla24xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla25xx_read_nvram_data, & qla25xx_write_nvram_data, & qla25xx_fw_dump, & qla24xx_beacon_on,
    & qla24xx_beacon_off, & qla24xx_beacon_blink, & qla25xx_read_optrom_data, & qla24xx_write_optrom_data,
    & qla24xx_get_flash_version, & qla24xx_dif_start_scsi, & qla2x00_abort_isp, & qla2x00_iospace_config,
    & qla2x00_initialize_adapter};
#line 2296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla81xx_isp_ops  = 
#line 2296
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla81xx_update_fw_options,
    & qla81xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla81xx_fw_dump,
    & qla24xx_beacon_on, & qla24xx_beacon_off, & qla83xx_beacon_blink, & qla25xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qla24xx_dif_start_scsi,
    & qla2x00_abort_isp, & qla2x00_iospace_config, & qla2x00_initialize_adapter};
#line 2334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla82xx_isp_ops  = 
#line 2334
     {& qla82xx_pci_config, & qla82xx_reset_chip, & qla24xx_chip_diag, & qla82xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla24xx_update_fw_options,
    & qla82xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla82xx_intr_handler,
    & qla82xx_enable_intrs, & qla82xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    & qla24xx_read_nvram_data, & qla24xx_write_nvram_data, & qla24xx_fw_dump, & qla82xx_beacon_on,
    & qla82xx_beacon_off, (void (*)(struct scsi_qla_host * ))0, & qla82xx_read_optrom_data,
    & qla82xx_write_optrom_data, & qla82xx_get_flash_version, & qla82xx_start_scsi,
    & qla82xx_abort_isp, & qla82xx_iospace_config, & qla2x00_initialize_adapter};
#line 2372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla8044_isp_ops  = 
#line 2372
     {& qla82xx_pci_config, & qla82xx_reset_chip, & qla24xx_chip_diag, & qla82xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla24xx_update_fw_options,
    & qla82xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla8044_intr_handler,
    & qla82xx_enable_intrs, & qla82xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla24xx_fw_dump,
    & qla82xx_beacon_on, & qla82xx_beacon_off, (void (*)(struct scsi_qla_host * ))0,
    & qla82xx_read_optrom_data, & qla8044_write_optrom_data, & qla82xx_get_flash_version,
    & qla82xx_start_scsi, & qla8044_abort_isp, & qla82xx_iospace_config, & qla2x00_initialize_adapter};
#line 2410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qla83xx_isp_ops  = 
#line 2410
     {& qla25xx_pci_config, & qla24xx_reset_chip, & qla24xx_chip_diag, & qla24xx_config_rings,
    & qla24xx_reset_adapter, & qla81xx_nvram_config, & qla81xx_update_fw_options,
    & qla81xx_load_risc, & qla24xx_pci_info_str, & qla24xx_fw_version_str, & qla24xx_intr_handler,
    & qla24xx_enable_intrs, & qla24xx_disable_intrs, & qla24xx_abort_command, & qla24xx_abort_target,
    & qla24xx_lun_reset, & qla24xx_login_fabric, & qla24xx_fabric_logout, (uint16_t (*)(uint16_t  ))0,
    (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0, & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb,
    (uint8_t *(*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0,
    (int (*)(struct scsi_qla_host * , uint8_t * , uint32_t  , uint32_t  ))0, & qla83xx_fw_dump,
    & qla24xx_beacon_on, & qla24xx_beacon_off, & qla83xx_beacon_blink, & qla25xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qla24xx_dif_start_scsi,
    & qla2x00_abort_isp, & qla83xx_iospace_config, & qla2x00_initialize_adapter};
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct isp_operations qlafx00_isp_ops  = 
#line 2448
     {& qlafx00_pci_config, & qlafx00_soft_reset, & qlafx00_chip_diag, & qlafx00_config_rings,
    & qlafx00_soft_reset, (int (*)(struct scsi_qla_host * ))0, (void (*)(struct scsi_qla_host * ))0,
    (int (*)(struct scsi_qla_host * , uint32_t * ))0, & qlafx00_pci_info_str, & qlafx00_fw_version_str,
    & qlafx00_intr_handler, & qlafx00_enable_intrs, & qlafx00_disable_intrs, & qlafx00_abort_command,
    & qlafx00_abort_target, & qlafx00_lun_reset, (int (*)(struct scsi_qla_host * ,
                                                          uint16_t  , uint8_t  , uint8_t  ,
                                                          uint8_t  , uint16_t * ,
                                                          uint8_t  ))0, (int (*)(struct scsi_qla_host * ,
                                                                                 uint16_t  ,
                                                                                 uint8_t  ,
                                                                                 uint8_t  ,
                                                                                 uint8_t  ))0,
    (uint16_t (*)(uint16_t  ))0, (void (*)(srb_t * , cmd_entry_t * , uint16_t  ))0,
    & qla24xx_prep_ms_iocb, & qla24xx_prep_ms_fdmi_iocb, & qla24xx_read_nvram_data,
    & qla24xx_write_nvram_data, (void (*)(struct scsi_qla_host * , int  ))0, & qla24xx_beacon_on,
    & qla24xx_beacon_off, (void (*)(struct scsi_qla_host * ))0, & qla24xx_read_optrom_data,
    & qla24xx_write_optrom_data, & qla24xx_get_flash_version, & qlafx00_start_scsi,
    & qlafx00_abort_isp, & qlafx00_iospace_config, & qlafx00_initialize_adapter};
#line 2487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void qla2x00_set_isp_flags(struct qla_hw_data *ha ) 
{ 


  {
#line 2489
  ha->device_type = 2147483648U;
#line 2490
  switch ((int )(ha->pdev)->device) {
  case 8448: 
#line 2492
  ha->device_type = ha->device_type | 1U;
#line 2493
  ha->device_type = ha->device_type & 2147483647U;
#line 2494
  ha->fw_srisc_address = 4096U;
#line 2495
  goto ldv_61882;
  case 8704: 
#line 2497
  ha->device_type = ha->device_type | 2U;
#line 2498
  ha->device_type = ha->device_type & 2147483647U;
#line 2499
  ha->fw_srisc_address = 4096U;
#line 2500
  goto ldv_61882;
  case 8960: 
#line 2502
  ha->device_type = ha->device_type | 4U;
#line 2503
  ha->device_type = ha->device_type | 268435456U;
#line 2504
  ha->fw_srisc_address = 2048U;
#line 2505
  goto ldv_61882;
  case 8978: 
#line 2507
  ha->device_type = ha->device_type | 8U;
#line 2508
  ha->device_type = ha->device_type | 268435456U;
#line 2509
  ha->fw_srisc_address = 2048U;
#line 2510
  goto ldv_61882;
  case 8994: 
#line 2512
  ha->device_type = ha->device_type | 16U;
#line 2513
  ha->device_type = ha->device_type | 268435456U;
#line 2514
  if ((unsigned int )(ha->pdev)->subsystem_vendor == 4136U && (unsigned int )(ha->pdev)->subsystem_device == 368U) {
#line 2516
    ha->device_type = ha->device_type | 536870912U;
  } else {

  }
#line 2517
  ha->fw_srisc_address = 2048U;
#line 2518
  goto ldv_61882;
  case 25362: 
#line 2520
  ha->device_type = ha->device_type | 32U;
#line 2521
  ha->fw_srisc_address = 2048U;
#line 2522
  goto ldv_61882;
  case 25378: 
#line 2524
  ha->device_type = ha->device_type | 64U;
#line 2525
  ha->fw_srisc_address = 2048U;
#line 2526
  goto ldv_61882;
  case 9250: 
#line 2528
  ha->device_type = ha->device_type | 128U;
#line 2529
  ha->device_type = ha->device_type | 268435456U;
#line 2530
  ha->device_type = ha->device_type | 134217728U;
#line 2531
  ha->device_type = ha->device_type | 67108864U;
#line 2532
  ha->fw_srisc_address = 1048576U;
#line 2533
  goto ldv_61882;
  case 9266: 
#line 2535
  ha->device_type = ha->device_type | 256U;
#line 2536
  ha->device_type = ha->device_type | 268435456U;
#line 2537
  ha->device_type = ha->device_type | 134217728U;
#line 2538
  ha->device_type = ha->device_type | 67108864U;
#line 2539
  ha->fw_srisc_address = 1048576U;
#line 2540
  goto ldv_61882;
  case 33842: 
#line 2542
  ha->device_type = ha->device_type | 4096U;
#line 2543
  ha->device_type = ha->device_type | 268435456U;
#line 2544
  ha->device_type = ha->device_type | 134217728U;
#line 2545
  ha->device_type = ha->device_type | 67108864U;
#line 2546
  ha->fw_srisc_address = 1048576U;
#line 2547
  goto ldv_61882;
  case 21538: 
#line 2549
  ha->device_type = ha->device_type | 512U;
#line 2550
  ha->device_type = ha->device_type | 134217728U;
#line 2551
  ha->fw_srisc_address = 1048576U;
#line 2552
  goto ldv_61882;
  case 21554: 
#line 2554
  ha->device_type = ha->device_type | 1024U;
#line 2555
  ha->device_type = ha->device_type | 134217728U;
#line 2556
  ha->fw_srisc_address = 1048576U;
#line 2557
  goto ldv_61882;
  case 9522: 
#line 2559
  ha->device_type = ha->device_type | 2048U;
#line 2560
  ha->device_type = ha->device_type | 268435456U;
#line 2561
  ha->device_type = ha->device_type | 134217728U;
#line 2562
  ha->device_type = ha->device_type | 67108864U;
#line 2563
  ha->fw_srisc_address = 1048576U;
#line 2564
  goto ldv_61882;
  case 32769: 
#line 2566
  ha->device_type = ha->device_type | 8192U;
#line 2567
  ha->device_type = ha->device_type | 268435456U;
#line 2568
  ha->device_type = ha->device_type | 134217728U;
#line 2569
  ha->device_type = ha->device_type | 67108864U;
#line 2570
  ha->fw_srisc_address = 1048576U;
#line 2571
  goto ldv_61882;
  case 32801: 
#line 2573
  ha->device_type = ha->device_type | 16384U;
#line 2574
  ha->device_type = ha->device_type | 268435456U;
#line 2575
  ha->device_type = ha->device_type | 134217728U;
#line 2576
  ha->fw_srisc_address = 1048576U;
#line 2578
  qla82xx_init_flags(ha);
#line 2579
  goto ldv_61882;
  case 32836: 
#line 2581
  ha->device_type = ha->device_type | 262144U;
#line 2582
  ha->device_type = ha->device_type | 268435456U;
#line 2583
  ha->device_type = ha->device_type | 134217728U;
#line 2584
  ha->fw_srisc_address = 1048576U;
#line 2586
  qla82xx_init_flags(ha);
#line 2587
  goto ldv_61882;
  case 8241: 
#line 2589
  ha->device_type = ha->device_type | 32768U;
#line 2590
  ha->device_type = ha->device_type | 268435456U;
#line 2591
  ha->device_type = ha->device_type | 134217728U;
#line 2592
  ha->device_type = ha->device_type | 67108864U;
#line 2593
  ha->device_type = ha->device_type | 33554432U;
#line 2594
  ha->fw_srisc_address = 1048576U;
#line 2595
  goto ldv_61882;
  case 32817: 
#line 2597
  ha->device_type = ha->device_type | 65536U;
#line 2598
  ha->device_type = ha->device_type | 268435456U;
#line 2599
  ha->device_type = ha->device_type | 134217728U;
#line 2600
  ha->device_type = ha->device_type | 67108864U;
#line 2601
  ha->device_type = ha->device_type | 33554432U;
#line 2602
  ha->fw_srisc_address = 1048576U;
#line 2603
  goto ldv_61882;
  case 61441: 
#line 2605
  ha->device_type = ha->device_type | 131072U;
#line 2606
  goto ldv_61882;
  }
  ldv_61882: ;
#line 2609
  if ((ha->device_type & 16384U) != 0U) {
#line 2610
    ha->port_no = ((int )ha->portnum & 1) == 0;
  } else {
#line 2613
    pci_read_config_byte((struct pci_dev  const  *)ha->pdev, 61, & ha->port_no);
  }
#line 2615
  if ((int )ha->port_no & 1) {
#line 2616
    ha->flags.port0 = 1U;
  } else {
#line 2618
    ha->flags.port0 = 0U;
  }
#line 2619
  ql_dbg_pci(1073741824U, ha->pdev, 11, "device_type=0x%x port=%d fw_srisc_address=0x%x.\n",
             ha->device_type, (int )ha->flags.port0, ha->fw_srisc_address);
#line 2622
  return;
}
}
#line 2625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2xxx_scan_start(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2627
  tmp = shost_priv(shost);
#line 2627
  vha = (scsi_qla_host_t *)tmp;
#line 2629
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 2630
    return;
  } else {

  }
#line 2632
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2633
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2634
  set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2635
  set_bit(16L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2636
  return;
}
}
#line 2639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2xxx_scan_finished(struct Scsi_Host *shost , unsigned long time ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2641
  tmp = shost_priv(shost);
#line 2641
  vha = (scsi_qla_host_t *)tmp;
#line 2643
  if ((unsigned long )vha->host == (unsigned long )((struct Scsi_Host *)0)) {
#line 2644
    return (1);
  } else {

  }
#line 2645
  if ((unsigned long )((int )(vha->hw)->loop_reset_delay * 250) < time) {
#line 2646
    return (1);
  } else {

  }
#line 2648
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 2648
  return (tmp___0 == 5);
}
}
#line 2655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_probe_one(struct pci_dev *pdev , struct pci_device_id  const  *id ) 
{ 
  int ret ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *base_vha ;
  struct qla_hw_data *ha ;
  char pci_info[30U] ;
  char fw_str[30U] ;
  char wq_name[30U] ;
  struct scsi_host_template *sht ;
  int bars ;
  int mem_only ;
  uint16_t req_length ;
  uint16_t rsp_length ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct scsi_qla_host *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  struct lock_class_key __key___3 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___8 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___5 ;
  char const   *__lock_name___0 ;
  struct workqueue_struct *tmp___9 ;
  struct lock_class_key __key___6 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___7 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___8 ;
  atomic_long_t __constr_expr_3 ;
  int prot ;
  int guard ;
  bool tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  uint8_t tmp___14 ;
  struct task_struct *t ;

  {
#line 2657
  ret = -19;
#line 2659
  base_vha = (scsi_qla_host_t *)0;
#line 2664
  mem_only = 0;
#line 2665
  req_length = 0U;
#line 2665
  rsp_length = 0U;
#line 2666
  req = (struct req_que *)0;
#line 2667
  rsp = (struct rsp_que *)0;
#line 2668
  bars = pci_select_bars(pdev, 768UL);
#line 2669
  sht = & qla2xxx_driver_template;
#line 2670
  if ((((((((((((unsigned int )pdev->device == 9250U || (unsigned int )pdev->device == 9266U) || (unsigned int )pdev->device == 33842U) || (unsigned int )pdev->device == 21538U) || (unsigned int )pdev->device == 21554U) || (unsigned int )pdev->device == 9522U) || (unsigned int )pdev->device == 32769U) || (unsigned int )pdev->device == 32801U) || (unsigned int )pdev->device == 8241U) || (unsigned int )pdev->device == 32817U) || (unsigned int )pdev->device == 61441U) || (unsigned int )pdev->device == 32836U) {
#line 2682
    bars = pci_select_bars(pdev, 512UL);
#line 2683
    mem_only = 1;
#line 2684
    ql_dbg_pci(1073741824U, pdev, 7, "Mem only adapter.\n");
  } else {

  }
#line 2687
  ql_dbg_pci(1073741824U, pdev, 8, "Bars=%d.\n", bars);
#line 2690
  if (mem_only != 0) {
#line 2691
    tmp = pci_enable_device_mem(pdev);
#line 2691
    if (tmp != 0) {
#line 2692
      goto probe_out;
    } else {

    }
  } else {
#line 2694
    tmp___0 = pci_enable_device(pdev);
#line 2694
    if (tmp___0 != 0) {
#line 2695
      goto probe_out;
    } else {

    }
  }
#line 2699
  pci_enable_pcie_error_reporting(pdev);
#line 2701
  tmp___1 = kzalloc(12480UL, 208U);
#line 2701
  ha = (struct qla_hw_data *)tmp___1;
#line 2702
  if ((unsigned long )ha == (unsigned long )((struct qla_hw_data *)0)) {
#line 2703
    ql_log_pci(0U, pdev, 9, "Unable to allocate memory for ha.\n");
#line 2705
    goto probe_out;
  } else {

  }
#line 2707
  ql_dbg_pci(1073741824U, pdev, 10, "Memory allocated for ha=%p.\n", ha);
#line 2709
  ha->pdev = pdev;
#line 2710
  ha->tgt.enable_class_2 = (unsigned char )ql2xenableclass2;
#line 2713
  ha->bars = bars;
#line 2714
  ha->mem_only = mem_only;
#line 2715
  spinlock_check(& ha->hardware_lock);
#line 2715
  __raw_spin_lock_init(& ha->hardware_lock.ldv_6105.rlock, "&(&ha->hardware_lock)->rlock",
                       & __key);
#line 2716
  spinlock_check(& ha->vport_slock);
#line 2716
  __raw_spin_lock_init(& ha->vport_slock.ldv_6105.rlock, "&(&ha->vport_slock)->rlock",
                       & __key___0);
#line 2717
  __mutex_init(& ha->selflogin_lock, "&ha->selflogin_lock", & __key___1);
#line 2720
  qla2x00_set_isp_flags(ha);
#line 2723
  if (((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 2725
    pdev->needs_freset = 1U;
  } else {

  }
#line 2727
  ha->prev_topology = 0U;
#line 2728
  ha->init_cb_size = 96;
#line 2729
  ha->link_data_rate = 65535U;
#line 2730
  ha->optrom_size = 131072U;
#line 2731
  ha->cfg_lun_q_depth = ql2xmaxqdepth;
#line 2734
  if ((int )ha->device_type & 1) {
#line 2735
    ha->max_fibre_devices = 512U;
#line 2736
    ha->mbx_count = 8U;
#line 2737
    req_length = 128U;
#line 2738
    rsp_length = 64U;
#line 2739
    ha->max_loop_id = 254U;
#line 2740
    ha->gid_list_info_size = 4;
#line 2741
    ha->flash_conf_off = 4294967295U;
#line 2742
    ha->flash_data_off = 4294967295U;
#line 2743
    ha->nvram_conf_off = 4294967295U;
#line 2744
    ha->nvram_data_off = 4294967295U;
#line 2745
    ha->isp_ops = & qla2100_isp_ops;
  } else
#line 2746
  if ((ha->device_type & 2U) != 0U) {
#line 2747
    ha->max_fibre_devices = 512U;
#line 2748
    ha->mbx_count = 24U;
#line 2749
    req_length = 2048U;
#line 2750
    rsp_length = 64U;
#line 2751
    ha->max_loop_id = 254U;
#line 2752
    ha->gid_list_info_size = 4;
#line 2753
    ha->flash_conf_off = 4294967295U;
#line 2754
    ha->flash_data_off = 4294967295U;
#line 2755
    ha->nvram_conf_off = 4294967295U;
#line 2756
    ha->nvram_data_off = 4294967295U;
#line 2757
    ha->isp_ops = & qla2100_isp_ops;
  } else
#line 2758
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2759
    ha->max_fibre_devices = 512U;
#line 2760
    ha->mbx_count = 32U;
#line 2761
    req_length = 2048U;
#line 2762
    rsp_length = 512U;
#line 2763
    ha->max_loop_id = 2047U;
#line 2764
    ha->gid_list_info_size = 6;
#line 2765
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2766
      ha->optrom_size = 1048576U;
    } else {

    }
#line 2767
    ha->flash_conf_off = 4294967295U;
#line 2768
    ha->flash_data_off = 4294967295U;
#line 2769
    ha->nvram_conf_off = 4294967295U;
#line 2770
    ha->nvram_data_off = 4294967295U;
#line 2771
    ha->isp_ops = & qla2300_isp_ops;
  } else
#line 2772
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 2773
    ha->max_fibre_devices = 2048U;
#line 2774
    ha->mbx_count = 32U;
#line 2775
    req_length = 2048U;
#line 2776
    rsp_length = 512U;
#line 2777
    ha->tgt.atio_q_length = 4096U;
#line 2778
    ha->max_loop_id = 2047U;
#line 2779
    ha->init_cb_size = 5252;
#line 2780
    ha->gid_list_info_size = 8;
#line 2781
    ha->optrom_size = 1048576U;
#line 2782
    ha->nvram_npiv_size = 128U;
#line 2783
    ha->isp_ops = & qla24xx_isp_ops;
#line 2784
    ha->flash_conf_off = 2147287040U;
#line 2785
    ha->flash_data_off = 2146435072U;
#line 2786
    ha->nvram_conf_off = 2147418112U;
#line 2787
    ha->nvram_data_off = 2147352576U;
  } else
#line 2788
  if ((ha->device_type & 2048U) != 0U) {
#line 2789
    ha->max_fibre_devices = 2048U;
#line 2790
    ha->mbx_count = 32U;
#line 2791
    req_length = 2048U;
#line 2792
    rsp_length = 512U;
#line 2793
    ha->tgt.atio_q_length = 4096U;
#line 2794
    ha->max_loop_id = 2047U;
#line 2795
    ha->init_cb_size = 5252;
#line 2796
    ha->gid_list_info_size = 8;
#line 2797
    ha->optrom_size = 2097152U;
#line 2798
    ha->nvram_npiv_size = 256U;
#line 2799
    ha->isp_ops = & qla25xx_isp_ops;
#line 2800
    ha->flash_conf_off = 2147287040U;
#line 2801
    ha->flash_data_off = 2146435072U;
#line 2802
    ha->nvram_conf_off = 2147418112U;
#line 2803
    ha->nvram_data_off = 2147352576U;
  } else
#line 2804
  if ((ha->device_type & 8192U) != 0U) {
#line 2805
    ha->max_fibre_devices = 2048U;
#line 2806
    ha->mbx_count = 32U;
#line 2807
    req_length = 2048U;
#line 2808
    rsp_length = 512U;
#line 2809
    ha->tgt.atio_q_length = 4096U;
#line 2810
    ha->max_loop_id = 2047U;
#line 2811
    ha->init_cb_size = 5252;
#line 2812
    ha->gid_list_info_size = 8;
#line 2813
    ha->optrom_size = 4194304U;
#line 2814
    ha->nvram_npiv_size = 256U;
#line 2815
    ha->isp_ops = & qla81xx_isp_ops;
#line 2816
    ha->flash_conf_off = 2147287040U;
#line 2817
    ha->flash_data_off = 2139095040U;
#line 2818
    ha->nvram_conf_off = 4294967295U;
#line 2819
    ha->nvram_data_off = 4294967295U;
  } else
#line 2820
  if ((ha->device_type & 16384U) != 0U) {
#line 2821
    ha->max_fibre_devices = 2048U;
#line 2822
    ha->mbx_count = 32U;
#line 2823
    req_length = 128U;
#line 2824
    rsp_length = 128U;
#line 2825
    ha->max_loop_id = 2047U;
#line 2826
    ha->init_cb_size = 5252;
#line 2827
    ha->gid_list_info_size = 8;
#line 2828
    ha->optrom_size = 8388608U;
#line 2829
    ha->nvram_npiv_size = 256U;
#line 2830
    ha->isp_ops = & qla82xx_isp_ops;
#line 2831
    ha->flash_conf_off = 2147287040U;
#line 2832
    ha->flash_data_off = 2146435072U;
#line 2833
    ha->nvram_conf_off = 2147418112U;
#line 2834
    ha->nvram_data_off = 2147352576U;
  } else
#line 2835
  if ((ha->device_type & 262144U) != 0U) {
#line 2836
    ha->max_fibre_devices = 2048U;
#line 2837
    ha->mbx_count = 32U;
#line 2838
    req_length = 128U;
#line 2839
    rsp_length = 128U;
#line 2840
    ha->max_loop_id = 2047U;
#line 2841
    ha->init_cb_size = 5252;
#line 2842
    ha->gid_list_info_size = 8;
#line 2843
    ha->optrom_size = 16777216U;
#line 2844
    ha->nvram_npiv_size = 256U;
#line 2845
    ha->isp_ops = & qla8044_isp_ops;
#line 2846
    ha->flash_conf_off = 2147287040U;
#line 2847
    ha->flash_data_off = 2146435072U;
#line 2848
    ha->nvram_conf_off = 2147418112U;
#line 2849
    ha->nvram_data_off = 2147352576U;
  } else
#line 2850
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 2851
    ha->portnum = (unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U;
#line 2852
    ha->max_fibre_devices = 2048U;
#line 2853
    ha->mbx_count = 32U;
#line 2854
    req_length = 2048U;
#line 2855
    rsp_length = 512U;
#line 2856
    ha->tgt.atio_q_length = 4096U;
#line 2857
    ha->max_loop_id = 2047U;
#line 2858
    ha->init_cb_size = 5252;
#line 2859
    ha->gid_list_info_size = 8;
#line 2860
    ha->optrom_size = 16777216U;
#line 2861
    ha->nvram_npiv_size = 256U;
#line 2862
    ha->isp_ops = & qla83xx_isp_ops;
#line 2863
    ha->flash_conf_off = 2147287040U;
#line 2864
    ha->flash_data_off = 2139095040U;
#line 2865
    ha->nvram_conf_off = 4294967295U;
#line 2866
    ha->nvram_data_off = 4294967295U;
  } else
#line 2867
  if ((ha->device_type & 131072U) != 0U) {
#line 2868
    ha->max_fibre_devices = 512U;
#line 2869
    ha->mbx_count = 16U;
#line 2870
    ha->aen_mbx_count = 8U;
#line 2871
    req_length = 512U;
#line 2872
    rsp_length = 256U;
#line 2873
    ha->init_cb_size = 128;
#line 2874
    ha->isp_ops = & qlafx00_isp_ops;
#line 2875
    ha->port_down_retry_count = 30;
#line 2876
    ha->mr.fw_hbt_cnt = 6U;
#line 2877
    ha->mr.fw_reset_timer_tick = 120U;
#line 2878
    ha->mr.fw_critemp_timer_tick = 60U;
#line 2879
    ha->mr.fw_hbt_en = 1U;
  } else {

  }
#line 2882
  ql_dbg_pci(1073741824U, pdev, 30, "mbx_count=%d, req_length=%d, rsp_length=%d, max_loop_id=%d, init_cb_size=%d, gid_list_info_size=%d, optrom_size=%d, nvram_npiv_size=%d, max_fibre_devices=%d.\n",
             (int )ha->mbx_count, (int )req_length, (int )rsp_length, (int )ha->max_loop_id,
             ha->init_cb_size, ha->gid_list_info_size, ha->optrom_size, (int )ha->nvram_npiv_size,
             (int )ha->max_fibre_devices);
#line 2890
  ql_dbg_pci(1073741824U, pdev, 31, "isp_ops=%p, flash_conf_off=%d, flash_data_off=%d, nvram_conf_off=%d, nvram_data_off=%d.\n",
             ha->isp_ops, ha->flash_conf_off, ha->flash_data_off, ha->nvram_conf_off,
             ha->nvram_data_off);
#line 2897
  ret = (*((ha->isp_ops)->iospace_config))(ha);
#line 2898
  if (ret != 0) {
#line 2899
    goto iospace_config_failed;
  } else {

  }
#line 2901
  ql_log_pci(2U, pdev, 29, "Found an ISP%04X irq %d iobase 0x%p.\n", (int )pdev->device,
             pdev->irq, ha->iobase);
#line 2904
  __mutex_init(& ha->vport_lock, "&ha->vport_lock", & __key___2);
#line 2905
  init_completion(& ha->mbx_cmd_comp);
#line 2906
  complete(& ha->mbx_cmd_comp);
#line 2907
  init_completion(& ha->mbx_intr_comp);
#line 2908
  init_completion(& ha->dcbx_comp);
#line 2909
  init_completion(& ha->lb_portup_comp);
#line 2911
  set_bit(0L, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 2913
  qla2x00_config_dma_addressing(ha);
#line 2914
  ql_dbg_pci(1073741824U, pdev, 32, "64 Bit addressing is %s.\n", *((unsigned long *)ha + 2UL) != 0UL ? (char *)"enable" : (char *)"disable");
#line 2918
  ret = qla2x00_mem_alloc(ha, (int )req_length, (int )rsp_length, & req, & rsp);
#line 2919
  if (ret == 0) {
#line 2920
    ql_log_pci(0U, pdev, 49, "Failed to allocate memory for adapter, aborting.\n");
#line 2923
    goto probe_hw_failed;
  } else {

  }
#line 2926
  req->max_q_depth = 32;
#line 2927
  if (ql2xmaxqdepth != 0 && (unsigned int )ql2xmaxqdepth <= 65535U) {
#line 2928
    req->max_q_depth = ql2xmaxqdepth;
  } else {

  }
#line 2931
  tmp___2 = qla2x00_create_host(sht, ha);
#line 2931
  base_vha = tmp___2;
#line 2932
  if ((unsigned long )base_vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 2933
    ret = -12;
#line 2934
    qla2x00_mem_free(ha);
#line 2935
    qla2x00_free_req_que(ha, req);
#line 2936
    qla2x00_free_rsp_que(ha, rsp);
#line 2937
    goto probe_hw_failed;
  } else {

  }
#line 2940
  pci_set_drvdata(pdev, (void *)base_vha);
#line 2942
  host = base_vha->host;
#line 2943
  base_vha->req = req;
#line 2944
  if ((ha->device_type & 131072U) != 0U) {
#line 2945
    host->can_queue = 1024;
  } else {
#line 2947
    host->can_queue = (int )req->length + 128;
  }
#line 2948
  if ((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) {
#line 2949
    base_vha->mgmt_svr_loop_id = (unsigned int )base_vha->vp_idx + 10U;
  } else {
#line 2951
    base_vha->mgmt_svr_loop_id = (unsigned int )base_vha->vp_idx + 254U;
  }
#line 2955
  ha->mr.fcport.vha = base_vha;
#line 2956
  ha->mr.fcport.port_type = 0;
#line 2957
  ha->mr.fcport.loop_id = 4096U;
#line 2958
  qla2x00_set_fcport_state(& ha->mr.fcport, 1);
#line 2959
  ha->mr.fcport.supported_classes = 0U;
#line 2960
  ha->mr.fcport.scan_state = 1U;
#line 2963
  if ((ha->device_type & 134217728U) == 0U) {
#line 2964
    if ((int )ha->device_type & 1) {
#line 2965
      host->sg_tablesize = 32U;
    } else {

    }
  } else
#line 2967
  if ((ha->device_type & 16384U) == 0U) {
#line 2968
    host->sg_tablesize = 1024U;
  } else {

  }
#line 2970
  ql_dbg(1073741824U, base_vha, 50, "can_queue=%d, req=%p, mgmt_svr_loop_id=%d, sg_tablesize=%d.\n",
         host->can_queue, base_vha->req, (int )base_vha->mgmt_svr_loop_id, (int )host->sg_tablesize);
#line 2975
  host->max_id = (unsigned int )ha->max_fibre_devices;
#line 2976
  host->cmd_per_lun = 3;
#line 2977
  host->unique_id = host->host_no;
#line 2978
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 2979
    host->max_cmd_len = 32U;
  } else {
#line 2981
    host->max_cmd_len = 16U;
  }
#line 2982
  host->max_channel = 0U;
#line 2983
  host->max_lun = ql2xmaxlun;
#line 2984
  host->transportt = qla2xxx_transport_template;
#line 2985
  sht->vendor_id = 72057594037932151ULL;
#line 2987
  ql_dbg(1073741824U, base_vha, 51, "max_id=%d this_id=%d cmd_per_len=%d unique_id=%d max_cmd_len=%d max_channel=%d max_lun=%d transportt=%p, vendor_id=%llu.\n",
         host->max_id, host->this_id, (int )host->cmd_per_lun, host->unique_id, (int )host->max_cmd_len,
         host->max_channel, host->max_lun, host->transportt, sht->vendor_id);
  que_init: 
#line 2997
  tmp___3 = qla2x00_alloc_queues(ha, req, rsp);
#line 2997
  if (tmp___3 == 0) {
#line 2998
    ql_log(0U, base_vha, 61, "Failed to allocate memory for queue pointers...aborting.\n");
#line 3001
    goto probe_init_failed;
  } else {

  }
#line 3004
  qlt_probe_one_stage1(base_vha, ha);
#line 3007
  ret = qla2x00_request_irqs(ha, rsp);
#line 3008
  if (ret != 0) {
#line 3009
    goto probe_init_failed;
  } else {

  }
#line 3011
  pci_save_state(pdev);
#line 3014
  rsp->req = req;
#line 3015
  req->rsp = rsp;
#line 3017
  if ((ha->device_type & 131072U) != 0U) {
#line 3018
    *(ha->rsp_q_map) = rsp;
#line 3019
    *(ha->req_q_map) = req;
#line 3020
    set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 3021
    set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
  } else {

  }
#line 3025
  req->req_q_in = & (ha->iobase)->isp24.req_q_in;
#line 3026
  req->req_q_out = & (ha->iobase)->isp24.req_q_out;
#line 3027
  rsp->rsp_q_in = & (ha->iobase)->isp24.rsp_q_in;
#line 3028
  rsp->rsp_q_out = & (ha->iobase)->isp24.rsp_q_out;
#line 3029
  if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 3030
    req->req_q_in = & (ha->mqiobase)->isp25mq.req_q_in;
#line 3031
    req->req_q_out = & (ha->mqiobase)->isp25mq.req_q_out;
#line 3032
    rsp->rsp_q_in = & (ha->mqiobase)->isp25mq.rsp_q_in;
#line 3033
    rsp->rsp_q_out = & (ha->mqiobase)->isp25mq.rsp_q_out;
  } else {

  }
#line 3036
  if ((ha->device_type & 131072U) != 0U) {
#line 3037
    req->req_q_in = & (ha->iobase)->ispfx00.req_q_in;
#line 3038
    req->req_q_out = & (ha->iobase)->ispfx00.req_q_out;
#line 3039
    rsp->rsp_q_in = & (ha->iobase)->ispfx00.rsp_q_in;
#line 3040
    rsp->rsp_q_out = & (ha->iobase)->ispfx00.rsp_q_out;
  } else {

  }
#line 3043
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3044
    req->req_q_out = (uint32_t *)(& (ha->iobase)->isp82.req_q_out);
#line 3045
    rsp->rsp_q_in = (uint32_t *)(& (ha->iobase)->isp82.rsp_q_in);
#line 3046
    rsp->rsp_q_out = (uint32_t *)(& (ha->iobase)->isp82.rsp_q_out);
  } else {

  }
#line 3049
  ql_dbg(1048576U, base_vha, 49161, "rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\n",
         ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);
#line 3052
  ql_dbg(1048576U, base_vha, 49162, "req->req_q_in=%p req->req_q_out=%p rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\n",
         req->req_q_in, req->req_q_out, rsp->rsp_q_in, rsp->rsp_q_out);
#line 3057
  ql_dbg(1073741824U, base_vha, 62, "rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\n",
         ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);
#line 3060
  ql_dbg(1073741824U, base_vha, 63, "req->req_q_in=%p req->req_q_out=%p rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\n",
         req->req_q_in, req->req_q_out, rsp->rsp_q_in, rsp->rsp_q_out);
#line 3064
  tmp___4 = (*((ha->isp_ops)->initialize_adapter))(base_vha);
#line 3064
  if (tmp___4 != 0) {
#line 3065
    ql_log(0U, base_vha, 214, "Failed to initialize adapter - Adapter flags %x.\n",
           base_vha->device_flags);
#line 3069
    if ((ha->device_type & 16384U) != 0U) {
#line 3070
      qla82xx_idc_lock(ha);
#line 3071
      qla82xx_wr_32(ha, 136323392UL, 6U);
#line 3073
      qla82xx_idc_unlock(ha);
#line 3074
      ql_log(0U, base_vha, 215, "HW State: FAILED.\n");
    } else
#line 3076
    if ((ha->device_type & 262144U) != 0U) {
#line 3077
      qla8044_idc_lock(ha);
#line 3078
      qla8044_wr_direct(base_vha, 4U, 6U);
#line 3081
      qla8044_idc_unlock(ha);
#line 3082
      ql_log(0U, base_vha, 336, "HW State: FAILED.\n");
    } else {

    }
#line 3086
    ret = -19;
#line 3087
    goto probe_failed;
  } else {

  }
#line 3090
  if ((unsigned int )ha->mqenable != 0U) {
#line 3091
    tmp___5 = qla25xx_setup_mode(base_vha);
#line 3091
    if (tmp___5 != 0) {
#line 3092
      ql_log(1U, base_vha, 236, "Failed to create queues, falling back to single queue mode.\n");
#line 3094
      goto que_init;
    } else {

    }
  } else {

  }
#line 3098
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3099
    goto skip_dpc;
  } else {

  }
#line 3104
  ha->dpc_thread = kthread_create_on_node(& qla2x00_do_dpc, (void *)ha, -1, "%s_dpc",
                                          (uint8_t *)(& base_vha->host_str));
#line 3106
  tmp___7 = IS_ERR((void const   *)ha->dpc_thread);
#line 3106
  if (tmp___7 != 0L) {
#line 3107
    ql_log(0U, base_vha, 237, "Failed to start DPC thread.\n");
#line 3109
    tmp___6 = PTR_ERR((void const   *)ha->dpc_thread);
#line 3109
    ret = (int )tmp___6;
#line 3110
    goto probe_failed;
  } else {

  }
#line 3112
  ql_dbg(1073741824U, base_vha, 238, "DPC thread started successfully.\n");
#line 3121
  qla2xxx_wake_dpc(base_vha);
#line 3123
  if ((ha->device_type & 65536U) != 0U || ((ha->device_type & 32768U) != 0U && (int )ha->fw_attributes_ext[0] & 1)) {
#line 3124
    sprintf((char *)(& wq_name), "qla2xxx_%lu_dpc_lp_wq", base_vha->host_no);
#line 3125
    __lock_name = "%s";
#line 3125
    tmp___8 = __alloc_workqueue_key("%s", 10U, 1, & __key___3, __lock_name, (char *)(& wq_name));
#line 3125
    ha->dpc_lp_wq = tmp___8;
#line 3126
    __init_work(& ha->idc_aen, 0);
#line 3126
    __constr_expr_0.counter = 137438953408L;
#line 3126
    ha->idc_aen.data = __constr_expr_0;
#line 3126
    lockdep_init_map(& ha->idc_aen.lockdep_map, "(&ha->idc_aen)", & __key___4, 0);
#line 3126
    INIT_LIST_HEAD(& ha->idc_aen.entry);
#line 3126
    ha->idc_aen.func = & qla83xx_service_idc_aen;
#line 3128
    sprintf((char *)(& wq_name), "qla2xxx_%lu_dpc_hp_wq", base_vha->host_no);
#line 3129
    __lock_name___0 = "%s";
#line 3129
    tmp___9 = __alloc_workqueue_key("%s", 10U, 1, & __key___5, __lock_name___0, (char *)(& wq_name));
#line 3129
    ha->dpc_hp_wq = tmp___9;
#line 3130
    __init_work(& ha->nic_core_reset, 0);
#line 3130
    __constr_expr_1.counter = 137438953408L;
#line 3130
    ha->nic_core_reset.data = __constr_expr_1;
#line 3130
    lockdep_init_map(& ha->nic_core_reset.lockdep_map, "(&ha->nic_core_reset)", & __key___6,
                     0);
#line 3130
    INIT_LIST_HEAD(& ha->nic_core_reset.entry);
#line 3130
    ha->nic_core_reset.func = & qla83xx_nic_core_reset_work;
#line 3131
    __init_work(& ha->idc_state_handler, 0);
#line 3131
    __constr_expr_2.counter = 137438953408L;
#line 3131
    ha->idc_state_handler.data = __constr_expr_2;
#line 3131
    lockdep_init_map(& ha->idc_state_handler.lockdep_map, "(&ha->idc_state_handler)",
                     & __key___7, 0);
#line 3131
    INIT_LIST_HEAD(& ha->idc_state_handler.entry);
#line 3131
    ha->idc_state_handler.func = & qla83xx_idc_state_handler_work;
#line 3133
    __init_work(& ha->nic_core_unrecoverable, 0);
#line 3133
    __constr_expr_3.counter = 137438953408L;
#line 3133
    ha->nic_core_unrecoverable.data = __constr_expr_3;
#line 3133
    lockdep_init_map(& ha->nic_core_unrecoverable.lockdep_map, "(&ha->nic_core_unrecoverable)",
                     & __key___8, 0);
#line 3133
    INIT_LIST_HEAD(& ha->nic_core_unrecoverable.entry);
#line 3133
    ha->nic_core_unrecoverable.func = & qla83xx_nic_core_unrecoverable_work;
  } else {

  }
  skip_dpc: 
#line 3138
  list_add_tail(& base_vha->list, & ha->vp_list);
#line 3139
  (base_vha->host)->irq = (ha->pdev)->irq;
#line 3142
  qla2x00_start_timer(base_vha, (void *)(& qla2x00_timer), 1UL);
#line 3143
  ql_dbg(1073741824U, base_vha, 239, "Started qla2x00_timer with interval=%d.\n",
         1);
#line 3146
  ql_dbg(1073741824U, base_vha, 240, "Detected hba at address=%p.\n", ha);
#line 3150
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 3151
    if (((int )ha->fw_attributes & 16) != 0) {
#line 3152
      prot = 0;
#line 3153
      base_vha->flags.difdix_supported = 1U;
#line 3154
      ql_dbg(1073741824U, base_vha, 241, "Registering for DIF/DIX type 1 and 3 protection.\n");
#line 3156
      if (ql2xenabledif == 1) {
#line 3157
        prot = 8;
      } else {

      }
#line 3158
      scsi_host_set_prot(host, (unsigned int )(prot | 119));
#line 3166
      guard = 1;
#line 3168
      if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && ql2xenabledif > 1) {
#line 3170
        guard = guard | 2;
      } else {

      }
#line 3172
      scsi_host_set_guard(host, (int )((unsigned char )guard));
    } else {
#line 3174
      base_vha->flags.difdix_supported = 0U;
    }
  } else {

  }
#line 3177
  (*((ha->isp_ops)->enable_intrs))(ha);
#line 3179
  if ((ha->device_type & 131072U) != 0U) {
#line 3180
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 1);
#line 3182
    host->sg_tablesize = (int )ha->mr.extended_io_enabled ? 1024U : 128U;
  } else {

  }
#line 3186
  ret = scsi_add_host(host, & pdev->dev);
#line 3187
  if (ret != 0) {
#line 3188
    goto probe_failed;
  } else {

  }
#line 3190
  base_vha->flags.init_done = 1U;
#line 3191
  base_vha->flags.online = 1U;
#line 3193
  ql_dbg(1073741824U, base_vha, 242, "Init done and hba is online.\n");
#line 3196
  tmp___10 = qla_ini_mode_enabled(base_vha);
#line 3196
  if ((int )tmp___10) {
#line 3197
    scsi_scan_host(host);
  } else {
#line 3199
    ql_dbg(1073741824U, base_vha, 290, "skipping scsi_scan_host() for non-initiator port\n");
  }
#line 3202
  qla2x00_alloc_sysfs_attr(base_vha);
#line 3204
  if ((ha->device_type & 131072U) != 0U) {
#line 3205
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 2);
#line 3209
    ret = qlafx00_fx_disc(base_vha, & (base_vha->hw)->mr.fcport, 153);
  } else {

  }
#line 3213
  qla2x00_init_host_attr(base_vha);
#line 3215
  qla2x00_dfs_setup(base_vha);
#line 3217
  ql_log(2U, base_vha, 251, "QLogic %s - %s.\n", (uint8_t *)(& ha->model_number),
         (char *)(& ha->model_desc));
#line 3219
  tmp___11 = (*((ha->isp_ops)->fw_version_str))(base_vha, (char *)(& fw_str));
#line 3219
  tmp___12 = pci_name((struct pci_dev  const  *)pdev);
#line 3219
  tmp___13 = (*((ha->isp_ops)->pci_info_str))(base_vha, (char *)(& pci_info));
#line 3219
  ql_log(2U, base_vha, 252, "ISP%04X: %s @ %s hdma%c host#=%ld fw=%s.\n", (int )pdev->device,
         tmp___13, tmp___12, *((unsigned long *)ha + 2UL) != 0UL ? 43 : 45, base_vha->host_no,
         tmp___11);
#line 3226
  qlt_add_target(ha, base_vha);
#line 3228
  return (0);
  probe_init_failed: 
#line 3231
  qla2x00_free_req_que(ha, req);
#line 3232
  *(ha->req_q_map) = (struct req_que *)0;
#line 3233
  clear_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 3234
  qla2x00_free_rsp_que(ha, rsp);
#line 3235
  *(ha->rsp_q_map) = (struct rsp_que *)0;
#line 3236
  clear_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 3237
  tmp___14 = 0U;
#line 3237
  ha->max_rsp_queues = tmp___14;
#line 3237
  ha->max_req_queues = tmp___14;
  probe_failed: ;
#line 3240
  if (base_vha->timer_active != 0U) {
#line 3241
    qla2x00_stop_timer(base_vha);
  } else {

  }
#line 3242
  base_vha->flags.online = 0U;
#line 3243
  if ((unsigned long )ha->dpc_thread != (unsigned long )((struct task_struct *)0)) {
#line 3244
    t = ha->dpc_thread;
#line 3246
    ha->dpc_thread = (struct task_struct *)0;
#line 3247
    kthread_stop(t);
  } else {

  }
#line 3250
  qla2x00_free_device(base_vha);
#line 3252
  scsi_host_put(base_vha->host);
  probe_hw_failed: ;
#line 3255
  if ((ha->device_type & 16384U) != 0U) {
#line 3256
    qla82xx_idc_lock(ha);
#line 3257
    qla82xx_clear_drv_active(ha);
#line 3258
    qla82xx_idc_unlock(ha);
  } else {

  }
#line 3260
  if ((ha->device_type & 262144U) != 0U) {
#line 3261
    qla8044_idc_lock(ha);
#line 3262
    qla8044_clear_drv_active(base_vha);
#line 3263
    qla8044_idc_unlock(ha);
  } else {

  }
  iospace_config_failed: ;
#line 3266
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3267
    if (ha->nx_pcibase == 0UL) {
#line 3268
      iounmap((void volatile   *)ha->nx_pcibase);
    } else {

    }
#line 3269
    if (ql2xdbwr == 0) {
#line 3270
      iounmap((void volatile   *)ha->nxdb_wr_ptr);
    } else {

    }
  } else {
#line 3272
    if ((unsigned long )ha->iobase != (unsigned long )((device_reg_t *)0)) {
#line 3273
      iounmap((void volatile   *)ha->iobase);
    } else {

    }
#line 3274
    if ((unsigned long )ha->cregbase != (unsigned long )((void *)0)) {
#line 3275
      iounmap((void volatile   *)ha->cregbase);
    } else {

    }
  }
#line 3277
  pci_release_selected_regions(ha->pdev, ha->bars);
#line 3278
  kfree((void const   *)ha);
#line 3279
  ha = (struct qla_hw_data *)0;
  probe_out: 
#line 3282
  pci_disable_device(pdev);
#line 3283
  return (ret);
}
}
#line 3287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_stop_dpc_thread(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct task_struct *t ;

  {
#line 3289
  ha = vha->hw;
#line 3290
  t = ha->dpc_thread;
#line 3292
  if ((unsigned long )ha->dpc_thread == (unsigned long )((struct task_struct *)0)) {
#line 3293
    return;
  } else {

  }
#line 3298
  ha->dpc_thread = (struct task_struct *)0;
#line 3299
  kthread_stop(t);
#line 3300
  return;
}
}
#line 3303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_shutdown(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;

  {
#line 3308
  tmp = atomic_read((atomic_t const   *)(& pdev->enable_cnt));
#line 3308
  if (tmp == 0) {
#line 3309
    return;
  } else {

  }
#line 3311
  tmp___0 = pci_get_drvdata(pdev);
#line 3311
  vha = (scsi_qla_host_t *)tmp___0;
#line 3312
  ha = vha->hw;
#line 3315
  if ((ha->device_type & 131072U) != 0U) {
#line 3316
    qlafx00_driver_shutdown(vha, 20);
  } else {

  }
#line 3319
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3320
    qla2x00_disable_fce_trace(vha, (uint64_t *)0ULL, (uint64_t *)0ULL);
#line 3321
    ha->flags.fce_enabled = 0U;
  } else {

  }
#line 3325
  if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 3326
    qla2x00_disable_eft_trace(vha);
  } else {

  }
#line 3329
  qla2x00_try_to_stop_firmware(vha);
#line 3332
  vha->flags.online = 0U;
#line 3335
  if ((unsigned int )ha->interrupts_on != 0U) {
#line 3336
    vha->flags.init_done = 0U;
#line 3337
    (*((ha->isp_ops)->disable_intrs))(ha);
  } else {

  }
#line 3340
  qla2x00_free_irqs(vha);
#line 3342
  qla2x00_free_fw_dump(ha);
#line 3343
  return;
}
}
#line 3346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_remove_one(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *base_vha ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  int tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  long tmp___2 ;
  struct list_head  const  *__mptr ;
  int tmp___3 ;
  struct task_struct *t ;

  {
#line 3356
  tmp = atomic_read((atomic_t const   *)(& pdev->enable_cnt));
#line 3356
  if (tmp == 0) {
#line 3357
    return;
  } else {

  }
#line 3359
  tmp___0 = pci_get_drvdata(pdev);
#line 3359
  base_vha = (scsi_qla_host_t *)tmp___0;
#line 3360
  ha = base_vha->hw;
#line 3362
  ha->flags.host_shutting_down = 1U;
#line 3364
  set_bit(15L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 3365
  if ((ha->device_type & 131072U) != 0U) {
#line 3366
    qlafx00_driver_shutdown(base_vha, 20);
  } else {

  }
#line 3368
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 3369
  goto ldv_61980;
  ldv_61979: 
#line 3370
  tmp___1 = spinlock_check(& ha->vport_slock);
#line 3370
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 3372
  tmp___2 = ldv__builtin_expect((unsigned long )base_vha->list.next == (unsigned long )(& ha->vp_list),
                             0L);
#line 3372
  if (tmp___2 != 0L) {
#line 3372
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"),
                         "i" (3372), "i" (12UL));
    ldv_61976: ;
#line 3372
    goto ldv_61976;
  } else {

  }
#line 3374
  __mptr = (struct list_head  const  *)base_vha->list.next;
#line 3374
  vha = (scsi_qla_host_t *)__mptr;
#line 3375
  scsi_host_get(vha->host);
#line 3377
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 3378
  mutex_unlock(& ha->vport_lock);
#line 3380
  fc_vport_terminate(vha->fc_vport);
#line 3381
  scsi_host_put(vha->host);
#line 3383
  mutex_lock_nested(& ha->vport_lock, 0U);
  ldv_61980: ;
#line 3369
  if (ha->cur_vport_count != 0) {
#line 3371
    goto ldv_61979;
  } else {

  }
#line 3385
  mutex_unlock(& ha->vport_lock);
#line 3387
  if ((ha->device_type & 65536U) != 0U) {
#line 3388
    ql_dbg(524288U, base_vha, 45182, "Clearing fcoe driver presence.\n");
#line 3390
    tmp___3 = qla83xx_clear_drv_presence(base_vha);
#line 3390
    if (tmp___3 != 0) {
#line 3391
      ql_dbg(524288U, base_vha, 45177, "Error while clearing DRV-Presence.\n");
    } else {

    }
  } else {

  }
#line 3395
  qla2x00_abort_all_cmds(base_vha, 65536);
#line 3397
  qla2x00_dfs_remove(base_vha);
#line 3399
  qla84xx_put_chip(base_vha);
#line 3402
  if (base_vha->timer_active != 0U) {
#line 3403
    qla2x00_stop_timer(base_vha);
  } else {

  }
#line 3405
  base_vha->flags.online = 0U;
#line 3408
  if ((unsigned long )ha->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3409
    flush_workqueue(ha->wq);
#line 3410
    destroy_workqueue(ha->wq);
#line 3411
    ha->wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3415
  if ((unsigned long )ha->dpc_lp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3416
    cancel_work_sync(& ha->idc_aen);
#line 3417
    destroy_workqueue(ha->dpc_lp_wq);
#line 3418
    ha->dpc_lp_wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3421
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 3422
    cancel_work_sync(& ha->nic_core_reset);
#line 3423
    cancel_work_sync(& ha->idc_state_handler);
#line 3424
    cancel_work_sync(& ha->nic_core_unrecoverable);
#line 3425
    destroy_workqueue(ha->dpc_hp_wq);
#line 3426
    ha->dpc_hp_wq = (struct workqueue_struct *)0;
  } else {

  }
#line 3430
  if ((unsigned long )ha->dpc_thread != (unsigned long )((struct task_struct *)0)) {
#line 3431
    t = ha->dpc_thread;
#line 3437
    ha->dpc_thread = (struct task_struct *)0;
#line 3438
    kthread_stop(t);
  } else {

  }
#line 3440
  qlt_remove_target(ha, base_vha);
#line 3442
  qla2x00_free_sysfs_attr(base_vha);
#line 3444
  fc_remove_host(base_vha->host);
#line 3446
  ldv_scsi_remove_host_5(base_vha->host);
#line 3448
  qla2x00_free_device(base_vha);
#line 3450
  scsi_host_put(base_vha->host);
#line 3452
  if ((ha->device_type & 262144U) != 0U) {
#line 3453
    qla8044_idc_lock(ha);
#line 3454
    qla8044_clear_drv_active(base_vha);
#line 3455
    qla8044_idc_unlock(ha);
  } else {

  }
#line 3457
  if ((ha->device_type & 16384U) != 0U) {
#line 3458
    qla82xx_idc_lock(ha);
#line 3459
    qla82xx_clear_drv_active(ha);
#line 3460
    qla82xx_idc_unlock(ha);
#line 3462
    iounmap((void volatile   *)ha->nx_pcibase);
#line 3463
    if (ql2xdbwr == 0) {
#line 3464
      iounmap((void volatile   *)ha->nxdb_wr_ptr);
    } else {

    }
  } else {
#line 3466
    if ((unsigned long )ha->iobase != (unsigned long )((device_reg_t *)0)) {
#line 3467
      iounmap((void volatile   *)ha->iobase);
    } else {

    }
#line 3469
    if ((unsigned long )ha->cregbase != (unsigned long )((void *)0)) {
#line 3470
      iounmap((void volatile   *)ha->cregbase);
    } else {

    }
#line 3472
    if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) {
#line 3473
      iounmap((void volatile   *)ha->mqiobase);
    } else {

    }
#line 3475
    if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && (unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0)) {
#line 3476
      iounmap((void volatile   *)ha->msixbase);
    } else {

    }
  }
#line 3479
  pci_release_selected_regions(ha->pdev, ha->bars);
#line 3480
  kfree((void const   *)ha);
#line 3481
  ha = (struct qla_hw_data *)0;
#line 3483
  pci_disable_pcie_error_reporting(pdev);
#line 3485
  pci_disable_device(pdev);
#line 3486
  pci_set_drvdata(pdev, (void *)0);
#line 3487
  return;
}
}
#line 3490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_free_device(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 3492
  ha = vha->hw;
#line 3494
  qla2x00_abort_all_cmds(vha, 65536);
#line 3497
  if (vha->timer_active != 0U) {
#line 3498
    qla2x00_stop_timer(vha);
  } else {

  }
#line 3500
  qla2x00_stop_dpc_thread(vha);
#line 3502
  qla25xx_delete_queues(vha);
#line 3503
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3504
    qla2x00_disable_fce_trace(vha, (uint64_t *)0ULL, (uint64_t *)0ULL);
  } else {

  }
#line 3506
  if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 3507
    qla2x00_disable_eft_trace(vha);
  } else {

  }
#line 3510
  qla2x00_try_to_stop_firmware(vha);
#line 3512
  vha->flags.online = 0U;
#line 3515
  if ((unsigned int )ha->interrupts_on != 0U) {
#line 3516
    vha->flags.init_done = 0U;
#line 3517
    (*((ha->isp_ops)->disable_intrs))(ha);
  } else {

  }
#line 3520
  qla2x00_free_irqs(vha);
#line 3522
  qla2x00_free_fcports(vha);
#line 3524
  qla2x00_mem_free(ha);
#line 3526
  qla82xx_md_free(vha);
#line 3528
  qla2x00_free_queues(ha);
#line 3529
  return;
}
}
#line 3531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_free_fcports(struct scsi_qla_host *vha ) 
{ 
  fc_port_t *fcport ;
  fc_port_t *tfcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 3535
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3535
  fcport = (fc_port_t *)__mptr;
#line 3535
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3535
  tfcport = (fc_port_t *)__mptr___0;
#line 3535
  goto ldv_61999;
  ldv_61998: 
#line 3536
  list_del(& fcport->list);
#line 3537
  qla2x00_clear_loop_id(fcport);
#line 3538
  kfree((void const   *)fcport);
#line 3539
  fcport = (fc_port_t *)0;
#line 3535
  fcport = tfcport;
#line 3535
  __mptr___1 = (struct list_head  const  *)tfcport->list.next;
#line 3535
  tfcport = (fc_port_t *)__mptr___1;
  ldv_61999: ;
#line 3535
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3537
    goto ldv_61998;
  } else {

  }

#line 3542
  return;
}
}
#line 3544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void qla2x00_schedule_rport_del(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                                int defer ) 
{ 
  struct fc_rport *rport ;
  scsi_qla_host_t *base_vha ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3551
  if ((unsigned long )fcport->rport == (unsigned long )((struct fc_rport *)0)) {
#line 3552
    return;
  } else {

  }
#line 3554
  rport = fcport->rport;
#line 3555
  if (defer != 0) {
#line 3556
    tmp = pci_get_drvdata((vha->hw)->pdev);
#line 3556
    base_vha = (scsi_qla_host_t *)tmp;
#line 3557
    tmp___0 = spinlock_check((vha->host)->host_lock);
#line 3557
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 3558
    fcport->drport = rport;
#line 3559
    spin_unlock_irqrestore((vha->host)->host_lock, flags);
#line 3560
    set_bit(13L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 3561
    qla2xxx_wake_dpc(base_vha);
  } else {
#line 3563
    fc_remote_port_delete(rport);
#line 3564
    qlt_fc_port_deleted(vha, fcport);
  }
#line 3566
  return;
}
}
#line 3577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_mark_device_lost(scsi_qla_host_t *vha , fc_port_t *fcport , int do_login ,
                              int defer ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3580
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 3581
    qla2x00_set_fcport_state(fcport, 3);
#line 3582
    qla2x00_schedule_rport_del(vha, fcport, defer);
#line 3583
    return;
  } else {

  }
#line 3586
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3586
  if (tmp == 4 && (int )vha->vp_idx == (int )(fcport->vha)->vp_idx) {
#line 3588
    qla2x00_set_fcport_state(fcport, 3);
#line 3589
    qla2x00_schedule_rport_del(vha, fcport, defer);
  } else {

  }
#line 3595
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3595
  if (tmp___0 != 2) {
#line 3596
    qla2x00_set_fcport_state(fcport, 3);
  } else {

  }
#line 3598
  if (do_login == 0) {
#line 3599
    return;
  } else {

  }
#line 3601
  if (fcport->login_retry == 0) {
#line 3602
    fcport->login_retry = (int )(vha->hw)->login_retry_count;
#line 3603
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3605
    ql_dbg(268435456U, vha, 8295, "Port login retry %8phN, id = 0x%04x retry cnt=%d.\n",
           (uint8_t *)(& fcport->port_name), (int )fcport->loop_id, fcport->login_retry);
  } else {

  }
#line 3609
  return;
}
}
#line 3625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_mark_all_devices_lost(scsi_qla_host_t *vha , int defer ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3629
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3629
  fcport = (fc_port_t *)__mptr;
#line 3629
  goto ldv_62029;
  ldv_62028: ;
#line 3630
  if ((unsigned int )vha->vp_idx != 0U && (int )vha->vp_idx != (int )(fcport->vha)->vp_idx) {
#line 3631
    goto ldv_62027;
  } else {

  }
#line 3637
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3637
  if (tmp == 2) {
#line 3638
    goto ldv_62027;
  } else {

  }
#line 3639
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3639
  if (tmp___0 == 4) {
#line 3640
    qla2x00_set_fcport_state(fcport, 3);
#line 3641
    if (defer != 0) {
#line 3642
      qla2x00_schedule_rport_del(vha, fcport, defer);
    } else
#line 3643
    if ((int )vha->vp_idx == (int )(fcport->vha)->vp_idx) {
#line 3644
      qla2x00_schedule_rport_del(vha, fcport, defer);
    } else {

    }
  } else {

  }
  ldv_62027: 
#line 3629
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3629
  fcport = (fc_port_t *)__mptr___0;
  ldv_62029: ;
#line 3629
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3631
    goto ldv_62028;
  } else {

  }

#line 3636
  return;
}
}
#line 3658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_mem_alloc(struct qla_hw_data *ha , uint16_t req_len , uint16_t rsp_len ,
                             struct req_que **req , struct rsp_que **rsp ) 
{ 
  char name[16U] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
#line 3663
  tmp = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, & ha->init_cb_dma,
                        208U, (struct dma_attrs *)0);
#line 3663
  ha->init_cb = (init_cb_t *)tmp;
#line 3665
  if ((unsigned long )ha->init_cb == (unsigned long )((init_cb_t *)0)) {
#line 3666
    goto fail;
  } else {

  }
#line 3668
  tmp___0 = qlt_mem_alloc(ha);
#line 3668
  if (tmp___0 < 0) {
#line 3669
    goto fail_free_init_cb;
  } else {

  }
#line 3671
  tmp___1 = qla2x00_gid_list_size(ha);
#line 3671
  tmp___2 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )tmp___1, & ha->gid_list_dma,
                            208U, (struct dma_attrs *)0);
#line 3671
  ha->gid_list = (struct gid_list_info *)tmp___2;
#line 3673
  if ((unsigned long )ha->gid_list == (unsigned long )((struct gid_list_info *)0)) {
#line 3674
    goto fail_free_tgt_mem;
  } else {

  }
#line 3676
  ha->srb_mempool = mempool_create_slab_pool(128, srb_cachep);
#line 3677
  if ((unsigned long )ha->srb_mempool == (unsigned long )((mempool_t *)0)) {
#line 3678
    goto fail_free_gid_list;
  } else {

  }
#line 3680
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3682
    if ((unsigned long )ctx_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 3683
      ctx_cachep = kmem_cache_create("qla2xxx_ctx", 48UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 3686
      if ((unsigned long )ctx_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 3687
        goto fail_free_gid_list;
      } else {

      }
    } else {

    }
#line 3689
    ha->ctx_mempool = mempool_create_slab_pool(128, ctx_cachep);
#line 3691
    if ((unsigned long )ha->ctx_mempool == (unsigned long )((mempool_t *)0)) {
#line 3692
      goto fail_free_srb_mempool;
    } else {

    }
#line 3693
    ql_dbg_pci(1073741824U, ha->pdev, 33, "ctx_cachep=%p ctx_mempool=%p.\n", ctx_cachep,
               ha->ctx_mempool);
  } else {

  }
#line 3699
  ha->nvram = kzalloc(4096UL, 208U);
#line 3700
  if ((unsigned long )ha->nvram == (unsigned long )((void *)0)) {
#line 3701
    goto fail_free_ctx_mempool;
  } else {

  }
#line 3703
  snprintf((char *)(& name), 16UL, "%s_%d", (char *)"qla2xxx", (int )(ha->pdev)->device);
#line 3705
  ha->s_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev, 256UL,
                                   8UL, 0UL);
#line 3707
  if ((unsigned long )ha->s_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3708
    goto fail_free_nvram;
  } else {

  }
#line 3710
  ql_dbg_pci(1073741824U, ha->pdev, 34, "init_cb=%p gid_list=%p, srb_mempool=%p s_dma_pool=%p.\n",
             ha->init_cb, ha->gid_list, ha->srb_mempool, ha->s_dma_pool);
#line 3714
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || ql2xenabledif != 0) {
#line 3715
    ha->dl_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev,
                                      512UL, 8UL, 0UL);
#line 3717
    if ((unsigned long )ha->dl_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3718
      ql_log_pci(0U, ha->pdev, 35, "Failed to allocate memory for dl_dma_pool.\n");
#line 3720
      goto fail_s_dma_pool;
    } else {

    }
#line 3723
    ha->fcp_cmnd_dma_pool = dma_pool_create((char const   *)(& name), & (ha->pdev)->dev,
                                            512UL, 8UL, 0UL);
#line 3725
    if ((unsigned long )ha->fcp_cmnd_dma_pool == (unsigned long )((struct dma_pool *)0)) {
#line 3726
      ql_log_pci(0U, ha->pdev, 36, "Failed to allocate memory for fcp_cmnd_dma_pool.\n");
#line 3728
      goto fail_dl_dma_pool;
    } else {

    }
#line 3730
    ql_dbg_pci(1073741824U, ha->pdev, 37, "dl_dma_pool=%p fcp_cmnd_dma_pool=%p.\n",
               ha->dl_dma_pool, ha->fcp_cmnd_dma_pool);
  } else {

  }
#line 3736
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 3738
    tmp___3 = dma_alloc_attrs(& (ha->pdev)->dev, 2064UL, & ha->sns_cmd_dma, 208U,
                              (struct dma_attrs *)0);
#line 3738
    ha->sns_cmd = (struct sns_cmd_pkt *)tmp___3;
#line 3740
    if ((unsigned long )ha->sns_cmd == (unsigned long )((struct sns_cmd_pkt *)0)) {
#line 3741
      goto fail_dma_pool;
    } else {

    }
#line 3742
    ql_dbg_pci(1073741824U, ha->pdev, 38, "sns_cmd: %p.\n", ha->sns_cmd);
  } else {
#line 3746
    tmp___4 = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->ms_iocb_dma);
#line 3746
    ha->ms_iocb = (ms_iocb_entry_t *)tmp___4;
#line 3748
    if ((unsigned long )ha->ms_iocb == (unsigned long )((ms_iocb_entry_t *)0)) {
#line 3749
      goto fail_dma_pool;
    } else {

    }
#line 3751
    tmp___5 = dma_alloc_attrs(& (ha->pdev)->dev, 8208UL, & ha->ct_sns_dma, 208U, (struct dma_attrs *)0);
#line 3751
    ha->ct_sns = (struct ct_sns_pkt *)tmp___5;
#line 3753
    if ((unsigned long )ha->ct_sns == (unsigned long )((struct ct_sns_pkt *)0)) {
#line 3754
      goto fail_free_ms_iocb;
    } else {

    }
#line 3755
    ql_dbg_pci(1073741824U, ha->pdev, 39, "ms_iocb=%p ct_sns=%p.\n", ha->ms_iocb,
               ha->ct_sns);
  }
#line 3761
  tmp___6 = kzalloc(184UL, 208U);
#line 3761
  *req = (struct req_que *)tmp___6;
#line 3762
  if ((unsigned long )*req == (unsigned long )((struct req_que *)0)) {
#line 3763
    ql_log_pci(0U, ha->pdev, 40, "Failed to allocate memory for req.\n");
#line 3765
    goto fail_req;
  } else {

  }
#line 3767
  (*req)->length = req_len;
#line 3768
  tmp___7 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*req)->length + 1) * 64UL,
                            & (*req)->dma, 208U, (struct dma_attrs *)0);
#line 3768
  (*req)->ring = (request_t *)tmp___7;
#line 3771
  if ((unsigned long )(*req)->ring == (unsigned long )((request_t *)0)) {
#line 3772
    ql_log_pci(0U, ha->pdev, 41, "Failed to allocate memory for req_ring.\n");
#line 3774
    goto fail_req_ring;
  } else {

  }
#line 3777
  tmp___8 = kzalloc(256UL, 208U);
#line 3777
  *rsp = (struct rsp_que *)tmp___8;
#line 3778
  if ((unsigned long )*rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3779
    ql_log_pci(0U, ha->pdev, 42, "Failed to allocate memory for rsp.\n");
#line 3781
    goto fail_rsp;
  } else {

  }
#line 3783
  (*rsp)->hw = ha;
#line 3784
  (*rsp)->length = rsp_len;
#line 3785
  tmp___9 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*rsp)->length + 1) * 64UL,
                            & (*rsp)->dma, 208U, (struct dma_attrs *)0);
#line 3785
  (*rsp)->ring = (response_t *)tmp___9;
#line 3788
  if ((unsigned long )(*rsp)->ring == (unsigned long )((response_t *)0)) {
#line 3789
    ql_log_pci(0U, ha->pdev, 43, "Failed to allocate memory for rsp_ring.\n");
#line 3791
    goto fail_rsp_ring;
  } else {

  }
#line 3793
  (*req)->rsp = *rsp;
#line 3794
  (*rsp)->req = *req;
#line 3795
  ql_dbg_pci(1073741824U, ha->pdev, 44, "req=%p req->length=%d req->ring=%p rsp=%p rsp->length=%d rsp->ring=%p.\n",
             *req, (int )(*req)->length, (*req)->ring, *rsp, (int )(*rsp)->length,
             (*rsp)->ring);
#line 3801
  if ((unsigned int )ha->nvram_npiv_size != 0U) {
#line 3802
    tmp___10 = kzalloc((unsigned long )ha->nvram_npiv_size * 24UL, 208U);
#line 3802
    ha->npiv_info = (struct qla_npiv_entry *)tmp___10;
#line 3804
    if ((unsigned long )ha->npiv_info == (unsigned long )((struct qla_npiv_entry *)0)) {
#line 3805
      ql_log_pci(0U, ha->pdev, 45, "Failed to allocate memory for npiv_info.\n");
#line 3807
      goto fail_npiv_info;
    } else {

    }
  } else {
#line 3810
    ha->npiv_info = (struct qla_npiv_entry *)0;
  }
#line 3813
  if (((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) || (ha->device_type & 32768U) != 0U) {
#line 3814
    tmp___11 = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->ex_init_cb_dma);
#line 3814
    ha->ex_init_cb = (struct ex_init_cb_81xx *)tmp___11;
#line 3816
    if ((unsigned long )ha->ex_init_cb == (unsigned long )((struct ex_init_cb_81xx *)0)) {
#line 3817
      goto fail_ex_init_cb;
    } else {

    }
#line 3818
    ql_dbg_pci(1073741824U, ha->pdev, 46, "ex_init_cb=%p.\n", ha->ex_init_cb);
  } else {

  }
#line 3822
  INIT_LIST_HEAD(& ha->gbl_dsd_list);
#line 3825
  if ((ha->device_type & 134217728U) == 0U) {
#line 3826
    ha->async_pd = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->async_pd_dma);
#line 3828
    if ((unsigned long )ha->async_pd == (unsigned long )((void *)0)) {
#line 3829
      goto fail_async_pd;
    } else {

    }
#line 3830
    ql_dbg_pci(1073741824U, ha->pdev, 47, "async_pd=%p.\n", ha->async_pd);
  } else {

  }
#line 3834
  INIT_LIST_HEAD(& ha->vp_list);
#line 3837
  ha->loop_id_map = kzalloc((((unsigned long )ha->max_fibre_devices + 63UL) / 64UL) * 8UL,
                            208U);
#line 3839
  if ((unsigned long )ha->loop_id_map == (unsigned long )((void *)0)) {
#line 3840
    goto fail_async_pd;
  } else {
#line 3842
    qla2x00_set_reserved_loop_ids(ha);
#line 3843
    ql_dbg_pci(1073741824U, ha->pdev, 291, "loop_id_map=%p. \n", ha->loop_id_map);
  }
#line 3847
  return (1);
  fail_async_pd: 
#line 3850
  dma_pool_free(ha->s_dma_pool, (void *)ha->ex_init_cb, ha->ex_init_cb_dma);
  fail_ex_init_cb: 
#line 3852
  kfree((void const   *)ha->npiv_info);
  fail_npiv_info: 
#line 3854
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*rsp)->length + 1) * 64UL,
                 (void *)(*rsp)->ring, (*rsp)->dma, (struct dma_attrs *)0);
#line 3856
  (*rsp)->ring = (response_t *)0;
#line 3857
  (*rsp)->dma = 0ULL;
  fail_rsp_ring: 
#line 3859
  kfree((void const   *)*rsp);
  fail_rsp: 
#line 3861
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )(*req)->length + 1) * 64UL,
                 (void *)(*req)->ring, (*req)->dma, (struct dma_attrs *)0);
#line 3863
  (*req)->ring = (request_t *)0;
#line 3864
  (*req)->dma = 0ULL;
  fail_req_ring: 
#line 3866
  kfree((void const   *)*req);
  fail_req: 
#line 3868
  dma_free_attrs(& (ha->pdev)->dev, 8208UL, (void *)ha->ct_sns, ha->ct_sns_dma, (struct dma_attrs *)0);
#line 3870
  ha->ct_sns = (struct ct_sns_pkt *)0;
#line 3871
  ha->ct_sns_dma = 0ULL;
  fail_free_ms_iocb: 
#line 3873
  dma_pool_free(ha->s_dma_pool, (void *)ha->ms_iocb, ha->ms_iocb_dma);
#line 3874
  ha->ms_iocb = (ms_iocb_entry_t *)0;
#line 3875
  ha->ms_iocb_dma = 0ULL;
  fail_dma_pool: ;
#line 3877
  if ((ha->device_type & 16384U) != 0U || ql2xenabledif != 0) {
#line 3878
    dma_pool_destroy(ha->fcp_cmnd_dma_pool);
#line 3879
    ha->fcp_cmnd_dma_pool = (struct dma_pool *)0;
  } else {

  }
  fail_dl_dma_pool: ;
#line 3882
  if ((ha->device_type & 16384U) != 0U || ql2xenabledif != 0) {
#line 3883
    dma_pool_destroy(ha->dl_dma_pool);
#line 3884
    ha->dl_dma_pool = (struct dma_pool *)0;
  } else {

  }
  fail_s_dma_pool: 
#line 3887
  dma_pool_destroy(ha->s_dma_pool);
#line 3888
  ha->s_dma_pool = (struct dma_pool *)0;
  fail_free_nvram: 
#line 3890
  kfree((void const   *)ha->nvram);
#line 3891
  ha->nvram = (void *)0;
  fail_free_ctx_mempool: 
#line 3893
  mempool_destroy(ha->ctx_mempool);
#line 3894
  ha->ctx_mempool = (mempool_t *)0;
  fail_free_srb_mempool: 
#line 3896
  mempool_destroy(ha->srb_mempool);
#line 3897
  ha->srb_mempool = (mempool_t *)0;
  fail_free_gid_list: 
#line 3899
  tmp___12 = qla2x00_gid_list_size(ha);
#line 3899
  dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp___12, (void *)ha->gid_list, ha->gid_list_dma,
                 (struct dma_attrs *)0);
#line 3902
  ha->gid_list = (struct gid_list_info *)0;
#line 3903
  ha->gid_list_dma = 0ULL;
  fail_free_tgt_mem: 
#line 3905
  qlt_mem_free(ha);
  fail_free_init_cb: 
#line 3907
  dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, (void *)ha->init_cb,
                 ha->init_cb_dma, (struct dma_attrs *)0);
#line 3909
  ha->init_cb = (init_cb_t *)0;
#line 3910
  ha->init_cb_dma = 0ULL;
  fail: 
#line 3912
  ql_log(0U, (scsi_qla_host_t *)0, 48, "Memory allocation failure.\n");
#line 3914
  return (-12);
}
}
#line 3925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_free_fw_dump(struct qla_hw_data *ha ) 
{ 
  __u32 tmp ;

  {
#line 3927
  if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 3928
    dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->fce, ha->fce_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3931
  if ((unsigned long )ha->fw_dump != (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 3932
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 3933
      tmp = __fswab32((ha->fw_dump)->eft_size);
#line 3933
      dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp, ha->eft, ha->eft_dma, (struct dma_attrs *)0);
    } else {

    }
#line 3935
    vfree((void const   *)ha->fw_dump);
  } else {

  }
#line 3937
  ha->fce = (void *)0;
#line 3938
  ha->fce_dma = 0ULL;
#line 3939
  ha->eft = (void *)0;
#line 3940
  ha->eft_dma = 0ULL;
#line 3941
  ha->fw_dump = (struct qla2xxx_fw_dump *)0;
#line 3942
  ha->fw_dumped = 0;
#line 3943
  ha->fw_dump_reading = 0;
#line 3944
  return;
}
}
#line 3954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_mem_free(struct qla_hw_data *ha ) 
{ 
  int tmp ;
  struct dsd_dma *dsd_ptr ;
  struct dsd_dma *tdsd_ptr ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;

  {
#line 3956
  qla2x00_free_fw_dump(ha);
#line 3958
  if ((unsigned long )ha->mctp_dump != (unsigned long )((void *)0)) {
#line 3959
    dma_free_attrs(& (ha->pdev)->dev, 548964UL, ha->mctp_dump, ha->mctp_dump_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3962
  if ((unsigned long )ha->srb_mempool != (unsigned long )((mempool_t *)0)) {
#line 3963
    mempool_destroy(ha->srb_mempool);
  } else {

  }
#line 3965
  if ((unsigned long )ha->dcbx_tlv != (unsigned long )((void *)0)) {
#line 3966
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, ha->dcbx_tlv, ha->dcbx_tlv_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3969
  if ((unsigned long )ha->xgmac_data != (unsigned long )((void *)0)) {
#line 3970
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, ha->xgmac_data, ha->xgmac_data_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3973
  if ((unsigned long )ha->sns_cmd != (unsigned long )((struct sns_cmd_pkt *)0)) {
#line 3974
    dma_free_attrs(& (ha->pdev)->dev, 2064UL, (void *)ha->sns_cmd, ha->sns_cmd_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3977
  if ((unsigned long )ha->ct_sns != (unsigned long )((struct ct_sns_pkt *)0)) {
#line 3978
    dma_free_attrs(& (ha->pdev)->dev, 8208UL, (void *)ha->ct_sns, ha->ct_sns_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 3981
  if ((unsigned long )ha->sfp_data != (unsigned long )((void *)0)) {
#line 3982
    dma_pool_free(ha->s_dma_pool, ha->sfp_data, ha->sfp_data_dma);
  } else {

  }
#line 3984
  if ((unsigned long )ha->ms_iocb != (unsigned long )((ms_iocb_entry_t *)0)) {
#line 3985
    dma_pool_free(ha->s_dma_pool, (void *)ha->ms_iocb, ha->ms_iocb_dma);
  } else {

  }
#line 3987
  if ((unsigned long )ha->ex_init_cb != (unsigned long )((struct ex_init_cb_81xx *)0)) {
#line 3988
    dma_pool_free(ha->s_dma_pool, (void *)ha->ex_init_cb, ha->ex_init_cb_dma);
  } else {

  }
#line 3991
  if ((unsigned long )ha->async_pd != (unsigned long )((void *)0)) {
#line 3992
    dma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);
  } else {

  }
#line 3994
  if ((unsigned long )ha->s_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 3995
    dma_pool_destroy(ha->s_dma_pool);
  } else {

  }
#line 3997
  if ((unsigned long )ha->gid_list != (unsigned long )((struct gid_list_info *)0)) {
#line 3998
    tmp = qla2x00_gid_list_size(ha);
#line 3998
    dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp, (void *)ha->gid_list, ha->gid_list_dma,
                   (struct dma_attrs *)0);
  } else {

  }
#line 4001
  if ((ha->device_type & 16384U) != 0U) {
#line 4002
    tmp___0 = list_empty((struct list_head  const  *)(& ha->gbl_dsd_list));
#line 4002
    if (tmp___0 == 0) {
#line 4006
      __mptr = (struct list_head  const  *)ha->gbl_dsd_list.next;
#line 4006
      dsd_ptr = (struct dsd_dma *)__mptr;
#line 4006
      __mptr___0 = (struct list_head  const  *)dsd_ptr->list.next;
#line 4006
      tdsd_ptr = (struct dsd_dma *)__mptr___0;
#line 4006
      goto ldv_62072;
      ldv_62071: 
#line 4008
      dma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr, dsd_ptr->dsd_list_dma);
#line 4010
      list_del(& dsd_ptr->list);
#line 4011
      kfree((void const   *)dsd_ptr);
#line 4006
      dsd_ptr = tdsd_ptr;
#line 4006
      __mptr___1 = (struct list_head  const  *)tdsd_ptr->list.next;
#line 4006
      tdsd_ptr = (struct dsd_dma *)__mptr___1;
      ldv_62072: ;
#line 4006
      if ((unsigned long )(& dsd_ptr->list) != (unsigned long )(& ha->gbl_dsd_list)) {
#line 4008
        goto ldv_62071;
      } else {

      }

    } else {

    }
  } else {

  }
#line 4016
  if ((unsigned long )ha->dl_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 4017
    dma_pool_destroy(ha->dl_dma_pool);
  } else {

  }
#line 4019
  if ((unsigned long )ha->fcp_cmnd_dma_pool != (unsigned long )((struct dma_pool *)0)) {
#line 4020
    dma_pool_destroy(ha->fcp_cmnd_dma_pool);
  } else {

  }
#line 4022
  if ((unsigned long )ha->ctx_mempool != (unsigned long )((mempool_t *)0)) {
#line 4023
    mempool_destroy(ha->ctx_mempool);
  } else {

  }
#line 4025
  qlt_mem_free(ha);
#line 4027
  if ((unsigned long )ha->init_cb != (unsigned long )((init_cb_t *)0)) {
#line 4028
    dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->init_cb_size, (void *)ha->init_cb,
                   ha->init_cb_dma, (struct dma_attrs *)0);
  } else {

  }
#line 4030
  vfree((void const   *)ha->optrom_buffer);
#line 4031
  kfree((void const   *)ha->nvram);
#line 4032
  kfree((void const   *)ha->npiv_info);
#line 4033
  kfree((void const   *)ha->swl);
#line 4034
  kfree((void const   *)ha->loop_id_map);
#line 4036
  ha->srb_mempool = (mempool_t *)0;
#line 4037
  ha->ctx_mempool = (mempool_t *)0;
#line 4038
  ha->sns_cmd = (struct sns_cmd_pkt *)0;
#line 4039
  ha->sns_cmd_dma = 0ULL;
#line 4040
  ha->ct_sns = (struct ct_sns_pkt *)0;
#line 4041
  ha->ct_sns_dma = 0ULL;
#line 4042
  ha->ms_iocb = (ms_iocb_entry_t *)0;
#line 4043
  ha->ms_iocb_dma = 0ULL;
#line 4044
  ha->init_cb = (init_cb_t *)0;
#line 4045
  ha->init_cb_dma = 0ULL;
#line 4046
  ha->ex_init_cb = (struct ex_init_cb_81xx *)0;
#line 4047
  ha->ex_init_cb_dma = 0ULL;
#line 4048
  ha->async_pd = (void *)0;
#line 4049
  ha->async_pd_dma = 0ULL;
#line 4051
  ha->s_dma_pool = (struct dma_pool *)0;
#line 4052
  ha->dl_dma_pool = (struct dma_pool *)0;
#line 4053
  ha->fcp_cmnd_dma_pool = (struct dma_pool *)0;
#line 4055
  ha->gid_list = (struct gid_list_info *)0;
#line 4056
  ha->gid_list_dma = 0ULL;
#line 4058
  ha->tgt.atio_ring = (struct atio *)0;
#line 4059
  ha->tgt.atio_dma = 0ULL;
#line 4060
  ha->tgt.tgt_vp_map = (struct qla_tgt_vp_map *)0;
#line 4061
  return;
}
}
#line 4063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht , struct qla_hw_data *ha ) 
{ 
  struct Scsi_Host *host ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  struct lock_class_key __key ;
  char const   *tmp___0 ;

  {
#line 4067
  vha = (struct scsi_qla_host *)0;
#line 4069
  host = ldv_scsi_host_alloc_6(sht, 992);
#line 4070
  if ((unsigned long )host == (unsigned long )((struct Scsi_Host *)0)) {
#line 4071
    ql_log_pci(0U, ha->pdev, 263, "Failed to allocate host from the scsi layer, aborting.\n");
#line 4073
    goto fail;
  } else {

  }
#line 4077
  tmp = shost_priv(host);
#line 4077
  vha = (struct scsi_qla_host *)tmp;
#line 4078
  memset((void *)vha, 0, 992UL);
#line 4080
  vha->host = host;
#line 4081
  vha->host_no = (unsigned long )host->host_no;
#line 4082
  vha->hw = ha;
#line 4084
  INIT_LIST_HEAD(& vha->vp_fcports);
#line 4085
  INIT_LIST_HEAD(& vha->work_list);
#line 4086
  INIT_LIST_HEAD(& vha->list);
#line 4088
  spinlock_check(& vha->work_lock);
#line 4088
  __raw_spin_lock_init(& vha->work_lock.ldv_6105.rlock, "&(&vha->work_lock)->rlock",
                       & __key);
#line 4090
  sprintf((char *)(& vha->host_str), "%s_%ld", (char *)"qla2xxx", vha->host_no);
#line 4091
  tmp___0 = dev_name((struct device  const  *)(& (ha->pdev)->dev));
#line 4091
  ql_dbg(1073741824U, vha, 65, "Allocated the host=%p hw=%p vha=%p dev_name=%s", vha->host,
         vha->hw, vha, tmp___0);
#line 4096
  return (vha);
  fail: ;
#line 4099
  return (vha);
}
}
#line 4103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct qla_work_evt *qla2x00_alloc_work(struct scsi_qla_host *vha , enum qla_work_type type ) 
{ 
  struct qla_work_evt *e ;
  uint8_t bail ;
  void *tmp ;

  {
#line 4108
  atomic_inc(& vha->vref_count);
#line 4108
  __asm__  volatile   ("mfence": : : "memory");
#line 4108
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4108
    atomic_dec(& vha->vref_count);
#line 4108
    bail = 1U;
  } else {
#line 4108
    bail = 0U;
  }
#line 4109
  if ((unsigned int )bail != 0U) {
#line 4110
    return ((struct qla_work_evt *)0);
  } else {

  }
#line 4112
  tmp = kzalloc(64UL, 32U);
#line 4112
  e = (struct qla_work_evt *)tmp;
#line 4113
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4114
    atomic_dec(& vha->vref_count);
#line 4115
    return ((struct qla_work_evt *)0);
  } else {

  }
#line 4118
  INIT_LIST_HEAD(& e->list);
#line 4119
  e->type = type;
#line 4120
  e->flags = 1U;
#line 4121
  return (e);
}
}
#line 4125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_post_work(struct scsi_qla_host *vha , struct qla_work_evt *e ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 4129
  tmp = spinlock_check(& vha->work_lock);
#line 4129
  flags = _raw_spin_lock_irqsave(tmp);
#line 4130
  list_add_tail(& e->list, & vha->work_list);
#line 4131
  spin_unlock_irqrestore(& vha->work_lock, flags);
#line 4132
  qla2xxx_wake_dpc(vha);
#line 4134
  return (0);
}
}
#line 4138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_aen_work(struct scsi_qla_host *vha , enum fc_host_event_code code ,
                          u32 data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4143
  e = qla2x00_alloc_work(vha, 0);
#line 4144
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4145
    return (258);
  } else {

  }
#line 4147
  e->u.aen.code = code;
#line 4148
  e->u.aen.data = data;
#line 4149
  tmp = qla2x00_post_work(vha, e);
#line 4149
  return (tmp);
}
}
#line 4153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_idc_ack_work(struct scsi_qla_host *vha , uint16_t *mb ) 
{ 
  struct qla_work_evt *e ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 4157
  e = qla2x00_alloc_work(vha, 1);
#line 4158
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4159
    return (258);
  } else {

  }
#line 4161
  __len = 14UL;
#line 4161
  if (__len > 63UL) {
#line 4161
    __ret = __memcpy((void *)(& e->u.idc_ack.mb), (void const   *)mb, __len);
  } else {
#line 4161
    __ret = __builtin_memcpy((void *)(& e->u.idc_ack.mb), (void const   *)mb, __len);
  }
#line 4162
  tmp = qla2x00_post_work(vha, e);
#line 4162
  return (tmp);
}
}
#line 4184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_login_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4184
  e = qla2x00_alloc_work(vha, 2);
#line 4184
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4184
    return (258);
  } else {

  }
#line 4184
  e->u.logio.fcport = fcport;
#line 4184
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4184
    e->u.logio.data[0] = *data;
#line 4184
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4184
  tmp = qla2x00_post_work(vha, e);
#line 4184
  return (tmp);
}
}
#line 4185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_login_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4185
  e = qla2x00_alloc_work(vha, 3);
#line 4185
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4185
    return (258);
  } else {

  }
#line 4185
  e->u.logio.fcport = fcport;
#line 4185
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4185
    e->u.logio.data[0] = *data;
#line 4185
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4185
  tmp = qla2x00_post_work(vha, e);
#line 4185
  return (tmp);
}
}
#line 4186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_logout_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                   uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4186
  e = qla2x00_alloc_work(vha, 4);
#line 4186
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4186
    return (258);
  } else {

  }
#line 4186
  e->u.logio.fcport = fcport;
#line 4186
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4186
    e->u.logio.data[0] = *data;
#line 4186
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4186
  tmp = qla2x00_post_work(vha, e);
#line 4186
  return (tmp);
}
}
#line 4187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_logout_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                        uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4187
  e = qla2x00_alloc_work(vha, 5);
#line 4187
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4187
    return (258);
  } else {

  }
#line 4187
  e->u.logio.fcport = fcport;
#line 4187
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4187
    e->u.logio.data[0] = *data;
#line 4187
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4187
  tmp = qla2x00_post_work(vha, e);
#line 4187
  return (tmp);
}
}
#line 4188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_adisc_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                  uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4188
  e = qla2x00_alloc_work(vha, 6);
#line 4188
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4188
    return (258);
  } else {

  }
#line 4188
  e->u.logio.fcport = fcport;
#line 4188
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4188
    e->u.logio.data[0] = *data;
#line 4188
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4188
  tmp = qla2x00_post_work(vha, e);
#line 4188
  return (tmp);
}
}
#line 4189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_async_adisc_done_work(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                       uint16_t *data ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4189
  e = qla2x00_alloc_work(vha, 7);
#line 4189
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4189
    return (258);
  } else {

  }
#line 4189
  e->u.logio.fcport = fcport;
#line 4189
  if ((unsigned long )data != (unsigned long )((uint16_t *)0U)) {
#line 4189
    e->u.logio.data[0] = *data;
#line 4189
    e->u.logio.data[1] = *(data + 1UL);
  } else {

  }
#line 4189
  tmp = qla2x00_post_work(vha, e);
#line 4189
  return (tmp);
}
}
#line 4192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla2x00_post_uevent_work(struct scsi_qla_host *vha , u32 code ) 
{ 
  struct qla_work_evt *e ;
  int tmp ;

  {
#line 4196
  e = qla2x00_alloc_work(vha, 8);
#line 4197
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4198
    return (258);
  } else {

  }
#line 4200
  e->u.uevent.code = code;
#line 4201
  tmp = qla2x00_post_work(vha, e);
#line 4201
  return (tmp);
}
}
#line 4205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_uevent_emit(struct scsi_qla_host *vha , u32 code ) 
{ 
  char event_string[40U] ;
  char *envp[2U] ;

  {
#line 4208
  envp[0] = (char *)(& event_string);
#line 4208
  envp[1] = (char *)0;
#line 4210
  switch (code) {
  case 0U: 
#line 4212
  snprintf((char *)(& event_string), 40UL, "FW_DUMP=%ld", vha->host_no);
#line 4214
  goto ldv_62158;
  default: ;
#line 4217
  goto ldv_62158;
  }
  ldv_62158: 
#line 4219
  kobject_uevent_env(& ((vha->hw)->pdev)->dev.kobj, 2, (char **)(& envp));
#line 4220
  return;
}
}
#line 4223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qlafx00_post_aenfx_work(struct scsi_qla_host *vha , uint32_t evtcode , uint32_t *data ,
                            int cnt ) 
{ 
  struct qla_work_evt *e ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 4228
  e = qla2x00_alloc_work(vha, 9);
#line 4229
  if ((unsigned long )e == (unsigned long )((struct qla_work_evt *)0)) {
#line 4230
    return (258);
  } else {

  }
#line 4232
  e->u.aenfx.evtcode = evtcode;
#line 4233
  e->u.aenfx.count = (uint32_t )cnt;
#line 4234
  __len = (unsigned long )cnt * 4UL;
#line 4234
  __ret = __builtin_memcpy((void *)(& e->u.aenfx.mbx), (void const   *)data, __len);
#line 4235
  tmp = qla2x00_post_work(vha, e);
#line 4235
  return (tmp);
}
}
#line 4239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_do_work(struct scsi_qla_host *vha ) 
{ 
  struct qla_work_evt *e ;
  struct qla_work_evt *tmp ;
  unsigned long flags ;
  struct list_head work ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u32 tmp___1 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 4243
  work.next = & work;
#line 4243
  work.prev = & work;
#line 4245
  tmp___0 = spinlock_check(& vha->work_lock);
#line 4245
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 4246
  list_splice_init(& vha->work_list, & work);
#line 4247
  spin_unlock_irqrestore(& vha->work_lock, flags);
#line 4249
  __mptr = (struct list_head  const  *)work.next;
#line 4249
  e = (struct qla_work_evt *)__mptr;
#line 4249
  __mptr___0 = (struct list_head  const  *)e->list.next;
#line 4249
  tmp = (struct qla_work_evt *)__mptr___0;
#line 4249
  goto ldv_62198;
  ldv_62197: 
#line 4250
  list_del_init(& e->list);
#line 4252
  switch ((unsigned int )e->type) {
  case 0U: 
#line 4254
  tmp___1 = fc_get_event_number();
#line 4254
  fc_host_post_event(vha->host, tmp___1, e->u.aen.code, e->u.aen.data);
#line 4256
  goto ldv_62187;
  case 1U: 
#line 4258
  qla81xx_idc_ack(vha, (uint16_t *)(& e->u.idc_ack.mb));
#line 4259
  goto ldv_62187;
  case 2U: 
#line 4261
  qla2x00_async_login(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 4263
  goto ldv_62187;
  case 3U: 
#line 4265
  qla2x00_async_login_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 4267
  goto ldv_62187;
  case 4U: 
#line 4269
  qla2x00_async_logout(vha, e->u.logio.fcport);
#line 4270
  goto ldv_62187;
  case 5U: 
#line 4272
  qla2x00_async_logout_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 4274
  goto ldv_62187;
  case 6U: 
#line 4276
  qla2x00_async_adisc(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 4278
  goto ldv_62187;
  case 7U: 
#line 4280
  qla2x00_async_adisc_done(vha, e->u.logio.fcport, (uint16_t *)(& e->u.logio.data));
#line 4282
  goto ldv_62187;
  case 8U: 
#line 4284
  qla2x00_uevent_emit(vha, e->u.uevent.code);
#line 4285
  goto ldv_62187;
  case 9U: 
#line 4287
  qlafx00_process_aen(vha, e);
#line 4288
  goto ldv_62187;
  }
  ldv_62187: ;
#line 4290
  if ((int )e->flags & 1) {
#line 4291
    kfree((void const   *)e);
  } else {

  }
#line 4294
  atomic_dec(& vha->vref_count);
#line 4249
  e = tmp;
#line 4249
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 4249
  tmp = (struct qla_work_evt *)__mptr___1;
  ldv_62198: ;
#line 4249
  if ((unsigned long )(& e->list) != (unsigned long )(& work)) {
#line 4251
    goto ldv_62197;
  } else {

  }

#line 4256
  return;
}
}
#line 4301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_relogin(struct scsi_qla_host *vha ) 
{ 
  fc_port_t *fcport ;
  int status ;
  uint16_t next_loopid ;
  struct qla_hw_data *ha ;
  uint16_t data[2U] ;
  struct list_head  const  *__mptr ;
  int status2 ;
  uint8_t opts ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4305
  next_loopid = 0U;
#line 4306
  ha = vha->hw;
#line 4309
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 4309
  fcport = (fc_port_t *)__mptr;
#line 4309
  goto ldv_62217;
  ldv_62216: 
#line 4314
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 4314
  if ((tmp != 4 && fcport->login_retry != 0) && (fcport->flags & 8U) == 0U) {
#line 4316
    fcport->login_retry = fcport->login_retry - 1;
#line 4317
    if ((int )fcport->flags & 1) {
#line 4318
      if ((fcport->flags & 4U) != 0U) {
#line 4319
        (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
      } else {

      }
#line 4325
      if ((unsigned int )fcport->loop_id == 4096U) {
#line 4326
        next_loopid = ha->min_external_loopid;
#line 4326
        fcport->loop_id = next_loopid;
#line 4328
        status = qla2x00_find_new_loop_id(vha, fcport);
#line 4330
        if (status != 0) {
#line 4332
          goto ldv_62212;
        } else {

        }
      } else {

      }
#line 4336
      if ((((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) || (ha->device_type & 134217728U) != 0U) {
#line 4337
        fcport->flags = fcport->flags | 8U;
#line 4338
        data[0] = 0U;
#line 4339
        data[1] = 1U;
#line 4340
        status = qla2x00_post_async_login_work(vha, fcport, (uint16_t *)(& data));
#line 4342
        if (status == 0) {
#line 4343
          goto ldv_62213;
        } else {

        }
#line 4345
        status = 1;
      } else {
#line 4347
        status = qla2x00_fabric_login(vha, fcport, & next_loopid);
#line 4349
        if (status == 0) {
#line 4353
          opts = 0U;
#line 4354
          if ((fcport->flags & 4U) != 0U) {
#line 4356
            opts = (uint8_t )((unsigned int )opts | 2U);
          } else {

          }
#line 4357
          status2 = qla2x00_get_port_database(vha, fcport, (int )opts);
#line 4360
          if (status2 != 0) {
#line 4361
            status = 1;
          } else {

          }
        } else {

        }
      }
    } else {
#line 4365
      status = qla2x00_local_device_login(vha, fcport);
    }
#line 4368
    if (status == 0) {
#line 4369
      fcport->old_loop_id = fcport->loop_id;
#line 4371
      ql_dbg(268435456U, vha, 8195, "Port login OK: logged in ID 0x%x.\n", (int )fcport->loop_id);
#line 4375
      qla2x00_update_fcport(vha, fcport);
    } else
#line 4377
    if (status == 1) {
#line 4378
      set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4380
      ql_dbg(268435456U, vha, 8199, "Retrying %d login again loop_id 0x%x.\n", fcport->login_retry,
             (int )fcport->loop_id);
    } else {
#line 4384
      fcport->login_retry = 0;
    }
#line 4387
    if (fcport->login_retry == 0 && status != 0) {
#line 4388
      qla2x00_clear_loop_id(fcport);
    } else {

    }
  } else {

  }
#line 4390
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4390
  if (tmp___0 != 0) {
#line 4391
    goto ldv_62212;
  } else {

  }
  ldv_62213: 
#line 4309
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 4309
  fcport = (fc_port_t *)__mptr___0;
  ldv_62217: ;
#line 4309
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 4311
    goto ldv_62216;
  } else {

  }
  ldv_62212: ;
#line 4316
  return;
}
}
#line 4397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_schedule_work(scsi_qla_host_t *base_vha , int work_code ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4399
  ha = base_vha->hw;
#line 4401
  switch (work_code) {
  case 33280: ;
#line 4403
  if ((unsigned long )ha->dpc_lp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4404
    queue_work(ha->dpc_lp_wq, & ha->idc_aen);
  } else {

  }
#line 4405
  goto ldv_62224;
  case 1: ;
#line 4408
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4409
    if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4410
      queue_work(ha->dpc_hp_wq, & ha->nic_core_reset);
    } else {

    }
  } else {
#line 4412
    ql_dbg(524288U, base_vha, 45150, "NIC Core reset is already active. Skip scheduling it again.\n");
  }
#line 4415
  goto ldv_62224;
  case 2: ;
#line 4417
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4418
    queue_work(ha->dpc_hp_wq, & ha->idc_state_handler);
  } else {

  }
#line 4419
  goto ldv_62224;
  case 3: ;
#line 4421
  if ((unsigned long )ha->dpc_hp_wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 4422
    queue_work(ha->dpc_hp_wq, & ha->nic_core_unrecoverable);
  } else {

  }
#line 4423
  goto ldv_62224;
  default: 
#line 4425
  ql_log(1U, base_vha, 45151, "Unknow work-code=0x%x.\n", work_code);
  }
  ldv_62224: ;
#line 4429
  return;
}
}
#line 4434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_nic_core_unrecoverable_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;

  {
#line 4437
  __mptr = (struct work_struct  const  *)work;
#line 4437
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff3d8UL;
#line 4438
  tmp = pci_get_drvdata(ha->pdev);
#line 4438
  base_vha = (scsi_qla_host_t *)tmp;
#line 4439
  dev_state = 0U;
#line 4441
  qla83xx_idc_lock(base_vha, 0);
#line 4442
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4443
  qla83xx_reset_ownership(base_vha);
#line 4444
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4445
    ha->flags.nic_core_reset_owner = 0U;
#line 4446
    qla83xx_wr_reg(base_vha, 571483012U, 6U);
#line 4448
    ql_log(2U, base_vha, 45152, "HW State: FAILED.\n");
#line 4449
    qla83xx_schedule_work(base_vha, 2);
  } else {

  }
#line 4451
  qla83xx_idc_unlock(base_vha, 0);
#line 4452
  return;
}
}
#line 4456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_idc_state_handler_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;

  {
#line 4459
  __mptr = (struct work_struct  const  *)work;
#line 4459
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff428UL;
#line 4460
  tmp = pci_get_drvdata(ha->pdev);
#line 4460
  base_vha = (scsi_qla_host_t *)tmp;
#line 4461
  dev_state = 0U;
#line 4463
  qla83xx_idc_lock(base_vha, 0);
#line 4464
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4465
  if (dev_state == 6U || dev_state == 5U) {
#line 4467
    qla83xx_idc_state_handler(base_vha);
  } else {

  }
#line 4468
  qla83xx_idc_unlock(base_vha, 0);
#line 4469
  return;
}
}
#line 4472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla83xx_check_nic_core_fw_alive(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  unsigned long heart_beat_wait ;
  uint32_t heart_beat_counter1 ;
  uint32_t heart_beat_counter2 ;

  {
#line 4474
  rval = 0;
#line 4475
  heart_beat_wait = (unsigned long )jiffies + 250UL;
  ldv_62259: ;
#line 4479
  if ((long )(heart_beat_wait - (unsigned long )jiffies) < 0L) {
#line 4480
    ql_dbg(524288U, base_vha, 45180, "Nic Core f/w is not alive.\n");
#line 4482
    rval = 258;
#line 4483
    goto ldv_62258;
  } else {

  }
#line 4486
  qla83xx_idc_lock(base_vha, 0);
#line 4487
  qla83xx_rd_reg(base_vha, 571482288U, & heart_beat_counter1);
#line 4489
  qla83xx_idc_unlock(base_vha, 0);
#line 4490
  msleep(100U);
#line 4491
  qla83xx_idc_lock(base_vha, 0);
#line 4492
  qla83xx_rd_reg(base_vha, 571482288U, & heart_beat_counter2);
#line 4494
  qla83xx_idc_unlock(base_vha, 0);
#line 4495
  if (heart_beat_counter1 == heart_beat_counter2) {
#line 4497
    goto ldv_62259;
  } else {

  }
  ldv_62258: ;
#line 4497
  return (rval);
}
}
#line 4502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_nic_core_reset_work(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4505
  __mptr = (struct work_struct  const  *)work;
#line 4505
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff478UL;
#line 4506
  tmp = pci_get_drvdata(ha->pdev);
#line 4506
  base_vha = (scsi_qla_host_t *)tmp;
#line 4507
  dev_state = 0U;
#line 4509
  if ((ha->device_type & 32768U) != 0U) {
#line 4510
    tmp___0 = qla2xxx_mctp_dump(base_vha);
#line 4510
    if (tmp___0 != 0) {
#line 4511
      ql_log(1U, base_vha, 45185, "Failed to dump mctp\n");
    } else {

    }
#line 4513
    return;
  } else {

  }
#line 4516
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4517
    tmp___1 = qla83xx_check_nic_core_fw_alive(base_vha);
#line 4517
    if (tmp___1 == 0) {
#line 4518
      qla83xx_idc_lock(base_vha, 0);
#line 4519
      qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4521
      qla83xx_idc_unlock(base_vha, 0);
#line 4522
      if (dev_state != 4U) {
#line 4523
        ql_dbg(524288U, base_vha, 45178, "Nic Core f/w is alive.\n");
#line 4525
        return;
      } else {

      }
    } else {

    }
#line 4529
    ha->flags.nic_core_reset_hdlr_active = 1U;
#line 4530
    tmp___2 = qla83xx_nic_core_reset(base_vha);
#line 4530
    if (tmp___2 != 0) {
#line 4532
      ql_dbg(524288U, base_vha, 45153, "NIC Core reset failed.\n");
    } else {

    }
#line 4535
    ha->flags.nic_core_reset_hdlr_active = 0U;
  } else {

  }
#line 4537
  return;
}
}
#line 4541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_service_idc_aen(struct work_struct *work ) 
{ 
  struct qla_hw_data *ha ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  uint32_t dev_state ;
  uint32_t idc_control ;
  int tmp___0 ;

  {
#line 4544
  __mptr = (struct work_struct  const  *)work;
#line 4544
  ha = (struct qla_hw_data *)__mptr + 0xfffffffffffff4d0UL;
#line 4545
  tmp = pci_get_drvdata(ha->pdev);
#line 4545
  base_vha = (scsi_qla_host_t *)tmp;
#line 4548
  qla83xx_idc_lock(base_vha, 0);
#line 4549
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4550
  qla83xx_rd_reg(base_vha, 571483024U, & idc_control);
#line 4551
  qla83xx_idc_unlock(base_vha, 0);
#line 4552
  if (dev_state == 4U) {
#line 4553
    if ((idc_control & 2U) != 0U) {
#line 4554
      ql_dbg(524288U, base_vha, 45154, "Application requested NIC Core Reset.\n");
#line 4556
      qla83xx_schedule_work(base_vha, 1);
    } else {
#line 4557
      tmp___0 = qla83xx_check_nic_core_fw_alive(base_vha);
#line 4557
      if (tmp___0 == 0) {
#line 4559
        ql_dbg(524288U, base_vha, 45179, "Other protocol driver requested NIC Core Reset.\n");
#line 4561
        qla83xx_schedule_work(base_vha, 1);
      } else {

      }
    }
  } else
#line 4563
  if (dev_state == 6U || dev_state == 5U) {
#line 4565
    qla83xx_schedule_work(base_vha, 2);
  } else {

  }
#line 4566
  return;
}
}
#line 4570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla83xx_wait_logic(void) 
{ 
  int i ;
  struct thread_info *tmp ;

  {
#line 4575
  tmp = current_thread_info();
#line 4575
  if (((unsigned long )tmp->preempt_count & 134217472UL) == 0UL) {
#line 4581
    msleep(100U);
#line 4582
    schedule();
  } else {
#line 4584
    i = 0;
#line 4584
    goto ldv_62282;
    ldv_62281: 
#line 4585
    cpu_relax();
#line 4584
    i = i + 1;
    ldv_62282: ;
#line 4584
    if (i <= 19) {
#line 4586
      goto ldv_62281;
    } else {

    }

  }
#line 4592
  return;
}
}
#line 4590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla83xx_force_lock_recovery(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  uint32_t data ;
  uint32_t idc_lck_rcvry_stage_mask ;
  uint32_t idc_lck_rcvry_owner_mask ;
  struct qla_hw_data *ha ;

  {
#line 4594
  idc_lck_rcvry_stage_mask = 3U;
#line 4595
  idc_lck_rcvry_owner_mask = 60U;
#line 4596
  ha = base_vha->hw;
#line 4597
  ql_dbg(524288U, base_vha, 45190, "Trying force recovery of the IDC lock.\n");
#line 4600
  rval = qla83xx_rd_reg(base_vha, 571483036U, & data);
#line 4601
  if (rval != 0) {
#line 4602
    return (rval);
  } else {

  }
#line 4604
  if ((data & idc_lck_rcvry_stage_mask) != 0U) {
#line 4605
    return (0);
  } else {
#line 4607
    data = (uint32_t )(((int )ha->portnum << 2) | 1);
#line 4608
    rval = qla83xx_wr_reg(base_vha, 571483036U, data);
#line 4610
    if (rval != 0) {
#line 4611
      return (rval);
    } else {

    }
#line 4613
    msleep(200U);
#line 4615
    rval = qla83xx_rd_reg(base_vha, 571483036U, & data);
#line 4617
    if (rval != 0) {
#line 4618
      return (rval);
    } else {

    }
#line 4620
    if ((data & idc_lck_rcvry_owner_mask) >> 2 == (uint32_t )ha->portnum) {
#line 4621
      data = (~ idc_lck_rcvry_stage_mask | 2U) & data;
#line 4623
      rval = qla83xx_wr_reg(base_vha, 571483036U, data);
#line 4625
      if (rval != 0) {
#line 4626
        return (rval);
      } else {

      }
#line 4629
      rval = qla83xx_rd_reg(base_vha, 2165424172U, & data);
#line 4631
      if (rval != 0) {
#line 4632
        return (rval);
      } else {

      }
#line 4634
      rval = qla83xx_wr_reg(base_vha, 571482372U, 255U);
#line 4636
      if (rval != 0) {
#line 4637
        return (rval);
      } else {

      }
#line 4639
      rval = qla83xx_wr_reg(base_vha, 571483036U, 0U);
#line 4641
      if (rval != 0) {
#line 4642
        return (rval);
      } else {

      }
    } else {
#line 4644
      return (0);
    }
  }
#line 4647
  return (rval);
}
}
#line 4651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla83xx_idc_lock_recovery(scsi_qla_host_t *base_vha ) 
{ 
  int rval ;
  uint32_t o_drv_lockid ;
  uint32_t n_drv_lockid ;
  unsigned long lock_recovery_timeout ;
  int tmp ;

  {
#line 4653
  rval = 0;
#line 4657
  lock_recovery_timeout = (unsigned long )jiffies + 500UL;
  retry_lockid: 
#line 4659
  rval = qla83xx_rd_reg(base_vha, 571482372U, & o_drv_lockid);
#line 4660
  if (rval != 0) {
#line 4661
    goto exit;
  } else {

  }
#line 4664
  if ((long )((unsigned long )jiffies - lock_recovery_timeout) >= 0L) {
#line 4665
    tmp = qla83xx_force_lock_recovery(base_vha);
#line 4665
    if (tmp == 0) {
#line 4666
      return (0);
    } else {
#line 4668
      return (258);
    }
  } else {

  }
#line 4671
  rval = qla83xx_rd_reg(base_vha, 571482372U, & n_drv_lockid);
#line 4672
  if (rval != 0) {
#line 4673
    goto exit;
  } else {

  }
#line 4675
  if (o_drv_lockid == n_drv_lockid) {
#line 4676
    qla83xx_wait_logic();
#line 4677
    goto retry_lockid;
  } else {
#line 4679
    return (0);
  }
  exit: ;
#line 4682
  return (rval);
}
}
#line 4686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_idc_lock(scsi_qla_host_t *base_vha , uint16_t requester_id ) 
{ 
  uint16_t options ;
  uint32_t data ;
  uint32_t lock_owner ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4688
  options = (uint16_t )((int )((short )((int )requester_id << 15)) | 64);
#line 4691
  ha = base_vha->hw;
  retry_lock: 
#line 4695
  tmp___0 = qla83xx_rd_reg(base_vha, 2165424168U, & data);
#line 4695
  if (tmp___0 == 0) {
#line 4697
    if (data != 0U) {
#line 4699
      qla83xx_wr_reg(base_vha, 571482372U, (uint32_t )ha->portnum);
    } else {
#line 4702
      qla83xx_rd_reg(base_vha, 571482372U, & lock_owner);
#line 4704
      ql_dbg(524288U, base_vha, 45155, "Failed to acquire IDC lock, acquired by %d, retrying...\n",
             lock_owner);
#line 4709
      tmp = qla83xx_idc_lock_recovery(base_vha);
#line 4709
      if (tmp == 0) {
#line 4711
        qla83xx_wait_logic();
#line 4712
        goto retry_lock;
      } else {
#line 4714
        ql_log(1U, base_vha, 45173, "IDC Lock recovery FAILED.\n");
      }
    }
  } else {

  }
#line 4720
  return;
  retry_lock2: 
#line 4724
  tmp___2 = qla83xx_access_control(base_vha, (int )options, 0U, 0U, (uint16_t *)0U);
#line 4724
  if (tmp___2 != 0) {
#line 4725
    ql_dbg(524288U, base_vha, 45170, "Failed to acquire IDC lock. retrying...\n");
#line 4728
    tmp___1 = qla83xx_idc_lock_recovery(base_vha);
#line 4728
    if (tmp___1 == 0) {
#line 4729
      qla83xx_wait_logic();
#line 4730
      goto retry_lock2;
    } else {
#line 4732
      ql_log(1U, base_vha, 45174, "IDC Lock recovery FAILED.\n");
    }
  } else {

  }
#line 4736
  return;
}
}
#line 4740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla83xx_idc_unlock(scsi_qla_host_t *base_vha , uint16_t requester_id ) 
{ 
  uint16_t options ;
  uint16_t retry ;
  uint32_t data ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 4742
  options = (uint16_t )((int )((short )((int )requester_id << 15)) | 128);
#line 4744
  ha = base_vha->hw;
#line 4749
  retry = 0U;
  retry_unlock: 
#line 4751
  tmp = qla83xx_rd_reg(base_vha, 571482372U, & data);
#line 4751
  if (tmp == 0) {
#line 4753
    if ((uint32_t )ha->portnum == data) {
#line 4754
      qla83xx_rd_reg(base_vha, 2165424172U, & data);
#line 4756
      qla83xx_wr_reg(base_vha, 571482372U, 255U);
    } else
#line 4757
    if ((unsigned int )retry <= 9U) {
#line 4761
      qla83xx_wait_logic();
#line 4762
      retry = (uint16_t )((int )retry + 1);
#line 4763
      ql_dbg(524288U, base_vha, 45156, "Failed to release IDC lock, retyring=%d\n",
             (int )retry);
#line 4765
      goto retry_unlock;
    } else {

    }
  } else
#line 4767
  if ((unsigned int )retry <= 9U) {
#line 4769
    qla83xx_wait_logic();
#line 4770
    retry = (uint16_t )((int )retry + 1);
#line 4771
    ql_dbg(524288U, base_vha, 45157, "Failed to read drv-lockid, retyring=%d\n", (int )retry);
#line 4773
    goto retry_unlock;
  } else {

  }
#line 4776
  return;
#line 4779
  retry = 0U;
  retry_unlock2: 
#line 4781
  tmp___0 = qla83xx_access_control(base_vha, (int )options, 0U, 0U, (uint16_t *)0U);
#line 4781
  if (tmp___0 != 0) {
#line 4782
    if ((unsigned int )retry <= 9U) {
#line 4784
      qla83xx_wait_logic();
#line 4785
      retry = (uint16_t )((int )retry + 1);
#line 4786
      ql_dbg(524288U, base_vha, 45158, "Failed to release IDC lock, retyring=%d\n",
             (int )retry);
#line 4788
      goto retry_unlock2;
    } else {

    }
  } else {

  }
#line 4792
  return;
}
}
#line 4796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int __qla83xx_set_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;

  {
#line 4798
  rval = 0;
#line 4799
  ha = vha->hw;
#line 4802
  rval = qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4803
  if (rval == 0) {
#line 4804
    drv_presence = (uint32_t )(1 << (int )ha->portnum) | drv_presence;
#line 4805
    rval = qla83xx_wr_reg(vha, 571483016U, drv_presence);
  } else {

  }
#line 4809
  return (rval);
}
}
#line 4813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla83xx_set_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 4815
  rval = 0;
#line 4817
  qla83xx_idc_lock(vha, 0);
#line 4818
  rval = __qla83xx_set_drv_presence(vha);
#line 4819
  qla83xx_idc_unlock(vha, 0);
#line 4821
  return (rval);
}
}
#line 4825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int __qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;

  {
#line 4827
  rval = 0;
#line 4828
  ha = vha->hw;
#line 4831
  rval = qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4832
  if (rval == 0) {
#line 4833
    drv_presence = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_presence;
#line 4834
    rval = qla83xx_wr_reg(vha, 571483016U, drv_presence);
  } else {

  }
#line 4838
  return (rval);
}
}
#line 4842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla83xx_clear_drv_presence(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 4844
  rval = 0;
#line 4846
  qla83xx_idc_lock(vha, 0);
#line 4847
  rval = __qla83xx_clear_drv_presence(vha);
#line 4848
  qla83xx_idc_unlock(vha, 0);
#line 4850
  return (rval);
}
}
#line 4854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla83xx_need_reset_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;
  uint32_t drv_presence ;
  unsigned long ack_timeout ;

  {
#line 4856
  ha = vha->hw;
#line 4861
  ack_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
  ldv_62361: 
#line 4863
  qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4864
  qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4865
  if ((drv_ack & drv_presence) == drv_presence) {
#line 4866
    goto ldv_62354;
  } else {

  }
#line 4868
  if ((long )((unsigned long )jiffies - ack_timeout) >= 0L) {
#line 4869
    ql_log(1U, vha, 45159, "RESET ACK TIMEOUT! drv_presence=0x%x drv_ack=0x%x\n",
           drv_presence, drv_ack);
#line 4877
    if (drv_ack != drv_presence) {
#line 4878
      qla83xx_wr_reg(vha, 571483016U, drv_ack);
    } else {

    }
#line 4880
    goto ldv_62354;
  } else {

  }
#line 4883
  qla83xx_idc_unlock(vha, 0);
#line 4884
  msleep(1000U);
#line 4885
  qla83xx_idc_lock(vha, 0);
#line 4886
  goto ldv_62361;
  ldv_62354: 
#line 4888
  qla83xx_wr_reg(vha, 571483012U, 1U);
#line 4889
  ql_log(2U, vha, 45160, "HW State: COLD/RE-INIT.\n");
#line 4890
  return;
}
}
#line 4893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla83xx_device_bootstrap(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t idc_control ;

  {
#line 4895
  rval = 0;
#line 4898
  qla83xx_wr_reg(vha, 571483012U, 2U);
#line 4899
  ql_log(2U, vha, 45161, "HW State: INITIALIZING.\n");
#line 4902
  __qla83xx_get_idc_control(vha, & idc_control);
#line 4903
  idc_control = idc_control & 4294967293U;
#line 4904
  __qla83xx_set_idc_control(vha, 0U);
#line 4906
  qla83xx_idc_unlock(vha, 0);
#line 4907
  rval = qla83xx_restart_nic_firmware(vha);
#line 4908
  qla83xx_idc_lock(vha, 0);
#line 4910
  if (rval != 0) {
#line 4911
    ql_log(0U, vha, 45162, "Failed to restart NIC f/w.\n");
#line 4913
    qla83xx_wr_reg(vha, 571483012U, 6U);
#line 4914
    ql_log(2U, vha, 45163, "HW State: FAILED.\n");
  } else {
#line 4916
    ql_dbg(524288U, vha, 45164, "Success in restarting nic f/w.\n");
#line 4918
    qla83xx_wr_reg(vha, 571483012U, 3U);
#line 4919
    ql_log(2U, vha, 45165, "HW State: READY.\n");
  }
#line 4922
  return (rval);
}
}
#line 4927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int qla83xx_idc_state_handler(scsi_qla_host_t *base_vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  unsigned long dev_init_timeout ;
  uint32_t dev_state ;

  {
#line 4929
  ha = base_vha->hw;
#line 4930
  rval = 0;
#line 4935
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
  ldv_62391: ;
#line 4939
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 4940
    ql_log(1U, base_vha, 45166, "Initialization TIMEOUT!\n");
#line 4945
    qla83xx_wr_reg(base_vha, 571483012U, 6U);
#line 4947
    ql_log(2U, base_vha, 45167, "HW State: FAILED.\n");
  } else {

  }
#line 4951
  qla83xx_rd_reg(base_vha, 571483012U, & dev_state);
#line 4952
  switch (dev_state) {
  case 3U: ;
#line 4954
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4955
    qla83xx_idc_audit(base_vha, 1);
  } else {

  }
#line 4957
  ha->flags.nic_core_reset_owner = 0U;
#line 4958
  ql_dbg(524288U, base_vha, 45168, "Reset_owner reset by 0x%x.\n", (int )ha->portnum);
#line 4961
  goto exit;
  case 1U: ;
#line 4963
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4964
    rval = qla83xx_device_bootstrap(base_vha);
  } else {
#line 4967
    qla83xx_idc_unlock(base_vha, 0);
#line 4968
    msleep(1000U);
#line 4969
    qla83xx_idc_lock(base_vha, 0);
  }
#line 4971
  goto ldv_62383;
  case 2U: 
#line 4974
  qla83xx_idc_unlock(base_vha, 0);
#line 4975
  msleep(1000U);
#line 4976
  qla83xx_idc_lock(base_vha, 0);
#line 4977
  goto ldv_62383;
  case 4U: ;
#line 4979
  if (ql2xdontresethba == 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 4980
    qla83xx_need_reset_handler(base_vha);
  } else {
#line 4983
    qla83xx_idc_unlock(base_vha, 0);
#line 4984
    msleep(1000U);
#line 4985
    qla83xx_idc_lock(base_vha, 0);
  }
#line 4988
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 4990
  goto ldv_62383;
  case 5U: 
#line 4993
  qla83xx_idc_unlock(base_vha, 0);
#line 4994
  msleep(1000U);
#line 4995
  qla83xx_idc_lock(base_vha, 0);
#line 4996
  goto ldv_62383;
  case 7U: ;
#line 4999
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5000
    goto exit;
  } else {

  }
#line 5002
  qla83xx_idc_unlock(base_vha, 0);
#line 5003
  msleep(1000U);
#line 5004
  qla83xx_idc_lock(base_vha, 0);
#line 5005
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 5007
  goto ldv_62383;
  case 6U: ;
#line 5009
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5010
    qla83xx_idc_audit(base_vha, 1);
  } else {

  }
#line 5012
  ha->flags.nic_core_reset_owner = 0U;
#line 5013
  __qla83xx_clear_drv_presence(base_vha);
#line 5014
  qla83xx_idc_unlock(base_vha, 0);
#line 5015
  qla8xxx_dev_failed_handler(base_vha);
#line 5016
  rval = 258;
#line 5017
  qla83xx_idc_lock(base_vha, 0);
#line 5018
  goto exit;
  case 3134241488U: 
#line 5020
  qla83xx_idc_unlock(base_vha, 0);
#line 5021
  msleep(1000U);
#line 5022
  qla83xx_idc_lock(base_vha, 0);
#line 5023
  goto ldv_62383;
  default: 
#line 5025
  ql_log(1U, base_vha, 45169, "Unknow Device State: %x.\n", dev_state);
#line 5027
  qla83xx_idc_unlock(base_vha, 0);
#line 5028
  qla8xxx_dev_failed_handler(base_vha);
#line 5029
  rval = 258;
#line 5030
  qla83xx_idc_lock(base_vha, 0);
#line 5031
  goto exit;
  }
  ldv_62383: ;
#line 5033
  goto ldv_62391;
  exit: ;
#line 5036
  return (rval);
}
}
#line 5053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_do_dpc(void *data ) 
{ 
  int rval ;
  scsi_qla_host_t *base_vha ;
  struct qla_hw_data *ha ;
  void *tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int ret ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___35 ;
  struct task_struct *tmp___36 ;
  struct task_struct *tmp___37 ;
  struct task_struct *tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  struct task_struct *tmp___41 ;

  {
#line 5059
  ha = (struct qla_hw_data *)data;
#line 5060
  tmp = pci_get_drvdata(ha->pdev);
#line 5060
  base_vha = (scsi_qla_host_t *)tmp;
#line 5062
  tmp___0 = get_current();
#line 5062
  set_user_nice(tmp___0, -20L);
#line 5064
  __ret = 1L;
#line 5064
  switch (8UL) {
  case 1UL: 
#line 5064
  tmp___1 = get_current();
#line 5064
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 5064
  goto ldv_62400;
  case 2UL: 
#line 5064
  tmp___2 = get_current();
#line 5064
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 5064
  goto ldv_62400;
  case 4UL: 
#line 5064
  tmp___3 = get_current();
#line 5064
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 5064
  goto ldv_62400;
  case 8UL: 
#line 5064
  tmp___4 = get_current();
#line 5064
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 5064
  goto ldv_62400;
  default: 
#line 5064
  __xchg_wrong_size();
  }
  ldv_62400: ;
#line 5065
  goto ldv_62407;
  ldv_62419: 
#line 5066
  ql_dbg(67108864U, base_vha, 16384, "DPC handler sleeping.\n");
#line 5069
  schedule();
#line 5070
  tmp___5 = get_current();
#line 5070
  tmp___5->state = 0L;
#line 5072
  if (*((unsigned long *)base_vha + 19UL) == 0UL || *((unsigned long *)ha + 2UL) != 0UL) {
#line 5073
    goto end_loop;
  } else {

  }
#line 5075
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5076
    ql_dbg(67108864U, base_vha, 16387, "eeh_busy=%d.\n", (int )ha->flags.eeh_busy);
#line 5078
    goto end_loop;
  } else {

  }
#line 5081
  ha->dpc_active = 1U;
#line 5083
  ql_dbg(67141632U, base_vha, 16385, "DPC handler waking up, dpc_flags=0x%lx.\n",
         base_vha->dpc_flags);
#line 5087
  qla2x00_do_work(base_vha);
#line 5089
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 5090
    if ((ha->device_type & 262144U) != 0U) {
#line 5091
      tmp___6 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5091
      if (tmp___6 != 0) {
#line 5093
        qla8044_idc_lock(ha);
#line 5094
        qla8044_wr_direct(base_vha, 4U, 6U);
#line 5097
        qla8044_idc_unlock(ha);
#line 5098
        ql_log(2U, base_vha, 16388, "HW State: FAILED.\n");
#line 5100
        qla8044_device_state_handler(base_vha);
#line 5101
        goto ldv_62407;
      } else {

      }
    } else {
#line 5105
      tmp___7 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5105
      if (tmp___7 != 0) {
#line 5107
        qla82xx_idc_lock(ha);
#line 5108
        qla82xx_wr_32(ha, 136323392UL, 6U);
#line 5110
        qla82xx_idc_unlock(ha);
#line 5111
        ql_log(2U, base_vha, 337, "HW State: FAILED.\n");
#line 5113
        qla82xx_device_state_handler(base_vha);
#line 5114
        goto ldv_62407;
      } else {

      }
    }
#line 5118
    tmp___10 = test_and_clear_bit(18L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5118
    if (tmp___10 != 0) {
#line 5121
      ql_dbg(67108864U, base_vha, 16389, "FCoE context reset scheduled.\n");
#line 5123
      tmp___9 = test_and_set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5123
      if (tmp___9 == 0) {
#line 5125
        tmp___8 = qla82xx_fcoe_ctx_reset(base_vha);
#line 5125
        if (tmp___8 != 0) {
#line 5129
          set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
        } else {

        }
#line 5132
        clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
      } else {

      }
#line 5136
      ql_dbg(67108864U, base_vha, 16390, "FCoE context reset end.\n");
    } else {

    }
  } else
#line 5139
  if ((ha->device_type & 131072U) != 0U) {
#line 5140
    tmp___13 = test_and_clear_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5140
    if (tmp___13 != 0) {
#line 5142
      ql_dbg(67108864U, base_vha, 16416, "Firmware Reset Recovery\n");
#line 5144
      tmp___12 = qlafx00_reset_initialize(base_vha);
#line 5144
      if (tmp___12 != 0) {
#line 5146
        tmp___11 = constant_test_bit(15L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5146
        if (tmp___11 == 0) {
#line 5148
          set_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
        } else {

        }
#line 5150
        ql_dbg(67108864U, base_vha, 16417, "Reset Recovery Failed\n");
      } else {

      }
    } else {

    }
#line 5156
    tmp___16 = test_and_clear_bit(26L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5156
    if (tmp___16 != 0) {
#line 5158
      ql_dbg(67108864U, base_vha, 16418, "ISPFx00 Target Scan scheduled\n");
#line 5160
      tmp___15 = qlafx00_rescan_isp(base_vha);
#line 5160
      if (tmp___15 != 0) {
#line 5161
        tmp___14 = constant_test_bit(15L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5161
        if (tmp___14 == 0) {
#line 5163
          set_bit(17L, (unsigned long volatile   *)(& base_vha->dpc_flags));
        } else {

        }
#line 5165
        ql_dbg(67108864U, base_vha, 16414, "ISPFx00 Target Scan Failed\n");
      } else {

      }
#line 5168
      ql_dbg(67108864U, base_vha, 16415, "ISPFx00 Target Scan End\n");
    } else {

    }
  } else {

  }
#line 5173
  tmp___19 = test_and_clear_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5173
  if (tmp___19 != 0) {
#line 5176
    ql_dbg(67108864U, base_vha, 16391, "ISP abort scheduled.\n");
#line 5178
    tmp___18 = test_and_set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5178
    if (tmp___18 == 0) {
#line 5181
      tmp___17 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 5181
      if (tmp___17 != 0) {
#line 5183
        set_bit(2L, (unsigned long volatile   *)(& base_vha->dpc_flags));
      } else {

      }
#line 5186
      clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
    } else {

    }
#line 5190
    ql_dbg(67108864U, base_vha, 16392, "ISP abort end.\n");
  } else {

  }
#line 5194
  tmp___20 = test_and_clear_bit(13L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5194
  if (tmp___20 != 0) {
#line 5196
    qla2x00_update_fcports(base_vha);
  } else {

  }
#line 5199
  tmp___21 = constant_test_bit(21L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5199
  if (tmp___21 != 0) {
#line 5201
    ret = qla2x00_send_change_request(base_vha, 3, 0);
#line 5202
    if (ret != 0) {
#line 5203
      ql_log(1U, base_vha, 289, "Failed to enable receiving of RSCN requests: 0x%x.\n",
             ret);
    } else {

    }
#line 5206
    clear_bit(21L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  } else {

  }
#line 5209
  if ((ha->device_type & 131072U) != 0U) {
#line 5210
    goto loop_resync_check;
  } else {

  }
#line 5212
  tmp___22 = constant_test_bit(20L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5212
  if (tmp___22 != 0) {
#line 5213
    ql_dbg(67108864U, base_vha, 16393, "Quiescence mode scheduled.\n");
#line 5215
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 5216
      if ((ha->device_type & 16384U) != 0U) {
#line 5217
        qla82xx_device_state_handler(base_vha);
      } else {

      }
#line 5218
      if ((ha->device_type & 262144U) != 0U) {
#line 5219
        qla8044_device_state_handler(base_vha);
      } else {

      }
#line 5220
      clear_bit(20L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5222
      if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 5223
        qla2x00_perform_loop_resync(base_vha);
#line 5224
        if ((ha->device_type & 16384U) != 0U) {
#line 5225
          qla82xx_idc_lock(ha);
#line 5226
          qla82xx_clear_qsnt_ready(base_vha);
#line 5228
          qla82xx_idc_unlock(ha);
        } else
#line 5229
        if ((ha->device_type & 262144U) != 0U) {
#line 5230
          qla8044_idc_lock(ha);
#line 5231
          qla8044_clear_qsnt_ready(base_vha);
#line 5233
          qla8044_idc_unlock(ha);
        } else {

        }
      } else {

      }
    } else {
#line 5237
      clear_bit(20L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5239
      qla2x00_quiesce_io(base_vha);
    }
#line 5241
    ql_dbg(67108864U, base_vha, 16394, "Quiescence mode end.\n");
  } else {

  }
#line 5245
  tmp___23 = test_and_clear_bit(0L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5245
  if (tmp___23 != 0) {
#line 5245
    tmp___24 = test_and_set_bit(1L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5245
    if (tmp___24 == 0) {
#line 5249
      ql_dbg(67108864U, base_vha, 16395, "Reset marker scheduled.\n");
#line 5251
      qla2x00_rst_aen(base_vha);
#line 5252
      clear_bit(1L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5253
      ql_dbg(67108864U, base_vha, 16396, "Reset marker end.\n");
    } else {

    }
  } else {

  }
#line 5258
  tmp___25 = test_and_clear_bit(8L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5258
  if (tmp___25 != 0) {
#line 5258
    tmp___26 = constant_test_bit(4L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5258
    if (tmp___26 == 0) {
#line 5258
      tmp___27 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 5258
      if (tmp___27 != 2) {
#line 5263
        ql_dbg(67108864U, base_vha, 16397, "Relogin scheduled.\n");
#line 5265
        qla2x00_relogin(base_vha);
#line 5266
        ql_dbg(67108864U, base_vha, 16398, "Relogin end.\n");
      } else {

      }
    } else {

    }
  } else {

  }
  loop_resync_check: 
#line 5270
  tmp___29 = test_and_clear_bit(4L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5270
  if (tmp___29 != 0) {
#line 5273
    ql_dbg(67108864U, base_vha, 16399, "Loop resync scheduled.\n");
#line 5276
    tmp___28 = test_and_set_bit(5L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5276
    if (tmp___28 == 0) {
#line 5279
      rval = qla2x00_loop_resync(base_vha);
#line 5281
      clear_bit(5L, (unsigned long volatile   *)(& base_vha->dpc_flags));
    } else {

    }
#line 5285
    ql_dbg(67108864U, base_vha, 16400, "Loop resync end.\n");
  } else {

  }
#line 5289
  if ((ha->device_type & 131072U) != 0U) {
#line 5290
    goto intr_on_check;
  } else {

  }
#line 5292
  tmp___30 = constant_test_bit(16L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 5292
  if (tmp___30 != 0) {
#line 5292
    tmp___31 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 5292
    if (tmp___31 == 5) {
#line 5294
      clear_bit(16L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5295
      qla2xxx_flash_npiv_conf(base_vha);
    } else {

    }
  } else {

  }
#line 5298
  tmp___32 = test_and_clear_bit(22L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5298
  if (tmp___32 != 0) {
#line 5301
    clear_bit(23L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5303
    qla2x00_host_ramp_down_queuedepth(base_vha);
  } else {

  }
#line 5306
  tmp___33 = test_and_clear_bit(23L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5306
  if (tmp___33 != 0) {
#line 5308
    qla2x00_host_ramp_up_queuedepth(base_vha);
  } else {

  }
  intr_on_check: ;
#line 5310
  if ((unsigned int )ha->interrupts_on == 0U) {
#line 5311
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 5313
  tmp___34 = test_and_clear_bit(11L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5313
  if (tmp___34 != 0) {
#line 5315
    (*((ha->isp_ops)->beacon_blink))(base_vha);
  } else {

  }
#line 5317
  if ((ha->device_type & 131072U) == 0U) {
#line 5318
    qla2x00_do_dpc_all_vps(base_vha);
  } else {

  }
#line 5320
  ha->dpc_active = 0U;
  end_loop: 
#line 5322
  __ret___0 = 1L;
#line 5322
  switch (8UL) {
  case 1UL: 
#line 5322
  tmp___35 = get_current();
#line 5322
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___35->state): : "memory",
                       "cc");
#line 5322
  goto ldv_62413;
  case 2UL: 
#line 5322
  tmp___36 = get_current();
#line 5322
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___36->state): : "memory",
                       "cc");
#line 5322
  goto ldv_62413;
  case 4UL: 
#line 5322
  tmp___37 = get_current();
#line 5322
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___37->state): : "memory",
                       "cc");
#line 5322
  goto ldv_62413;
  case 8UL: 
#line 5322
  tmp___38 = get_current();
#line 5322
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___38->state): : "memory",
                       "cc");
#line 5322
  goto ldv_62413;
  default: 
#line 5322
  __xchg_wrong_size();
  }
  ldv_62413: ;
  ldv_62407: 
#line 5065
  tmp___39 = kthread_should_stop();
#line 5065
  if (tmp___39) {
#line 5065
    tmp___40 = 0;
  } else {
#line 5065
    tmp___40 = 1;
  }
#line 5065
  if (tmp___40) {
#line 5067
    goto ldv_62419;
  } else {

  }
#line 5324
  tmp___41 = get_current();
#line 5324
  tmp___41->state = 0L;
#line 5326
  ql_dbg(67108864U, base_vha, 16401, "DPC handler exiting.\n");
#line 5332
  ha->dpc_active = 0U;
#line 5335
  qla2x00_abort_all_cmds(base_vha, 65536);
#line 5337
  return (0);
}
}
#line 5341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2xxx_wake_dpc(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct task_struct *t ;
  int tmp ;

  {
#line 5343
  ha = vha->hw;
#line 5344
  t = ha->dpc_thread;
#line 5346
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5346
  if (tmp == 0 && (unsigned long )t != (unsigned long )((struct task_struct *)0)) {
#line 5347
    wake_up_process(t);
  } else {

  }
#line 5348
  return;
}
}
#line 5358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_rst_aen(scsi_qla_host_t *vha ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5360
  if (*((unsigned long *)vha + 19UL) != 0UL && *((unsigned long *)vha + 19UL) == 0UL) {
#line 5360
    tmp___1 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5360
    if (tmp___1 == 0) {
#line 5360
      tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5360
      if (tmp___2 == 0) {
        ldv_62429: 
#line 5364
        clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5370
        vha->marker_needed = 1U;
#line 5372
        tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5372
        if (tmp == 0) {
#line 5372
          tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5372
          if (tmp___0 != 0) {
#line 5373
            goto ldv_62429;
          } else {
#line 5376
            goto ldv_62430;
          }
        } else {

        }
        ldv_62430: ;
      } else {

      }
    } else {

    }
  } else {

  }
#line 5379
  return;
}
}
#line 5385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void qla2x00_timer(scsi_qla_host_t *vha ) 
{ 
  unsigned long cpu_flags ;
  int start_dpc ;
  int index ;
  srb_t *sp ;
  uint16_t w ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  fc_port_t *sfcp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 5387
  cpu_flags = 0UL;
#line 5388
  start_dpc = 0;
#line 5392
  ha = vha->hw;
#line 5395
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5396
    ql_dbg(16777216U, vha, 24576, "EEH = %d, restarting timer.\n", (int )ha->flags.eeh_busy);
#line 5399
    qla2x00_restart_timer(vha, 1UL);
#line 5400
    return;
  } else {

  }
#line 5404
  tmp = pci_channel_offline(ha->pdev);
#line 5404
  if (tmp == 0) {
#line 5405
    pci_read_config_word((struct pci_dev  const  *)ha->pdev, 0, & w);
  } else {

  }
#line 5408
  if ((unsigned int )vha->vp_idx == 0U && ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U)) {
#line 5409
    tmp___0 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5409
    if (tmp___0 != 0) {
#line 5410
      start_dpc = start_dpc + 1;
    } else {

    }
#line 5411
    if ((ha->device_type & 16384U) != 0U) {
#line 5412
      qla82xx_watchdog(vha);
    } else
#line 5413
    if ((ha->device_type & 262144U) != 0U) {
#line 5414
      qla8044_watchdog(vha);
    } else {

    }
  } else {

  }
#line 5417
  if ((unsigned int )vha->vp_idx == 0U && (ha->device_type & 131072U) != 0U) {
#line 5418
    qlafx00_timer_routine(vha);
  } else {

  }
#line 5421
  tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5421
  if (tmp___5 > 0) {
#line 5421
    tmp___6 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5421
    if (tmp___6 == 0) {
#line 5421
      tmp___7 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5421
      if (tmp___7 == 0) {
#line 5421
        if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 5426
          tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5426
          if (tmp___2 == (int )vha->loop_down_abort_time) {
#line 5429
            ql_log(2U, vha, 24584, "Loop down - aborting the queues before time expires.\n");
#line 5432
            if ((ha->device_type & 1U) == 0U && (unsigned int )vha->link_down_timeout != 0U) {
#line 5433
              atomic_set(& vha->loop_state, 6);
            } else {

            }
#line 5440
            if ((unsigned int )vha->vp_idx == 0U) {
#line 5441
              tmp___1 = spinlock_check(& ha->hardware_lock);
#line 5441
              cpu_flags = _raw_spin_lock_irqsave(tmp___1);
#line 5443
              req = *(ha->req_q_map);
#line 5444
              index = 1;
#line 5444
              goto ldv_62448;
              ldv_62447: 
#line 5449
              sp = *(req->outstanding_cmds + (unsigned long )index);
#line 5450
              if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 5451
                goto ldv_62445;
              } else {

              }
#line 5452
              if ((unsigned int )sp->type != 8U) {
#line 5453
                goto ldv_62445;
              } else {

              }
#line 5454
              sfcp = sp->fcport;
#line 5455
              if ((sfcp->flags & 4U) == 0U) {
#line 5456
                goto ldv_62445;
              } else {

              }
#line 5458
              if ((ha->device_type & 16384U) != 0U) {
#line 5459
                set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
              } else {
#line 5462
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
              }
#line 5464
              goto ldv_62446;
              ldv_62445: 
#line 5446
              index = index + 1;
              ldv_62448: ;
#line 5444
              if ((int )req->num_outstanding_cmds > index) {
#line 5447
                goto ldv_62447;
              } else {

              }
              ldv_62446: 
#line 5466
              spin_unlock_irqrestore(& ha->hardware_lock, cpu_flags);
            } else {

            }
#line 5469
            start_dpc = start_dpc + 1;
          } else {

          }
#line 5473
          tmp___3 = atomic_dec_and_test(& vha->loop_down_timer);
#line 5473
          if (tmp___3 != 0) {
#line 5474
            if ((vha->device_flags & 2U) == 0U) {
#line 5475
              ql_log(1U, vha, 24585, "Loop down - aborting ISP.\n");
#line 5478
              if ((ha->device_type & 16384U) != 0U) {
#line 5479
                set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
              } else {
#line 5482
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
              }
            } else {

            }
          } else {

          }
#line 5486
          tmp___4 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 5486
          ql_dbg(16777216U, vha, 24586, "Loop down - seconds remaining %d.\n", tmp___4);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 5492
  if ((unsigned int )vha->vp_idx == 0U && (unsigned int )ha->beacon_blink_led == 1U) {
#line 5494
    if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 5495
      set_bit(11L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5496
      start_dpc = start_dpc + 1;
    } else {

    }
  } else {

  }
#line 5501
  tmp___8 = list_empty((struct list_head  const  *)(& vha->work_list));
#line 5501
  if (tmp___8 == 0) {
#line 5502
    start_dpc = start_dpc + 1;
  } else {

  }
#line 5505
  tmp___20 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
  if (tmp___20 != 0) {
#line 5505
    goto _L;
  } else {
#line 5505
    tmp___21 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
    if (tmp___21 != 0) {
#line 5505
      goto _L;
    } else {
#line 5505
      tmp___22 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
      if (tmp___22 != 0) {
#line 5505
        goto _L;
      } else
#line 5505
      if (start_dpc != 0) {
#line 5505
        goto _L;
      } else {
#line 5505
        tmp___23 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
        if (tmp___23 != 0) {
#line 5505
          goto _L;
        } else {
#line 5505
          tmp___24 = constant_test_bit(11L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
          if (tmp___24 != 0) {
#line 5505
            goto _L;
          } else {
#line 5505
            tmp___25 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
            if (tmp___25 != 0) {
#line 5505
              goto _L;
            } else {
#line 5505
              tmp___26 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
              if (tmp___26 != 0) {
#line 5505
                goto _L;
              } else {
#line 5505
                tmp___27 = constant_test_bit(14L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
                if (tmp___27 != 0) {
#line 5505
                  goto _L;
                } else {
#line 5505
                  tmp___28 = constant_test_bit(8L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
                  if (tmp___28 != 0) {
#line 5505
                    goto _L;
                  } else {
#line 5505
                    tmp___29 = constant_test_bit(22L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
                    if (tmp___29 != 0) {
#line 5505
                      goto _L;
                    } else {
#line 5505
                      tmp___30 = constant_test_bit(23L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5505
                      if (tmp___30 != 0) {
                        _L: /* CIL Label */ 
#line 5517
                        tmp___9 = constant_test_bit(0L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5517
                        tmp___10 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5517
                        tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5517
                        tmp___12 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5517
                        ql_dbg(16777216U, vha, 24587, "isp_abort_needed=%d loop_resync_needed=%d fcport_update_needed=%d start_dpc=%d reset_marker_needed=%d",
                               tmp___12, tmp___11, tmp___10, start_dpc, tmp___9);
#line 5526
                        tmp___13 = constant_test_bit(22L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___14 = constant_test_bit(23L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___15 = constant_test_bit(8L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___16 = constant_test_bit(14L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___17 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___18 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        tmp___19 = constant_test_bit(11L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 5526
                        ql_dbg(16777216U, vha, 24588, "beacon_blink_needed=%d isp_unrecoverable=%d fcoe_ctx_reset_needed=%d vp_dpc_needed=%d relogin_needed=%d, host_ramp_down_needed=%d host_ramp_up_needed=%d.\n",
                               tmp___19, tmp___18, tmp___17, tmp___16, tmp___15, tmp___14,
                               tmp___13);
#line 5538
                        qla2xxx_wake_dpc(vha);
                      } else {

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 5541
  qla2x00_restart_timer(vha, 1UL);
#line 5542
  return;
}
}
#line 5569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct mutex qla_fw_lock  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_fw_lock.wait_lock",
                                                           0, 0UL}}}}, {& qla_fw_lock.wait_list,
                                                                        & qla_fw_lock.wait_list},
    0, 0, (void *)(& qla_fw_lock), {0, {0, 0}, "qla_fw_lock", 0, 0UL}};
#line 5571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct fw_blob qla_fw_blobs[10U]  = 
#line 5571
  {      {(char *)"ql2100_fw.bin", {4096U, 0U}, 0}, 
        {(char *)"ql2200_fw.bin", {4096U, 0U}, 0}, 
        {(char *)"ql2300_fw.bin", {2048U, 0U}, 0}, 
        {(char *)"ql2322_fw.bin", {2048U, 114688U, 122880U, 0U}, 0}, 
        {(char *)"ql2400_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql2500_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8100_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8200_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql2600_fw.bin", {0U, 0U, 0U, 0U}, 0}, 
        {(char *)"ql8300_fw.bin", {0U, 0U, 0U, 0U}, 0}};
#line 5585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct fw_blob *qla2x00_request_firmware(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct fw_blob *blob ;
  int tmp ;

  {
#line 5587
  ha = vha->hw;
#line 5590
  if ((int )ha->device_type & 1) {
#line 5591
    blob = (struct fw_blob *)(& qla_fw_blobs);
  } else
#line 5592
  if ((ha->device_type & 2U) != 0U) {
#line 5593
    blob = (struct fw_blob *)(& qla_fw_blobs) + 1UL;
  } else
#line 5594
  if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 5595
    blob = (struct fw_blob *)(& qla_fw_blobs) + 2UL;
  } else
#line 5596
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 5597
    blob = (struct fw_blob *)(& qla_fw_blobs) + 3UL;
  } else
#line 5598
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 5599
    blob = (struct fw_blob *)(& qla_fw_blobs) + 4UL;
  } else
#line 5600
  if ((ha->device_type & 2048U) != 0U) {
#line 5601
    blob = (struct fw_blob *)(& qla_fw_blobs) + 5UL;
  } else
#line 5602
  if ((ha->device_type & 8192U) != 0U) {
#line 5603
    blob = (struct fw_blob *)(& qla_fw_blobs) + 6UL;
  } else
#line 5604
  if ((ha->device_type & 16384U) != 0U) {
#line 5605
    blob = (struct fw_blob *)(& qla_fw_blobs) + 7UL;
  } else
#line 5606
  if ((ha->device_type & 32768U) != 0U) {
#line 5607
    blob = (struct fw_blob *)(& qla_fw_blobs) + 8UL;
  } else
#line 5608
  if ((ha->device_type & 65536U) != 0U) {
#line 5609
    blob = (struct fw_blob *)(& qla_fw_blobs) + 9UL;
  } else {
#line 5611
    return ((struct fw_blob *)0);
  }
#line 5614
  mutex_lock_nested(& qla_fw_lock, 0U);
#line 5615
  if ((unsigned long )blob->fw != (unsigned long )((struct firmware  const  *)0)) {
#line 5616
    goto out;
  } else {

  }
#line 5618
  tmp = request_firmware(& blob->fw, (char const   *)blob->name, & (ha->pdev)->dev);
#line 5618
  if (tmp != 0) {
#line 5619
    ql_log(1U, vha, 99, "Failed to load firmware image (%s).\n", blob->name);
#line 5621
    blob->fw = (struct firmware  const  *)0;
#line 5622
    blob = (struct fw_blob *)0;
#line 5623
    goto out;
  } else {

  }
  out: 
#line 5627
  mutex_unlock(& qla_fw_lock);
#line 5628
  return (blob);
}
}
#line 5632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_release_firmware(void) 
{ 
  int idx ;

  {
#line 5636
  mutex_lock_nested(& qla_fw_lock, 0U);
#line 5637
  idx = 0;
#line 5637
  goto ldv_62463;
  ldv_62462: 
#line 5638
  release_firmware(qla_fw_blobs[idx].fw);
#line 5637
  idx = idx + 1;
  ldv_62463: ;
#line 5637
  if (idx <= 9) {
#line 5639
    goto ldv_62462;
  } else {

  }
#line 5639
  mutex_unlock(& qla_fw_lock);
#line 5640
  return;
}
}
#line 5643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static pci_ers_result_t qla2xxx_pci_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;

  {
#line 5645
  tmp = pci_get_drvdata(pdev);
#line 5645
  vha = (scsi_qla_host_t *)tmp;
#line 5646
  ha = vha->hw;
#line 5648
  ql_dbg(2097152U, vha, 36864, "PCI error detected, state %x.\n", state);
#line 5651
  switch (state) {
  case 1U: 
#line 5653
  ha->flags.eeh_busy = 0U;
#line 5654
  return (2U);
  case 2U: 
#line 5656
  ha->flags.eeh_busy = 1U;
#line 5658
  if ((ha->device_type & 16384U) != 0U) {
#line 5659
    ha->flags.isp82xx_fw_hung = 1U;
#line 5660
    ql_dbg(2097152U, vha, 36865, "Pci channel io frozen\n");
#line 5661
    qla82xx_clear_pending_mbx(vha);
  } else {

  }
#line 5663
  qla2x00_free_irqs(vha);
#line 5664
  pci_disable_device(pdev);
#line 5666
  qla2x00_abort_all_cmds(vha, 524288);
#line 5667
  return (3U);
  case 3U: 
#line 5669
  ha->flags.pci_channel_io_perm_failure = 1U;
#line 5670
  qla2x00_abort_all_cmds(vha, 65536);
#line 5671
  return (4U);
  }
#line 5673
  return (3U);
}
}
#line 5677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static pci_ers_result_t qla2xxx_pci_mmio_enabled(struct pci_dev *pdev ) 
{ 
  int risc_paused ;
  uint32_t stat ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  raw_spinlock_t *tmp___0 ;

  {
#line 5679
  risc_paused = 0;
#line 5682
  tmp = pci_get_drvdata(pdev);
#line 5682
  base_vha = (scsi_qla_host_t *)tmp;
#line 5683
  ha = base_vha->hw;
#line 5684
  reg = & (ha->iobase)->isp;
#line 5685
  reg24 = & (ha->iobase)->isp24;
#line 5687
  if ((ha->device_type & 16384U) != 0U) {
#line 5688
    return (5U);
  } else {

  }
#line 5690
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5690
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 5691
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 5692
    stat = readl((void const volatile   *)(& reg->hccr));
#line 5693
    if ((stat & 32U) != 0U) {
#line 5694
      risc_paused = 1;
    } else {

    }
  } else
#line 5695
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 5696
    stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 5697
    if ((stat & 256U) != 0U) {
#line 5698
      risc_paused = 1;
    } else {

    }
  } else
#line 5699
  if ((ha->device_type & 134217728U) != 0U) {
#line 5700
    stat = readl((void const volatile   *)(& reg24->host_status));
#line 5701
    if ((stat & 256U) != 0U) {
#line 5702
      risc_paused = 1;
    } else {

    }
  } else {

  }
#line 5704
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5706
  if (risc_paused != 0) {
#line 5707
    ql_log(2U, base_vha, 36867, "RISC paused -- mmio_enabled, Dumping firmware.\n");
#line 5709
    (*((ha->isp_ops)->fw_dump))(base_vha, 0);
#line 5711
    return (3U);
  } else {
#line 5713
    return (5U);
  }
}
}
#line 5717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static uint32_t qla82xx_error_recovery(scsi_qla_host_t *base_vha ) 
{ 
  uint32_t rval ;
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int fn ;
  struct pci_dev *other_pdev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5719
  rval = 258U;
#line 5720
  drv_active = 0U;
#line 5721
  ha = base_vha->hw;
#line 5723
  other_pdev = (struct pci_dev *)0;
#line 5725
  ql_dbg(2097152U, base_vha, 36870, "Entered %s.\n", "qla82xx_error_recovery");
#line 5728
  set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5730
  if (*((unsigned long *)base_vha + 19UL) != 0UL) {
#line 5733
    qla2x00_abort_isp_cleanup(base_vha);
  } else {

  }
#line 5737
  fn = (int )(ha->pdev)->devfn & 7;
#line 5738
  goto ldv_62496;
  ldv_62498: 
#line 5739
  fn = fn - 1;
#line 5740
  ql_dbg(2097152U, base_vha, 36871, "Finding pci device at function = 0x%x.\n", fn);
#line 5742
  tmp = pci_domain_nr((ha->pdev)->bus);
#line 5742
  other_pdev = pci_get_domain_bus_and_slot(tmp, (unsigned int )((ha->pdev)->bus)->number,
                                           ((ha->pdev)->devfn & 248U) | ((unsigned int )fn & 7U));
#line 5747
  if ((unsigned long )other_pdev == (unsigned long )((struct pci_dev *)0)) {
#line 5748
    goto ldv_62496;
  } else {

  }
#line 5749
  tmp___0 = atomic_read((atomic_t const   *)(& other_pdev->enable_cnt));
#line 5749
  if (tmp___0 != 0) {
#line 5750
    ql_dbg(2097152U, base_vha, 36872, "Found PCI func available and enable at 0x%x.\n",
           fn);
#line 5753
    pci_dev_put(other_pdev);
#line 5754
    goto ldv_62497;
  } else {

  }
#line 5756
  pci_dev_put(other_pdev);
  ldv_62496: ;
#line 5738
  if (fn > 0) {
#line 5740
    goto ldv_62498;
  } else {

  }
  ldv_62497: ;
#line 5759
  if (fn == 0) {
#line 5761
    ql_dbg(2097152U, base_vha, 36873, "This devfn is reset owner = 0x%x.\n", (ha->pdev)->devfn);
#line 5764
    qla82xx_idc_lock(ha);
#line 5766
    qla82xx_wr_32(ha, 136323392UL, 2U);
#line 5769
    qla82xx_wr_32(ha, 136323444UL, 1U);
#line 5772
    tmp___1 = qla82xx_rd_32(ha, 136323384UL);
#line 5772
    drv_active = (uint32_t )tmp___1;
#line 5773
    ql_dbg(2097152U, base_vha, 36874, "drv_active = 0x%x.\n", drv_active);
#line 5776
    qla82xx_idc_unlock(ha);
#line 5780
    if (drv_active != 0U) {
#line 5781
      tmp___2 = qla82xx_start_firmware(base_vha);
#line 5781
      rval = (uint32_t )tmp___2;
    } else {
#line 5783
      rval = 0U;
    }
#line 5784
    qla82xx_idc_lock(ha);
#line 5786
    if (rval != 0U) {
#line 5787
      ql_log(2U, base_vha, 36875, "HW State: FAILED.\n");
#line 5789
      qla82xx_clear_drv_active(ha);
#line 5790
      qla82xx_wr_32(ha, 136323392UL, 6U);
    } else {
#line 5793
      ql_log(2U, base_vha, 36876, "HW State: READY.\n");
#line 5795
      qla82xx_wr_32(ha, 136323392UL, 3U);
#line 5797
      qla82xx_idc_unlock(ha);
#line 5798
      ha->flags.isp82xx_fw_hung = 0U;
#line 5799
      tmp___3 = qla82xx_restart_isp(base_vha);
#line 5799
      rval = (uint32_t )tmp___3;
#line 5800
      qla82xx_idc_lock(ha);
#line 5802
      qla82xx_wr_32(ha, 136323396UL, 0U);
#line 5803
      qla82xx_set_drv_active(base_vha);
    }
#line 5805
    qla82xx_idc_unlock(ha);
  } else {
#line 5807
    ql_dbg(2097152U, base_vha, 36877, "This devfn is not reset owner = 0x%x.\n", (ha->pdev)->devfn);
#line 5810
    tmp___5 = qla82xx_rd_32(ha, 136323392UL);
#line 5810
    if (tmp___5 == 3) {
#line 5812
      ha->flags.isp82xx_fw_hung = 0U;
#line 5813
      tmp___4 = qla82xx_restart_isp(base_vha);
#line 5813
      rval = (uint32_t )tmp___4;
#line 5814
      qla82xx_idc_lock(ha);
#line 5815
      qla82xx_set_drv_active(base_vha);
#line 5816
      qla82xx_idc_unlock(ha);
    } else {

    }
  }
#line 5819
  clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5821
  return (rval);
}
}
#line 5825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static pci_ers_result_t qla2xxx_pci_slot_reset(struct pci_dev *pdev ) 
{ 
  pci_ers_result_t ret ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  int rc ;
  int retries ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 5827
  ret = 4U;
#line 5828
  tmp = pci_get_drvdata(pdev);
#line 5828
  base_vha = (scsi_qla_host_t *)tmp;
#line 5829
  ha = base_vha->hw;
#line 5831
  retries = 10;
#line 5833
  ql_dbg(2097152U, base_vha, 36868, "Slot Reset.\n");
#line 5840
  pdev->error_state = 1U;
#line 5842
  pci_restore_state(pdev);
#line 5847
  pci_save_state(pdev);
#line 5849
  if (ha->mem_only != 0) {
#line 5850
    rc = pci_enable_device_mem(pdev);
  } else {
#line 5852
    rc = pci_enable_device(pdev);
  }
#line 5854
  if (rc != 0) {
#line 5855
    ql_log(1U, base_vha, 36869, "Can\'t re-enable PCI device after reset.\n");
#line 5857
    goto exit_slot_reset;
  } else {

  }
#line 5860
  rsp = *(ha->rsp_q_map);
#line 5861
  tmp___0 = qla2x00_request_irqs(ha, rsp);
#line 5861
  if (tmp___0 != 0) {
#line 5862
    goto exit_slot_reset;
  } else {

  }
#line 5864
  tmp___1 = (*((ha->isp_ops)->pci_config))(base_vha);
#line 5864
  if (tmp___1 != 0) {
#line 5865
    goto exit_slot_reset;
  } else {

  }
#line 5867
  if ((ha->device_type & 16384U) != 0U) {
#line 5868
    tmp___2 = qla82xx_error_recovery(base_vha);
#line 5868
    if (tmp___2 == 0U) {
#line 5869
      ret = 5U;
#line 5870
      goto exit_slot_reset;
    } else {
#line 5872
      goto exit_slot_reset;
    }
  } else {

  }
#line 5875
  goto ldv_62510;
  ldv_62509: 
#line 5876
  msleep(1000U);
  ldv_62510: ;
#line 5875
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5875
    tmp___3 = retries;
#line 5875
    retries = retries - 1;
#line 5875
    if (tmp___3 != 0) {
#line 5877
      goto ldv_62509;
    } else {
#line 5880
      goto ldv_62511;
    }
  } else {

  }
  ldv_62511: 
#line 5878
  set_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
#line 5879
  tmp___4 = (*((ha->isp_ops)->abort_isp))(base_vha);
#line 5879
  if (tmp___4 == 0) {
#line 5880
    ret = 5U;
  } else {

  }
#line 5881
  clear_bit(3L, (unsigned long volatile   *)(& base_vha->dpc_flags));
  exit_slot_reset: 
#line 5885
  ql_dbg(2097152U, base_vha, 36878, "slot_reset return %x.\n", ret);
#line 5888
  return (ret);
}
}
#line 5892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2xxx_pci_resume(struct pci_dev *pdev ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;

  {
#line 5894
  tmp = pci_get_drvdata(pdev);
#line 5894
  base_vha = (scsi_qla_host_t *)tmp;
#line 5895
  ha = base_vha->hw;
#line 5898
  ql_dbg(2097152U, base_vha, 36879, "pci_resume.\n");
#line 5901
  ret = qla2x00_wait_for_hba_online(base_vha);
#line 5902
  if (ret != 0) {
#line 5903
    ql_log(0U, base_vha, 36866, "The device failed to resume I/O from slot/link_reset.\n");
  } else {

  }
#line 5907
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 5909
  ha->flags.eeh_busy = 0U;
#line 5910
  return;
}
}
#line 5912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct pci_error_handlers  const  qla2xxx_err_handler  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& qla2xxx_pci_error_detected),
    & qla2xxx_pci_mmio_enabled, 0, & qla2xxx_pci_slot_reset, & qla2xxx_pci_resume};
#line 5919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct pci_device_id qla2xxx_pci_tbl[20U]  = 
#line 5919
  {      {4215U, 8448U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8704U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8960U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8978U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8994U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 25362U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 25378U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9250U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9266U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 33842U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 21538U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 21554U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 9522U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 8241U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32769U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32801U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32817U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 61441U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4215U, 32836U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 5941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 5943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct pci_driver qla2xxx_pci_driver  = 
#line 5943
     {{0, 0}, "qla2xxx", (struct pci_device_id  const  *)(& qla2xxx_pci_tbl), & qla2x00_probe_one,
    & qla2x00_remove_one, 0, 0, 0, 0, & qla2x00_shutdown, 0, & qla2xxx_err_handler,
    {0, 0, & __this_module, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}},
                                                                            0U, 0U,
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                         {0, 0}}};
#line 5955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static struct file_operations  const  apidev_fops  = 
#line 5955
     {& __this_module, & noop_llseek, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 5964 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static int qla2x00_module_init(void) 
{ 
  int ret ;

  {
#line 5966
  ret = 0;
#line 5969
  srb_cachep = kmem_cache_create("qla2xxx_srbs", 376UL, 0UL, 8192UL, (void (*)(void * ))0);
#line 5971
  if ((unsigned long )srb_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 5972
    ql_log(0U, (scsi_qla_host_t *)0, 1, "Unable to allocate SRB cache...Failing load!.\n");
#line 5974
    return (-12);
  } else {

  }
#line 5978
  ret = qlt_init();
#line 5979
  if (ret < 0) {
#line 5980
    kmem_cache_destroy(srb_cachep);
#line 5981
    return (ret);
  } else
#line 5982
  if (ret > 0) {
#line 5988
    qla2xxx_transport_functions.disable_target_scan = 1U;
#line 5989
    qla2xxx_transport_vport_functions.disable_target_scan = 1U;
  } else {

  }
#line 5993
  strcpy((char *)(& qla2x00_version_str), "8.06.00.08-k");
#line 5994
  if (ql2xextended_error_logging != 0) {
#line 5995
    strcat((char *)(& qla2x00_version_str), "-debug");
  } else {

  }
#line 5997
  qla2xxx_transport_template = fc_attach_transport(& qla2xxx_transport_functions);
#line 5999
  if ((unsigned long )qla2xxx_transport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 6000
    kmem_cache_destroy(srb_cachep);
#line 6001
    ql_log(0U, (scsi_qla_host_t *)0, 2, "fc_attach_transport failed...Failing load!.\n");
#line 6003
    qlt_exit();
#line 6004
    return (-19);
  } else {

  }
#line 6007
  apidev_major = ldv_register_chrdev_7(0U, "ql2xapidev", & apidev_fops);
#line 6008
  if (apidev_major < 0) {
#line 6009
    ql_log(0U, (scsi_qla_host_t *)0, 3, "Unable to register char device %s.\n", (char *)"ql2xapidev");
  } else {

  }
#line 6013
  qla2xxx_transport_vport_template = fc_attach_transport(& qla2xxx_transport_vport_functions);
#line 6015
  if ((unsigned long )qla2xxx_transport_vport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 6016
    kmem_cache_destroy(srb_cachep);
#line 6017
    qlt_exit();
#line 6018
    fc_release_transport(qla2xxx_transport_template);
#line 6019
    ql_log(0U, (scsi_qla_host_t *)0, 4, "fc_attach_transport vport failed...Failing load!.\n");
#line 6021
    return (-19);
  } else {

  }
#line 6023
  ql_log(2U, (scsi_qla_host_t *)0, 5, "QLogic Fibre Channel HBA Driver: %s.\n", (char *)(& qla2x00_version_str));
#line 6026
  ret = __pci_register_driver(& qla2xxx_pci_driver, & __this_module, "qla2xxx");
#line 6027
  if (ret != 0) {
#line 6028
    kmem_cache_destroy(srb_cachep);
#line 6029
    qlt_exit();
#line 6030
    fc_release_transport(qla2xxx_transport_template);
#line 6031
    fc_release_transport(qla2xxx_transport_vport_template);
#line 6032
    ql_log(0U, (scsi_qla_host_t *)0, 6, "pci_register_driver failed...ret=%d Failing load!.\n",
           ret);
  } else {

  }
#line 6036
  return (ret);
}
}
#line 6043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
static void qla2x00_module_exit(void) 
{ 


  {
#line 6045
  ldv_unregister_chrdev_8((unsigned int )apidev_major, "ql2xapidev");
#line 6046
  pci_unregister_driver(& qla2xxx_pci_driver);
#line 6047
  qla2x00_release_firmware();
#line 6048
  kmem_cache_destroy(srb_cachep);
#line 6049
  qlt_exit();
#line 6050
  if ((unsigned long )ctx_cachep != (unsigned long )((struct kmem_cache *)0)) {
#line 6051
    kmem_cache_destroy(ctx_cachep);
  } else {

  }
#line 6052
  fc_release_transport(qla2xxx_transport_template);
#line 6053
  fc_release_transport(qla2xxx_transport_vport_template);
#line 6054
  return;
}
}
#line 6070
extern int ldv_probe_71(void) ;
#line 6071
extern int ldv_release_62(void) ;
#line 6072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_2  ;
#line 6073
extern int ldv_probe_68(void) ;
#line 6074
extern int ldv_probe_66(void) ;
#line 6075
extern int ldv_probe_62(void) ;
#line 6076
extern int ldv_open_60(void) ;
#line 6077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_1  ;
#line 6078
extern void ldv_initialize(void) ;
#line 6079
extern int ldv_probe_69(void) ;
#line 6080
extern int ldv_release_69(void) ;
#line 6081
extern int ldv_release_64(void) ;
#line 6082
extern int ldv_release_68(void) ;
#line 6083
extern int ldv_release_65(void) ;
#line 6084
extern int ldv_probe_67(void) ;
#line 6085
extern int ldv_release_67(void) ;
#line 6086
extern int ldv_release_66(void) ;
#line 6087
extern int ldv_release_70(void) ;
#line 6088
extern int ldv_probe_65(void) ;
#line 6089
extern int ldv_probe_63(void) ;
#line 6090
extern int ldv_release_71(void) ;
#line 6091
extern int ldv_suspend_62(void) ;
#line 6092
void ldv_check_final_state(void) ;
#line 6093
extern int ldv_release_63(void) ;
#line 6094 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_retval_3  ;
#line 6095
extern int ldv_probe_70(void) ;
#line 6096
extern int ldv_probe_64(void) ;
#line 6097
extern int ldv_release_60(void) ;
#line 6100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 6100
  if ((unsigned long )ldv_timer_list_2 == (unsigned long )timer) {
#line 6101
    if (ldv_timer_state_2 == 2 || pending_flag != 0) {
#line 6102
      ldv_timer_list_2 = timer;
#line 6103
      ldv_timer_list_2->data = data;
#line 6104
      ldv_timer_state_2 = 1;
    } else {

    }
#line 6106
    return;
  } else {

  }
#line 6108
  reg_timer_2(timer);
#line 6109
  ldv_timer_list_2->data = data;
#line 6110
  return;
}
}
#line 6113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void choose_timer_1(struct timer_list *timer ) 
{ 


  {
#line 6114
  LDV_IN_INTERRUPT = 2;
#line 6115
  (*(timer->function))(timer->data);
#line 6116
  LDV_IN_INTERRUPT = 1;
#line 6117
  ldv_timer_state_1 = 2;
#line 6118
  return;
}
}
#line 6121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void choose_timer_2(struct timer_list *timer ) 
{ 


  {
#line 6122
  LDV_IN_INTERRUPT = 2;
#line 6123
  (*(timer->function))(timer->data);
#line 6124
  LDV_IN_INTERRUPT = 1;
#line 6125
  ldv_timer_state_2 = 2;
#line 6126
  return;
}
}
#line 6129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int reg_timer_2(struct timer_list *timer ) 
{ 


  {
#line 6130
  ldv_timer_list_2 = timer;
#line 6131
  ldv_timer_state_2 = 1;
#line 6132
  return (0);
}
}
#line 6135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_65(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6136
  tmp = ldv_zalloc(992UL);
#line 6136
  qla8044_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6137
  tmp___0 = ldv_zalloc(128UL);
#line 6137
  qla8044_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6138
  tmp___1 = ldv_zalloc(12480UL);
#line 6138
  qla8044_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6139
  return;
}
}
#line 6141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_68(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6142
  tmp = ldv_zalloc(992UL);
#line 6142
  qla25xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6143
  tmp___0 = ldv_zalloc(128UL);
#line 6143
  qla25xx_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6144
  tmp___1 = ldv_zalloc(12480UL);
#line 6144
  qla25xx_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6145
  return;
}
}
#line 6147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_70(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6148
  tmp = ldv_zalloc(992UL);
#line 6148
  qla2300_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6149
  tmp___0 = ldv_zalloc(128UL);
#line 6149
  qla2300_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6150
  tmp___1 = ldv_zalloc(12480UL);
#line 6150
  qla2300_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6151
  return;
}
}
#line 6153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_pci_error_handlers_62(void) 
{ 
  void *tmp ;

  {
#line 6154
  tmp = ldv_zalloc(2928UL);
#line 6154
  qla2xxx_err_handler_group0 = (struct pci_dev *)tmp;
#line 6155
  return;
}
}
#line 6157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_scsi_host_template_72(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6158
  tmp = ldv_zalloc(232UL);
#line 6158
  qla2xxx_driver_template_group0 = (struct scsi_cmnd *)tmp;
#line 6159
  tmp___0 = ldv_zalloc(3496UL);
#line 6159
  qla2xxx_driver_template_group1 = (struct Scsi_Host *)tmp___0;
#line 6160
  tmp___1 = ldv_zalloc(3376UL);
#line 6160
  qla2xxx_driver_template_group2 = (struct scsi_device *)tmp___1;
#line 6161
  return;
}
}
#line 6163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_66(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6164
  tmp = ldv_zalloc(992UL);
#line 6164
  qla82xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6165
  tmp___0 = ldv_zalloc(128UL);
#line 6165
  qla82xx_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6166
  tmp___1 = ldv_zalloc(12480UL);
#line 6166
  qla82xx_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6167
  return;
}
}
#line 6169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_63(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6170
  tmp = ldv_zalloc(992UL);
#line 6170
  qlafx00_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6171
  tmp___0 = ldv_zalloc(128UL);
#line 6171
  qlafx00_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6172
  tmp___1 = ldv_zalloc(12480UL);
#line 6172
  qlafx00_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6173
  return;
}
}
#line 6175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_64(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6176
  tmp = ldv_zalloc(992UL);
#line 6176
  qla83xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6177
  tmp___0 = ldv_zalloc(128UL);
#line 6177
  qla83xx_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6178
  tmp___1 = ldv_zalloc(12480UL);
#line 6178
  qla83xx_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6179
  return;
}
}
#line 6181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_71(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6182
  tmp = ldv_zalloc(992UL);
#line 6182
  qla2100_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6183
  tmp___0 = ldv_zalloc(128UL);
#line 6183
  qla2100_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6184
  tmp___1 = ldv_zalloc(12480UL);
#line 6184
  qla2100_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6185
  return;
}
}
#line 6187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_file_operations_60(void) 
{ 
  void *tmp ;

  {
#line 6188
  apidev_fops_group1 = ldv_zalloc(1032UL);
#line 6189
  tmp = ldv_zalloc(360UL);
#line 6189
  apidev_fops_group2 = (struct file *)tmp;
#line 6190
  return;
}
}
#line 6193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int reg_timer_1(struct timer_list *timer ) 
{ 


  {
#line 6194
  ldv_timer_list_1 = timer;
#line 6195
  ldv_timer_state_1 = 1;
#line 6196
  return (0);
}
}
#line 6199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 6200
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_2) {
#line 6201
    ldv_timer_state_2 = 0;
#line 6202
    return;
  } else {

  }
#line 6204
  return;
}
}
#line 6207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_67(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6208
  tmp = ldv_zalloc(992UL);
#line 6208
  qla81xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6209
  tmp___0 = ldv_zalloc(128UL);
#line 6209
  qla81xx_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6210
  tmp___1 = ldv_zalloc(12480UL);
#line 6210
  qla81xx_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6211
  return;
}
}
#line 6213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 6213
  if ((unsigned long )ldv_timer_list_1 == (unsigned long )timer) {
#line 6214
    if (ldv_timer_state_1 == 2 || pending_flag != 0) {
#line 6215
      ldv_timer_list_1 = timer;
#line 6216
      ldv_timer_list_1->data = data;
#line 6217
      ldv_timer_state_1 = 1;
    } else {

    }
#line 6219
    return;
  } else {

  }
#line 6221
  reg_timer_1(timer);
#line 6222
  ldv_timer_list_1->data = data;
#line 6223
  return;
}
}
#line 6226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void disable_suitable_timer_1(struct timer_list *timer ) 
{ 


  {
#line 6227
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_1) {
#line 6228
    ldv_timer_state_1 = 0;
#line 6229
    return;
  } else {

  }
#line 6231
  return;
}
}
#line 6235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_pci_driver_61(void) 
{ 
  void *tmp ;

  {
#line 6236
  tmp = ldv_zalloc(2928UL);
#line 6236
  qla2xxx_pci_driver_group0 = (struct pci_dev *)tmp;
#line 6237
  return;
}
}
#line 6239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_initialize_isp_operations_69(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 6240
  tmp = ldv_zalloc(992UL);
#line 6240
  qla24xx_isp_ops_group0 = (struct scsi_qla_host *)tmp;
#line 6241
  tmp___0 = ldv_zalloc(128UL);
#line 6241
  qla24xx_isp_ops_group1 = (struct fc_port *)tmp___0;
#line 6242
  tmp___1 = ldv_zalloc(12480UL);
#line 6242
  qla24xx_isp_ops_group2 = (struct qla_hw_data *)tmp___1;
#line 6243
  return;
}
}
#line 6260
void ldv_main_exported_18(void) ;
#line 6261
void ldv_main_exported_33(void) ;
#line 6262
void ldv_main_exported_32(void) ;
#line 6263
void ldv_main_exported_21(void) ;
#line 6264
void ldv_main_exported_26(void) ;
#line 6265
void ldv_main_exported_30(void) ;
#line 6266
void ldv_main_exported_44(void) ;
#line 6267
void ldv_main_exported_55(void) ;
#line 6268
void ldv_main_exported_25(void) ;
#line 6269
void ldv_main_exported_27(void) ;
#line 6270
void ldv_main_exported_28(void) ;
#line 6271
void ldv_main_exported_57(void) ;
#line 6272
void ldv_main_exported_40(void) ;
#line 6273
void ldv_main_exported_20(void) ;
#line 6274
void ldv_main_exported_59(void) ;
#line 6275
void ldv_main_exported_49(void) ;
#line 6276
void ldv_main_exported_24(void) ;
#line 6277
void ldv_main_exported_31(void) ;
#line 6278
void ldv_main_exported_35(void) ;
#line 6279
void ldv_main_exported_53(void) ;
#line 6280
void ldv_main_exported_48(void) ;
#line 6281
void ldv_main_exported_22(void) ;
#line 6282
void ldv_main_exported_42(void) ;
#line 6283
void ldv_main_exported_46(void) ;
#line 6284
void ldv_main_exported_23(void) ;
#line 6285
void ldv_main_exported_29(void) ;
#line 6286
void ldv_main_exported_50(void) ;
#line 6287
void ldv_main_exported_39(void) ;
#line 6288
void ldv_main_exported_36(void) ;
#line 6289
void ldv_main_exported_51(void) ;
#line 6290
void ldv_main_exported_58(void) ;
#line 6291
void ldv_main_exported_41(void) ;
#line 6292
void ldv_main_exported_47(void) ;
#line 6293
void ldv_main_exported_38(void) ;
#line 6294
void ldv_main_exported_52(void) ;
#line 6295
void ldv_main_exported_34(void) ;
#line 6296
void ldv_main_exported_56(void) ;
#line 6297
void ldv_main_exported_37(void) ;
#line 6298
void ldv_main_exported_45(void) ;
#line 6299
void ldv_main_exported_19(void) ;
#line 6300
void ldv_main_exported_43(void) ;
#line 6301
void ldv_main_exported_54(void) ;
#line 6305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int main(void) 
{ 
  char *ldvarg18 ;
  void *tmp ;
  uint32_t ldvarg11 ;
  uint8_t *ldvarg32 ;
  void *tmp___0 ;
  uint32_t ldvarg31 ;
  char *ldvarg20 ;
  void *tmp___1 ;
  uint32_t ldvarg7 ;
  uint32_t ldvarg23 ;
  uint32_t ldvarg12 ;
  uint32_t ldvarg8 ;
  uint8_t *ldvarg13 ;
  void *tmp___2 ;
  void *ldvarg29 ;
  void *tmp___3 ;
  uint8_t *ldvarg10 ;
  void *tmp___4 ;
  uint32_t ldvarg9 ;
  uint32_t ldvarg24 ;
  unsigned int ldvarg27 ;
  unsigned int tmp___5 ;
  int ldvarg26 ;
  int tmp___6 ;
  uint32_t ldvarg30 ;
  uint32_t ldvarg6 ;
  uint32_t ldvarg15 ;
  uint32_t ldvarg16 ;
  int ldvarg21 ;
  int tmp___7 ;
  srb_t *ldvarg25 ;
  void *tmp___8 ;
  srb_t *ldvarg14 ;
  void *tmp___9 ;
  uint8_t *ldvarg17 ;
  void *tmp___10 ;
  unsigned int ldvarg22 ;
  unsigned int tmp___11 ;
  void *ldvarg19 ;
  void *tmp___12 ;
  int ldvarg28 ;
  int tmp___13 ;
  uint32_t ldvarg77 ;
  int ldvarg51 ;
  int tmp___14 ;
  uint8_t ldvarg67 ;
  uint8_t *ldvarg43 ;
  void *tmp___15 ;
  uint32_t ldvarg42 ;
  srb_t *ldvarg71 ;
  void *tmp___16 ;
  int ldvarg72 ;
  int tmp___17 ;
  uint32_t ldvarg56 ;
  uint32_t *ldvarg50 ;
  void *tmp___18 ;
  uint8_t ldvarg46 ;
  uint8_t *ldvarg58 ;
  void *tmp___19 ;
  uint32_t ldvarg37 ;
  srb_t *ldvarg53 ;
  void *tmp___20 ;
  unsigned int ldvarg64 ;
  unsigned int tmp___21 ;
  uint16_t *ldvarg44 ;
  void *tmp___22 ;
  uint32_t ldvarg38 ;
  uint16_t ldvarg69 ;
  uint16_t ldvarg48 ;
  uint8_t ldvarg47 ;
  uint32_t ldvarg39 ;
  uint32_t ldvarg41 ;
  uint16_t ldvarg60 ;
  char *ldvarg59 ;
  void *tmp___23 ;
  uint8_t ldvarg49 ;
  char *ldvarg62 ;
  void *tmp___24 ;
  uint32_t ldvarg57 ;
  uint32_t ldvarg65 ;
  uint32_t ldvarg36 ;
  cmd_entry_t *ldvarg55 ;
  void *tmp___25 ;
  uint32_t ldvarg66 ;
  uint8_t *ldvarg40 ;
  void *tmp___26 ;
  uint8_t ldvarg45 ;
  int ldvarg63 ;
  int tmp___27 ;
  unsigned int ldvarg73 ;
  unsigned int tmp___28 ;
  uint8_t ldvarg70 ;
  uint8_t *ldvarg78 ;
  void *tmp___29 ;
  uint8_t ldvarg68 ;
  uint16_t ldvarg54 ;
  void *ldvarg61 ;
  void *tmp___30 ;
  uint32_t ldvarg76 ;
  int ldvarg74 ;
  int tmp___31 ;
  srb_t *ldvarg52 ;
  void *tmp___32 ;
  void *ldvarg75 ;
  void *tmp___33 ;
  int ldvarg88 ;
  int tmp___34 ;
  int ldvarg89 ;
  int tmp___35 ;
  unsigned long ldvarg90 ;
  unsigned long tmp___36 ;
  int ldvarg87 ;
  int tmp___37 ;
  struct pci_device_id *ldvarg109 ;
  void *tmp___38 ;
  int ldvarg131 ;
  int tmp___39 ;
  uint32_t ldvarg134 ;
  uint8_t ldvarg146 ;
  uint32_t ldvarg141 ;
  char *ldvarg136 ;
  void *tmp___40 ;
  uint8_t ldvarg125 ;
  uint16_t ldvarg145 ;
  unsigned int ldvarg140 ;
  unsigned int tmp___41 ;
  uint32_t ldvarg152 ;
  srb_t *ldvarg132 ;
  void *tmp___42 ;
  char *ldvarg138 ;
  void *tmp___43 ;
  uint8_t ldvarg129 ;
  unsigned int ldvarg149 ;
  unsigned int tmp___44 ;
  uint32_t ldvarg142 ;
  void *ldvarg151 ;
  void *tmp___45 ;
  uint8_t *ldvarg154 ;
  void *tmp___46 ;
  void *ldvarg137 ;
  void *tmp___47 ;
  uint32_t ldvarg122 ;
  uint8_t ldvarg144 ;
  uint16_t ldvarg128 ;
  uint8_t ldvarg126 ;
  uint32_t ldvarg123 ;
  uint32_t ldvarg153 ;
  uint8_t *ldvarg135 ;
  void *tmp___48 ;
  srb_t *ldvarg147 ;
  void *tmp___49 ;
  uint8_t ldvarg127 ;
  uint16_t *ldvarg124 ;
  void *tmp___50 ;
  uint32_t ldvarg133 ;
  int ldvarg150 ;
  int tmp___51 ;
  uint8_t ldvarg143 ;
  uint32_t *ldvarg130 ;
  void *tmp___52 ;
  int ldvarg139 ;
  int tmp___53 ;
  int ldvarg148 ;
  int tmp___54 ;
  char *ldvarg178 ;
  void *tmp___55 ;
  int ldvarg181 ;
  int tmp___56 ;
  srb_t *ldvarg174 ;
  void *tmp___57 ;
  uint32_t ldvarg165 ;
  uint8_t ldvarg168 ;
  uint8_t ldvarg188 ;
  uint8_t ldvarg185 ;
  unsigned int ldvarg191 ;
  unsigned int tmp___58 ;
  uint8_t ldvarg167 ;
  uint8_t *ldvarg196 ;
  void *tmp___59 ;
  uint16_t ldvarg170 ;
  srb_t *ldvarg189 ;
  void *tmp___60 ;
  unsigned int ldvarg182 ;
  unsigned int tmp___61 ;
  uint8_t ldvarg169 ;
  uint32_t ldvarg175 ;
  uint32_t ldvarg195 ;
  uint16_t ldvarg187 ;
  uint32_t *ldvarg172 ;
  void *tmp___62 ;
  uint32_t ldvarg184 ;
  uint8_t ldvarg186 ;
  uint8_t *ldvarg177 ;
  void *tmp___63 ;
  int ldvarg190 ;
  int tmp___64 ;
  void *ldvarg193 ;
  void *tmp___65 ;
  uint16_t *ldvarg166 ;
  void *tmp___66 ;
  int ldvarg192 ;
  int tmp___67 ;
  uint32_t ldvarg164 ;
  uint32_t ldvarg183 ;
  uint32_t ldvarg176 ;
  int ldvarg173 ;
  int tmp___68 ;
  uint32_t ldvarg194 ;
  void *ldvarg179 ;
  void *tmp___69 ;
  char *ldvarg180 ;
  void *tmp___70 ;
  uint8_t ldvarg171 ;
  loff_t ldvarg213 ;
  loff_t tmp___71 ;
  int ldvarg212 ;
  int tmp___72 ;
  char *ldvarg242 ;
  void *tmp___73 ;
  uint32_t ldvarg237 ;
  uint32_t ldvarg225 ;
  uint8_t ldvarg247 ;
  uint8_t ldvarg233 ;
  srb_t *ldvarg236 ;
  void *tmp___74 ;
  int ldvarg243 ;
  int tmp___75 ;
  uint32_t *ldvarg234 ;
  void *tmp___76 ;
  unsigned int ldvarg244 ;
  unsigned int tmp___77 ;
  uint16_t *ldvarg228 ;
  void *tmp___78 ;
  uint32_t ldvarg257 ;
  uint32_t ldvarg226 ;
  uint32_t ldvarg221 ;
  uint8_t *ldvarg258 ;
  void *tmp___79 ;
  uint32_t ldvarg222 ;
  void *ldvarg255 ;
  void *tmp___80 ;
  uint16_t ldvarg232 ;
  uint8_t ldvarg230 ;
  char *ldvarg240 ;
  void *tmp___81 ;
  void *ldvarg241 ;
  void *tmp___82 ;
  uint32_t ldvarg246 ;
  uint8_t ldvarg231 ;
  uint32_t ldvarg238 ;
  int ldvarg254 ;
  int tmp___83 ;
  uint8_t *ldvarg224 ;
  void *tmp___84 ;
  uint8_t ldvarg248 ;
  uint32_t ldvarg223 ;
  int ldvarg235 ;
  int tmp___85 ;
  uint32_t ldvarg245 ;
  uint32_t ldvarg256 ;
  int ldvarg252 ;
  int tmp___86 ;
  uint8_t ldvarg229 ;
  uint8_t *ldvarg227 ;
  void *tmp___87 ;
  srb_t *ldvarg251 ;
  void *tmp___88 ;
  uint32_t ldvarg220 ;
  uint8_t ldvarg250 ;
  uint16_t ldvarg249 ;
  uint8_t *ldvarg239 ;
  void *tmp___89 ;
  unsigned int ldvarg253 ;
  unsigned int tmp___90 ;
  enum pci_channel_state ldvarg263 ;
  uint32_t ldvarg290 ;
  void *ldvarg299 ;
  void *tmp___91 ;
  uint32_t *ldvarg278 ;
  void *tmp___92 ;
  void *ldvarg285 ;
  void *tmp___93 ;
  uint32_t ldvarg300 ;
  srb_t *ldvarg295 ;
  void *tmp___94 ;
  int ldvarg296 ;
  int tmp___95 ;
  uint32_t ldvarg281 ;
  uint32_t ldvarg271 ;
  uint8_t *ldvarg302 ;
  void *tmp___96 ;
  char *ldvarg284 ;
  void *tmp___97 ;
  srb_t *ldvarg280 ;
  void *tmp___98 ;
  uint8_t ldvarg274 ;
  uint16_t *ldvarg272 ;
  void *tmp___99 ;
  uint16_t ldvarg293 ;
  uint8_t ldvarg275 ;
  uint8_t ldvarg277 ;
  unsigned int ldvarg288 ;
  unsigned int tmp___100 ;
  uint8_t ldvarg291 ;
  uint32_t ldvarg289 ;
  uint32_t ldvarg282 ;
  uint32_t ldvarg301 ;
  uint32_t ldvarg270 ;
  char *ldvarg286 ;
  void *tmp___101 ;
  int ldvarg287 ;
  int tmp___102 ;
  uint16_t ldvarg276 ;
  unsigned int ldvarg297 ;
  unsigned int tmp___103 ;
  uint8_t *ldvarg283 ;
  void *tmp___104 ;
  int ldvarg279 ;
  int tmp___105 ;
  uint8_t ldvarg273 ;
  uint8_t ldvarg292 ;
  int ldvarg298 ;
  int tmp___106 ;
  uint8_t ldvarg294 ;
  uint16_t ldvarg315 ;
  uint32_t ldvarg308 ;
  uint32_t ldvarg305 ;
  int ldvarg341 ;
  int tmp___107 ;
  uint8_t ldvarg313 ;
  uint8_t *ldvarg307 ;
  void *tmp___108 ;
  uint16_t ldvarg321 ;
  uint16_t ldvarg336 ;
  uint16_t *ldvarg311 ;
  void *tmp___109 ;
  uint32_t ldvarg309 ;
  cmd_entry_t *ldvarg322 ;
  void *tmp___110 ;
  uint8_t *ldvarg310 ;
  void *tmp___111 ;
  unsigned int ldvarg340 ;
  unsigned int tmp___112 ;
  uint32_t ldvarg333 ;
  srb_t *ldvarg338 ;
  void *tmp___113 ;
  uint8_t *ldvarg325 ;
  void *tmp___114 ;
  uint32_t ldvarg303 ;
  uint32_t *ldvarg317 ;
  void *tmp___115 ;
  void *ldvarg342 ;
  void *tmp___116 ;
  uint8_t ldvarg335 ;
  uint32_t ldvarg304 ;
  uint32_t ldvarg343 ;
  uint8_t ldvarg337 ;
  uint32_t ldvarg344 ;
  int ldvarg339 ;
  int tmp___117 ;
  uint8_t ldvarg312 ;
  uint8_t *ldvarg345 ;
  void *tmp___118 ;
  int ldvarg318 ;
  int tmp___119 ;
  char *ldvarg326 ;
  void *tmp___120 ;
  unsigned int ldvarg331 ;
  unsigned int tmp___121 ;
  uint8_t ldvarg334 ;
  uint32_t ldvarg324 ;
  uint32_t ldvarg306 ;
  uint8_t ldvarg314 ;
  srb_t *ldvarg319 ;
  void *tmp___122 ;
  uint32_t ldvarg323 ;
  char *ldvarg329 ;
  void *tmp___123 ;
  uint16_t ldvarg327 ;
  uint32_t ldvarg332 ;
  srb_t *ldvarg320 ;
  void *tmp___124 ;
  void *ldvarg328 ;
  void *tmp___125 ;
  int ldvarg330 ;
  int tmp___126 ;
  uint8_t ldvarg316 ;
  uint32_t ldvarg372 ;
  uint8_t ldvarg357 ;
  void *ldvarg381 ;
  void *tmp___127 ;
  uint32_t ldvarg349 ;
  uint32_t ldvarg352 ;
  int ldvarg380 ;
  int tmp___128 ;
  uint32_t ldvarg363 ;
  int ldvarg369 ;
  int tmp___129 ;
  uint32_t ldvarg383 ;
  srb_t *ldvarg362 ;
  void *tmp___130 ;
  unsigned int ldvarg379 ;
  unsigned int tmp___131 ;
  uint32_t ldvarg348 ;
  uint8_t *ldvarg365 ;
  void *tmp___132 ;
  uint8_t *ldvarg350 ;
  void *tmp___133 ;
  uint32_t ldvarg346 ;
  uint32_t *ldvarg360 ;
  void *tmp___134 ;
  uint32_t ldvarg364 ;
  uint8_t ldvarg376 ;
  srb_t *ldvarg377 ;
  void *tmp___135 ;
  uint8_t ldvarg374 ;
  unsigned int ldvarg370 ;
  unsigned int tmp___136 ;
  int ldvarg361 ;
  int tmp___137 ;
  uint16_t *ldvarg354 ;
  void *tmp___138 ;
  uint16_t ldvarg375 ;
  uint8_t *ldvarg384 ;
  void *tmp___139 ;
  uint16_t ldvarg358 ;
  uint32_t ldvarg351 ;
  void *ldvarg367 ;
  void *tmp___140 ;
  uint32_t ldvarg347 ;
  int ldvarg378 ;
  int tmp___141 ;
  uint32_t ldvarg382 ;
  uint8_t ldvarg359 ;
  char *ldvarg368 ;
  void *tmp___142 ;
  uint8_t *ldvarg353 ;
  void *tmp___143 ;
  uint8_t ldvarg373 ;
  uint32_t ldvarg371 ;
  char *ldvarg366 ;
  void *tmp___144 ;
  uint8_t ldvarg355 ;
  uint8_t ldvarg356 ;
  uint8_t *ldvarg404 ;
  void *tmp___145 ;
  uint8_t *ldvarg435 ;
  void *tmp___146 ;
  srb_t *ldvarg428 ;
  void *tmp___147 ;
  int ldvarg412 ;
  int tmp___148 ;
  uint32_t ldvarg397 ;
  uint8_t ldvarg408 ;
  uint32_t ldvarg403 ;
  uint8_t ldvarg424 ;
  uint8_t *ldvarg416 ;
  void *tmp___149 ;
  uint32_t ldvarg398 ;
  uint32_t ldvarg423 ;
  uint32_t ldvarg415 ;
  void *ldvarg418 ;
  void *tmp___150 ;
  uint32_t ldvarg422 ;
  uint8_t ldvarg407 ;
  uint16_t *ldvarg405 ;
  void *tmp___151 ;
  uint16_t ldvarg409 ;
  int ldvarg431 ;
  int tmp___152 ;
  uint8_t ldvarg406 ;
  uint32_t ldvarg399 ;
  void *ldvarg432 ;
  void *tmp___153 ;
  char *ldvarg419 ;
  void *tmp___154 ;
  int ldvarg420 ;
  int tmp___155 ;
  uint8_t *ldvarg401 ;
  void *tmp___156 ;
  unsigned int ldvarg421 ;
  unsigned int tmp___157 ;
  char *ldvarg417 ;
  void *tmp___158 ;
  uint32_t ldvarg433 ;
  uint8_t ldvarg425 ;
  uint32_t ldvarg434 ;
  uint8_t ldvarg410 ;
  uint32_t ldvarg402 ;
  uint32_t ldvarg400 ;
  int ldvarg429 ;
  int tmp___159 ;
  unsigned int ldvarg430 ;
  unsigned int tmp___160 ;
  uint16_t ldvarg426 ;
  srb_t *ldvarg413 ;
  void *tmp___161 ;
  uint8_t ldvarg427 ;
  uint32_t *ldvarg411 ;
  void *tmp___162 ;
  uint32_t ldvarg414 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  int tmp___169 ;
  int tmp___170 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;

  {
#line 6308
  tmp = ldv_zalloc(1UL);
#line 6308
  ldvarg18 = (char *)tmp;
#line 6310
  tmp___0 = ldv_zalloc(1UL);
#line 6310
  ldvarg32 = (uint8_t *)tmp___0;
#line 6312
  tmp___1 = ldv_zalloc(1UL);
#line 6312
  ldvarg20 = (char *)tmp___1;
#line 6317
  tmp___2 = ldv_zalloc(1UL);
#line 6317
  ldvarg13 = (uint8_t *)tmp___2;
#line 6318
  tmp___3 = ldv_zalloc(1UL);
#line 6318
  ldvarg29 = tmp___3;
#line 6319
  tmp___4 = ldv_zalloc(1UL);
#line 6319
  ldvarg10 = (uint8_t *)tmp___4;
#line 6322
  tmp___5 = __VERIFIER_nondet_uint();
#line 6322
  ldvarg27 = tmp___5;
#line 6323
  tmp___6 = __VERIFIER_nondet_int();
#line 6323
  ldvarg26 = tmp___6;
#line 6328
  tmp___7 = __VERIFIER_nondet_int();
#line 6328
  ldvarg21 = tmp___7;
#line 6329
  tmp___8 = ldv_zalloc(376UL);
#line 6329
  ldvarg25 = (srb_t *)tmp___8;
#line 6330
  tmp___9 = ldv_zalloc(376UL);
#line 6330
  ldvarg14 = (srb_t *)tmp___9;
#line 6331
  tmp___10 = ldv_zalloc(1UL);
#line 6331
  ldvarg17 = (uint8_t *)tmp___10;
#line 6332
  tmp___11 = __VERIFIER_nondet_uint();
#line 6332
  ldvarg22 = tmp___11;
#line 6333
  tmp___12 = ldv_zalloc(1UL);
#line 6333
  ldvarg19 = tmp___12;
#line 6334
  tmp___13 = __VERIFIER_nondet_int();
#line 6334
  ldvarg28 = tmp___13;
#line 6336
  tmp___14 = __VERIFIER_nondet_int();
#line 6336
  ldvarg51 = tmp___14;
#line 6338
  tmp___15 = ldv_zalloc(1UL);
#line 6338
  ldvarg43 = (uint8_t *)tmp___15;
#line 6340
  tmp___16 = ldv_zalloc(376UL);
#line 6340
  ldvarg71 = (srb_t *)tmp___16;
#line 6341
  tmp___17 = __VERIFIER_nondet_int();
#line 6341
  ldvarg72 = tmp___17;
#line 6343
  tmp___18 = ldv_zalloc(4UL);
#line 6343
  ldvarg50 = (uint32_t *)tmp___18;
#line 6345
  tmp___19 = ldv_zalloc(1UL);
#line 6345
  ldvarg58 = (uint8_t *)tmp___19;
#line 6347
  tmp___20 = ldv_zalloc(376UL);
#line 6347
  ldvarg53 = (srb_t *)tmp___20;
#line 6348
  tmp___21 = __VERIFIER_nondet_uint();
#line 6348
  ldvarg64 = tmp___21;
#line 6349
  tmp___22 = ldv_zalloc(2UL);
#line 6349
  ldvarg44 = (uint16_t *)tmp___22;
#line 6357
  tmp___23 = ldv_zalloc(1UL);
#line 6357
  ldvarg59 = (char *)tmp___23;
#line 6359
  tmp___24 = ldv_zalloc(1UL);
#line 6359
  ldvarg62 = (char *)tmp___24;
#line 6363
  tmp___25 = ldv_zalloc(64UL);
#line 6363
  ldvarg55 = (cmd_entry_t *)tmp___25;
#line 6365
  tmp___26 = ldv_zalloc(1UL);
#line 6365
  ldvarg40 = (uint8_t *)tmp___26;
#line 6367
  tmp___27 = __VERIFIER_nondet_int();
#line 6367
  ldvarg63 = tmp___27;
#line 6368
  tmp___28 = __VERIFIER_nondet_uint();
#line 6368
  ldvarg73 = tmp___28;
#line 6370
  tmp___29 = ldv_zalloc(1UL);
#line 6370
  ldvarg78 = (uint8_t *)tmp___29;
#line 6373
  tmp___30 = ldv_zalloc(1UL);
#line 6373
  ldvarg61 = tmp___30;
#line 6375
  tmp___31 = __VERIFIER_nondet_int();
#line 6375
  ldvarg74 = tmp___31;
#line 6376
  tmp___32 = ldv_zalloc(376UL);
#line 6376
  ldvarg52 = (srb_t *)tmp___32;
#line 6377
  tmp___33 = ldv_zalloc(1UL);
#line 6377
  ldvarg75 = tmp___33;
#line 6378
  tmp___34 = __VERIFIER_nondet_int();
#line 6378
  ldvarg88 = tmp___34;
#line 6379
  tmp___35 = __VERIFIER_nondet_int();
#line 6379
  ldvarg89 = tmp___35;
#line 6380
  tmp___36 = __VERIFIER_nondet_ulong();
#line 6380
  ldvarg90 = tmp___36;
#line 6381
  tmp___37 = __VERIFIER_nondet_int();
#line 6381
  ldvarg87 = tmp___37;
#line 6382
  tmp___38 = ldv_zalloc(32UL);
#line 6382
  ldvarg109 = (struct pci_device_id *)tmp___38;
#line 6383
  tmp___39 = __VERIFIER_nondet_int();
#line 6383
  ldvarg131 = tmp___39;
#line 6387
  tmp___40 = ldv_zalloc(1UL);
#line 6387
  ldvarg136 = (char *)tmp___40;
#line 6390
  tmp___41 = __VERIFIER_nondet_uint();
#line 6390
  ldvarg140 = tmp___41;
#line 6392
  tmp___42 = ldv_zalloc(376UL);
#line 6392
  ldvarg132 = (srb_t *)tmp___42;
#line 6393
  tmp___43 = ldv_zalloc(1UL);
#line 6393
  ldvarg138 = (char *)tmp___43;
#line 6395
  tmp___44 = __VERIFIER_nondet_uint();
#line 6395
  ldvarg149 = tmp___44;
#line 6397
  tmp___45 = ldv_zalloc(1UL);
#line 6397
  ldvarg151 = tmp___45;
#line 6398
  tmp___46 = ldv_zalloc(1UL);
#line 6398
  ldvarg154 = (uint8_t *)tmp___46;
#line 6399
  tmp___47 = ldv_zalloc(1UL);
#line 6399
  ldvarg137 = tmp___47;
#line 6406
  tmp___48 = ldv_zalloc(1UL);
#line 6406
  ldvarg135 = (uint8_t *)tmp___48;
#line 6407
  tmp___49 = ldv_zalloc(376UL);
#line 6407
  ldvarg147 = (srb_t *)tmp___49;
#line 6409
  tmp___50 = ldv_zalloc(2UL);
#line 6409
  ldvarg124 = (uint16_t *)tmp___50;
#line 6411
  tmp___51 = __VERIFIER_nondet_int();
#line 6411
  ldvarg150 = tmp___51;
#line 6413
  tmp___52 = ldv_zalloc(4UL);
#line 6413
  ldvarg130 = (uint32_t *)tmp___52;
#line 6414
  tmp___53 = __VERIFIER_nondet_int();
#line 6414
  ldvarg139 = tmp___53;
#line 6415
  tmp___54 = __VERIFIER_nondet_int();
#line 6415
  ldvarg148 = tmp___54;
#line 6416
  tmp___55 = ldv_zalloc(1UL);
#line 6416
  ldvarg178 = (char *)tmp___55;
#line 6417
  tmp___56 = __VERIFIER_nondet_int();
#line 6417
  ldvarg181 = tmp___56;
#line 6418
  tmp___57 = ldv_zalloc(376UL);
#line 6418
  ldvarg174 = (srb_t *)tmp___57;
#line 6423
  tmp___58 = __VERIFIER_nondet_uint();
#line 6423
  ldvarg191 = tmp___58;
#line 6425
  tmp___59 = ldv_zalloc(1UL);
#line 6425
  ldvarg196 = (uint8_t *)tmp___59;
#line 6427
  tmp___60 = ldv_zalloc(376UL);
#line 6427
  ldvarg189 = (srb_t *)tmp___60;
#line 6428
  tmp___61 = __VERIFIER_nondet_uint();
#line 6428
  ldvarg182 = tmp___61;
#line 6433
  tmp___62 = ldv_zalloc(4UL);
#line 6433
  ldvarg172 = (uint32_t *)tmp___62;
#line 6436
  tmp___63 = ldv_zalloc(1UL);
#line 6436
  ldvarg177 = (uint8_t *)tmp___63;
#line 6437
  tmp___64 = __VERIFIER_nondet_int();
#line 6437
  ldvarg190 = tmp___64;
#line 6438
  tmp___65 = ldv_zalloc(1UL);
#line 6438
  ldvarg193 = tmp___65;
#line 6439
  tmp___66 = ldv_zalloc(2UL);
#line 6439
  ldvarg166 = (uint16_t *)tmp___66;
#line 6440
  tmp___67 = __VERIFIER_nondet_int();
#line 6440
  ldvarg192 = tmp___67;
#line 6444
  tmp___68 = __VERIFIER_nondet_int();
#line 6444
  ldvarg173 = tmp___68;
#line 6446
  tmp___69 = ldv_zalloc(1UL);
#line 6446
  ldvarg179 = tmp___69;
#line 6447
  tmp___70 = ldv_zalloc(1UL);
#line 6447
  ldvarg180 = (char *)tmp___70;
#line 6449
  tmp___71 = __VERIFIER_nondet_loff_t();
#line 6449
  ldvarg213 = tmp___71;
#line 6450
  tmp___72 = __VERIFIER_nondet_int();
#line 6450
  ldvarg212 = tmp___72;
#line 6451
  tmp___73 = ldv_zalloc(1UL);
#line 6451
  ldvarg242 = (char *)tmp___73;
#line 6456
  tmp___74 = ldv_zalloc(376UL);
#line 6456
  ldvarg236 = (srb_t *)tmp___74;
#line 6457
  tmp___75 = __VERIFIER_nondet_int();
#line 6457
  ldvarg243 = tmp___75;
#line 6458
  tmp___76 = ldv_zalloc(4UL);
#line 6458
  ldvarg234 = (uint32_t *)tmp___76;
#line 6459
  tmp___77 = __VERIFIER_nondet_uint();
#line 6459
  ldvarg244 = tmp___77;
#line 6460
  tmp___78 = ldv_zalloc(2UL);
#line 6460
  ldvarg228 = (uint16_t *)tmp___78;
#line 6464
  tmp___79 = ldv_zalloc(1UL);
#line 6464
  ldvarg258 = (uint8_t *)tmp___79;
#line 6466
  tmp___80 = ldv_zalloc(1UL);
#line 6466
  ldvarg255 = tmp___80;
#line 6469
  tmp___81 = ldv_zalloc(1UL);
#line 6469
  ldvarg240 = (char *)tmp___81;
#line 6470
  tmp___82 = ldv_zalloc(1UL);
#line 6470
  ldvarg241 = tmp___82;
#line 6474
  tmp___83 = __VERIFIER_nondet_int();
#line 6474
  ldvarg254 = tmp___83;
#line 6475
  tmp___84 = ldv_zalloc(1UL);
#line 6475
  ldvarg224 = (uint8_t *)tmp___84;
#line 6478
  tmp___85 = __VERIFIER_nondet_int();
#line 6478
  ldvarg235 = tmp___85;
#line 6481
  tmp___86 = __VERIFIER_nondet_int();
#line 6481
  ldvarg252 = tmp___86;
#line 6483
  tmp___87 = ldv_zalloc(1UL);
#line 6483
  ldvarg227 = (uint8_t *)tmp___87;
#line 6484
  tmp___88 = ldv_zalloc(376UL);
#line 6484
  ldvarg251 = (srb_t *)tmp___88;
#line 6488
  tmp___89 = ldv_zalloc(1UL);
#line 6488
  ldvarg239 = (uint8_t *)tmp___89;
#line 6489
  tmp___90 = __VERIFIER_nondet_uint();
#line 6489
  ldvarg253 = tmp___90;
#line 6492
  tmp___91 = ldv_zalloc(1UL);
#line 6492
  ldvarg299 = tmp___91;
#line 6493
  tmp___92 = ldv_zalloc(4UL);
#line 6493
  ldvarg278 = (uint32_t *)tmp___92;
#line 6494
  tmp___93 = ldv_zalloc(1UL);
#line 6494
  ldvarg285 = tmp___93;
#line 6496
  tmp___94 = ldv_zalloc(376UL);
#line 6496
  ldvarg295 = (srb_t *)tmp___94;
#line 6497
  tmp___95 = __VERIFIER_nondet_int();
#line 6497
  ldvarg296 = tmp___95;
#line 6500
  tmp___96 = ldv_zalloc(1UL);
#line 6500
  ldvarg302 = (uint8_t *)tmp___96;
#line 6501
  tmp___97 = ldv_zalloc(1UL);
#line 6501
  ldvarg284 = (char *)tmp___97;
#line 6502
  tmp___98 = ldv_zalloc(376UL);
#line 6502
  ldvarg280 = (srb_t *)tmp___98;
#line 6504
  tmp___99 = ldv_zalloc(2UL);
#line 6504
  ldvarg272 = (uint16_t *)tmp___99;
#line 6508
  tmp___100 = __VERIFIER_nondet_uint();
#line 6508
  ldvarg288 = tmp___100;
#line 6514
  tmp___101 = ldv_zalloc(1UL);
#line 6514
  ldvarg286 = (char *)tmp___101;
#line 6515
  tmp___102 = __VERIFIER_nondet_int();
#line 6515
  ldvarg287 = tmp___102;
#line 6517
  tmp___103 = __VERIFIER_nondet_uint();
#line 6517
  ldvarg297 = tmp___103;
#line 6518
  tmp___104 = ldv_zalloc(1UL);
#line 6518
  ldvarg283 = (uint8_t *)tmp___104;
#line 6519
  tmp___105 = __VERIFIER_nondet_int();
#line 6519
  ldvarg279 = tmp___105;
#line 6522
  tmp___106 = __VERIFIER_nondet_int();
#line 6522
  ldvarg298 = tmp___106;
#line 6527
  tmp___107 = __VERIFIER_nondet_int();
#line 6527
  ldvarg341 = tmp___107;
#line 6529
  tmp___108 = ldv_zalloc(1UL);
#line 6529
  ldvarg307 = (uint8_t *)tmp___108;
#line 6532
  tmp___109 = ldv_zalloc(2UL);
#line 6532
  ldvarg311 = (uint16_t *)tmp___109;
#line 6534
  tmp___110 = ldv_zalloc(64UL);
#line 6534
  ldvarg322 = (cmd_entry_t *)tmp___110;
#line 6535
  tmp___111 = ldv_zalloc(1UL);
#line 6535
  ldvarg310 = (uint8_t *)tmp___111;
#line 6536
  tmp___112 = __VERIFIER_nondet_uint();
#line 6536
  ldvarg340 = tmp___112;
#line 6538
  tmp___113 = ldv_zalloc(376UL);
#line 6538
  ldvarg338 = (srb_t *)tmp___113;
#line 6539
  tmp___114 = ldv_zalloc(1UL);
#line 6539
  ldvarg325 = (uint8_t *)tmp___114;
#line 6541
  tmp___115 = ldv_zalloc(4UL);
#line 6541
  ldvarg317 = (uint32_t *)tmp___115;
#line 6542
  tmp___116 = ldv_zalloc(1UL);
#line 6542
  ldvarg342 = tmp___116;
#line 6548
  tmp___117 = __VERIFIER_nondet_int();
#line 6548
  ldvarg339 = tmp___117;
#line 6550
  tmp___118 = ldv_zalloc(1UL);
#line 6550
  ldvarg345 = (uint8_t *)tmp___118;
#line 6551
  tmp___119 = __VERIFIER_nondet_int();
#line 6551
  ldvarg318 = tmp___119;
#line 6552
  tmp___120 = ldv_zalloc(1UL);
#line 6552
  ldvarg326 = (char *)tmp___120;
#line 6553
  tmp___121 = __VERIFIER_nondet_uint();
#line 6553
  ldvarg331 = tmp___121;
#line 6558
  tmp___122 = ldv_zalloc(376UL);
#line 6558
  ldvarg319 = (srb_t *)tmp___122;
#line 6560
  tmp___123 = ldv_zalloc(1UL);
#line 6560
  ldvarg329 = (char *)tmp___123;
#line 6563
  tmp___124 = ldv_zalloc(376UL);
#line 6563
  ldvarg320 = (srb_t *)tmp___124;
#line 6564
  tmp___125 = ldv_zalloc(1UL);
#line 6564
  ldvarg328 = tmp___125;
#line 6565
  tmp___126 = __VERIFIER_nondet_int();
#line 6565
  ldvarg330 = tmp___126;
#line 6569
  tmp___127 = ldv_zalloc(1UL);
#line 6569
  ldvarg381 = tmp___127;
#line 6572
  tmp___128 = __VERIFIER_nondet_int();
#line 6572
  ldvarg380 = tmp___128;
#line 6574
  tmp___129 = __VERIFIER_nondet_int();
#line 6574
  ldvarg369 = tmp___129;
#line 6576
  tmp___130 = ldv_zalloc(376UL);
#line 6576
  ldvarg362 = (srb_t *)tmp___130;
#line 6577
  tmp___131 = __VERIFIER_nondet_uint();
#line 6577
  ldvarg379 = tmp___131;
#line 6579
  tmp___132 = ldv_zalloc(1UL);
#line 6579
  ldvarg365 = (uint8_t *)tmp___132;
#line 6580
  tmp___133 = ldv_zalloc(1UL);
#line 6580
  ldvarg350 = (uint8_t *)tmp___133;
#line 6582
  tmp___134 = ldv_zalloc(4UL);
#line 6582
  ldvarg360 = (uint32_t *)tmp___134;
#line 6585
  tmp___135 = ldv_zalloc(376UL);
#line 6585
  ldvarg377 = (srb_t *)tmp___135;
#line 6587
  tmp___136 = __VERIFIER_nondet_uint();
#line 6587
  ldvarg370 = tmp___136;
#line 6588
  tmp___137 = __VERIFIER_nondet_int();
#line 6588
  ldvarg361 = tmp___137;
#line 6589
  tmp___138 = ldv_zalloc(2UL);
#line 6589
  ldvarg354 = (uint16_t *)tmp___138;
#line 6591
  tmp___139 = ldv_zalloc(1UL);
#line 6591
  ldvarg384 = (uint8_t *)tmp___139;
#line 6594
  tmp___140 = ldv_zalloc(1UL);
#line 6594
  ldvarg367 = tmp___140;
#line 6596
  tmp___141 = __VERIFIER_nondet_int();
#line 6596
  ldvarg378 = tmp___141;
#line 6599
  tmp___142 = ldv_zalloc(1UL);
#line 6599
  ldvarg368 = (char *)tmp___142;
#line 6600
  tmp___143 = ldv_zalloc(1UL);
#line 6600
  ldvarg353 = (uint8_t *)tmp___143;
#line 6603
  tmp___144 = ldv_zalloc(1UL);
#line 6603
  ldvarg366 = (char *)tmp___144;
#line 6606
  tmp___145 = ldv_zalloc(1UL);
#line 6606
  ldvarg404 = (uint8_t *)tmp___145;
#line 6607
  tmp___146 = ldv_zalloc(1UL);
#line 6607
  ldvarg435 = (uint8_t *)tmp___146;
#line 6608
  tmp___147 = ldv_zalloc(376UL);
#line 6608
  ldvarg428 = (srb_t *)tmp___147;
#line 6609
  tmp___148 = __VERIFIER_nondet_int();
#line 6609
  ldvarg412 = tmp___148;
#line 6614
  tmp___149 = ldv_zalloc(1UL);
#line 6614
  ldvarg416 = (uint8_t *)tmp___149;
#line 6618
  tmp___150 = ldv_zalloc(1UL);
#line 6618
  ldvarg418 = tmp___150;
#line 6621
  tmp___151 = ldv_zalloc(2UL);
#line 6621
  ldvarg405 = (uint16_t *)tmp___151;
#line 6623
  tmp___152 = __VERIFIER_nondet_int();
#line 6623
  ldvarg431 = tmp___152;
#line 6626
  tmp___153 = ldv_zalloc(1UL);
#line 6626
  ldvarg432 = tmp___153;
#line 6627
  tmp___154 = ldv_zalloc(1UL);
#line 6627
  ldvarg419 = (char *)tmp___154;
#line 6628
  tmp___155 = __VERIFIER_nondet_int();
#line 6628
  ldvarg420 = tmp___155;
#line 6629
  tmp___156 = ldv_zalloc(1UL);
#line 6629
  ldvarg401 = (uint8_t *)tmp___156;
#line 6630
  tmp___157 = __VERIFIER_nondet_uint();
#line 6630
  ldvarg421 = tmp___157;
#line 6631
  tmp___158 = ldv_zalloc(1UL);
#line 6631
  ldvarg417 = (char *)tmp___158;
#line 6638
  tmp___159 = __VERIFIER_nondet_int();
#line 6638
  ldvarg429 = tmp___159;
#line 6639
  tmp___160 = __VERIFIER_nondet_uint();
#line 6639
  ldvarg430 = tmp___160;
#line 6641
  tmp___161 = ldv_zalloc(376UL);
#line 6641
  ldvarg413 = (srb_t *)tmp___161;
#line 6643
  tmp___162 = ldv_zalloc(4UL);
#line 6643
  ldvarg411 = (uint32_t *)tmp___162;
#line 6306
  ldv_initialize();
#line 6309
  memset((void *)(& ldvarg11), 0, 4UL);
#line 6311
  memset((void *)(& ldvarg31), 0, 4UL);
#line 6313
  memset((void *)(& ldvarg7), 0, 4UL);
#line 6314
  memset((void *)(& ldvarg23), 0, 4UL);
#line 6315
  memset((void *)(& ldvarg12), 0, 4UL);
#line 6316
  memset((void *)(& ldvarg8), 0, 4UL);
#line 6320
  memset((void *)(& ldvarg9), 0, 4UL);
#line 6321
  memset((void *)(& ldvarg24), 0, 4UL);
#line 6324
  memset((void *)(& ldvarg30), 0, 4UL);
#line 6325
  memset((void *)(& ldvarg6), 0, 4UL);
#line 6326
  memset((void *)(& ldvarg15), 0, 4UL);
#line 6327
  memset((void *)(& ldvarg16), 0, 4UL);
#line 6335
  memset((void *)(& ldvarg77), 0, 4UL);
#line 6337
  memset((void *)(& ldvarg67), 0, 1UL);
#line 6339
  memset((void *)(& ldvarg42), 0, 4UL);
#line 6342
  memset((void *)(& ldvarg56), 0, 4UL);
#line 6344
  memset((void *)(& ldvarg46), 0, 1UL);
#line 6346
  memset((void *)(& ldvarg37), 0, 4UL);
#line 6350
  memset((void *)(& ldvarg38), 0, 4UL);
#line 6351
  memset((void *)(& ldvarg69), 0, 2UL);
#line 6352
  memset((void *)(& ldvarg48), 0, 2UL);
#line 6353
  memset((void *)(& ldvarg47), 0, 1UL);
#line 6354
  memset((void *)(& ldvarg39), 0, 4UL);
#line 6355
  memset((void *)(& ldvarg41), 0, 4UL);
#line 6356
  memset((void *)(& ldvarg60), 0, 2UL);
#line 6358
  memset((void *)(& ldvarg49), 0, 1UL);
#line 6360
  memset((void *)(& ldvarg57), 0, 4UL);
#line 6361
  memset((void *)(& ldvarg65), 0, 4UL);
#line 6362
  memset((void *)(& ldvarg36), 0, 4UL);
#line 6364
  memset((void *)(& ldvarg66), 0, 4UL);
#line 6366
  memset((void *)(& ldvarg45), 0, 1UL);
#line 6369
  memset((void *)(& ldvarg70), 0, 1UL);
#line 6371
  memset((void *)(& ldvarg68), 0, 1UL);
#line 6372
  memset((void *)(& ldvarg54), 0, 2UL);
#line 6374
  memset((void *)(& ldvarg76), 0, 4UL);
#line 6384
  memset((void *)(& ldvarg134), 0, 4UL);
#line 6385
  memset((void *)(& ldvarg146), 0, 1UL);
#line 6386
  memset((void *)(& ldvarg141), 0, 4UL);
#line 6388
  memset((void *)(& ldvarg125), 0, 1UL);
#line 6389
  memset((void *)(& ldvarg145), 0, 2UL);
#line 6391
  memset((void *)(& ldvarg152), 0, 4UL);
#line 6394
  memset((void *)(& ldvarg129), 0, 1UL);
#line 6396
  memset((void *)(& ldvarg142), 0, 4UL);
#line 6400
  memset((void *)(& ldvarg122), 0, 4UL);
#line 6401
  memset((void *)(& ldvarg144), 0, 1UL);
#line 6402
  memset((void *)(& ldvarg128), 0, 2UL);
#line 6403
  memset((void *)(& ldvarg126), 0, 1UL);
#line 6404
  memset((void *)(& ldvarg123), 0, 4UL);
#line 6405
  memset((void *)(& ldvarg153), 0, 4UL);
#line 6408
  memset((void *)(& ldvarg127), 0, 1UL);
#line 6410
  memset((void *)(& ldvarg133), 0, 4UL);
#line 6412
  memset((void *)(& ldvarg143), 0, 1UL);
#line 6419
  memset((void *)(& ldvarg165), 0, 4UL);
#line 6420
  memset((void *)(& ldvarg168), 0, 1UL);
#line 6421
  memset((void *)(& ldvarg188), 0, 1UL);
#line 6422
  memset((void *)(& ldvarg185), 0, 1UL);
#line 6424
  memset((void *)(& ldvarg167), 0, 1UL);
#line 6426
  memset((void *)(& ldvarg170), 0, 2UL);
#line 6429
  memset((void *)(& ldvarg169), 0, 1UL);
#line 6430
  memset((void *)(& ldvarg175), 0, 4UL);
#line 6431
  memset((void *)(& ldvarg195), 0, 4UL);
#line 6432
  memset((void *)(& ldvarg187), 0, 2UL);
#line 6434
  memset((void *)(& ldvarg184), 0, 4UL);
#line 6435
  memset((void *)(& ldvarg186), 0, 1UL);
#line 6441
  memset((void *)(& ldvarg164), 0, 4UL);
#line 6442
  memset((void *)(& ldvarg183), 0, 4UL);
#line 6443
  memset((void *)(& ldvarg176), 0, 4UL);
#line 6445
  memset((void *)(& ldvarg194), 0, 4UL);
#line 6448
  memset((void *)(& ldvarg171), 0, 1UL);
#line 6452
  memset((void *)(& ldvarg237), 0, 4UL);
#line 6453
  memset((void *)(& ldvarg225), 0, 4UL);
#line 6454
  memset((void *)(& ldvarg247), 0, 1UL);
#line 6455
  memset((void *)(& ldvarg233), 0, 1UL);
#line 6461
  memset((void *)(& ldvarg257), 0, 4UL);
#line 6462
  memset((void *)(& ldvarg226), 0, 4UL);
#line 6463
  memset((void *)(& ldvarg221), 0, 4UL);
#line 6465
  memset((void *)(& ldvarg222), 0, 4UL);
#line 6467
  memset((void *)(& ldvarg232), 0, 2UL);
#line 6468
  memset((void *)(& ldvarg230), 0, 1UL);
#line 6471
  memset((void *)(& ldvarg246), 0, 4UL);
#line 6472
  memset((void *)(& ldvarg231), 0, 1UL);
#line 6473
  memset((void *)(& ldvarg238), 0, 4UL);
#line 6476
  memset((void *)(& ldvarg248), 0, 1UL);
#line 6477
  memset((void *)(& ldvarg223), 0, 4UL);
#line 6479
  memset((void *)(& ldvarg245), 0, 4UL);
#line 6480
  memset((void *)(& ldvarg256), 0, 4UL);
#line 6482
  memset((void *)(& ldvarg229), 0, 1UL);
#line 6485
  memset((void *)(& ldvarg220), 0, 4UL);
#line 6486
  memset((void *)(& ldvarg250), 0, 1UL);
#line 6487
  memset((void *)(& ldvarg249), 0, 2UL);
#line 6490
  memset((void *)(& ldvarg263), 0, 4UL);
#line 6491
  memset((void *)(& ldvarg290), 0, 4UL);
#line 6495
  memset((void *)(& ldvarg300), 0, 4UL);
#line 6498
  memset((void *)(& ldvarg281), 0, 4UL);
#line 6499
  memset((void *)(& ldvarg271), 0, 4UL);
#line 6503
  memset((void *)(& ldvarg274), 0, 1UL);
#line 6505
  memset((void *)(& ldvarg293), 0, 2UL);
#line 6506
  memset((void *)(& ldvarg275), 0, 1UL);
#line 6507
  memset((void *)(& ldvarg277), 0, 1UL);
#line 6509
  memset((void *)(& ldvarg291), 0, 1UL);
#line 6510
  memset((void *)(& ldvarg289), 0, 4UL);
#line 6511
  memset((void *)(& ldvarg282), 0, 4UL);
#line 6512
  memset((void *)(& ldvarg301), 0, 4UL);
#line 6513
  memset((void *)(& ldvarg270), 0, 4UL);
#line 6516
  memset((void *)(& ldvarg276), 0, 2UL);
#line 6520
  memset((void *)(& ldvarg273), 0, 1UL);
#line 6521
  memset((void *)(& ldvarg292), 0, 1UL);
#line 6523
  memset((void *)(& ldvarg294), 0, 1UL);
#line 6524
  memset((void *)(& ldvarg315), 0, 2UL);
#line 6525
  memset((void *)(& ldvarg308), 0, 4UL);
#line 6526
  memset((void *)(& ldvarg305), 0, 4UL);
#line 6528
  memset((void *)(& ldvarg313), 0, 1UL);
#line 6530
  memset((void *)(& ldvarg321), 0, 2UL);
#line 6531
  memset((void *)(& ldvarg336), 0, 2UL);
#line 6533
  memset((void *)(& ldvarg309), 0, 4UL);
#line 6537
  memset((void *)(& ldvarg333), 0, 4UL);
#line 6540
  memset((void *)(& ldvarg303), 0, 4UL);
#line 6543
  memset((void *)(& ldvarg335), 0, 1UL);
#line 6544
  memset((void *)(& ldvarg304), 0, 4UL);
#line 6545
  memset((void *)(& ldvarg343), 0, 4UL);
#line 6546
  memset((void *)(& ldvarg337), 0, 1UL);
#line 6547
  memset((void *)(& ldvarg344), 0, 4UL);
#line 6549
  memset((void *)(& ldvarg312), 0, 1UL);
#line 6554
  memset((void *)(& ldvarg334), 0, 1UL);
#line 6555
  memset((void *)(& ldvarg324), 0, 4UL);
#line 6556
  memset((void *)(& ldvarg306), 0, 4UL);
#line 6557
  memset((void *)(& ldvarg314), 0, 1UL);
#line 6559
  memset((void *)(& ldvarg323), 0, 4UL);
#line 6561
  memset((void *)(& ldvarg327), 0, 2UL);
#line 6562
  memset((void *)(& ldvarg332), 0, 4UL);
#line 6566
  memset((void *)(& ldvarg316), 0, 1UL);
#line 6567
  memset((void *)(& ldvarg372), 0, 4UL);
#line 6568
  memset((void *)(& ldvarg357), 0, 1UL);
#line 6570
  memset((void *)(& ldvarg349), 0, 4UL);
#line 6571
  memset((void *)(& ldvarg352), 0, 4UL);
#line 6573
  memset((void *)(& ldvarg363), 0, 4UL);
#line 6575
  memset((void *)(& ldvarg383), 0, 4UL);
#line 6578
  memset((void *)(& ldvarg348), 0, 4UL);
#line 6581
  memset((void *)(& ldvarg346), 0, 4UL);
#line 6583
  memset((void *)(& ldvarg364), 0, 4UL);
#line 6584
  memset((void *)(& ldvarg376), 0, 1UL);
#line 6586
  memset((void *)(& ldvarg374), 0, 1UL);
#line 6590
  memset((void *)(& ldvarg375), 0, 2UL);
#line 6592
  memset((void *)(& ldvarg358), 0, 2UL);
#line 6593
  memset((void *)(& ldvarg351), 0, 4UL);
#line 6595
  memset((void *)(& ldvarg347), 0, 4UL);
#line 6597
  memset((void *)(& ldvarg382), 0, 4UL);
#line 6598
  memset((void *)(& ldvarg359), 0, 1UL);
#line 6601
  memset((void *)(& ldvarg373), 0, 1UL);
#line 6602
  memset((void *)(& ldvarg371), 0, 4UL);
#line 6604
  memset((void *)(& ldvarg355), 0, 1UL);
#line 6605
  memset((void *)(& ldvarg356), 0, 1UL);
#line 6610
  memset((void *)(& ldvarg397), 0, 4UL);
#line 6611
  memset((void *)(& ldvarg408), 0, 1UL);
#line 6612
  memset((void *)(& ldvarg403), 0, 4UL);
#line 6613
  memset((void *)(& ldvarg424), 0, 1UL);
#line 6615
  memset((void *)(& ldvarg398), 0, 4UL);
#line 6616
  memset((void *)(& ldvarg423), 0, 4UL);
#line 6617
  memset((void *)(& ldvarg415), 0, 4UL);
#line 6619
  memset((void *)(& ldvarg422), 0, 4UL);
#line 6620
  memset((void *)(& ldvarg407), 0, 1UL);
#line 6622
  memset((void *)(& ldvarg409), 0, 2UL);
#line 6624
  memset((void *)(& ldvarg406), 0, 1UL);
#line 6625
  memset((void *)(& ldvarg399), 0, 4UL);
#line 6632
  memset((void *)(& ldvarg433), 0, 4UL);
#line 6633
  memset((void *)(& ldvarg425), 0, 1UL);
#line 6634
  memset((void *)(& ldvarg434), 0, 4UL);
#line 6635
  memset((void *)(& ldvarg410), 0, 1UL);
#line 6636
  memset((void *)(& ldvarg402), 0, 4UL);
#line 6637
  memset((void *)(& ldvarg400), 0, 4UL);
#line 6640
  memset((void *)(& ldvarg426), 0, 2UL);
#line 6642
  memset((void *)(& ldvarg427), 0, 1UL);
#line 6644
  memset((void *)(& ldvarg414), 0, 4UL);
#line 6646
  ldv_state_variable_33 = 0;
#line 6647
  ldv_state_variable_32 = 0;
#line 6648
  ldv_state_variable_63 = 0;
#line 6649
  ldv_state_variable_21 = 0;
#line 6650
  ldv_state_variable_71 = 0;
#line 6652
  ldv_state_variable_7 = 1;
#line 6653
  ldv_state_variable_26 = 0;
#line 6654
  ldv_state_variable_18 = 0;
#line 6655
  ldv_state_variable_72 = 0;
#line 6657
  ldv_state_variable_16 = 1;
#line 6658
  ldv_state_variable_44 = 0;
#line 6659
  ldv_state_variable_55 = 0;
#line 6660
  ldv_state_variable_27 = 0;
#line 6661
  ldv_state_variable_57 = 0;
#line 6662
  ldv_state_variable_61 = 0;
#line 6663
  ldv_state_variable_20 = 0;
#line 6665
  ldv_state_variable_10 = 1;
#line 6666
  ldv_state_variable_31 = 0;
#line 6667
  ldv_state_variable_35 = 0;
#line 6669
  ldv_state_variable_11 = 1;
#line 6670
  ldv_state_variable_48 = 0;
#line 6671
  ldv_state_variable_65 = 0;
#line 6672
  ldv_state_variable_29 = 0;
#line 6673
  ldv_state_variable_50 = 0;
#line 6674
  ldv_state_variable_39 = 0;
#line 6675
  ldv_state_variable_64 = 0;
#line 6676
  ldv_state_variable_58 = 0;
#line 6677
  ldv_state_variable_41 = 0;
#line 6679
  ldv_state_variable_12 = 1;
#line 6681
  ldv_state_variable_15 = 1;
#line 6682
  ldv_state_variable_52 = 0;
#line 6683
  ldv_state_variable_60 = 0;
#line 6684
  ldv_state_variable_56 = 0;
#line 6685
  ldv_state_variable_66 = 0;
#line 6686
  ldv_state_variable_45 = 0;
#line 6687
  ldv_state_variable_19 = 0;
#line 6688
  ldv_state_variable_62 = 0;
#line 6689
  ldv_state_variable_54 = 0;
#line 6690
  ldv_state_variable_67 = 0;
#line 6691
  ldv_state_variable_70 = 0;
#line 6692
  ldv_state_variable_68 = 0;
#line 6694
  ldv_state_variable_2 = 1;
#line 6696
  ldv_state_variable_17 = 1;
#line 6698
  ldv_state_variable_1 = 1;
#line 6699
  ldv_state_variable_30 = 0;
#line 6700
  ldv_state_variable_25 = 0;
#line 6701
  ldv_state_variable_28 = 0;
#line 6702
  ldv_state_variable_40 = 0;
#line 6704
  ldv_state_variable_14 = 1;
#line 6705
  ldv_state_variable_69 = 0;
#line 6706
  ldv_state_variable_59 = 0;
#line 6707
  ldv_state_variable_49 = 0;
#line 6708
  ldv_state_variable_24 = 0;
#line 6709
  ldv_state_variable_53 = 0;
#line 6710
  ldv_state_variable_22 = 0;
#line 6711
  ldv_state_variable_42 = 0;
#line 6712
  ref_cnt = 0;
#line 6713
  ldv_state_variable_0 = 1;
#line 6714
  ldv_state_variable_46 = 0;
#line 6715
  ldv_state_variable_23 = 0;
#line 6717
  ldv_state_variable_13 = 1;
#line 6719
  ldv_state_variable_6 = 1;
#line 6721
  ldv_state_variable_3 = 1;
#line 6722
  ldv_state_variable_36 = 0;
#line 6724
  ldv_state_variable_9 = 1;
#line 6725
  ldv_state_variable_51 = 0;
#line 6726
  ldv_state_variable_47 = 0;
#line 6728
  ldv_state_variable_8 = 1;
#line 6729
  ldv_state_variable_38 = 0;
#line 6731
  ldv_state_variable_4 = 1;
#line 6732
  ldv_state_variable_34 = 0;
#line 6733
  ldv_state_variable_37 = 0;
#line 6734
  ldv_state_variable_43 = 0;
#line 6736
  ldv_state_variable_5 = 1;
  ldv_63557: 
#line 6738
  tmp___163 = __VERIFIER_nondet_int();
#line 6738
  switch (tmp___163) {
  case 0: ;
#line 6742
  if (ldv_state_variable_33 != 0) {
#line 6743
    ldv_main_exported_33();
  } else {

  }
#line 6746
  goto ldv_63125;
  case 1: ;
#line 6750
  if (ldv_state_variable_32 != 0) {
#line 6751
    ldv_main_exported_32();
  } else {

  }
#line 6754
  goto ldv_63125;
  case 2: ;
#line 6758
  if (ldv_state_variable_63 != 0) {
#line 6759
    tmp___164 = __VERIFIER_nondet_int();
#line 6759
    switch (tmp___164) {
    case 0: ;
#line 6762
    if (ldv_state_variable_63 == 1) {
#line 6764
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 6766
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6769
    if (ldv_state_variable_63 == 2) {
#line 6771
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 6773
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6776
    goto ldv_63129;
    case 1: ;
#line 6779
    if (ldv_state_variable_63 == 2) {
#line 6781
      qla24xx_write_optrom_data(qlafx00_isp_ops_group0, ldvarg32, ldvarg31, ldvarg30);
#line 6783
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6786
    goto ldv_63129;
    case 2: ;
#line 6789
    if (ldv_state_variable_63 == 1) {
#line 6791
      qlafx00_enable_intrs(qlafx00_isp_ops_group2);
#line 6793
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6796
    if (ldv_state_variable_63 == 2) {
#line 6798
      qlafx00_enable_intrs(qlafx00_isp_ops_group2);
#line 6800
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6803
    goto ldv_63129;
    case 3: ;
#line 6806
    if (ldv_state_variable_63 == 1) {
#line 6808
      qlafx00_intr_handler(ldvarg28, ldvarg29);
#line 6810
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6813
    if (ldv_state_variable_63 == 2) {
#line 6815
      qlafx00_intr_handler(ldvarg28, ldvarg29);
#line 6817
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6820
    goto ldv_63129;
    case 4: ;
#line 6823
    if (ldv_state_variable_63 == 1) {
#line 6825
      qlafx00_abort_target(qlafx00_isp_ops_group1, ldvarg27, ldvarg26);
#line 6827
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6830
    if (ldv_state_variable_63 == 2) {
#line 6832
      qlafx00_abort_target(qlafx00_isp_ops_group1, ldvarg27, ldvarg26);
#line 6834
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6837
    goto ldv_63129;
    case 5: ;
#line 6840
    if (ldv_state_variable_63 == 1) {
#line 6842
      qlafx00_abort_isp(qlafx00_isp_ops_group0);
#line 6844
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6847
    if (ldv_state_variable_63 == 2) {
#line 6849
      qlafx00_abort_isp(qlafx00_isp_ops_group0);
#line 6851
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6854
    goto ldv_63129;
    case 6: ;
#line 6857
    if (ldv_state_variable_63 == 1) {
#line 6859
      qlafx00_start_scsi(ldvarg25);
#line 6861
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6864
    if (ldv_state_variable_63 == 2) {
#line 6866
      qlafx00_start_scsi(ldvarg25);
#line 6868
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6871
    goto ldv_63129;
    case 7: ;
#line 6874
    if (ldv_state_variable_63 == 1) {
#line 6876
      qlafx00_chip_diag(qlafx00_isp_ops_group0);
#line 6878
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6881
    if (ldv_state_variable_63 == 2) {
#line 6883
      qlafx00_chip_diag(qlafx00_isp_ops_group0);
#line 6885
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6888
    goto ldv_63129;
    case 8: ;
#line 6891
    if (ldv_state_variable_63 == 1) {
#line 6893
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 6895
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6898
    if (ldv_state_variable_63 == 2) {
#line 6900
      qlafx00_soft_reset(qlafx00_isp_ops_group0);
#line 6902
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6905
    goto ldv_63129;
    case 9: ;
#line 6908
    if (ldv_state_variable_63 == 1) {
#line 6910
      qla24xx_prep_ms_iocb(qlafx00_isp_ops_group0, ldvarg24, ldvarg23);
#line 6912
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6915
    if (ldv_state_variable_63 == 2) {
#line 6917
      qla24xx_prep_ms_iocb(qlafx00_isp_ops_group0, ldvarg24, ldvarg23);
#line 6919
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6922
    goto ldv_63129;
    case 10: ;
#line 6925
    if (ldv_state_variable_63 == 1) {
#line 6927
      qlafx00_lun_reset(qlafx00_isp_ops_group1, ldvarg22, ldvarg21);
#line 6929
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6932
    if (ldv_state_variable_63 == 2) {
#line 6934
      qlafx00_lun_reset(qlafx00_isp_ops_group1, ldvarg22, ldvarg21);
#line 6936
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6939
    goto ldv_63129;
    case 11: ;
#line 6942
    if (ldv_state_variable_63 == 1) {
#line 6944
      qlafx00_fw_version_str(qlafx00_isp_ops_group0, ldvarg20);
#line 6946
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6949
    if (ldv_state_variable_63 == 2) {
#line 6951
      qlafx00_fw_version_str(qlafx00_isp_ops_group0, ldvarg20);
#line 6953
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6956
    goto ldv_63129;
    case 12: ;
#line 6959
    if (ldv_state_variable_63 == 1) {
#line 6961
      qlafx00_iospace_config(qlafx00_isp_ops_group2);
#line 6963
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6966
    if (ldv_state_variable_63 == 2) {
#line 6968
      qlafx00_iospace_config(qlafx00_isp_ops_group2);
#line 6970
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6973
    goto ldv_63129;
    case 13: ;
#line 6976
    if (ldv_state_variable_63 == 1) {
#line 6978
      qlafx00_initialize_adapter(qlafx00_isp_ops_group0);
#line 6980
      ldv_state_variable_63 = 1;
    } else {

    }
#line 6983
    if (ldv_state_variable_63 == 2) {
#line 6985
      qlafx00_initialize_adapter(qlafx00_isp_ops_group0);
#line 6987
      ldv_state_variable_63 = 2;
    } else {

    }
#line 6990
    goto ldv_63129;
    case 14: ;
#line 6993
    if (ldv_state_variable_63 == 1) {
#line 6995
      qla24xx_get_flash_version(qlafx00_isp_ops_group0, ldvarg19);
#line 6997
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7000
    if (ldv_state_variable_63 == 2) {
#line 7002
      qla24xx_get_flash_version(qlafx00_isp_ops_group0, ldvarg19);
#line 7004
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7007
    goto ldv_63129;
    case 15: ;
#line 7010
    if (ldv_state_variable_63 == 1) {
#line 7012
      qlafx00_disable_intrs(qlafx00_isp_ops_group2);
#line 7014
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7017
    if (ldv_state_variable_63 == 2) {
#line 7019
      qlafx00_disable_intrs(qlafx00_isp_ops_group2);
#line 7021
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7024
    goto ldv_63129;
    case 16: ;
#line 7027
    if (ldv_state_variable_63 == 1) {
#line 7029
      qlafx00_pci_info_str(qlafx00_isp_ops_group0, ldvarg18);
#line 7031
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7034
    if (ldv_state_variable_63 == 2) {
#line 7036
      qlafx00_pci_info_str(qlafx00_isp_ops_group0, ldvarg18);
#line 7038
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7041
    goto ldv_63129;
    case 17: ;
#line 7044
    if (ldv_state_variable_63 == 2) {
#line 7046
      qla24xx_read_optrom_data(qlafx00_isp_ops_group0, ldvarg17, ldvarg16, ldvarg15);
#line 7048
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7051
    goto ldv_63129;
    case 18: ;
#line 7054
    if (ldv_state_variable_63 == 1) {
#line 7056
      qla24xx_beacon_off(qlafx00_isp_ops_group0);
#line 7058
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7061
    if (ldv_state_variable_63 == 2) {
#line 7063
      qla24xx_beacon_off(qlafx00_isp_ops_group0);
#line 7065
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7068
    goto ldv_63129;
    case 19: ;
#line 7071
    if (ldv_state_variable_63 == 1) {
#line 7073
      qlafx00_abort_command(ldvarg14);
#line 7075
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7078
    if (ldv_state_variable_63 == 2) {
#line 7080
      qlafx00_abort_command(ldvarg14);
#line 7082
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7085
    goto ldv_63129;
    case 20: ;
#line 7088
    if (ldv_state_variable_63 == 1) {
#line 7090
      qlafx00_config_rings(qlafx00_isp_ops_group0);
#line 7092
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7095
    if (ldv_state_variable_63 == 2) {
#line 7097
      qlafx00_config_rings(qlafx00_isp_ops_group0);
#line 7099
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7102
    goto ldv_63129;
    case 21: ;
#line 7105
    if (ldv_state_variable_63 == 1) {
#line 7107
      qlafx00_pci_config(qlafx00_isp_ops_group0);
#line 7109
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7112
    if (ldv_state_variable_63 == 2) {
#line 7114
      qlafx00_pci_config(qlafx00_isp_ops_group0);
#line 7116
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7119
    goto ldv_63129;
    case 22: ;
#line 7122
    if (ldv_state_variable_63 == 1) {
#line 7124
      qla24xx_write_nvram_data(qlafx00_isp_ops_group0, ldvarg13, ldvarg12, ldvarg11);
#line 7126
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7129
    if (ldv_state_variable_63 == 2) {
#line 7131
      qla24xx_write_nvram_data(qlafx00_isp_ops_group0, ldvarg13, ldvarg12, ldvarg11);
#line 7133
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7136
    goto ldv_63129;
    case 23: ;
#line 7139
    if (ldv_state_variable_63 == 1) {
#line 7141
      qla24xx_beacon_on(qlafx00_isp_ops_group0);
#line 7143
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7146
    if (ldv_state_variable_63 == 2) {
#line 7148
      qla24xx_beacon_on(qlafx00_isp_ops_group0);
#line 7150
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7153
    goto ldv_63129;
    case 24: ;
#line 7156
    if (ldv_state_variable_63 == 1) {
#line 7158
      qla24xx_read_nvram_data(qlafx00_isp_ops_group0, ldvarg10, ldvarg9, ldvarg8);
#line 7160
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7163
    if (ldv_state_variable_63 == 2) {
#line 7165
      qla24xx_read_nvram_data(qlafx00_isp_ops_group0, ldvarg10, ldvarg9, ldvarg8);
#line 7167
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7170
    goto ldv_63129;
    case 25: ;
#line 7173
    if (ldv_state_variable_63 == 1) {
#line 7175
      qla24xx_prep_ms_fdmi_iocb(qlafx00_isp_ops_group0, ldvarg7, ldvarg6);
#line 7177
      ldv_state_variable_63 = 1;
    } else {

    }
#line 7180
    if (ldv_state_variable_63 == 2) {
#line 7182
      qla24xx_prep_ms_fdmi_iocb(qlafx00_isp_ops_group0, ldvarg7, ldvarg6);
#line 7184
      ldv_state_variable_63 = 2;
    } else {

    }
#line 7187
    goto ldv_63129;
    case 26: ;
#line 7190
    if (ldv_state_variable_63 == 2) {
#line 7192
      ldv_release_63();
#line 7194
      ldv_state_variable_63 = 1;
#line 7195
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 7198
    goto ldv_63129;
    case 27: ;
#line 7201
    if (ldv_state_variable_63 == 1) {
#line 7203
      ldv_probe_63();
#line 7205
      ldv_state_variable_63 = 2;
#line 7206
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 7209
    goto ldv_63129;
    default: 
#line 7210
    ldv_stop();
    }
    ldv_63129: ;
  } else {

  }
#line 7214
  goto ldv_63125;
  case 3: ;
#line 7218
  if (ldv_state_variable_21 != 0) {
#line 7219
    ldv_main_exported_21();
  } else {

  }
#line 7222
  goto ldv_63125;
  case 4: ;
#line 7226
  if (ldv_state_variable_71 != 0) {
#line 7227
    tmp___165 = __VERIFIER_nondet_int();
#line 7227
    switch (tmp___165) {
    case 0: ;
#line 7230
    if (ldv_state_variable_71 == 1) {
#line 7232
      qla2x00_reset_adapter(qla2100_isp_ops_group0);
#line 7234
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7237
    if (ldv_state_variable_71 == 2) {
#line 7239
      qla2x00_reset_adapter(qla2100_isp_ops_group0);
#line 7241
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7244
    goto ldv_63161;
    case 1: ;
#line 7247
    if (ldv_state_variable_71 == 1) {
#line 7249
      qla2x00_enable_intrs(qla2100_isp_ops_group2);
#line 7251
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7254
    if (ldv_state_variable_71 == 2) {
#line 7256
      qla2x00_enable_intrs(qla2100_isp_ops_group2);
#line 7258
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7261
    goto ldv_63161;
    case 2: ;
#line 7264
    if (ldv_state_variable_71 == 2) {
#line 7266
      qla2x00_write_optrom_data(qla2100_isp_ops_group0, ldvarg78, ldvarg77, ldvarg76);
#line 7268
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7271
    goto ldv_63161;
    case 3: ;
#line 7274
    if (ldv_state_variable_71 == 1) {
#line 7276
      qla2100_intr_handler(ldvarg74, ldvarg75);
#line 7278
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7281
    if (ldv_state_variable_71 == 2) {
#line 7283
      qla2100_intr_handler(ldvarg74, ldvarg75);
#line 7285
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7288
    goto ldv_63161;
    case 4: ;
#line 7291
    if (ldv_state_variable_71 == 1) {
#line 7293
      qla2x00_abort_target(qla2100_isp_ops_group1, ldvarg73, ldvarg72);
#line 7295
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7298
    if (ldv_state_variable_71 == 2) {
#line 7300
      qla2x00_abort_target(qla2100_isp_ops_group1, ldvarg73, ldvarg72);
#line 7302
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7305
    goto ldv_63161;
    case 5: ;
#line 7308
    if (ldv_state_variable_71 == 1) {
#line 7310
      qla2x00_update_fw_options(qla2100_isp_ops_group0);
#line 7312
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7315
    if (ldv_state_variable_71 == 2) {
#line 7317
      qla2x00_update_fw_options(qla2100_isp_ops_group0);
#line 7319
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7322
    goto ldv_63161;
    case 6: ;
#line 7325
    if (ldv_state_variable_71 == 1) {
#line 7327
      qla2x00_start_scsi(ldvarg71);
#line 7329
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7332
    if (ldv_state_variable_71 == 2) {
#line 7334
      qla2x00_start_scsi(ldvarg71);
#line 7336
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7339
    goto ldv_63161;
    case 7: ;
#line 7342
    if (ldv_state_variable_71 == 1) {
#line 7344
      qla2x00_abort_isp(qla2100_isp_ops_group0);
#line 7346
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7349
    if (ldv_state_variable_71 == 2) {
#line 7351
      qla2x00_abort_isp(qla2100_isp_ops_group0);
#line 7353
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7356
    goto ldv_63161;
    case 8: ;
#line 7359
    if (ldv_state_variable_71 == 1) {
#line 7361
      qla2x00_chip_diag(qla2100_isp_ops_group0);
#line 7363
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7366
    if (ldv_state_variable_71 == 2) {
#line 7368
      qla2x00_chip_diag(qla2100_isp_ops_group0);
#line 7370
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7373
    goto ldv_63161;
    case 9: ;
#line 7376
    if (ldv_state_variable_71 == 1) {
#line 7378
      qla2x00_fabric_logout(qla2100_isp_ops_group0, (int )ldvarg69, (int )ldvarg68,
                            (int )ldvarg67, (int )ldvarg70);
#line 7380
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7383
    if (ldv_state_variable_71 == 2) {
#line 7385
      qla2x00_fabric_logout(qla2100_isp_ops_group0, (int )ldvarg69, (int )ldvarg68,
                            (int )ldvarg67, (int )ldvarg70);
#line 7387
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7390
    goto ldv_63161;
    case 10: ;
#line 7393
    if (ldv_state_variable_71 == 1) {
#line 7395
      qla2x00_reset_chip(qla2100_isp_ops_group0);
#line 7397
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7400
    if (ldv_state_variable_71 == 2) {
#line 7402
      qla2x00_reset_chip(qla2100_isp_ops_group0);
#line 7404
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7407
    goto ldv_63161;
    case 11: ;
#line 7410
    if (ldv_state_variable_71 == 1) {
#line 7412
      qla2x00_prep_ms_iocb(qla2100_isp_ops_group0, ldvarg66, ldvarg65);
#line 7414
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7417
    if (ldv_state_variable_71 == 2) {
#line 7419
      qla2x00_prep_ms_iocb(qla2100_isp_ops_group0, ldvarg66, ldvarg65);
#line 7421
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7424
    goto ldv_63161;
    case 12: ;
#line 7427
    if (ldv_state_variable_71 == 1) {
#line 7429
      qla2x00_lun_reset(qla2100_isp_ops_group1, ldvarg64, ldvarg63);
#line 7431
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7434
    if (ldv_state_variable_71 == 2) {
#line 7436
      qla2x00_lun_reset(qla2100_isp_ops_group1, ldvarg64, ldvarg63);
#line 7438
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7441
    goto ldv_63161;
    case 13: ;
#line 7444
    if (ldv_state_variable_71 == 1) {
#line 7446
      qla2x00_fw_version_str(qla2100_isp_ops_group0, ldvarg62);
#line 7448
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7451
    if (ldv_state_variable_71 == 2) {
#line 7453
      qla2x00_fw_version_str(qla2100_isp_ops_group0, ldvarg62);
#line 7455
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7458
    goto ldv_63161;
    case 14: ;
#line 7461
    if (ldv_state_variable_71 == 1) {
#line 7463
      qla2x00_iospace_config(qla2100_isp_ops_group2);
#line 7465
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7468
    if (ldv_state_variable_71 == 2) {
#line 7470
      qla2x00_iospace_config(qla2100_isp_ops_group2);
#line 7472
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7475
    goto ldv_63161;
    case 15: ;
#line 7478
    if (ldv_state_variable_71 == 1) {
#line 7480
      qla2x00_initialize_adapter(qla2100_isp_ops_group0);
#line 7482
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7485
    if (ldv_state_variable_71 == 2) {
#line 7487
      qla2x00_initialize_adapter(qla2100_isp_ops_group0);
#line 7489
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7492
    goto ldv_63161;
    case 16: ;
#line 7495
    if (ldv_state_variable_71 == 1) {
#line 7497
      qla2x00_disable_intrs(qla2100_isp_ops_group2);
#line 7499
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7502
    if (ldv_state_variable_71 == 2) {
#line 7504
      qla2x00_disable_intrs(qla2100_isp_ops_group2);
#line 7506
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7509
    goto ldv_63161;
    case 17: ;
#line 7512
    if (ldv_state_variable_71 == 1) {
#line 7514
      qla2x00_get_flash_version(qla2100_isp_ops_group0, ldvarg61);
#line 7516
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7519
    if (ldv_state_variable_71 == 2) {
#line 7521
      qla2x00_get_flash_version(qla2100_isp_ops_group0, ldvarg61);
#line 7523
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7526
    goto ldv_63161;
    case 18: ;
#line 7529
    if (ldv_state_variable_71 == 1) {
#line 7531
      qla2x00_calc_iocbs_32((int )ldvarg60);
#line 7533
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7536
    if (ldv_state_variable_71 == 2) {
#line 7538
      qla2x00_calc_iocbs_32((int )ldvarg60);
#line 7540
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7543
    goto ldv_63161;
    case 19: ;
#line 7546
    if (ldv_state_variable_71 == 1) {
#line 7548
      qla2x00_nvram_config(qla2100_isp_ops_group0);
#line 7550
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7553
    if (ldv_state_variable_71 == 2) {
#line 7555
      qla2x00_nvram_config(qla2100_isp_ops_group0);
#line 7557
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7560
    goto ldv_63161;
    case 20: ;
#line 7563
    if (ldv_state_variable_71 == 1) {
#line 7565
      qla2x00_pci_info_str(qla2100_isp_ops_group0, ldvarg59);
#line 7567
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7570
    if (ldv_state_variable_71 == 2) {
#line 7572
      qla2x00_pci_info_str(qla2100_isp_ops_group0, ldvarg59);
#line 7574
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7577
    goto ldv_63161;
    case 21: ;
#line 7580
    if (ldv_state_variable_71 == 2) {
#line 7582
      qla2x00_read_optrom_data(qla2100_isp_ops_group0, ldvarg58, ldvarg57, ldvarg56);
#line 7584
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7587
    goto ldv_63161;
    case 22: ;
#line 7590
    if (ldv_state_variable_71 == 1) {
#line 7592
      qla2x00_build_scsi_iocbs_32(ldvarg53, ldvarg55, (int )ldvarg54);
#line 7594
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7597
    if (ldv_state_variable_71 == 2) {
#line 7599
      qla2x00_build_scsi_iocbs_32(ldvarg53, ldvarg55, (int )ldvarg54);
#line 7601
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7604
    goto ldv_63161;
    case 23: ;
#line 7607
    if (ldv_state_variable_71 == 1) {
#line 7609
      qla2x00_abort_command(ldvarg52);
#line 7611
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7614
    if (ldv_state_variable_71 == 2) {
#line 7616
      qla2x00_abort_command(ldvarg52);
#line 7618
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7621
    goto ldv_63161;
    case 24: ;
#line 7624
    if (ldv_state_variable_71 == 1) {
#line 7626
      qla2100_fw_dump(qla2100_isp_ops_group0, ldvarg51);
#line 7628
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7631
    if (ldv_state_variable_71 == 2) {
#line 7633
      qla2100_fw_dump(qla2100_isp_ops_group0, ldvarg51);
#line 7635
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7638
    goto ldv_63161;
    case 25: ;
#line 7641
    if (ldv_state_variable_71 == 1) {
#line 7643
      qla2x00_config_rings(qla2100_isp_ops_group0);
#line 7645
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7648
    if (ldv_state_variable_71 == 2) {
#line 7650
      qla2x00_config_rings(qla2100_isp_ops_group0);
#line 7652
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7655
    goto ldv_63161;
    case 26: ;
#line 7658
    if (ldv_state_variable_71 == 1) {
#line 7660
      qla2x00_load_risc(qla2100_isp_ops_group0, ldvarg50);
#line 7662
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7665
    if (ldv_state_variable_71 == 2) {
#line 7667
      qla2x00_load_risc(qla2100_isp_ops_group0, ldvarg50);
#line 7669
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7672
    goto ldv_63161;
    case 27: ;
#line 7675
    if (ldv_state_variable_71 == 1) {
#line 7677
      qla2100_pci_config(qla2100_isp_ops_group0);
#line 7679
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7682
    if (ldv_state_variable_71 == 2) {
#line 7684
      qla2100_pci_config(qla2100_isp_ops_group0);
#line 7686
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7689
    goto ldv_63161;
    case 28: ;
#line 7692
    if (ldv_state_variable_71 == 1) {
#line 7694
      qla2x00_login_fabric(qla2100_isp_ops_group0, (int )ldvarg48, (int )ldvarg46,
                           (int )ldvarg45, (int )ldvarg49, ldvarg44, (int )ldvarg47);
#line 7696
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7699
    if (ldv_state_variable_71 == 2) {
#line 7701
      qla2x00_login_fabric(qla2100_isp_ops_group0, (int )ldvarg48, (int )ldvarg46,
                           (int )ldvarg45, (int )ldvarg49, ldvarg44, (int )ldvarg47);
#line 7703
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7706
    goto ldv_63161;
    case 29: ;
#line 7709
    if (ldv_state_variable_71 == 1) {
#line 7711
      qla2x00_write_nvram_data(qla2100_isp_ops_group0, ldvarg43, ldvarg42, ldvarg41);
#line 7713
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7716
    if (ldv_state_variable_71 == 2) {
#line 7718
      qla2x00_write_nvram_data(qla2100_isp_ops_group0, ldvarg43, ldvarg42, ldvarg41);
#line 7720
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7723
    goto ldv_63161;
    case 30: ;
#line 7726
    if (ldv_state_variable_71 == 1) {
#line 7728
      qla2x00_read_nvram_data(qla2100_isp_ops_group0, ldvarg40, ldvarg39, ldvarg38);
#line 7730
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7733
    if (ldv_state_variable_71 == 2) {
#line 7735
      qla2x00_read_nvram_data(qla2100_isp_ops_group0, ldvarg40, ldvarg39, ldvarg38);
#line 7737
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7740
    goto ldv_63161;
    case 31: ;
#line 7743
    if (ldv_state_variable_71 == 1) {
#line 7745
      qla2x00_prep_ms_fdmi_iocb(qla2100_isp_ops_group0, ldvarg37, ldvarg36);
#line 7747
      ldv_state_variable_71 = 1;
    } else {

    }
#line 7750
    if (ldv_state_variable_71 == 2) {
#line 7752
      qla2x00_prep_ms_fdmi_iocb(qla2100_isp_ops_group0, ldvarg37, ldvarg36);
#line 7754
      ldv_state_variable_71 = 2;
    } else {

    }
#line 7757
    goto ldv_63161;
    case 32: ;
#line 7760
    if (ldv_state_variable_71 == 2) {
#line 7762
      ldv_release_71();
#line 7764
      ldv_state_variable_71 = 1;
#line 7765
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 7768
    goto ldv_63161;
    case 33: ;
#line 7771
    if (ldv_state_variable_71 == 1) {
#line 7773
      ldv_probe_71();
#line 7775
      ldv_state_variable_71 = 2;
#line 7776
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 7779
    goto ldv_63161;
    default: 
#line 7780
    ldv_stop();
    }
    ldv_63161: ;
  } else {

  }
#line 7784
  goto ldv_63125;
  case 5: ;
#line 7791
  goto ldv_63125;
  case 6: ;
#line 7795
  if (ldv_state_variable_26 != 0) {
#line 7796
    ldv_main_exported_26();
  } else {

  }
#line 7799
  goto ldv_63125;
  case 7: ;
#line 7803
  if (ldv_state_variable_18 != 0) {
#line 7804
    ldv_main_exported_18();
  } else {

  }
#line 7807
  goto ldv_63125;
  case 8: ;
#line 7811
  if (ldv_state_variable_72 != 0) {
#line 7812
    tmp___166 = __VERIFIER_nondet_int();
#line 7812
    switch (tmp___166) {
    case 0: ;
#line 7815
    if (ldv_state_variable_72 == 1) {
#line 7817
      qla2xxx_scan_finished(qla2xxx_driver_template_group1, ldvarg90);
#line 7819
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7822
    goto ldv_63201;
    case 1: ;
#line 7825
    if (ldv_state_variable_72 == 1) {
#line 7827
      qla2xxx_slave_configure(qla2xxx_driver_template_group2);
#line 7829
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7832
    goto ldv_63201;
    case 2: ;
#line 7835
    if (ldv_state_variable_72 == 1) {
#line 7837
      qla2x00_change_queue_depth(qla2xxx_driver_template_group2, ldvarg89, ldvarg88);
#line 7839
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7842
    goto ldv_63201;
    case 3: ;
#line 7845
    if (ldv_state_variable_72 == 1) {
#line 7847
      qla2xxx_queuecommand(qla2xxx_driver_template_group1, qla2xxx_driver_template_group0);
#line 7849
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7852
    goto ldv_63201;
    case 4: ;
#line 7855
    if (ldv_state_variable_72 == 1) {
#line 7857
      qla2xxx_eh_target_reset(qla2xxx_driver_template_group0);
#line 7859
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7862
    goto ldv_63201;
    case 5: ;
#line 7865
    if (ldv_state_variable_72 == 1) {
#line 7867
      qla2xxx_eh_device_reset(qla2xxx_driver_template_group0);
#line 7869
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7872
    goto ldv_63201;
    case 6: ;
#line 7875
    if (ldv_state_variable_72 == 1) {
#line 7877
      qla2xxx_scan_start(qla2xxx_driver_template_group1);
#line 7879
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7882
    goto ldv_63201;
    case 7: ;
#line 7885
    if (ldv_state_variable_72 == 1) {
#line 7887
      qla2xxx_eh_abort(qla2xxx_driver_template_group0);
#line 7889
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7892
    goto ldv_63201;
    case 8: ;
#line 7895
    if (ldv_state_variable_72 == 1) {
#line 7897
      qla2xxx_slave_alloc(qla2xxx_driver_template_group2);
#line 7899
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7902
    goto ldv_63201;
    case 9: ;
#line 7905
    if (ldv_state_variable_72 == 1) {
#line 7907
      qla2xxx_slave_destroy(qla2xxx_driver_template_group2);
#line 7909
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7912
    goto ldv_63201;
    case 10: ;
#line 7915
    if (ldv_state_variable_72 == 1) {
#line 7917
      qla2x00_change_queue_type(qla2xxx_driver_template_group2, ldvarg87);
#line 7919
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7922
    goto ldv_63201;
    case 11: ;
#line 7925
    if (ldv_state_variable_72 == 1) {
#line 7927
      qla2xxx_eh_bus_reset(qla2xxx_driver_template_group0);
#line 7929
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7932
    goto ldv_63201;
    case 12: ;
#line 7935
    if (ldv_state_variable_72 == 1) {
#line 7937
      qla2xxx_eh_host_reset(qla2xxx_driver_template_group0);
#line 7939
      ldv_state_variable_72 = 1;
    } else {

    }
#line 7942
    goto ldv_63201;
    default: 
#line 7943
    ldv_stop();
    }
    ldv_63201: ;
  } else {

  }
#line 7947
  goto ldv_63125;
  case 9: ;
#line 7954
  goto ldv_63125;
  case 10: ;
#line 7958
  if (ldv_state_variable_44 != 0) {
#line 7959
    ldv_main_exported_44();
  } else {

  }
#line 7962
  goto ldv_63125;
  case 11: ;
#line 7966
  if (ldv_state_variable_55 != 0) {
#line 7967
    ldv_main_exported_55();
  } else {

  }
#line 7970
  goto ldv_63125;
  case 12: ;
#line 7974
  if (ldv_state_variable_27 != 0) {
#line 7975
    ldv_main_exported_27();
  } else {

  }
#line 7978
  goto ldv_63125;
  case 13: ;
#line 7982
  if (ldv_state_variable_57 != 0) {
#line 7983
    ldv_main_exported_57();
  } else {

  }
#line 7986
  goto ldv_63125;
  case 14: ;
#line 7990
  if (ldv_state_variable_61 != 0) {
#line 7991
    tmp___167 = __VERIFIER_nondet_int();
#line 7991
    switch (tmp___167) {
    case 0: ;
#line 7994
    if (ldv_state_variable_61 == 1) {
#line 7996
      ldv_retval_1 = qla2x00_probe_one(qla2xxx_pci_driver_group0, (struct pci_device_id  const  *)ldvarg109);
#line 7998
      if (ldv_retval_1 == 0) {
#line 7999
        ldv_state_variable_61 = 2;
#line 8000
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 8004
    goto ldv_63222;
    case 1: ;
#line 8007
    if (ldv_state_variable_61 == 2) {
#line 8009
      qla2x00_shutdown(qla2xxx_pci_driver_group0);
#line 8011
      ldv_state_variable_61 = 3;
    } else {

    }
#line 8014
    goto ldv_63222;
    case 2: ;
#line 8017
    if (ldv_state_variable_61 == 3) {
#line 8019
      qla2x00_remove_one(qla2xxx_pci_driver_group0);
#line 8021
      ldv_state_variable_61 = 1;
#line 8022
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 8025
    if (ldv_state_variable_61 == 2) {
#line 8027
      qla2x00_remove_one(qla2xxx_pci_driver_group0);
#line 8029
      ldv_state_variable_61 = 1;
#line 8030
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 8033
    goto ldv_63222;
    default: 
#line 8034
    ldv_stop();
    }
    ldv_63222: ;
  } else {

  }
#line 8038
  goto ldv_63125;
  case 15: ;
#line 8042
  if (ldv_state_variable_20 != 0) {
#line 8043
    ldv_main_exported_20();
  } else {

  }
#line 8046
  goto ldv_63125;
  case 16: ;
#line 8053
  goto ldv_63125;
  case 17: ;
#line 8057
  if (ldv_state_variable_31 != 0) {
#line 8058
    ldv_main_exported_31();
  } else {

  }
#line 8061
  goto ldv_63125;
  case 18: ;
#line 8065
  if (ldv_state_variable_35 != 0) {
#line 8066
    ldv_main_exported_35();
  } else {

  }
#line 8069
  goto ldv_63125;
  case 19: ;
#line 8076
  goto ldv_63125;
  case 20: ;
#line 8080
  if (ldv_state_variable_48 != 0) {
#line 8081
    ldv_main_exported_48();
  } else {

  }
#line 8084
  goto ldv_63125;
  case 21: ;
#line 8088
  if (ldv_state_variable_65 != 0) {
#line 8089
    tmp___168 = __VERIFIER_nondet_int();
#line 8089
    switch (tmp___168) {
    case 0: ;
#line 8092
    if (ldv_state_variable_65 == 1) {
#line 8094
      qla24xx_reset_adapter(qla8044_isp_ops_group0);
#line 8096
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8099
    if (ldv_state_variable_65 == 2) {
#line 8101
      qla24xx_reset_adapter(qla8044_isp_ops_group0);
#line 8103
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8106
    goto ldv_63234;
    case 1: ;
#line 8109
    if (ldv_state_variable_65 == 2) {
#line 8111
      qla8044_write_optrom_data(qla8044_isp_ops_group0, ldvarg154, ldvarg153, ldvarg152);
#line 8113
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8116
    goto ldv_63234;
    case 2: ;
#line 8119
    if (ldv_state_variable_65 == 1) {
#line 8121
      qla82xx_enable_intrs(qla8044_isp_ops_group2);
#line 8123
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8126
    if (ldv_state_variable_65 == 2) {
#line 8128
      qla82xx_enable_intrs(qla8044_isp_ops_group2);
#line 8130
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8133
    goto ldv_63234;
    case 3: ;
#line 8136
    if (ldv_state_variable_65 == 1) {
#line 8138
      qla8044_intr_handler(ldvarg150, ldvarg151);
#line 8140
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8143
    if (ldv_state_variable_65 == 2) {
#line 8145
      qla8044_intr_handler(ldvarg150, ldvarg151);
#line 8147
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8150
    goto ldv_63234;
    case 4: ;
#line 8153
    if (ldv_state_variable_65 == 1) {
#line 8155
      qla24xx_abort_target(qla8044_isp_ops_group1, ldvarg149, ldvarg148);
#line 8157
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8160
    if (ldv_state_variable_65 == 2) {
#line 8162
      qla24xx_abort_target(qla8044_isp_ops_group1, ldvarg149, ldvarg148);
#line 8164
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8167
    goto ldv_63234;
    case 5: ;
#line 8170
    if (ldv_state_variable_65 == 1) {
#line 8172
      qla24xx_update_fw_options(qla8044_isp_ops_group0);
#line 8174
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8177
    if (ldv_state_variable_65 == 2) {
#line 8179
      qla24xx_update_fw_options(qla8044_isp_ops_group0);
#line 8181
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8184
    goto ldv_63234;
    case 6: ;
#line 8187
    if (ldv_state_variable_65 == 1) {
#line 8189
      qla8044_abort_isp(qla8044_isp_ops_group0);
#line 8191
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8194
    if (ldv_state_variable_65 == 2) {
#line 8196
      qla8044_abort_isp(qla8044_isp_ops_group0);
#line 8198
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8201
    goto ldv_63234;
    case 7: ;
#line 8204
    if (ldv_state_variable_65 == 1) {
#line 8206
      qla82xx_start_scsi(ldvarg147);
#line 8208
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8211
    if (ldv_state_variable_65 == 2) {
#line 8213
      qla82xx_start_scsi(ldvarg147);
#line 8215
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8218
    goto ldv_63234;
    case 8: ;
#line 8221
    if (ldv_state_variable_65 == 1) {
#line 8223
      qla24xx_chip_diag(qla8044_isp_ops_group0);
#line 8225
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8228
    if (ldv_state_variable_65 == 2) {
#line 8230
      qla24xx_chip_diag(qla8044_isp_ops_group0);
#line 8232
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8235
    goto ldv_63234;
    case 9: ;
#line 8238
    if (ldv_state_variable_65 == 1) {
#line 8240
      qla24xx_fabric_logout(qla8044_isp_ops_group0, (int )ldvarg145, (int )ldvarg144,
                            (int )ldvarg143, (int )ldvarg146);
#line 8242
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8245
    if (ldv_state_variable_65 == 2) {
#line 8247
      qla24xx_fabric_logout(qla8044_isp_ops_group0, (int )ldvarg145, (int )ldvarg144,
                            (int )ldvarg143, (int )ldvarg146);
#line 8249
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8252
    goto ldv_63234;
    case 10: ;
#line 8255
    if (ldv_state_variable_65 == 1) {
#line 8257
      qla82xx_reset_chip(qla8044_isp_ops_group0);
#line 8259
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8262
    if (ldv_state_variable_65 == 2) {
#line 8264
      qla82xx_reset_chip(qla8044_isp_ops_group0);
#line 8266
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8269
    goto ldv_63234;
    case 11: ;
#line 8272
    if (ldv_state_variable_65 == 1) {
#line 8274
      qla24xx_prep_ms_iocb(qla8044_isp_ops_group0, ldvarg142, ldvarg141);
#line 8276
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8279
    if (ldv_state_variable_65 == 2) {
#line 8281
      qla24xx_prep_ms_iocb(qla8044_isp_ops_group0, ldvarg142, ldvarg141);
#line 8283
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8286
    goto ldv_63234;
    case 12: ;
#line 8289
    if (ldv_state_variable_65 == 1) {
#line 8291
      qla24xx_lun_reset(qla8044_isp_ops_group1, ldvarg140, ldvarg139);
#line 8293
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8296
    if (ldv_state_variable_65 == 2) {
#line 8298
      qla24xx_lun_reset(qla8044_isp_ops_group1, ldvarg140, ldvarg139);
#line 8300
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8303
    goto ldv_63234;
    case 13: ;
#line 8306
    if (ldv_state_variable_65 == 1) {
#line 8308
      qla24xx_fw_version_str(qla8044_isp_ops_group0, ldvarg138);
#line 8310
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8313
    if (ldv_state_variable_65 == 2) {
#line 8315
      qla24xx_fw_version_str(qla8044_isp_ops_group0, ldvarg138);
#line 8317
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8320
    goto ldv_63234;
    case 14: ;
#line 8323
    if (ldv_state_variable_65 == 1) {
#line 8325
      qla82xx_iospace_config(qla8044_isp_ops_group2);
#line 8327
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8330
    if (ldv_state_variable_65 == 2) {
#line 8332
      qla82xx_iospace_config(qla8044_isp_ops_group2);
#line 8334
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8337
    goto ldv_63234;
    case 15: ;
#line 8340
    if (ldv_state_variable_65 == 1) {
#line 8342
      qla2x00_initialize_adapter(qla8044_isp_ops_group0);
#line 8344
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8347
    if (ldv_state_variable_65 == 2) {
#line 8349
      qla2x00_initialize_adapter(qla8044_isp_ops_group0);
#line 8351
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8354
    goto ldv_63234;
    case 16: ;
#line 8357
    if (ldv_state_variable_65 == 1) {
#line 8359
      qla82xx_get_flash_version(qla8044_isp_ops_group0, ldvarg137);
#line 8361
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8364
    if (ldv_state_variable_65 == 2) {
#line 8366
      qla82xx_get_flash_version(qla8044_isp_ops_group0, ldvarg137);
#line 8368
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8371
    goto ldv_63234;
    case 17: ;
#line 8374
    if (ldv_state_variable_65 == 1) {
#line 8376
      qla82xx_disable_intrs(qla8044_isp_ops_group2);
#line 8378
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8381
    if (ldv_state_variable_65 == 2) {
#line 8383
      qla82xx_disable_intrs(qla8044_isp_ops_group2);
#line 8385
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8388
    goto ldv_63234;
    case 18: ;
#line 8391
    if (ldv_state_variable_65 == 1) {
#line 8393
      qla81xx_nvram_config(qla8044_isp_ops_group0);
#line 8395
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8398
    if (ldv_state_variable_65 == 2) {
#line 8400
      qla81xx_nvram_config(qla8044_isp_ops_group0);
#line 8402
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8405
    goto ldv_63234;
    case 19: ;
#line 8408
    if (ldv_state_variable_65 == 1) {
#line 8410
      qla24xx_pci_info_str(qla8044_isp_ops_group0, ldvarg136);
#line 8412
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8415
    if (ldv_state_variable_65 == 2) {
#line 8417
      qla24xx_pci_info_str(qla8044_isp_ops_group0, ldvarg136);
#line 8419
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8422
    goto ldv_63234;
    case 20: ;
#line 8425
    if (ldv_state_variable_65 == 2) {
#line 8427
      qla82xx_read_optrom_data(qla8044_isp_ops_group0, ldvarg135, ldvarg134, ldvarg133);
#line 8429
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8432
    goto ldv_63234;
    case 21: ;
#line 8435
    if (ldv_state_variable_65 == 1) {
#line 8437
      qla82xx_beacon_off(qla8044_isp_ops_group0);
#line 8439
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8442
    if (ldv_state_variable_65 == 2) {
#line 8444
      qla82xx_beacon_off(qla8044_isp_ops_group0);
#line 8446
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8449
    goto ldv_63234;
    case 22: ;
#line 8452
    if (ldv_state_variable_65 == 1) {
#line 8454
      qla24xx_abort_command(ldvarg132);
#line 8456
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8459
    if (ldv_state_variable_65 == 2) {
#line 8461
      qla24xx_abort_command(ldvarg132);
#line 8463
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8466
    goto ldv_63234;
    case 23: ;
#line 8469
    if (ldv_state_variable_65 == 1) {
#line 8471
      qla24xx_fw_dump(qla8044_isp_ops_group0, ldvarg131);
#line 8473
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8476
    if (ldv_state_variable_65 == 2) {
#line 8478
      qla24xx_fw_dump(qla8044_isp_ops_group0, ldvarg131);
#line 8480
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8483
    goto ldv_63234;
    case 24: ;
#line 8486
    if (ldv_state_variable_65 == 1) {
#line 8488
      qla82xx_config_rings(qla8044_isp_ops_group0);
#line 8490
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8493
    if (ldv_state_variable_65 == 2) {
#line 8495
      qla82xx_config_rings(qla8044_isp_ops_group0);
#line 8497
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8500
    goto ldv_63234;
    case 25: ;
#line 8503
    if (ldv_state_variable_65 == 1) {
#line 8505
      qla82xx_load_risc(qla8044_isp_ops_group0, ldvarg130);
#line 8507
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8510
    if (ldv_state_variable_65 == 2) {
#line 8512
      qla82xx_load_risc(qla8044_isp_ops_group0, ldvarg130);
#line 8514
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8517
    goto ldv_63234;
    case 26: ;
#line 8520
    if (ldv_state_variable_65 == 1) {
#line 8522
      qla82xx_pci_config(qla8044_isp_ops_group0);
#line 8524
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8527
    if (ldv_state_variable_65 == 2) {
#line 8529
      qla82xx_pci_config(qla8044_isp_ops_group0);
#line 8531
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8534
    goto ldv_63234;
    case 27: ;
#line 8537
    if (ldv_state_variable_65 == 1) {
#line 8539
      qla24xx_login_fabric(qla8044_isp_ops_group0, (int )ldvarg128, (int )ldvarg126,
                           (int )ldvarg125, (int )ldvarg129, ldvarg124, (int )ldvarg127);
#line 8541
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8544
    if (ldv_state_variable_65 == 2) {
#line 8546
      qla24xx_login_fabric(qla8044_isp_ops_group0, (int )ldvarg128, (int )ldvarg126,
                           (int )ldvarg125, (int )ldvarg129, ldvarg124, (int )ldvarg127);
#line 8548
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8551
    goto ldv_63234;
    case 28: ;
#line 8554
    if (ldv_state_variable_65 == 1) {
#line 8556
      qla82xx_beacon_on(qla8044_isp_ops_group0);
#line 8558
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8561
    if (ldv_state_variable_65 == 2) {
#line 8563
      qla82xx_beacon_on(qla8044_isp_ops_group0);
#line 8565
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8568
    goto ldv_63234;
    case 29: ;
#line 8571
    if (ldv_state_variable_65 == 1) {
#line 8573
      qla24xx_prep_ms_fdmi_iocb(qla8044_isp_ops_group0, ldvarg123, ldvarg122);
#line 8575
      ldv_state_variable_65 = 1;
    } else {

    }
#line 8578
    if (ldv_state_variable_65 == 2) {
#line 8580
      qla24xx_prep_ms_fdmi_iocb(qla8044_isp_ops_group0, ldvarg123, ldvarg122);
#line 8582
      ldv_state_variable_65 = 2;
    } else {

    }
#line 8585
    goto ldv_63234;
    case 30: ;
#line 8588
    if (ldv_state_variable_65 == 2) {
#line 8590
      ldv_release_65();
#line 8592
      ldv_state_variable_65 = 1;
#line 8593
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 8596
    goto ldv_63234;
    case 31: ;
#line 8599
    if (ldv_state_variable_65 == 1) {
#line 8601
      ldv_probe_65();
#line 8603
      ldv_state_variable_65 = 2;
#line 8604
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 8607
    goto ldv_63234;
    default: 
#line 8608
    ldv_stop();
    }
    ldv_63234: ;
  } else {

  }
#line 8612
  goto ldv_63125;
  case 22: ;
#line 8616
  if (ldv_state_variable_29 != 0) {
#line 8617
    ldv_main_exported_29();
  } else {

  }
#line 8620
  goto ldv_63125;
  case 23: ;
#line 8624
  if (ldv_state_variable_50 != 0) {
#line 8625
    ldv_main_exported_50();
  } else {

  }
#line 8628
  goto ldv_63125;
  case 24: ;
#line 8632
  if (ldv_state_variable_39 != 0) {
#line 8633
    ldv_main_exported_39();
  } else {

  }
#line 8636
  goto ldv_63125;
  case 25: ;
#line 8640
  if (ldv_state_variable_64 != 0) {
#line 8641
    tmp___169 = __VERIFIER_nondet_int();
#line 8641
    switch (tmp___169) {
    case 0: ;
#line 8644
    if (ldv_state_variable_64 == 1) {
#line 8646
      qla24xx_reset_adapter(qla83xx_isp_ops_group0);
#line 8648
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8651
    if (ldv_state_variable_64 == 2) {
#line 8653
      qla24xx_reset_adapter(qla83xx_isp_ops_group0);
#line 8655
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8658
    goto ldv_63272;
    case 1: ;
#line 8661
    if (ldv_state_variable_64 == 2) {
#line 8663
      qla24xx_write_optrom_data(qla83xx_isp_ops_group0, ldvarg196, ldvarg195, ldvarg194);
#line 8665
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8668
    goto ldv_63272;
    case 2: ;
#line 8671
    if (ldv_state_variable_64 == 1) {
#line 8673
      qla24xx_enable_intrs(qla83xx_isp_ops_group2);
#line 8675
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8678
    if (ldv_state_variable_64 == 2) {
#line 8680
      qla24xx_enable_intrs(qla83xx_isp_ops_group2);
#line 8682
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8685
    goto ldv_63272;
    case 3: ;
#line 8688
    if (ldv_state_variable_64 == 1) {
#line 8690
      qla24xx_intr_handler(ldvarg192, ldvarg193);
#line 8692
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8695
    if (ldv_state_variable_64 == 2) {
#line 8697
      qla24xx_intr_handler(ldvarg192, ldvarg193);
#line 8699
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8702
    goto ldv_63272;
    case 4: ;
#line 8705
    if (ldv_state_variable_64 == 1) {
#line 8707
      qla24xx_abort_target(qla83xx_isp_ops_group1, ldvarg191, ldvarg190);
#line 8709
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8712
    if (ldv_state_variable_64 == 2) {
#line 8714
      qla24xx_abort_target(qla83xx_isp_ops_group1, ldvarg191, ldvarg190);
#line 8716
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8719
    goto ldv_63272;
    case 5: ;
#line 8722
    if (ldv_state_variable_64 == 1) {
#line 8724
      qla81xx_update_fw_options(qla83xx_isp_ops_group0);
#line 8726
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8729
    if (ldv_state_variable_64 == 2) {
#line 8731
      qla81xx_update_fw_options(qla83xx_isp_ops_group0);
#line 8733
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8736
    goto ldv_63272;
    case 6: ;
#line 8739
    if (ldv_state_variable_64 == 1) {
#line 8741
      qla2x00_abort_isp(qla83xx_isp_ops_group0);
#line 8743
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8746
    if (ldv_state_variable_64 == 2) {
#line 8748
      qla2x00_abort_isp(qla83xx_isp_ops_group0);
#line 8750
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8753
    goto ldv_63272;
    case 7: ;
#line 8756
    if (ldv_state_variable_64 == 1) {
#line 8758
      qla24xx_dif_start_scsi(ldvarg189);
#line 8760
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8763
    if (ldv_state_variable_64 == 2) {
#line 8765
      qla24xx_dif_start_scsi(ldvarg189);
#line 8767
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8770
    goto ldv_63272;
    case 8: ;
#line 8773
    if (ldv_state_variable_64 == 1) {
#line 8775
      qla24xx_chip_diag(qla83xx_isp_ops_group0);
#line 8777
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8780
    if (ldv_state_variable_64 == 2) {
#line 8782
      qla24xx_chip_diag(qla83xx_isp_ops_group0);
#line 8784
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8787
    goto ldv_63272;
    case 9: ;
#line 8790
    if (ldv_state_variable_64 == 1) {
#line 8792
      qla24xx_fabric_logout(qla83xx_isp_ops_group0, (int )ldvarg187, (int )ldvarg186,
                            (int )ldvarg185, (int )ldvarg188);
#line 8794
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8797
    if (ldv_state_variable_64 == 2) {
#line 8799
      qla24xx_fabric_logout(qla83xx_isp_ops_group0, (int )ldvarg187, (int )ldvarg186,
                            (int )ldvarg185, (int )ldvarg188);
#line 8801
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8804
    goto ldv_63272;
    case 10: ;
#line 8807
    if (ldv_state_variable_64 == 1) {
#line 8809
      qla24xx_reset_chip(qla83xx_isp_ops_group0);
#line 8811
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8814
    if (ldv_state_variable_64 == 2) {
#line 8816
      qla24xx_reset_chip(qla83xx_isp_ops_group0);
#line 8818
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8821
    goto ldv_63272;
    case 11: ;
#line 8824
    if (ldv_state_variable_64 == 1) {
#line 8826
      qla24xx_prep_ms_iocb(qla83xx_isp_ops_group0, ldvarg184, ldvarg183);
#line 8828
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8831
    if (ldv_state_variable_64 == 2) {
#line 8833
      qla24xx_prep_ms_iocb(qla83xx_isp_ops_group0, ldvarg184, ldvarg183);
#line 8835
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8838
    goto ldv_63272;
    case 12: ;
#line 8841
    if (ldv_state_variable_64 == 1) {
#line 8843
      qla24xx_lun_reset(qla83xx_isp_ops_group1, ldvarg182, ldvarg181);
#line 8845
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8848
    if (ldv_state_variable_64 == 2) {
#line 8850
      qla24xx_lun_reset(qla83xx_isp_ops_group1, ldvarg182, ldvarg181);
#line 8852
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8855
    goto ldv_63272;
    case 13: ;
#line 8858
    if (ldv_state_variable_64 == 1) {
#line 8860
      qla24xx_fw_version_str(qla83xx_isp_ops_group0, ldvarg180);
#line 8862
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8865
    if (ldv_state_variable_64 == 2) {
#line 8867
      qla24xx_fw_version_str(qla83xx_isp_ops_group0, ldvarg180);
#line 8869
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8872
    goto ldv_63272;
    case 14: ;
#line 8875
    if (ldv_state_variable_64 == 1) {
#line 8877
      qla83xx_iospace_config(qla83xx_isp_ops_group2);
#line 8879
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8882
    if (ldv_state_variable_64 == 2) {
#line 8884
      qla83xx_iospace_config(qla83xx_isp_ops_group2);
#line 8886
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8889
    goto ldv_63272;
    case 15: ;
#line 8892
    if (ldv_state_variable_64 == 1) {
#line 8894
      qla2x00_initialize_adapter(qla83xx_isp_ops_group0);
#line 8896
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8899
    if (ldv_state_variable_64 == 2) {
#line 8901
      qla2x00_initialize_adapter(qla83xx_isp_ops_group0);
#line 8903
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8906
    goto ldv_63272;
    case 16: ;
#line 8909
    if (ldv_state_variable_64 == 1) {
#line 8911
      qla24xx_get_flash_version(qla83xx_isp_ops_group0, ldvarg179);
#line 8913
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8916
    if (ldv_state_variable_64 == 2) {
#line 8918
      qla24xx_get_flash_version(qla83xx_isp_ops_group0, ldvarg179);
#line 8920
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8923
    goto ldv_63272;
    case 17: ;
#line 8926
    if (ldv_state_variable_64 == 1) {
#line 8928
      qla24xx_disable_intrs(qla83xx_isp_ops_group2);
#line 8930
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8933
    if (ldv_state_variable_64 == 2) {
#line 8935
      qla24xx_disable_intrs(qla83xx_isp_ops_group2);
#line 8937
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8940
    goto ldv_63272;
    case 18: ;
#line 8943
    if (ldv_state_variable_64 == 1) {
#line 8945
      qla81xx_nvram_config(qla83xx_isp_ops_group0);
#line 8947
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8950
    if (ldv_state_variable_64 == 2) {
#line 8952
      qla81xx_nvram_config(qla83xx_isp_ops_group0);
#line 8954
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8957
    goto ldv_63272;
    case 19: ;
#line 8960
    if (ldv_state_variable_64 == 1) {
#line 8962
      qla24xx_pci_info_str(qla83xx_isp_ops_group0, ldvarg178);
#line 8964
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8967
    if (ldv_state_variable_64 == 2) {
#line 8969
      qla24xx_pci_info_str(qla83xx_isp_ops_group0, ldvarg178);
#line 8971
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8974
    goto ldv_63272;
    case 20: ;
#line 8977
    if (ldv_state_variable_64 == 2) {
#line 8979
      qla25xx_read_optrom_data(qla83xx_isp_ops_group0, ldvarg177, ldvarg176, ldvarg175);
#line 8981
      ldv_state_variable_64 = 2;
    } else {

    }
#line 8984
    goto ldv_63272;
    case 21: ;
#line 8987
    if (ldv_state_variable_64 == 1) {
#line 8989
      qla83xx_beacon_blink(qla83xx_isp_ops_group0);
#line 8991
      ldv_state_variable_64 = 1;
    } else {

    }
#line 8994
    if (ldv_state_variable_64 == 2) {
#line 8996
      qla83xx_beacon_blink(qla83xx_isp_ops_group0);
#line 8998
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9001
    goto ldv_63272;
    case 22: ;
#line 9004
    if (ldv_state_variable_64 == 1) {
#line 9006
      qla24xx_beacon_off(qla83xx_isp_ops_group0);
#line 9008
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9011
    if (ldv_state_variable_64 == 2) {
#line 9013
      qla24xx_beacon_off(qla83xx_isp_ops_group0);
#line 9015
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9018
    goto ldv_63272;
    case 23: ;
#line 9021
    if (ldv_state_variable_64 == 1) {
#line 9023
      qla24xx_abort_command(ldvarg174);
#line 9025
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9028
    if (ldv_state_variable_64 == 2) {
#line 9030
      qla24xx_abort_command(ldvarg174);
#line 9032
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9035
    goto ldv_63272;
    case 24: ;
#line 9038
    if (ldv_state_variable_64 == 1) {
#line 9040
      qla83xx_fw_dump(qla83xx_isp_ops_group0, ldvarg173);
#line 9042
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9045
    if (ldv_state_variable_64 == 2) {
#line 9047
      qla83xx_fw_dump(qla83xx_isp_ops_group0, ldvarg173);
#line 9049
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9052
    goto ldv_63272;
    case 25: ;
#line 9055
    if (ldv_state_variable_64 == 1) {
#line 9057
      qla24xx_config_rings(qla83xx_isp_ops_group0);
#line 9059
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9062
    if (ldv_state_variable_64 == 2) {
#line 9064
      qla24xx_config_rings(qla83xx_isp_ops_group0);
#line 9066
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9069
    goto ldv_63272;
    case 26: ;
#line 9072
    if (ldv_state_variable_64 == 1) {
#line 9074
      qla81xx_load_risc(qla83xx_isp_ops_group0, ldvarg172);
#line 9076
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9079
    if (ldv_state_variable_64 == 2) {
#line 9081
      qla81xx_load_risc(qla83xx_isp_ops_group0, ldvarg172);
#line 9083
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9086
    goto ldv_63272;
    case 27: ;
#line 9089
    if (ldv_state_variable_64 == 1) {
#line 9091
      qla25xx_pci_config(qla83xx_isp_ops_group0);
#line 9093
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9096
    if (ldv_state_variable_64 == 2) {
#line 9098
      qla25xx_pci_config(qla83xx_isp_ops_group0);
#line 9100
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9103
    goto ldv_63272;
    case 28: ;
#line 9106
    if (ldv_state_variable_64 == 1) {
#line 9108
      qla24xx_login_fabric(qla83xx_isp_ops_group0, (int )ldvarg170, (int )ldvarg168,
                           (int )ldvarg167, (int )ldvarg171, ldvarg166, (int )ldvarg169);
#line 9110
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9113
    if (ldv_state_variable_64 == 2) {
#line 9115
      qla24xx_login_fabric(qla83xx_isp_ops_group0, (int )ldvarg170, (int )ldvarg168,
                           (int )ldvarg167, (int )ldvarg171, ldvarg166, (int )ldvarg169);
#line 9117
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9120
    goto ldv_63272;
    case 29: ;
#line 9123
    if (ldv_state_variable_64 == 1) {
#line 9125
      qla24xx_beacon_on(qla83xx_isp_ops_group0);
#line 9127
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9130
    if (ldv_state_variable_64 == 2) {
#line 9132
      qla24xx_beacon_on(qla83xx_isp_ops_group0);
#line 9134
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9137
    goto ldv_63272;
    case 30: ;
#line 9140
    if (ldv_state_variable_64 == 1) {
#line 9142
      qla24xx_prep_ms_fdmi_iocb(qla83xx_isp_ops_group0, ldvarg165, ldvarg164);
#line 9144
      ldv_state_variable_64 = 1;
    } else {

    }
#line 9147
    if (ldv_state_variable_64 == 2) {
#line 9149
      qla24xx_prep_ms_fdmi_iocb(qla83xx_isp_ops_group0, ldvarg165, ldvarg164);
#line 9151
      ldv_state_variable_64 = 2;
    } else {

    }
#line 9154
    goto ldv_63272;
    case 31: ;
#line 9157
    if (ldv_state_variable_64 == 2) {
#line 9159
      ldv_release_64();
#line 9161
      ldv_state_variable_64 = 1;
#line 9162
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 9165
    goto ldv_63272;
    case 32: ;
#line 9168
    if (ldv_state_variable_64 == 1) {
#line 9170
      ldv_probe_64();
#line 9172
      ldv_state_variable_64 = 2;
#line 9173
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 9176
    goto ldv_63272;
    default: 
#line 9177
    ldv_stop();
    }
    ldv_63272: ;
  } else {

  }
#line 9181
  goto ldv_63125;
  case 26: ;
#line 9185
  if (ldv_state_variable_58 != 0) {
#line 9186
    ldv_main_exported_58();
  } else {

  }
#line 9189
  goto ldv_63125;
  case 27: ;
#line 9193
  if (ldv_state_variable_41 != 0) {
#line 9194
    ldv_main_exported_41();
  } else {

  }
#line 9197
  goto ldv_63125;
  case 28: ;
#line 9204
  goto ldv_63125;
  case 29: ;
#line 9211
  goto ldv_63125;
  case 30: ;
#line 9215
  if (ldv_state_variable_52 != 0) {
#line 9216
    ldv_main_exported_52();
  } else {

  }
#line 9219
  goto ldv_63125;
  case 31: ;
#line 9223
  if (ldv_state_variable_60 != 0) {
#line 9224
    tmp___170 = __VERIFIER_nondet_int();
#line 9224
    switch (tmp___170) {
    case 0: ;
#line 9227
    if (ldv_state_variable_60 == 2) {
#line 9229
      noop_llseek(apidev_fops_group2, ldvarg213, ldvarg212);
#line 9231
      ldv_state_variable_60 = 2;
    } else {

    }
#line 9234
    goto ldv_63313;
    case 1: ;
#line 9237
    if (ldv_state_variable_60 == 1) {
#line 9239
      ldv_retval_2 = ldv_open_60();
#line 9240
      if (ldv_retval_2 == 0) {
#line 9241
        ldv_state_variable_60 = 2;
#line 9242
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 9246
    goto ldv_63313;
    case 2: ;
#line 9249
    if (ldv_state_variable_60 == 2) {
#line 9251
      ldv_release_60();
#line 9252
      ldv_state_variable_60 = 1;
#line 9253
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 9256
    goto ldv_63313;
    default: 
#line 9257
    ldv_stop();
    }
    ldv_63313: ;
  } else {

  }
#line 9261
  goto ldv_63125;
  case 32: ;
#line 9265
  if (ldv_state_variable_56 != 0) {
#line 9266
    ldv_main_exported_56();
  } else {

  }
#line 9269
  goto ldv_63125;
  case 33: ;
#line 9273
  if (ldv_state_variable_66 != 0) {
#line 9274
    tmp___171 = __VERIFIER_nondet_int();
#line 9274
    switch (tmp___171) {
    case 0: ;
#line 9277
    if (ldv_state_variable_66 == 1) {
#line 9279
      qla24xx_reset_adapter(qla82xx_isp_ops_group0);
#line 9281
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9284
    if (ldv_state_variable_66 == 2) {
#line 9286
      qla24xx_reset_adapter(qla82xx_isp_ops_group0);
#line 9288
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9291
    goto ldv_63320;
    case 1: ;
#line 9294
    if (ldv_state_variable_66 == 2) {
#line 9296
      qla82xx_write_optrom_data(qla82xx_isp_ops_group0, ldvarg258, ldvarg257, ldvarg256);
#line 9298
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9301
    goto ldv_63320;
    case 2: ;
#line 9304
    if (ldv_state_variable_66 == 1) {
#line 9306
      qla82xx_enable_intrs(qla82xx_isp_ops_group2);
#line 9308
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9311
    if (ldv_state_variable_66 == 2) {
#line 9313
      qla82xx_enable_intrs(qla82xx_isp_ops_group2);
#line 9315
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9318
    goto ldv_63320;
    case 3: ;
#line 9321
    if (ldv_state_variable_66 == 1) {
#line 9323
      qla82xx_intr_handler(ldvarg254, ldvarg255);
#line 9325
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9328
    if (ldv_state_variable_66 == 2) {
#line 9330
      qla82xx_intr_handler(ldvarg254, ldvarg255);
#line 9332
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9335
    goto ldv_63320;
    case 4: ;
#line 9338
    if (ldv_state_variable_66 == 1) {
#line 9340
      qla24xx_abort_target(qla82xx_isp_ops_group1, ldvarg253, ldvarg252);
#line 9342
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9345
    if (ldv_state_variable_66 == 2) {
#line 9347
      qla24xx_abort_target(qla82xx_isp_ops_group1, ldvarg253, ldvarg252);
#line 9349
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9352
    goto ldv_63320;
    case 5: ;
#line 9355
    if (ldv_state_variable_66 == 1) {
#line 9357
      qla24xx_update_fw_options(qla82xx_isp_ops_group0);
#line 9359
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9362
    if (ldv_state_variable_66 == 2) {
#line 9364
      qla24xx_update_fw_options(qla82xx_isp_ops_group0);
#line 9366
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9369
    goto ldv_63320;
    case 6: ;
#line 9372
    if (ldv_state_variable_66 == 1) {
#line 9374
      qla82xx_abort_isp(qla82xx_isp_ops_group0);
#line 9376
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9379
    if (ldv_state_variable_66 == 2) {
#line 9381
      qla82xx_abort_isp(qla82xx_isp_ops_group0);
#line 9383
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9386
    goto ldv_63320;
    case 7: ;
#line 9389
    if (ldv_state_variable_66 == 1) {
#line 9391
      qla82xx_start_scsi(ldvarg251);
#line 9393
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9396
    if (ldv_state_variable_66 == 2) {
#line 9398
      qla82xx_start_scsi(ldvarg251);
#line 9400
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9403
    goto ldv_63320;
    case 8: ;
#line 9406
    if (ldv_state_variable_66 == 1) {
#line 9408
      qla24xx_chip_diag(qla82xx_isp_ops_group0);
#line 9410
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9413
    if (ldv_state_variable_66 == 2) {
#line 9415
      qla24xx_chip_diag(qla82xx_isp_ops_group0);
#line 9417
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9420
    goto ldv_63320;
    case 9: ;
#line 9423
    if (ldv_state_variable_66 == 1) {
#line 9425
      qla24xx_fabric_logout(qla82xx_isp_ops_group0, (int )ldvarg249, (int )ldvarg248,
                            (int )ldvarg247, (int )ldvarg250);
#line 9427
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9430
    if (ldv_state_variable_66 == 2) {
#line 9432
      qla24xx_fabric_logout(qla82xx_isp_ops_group0, (int )ldvarg249, (int )ldvarg248,
                            (int )ldvarg247, (int )ldvarg250);
#line 9434
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9437
    goto ldv_63320;
    case 10: ;
#line 9440
    if (ldv_state_variable_66 == 1) {
#line 9442
      qla82xx_reset_chip(qla82xx_isp_ops_group0);
#line 9444
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9447
    if (ldv_state_variable_66 == 2) {
#line 9449
      qla82xx_reset_chip(qla82xx_isp_ops_group0);
#line 9451
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9454
    goto ldv_63320;
    case 11: ;
#line 9457
    if (ldv_state_variable_66 == 1) {
#line 9459
      qla24xx_prep_ms_iocb(qla82xx_isp_ops_group0, ldvarg246, ldvarg245);
#line 9461
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9464
    if (ldv_state_variable_66 == 2) {
#line 9466
      qla24xx_prep_ms_iocb(qla82xx_isp_ops_group0, ldvarg246, ldvarg245);
#line 9468
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9471
    goto ldv_63320;
    case 12: ;
#line 9474
    if (ldv_state_variable_66 == 1) {
#line 9476
      qla24xx_lun_reset(qla82xx_isp_ops_group1, ldvarg244, ldvarg243);
#line 9478
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9481
    if (ldv_state_variable_66 == 2) {
#line 9483
      qla24xx_lun_reset(qla82xx_isp_ops_group1, ldvarg244, ldvarg243);
#line 9485
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9488
    goto ldv_63320;
    case 13: ;
#line 9491
    if (ldv_state_variable_66 == 1) {
#line 9493
      qla24xx_fw_version_str(qla82xx_isp_ops_group0, ldvarg242);
#line 9495
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9498
    if (ldv_state_variable_66 == 2) {
#line 9500
      qla24xx_fw_version_str(qla82xx_isp_ops_group0, ldvarg242);
#line 9502
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9505
    goto ldv_63320;
    case 14: ;
#line 9508
    if (ldv_state_variable_66 == 1) {
#line 9510
      qla82xx_iospace_config(qla82xx_isp_ops_group2);
#line 9512
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9515
    if (ldv_state_variable_66 == 2) {
#line 9517
      qla82xx_iospace_config(qla82xx_isp_ops_group2);
#line 9519
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9522
    goto ldv_63320;
    case 15: ;
#line 9525
    if (ldv_state_variable_66 == 1) {
#line 9527
      qla2x00_initialize_adapter(qla82xx_isp_ops_group0);
#line 9529
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9532
    if (ldv_state_variable_66 == 2) {
#line 9534
      qla2x00_initialize_adapter(qla82xx_isp_ops_group0);
#line 9536
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9539
    goto ldv_63320;
    case 16: ;
#line 9542
    if (ldv_state_variable_66 == 1) {
#line 9544
      qla82xx_get_flash_version(qla82xx_isp_ops_group0, ldvarg241);
#line 9546
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9549
    if (ldv_state_variable_66 == 2) {
#line 9551
      qla82xx_get_flash_version(qla82xx_isp_ops_group0, ldvarg241);
#line 9553
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9556
    goto ldv_63320;
    case 17: ;
#line 9559
    if (ldv_state_variable_66 == 1) {
#line 9561
      qla82xx_disable_intrs(qla82xx_isp_ops_group2);
#line 9563
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9566
    if (ldv_state_variable_66 == 2) {
#line 9568
      qla82xx_disable_intrs(qla82xx_isp_ops_group2);
#line 9570
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9573
    goto ldv_63320;
    case 18: ;
#line 9576
    if (ldv_state_variable_66 == 1) {
#line 9578
      qla81xx_nvram_config(qla82xx_isp_ops_group0);
#line 9580
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9583
    if (ldv_state_variable_66 == 2) {
#line 9585
      qla81xx_nvram_config(qla82xx_isp_ops_group0);
#line 9587
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9590
    goto ldv_63320;
    case 19: ;
#line 9593
    if (ldv_state_variable_66 == 1) {
#line 9595
      qla24xx_pci_info_str(qla82xx_isp_ops_group0, ldvarg240);
#line 9597
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9600
    if (ldv_state_variable_66 == 2) {
#line 9602
      qla24xx_pci_info_str(qla82xx_isp_ops_group0, ldvarg240);
#line 9604
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9607
    goto ldv_63320;
    case 20: ;
#line 9610
    if (ldv_state_variable_66 == 2) {
#line 9612
      qla82xx_read_optrom_data(qla82xx_isp_ops_group0, ldvarg239, ldvarg238, ldvarg237);
#line 9614
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9617
    goto ldv_63320;
    case 21: ;
#line 9620
    if (ldv_state_variable_66 == 1) {
#line 9622
      qla82xx_beacon_off(qla82xx_isp_ops_group0);
#line 9624
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9627
    if (ldv_state_variable_66 == 2) {
#line 9629
      qla82xx_beacon_off(qla82xx_isp_ops_group0);
#line 9631
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9634
    goto ldv_63320;
    case 22: ;
#line 9637
    if (ldv_state_variable_66 == 1) {
#line 9639
      qla24xx_abort_command(ldvarg236);
#line 9641
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9644
    if (ldv_state_variable_66 == 2) {
#line 9646
      qla24xx_abort_command(ldvarg236);
#line 9648
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9651
    goto ldv_63320;
    case 23: ;
#line 9654
    if (ldv_state_variable_66 == 1) {
#line 9656
      qla24xx_fw_dump(qla82xx_isp_ops_group0, ldvarg235);
#line 9658
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9661
    if (ldv_state_variable_66 == 2) {
#line 9663
      qla24xx_fw_dump(qla82xx_isp_ops_group0, ldvarg235);
#line 9665
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9668
    goto ldv_63320;
    case 24: ;
#line 9671
    if (ldv_state_variable_66 == 1) {
#line 9673
      qla82xx_config_rings(qla82xx_isp_ops_group0);
#line 9675
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9678
    if (ldv_state_variable_66 == 2) {
#line 9680
      qla82xx_config_rings(qla82xx_isp_ops_group0);
#line 9682
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9685
    goto ldv_63320;
    case 25: ;
#line 9688
    if (ldv_state_variable_66 == 1) {
#line 9690
      qla82xx_load_risc(qla82xx_isp_ops_group0, ldvarg234);
#line 9692
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9695
    if (ldv_state_variable_66 == 2) {
#line 9697
      qla82xx_load_risc(qla82xx_isp_ops_group0, ldvarg234);
#line 9699
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9702
    goto ldv_63320;
    case 26: ;
#line 9705
    if (ldv_state_variable_66 == 1) {
#line 9707
      qla82xx_pci_config(qla82xx_isp_ops_group0);
#line 9709
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9712
    if (ldv_state_variable_66 == 2) {
#line 9714
      qla82xx_pci_config(qla82xx_isp_ops_group0);
#line 9716
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9719
    goto ldv_63320;
    case 27: ;
#line 9722
    if (ldv_state_variable_66 == 1) {
#line 9724
      qla24xx_login_fabric(qla82xx_isp_ops_group0, (int )ldvarg232, (int )ldvarg230,
                           (int )ldvarg229, (int )ldvarg233, ldvarg228, (int )ldvarg231);
#line 9726
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9729
    if (ldv_state_variable_66 == 2) {
#line 9731
      qla24xx_login_fabric(qla82xx_isp_ops_group0, (int )ldvarg232, (int )ldvarg230,
                           (int )ldvarg229, (int )ldvarg233, ldvarg228, (int )ldvarg231);
#line 9733
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9736
    goto ldv_63320;
    case 28: ;
#line 9739
    if (ldv_state_variable_66 == 1) {
#line 9741
      qla24xx_write_nvram_data(qla82xx_isp_ops_group0, ldvarg227, ldvarg226, ldvarg225);
#line 9743
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9746
    if (ldv_state_variable_66 == 2) {
#line 9748
      qla24xx_write_nvram_data(qla82xx_isp_ops_group0, ldvarg227, ldvarg226, ldvarg225);
#line 9750
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9753
    goto ldv_63320;
    case 29: ;
#line 9756
    if (ldv_state_variable_66 == 1) {
#line 9758
      qla82xx_beacon_on(qla82xx_isp_ops_group0);
#line 9760
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9763
    if (ldv_state_variable_66 == 2) {
#line 9765
      qla82xx_beacon_on(qla82xx_isp_ops_group0);
#line 9767
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9770
    goto ldv_63320;
    case 30: ;
#line 9773
    if (ldv_state_variable_66 == 1) {
#line 9775
      qla24xx_read_nvram_data(qla82xx_isp_ops_group0, ldvarg224, ldvarg223, ldvarg222);
#line 9777
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9780
    if (ldv_state_variable_66 == 2) {
#line 9782
      qla24xx_read_nvram_data(qla82xx_isp_ops_group0, ldvarg224, ldvarg223, ldvarg222);
#line 9784
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9787
    goto ldv_63320;
    case 31: ;
#line 9790
    if (ldv_state_variable_66 == 1) {
#line 9792
      qla24xx_prep_ms_fdmi_iocb(qla82xx_isp_ops_group0, ldvarg221, ldvarg220);
#line 9794
      ldv_state_variable_66 = 1;
    } else {

    }
#line 9797
    if (ldv_state_variable_66 == 2) {
#line 9799
      qla24xx_prep_ms_fdmi_iocb(qla82xx_isp_ops_group0, ldvarg221, ldvarg220);
#line 9801
      ldv_state_variable_66 = 2;
    } else {

    }
#line 9804
    goto ldv_63320;
    case 32: ;
#line 9807
    if (ldv_state_variable_66 == 2) {
#line 9809
      ldv_release_66();
#line 9811
      ldv_state_variable_66 = 1;
#line 9812
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 9815
    goto ldv_63320;
    case 33: ;
#line 9818
    if (ldv_state_variable_66 == 1) {
#line 9820
      ldv_probe_66();
#line 9822
      ldv_state_variable_66 = 2;
#line 9823
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 9826
    goto ldv_63320;
    default: 
#line 9827
    ldv_stop();
    }
    ldv_63320: ;
  } else {

  }
#line 9831
  goto ldv_63125;
  case 34: ;
#line 9835
  if (ldv_state_variable_45 != 0) {
#line 9836
    ldv_main_exported_45();
  } else {

  }
#line 9839
  goto ldv_63125;
  case 35: ;
#line 9843
  if (ldv_state_variable_19 != 0) {
#line 9844
    ldv_main_exported_19();
  } else {

  }
#line 9847
  goto ldv_63125;
  case 36: ;
#line 9851
  if (ldv_state_variable_62 != 0) {
#line 9852
    tmp___172 = __VERIFIER_nondet_int();
#line 9852
    switch (tmp___172) {
    case 0: ;
#line 9855
    if (ldv_state_variable_62 == 3) {
#line 9857
      qla2xxx_pci_resume(qla2xxx_err_handler_group0);
#line 9859
      ldv_state_variable_62 = 2;
    } else {

    }
#line 9862
    goto ldv_63359;
    case 1: ;
#line 9865
    if (ldv_state_variable_62 == 1) {
#line 9867
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 9869
      ldv_state_variable_62 = 1;
    } else {

    }
#line 9872
    if (ldv_state_variable_62 == 3) {
#line 9874
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 9876
      ldv_state_variable_62 = 3;
    } else {

    }
#line 9879
    if (ldv_state_variable_62 == 2) {
#line 9881
      qla2xxx_pci_slot_reset(qla2xxx_err_handler_group0);
#line 9883
      ldv_state_variable_62 = 2;
    } else {

    }
#line 9886
    goto ldv_63359;
    case 2: ;
#line 9889
    if (ldv_state_variable_62 == 1) {
#line 9891
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg263);
#line 9893
      ldv_state_variable_62 = 1;
    } else {

    }
#line 9896
    if (ldv_state_variable_62 == 3) {
#line 9898
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg263);
#line 9900
      ldv_state_variable_62 = 3;
    } else {

    }
#line 9903
    if (ldv_state_variable_62 == 2) {
#line 9905
      qla2xxx_pci_error_detected(qla2xxx_err_handler_group0, (pci_channel_state_t )ldvarg263);
#line 9907
      ldv_state_variable_62 = 2;
    } else {

    }
#line 9910
    goto ldv_63359;
    case 3: ;
#line 9913
    if (ldv_state_variable_62 == 1) {
#line 9915
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 9917
      ldv_state_variable_62 = 1;
    } else {

    }
#line 9920
    if (ldv_state_variable_62 == 3) {
#line 9922
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 9924
      ldv_state_variable_62 = 3;
    } else {

    }
#line 9927
    if (ldv_state_variable_62 == 2) {
#line 9929
      qla2xxx_pci_mmio_enabled(qla2xxx_err_handler_group0);
#line 9931
      ldv_state_variable_62 = 2;
    } else {

    }
#line 9934
    goto ldv_63359;
    case 4: ;
#line 9937
    if (ldv_state_variable_62 == 2) {
#line 9939
      ldv_suspend_62();
#line 9941
      ldv_state_variable_62 = 3;
    } else {

    }
#line 9944
    goto ldv_63359;
    case 5: ;
#line 9947
    if (ldv_state_variable_62 == 3) {
#line 9949
      ldv_release_62();
#line 9951
      ldv_state_variable_62 = 1;
#line 9952
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 9955
    if (ldv_state_variable_62 == 2) {
#line 9957
      ldv_release_62();
#line 9959
      ldv_state_variable_62 = 1;
#line 9960
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 9963
    goto ldv_63359;
    case 6: ;
#line 9966
    if (ldv_state_variable_62 == 1) {
#line 9968
      ldv_probe_62();
#line 9970
      ldv_state_variable_62 = 2;
#line 9971
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 9974
    goto ldv_63359;
    default: 
#line 9975
    ldv_stop();
    }
    ldv_63359: ;
  } else {

  }
#line 9979
  goto ldv_63125;
  case 37: ;
#line 9983
  if (ldv_state_variable_54 != 0) {
#line 9984
    ldv_main_exported_54();
  } else {

  }
#line 9987
  goto ldv_63125;
  case 38: ;
#line 9991
  if (ldv_state_variable_67 != 0) {
#line 9992
    tmp___173 = __VERIFIER_nondet_int();
#line 9992
    switch (tmp___173) {
    case 0: ;
#line 9995
    if (ldv_state_variable_67 == 1) {
#line 9997
      qla24xx_reset_adapter(qla81xx_isp_ops_group0);
#line 9999
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10002
    if (ldv_state_variable_67 == 2) {
#line 10004
      qla24xx_reset_adapter(qla81xx_isp_ops_group0);
#line 10006
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10009
    goto ldv_63370;
    case 1: ;
#line 10012
    if (ldv_state_variable_67 == 2) {
#line 10014
      qla24xx_write_optrom_data(qla81xx_isp_ops_group0, ldvarg302, ldvarg301, ldvarg300);
#line 10016
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10019
    goto ldv_63370;
    case 2: ;
#line 10022
    if (ldv_state_variable_67 == 1) {
#line 10024
      qla24xx_enable_intrs(qla81xx_isp_ops_group2);
#line 10026
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10029
    if (ldv_state_variable_67 == 2) {
#line 10031
      qla24xx_enable_intrs(qla81xx_isp_ops_group2);
#line 10033
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10036
    goto ldv_63370;
    case 3: ;
#line 10039
    if (ldv_state_variable_67 == 1) {
#line 10041
      qla24xx_intr_handler(ldvarg298, ldvarg299);
#line 10043
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10046
    if (ldv_state_variable_67 == 2) {
#line 10048
      qla24xx_intr_handler(ldvarg298, ldvarg299);
#line 10050
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10053
    goto ldv_63370;
    case 4: ;
#line 10056
    if (ldv_state_variable_67 == 1) {
#line 10058
      qla24xx_abort_target(qla81xx_isp_ops_group1, ldvarg297, ldvarg296);
#line 10060
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10063
    if (ldv_state_variable_67 == 2) {
#line 10065
      qla24xx_abort_target(qla81xx_isp_ops_group1, ldvarg297, ldvarg296);
#line 10067
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10070
    goto ldv_63370;
    case 5: ;
#line 10073
    if (ldv_state_variable_67 == 1) {
#line 10075
      qla81xx_update_fw_options(qla81xx_isp_ops_group0);
#line 10077
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10080
    if (ldv_state_variable_67 == 2) {
#line 10082
      qla81xx_update_fw_options(qla81xx_isp_ops_group0);
#line 10084
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10087
    goto ldv_63370;
    case 6: ;
#line 10090
    if (ldv_state_variable_67 == 1) {
#line 10092
      qla2x00_abort_isp(qla81xx_isp_ops_group0);
#line 10094
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10097
    if (ldv_state_variable_67 == 2) {
#line 10099
      qla2x00_abort_isp(qla81xx_isp_ops_group0);
#line 10101
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10104
    goto ldv_63370;
    case 7: ;
#line 10107
    if (ldv_state_variable_67 == 1) {
#line 10109
      qla24xx_dif_start_scsi(ldvarg295);
#line 10111
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10114
    if (ldv_state_variable_67 == 2) {
#line 10116
      qla24xx_dif_start_scsi(ldvarg295);
#line 10118
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10121
    goto ldv_63370;
    case 8: ;
#line 10124
    if (ldv_state_variable_67 == 1) {
#line 10126
      qla24xx_chip_diag(qla81xx_isp_ops_group0);
#line 10128
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10131
    if (ldv_state_variable_67 == 2) {
#line 10133
      qla24xx_chip_diag(qla81xx_isp_ops_group0);
#line 10135
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10138
    goto ldv_63370;
    case 9: ;
#line 10141
    if (ldv_state_variable_67 == 1) {
#line 10143
      qla24xx_fabric_logout(qla81xx_isp_ops_group0, (int )ldvarg293, (int )ldvarg292,
                            (int )ldvarg291, (int )ldvarg294);
#line 10145
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10148
    if (ldv_state_variable_67 == 2) {
#line 10150
      qla24xx_fabric_logout(qla81xx_isp_ops_group0, (int )ldvarg293, (int )ldvarg292,
                            (int )ldvarg291, (int )ldvarg294);
#line 10152
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10155
    goto ldv_63370;
    case 10: ;
#line 10158
    if (ldv_state_variable_67 == 1) {
#line 10160
      qla24xx_reset_chip(qla81xx_isp_ops_group0);
#line 10162
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10165
    if (ldv_state_variable_67 == 2) {
#line 10167
      qla24xx_reset_chip(qla81xx_isp_ops_group0);
#line 10169
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10172
    goto ldv_63370;
    case 11: ;
#line 10175
    if (ldv_state_variable_67 == 1) {
#line 10177
      qla24xx_prep_ms_iocb(qla81xx_isp_ops_group0, ldvarg290, ldvarg289);
#line 10179
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10182
    if (ldv_state_variable_67 == 2) {
#line 10184
      qla24xx_prep_ms_iocb(qla81xx_isp_ops_group0, ldvarg290, ldvarg289);
#line 10186
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10189
    goto ldv_63370;
    case 12: ;
#line 10192
    if (ldv_state_variable_67 == 1) {
#line 10194
      qla24xx_lun_reset(qla81xx_isp_ops_group1, ldvarg288, ldvarg287);
#line 10196
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10199
    if (ldv_state_variable_67 == 2) {
#line 10201
      qla24xx_lun_reset(qla81xx_isp_ops_group1, ldvarg288, ldvarg287);
#line 10203
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10206
    goto ldv_63370;
    case 13: ;
#line 10209
    if (ldv_state_variable_67 == 1) {
#line 10211
      qla24xx_fw_version_str(qla81xx_isp_ops_group0, ldvarg286);
#line 10213
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10216
    if (ldv_state_variable_67 == 2) {
#line 10218
      qla24xx_fw_version_str(qla81xx_isp_ops_group0, ldvarg286);
#line 10220
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10223
    goto ldv_63370;
    case 14: ;
#line 10226
    if (ldv_state_variable_67 == 1) {
#line 10228
      qla2x00_iospace_config(qla81xx_isp_ops_group2);
#line 10230
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10233
    if (ldv_state_variable_67 == 2) {
#line 10235
      qla2x00_iospace_config(qla81xx_isp_ops_group2);
#line 10237
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10240
    goto ldv_63370;
    case 15: ;
#line 10243
    if (ldv_state_variable_67 == 1) {
#line 10245
      qla2x00_initialize_adapter(qla81xx_isp_ops_group0);
#line 10247
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10250
    if (ldv_state_variable_67 == 2) {
#line 10252
      qla2x00_initialize_adapter(qla81xx_isp_ops_group0);
#line 10254
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10257
    goto ldv_63370;
    case 16: ;
#line 10260
    if (ldv_state_variable_67 == 1) {
#line 10262
      qla24xx_get_flash_version(qla81xx_isp_ops_group0, ldvarg285);
#line 10264
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10267
    if (ldv_state_variable_67 == 2) {
#line 10269
      qla24xx_get_flash_version(qla81xx_isp_ops_group0, ldvarg285);
#line 10271
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10274
    goto ldv_63370;
    case 17: ;
#line 10277
    if (ldv_state_variable_67 == 1) {
#line 10279
      qla24xx_disable_intrs(qla81xx_isp_ops_group2);
#line 10281
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10284
    if (ldv_state_variable_67 == 2) {
#line 10286
      qla24xx_disable_intrs(qla81xx_isp_ops_group2);
#line 10288
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10291
    goto ldv_63370;
    case 18: ;
#line 10294
    if (ldv_state_variable_67 == 1) {
#line 10296
      qla81xx_nvram_config(qla81xx_isp_ops_group0);
#line 10298
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10301
    if (ldv_state_variable_67 == 2) {
#line 10303
      qla81xx_nvram_config(qla81xx_isp_ops_group0);
#line 10305
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10308
    goto ldv_63370;
    case 19: ;
#line 10311
    if (ldv_state_variable_67 == 1) {
#line 10313
      qla24xx_pci_info_str(qla81xx_isp_ops_group0, ldvarg284);
#line 10315
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10318
    if (ldv_state_variable_67 == 2) {
#line 10320
      qla24xx_pci_info_str(qla81xx_isp_ops_group0, ldvarg284);
#line 10322
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10325
    goto ldv_63370;
    case 20: ;
#line 10328
    if (ldv_state_variable_67 == 2) {
#line 10330
      qla25xx_read_optrom_data(qla81xx_isp_ops_group0, ldvarg283, ldvarg282, ldvarg281);
#line 10332
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10335
    goto ldv_63370;
    case 21: ;
#line 10338
    if (ldv_state_variable_67 == 1) {
#line 10340
      qla83xx_beacon_blink(qla81xx_isp_ops_group0);
#line 10342
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10345
    if (ldv_state_variable_67 == 2) {
#line 10347
      qla83xx_beacon_blink(qla81xx_isp_ops_group0);
#line 10349
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10352
    goto ldv_63370;
    case 22: ;
#line 10355
    if (ldv_state_variable_67 == 1) {
#line 10357
      qla24xx_beacon_off(qla81xx_isp_ops_group0);
#line 10359
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10362
    if (ldv_state_variable_67 == 2) {
#line 10364
      qla24xx_beacon_off(qla81xx_isp_ops_group0);
#line 10366
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10369
    goto ldv_63370;
    case 23: ;
#line 10372
    if (ldv_state_variable_67 == 1) {
#line 10374
      qla24xx_abort_command(ldvarg280);
#line 10376
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10379
    if (ldv_state_variable_67 == 2) {
#line 10381
      qla24xx_abort_command(ldvarg280);
#line 10383
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10386
    goto ldv_63370;
    case 24: ;
#line 10389
    if (ldv_state_variable_67 == 1) {
#line 10391
      qla81xx_fw_dump(qla81xx_isp_ops_group0, ldvarg279);
#line 10393
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10396
    if (ldv_state_variable_67 == 2) {
#line 10398
      qla81xx_fw_dump(qla81xx_isp_ops_group0, ldvarg279);
#line 10400
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10403
    goto ldv_63370;
    case 25: ;
#line 10406
    if (ldv_state_variable_67 == 1) {
#line 10408
      qla24xx_config_rings(qla81xx_isp_ops_group0);
#line 10410
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10413
    if (ldv_state_variable_67 == 2) {
#line 10415
      qla24xx_config_rings(qla81xx_isp_ops_group0);
#line 10417
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10420
    goto ldv_63370;
    case 26: ;
#line 10423
    if (ldv_state_variable_67 == 1) {
#line 10425
      qla81xx_load_risc(qla81xx_isp_ops_group0, ldvarg278);
#line 10427
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10430
    if (ldv_state_variable_67 == 2) {
#line 10432
      qla81xx_load_risc(qla81xx_isp_ops_group0, ldvarg278);
#line 10434
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10437
    goto ldv_63370;
    case 27: ;
#line 10440
    if (ldv_state_variable_67 == 1) {
#line 10442
      qla25xx_pci_config(qla81xx_isp_ops_group0);
#line 10444
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10447
    if (ldv_state_variable_67 == 2) {
#line 10449
      qla25xx_pci_config(qla81xx_isp_ops_group0);
#line 10451
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10454
    goto ldv_63370;
    case 28: ;
#line 10457
    if (ldv_state_variable_67 == 1) {
#line 10459
      qla24xx_login_fabric(qla81xx_isp_ops_group0, (int )ldvarg276, (int )ldvarg274,
                           (int )ldvarg273, (int )ldvarg277, ldvarg272, (int )ldvarg275);
#line 10461
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10464
    if (ldv_state_variable_67 == 2) {
#line 10466
      qla24xx_login_fabric(qla81xx_isp_ops_group0, (int )ldvarg276, (int )ldvarg274,
                           (int )ldvarg273, (int )ldvarg277, ldvarg272, (int )ldvarg275);
#line 10468
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10471
    goto ldv_63370;
    case 29: ;
#line 10474
    if (ldv_state_variable_67 == 1) {
#line 10476
      qla24xx_beacon_on(qla81xx_isp_ops_group0);
#line 10478
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10481
    if (ldv_state_variable_67 == 2) {
#line 10483
      qla24xx_beacon_on(qla81xx_isp_ops_group0);
#line 10485
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10488
    goto ldv_63370;
    case 30: ;
#line 10491
    if (ldv_state_variable_67 == 1) {
#line 10493
      qla24xx_prep_ms_fdmi_iocb(qla81xx_isp_ops_group0, ldvarg271, ldvarg270);
#line 10495
      ldv_state_variable_67 = 1;
    } else {

    }
#line 10498
    if (ldv_state_variable_67 == 2) {
#line 10500
      qla24xx_prep_ms_fdmi_iocb(qla81xx_isp_ops_group0, ldvarg271, ldvarg270);
#line 10502
      ldv_state_variable_67 = 2;
    } else {

    }
#line 10505
    goto ldv_63370;
    case 31: ;
#line 10508
    if (ldv_state_variable_67 == 2) {
#line 10510
      ldv_release_67();
#line 10512
      ldv_state_variable_67 = 1;
#line 10513
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 10516
    goto ldv_63370;
    case 32: ;
#line 10519
    if (ldv_state_variable_67 == 1) {
#line 10521
      ldv_probe_67();
#line 10523
      ldv_state_variable_67 = 2;
#line 10524
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 10527
    goto ldv_63370;
    default: 
#line 10528
    ldv_stop();
    }
    ldv_63370: ;
  } else {

  }
#line 10532
  goto ldv_63125;
  case 39: ;
#line 10536
  if (ldv_state_variable_70 != 0) {
#line 10537
    tmp___174 = __VERIFIER_nondet_int();
#line 10537
    switch (tmp___174) {
    case 0: ;
#line 10540
    if (ldv_state_variable_70 == 1) {
#line 10542
      qla2x00_reset_adapter(qla2300_isp_ops_group0);
#line 10544
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10547
    if (ldv_state_variable_70 == 2) {
#line 10549
      qla2x00_reset_adapter(qla2300_isp_ops_group0);
#line 10551
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10554
    goto ldv_63406;
    case 1: ;
#line 10557
    if (ldv_state_variable_70 == 1) {
#line 10559
      qla2x00_enable_intrs(qla2300_isp_ops_group2);
#line 10561
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10564
    if (ldv_state_variable_70 == 2) {
#line 10566
      qla2x00_enable_intrs(qla2300_isp_ops_group2);
#line 10568
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10571
    goto ldv_63406;
    case 2: ;
#line 10574
    if (ldv_state_variable_70 == 2) {
#line 10576
      qla2x00_write_optrom_data(qla2300_isp_ops_group0, ldvarg345, ldvarg344, ldvarg343);
#line 10578
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10581
    goto ldv_63406;
    case 3: ;
#line 10584
    if (ldv_state_variable_70 == 1) {
#line 10586
      qla2300_intr_handler(ldvarg341, ldvarg342);
#line 10588
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10591
    if (ldv_state_variable_70 == 2) {
#line 10593
      qla2300_intr_handler(ldvarg341, ldvarg342);
#line 10595
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10598
    goto ldv_63406;
    case 4: ;
#line 10601
    if (ldv_state_variable_70 == 1) {
#line 10603
      qla2x00_abort_target(qla2300_isp_ops_group1, ldvarg340, ldvarg339);
#line 10605
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10608
    if (ldv_state_variable_70 == 2) {
#line 10610
      qla2x00_abort_target(qla2300_isp_ops_group1, ldvarg340, ldvarg339);
#line 10612
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10615
    goto ldv_63406;
    case 5: ;
#line 10618
    if (ldv_state_variable_70 == 1) {
#line 10620
      qla2x00_update_fw_options(qla2300_isp_ops_group0);
#line 10622
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10625
    if (ldv_state_variable_70 == 2) {
#line 10627
      qla2x00_update_fw_options(qla2300_isp_ops_group0);
#line 10629
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10632
    goto ldv_63406;
    case 6: ;
#line 10635
    if (ldv_state_variable_70 == 1) {
#line 10637
      qla2x00_abort_isp(qla2300_isp_ops_group0);
#line 10639
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10642
    if (ldv_state_variable_70 == 2) {
#line 10644
      qla2x00_abort_isp(qla2300_isp_ops_group0);
#line 10646
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10649
    goto ldv_63406;
    case 7: ;
#line 10652
    if (ldv_state_variable_70 == 1) {
#line 10654
      qla2x00_start_scsi(ldvarg338);
#line 10656
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10659
    if (ldv_state_variable_70 == 2) {
#line 10661
      qla2x00_start_scsi(ldvarg338);
#line 10663
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10666
    goto ldv_63406;
    case 8: ;
#line 10669
    if (ldv_state_variable_70 == 1) {
#line 10671
      qla2x00_chip_diag(qla2300_isp_ops_group0);
#line 10673
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10676
    if (ldv_state_variable_70 == 2) {
#line 10678
      qla2x00_chip_diag(qla2300_isp_ops_group0);
#line 10680
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10683
    goto ldv_63406;
    case 9: ;
#line 10686
    if (ldv_state_variable_70 == 1) {
#line 10688
      qla2x00_fabric_logout(qla2300_isp_ops_group0, (int )ldvarg336, (int )ldvarg335,
                            (int )ldvarg334, (int )ldvarg337);
#line 10690
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10693
    if (ldv_state_variable_70 == 2) {
#line 10695
      qla2x00_fabric_logout(qla2300_isp_ops_group0, (int )ldvarg336, (int )ldvarg335,
                            (int )ldvarg334, (int )ldvarg337);
#line 10697
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10700
    goto ldv_63406;
    case 10: ;
#line 10703
    if (ldv_state_variable_70 == 1) {
#line 10705
      qla2x00_reset_chip(qla2300_isp_ops_group0);
#line 10707
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10710
    if (ldv_state_variable_70 == 2) {
#line 10712
      qla2x00_reset_chip(qla2300_isp_ops_group0);
#line 10714
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10717
    goto ldv_63406;
    case 11: ;
#line 10720
    if (ldv_state_variable_70 == 1) {
#line 10722
      qla2x00_prep_ms_iocb(qla2300_isp_ops_group0, ldvarg333, ldvarg332);
#line 10724
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10727
    if (ldv_state_variable_70 == 2) {
#line 10729
      qla2x00_prep_ms_iocb(qla2300_isp_ops_group0, ldvarg333, ldvarg332);
#line 10731
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10734
    goto ldv_63406;
    case 12: ;
#line 10737
    if (ldv_state_variable_70 == 1) {
#line 10739
      qla2x00_lun_reset(qla2300_isp_ops_group1, ldvarg331, ldvarg330);
#line 10741
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10744
    if (ldv_state_variable_70 == 2) {
#line 10746
      qla2x00_lun_reset(qla2300_isp_ops_group1, ldvarg331, ldvarg330);
#line 10748
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10751
    goto ldv_63406;
    case 13: ;
#line 10754
    if (ldv_state_variable_70 == 1) {
#line 10756
      qla2x00_fw_version_str(qla2300_isp_ops_group0, ldvarg329);
#line 10758
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10761
    if (ldv_state_variable_70 == 2) {
#line 10763
      qla2x00_fw_version_str(qla2300_isp_ops_group0, ldvarg329);
#line 10765
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10768
    goto ldv_63406;
    case 14: ;
#line 10771
    if (ldv_state_variable_70 == 1) {
#line 10773
      qla2x00_iospace_config(qla2300_isp_ops_group2);
#line 10775
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10778
    if (ldv_state_variable_70 == 2) {
#line 10780
      qla2x00_iospace_config(qla2300_isp_ops_group2);
#line 10782
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10785
    goto ldv_63406;
    case 15: ;
#line 10788
    if (ldv_state_variable_70 == 1) {
#line 10790
      qla2x00_initialize_adapter(qla2300_isp_ops_group0);
#line 10792
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10795
    if (ldv_state_variable_70 == 2) {
#line 10797
      qla2x00_initialize_adapter(qla2300_isp_ops_group0);
#line 10799
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10802
    goto ldv_63406;
    case 16: ;
#line 10805
    if (ldv_state_variable_70 == 1) {
#line 10807
      qla2x00_disable_intrs(qla2300_isp_ops_group2);
#line 10809
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10812
    if (ldv_state_variable_70 == 2) {
#line 10814
      qla2x00_disable_intrs(qla2300_isp_ops_group2);
#line 10816
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10819
    goto ldv_63406;
    case 17: ;
#line 10822
    if (ldv_state_variable_70 == 1) {
#line 10824
      qla2x00_get_flash_version(qla2300_isp_ops_group0, ldvarg328);
#line 10826
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10829
    if (ldv_state_variable_70 == 2) {
#line 10831
      qla2x00_get_flash_version(qla2300_isp_ops_group0, ldvarg328);
#line 10833
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10836
    goto ldv_63406;
    case 18: ;
#line 10839
    if (ldv_state_variable_70 == 1) {
#line 10841
      qla2x00_calc_iocbs_32((int )ldvarg327);
#line 10843
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10846
    if (ldv_state_variable_70 == 2) {
#line 10848
      qla2x00_calc_iocbs_32((int )ldvarg327);
#line 10850
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10853
    goto ldv_63406;
    case 19: ;
#line 10856
    if (ldv_state_variable_70 == 1) {
#line 10858
      qla2x00_nvram_config(qla2300_isp_ops_group0);
#line 10860
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10863
    if (ldv_state_variable_70 == 2) {
#line 10865
      qla2x00_nvram_config(qla2300_isp_ops_group0);
#line 10867
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10870
    goto ldv_63406;
    case 20: ;
#line 10873
    if (ldv_state_variable_70 == 1) {
#line 10875
      qla2x00_pci_info_str(qla2300_isp_ops_group0, ldvarg326);
#line 10877
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10880
    if (ldv_state_variable_70 == 2) {
#line 10882
      qla2x00_pci_info_str(qla2300_isp_ops_group0, ldvarg326);
#line 10884
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10887
    goto ldv_63406;
    case 21: ;
#line 10890
    if (ldv_state_variable_70 == 2) {
#line 10892
      qla2x00_read_optrom_data(qla2300_isp_ops_group0, ldvarg325, ldvarg324, ldvarg323);
#line 10894
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10897
    goto ldv_63406;
    case 22: ;
#line 10900
    if (ldv_state_variable_70 == 1) {
#line 10902
      qla2x00_beacon_blink(qla2300_isp_ops_group0);
#line 10904
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10907
    if (ldv_state_variable_70 == 2) {
#line 10909
      qla2x00_beacon_blink(qla2300_isp_ops_group0);
#line 10911
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10914
    goto ldv_63406;
    case 23: ;
#line 10917
    if (ldv_state_variable_70 == 1) {
#line 10919
      qla2x00_beacon_off(qla2300_isp_ops_group0);
#line 10921
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10924
    if (ldv_state_variable_70 == 2) {
#line 10926
      qla2x00_beacon_off(qla2300_isp_ops_group0);
#line 10928
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10931
    goto ldv_63406;
    case 24: ;
#line 10934
    if (ldv_state_variable_70 == 1) {
#line 10936
      qla2x00_build_scsi_iocbs_32(ldvarg320, ldvarg322, (int )ldvarg321);
#line 10938
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10941
    if (ldv_state_variable_70 == 2) {
#line 10943
      qla2x00_build_scsi_iocbs_32(ldvarg320, ldvarg322, (int )ldvarg321);
#line 10945
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10948
    goto ldv_63406;
    case 25: ;
#line 10951
    if (ldv_state_variable_70 == 1) {
#line 10953
      qla2x00_abort_command(ldvarg319);
#line 10955
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10958
    if (ldv_state_variable_70 == 2) {
#line 10960
      qla2x00_abort_command(ldvarg319);
#line 10962
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10965
    goto ldv_63406;
    case 26: ;
#line 10968
    if (ldv_state_variable_70 == 1) {
#line 10970
      qla2300_fw_dump(qla2300_isp_ops_group0, ldvarg318);
#line 10972
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10975
    if (ldv_state_variable_70 == 2) {
#line 10977
      qla2300_fw_dump(qla2300_isp_ops_group0, ldvarg318);
#line 10979
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10982
    goto ldv_63406;
    case 27: ;
#line 10985
    if (ldv_state_variable_70 == 1) {
#line 10987
      qla2x00_config_rings(qla2300_isp_ops_group0);
#line 10989
      ldv_state_variable_70 = 1;
    } else {

    }
#line 10992
    if (ldv_state_variable_70 == 2) {
#line 10994
      qla2x00_config_rings(qla2300_isp_ops_group0);
#line 10996
      ldv_state_variable_70 = 2;
    } else {

    }
#line 10999
    goto ldv_63406;
    case 28: ;
#line 11002
    if (ldv_state_variable_70 == 1) {
#line 11004
      qla2x00_load_risc(qla2300_isp_ops_group0, ldvarg317);
#line 11006
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11009
    if (ldv_state_variable_70 == 2) {
#line 11011
      qla2x00_load_risc(qla2300_isp_ops_group0, ldvarg317);
#line 11013
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11016
    goto ldv_63406;
    case 29: ;
#line 11019
    if (ldv_state_variable_70 == 1) {
#line 11021
      qla2300_pci_config(qla2300_isp_ops_group0);
#line 11023
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11026
    if (ldv_state_variable_70 == 2) {
#line 11028
      qla2300_pci_config(qla2300_isp_ops_group0);
#line 11030
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11033
    goto ldv_63406;
    case 30: ;
#line 11036
    if (ldv_state_variable_70 == 1) {
#line 11038
      qla2x00_login_fabric(qla2300_isp_ops_group0, (int )ldvarg315, (int )ldvarg313,
                           (int )ldvarg312, (int )ldvarg316, ldvarg311, (int )ldvarg314);
#line 11040
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11043
    if (ldv_state_variable_70 == 2) {
#line 11045
      qla2x00_login_fabric(qla2300_isp_ops_group0, (int )ldvarg315, (int )ldvarg313,
                           (int )ldvarg312, (int )ldvarg316, ldvarg311, (int )ldvarg314);
#line 11047
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11050
    goto ldv_63406;
    case 31: ;
#line 11053
    if (ldv_state_variable_70 == 1) {
#line 11055
      qla2x00_write_nvram_data(qla2300_isp_ops_group0, ldvarg310, ldvarg309, ldvarg308);
#line 11057
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11060
    if (ldv_state_variable_70 == 2) {
#line 11062
      qla2x00_write_nvram_data(qla2300_isp_ops_group0, ldvarg310, ldvarg309, ldvarg308);
#line 11064
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11067
    goto ldv_63406;
    case 32: ;
#line 11070
    if (ldv_state_variable_70 == 1) {
#line 11072
      qla2x00_beacon_on(qla2300_isp_ops_group0);
#line 11074
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11077
    if (ldv_state_variable_70 == 2) {
#line 11079
      qla2x00_beacon_on(qla2300_isp_ops_group0);
#line 11081
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11084
    goto ldv_63406;
    case 33: ;
#line 11087
    if (ldv_state_variable_70 == 1) {
#line 11089
      qla2x00_read_nvram_data(qla2300_isp_ops_group0, ldvarg307, ldvarg306, ldvarg305);
#line 11091
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11094
    if (ldv_state_variable_70 == 2) {
#line 11096
      qla2x00_read_nvram_data(qla2300_isp_ops_group0, ldvarg307, ldvarg306, ldvarg305);
#line 11098
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11101
    goto ldv_63406;
    case 34: ;
#line 11104
    if (ldv_state_variable_70 == 1) {
#line 11106
      qla2x00_prep_ms_fdmi_iocb(qla2300_isp_ops_group0, ldvarg304, ldvarg303);
#line 11108
      ldv_state_variable_70 = 1;
    } else {

    }
#line 11111
    if (ldv_state_variable_70 == 2) {
#line 11113
      qla2x00_prep_ms_fdmi_iocb(qla2300_isp_ops_group0, ldvarg304, ldvarg303);
#line 11115
      ldv_state_variable_70 = 2;
    } else {

    }
#line 11118
    goto ldv_63406;
    case 35: ;
#line 11121
    if (ldv_state_variable_70 == 2) {
#line 11123
      ldv_release_70();
#line 11125
      ldv_state_variable_70 = 1;
#line 11126
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 11129
    goto ldv_63406;
    case 36: ;
#line 11132
    if (ldv_state_variable_70 == 1) {
#line 11134
      ldv_probe_70();
#line 11136
      ldv_state_variable_70 = 2;
#line 11137
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 11140
    goto ldv_63406;
    default: 
#line 11141
    ldv_stop();
    }
    ldv_63406: ;
  } else {

  }
#line 11145
  goto ldv_63125;
  case 40: ;
#line 11149
  if (ldv_state_variable_68 != 0) {
#line 11150
    tmp___175 = __VERIFIER_nondet_int();
#line 11150
    switch (tmp___175) {
    case 0: ;
#line 11153
    if (ldv_state_variable_68 == 1) {
#line 11155
      qla24xx_reset_adapter(qla25xx_isp_ops_group0);
#line 11157
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11160
    if (ldv_state_variable_68 == 2) {
#line 11162
      qla24xx_reset_adapter(qla25xx_isp_ops_group0);
#line 11164
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11167
    goto ldv_63446;
    case 1: ;
#line 11170
    if (ldv_state_variable_68 == 2) {
#line 11172
      qla24xx_write_optrom_data(qla25xx_isp_ops_group0, ldvarg384, ldvarg383, ldvarg382);
#line 11174
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11177
    goto ldv_63446;
    case 2: ;
#line 11180
    if (ldv_state_variable_68 == 1) {
#line 11182
      qla24xx_enable_intrs(qla25xx_isp_ops_group2);
#line 11184
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11187
    if (ldv_state_variable_68 == 2) {
#line 11189
      qla24xx_enable_intrs(qla25xx_isp_ops_group2);
#line 11191
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11194
    goto ldv_63446;
    case 3: ;
#line 11197
    if (ldv_state_variable_68 == 1) {
#line 11199
      qla24xx_intr_handler(ldvarg380, ldvarg381);
#line 11201
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11204
    if (ldv_state_variable_68 == 2) {
#line 11206
      qla24xx_intr_handler(ldvarg380, ldvarg381);
#line 11208
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11211
    goto ldv_63446;
    case 4: ;
#line 11214
    if (ldv_state_variable_68 == 1) {
#line 11216
      qla24xx_abort_target(qla25xx_isp_ops_group1, ldvarg379, ldvarg378);
#line 11218
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11221
    if (ldv_state_variable_68 == 2) {
#line 11223
      qla24xx_abort_target(qla25xx_isp_ops_group1, ldvarg379, ldvarg378);
#line 11225
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11228
    goto ldv_63446;
    case 5: ;
#line 11231
    if (ldv_state_variable_68 == 1) {
#line 11233
      qla24xx_update_fw_options(qla25xx_isp_ops_group0);
#line 11235
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11238
    if (ldv_state_variable_68 == 2) {
#line 11240
      qla24xx_update_fw_options(qla25xx_isp_ops_group0);
#line 11242
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11245
    goto ldv_63446;
    case 6: ;
#line 11248
    if (ldv_state_variable_68 == 1) {
#line 11250
      qla2x00_abort_isp(qla25xx_isp_ops_group0);
#line 11252
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11255
    if (ldv_state_variable_68 == 2) {
#line 11257
      qla2x00_abort_isp(qla25xx_isp_ops_group0);
#line 11259
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11262
    goto ldv_63446;
    case 7: ;
#line 11265
    if (ldv_state_variable_68 == 1) {
#line 11267
      qla24xx_dif_start_scsi(ldvarg377);
#line 11269
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11272
    if (ldv_state_variable_68 == 2) {
#line 11274
      qla24xx_dif_start_scsi(ldvarg377);
#line 11276
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11279
    goto ldv_63446;
    case 8: ;
#line 11282
    if (ldv_state_variable_68 == 1) {
#line 11284
      qla24xx_chip_diag(qla25xx_isp_ops_group0);
#line 11286
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11289
    if (ldv_state_variable_68 == 2) {
#line 11291
      qla24xx_chip_diag(qla25xx_isp_ops_group0);
#line 11293
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11296
    goto ldv_63446;
    case 9: ;
#line 11299
    if (ldv_state_variable_68 == 1) {
#line 11301
      qla24xx_fabric_logout(qla25xx_isp_ops_group0, (int )ldvarg375, (int )ldvarg374,
                            (int )ldvarg373, (int )ldvarg376);
#line 11303
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11306
    if (ldv_state_variable_68 == 2) {
#line 11308
      qla24xx_fabric_logout(qla25xx_isp_ops_group0, (int )ldvarg375, (int )ldvarg374,
                            (int )ldvarg373, (int )ldvarg376);
#line 11310
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11313
    goto ldv_63446;
    case 10: ;
#line 11316
    if (ldv_state_variable_68 == 1) {
#line 11318
      qla24xx_reset_chip(qla25xx_isp_ops_group0);
#line 11320
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11323
    if (ldv_state_variable_68 == 2) {
#line 11325
      qla24xx_reset_chip(qla25xx_isp_ops_group0);
#line 11327
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11330
    goto ldv_63446;
    case 11: ;
#line 11333
    if (ldv_state_variable_68 == 1) {
#line 11335
      qla24xx_prep_ms_iocb(qla25xx_isp_ops_group0, ldvarg372, ldvarg371);
#line 11337
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11340
    if (ldv_state_variable_68 == 2) {
#line 11342
      qla24xx_prep_ms_iocb(qla25xx_isp_ops_group0, ldvarg372, ldvarg371);
#line 11344
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11347
    goto ldv_63446;
    case 12: ;
#line 11350
    if (ldv_state_variable_68 == 1) {
#line 11352
      qla24xx_lun_reset(qla25xx_isp_ops_group1, ldvarg370, ldvarg369);
#line 11354
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11357
    if (ldv_state_variable_68 == 2) {
#line 11359
      qla24xx_lun_reset(qla25xx_isp_ops_group1, ldvarg370, ldvarg369);
#line 11361
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11364
    goto ldv_63446;
    case 13: ;
#line 11367
    if (ldv_state_variable_68 == 1) {
#line 11369
      qla24xx_fw_version_str(qla25xx_isp_ops_group0, ldvarg368);
#line 11371
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11374
    if (ldv_state_variable_68 == 2) {
#line 11376
      qla24xx_fw_version_str(qla25xx_isp_ops_group0, ldvarg368);
#line 11378
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11381
    goto ldv_63446;
    case 14: ;
#line 11384
    if (ldv_state_variable_68 == 1) {
#line 11386
      qla2x00_iospace_config(qla25xx_isp_ops_group2);
#line 11388
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11391
    if (ldv_state_variable_68 == 2) {
#line 11393
      qla2x00_iospace_config(qla25xx_isp_ops_group2);
#line 11395
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11398
    goto ldv_63446;
    case 15: ;
#line 11401
    if (ldv_state_variable_68 == 1) {
#line 11403
      qla2x00_initialize_adapter(qla25xx_isp_ops_group0);
#line 11405
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11408
    if (ldv_state_variable_68 == 2) {
#line 11410
      qla2x00_initialize_adapter(qla25xx_isp_ops_group0);
#line 11412
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11415
    goto ldv_63446;
    case 16: ;
#line 11418
    if (ldv_state_variable_68 == 1) {
#line 11420
      qla24xx_get_flash_version(qla25xx_isp_ops_group0, ldvarg367);
#line 11422
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11425
    if (ldv_state_variable_68 == 2) {
#line 11427
      qla24xx_get_flash_version(qla25xx_isp_ops_group0, ldvarg367);
#line 11429
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11432
    goto ldv_63446;
    case 17: ;
#line 11435
    if (ldv_state_variable_68 == 1) {
#line 11437
      qla24xx_disable_intrs(qla25xx_isp_ops_group2);
#line 11439
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11442
    if (ldv_state_variable_68 == 2) {
#line 11444
      qla24xx_disable_intrs(qla25xx_isp_ops_group2);
#line 11446
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11449
    goto ldv_63446;
    case 18: ;
#line 11452
    if (ldv_state_variable_68 == 1) {
#line 11454
      qla24xx_nvram_config(qla25xx_isp_ops_group0);
#line 11456
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11459
    if (ldv_state_variable_68 == 2) {
#line 11461
      qla24xx_nvram_config(qla25xx_isp_ops_group0);
#line 11463
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11466
    goto ldv_63446;
    case 19: ;
#line 11469
    if (ldv_state_variable_68 == 1) {
#line 11471
      qla24xx_pci_info_str(qla25xx_isp_ops_group0, ldvarg366);
#line 11473
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11476
    if (ldv_state_variable_68 == 2) {
#line 11478
      qla24xx_pci_info_str(qla25xx_isp_ops_group0, ldvarg366);
#line 11480
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11483
    goto ldv_63446;
    case 20: ;
#line 11486
    if (ldv_state_variable_68 == 2) {
#line 11488
      qla25xx_read_optrom_data(qla25xx_isp_ops_group0, ldvarg365, ldvarg364, ldvarg363);
#line 11490
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11493
    goto ldv_63446;
    case 21: ;
#line 11496
    if (ldv_state_variable_68 == 1) {
#line 11498
      qla24xx_beacon_blink(qla25xx_isp_ops_group0);
#line 11500
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11503
    if (ldv_state_variable_68 == 2) {
#line 11505
      qla24xx_beacon_blink(qla25xx_isp_ops_group0);
#line 11507
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11510
    goto ldv_63446;
    case 22: ;
#line 11513
    if (ldv_state_variable_68 == 1) {
#line 11515
      qla24xx_beacon_off(qla25xx_isp_ops_group0);
#line 11517
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11520
    if (ldv_state_variable_68 == 2) {
#line 11522
      qla24xx_beacon_off(qla25xx_isp_ops_group0);
#line 11524
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11527
    goto ldv_63446;
    case 23: ;
#line 11530
    if (ldv_state_variable_68 == 1) {
#line 11532
      qla24xx_abort_command(ldvarg362);
#line 11534
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11537
    if (ldv_state_variable_68 == 2) {
#line 11539
      qla24xx_abort_command(ldvarg362);
#line 11541
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11544
    goto ldv_63446;
    case 24: ;
#line 11547
    if (ldv_state_variable_68 == 1) {
#line 11549
      qla25xx_fw_dump(qla25xx_isp_ops_group0, ldvarg361);
#line 11551
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11554
    if (ldv_state_variable_68 == 2) {
#line 11556
      qla25xx_fw_dump(qla25xx_isp_ops_group0, ldvarg361);
#line 11558
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11561
    goto ldv_63446;
    case 25: ;
#line 11564
    if (ldv_state_variable_68 == 1) {
#line 11566
      qla24xx_config_rings(qla25xx_isp_ops_group0);
#line 11568
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11571
    if (ldv_state_variable_68 == 2) {
#line 11573
      qla24xx_config_rings(qla25xx_isp_ops_group0);
#line 11575
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11578
    goto ldv_63446;
    case 26: ;
#line 11581
    if (ldv_state_variable_68 == 1) {
#line 11583
      qla24xx_load_risc(qla25xx_isp_ops_group0, ldvarg360);
#line 11585
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11588
    if (ldv_state_variable_68 == 2) {
#line 11590
      qla24xx_load_risc(qla25xx_isp_ops_group0, ldvarg360);
#line 11592
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11595
    goto ldv_63446;
    case 27: ;
#line 11598
    if (ldv_state_variable_68 == 1) {
#line 11600
      qla25xx_pci_config(qla25xx_isp_ops_group0);
#line 11602
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11605
    if (ldv_state_variable_68 == 2) {
#line 11607
      qla25xx_pci_config(qla25xx_isp_ops_group0);
#line 11609
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11612
    goto ldv_63446;
    case 28: ;
#line 11615
    if (ldv_state_variable_68 == 1) {
#line 11617
      qla24xx_login_fabric(qla25xx_isp_ops_group0, (int )ldvarg358, (int )ldvarg356,
                           (int )ldvarg355, (int )ldvarg359, ldvarg354, (int )ldvarg357);
#line 11619
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11622
    if (ldv_state_variable_68 == 2) {
#line 11624
      qla24xx_login_fabric(qla25xx_isp_ops_group0, (int )ldvarg358, (int )ldvarg356,
                           (int )ldvarg355, (int )ldvarg359, ldvarg354, (int )ldvarg357);
#line 11626
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11629
    goto ldv_63446;
    case 29: ;
#line 11632
    if (ldv_state_variable_68 == 1) {
#line 11634
      qla25xx_write_nvram_data(qla25xx_isp_ops_group0, ldvarg353, ldvarg352, ldvarg351);
#line 11636
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11639
    if (ldv_state_variable_68 == 2) {
#line 11641
      qla25xx_write_nvram_data(qla25xx_isp_ops_group0, ldvarg353, ldvarg352, ldvarg351);
#line 11643
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11646
    goto ldv_63446;
    case 30: ;
#line 11649
    if (ldv_state_variable_68 == 1) {
#line 11651
      qla24xx_beacon_on(qla25xx_isp_ops_group0);
#line 11653
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11656
    if (ldv_state_variable_68 == 2) {
#line 11658
      qla24xx_beacon_on(qla25xx_isp_ops_group0);
#line 11660
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11663
    goto ldv_63446;
    case 31: ;
#line 11666
    if (ldv_state_variable_68 == 1) {
#line 11668
      qla25xx_read_nvram_data(qla25xx_isp_ops_group0, ldvarg350, ldvarg349, ldvarg348);
#line 11670
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11673
    if (ldv_state_variable_68 == 2) {
#line 11675
      qla25xx_read_nvram_data(qla25xx_isp_ops_group0, ldvarg350, ldvarg349, ldvarg348);
#line 11677
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11680
    goto ldv_63446;
    case 32: ;
#line 11683
    if (ldv_state_variable_68 == 1) {
#line 11685
      qla24xx_prep_ms_fdmi_iocb(qla25xx_isp_ops_group0, ldvarg347, ldvarg346);
#line 11687
      ldv_state_variable_68 = 1;
    } else {

    }
#line 11690
    if (ldv_state_variable_68 == 2) {
#line 11692
      qla24xx_prep_ms_fdmi_iocb(qla25xx_isp_ops_group0, ldvarg347, ldvarg346);
#line 11694
      ldv_state_variable_68 = 2;
    } else {

    }
#line 11697
    goto ldv_63446;
    case 33: ;
#line 11700
    if (ldv_state_variable_68 == 2) {
#line 11702
      ldv_release_68();
#line 11704
      ldv_state_variable_68 = 1;
#line 11705
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 11708
    goto ldv_63446;
    case 34: ;
#line 11711
    if (ldv_state_variable_68 == 1) {
#line 11713
      ldv_probe_68();
#line 11715
      ldv_state_variable_68 = 2;
#line 11716
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 11719
    goto ldv_63446;
    default: 
#line 11720
    ldv_stop();
    }
    ldv_63446: ;
  } else {

  }
#line 11724
  goto ldv_63125;
  case 41: ;
#line 11728
  if (ldv_state_variable_2 != 0) {
#line 11729
    choose_timer_2(ldv_timer_list_2);
  } else {

  }
#line 11732
  goto ldv_63125;
  case 42: ;
#line 11739
  goto ldv_63125;
  case 43: ;
#line 11743
  if (ldv_state_variable_1 != 0) {
#line 11744
    choose_timer_1(ldv_timer_list_1);
  } else {

  }
#line 11747
  goto ldv_63125;
  case 44: ;
#line 11751
  if (ldv_state_variable_30 != 0) {
#line 11752
    ldv_main_exported_30();
  } else {

  }
#line 11755
  goto ldv_63125;
  case 45: ;
#line 11759
  if (ldv_state_variable_25 != 0) {
#line 11760
    ldv_main_exported_25();
  } else {

  }
#line 11763
  goto ldv_63125;
  case 46: ;
#line 11767
  if (ldv_state_variable_28 != 0) {
#line 11768
    ldv_main_exported_28();
  } else {

  }
#line 11771
  goto ldv_63125;
  case 47: ;
#line 11775
  if (ldv_state_variable_40 != 0) {
#line 11776
    ldv_main_exported_40();
  } else {

  }
#line 11779
  goto ldv_63125;
  case 48: ;
#line 11786
  goto ldv_63125;
  case 49: ;
#line 11790
  if (ldv_state_variable_69 != 0) {
#line 11791
    tmp___176 = __VERIFIER_nondet_int();
#line 11791
    switch (tmp___176) {
    case 0: ;
#line 11794
    if (ldv_state_variable_69 == 1) {
#line 11796
      qla24xx_reset_adapter(qla24xx_isp_ops_group0);
#line 11798
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11801
    if (ldv_state_variable_69 == 2) {
#line 11803
      qla24xx_reset_adapter(qla24xx_isp_ops_group0);
#line 11805
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11808
    goto ldv_63492;
    case 1: ;
#line 11811
    if (ldv_state_variable_69 == 2) {
#line 11813
      qla24xx_write_optrom_data(qla24xx_isp_ops_group0, ldvarg435, ldvarg434, ldvarg433);
#line 11815
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11818
    goto ldv_63492;
    case 2: ;
#line 11821
    if (ldv_state_variable_69 == 1) {
#line 11823
      qla24xx_enable_intrs(qla24xx_isp_ops_group2);
#line 11825
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11828
    if (ldv_state_variable_69 == 2) {
#line 11830
      qla24xx_enable_intrs(qla24xx_isp_ops_group2);
#line 11832
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11835
    goto ldv_63492;
    case 3: ;
#line 11838
    if (ldv_state_variable_69 == 1) {
#line 11840
      qla24xx_intr_handler(ldvarg431, ldvarg432);
#line 11842
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11845
    if (ldv_state_variable_69 == 2) {
#line 11847
      qla24xx_intr_handler(ldvarg431, ldvarg432);
#line 11849
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11852
    goto ldv_63492;
    case 4: ;
#line 11855
    if (ldv_state_variable_69 == 1) {
#line 11857
      qla24xx_abort_target(qla24xx_isp_ops_group1, ldvarg430, ldvarg429);
#line 11859
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11862
    if (ldv_state_variable_69 == 2) {
#line 11864
      qla24xx_abort_target(qla24xx_isp_ops_group1, ldvarg430, ldvarg429);
#line 11866
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11869
    goto ldv_63492;
    case 5: ;
#line 11872
    if (ldv_state_variable_69 == 1) {
#line 11874
      qla24xx_update_fw_options(qla24xx_isp_ops_group0);
#line 11876
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11879
    if (ldv_state_variable_69 == 2) {
#line 11881
      qla24xx_update_fw_options(qla24xx_isp_ops_group0);
#line 11883
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11886
    goto ldv_63492;
    case 6: ;
#line 11889
    if (ldv_state_variable_69 == 1) {
#line 11891
      qla2x00_abort_isp(qla24xx_isp_ops_group0);
#line 11893
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11896
    if (ldv_state_variable_69 == 2) {
#line 11898
      qla2x00_abort_isp(qla24xx_isp_ops_group0);
#line 11900
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11903
    goto ldv_63492;
    case 7: ;
#line 11906
    if (ldv_state_variable_69 == 1) {
#line 11908
      qla24xx_start_scsi(ldvarg428);
#line 11910
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11913
    if (ldv_state_variable_69 == 2) {
#line 11915
      qla24xx_start_scsi(ldvarg428);
#line 11917
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11920
    goto ldv_63492;
    case 8: ;
#line 11923
    if (ldv_state_variable_69 == 1) {
#line 11925
      qla24xx_chip_diag(qla24xx_isp_ops_group0);
#line 11927
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11930
    if (ldv_state_variable_69 == 2) {
#line 11932
      qla24xx_chip_diag(qla24xx_isp_ops_group0);
#line 11934
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11937
    goto ldv_63492;
    case 9: ;
#line 11940
    if (ldv_state_variable_69 == 1) {
#line 11942
      qla24xx_fabric_logout(qla24xx_isp_ops_group0, (int )ldvarg426, (int )ldvarg425,
                            (int )ldvarg424, (int )ldvarg427);
#line 11944
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11947
    if (ldv_state_variable_69 == 2) {
#line 11949
      qla24xx_fabric_logout(qla24xx_isp_ops_group0, (int )ldvarg426, (int )ldvarg425,
                            (int )ldvarg424, (int )ldvarg427);
#line 11951
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11954
    goto ldv_63492;
    case 10: ;
#line 11957
    if (ldv_state_variable_69 == 1) {
#line 11959
      qla24xx_reset_chip(qla24xx_isp_ops_group0);
#line 11961
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11964
    if (ldv_state_variable_69 == 2) {
#line 11966
      qla24xx_reset_chip(qla24xx_isp_ops_group0);
#line 11968
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11971
    goto ldv_63492;
    case 11: ;
#line 11974
    if (ldv_state_variable_69 == 1) {
#line 11976
      qla24xx_prep_ms_iocb(qla24xx_isp_ops_group0, ldvarg423, ldvarg422);
#line 11978
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11981
    if (ldv_state_variable_69 == 2) {
#line 11983
      qla24xx_prep_ms_iocb(qla24xx_isp_ops_group0, ldvarg423, ldvarg422);
#line 11985
      ldv_state_variable_69 = 2;
    } else {

    }
#line 11988
    goto ldv_63492;
    case 12: ;
#line 11991
    if (ldv_state_variable_69 == 1) {
#line 11993
      qla24xx_lun_reset(qla24xx_isp_ops_group1, ldvarg421, ldvarg420);
#line 11995
      ldv_state_variable_69 = 1;
    } else {

    }
#line 11998
    if (ldv_state_variable_69 == 2) {
#line 12000
      qla24xx_lun_reset(qla24xx_isp_ops_group1, ldvarg421, ldvarg420);
#line 12002
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12005
    goto ldv_63492;
    case 13: ;
#line 12008
    if (ldv_state_variable_69 == 1) {
#line 12010
      qla24xx_fw_version_str(qla24xx_isp_ops_group0, ldvarg419);
#line 12012
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12015
    if (ldv_state_variable_69 == 2) {
#line 12017
      qla24xx_fw_version_str(qla24xx_isp_ops_group0, ldvarg419);
#line 12019
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12022
    goto ldv_63492;
    case 14: ;
#line 12025
    if (ldv_state_variable_69 == 1) {
#line 12027
      qla2x00_iospace_config(qla24xx_isp_ops_group2);
#line 12029
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12032
    if (ldv_state_variable_69 == 2) {
#line 12034
      qla2x00_iospace_config(qla24xx_isp_ops_group2);
#line 12036
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12039
    goto ldv_63492;
    case 15: ;
#line 12042
    if (ldv_state_variable_69 == 1) {
#line 12044
      qla2x00_initialize_adapter(qla24xx_isp_ops_group0);
#line 12046
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12049
    if (ldv_state_variable_69 == 2) {
#line 12051
      qla2x00_initialize_adapter(qla24xx_isp_ops_group0);
#line 12053
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12056
    goto ldv_63492;
    case 16: ;
#line 12059
    if (ldv_state_variable_69 == 1) {
#line 12061
      qla24xx_get_flash_version(qla24xx_isp_ops_group0, ldvarg418);
#line 12063
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12066
    if (ldv_state_variable_69 == 2) {
#line 12068
      qla24xx_get_flash_version(qla24xx_isp_ops_group0, ldvarg418);
#line 12070
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12073
    goto ldv_63492;
    case 17: ;
#line 12076
    if (ldv_state_variable_69 == 1) {
#line 12078
      qla24xx_disable_intrs(qla24xx_isp_ops_group2);
#line 12080
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12083
    if (ldv_state_variable_69 == 2) {
#line 12085
      qla24xx_disable_intrs(qla24xx_isp_ops_group2);
#line 12087
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12090
    goto ldv_63492;
    case 18: ;
#line 12093
    if (ldv_state_variable_69 == 1) {
#line 12095
      qla24xx_nvram_config(qla24xx_isp_ops_group0);
#line 12097
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12100
    if (ldv_state_variable_69 == 2) {
#line 12102
      qla24xx_nvram_config(qla24xx_isp_ops_group0);
#line 12104
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12107
    goto ldv_63492;
    case 19: ;
#line 12110
    if (ldv_state_variable_69 == 1) {
#line 12112
      qla24xx_pci_info_str(qla24xx_isp_ops_group0, ldvarg417);
#line 12114
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12117
    if (ldv_state_variable_69 == 2) {
#line 12119
      qla24xx_pci_info_str(qla24xx_isp_ops_group0, ldvarg417);
#line 12121
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12124
    goto ldv_63492;
    case 20: ;
#line 12127
    if (ldv_state_variable_69 == 2) {
#line 12129
      qla24xx_read_optrom_data(qla24xx_isp_ops_group0, ldvarg416, ldvarg415, ldvarg414);
#line 12131
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12134
    goto ldv_63492;
    case 21: ;
#line 12137
    if (ldv_state_variable_69 == 1) {
#line 12139
      qla24xx_beacon_blink(qla24xx_isp_ops_group0);
#line 12141
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12144
    if (ldv_state_variable_69 == 2) {
#line 12146
      qla24xx_beacon_blink(qla24xx_isp_ops_group0);
#line 12148
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12151
    goto ldv_63492;
    case 22: ;
#line 12154
    if (ldv_state_variable_69 == 1) {
#line 12156
      qla24xx_beacon_off(qla24xx_isp_ops_group0);
#line 12158
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12161
    if (ldv_state_variable_69 == 2) {
#line 12163
      qla24xx_beacon_off(qla24xx_isp_ops_group0);
#line 12165
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12168
    goto ldv_63492;
    case 23: ;
#line 12171
    if (ldv_state_variable_69 == 1) {
#line 12173
      qla24xx_abort_command(ldvarg413);
#line 12175
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12178
    if (ldv_state_variable_69 == 2) {
#line 12180
      qla24xx_abort_command(ldvarg413);
#line 12182
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12185
    goto ldv_63492;
    case 24: ;
#line 12188
    if (ldv_state_variable_69 == 1) {
#line 12190
      qla24xx_fw_dump(qla24xx_isp_ops_group0, ldvarg412);
#line 12192
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12195
    if (ldv_state_variable_69 == 2) {
#line 12197
      qla24xx_fw_dump(qla24xx_isp_ops_group0, ldvarg412);
#line 12199
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12202
    goto ldv_63492;
    case 25: ;
#line 12205
    if (ldv_state_variable_69 == 1) {
#line 12207
      qla24xx_config_rings(qla24xx_isp_ops_group0);
#line 12209
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12212
    if (ldv_state_variable_69 == 2) {
#line 12214
      qla24xx_config_rings(qla24xx_isp_ops_group0);
#line 12216
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12219
    goto ldv_63492;
    case 26: ;
#line 12222
    if (ldv_state_variable_69 == 1) {
#line 12224
      qla24xx_load_risc(qla24xx_isp_ops_group0, ldvarg411);
#line 12226
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12229
    if (ldv_state_variable_69 == 2) {
#line 12231
      qla24xx_load_risc(qla24xx_isp_ops_group0, ldvarg411);
#line 12233
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12236
    goto ldv_63492;
    case 27: ;
#line 12239
    if (ldv_state_variable_69 == 1) {
#line 12241
      qla24xx_pci_config(qla24xx_isp_ops_group0);
#line 12243
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12246
    if (ldv_state_variable_69 == 2) {
#line 12248
      qla24xx_pci_config(qla24xx_isp_ops_group0);
#line 12250
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12253
    goto ldv_63492;
    case 28: ;
#line 12256
    if (ldv_state_variable_69 == 1) {
#line 12258
      qla24xx_login_fabric(qla24xx_isp_ops_group0, (int )ldvarg409, (int )ldvarg407,
                           (int )ldvarg406, (int )ldvarg410, ldvarg405, (int )ldvarg408);
#line 12260
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12263
    if (ldv_state_variable_69 == 2) {
#line 12265
      qla24xx_login_fabric(qla24xx_isp_ops_group0, (int )ldvarg409, (int )ldvarg407,
                           (int )ldvarg406, (int )ldvarg410, ldvarg405, (int )ldvarg408);
#line 12267
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12270
    goto ldv_63492;
    case 29: ;
#line 12273
    if (ldv_state_variable_69 == 1) {
#line 12275
      qla24xx_write_nvram_data(qla24xx_isp_ops_group0, ldvarg404, ldvarg403, ldvarg402);
#line 12277
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12280
    if (ldv_state_variable_69 == 2) {
#line 12282
      qla24xx_write_nvram_data(qla24xx_isp_ops_group0, ldvarg404, ldvarg403, ldvarg402);
#line 12284
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12287
    goto ldv_63492;
    case 30: ;
#line 12290
    if (ldv_state_variable_69 == 1) {
#line 12292
      qla24xx_beacon_on(qla24xx_isp_ops_group0);
#line 12294
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12297
    if (ldv_state_variable_69 == 2) {
#line 12299
      qla24xx_beacon_on(qla24xx_isp_ops_group0);
#line 12301
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12304
    goto ldv_63492;
    case 31: ;
#line 12307
    if (ldv_state_variable_69 == 1) {
#line 12309
      qla24xx_read_nvram_data(qla24xx_isp_ops_group0, ldvarg401, ldvarg400, ldvarg399);
#line 12311
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12314
    if (ldv_state_variable_69 == 2) {
#line 12316
      qla24xx_read_nvram_data(qla24xx_isp_ops_group0, ldvarg401, ldvarg400, ldvarg399);
#line 12318
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12321
    goto ldv_63492;
    case 32: ;
#line 12324
    if (ldv_state_variable_69 == 1) {
#line 12326
      qla24xx_prep_ms_fdmi_iocb(qla24xx_isp_ops_group0, ldvarg398, ldvarg397);
#line 12328
      ldv_state_variable_69 = 1;
    } else {

    }
#line 12331
    if (ldv_state_variable_69 == 2) {
#line 12333
      qla24xx_prep_ms_fdmi_iocb(qla24xx_isp_ops_group0, ldvarg398, ldvarg397);
#line 12335
      ldv_state_variable_69 = 2;
    } else {

    }
#line 12338
    goto ldv_63492;
    case 33: ;
#line 12341
    if (ldv_state_variable_69 == 2) {
#line 12343
      ldv_release_69();
#line 12345
      ldv_state_variable_69 = 1;
#line 12346
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 12349
    goto ldv_63492;
    case 34: ;
#line 12352
    if (ldv_state_variable_69 == 1) {
#line 12354
      ldv_probe_69();
#line 12356
      ldv_state_variable_69 = 2;
#line 12357
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 12360
    goto ldv_63492;
    default: 
#line 12361
    ldv_stop();
    }
    ldv_63492: ;
  } else {

  }
#line 12365
  goto ldv_63125;
  case 50: ;
#line 12369
  if (ldv_state_variable_59 != 0) {
#line 12370
    ldv_main_exported_59();
  } else {

  }
#line 12373
  goto ldv_63125;
  case 51: ;
#line 12377
  if (ldv_state_variable_49 != 0) {
#line 12378
    ldv_main_exported_49();
  } else {

  }
#line 12381
  goto ldv_63125;
  case 52: ;
#line 12385
  if (ldv_state_variable_24 != 0) {
#line 12386
    ldv_main_exported_24();
  } else {

  }
#line 12389
  goto ldv_63125;
  case 53: ;
#line 12393
  if (ldv_state_variable_53 != 0) {
#line 12394
    ldv_main_exported_53();
  } else {

  }
#line 12397
  goto ldv_63125;
  case 54: ;
#line 12401
  if (ldv_state_variable_22 != 0) {
#line 12402
    ldv_main_exported_22();
  } else {

  }
#line 12405
  goto ldv_63125;
  case 55: ;
#line 12409
  if (ldv_state_variable_42 != 0) {
#line 12410
    ldv_main_exported_42();
  } else {

  }
#line 12413
  goto ldv_63125;
  case 56: ;
#line 12417
  if (ldv_state_variable_0 != 0) {
#line 12418
    tmp___177 = __VERIFIER_nondet_int();
#line 12418
    switch (tmp___177) {
    case 0: ;
#line 12421
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 12423
      qla2x00_module_exit();
#line 12424
      ldv_state_variable_0 = 2;
#line 12425
      goto ldv_final;
    } else {

    }
#line 12428
    goto ldv_63537;
    case 1: ;
#line 12431
    if (ldv_state_variable_0 == 1) {
#line 12433
      ldv_retval_3 = qla2x00_module_init();
#line 12435
      if (ldv_retval_3 == 0) {
#line 12436
        ldv_state_variable_0 = 3;
#line 12437
        ldv_state_variable_54 = 1;
#line 12438
        ldv_state_variable_62 = 1;
#line 12439
        ldv_initialize_pci_error_handlers_62();
#line 12440
        ldv_state_variable_43 = 1;
#line 12441
        ldv_state_variable_19 = 1;
#line 12442
        ldv_initialize_fc_function_template_19();
#line 12443
        ldv_state_variable_45 = 1;
#line 12444
        ldv_state_variable_37 = 1;
#line 12445
        ldv_state_variable_66 = 1;
#line 12446
        ldv_initialize_isp_operations_66();
#line 12447
        ldv_state_variable_56 = 1;
#line 12448
        ldv_state_variable_34 = 1;
#line 12449
        ldv_state_variable_52 = 1;
#line 12450
        ldv_state_variable_38 = 1;
#line 12451
        ldv_state_variable_47 = 1;
#line 12452
        ldv_state_variable_41 = 1;
#line 12453
        ldv_initialize_device_attribute_41();
#line 12454
        ldv_state_variable_58 = 1;
#line 12455
        ldv_initialize_bin_attribute_58();
#line 12456
        ldv_state_variable_51 = 1;
#line 12457
        ldv_state_variable_36 = 1;
#line 12458
        ldv_state_variable_64 = 1;
#line 12459
        ldv_initialize_isp_operations_64();
#line 12460
        ldv_state_variable_39 = 1;
#line 12461
        ldv_initialize_device_attribute_39();
#line 12462
        ldv_state_variable_50 = 1;
#line 12463
        ldv_state_variable_29 = 1;
#line 12464
        ldv_state_variable_65 = 1;
#line 12465
        ldv_initialize_isp_operations_65();
#line 12466
        ldv_state_variable_23 = 1;
#line 12467
        ldv_state_variable_46 = 1;
#line 12468
        ldv_state_variable_42 = 1;
#line 12469
        ldv_state_variable_22 = 1;
#line 12470
        ldv_state_variable_48 = 1;
#line 12471
        ldv_state_variable_53 = 1;
#line 12472
        ldv_state_variable_35 = 1;
#line 12473
        ldv_state_variable_31 = 1;
#line 12474
        ldv_state_variable_24 = 1;
#line 12475
        ldv_state_variable_49 = 1;
#line 12476
        ldv_state_variable_59 = 1;
#line 12477
        ldv_initialize_bin_attribute_59();
#line 12478
        ldv_state_variable_69 = 1;
#line 12479
        ldv_initialize_isp_operations_69();
#line 12480
        ldv_state_variable_20 = 1;
#line 12481
        ldv_initialize_fc_function_template_20();
#line 12482
        ldv_state_variable_61 = 1;
#line 12483
        ldv_initialize_pci_driver_61();
#line 12484
        ldv_state_variable_40 = 1;
#line 12485
        ldv_initialize_device_attribute_40();
#line 12486
        ldv_state_variable_57 = 1;
#line 12487
        ldv_initialize_bin_attribute_57();
#line 12488
        ldv_state_variable_28 = 1;
#line 12489
        ldv_state_variable_27 = 1;
#line 12490
        ldv_state_variable_25 = 1;
#line 12491
        ldv_state_variable_55 = 1;
#line 12492
        ldv_initialize_bin_attribute_55();
#line 12493
        ldv_state_variable_44 = 1;
#line 12494
        ldv_state_variable_30 = 1;
#line 12495
        ldv_state_variable_26 = 1;
#line 12496
        ldv_state_variable_68 = 1;
#line 12497
        ldv_initialize_isp_operations_68();
#line 12498
        ldv_state_variable_70 = 1;
#line 12499
        ldv_initialize_isp_operations_70();
#line 12500
        ldv_state_variable_71 = 1;
#line 12501
        ldv_initialize_isp_operations_71();
#line 12502
        ldv_state_variable_21 = 1;
#line 12503
        ldv_state_variable_63 = 1;
#line 12504
        ldv_initialize_isp_operations_63();
#line 12505
        ldv_state_variable_32 = 1;
#line 12506
        ldv_state_variable_33 = 1;
#line 12507
        ldv_state_variable_67 = 1;
#line 12508
        ldv_initialize_isp_operations_67();
      } else {

      }
#line 12510
      if (ldv_retval_3 != 0) {
#line 12511
        ldv_state_variable_0 = 2;
#line 12512
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 12516
    goto ldv_63537;
    default: 
#line 12517
    ldv_stop();
    }
    ldv_63537: ;
  } else {

  }
#line 12521
  goto ldv_63125;
  case 57: ;
#line 12525
  if (ldv_state_variable_46 != 0) {
#line 12526
    ldv_main_exported_46();
  } else {

  }
#line 12529
  goto ldv_63125;
  case 58: ;
#line 12533
  if (ldv_state_variable_23 != 0) {
#line 12534
    ldv_main_exported_23();
  } else {

  }
#line 12537
  goto ldv_63125;
  case 59: ;
#line 12544
  goto ldv_63125;
  case 60: ;
#line 12551
  goto ldv_63125;
  case 61: ;
#line 12558
  goto ldv_63125;
  case 62: ;
#line 12562
  if (ldv_state_variable_36 != 0) {
#line 12563
    ldv_main_exported_36();
  } else {

  }
#line 12566
  goto ldv_63125;
  case 63: ;
#line 12573
  goto ldv_63125;
  case 64: ;
#line 12577
  if (ldv_state_variable_51 != 0) {
#line 12578
    ldv_main_exported_51();
  } else {

  }
#line 12581
  goto ldv_63125;
  case 65: ;
#line 12585
  if (ldv_state_variable_47 != 0) {
#line 12586
    ldv_main_exported_47();
  } else {

  }
#line 12589
  goto ldv_63125;
  case 66: ;
#line 12596
  goto ldv_63125;
  case 67: ;
#line 12600
  if (ldv_state_variable_38 != 0) {
#line 12601
    ldv_main_exported_38();
  } else {

  }
#line 12604
  goto ldv_63125;
  case 68: ;
#line 12611
  goto ldv_63125;
  case 69: ;
#line 12615
  if (ldv_state_variable_34 != 0) {
#line 12616
    ldv_main_exported_34();
  } else {

  }
#line 12619
  goto ldv_63125;
  case 70: ;
#line 12623
  if (ldv_state_variable_37 != 0) {
#line 12624
    ldv_main_exported_37();
  } else {

  }
#line 12627
  goto ldv_63125;
  case 71: ;
#line 12631
  if (ldv_state_variable_43 != 0) {
#line 12632
    ldv_main_exported_43();
  } else {

  }
#line 12635
  goto ldv_63125;
  case 72: ;
#line 12642
  goto ldv_63125;
  default: 
#line 12643
  ldv_stop();
  }
  ldv_63125: ;
#line 12645
  goto ldv_63557;
  ldv_final: 
#line 12647
  ldv_check_final_state();
#line 12648
  return 0;
}
}
#line 12651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_del_timer_1(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 12655
  tmp = del_timer(ldv_func_arg1);
#line 12655
  ldv_func_res = tmp;
#line 12657
  disable_suitable_timer_7(ldv_func_arg1);
#line 12659
  return (ldv_func_res);
}
}
#line 12662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_scsi_add_host_with_dma_2(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 12666
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 12666
  ldv_func_res = tmp;
#line 12668
  if (ldv_func_res == 0) {
#line 12669
    ldv_state_variable_72 = 1;
#line 12669
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 12673
  return (ldv_func_res);
}
}
#line 12676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_mod_timer_3(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 12680
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 12680
  ldv_func_res = tmp;
#line 12682
  activate_pending_timer_7(ldv_func_arg1, ldv_func_arg2, 1);
#line 12684
  return (ldv_func_res);
}
}
#line 12687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
int ldv_del_timer_sync_4(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 12691
  tmp = del_timer_sync(ldv_func_arg1);
#line 12691
  ldv_func_res = tmp;
#line 12693
  disable_suitable_timer_7(ldv_func_arg1);
#line 12695
  return (ldv_func_res);
}
}
#line 12698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
void ldv_scsi_remove_host_5(struct Scsi_Host *shost ) 
{ 


  {
#line 12701
  scsi_remove_host(shost);
#line 12703
  ldv_state_variable_72 = 0;
#line 12704
  return;
}
}
#line 12706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_6(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 12710
  tmp = scsi_host_alloc(sht, privsize);
#line 12710
  ldv_func_res = tmp;
#line 12712
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___3 )0)) {
#line 12713
    ldv_state_variable_72 = 1;
#line 12713
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 12717
  return (ldv_func_res);
}
}
#line 12720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static int ldv_register_chrdev_7(unsigned int major , char const   *name ,
                                          struct file_operations  const  *fops ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 12724
  tmp = register_chrdev(major, name, fops);
#line 12724
  ldv_func_res = tmp;
#line 12726
  ldv_state_variable_18 = 1;
#line 12727
  ldv_file_operations_18();
#line 12730
  return (ldv_func_res);
}
}
#line 12733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_os.o.c.prepared"
__inline static void ldv_unregister_chrdev_8(unsigned int major , char const   *name ) 
{ 


  {
#line 12736
  unregister_chrdev(major, name);
#line 12738
  ldv_state_variable_18 = 0;
#line 12739
  return;
}
}
#line 45 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 15 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 77 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2,%0; sete %1": "+m" (v->counter),
                       "=qm" (c): "ir" (i): "memory");
#line 84
  return ((int )c);
}
}
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 175
  __ret = i;
#line 175
  switch (4UL) {
  case 1UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5380;
  case 2UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5380;
  case 4UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5380;
  case 8UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5380;
  default: 
#line 175
  __xadd_wrong_size();
  }
  ldv_5380: ;
#line 175
  return (__ret + i);
}
}
#line 164 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 167
  __list_del_entry(list);
#line 168
  list_add_tail(list, head);
#line 169
  return;
}
}
#line 82 "include/linux/jiffies.h"
__inline static u64 get_jiffies_64(void) 
{ 


  {
#line 84
  return ((u64 )jiffies);
}
}
#line 295
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_17(struct timer_list *ldv_func_arg1 ) ;
#line 182
int ldv_del_timer_19(struct timer_list *ldv_func_arg1 ) ;
#line 67 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 558 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 560
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 561
    return ((void *)0);
  } else {

  }
#line 562
  tmp = __kmalloc(n * size, flags);
#line 562
  return (tmp);
}
}
#line 571 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 573
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 573
  return (tmp);
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int reg_timer_3(struct timer_list *timer ) ;
#line 245
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 265
void disable_suitable_timer_3(struct timer_list *timer ) ;
#line 275
void choose_timer_3(struct timer_list *timer ) ;
#line 789 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 819
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 821
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 840 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 842
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 842
  return (tmp);
}
}
#line 844 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 846
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 846
  return (tmp);
}
}
#line 915
extern void pci_set_master(struct pci_dev * ) ;
#line 922
extern int pci_try_set_mwi(struct pci_dev * ) ;
#line 923
extern void pci_clear_mwi(struct pci_dev * ) ;
#line 934
extern int pcix_set_mmrbc(struct pci_dev * , int  ) ;
#line 936
extern int pcie_set_readrq(struct pci_dev * , int  ) ;
#line 956
extern void pci_disable_rom(struct pci_dev * ) ;
#line 1754 "include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
#line 1756
  tmp = pci_pcie_cap(dev);
#line 1756
  return (tmp != 0);
}
}
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_18(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 792 "include/scsi/scsi_transport_fc.h"
__inline static u64 wwn_to_u64(u8 *wwn ) 
{ 


  {
#line 794
  return (((((((((unsigned long long )*wwn << 56) | ((unsigned long long )*(wwn + 1UL) << 48)) | ((unsigned long long )*(wwn + 2UL) << 40)) | ((unsigned long long )*(wwn + 3UL) << 32)) | ((unsigned long long )*(wwn + 4UL) << 24)) | ((unsigned long long )*(wwn + 5UL) << 16)) | ((unsigned long long )*(wwn + 6UL) << 8)) | (unsigned long long )*(wwn + 7UL));
}
}
#line 836
extern struct fc_rport *fc_remote_port_add(struct Scsi_Host * , int  , struct fc_rport_identifiers * ) ;
#line 839
extern void fc_remote_port_rolechg(struct fc_rport * , u32  ) ;
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___0[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 55 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_alloc_fw_dump(scsi_qla_host_t *vha ) ;
#line 67
int qla2x00_async_tm_cmd(fc_port_t *fcport , uint32_t tm_flags , uint32_t lun , uint32_t tag ) ;
#line 75
int qla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 78
fc_port_t *qla2x00_alloc_fcport(scsi_qla_host_t *vha , gfp_t flags ) ;
#line 88
int qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha , struct req_que *req ) ;
#line 89
int qla2x00_init_rings(scsi_qla_host_t *vha ) ;
#line 177
int qla24xx_configure_vhba(scsi_qla_host_t *vha ) ;
#line 212
int qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                   uint16_t loop_id , uint16_t lun , uint8_t type ) ;
#line 214
int qla2x00_start_sp(srb_t *sp ) ;
#line 217
unsigned long qla2x00_get_async_timeout(struct scsi_qla_host *vha ) ;
#line 226
int qla2x00_load_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t risc_addr ,
                     uint32_t risc_code_size ) ;
#line 232
int qla2x00_execute_fw(scsi_qla_host_t *vha , uint32_t risc_addr ) ;
#line 235
int qla2x00_get_fw_version(scsi_qla_host_t *vha ) ;
#line 238
int qla2x00_get_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) ;
#line 241
int qla2x00_set_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) ;
#line 244
int qla2x00_mbx_reg_test(scsi_qla_host_t *vha ) ;
#line 247
int qla2x00_verify_checksum(scsi_qla_host_t *vha , uint32_t risc_addr ) ;
#line 262
int qla2x00_get_adapter_id(scsi_qla_host_t *vha , uint16_t *id , uint8_t *al_pa ,
                           uint8_t *area , uint8_t *domain , uint16_t *top , uint16_t *sw_cap ) ;
#line 266
int qla2x00_get_retry_cnt(scsi_qla_host_t *vha , uint8_t *retry_cnt , uint8_t *tov ,
                          uint16_t *r_a_tov ) ;
#line 269
int qla2x00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) ;
#line 278
int qla2x00_get_firmware_state(scsi_qla_host_t *vha , uint16_t *states ) ;
#line 281
int qla2x00_get_port_name(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t *name ,
                          uint8_t opt ) ;
#line 284
int qla24xx_link_initialize(scsi_qla_host_t *vha ) ;
#line 300
int qla2x00_login_local_device(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *mb_ret ,
                               uint8_t opt ) ;
#line 313
int qla2x00_get_id_list(scsi_qla_host_t *vha , void *id_list , dma_addr_t id_list_dma ,
                        uint16_t *entries ) ;
#line 316
int qla2x00_get_resource_cnts(scsi_qla_host_t *vha , uint16_t *cur_xchg_cnt , uint16_t *orig_xchg_cnt ,
                              uint16_t *cur_iocb_cnt , uint16_t *orig_iocb_cnt , uint16_t *max_npiv_vports ,
                              uint16_t *max_fcfs ) ;
#line 342
int qla2x00_set_serdes_params(scsi_qla_host_t *vha , uint16_t sw_em_1g , uint16_t sw_em_2g ,
                              uint16_t sw_em_4g ) ;
#line 345
int qla2x00_stop_firmware(scsi_qla_host_t *vha ) ;
#line 348
int qla2x00_enable_eft_trace(scsi_qla_host_t *vha , dma_addr_t eft_dma , uint16_t buffers ) ;
#line 353
int qla2x00_enable_fce_trace(scsi_qla_host_t *vha , dma_addr_t fce_dma , uint16_t buffers ,
                             uint16_t *mb , uint32_t *dwords ) ;
#line 360
int qla82xx_set_driver_version(scsi_qla_host_t *vha , char *version ) ;
#line 363
int qla25xx_set_driver_version(scsi_qla_host_t *vha , char *version ) ;
#line 374
int qla2x00_set_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t port_speed ,
                           uint16_t *mb ) ;
#line 376
int qla84xx_verify_chip(struct scsi_qla_host *vha , uint16_t *status ) ;
#line 381
int qla81xx_fac_get_sector_size(scsi_qla_host_t *vha , uint32_t *sector_size ) ;
#line 396
int qla2x00_read_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t *data ) ;
#line 399
int qla2x00_write_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t data ) ;
#line 402
int qla81xx_write_mpi_register(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 403
int qla2x00_get_data_rate(scsi_qla_host_t *vha ) ;
#line 404
int qla24xx_set_fcp_prio(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t priority ,
                         uint16_t *mb ) ;
#line 407
int qla81xx_get_port_config(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 416
int qla2x00_dump_mctp_data(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr ,
                           uint32_t size ) ;
#line 431
char const   *qla2x00_get_link_speed_str(struct qla_hw_data *ha , uint16_t speed ) ;
#line 443
uint32_t *qla24xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                  uint32_t dwords ) ;
#line 457
int qla2x00_is_a_vp_did(scsi_qla_host_t *vha , uint32_t rscn_entry ) ;
#line 492
int qla2xxx_get_flash_info(scsi_qla_host_t *vha ) ;
#line 493
int qla2xxx_get_vpd_field(scsi_qla_host_t *vha , char *key , char *str , size_t size ) ;
#line 496
int qla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha ) ;
#line 510
void ql_dump_buffer(uint32_t level , scsi_qla_host_t *vha , int32_t id , uint8_t *b ,
                    uint32_t size ) ;
#line 519
int qla2x00_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 520
int qla2x00_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 521
int qla2x00_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 522
int qla2x00_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 523
void qla2x00_gff_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 524
int qla2x00_rft_id(scsi_qla_host_t *vha ) ;
#line 525
int qla2x00_rff_id(scsi_qla_host_t *vha ) ;
#line 526
int qla2x00_rnn_id(scsi_qla_host_t *vha ) ;
#line 527
int qla2x00_rsnn_nn(scsi_qla_host_t *vha ) ;
#line 530
int qla2x00_fdmi_register(scsi_qla_host_t *vha ) ;
#line 531
int qla2x00_gfpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 532
int qla2x00_gpsc(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 551
int qla24xx_update_all_fcp_prio(scsi_qla_host_t *vha ) ;
#line 563
int qla25xx_init_req_que(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 564
int qla25xx_init_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) ;
#line 569
void qla2x00_init_response_q_entries(struct rsp_que *rsp ) ;
#line 596
int qlafx00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) ;
#line 598
int qlafx00_fw_ready(scsi_qla_host_t *vha ) ;
#line 599
int qlafx00_configure_devices(scsi_qla_host_t *vha ) ;
#line 608
void qlafx00_init_response_q_entries(struct rsp_que *rsp ) ;
#line 644
void qla2x00_sp_free(void *data , void *ptr ) ;
#line 645
void qla2x00_sp_timeout(unsigned long __data ) ;
#line 676
__inline void qla2x00_set_model_info(scsi_qla_host_t *vha , uint8_t *model , size_t len ,
                                     char *def ) ;
#line 682
int qla82xx_check_md_needed(scsi_qla_host_t *vha ) ;
#line 683
void qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha ) ;
#line 719
void qla8044_read_reset_template(struct scsi_qla_host *vha ) ;
#line 720
void qla8044_set_idc_dontreset(struct scsi_qla_host *vha ) ;
#line 721
int qla8044_rd_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg ) ;
#line 41 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla2x00_debounce_register(uint16_t volatile   *addr ) 
{ 
  uint16_t volatile   first ;
  uint16_t volatile   second ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
  ldv_43298: 
#line 47
  tmp = readw((void const volatile   *)addr);
#line 47
  first = tmp;
#line 48
  __asm__  volatile   ("": : : "memory");
#line 49
  cpu_relax();
#line 50
  tmp___0 = readw((void const volatile   *)addr);
#line 50
  second = tmp___0;
#line 51
  if ((int )((unsigned short )first) != (int )((unsigned short )second)) {
#line 53
    goto ldv_43298;
  } else {

  }

#line 53
  return ((uint16_t )first);
}
}
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___0(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 154
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 155
  atomic_set(& fcport->state, state);
#line 158
  if (old_state != 0 && old_state != state) {
#line 159
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___0[old_state], port_state_str___0[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 165
  return;
}
}
#line 241 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_init_timer(srb_t *sp , unsigned long tmo ) 
{ 


  {
#line 243
  reg_timer_7(& sp->u.iocb_cmd.timer);
#line 244
  sp->u.iocb_cmd.timer.expires = tmo * 250UL + (unsigned long )jiffies;
#line 245
  sp->u.iocb_cmd.timer.data = (unsigned long )sp;
#line 246
  sp->u.iocb_cmd.timer.function = & qla2x00_sp_timeout;
#line 247
  add_timer(& sp->u.iocb_cmd.timer);
#line 248
  sp->free = & qla2x00_sp_free;
#line 249
  if (((((sp->fcport)->vha)->hw)->device_type & 131072U) != 0U && (unsigned int )sp->type == 10U) {
#line 251
    init_completion(& sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);
  } else {

  }
#line 252
  return;
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 6 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_devtbl.h"
static char *qla2x00_model_name[184U]  = 
#line 6 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_devtbl.h"
  {      (char *)"QLA2340",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2342",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel", 
        (char *)"QLA2344",      (char *)"133MHz PCI-X to 2Gb FC, Quad Channel",      (char *)"QCP2342",      (char *)"cPCI to 2Gb FC, Dual Channel", 
        (char *)"QSB2340",      (char *)"SBUS to 2Gb FC, Single Channel",      (char *)"QSB2342",      (char *)"SBUS to 2Gb FC, Dual Channel", 
        (char *)"QLA2310",      (char *)"Sun 66MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2332",      (char *)"Sun 66MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"QCP2332",      (char *)"Sun cPCI to 2Gb FC, Dual Channel",      (char *)"QCP2340",      (char *)"cPCI to 2Gb FC, Single Channel", 
        (char *)"QLA2342",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)"QCP2342",      (char *)"Sun - cPCI to 2Gb FC, Dual Channel", 
        (char *)"QLA2350",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2352",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel", 
        (char *)"QLA2352",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QLA2360",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"QLA2362",      (char *)"133MHz PCI-X to 2Gb FC, Dual Channel",      (char *)"QLE2360",      (char *)"PCI-Express to 2Gb FC, Single Channel", 
        (char *)"QLE2362",      (char *)"PCI-Express to 2Gb FC, Dual Channel",      (char *)"QLA200",      (char *)"133MHz PCI-X to 2Gb FC Optical", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QLA200P",      (char *)"133MHz PCI-X to 2Gb FC SFP",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QLA210",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)"EMC 250",      (char *)"133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"HP A7538A",      (char *)"HP 1p2g PCI-X to 2Gb FC, Single Channel", 
        (char *)"QLA210",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Single Channel",      (char *)"QLA2460",      (char *)"PCI-X 2.0 to 4Gb FC, Single Channel", 
        (char *)"QLA2462",      (char *)"PCI-X 2.0 to 4Gb FC, Dual Channel",      (char *)"QMC2462",      (char *)"IBM eServer BC 4Gb FC Expansion Card", 
        (char *)"QMC2462S",      (char *)"IBM eServer BC 4Gb FC Expansion Card SFF",      (char *)"QLE2460",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel",      (char *)"QME2462",      (char *)"Dell BS PCI-Express to 4Gb FC, Dual Channel", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QEM2462",      (char *)"Sun Server I/O Module 4Gb FC, Dual Channel", 
        (char *)"QLE210",      (char *)"PCI-Express to 2Gb FC, Single Channel",      (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLA2460",      (char *)"Sun PCI-X 2.0 to 4Gb FC, Single Channel",      (char *)"QLA2462",      (char *)"Sun PCI-X 2.0 to 4Gb FC, Dual Channel", 
        (char *)"QLE2460",      (char *)"Sun PCI-Express to 2Gb FC, Single Channel",      (char *)"QLE2462",      (char *)"Sun PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QEM2462",      (char *)"Server I/O Module 4Gb FC, Dual Channel",      (char *)"QLE2440",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE2464",      (char *)"PCI-Express to 4Gb FC, Quad Channel",      (char *)"QLA2440",      (char *)"PCI-X 2.0 to 4Gb FC, Single Channel", 
        (char *)"HP AE369A",      (char *)"PCI-X 2.0 to 4Gb FC, Dual Channel",      (char *)"QLA2340",      (char *)"Sun 133MHz PCI-X to 2Gb FC, Single Channel", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QMC2432M",      (char *)"IBM eServer BC 4Gb FC Expansion Card CFFE",      (char *)"QMC2422M",      (char *)"IBM eServer BC 4Gb FC Expansion Card CFFX", 
        (char *)"QLE220",      (char *)"Sun PCI-Express to 4Gb FC, Single Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)"QME2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel Mezz HBA",      (char *)"QMH2462",      (char *)"PCI-Express to 4Gb FC, Dual Channel Mezz HBA", 
        (char *)" ",      (char *)" ",      (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel", 
        (char *)"QLE220",      (char *)"PCI-Express to 4Gb FC, Single Channel",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)" ",      (char *)" ", 
        (char *)" ",      (char *)" ",      (char *)"QME2472",      (char *)"Dell BS PCI-Express to 4Gb FC, Dual Channel"};
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_fc_port_added(struct scsi_qla_host *vha , fc_port_t *fcport ) ;
#line 945
void qlt_update_vp_map(struct scsi_qla_host *vha , int cmd ) ;
#line 954 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static bool qla_tgt_mode_enabled(struct scsi_qla_host *ha ) 
{ 


  {
#line 956
  return (((int )(ha->host)->active_mode & 2) != 0);
}
}
#line 987
void qlt_init_atio_q_entries(struct scsi_qla_host *vha ) ;
#line 988
void qlt_24xx_process_atio_queue(struct scsi_qla_host *vha ) ;
#line 989
void qlt_24xx_config_rings(struct scsi_qla_host *vha ) ;
#line 990
void qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_24xx *nv ) ;
#line 992
void qlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_24xx *icb ) ;
#line 994
void qlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_81xx *icb ) ;
#line 996
void qlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_81xx *nv ) ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_isp_firmware(scsi_qla_host_t *vha ) ;
#line 326
static int qla2x00_setup_chip(scsi_qla_host_t *vha ) ;
#line 327
static int qla2x00_fw_ready(scsi_qla_host_t *vha ) ;
#line 328
static int qla2x00_configure_hba(scsi_qla_host_t *vha ) ;
#line 329
static int qla2x00_configure_loop(scsi_qla_host_t *vha ) ;
#line 330
static int qla2x00_configure_local_loop(scsi_qla_host_t *vha ) ;
#line 331
static int qla2x00_configure_fabric(scsi_qla_host_t *vha ) ;
#line 332
static int qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha , struct list_head *new_fcports ) ;
#line 333
static int qla2x00_fabric_dev_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) ;
#line 336
static int qla2x00_restart_isp(scsi_qla_host_t *vha ) ;
#line 338
static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *vha ) ;
#line 339
static int qla84xx_init_chip(scsi_qla_host_t *vha ) ;
#line 340
static int qla25xx_init_queues(struct qla_hw_data *ha ) ;
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_sp_timeout(unsigned long __data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *iocb ;
  fc_port_t *fcport ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 347
  sp = (srb_t *)__data;
#line 349
  fcport = sp->fcport;
#line 350
  ha = (fcport->vha)->hw;
#line 354
  tmp = spinlock_check(& ha->hardware_lock);
#line 354
  flags = _raw_spin_lock_irqsave(tmp);
#line 355
  req = *(ha->req_q_map);
#line 356
  *(req->outstanding_cmds + (unsigned long )sp->handle) = (srb_t *)0;
#line 357
  iocb = & sp->u.iocb_cmd;
#line 358
  (*(iocb->timeout))((void *)sp);
#line 359
  (*(sp->free))((void *)fcport->vha, (void *)sp);
#line 360
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 361
  return;
}
}
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_sp_free(void *data , void *ptr ) 
{ 
  srb_t *sp ;
  struct srb_iocb *iocb ;
  struct scsi_qla_host *vha ;

  {
#line 366
  sp = (srb_t *)ptr;
#line 367
  iocb = & sp->u.iocb_cmd;
#line 368
  vha = (struct scsi_qla_host *)data;
#line 370
  ldv_del_timer_19(& iocb->timer);
#line 371
  qla2x00_rel_sp(vha, sp);
#line 372
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
unsigned long qla2x00_get_async_timeout(struct scsi_qla_host *vha ) 
{ 
  unsigned long tmo ;
  struct qla_hw_data *ha ;

  {
#line 380
  ha = vha->hw;
#line 383
  tmo = (unsigned long )((int )((unsigned int )ha->r_a_tov / 10U) * 2);
#line 384
  if ((ha->device_type & 131072U) != 0U) {
#line 385
    tmo = 20UL;
  } else
#line 386
  if ((ha->device_type & 134217728U) == 0U) {
#line 391
    tmo = (unsigned long )ha->login_timeout;
  } else {

  }
#line 393
  return (tmo);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_async_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct srb_iocb *lio ;

  {
#line 399
  sp = (srb_t *)data;
#line 400
  fcport = sp->fcport;
#line 402
  ql_dbg(268435456U, fcport->vha, 8305, "Async-%s timeout - hdl=%x portid=%02x%02x%02x.\n",
         sp->name, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 407
  fcport->flags = fcport->flags & 4294967287U;
#line 408
  if ((unsigned int )sp->type == 1U) {
#line 409
    lio = & sp->u.iocb_cmd;
#line 410
    qla2x00_post_async_logout_work(fcport->vha, fcport, (uint16_t *)0U);
#line 412
    lio->u.logio.data[0] = 16389U;
#line 413
    lio->u.logio.data[1] = (unsigned int )lio->u.logio.flags & 1U;
#line 415
    qla2x00_post_async_login_done_work(fcport->vha, fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 418
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_async_login_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 423
  sp = (srb_t *)ptr;
#line 424
  lio = & sp->u.iocb_cmd;
#line 425
  vha = (struct scsi_qla_host *)data;
#line 427
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 427
  if (tmp == 0) {
#line 428
    qla2x00_post_async_login_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 430
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 431
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_async_login(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 441
  rval = 258;
#line 442
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 443
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 444
    goto done;
  } else {

  }
#line 446
  sp->type = 1U;
#line 447
  sp->name = (char *)"login";
#line 448
  tmp = qla2x00_get_async_timeout(vha);
#line 448
  qla2x00_init_timer(sp, tmp + 2UL);
#line 450
  lio = & sp->u.iocb_cmd;
#line 451
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 452
  sp->done = & qla2x00_async_login_sp_done;
#line 453
  lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 2U);
#line 454
  if ((int )*(data + 1UL) & 1) {
#line 455
    lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 1U);
  } else {

  }
#line 456
  rval = qla2x00_start_sp(sp);
#line 457
  if (rval != 0) {
#line 458
    goto done_free_sp;
  } else {

  }
#line 460
  ql_dbg(268435456U, vha, 8306, "Async-login - hdl=%x, loopid=%x portid=%02x%02x%02x retries=%d.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, fcport->login_retry);
#line 465
  return (rval);
  done_free_sp: 
#line 468
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 470
  return (rval);
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_async_logout_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 476
  sp = (srb_t *)ptr;
#line 477
  lio = & sp->u.iocb_cmd;
#line 478
  vha = (struct scsi_qla_host *)data;
#line 480
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 480
  if (tmp == 0) {
#line 481
    qla2x00_post_async_logout_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 483
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 484
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_async_logout(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 493
  rval = 258;
#line 494
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 495
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 496
    goto done;
  } else {

  }
#line 498
  sp->type = 2U;
#line 499
  sp->name = (char *)"logout";
#line 500
  tmp = qla2x00_get_async_timeout(vha);
#line 500
  qla2x00_init_timer(sp, tmp + 2UL);
#line 502
  lio = & sp->u.iocb_cmd;
#line 503
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 504
  sp->done = & qla2x00_async_logout_sp_done;
#line 505
  rval = qla2x00_start_sp(sp);
#line 506
  if (rval != 0) {
#line 507
    goto done_free_sp;
  } else {

  }
#line 509
  ql_dbg(268435456U, vha, 8304, "Async-logout - hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 513
  return (rval);
  done_free_sp: 
#line 516
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 518
  return (rval);
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_async_adisc_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  struct scsi_qla_host *vha ;
  int tmp ;

  {
#line 524
  sp = (srb_t *)ptr;
#line 525
  lio = & sp->u.iocb_cmd;
#line 526
  vha = (struct scsi_qla_host *)data;
#line 528
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 528
  if (tmp == 0) {
#line 529
    qla2x00_post_async_adisc_done_work((sp->fcport)->vha, sp->fcport, (uint16_t *)(& lio->u.logio.data));
  } else {

  }
#line 531
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 532
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_async_adisc(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;
  int rval ;
  unsigned long tmp ;

  {
#line 542
  rval = 258;
#line 543
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 544
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 545
    goto done;
  } else {

  }
#line 547
  sp->type = 6U;
#line 548
  sp->name = (char *)"adisc";
#line 549
  tmp = qla2x00_get_async_timeout(vha);
#line 549
  qla2x00_init_timer(sp, tmp + 2UL);
#line 551
  lio = & sp->u.iocb_cmd;
#line 552
  lio->timeout = & qla2x00_async_iocb_timeout;
#line 553
  sp->done = & qla2x00_async_adisc_sp_done;
#line 554
  if ((int )*(data + 1UL) & 1) {
#line 555
    lio->u.logio.flags = (uint16_t )((unsigned int )lio->u.logio.flags | 1U);
  } else {

  }
#line 556
  rval = qla2x00_start_sp(sp);
#line 557
  if (rval != 0) {
#line 558
    goto done_free_sp;
  } else {

  }
#line 560
  ql_dbg(268435456U, vha, 8303, "Async-adisc - hdl=%x loopid=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 564
  return (rval);
  done_free_sp: 
#line 567
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 569
  return (rval);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_async_tm_cmd_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *iocb ;
  struct scsi_qla_host *vha ;
  uint32_t flags ;
  uint16_t lun ;
  int rval ;
  int tmp ;

  {
#line 575
  sp = (srb_t *)ptr;
#line 576
  iocb = & sp->u.iocb_cmd;
#line 577
  vha = (struct scsi_qla_host *)data;
#line 582
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 582
  if (tmp == 0) {
#line 583
    flags = iocb->u.tmf.flags;
#line 584
    lun = (unsigned short )iocb->u.tmf.lun;
#line 587
    rval = qla2x00_marker(vha, *((vha->hw)->req_q_map), *((vha->hw)->rsp_q_map), (int )(sp->fcport)->loop_id,
                          (int )lun, flags != 16U);
#line 591
    if (rval != 0 || iocb->u.tmf.data != 0U) {
#line 592
      ql_dbg(4194304U, vha, 32816, "TM IOCB failed (%x).\n", rval);
    } else {

    }
  } else {

  }
#line 596
  (*(sp->free))((void *)(sp->fcport)->vha, (void *)sp);
#line 597
  return;
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_async_tm_cmd(fc_port_t *fcport , uint32_t tm_flags , uint32_t lun , uint32_t tag ) 
{ 
  struct scsi_qla_host *vha ;
  srb_t *sp ;
  struct srb_iocb *tcf ;
  int rval ;
  unsigned long tmp ;

  {
#line 603
  vha = fcport->vha;
#line 608
  rval = 258;
#line 609
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 610
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 611
    goto done;
  } else {

  }
#line 613
  sp->type = 7U;
#line 614
  sp->name = (char *)"tmf";
#line 615
  tmp = qla2x00_get_async_timeout(vha);
#line 615
  qla2x00_init_timer(sp, tmp + 2UL);
#line 617
  tcf = & sp->u.iocb_cmd;
#line 618
  tcf->u.tmf.flags = tm_flags;
#line 619
  tcf->u.tmf.lun = lun;
#line 620
  tcf->u.tmf.data = tag;
#line 621
  tcf->timeout = & qla2x00_async_iocb_timeout;
#line 622
  sp->done = & qla2x00_async_tm_cmd_done;
#line 624
  rval = qla2x00_start_sp(sp);
#line 625
  if (rval != 0) {
#line 626
    goto done_free_sp;
  } else {

  }
#line 628
  ql_dbg(4194304U, vha, 32815, "Async-tmf hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
         sp->handle, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 632
  return (rval);
  done_free_sp: 
#line 635
  (*(sp->free))((void *)fcport->vha, (void *)sp);
  done: ;
#line 637
  return (rval);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_async_login_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 
  int rval ;

  {
#line 646
  switch ((int )*data) {
  case 16384: 
#line 653
  rval = qla2x00_get_port_database(vha, fcport, 0);
#line 654
  if (rval == 10) {
#line 655
    fcport->flags = fcport->flags & 4294967287U;
#line 656
    fcport->flags = fcport->flags | 2U;
#line 657
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 658
    goto ldv_60865;
  } else {

  }
#line 661
  if (rval != 0) {
#line 662
    qla2x00_post_async_logout_work(vha, fcport, (uint16_t *)0U);
#line 663
    qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 664
    goto ldv_60865;
  } else {

  }
#line 666
  if ((fcport->flags & 4U) != 0U) {
#line 667
    qla2x00_post_async_adisc_work(vha, fcport, data);
#line 668
    goto ldv_60865;
  } else {

  }
#line 670
  qla2x00_update_fcport(vha, fcport);
#line 671
  goto ldv_60865;
  case 16389: 
#line 673
  fcport->flags = fcport->flags & 4294967287U;
#line 674
  if ((int )*(data + 1UL) & 1) {
#line 675
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 677
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 678
  goto ldv_60865;
  case 16391: 
#line 680
  fcport->loop_id = *(data + 1UL);
#line 681
  qla2x00_post_async_logout_work(vha, fcport, (uint16_t *)0U);
#line 682
  qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 683
  goto ldv_60865;
  case 16392: 
#line 685
  fcport->loop_id = (uint16_t )((int )fcport->loop_id + 1);
#line 686
  rval = qla2x00_find_new_loop_id(vha, fcport);
#line 687
  if (rval != 0) {
#line 688
    fcport->flags = fcport->flags & 4294967287U;
#line 689
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 690
    goto ldv_60865;
  } else {

  }
#line 692
  qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 693
  goto ldv_60865;
  }
  ldv_60865: ;
#line 695
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_async_logout_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 


  {
#line 702
  qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 703
  return;
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_async_adisc_done(struct scsi_qla_host *vha , fc_port_t *fcport , uint16_t *data ) 
{ 


  {
#line 710
  if ((unsigned int )*data == 16384U) {
#line 711
    qla2x00_update_fcport(vha, fcport);
#line 713
    return;
  } else {

  }
#line 717
  fcport->flags = fcport->flags & 4294967287U;
#line 718
  if ((int )*(data + 1UL) & 1) {
#line 719
    set_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 721
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 723
  return;
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla83xx_nic_core_fw_load(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t idc_major_ver ;
  uint32_t idc_minor_ver ;
  uint16_t config[4U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 733
  rval = 0;
#line 734
  ha = vha->hw;
#line 738
  qla83xx_idc_lock(vha, 0);
#line 743
  ha->fcoe_dev_init_timeout = 30U;
#line 744
  ha->fcoe_reset_timeout = 10U;
#line 747
  tmp = __qla83xx_set_drv_presence(vha);
#line 747
  if (tmp != 0) {
#line 748
    ql_dbg(524288U, vha, 45175, "Error while setting DRV-Presence.\n");
#line 750
    rval = 258;
#line 751
    goto exit;
  } else {

  }
#line 755
  qla83xx_reset_ownership(vha);
#line 763
  qla83xx_rd_reg(vha, 571483008U, & idc_major_ver);
#line 764
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 766
    idc_major_ver = 1U;
#line 767
    qla83xx_wr_reg(vha, 571483008U, idc_major_ver);
#line 770
    qla83xx_wr_reg(vha, 571483036U, 0U);
  } else
#line 771
  if (idc_major_ver != 1U) {
#line 776
    ql_log(1U, vha, 45181, "Failing load, idc_major_ver=%d, expected_major_ver=%d.\n",
           idc_major_ver, 1);
#line 779
    __qla83xx_clear_drv_presence(vha);
#line 780
    rval = 258;
#line 781
    goto exit;
  } else {

  }
#line 784
  qla83xx_rd_reg(vha, 571483032U, & idc_minor_ver);
#line 785
  idc_minor_ver = idc_minor_ver;
#line 786
  qla83xx_wr_reg(vha, 571483032U, idc_minor_ver);
#line 788
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 789
    memset((void *)(& config), 0, 8UL);
#line 790
    tmp___0 = qla81xx_get_port_config(vha, (uint16_t *)(& config));
#line 790
    if (tmp___0 == 0) {
#line 791
      qla83xx_wr_reg(vha, 571483012U, 3U);
    } else {

    }
  } else {

  }
#line 795
  rval = qla83xx_idc_state_handler(vha);
  exit: 
#line 798
  qla83xx_idc_unlock(vha, 0);
#line 800
  return (rval);
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_initialize_adapter(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  bool tmp___0 ;

  {
#line 817
  ha = vha->hw;
#line 818
  req = *(ha->req_q_map);
#line 821
  vha->flags.online = 0U;
#line 822
  ha->flags.chip_reset_done = 0U;
#line 823
  vha->flags.reset_active = 0U;
#line 824
  ha->flags.pci_channel_io_perm_failure = 0U;
#line 825
  ha->flags.eeh_busy = 0U;
#line 826
  vha->qla_stats.jiffies_at_last_reset = get_jiffies_64();
#line 827
  atomic_set(& vha->loop_down_timer, 255);
#line 828
  atomic_set(& vha->loop_state, 2);
#line 829
  vha->device_flags = 2U;
#line 830
  vha->dpc_flags = 0UL;
#line 831
  vha->flags.management_server_logged_in = 0U;
#line 832
  vha->marker_needed = 0U;
#line 833
  ha->isp_abort_cnt = 0U;
#line 834
  ha->beacon_blink_led = 0U;
#line 836
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 837
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 839
  ql_dbg(1073741824U, vha, 64, "Configuring PCI space...\n");
#line 841
  rval = (*((ha->isp_ops)->pci_config))(vha);
#line 842
  if (rval != 0) {
#line 843
    ql_log(1U, vha, 68, "Unable to configure PCI space.\n");
#line 845
    return (rval);
  } else {

  }
#line 848
  (*((ha->isp_ops)->reset_chip))(vha);
#line 850
  rval = qla2xxx_get_flash_info(vha);
#line 851
  if (rval != 0) {
#line 852
    ql_log(0U, vha, 79, "Unable to validate FLASH data.\n");
#line 854
    return (rval);
  } else {

  }
#line 857
  if ((ha->device_type & 262144U) != 0U) {
#line 858
    qla8044_read_reset_template(vha);
#line 864
    if (ql2xdontresethba == 1) {
#line 865
      qla8044_set_idc_dontreset(vha);
    } else {

    }
  } else {

  }
#line 868
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 869
  ql_dbg(1073741824U, vha, 97, "Configure NVRAM parameters...\n");
#line 872
  (*((ha->isp_ops)->nvram_config))(vha);
#line 874
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 876
    ql_log(2U, vha, 119, "Masking HBA WWPN %8phN (via NVRAM).\n", (uint8_t *)(& vha->port_name));
#line 878
    return (258);
  } else {

  }
#line 881
  ql_dbg(1073741824U, vha, 120, "Verifying loaded RISC code...\n");
#line 884
  tmp = qla2x00_isp_firmware(vha);
#line 884
  if (tmp != 0) {
#line 885
    rval = (*((ha->isp_ops)->chip_diag))(vha);
#line 886
    if (rval != 0) {
#line 887
      return (rval);
    } else {

    }
#line 888
    rval = qla2x00_setup_chip(vha);
#line 889
    if (rval != 0) {
#line 890
      return (rval);
    } else {

    }
  } else {

  }
#line 893
  if ((ha->device_type & 4096U) != 0U) {
#line 894
    ha->cs84xx = qla84xx_get_chip(vha);
#line 895
    if ((unsigned long )ha->cs84xx == (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 896
      ql_log(1U, vha, 208, "Unable to configure ISP84XX.\n");
#line 898
      return (258);
    } else {

    }
  } else {

  }
#line 902
  tmp___0 = qla_ini_mode_enabled(vha);
#line 902
  if ((int )tmp___0) {
#line 903
    rval = qla2x00_init_rings(vha);
  } else {

  }
#line 905
  ha->flags.chip_reset_done = 1U;
#line 907
  if (rval == 0 && (ha->device_type & 4096U) != 0U) {
#line 909
    rval = qla84xx_init_chip(vha);
#line 910
    if (rval != 0) {
#line 911
      ql_log(1U, vha, 212, "Unable to initialize ISP84XX.\n");
#line 913
      qla84xx_put_chip(vha);
    } else {

    }
  } else {

  }
#line 918
  if ((ha->device_type & 65536U) != 0U) {
#line 919
    rval = qla83xx_nic_core_fw_load(vha);
#line 920
    if (rval != 0) {
#line 921
      ql_log(1U, vha, 292, "Error in initializing NIC Core f/w.\n");
    } else {

    }
  } else {

  }
#line 925
  if (((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) {
#line 926
    qla24xx_read_fcp_prio_cfg(vha);
  } else {

  }
#line 928
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 929
    qla82xx_set_driver_version(vha, (char *)"8.06.00.08-k");
  } else {
#line 931
    qla25xx_set_driver_version(vha, (char *)"8.06.00.08-k");
  }
#line 933
  return (rval);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2100_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;

  {
#line 947
  ha = vha->hw;
#line 948
  reg = & (ha->iobase)->isp;
#line 950
  pci_set_master(ha->pdev);
#line 951
  pci_try_set_mwi(ha->pdev);
#line 953
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 954
  w = (uint16_t )((unsigned int )w | 320U);
#line 955
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 957
  pci_disable_rom(ha->pdev);
#line 960
  tmp = spinlock_check(& ha->hardware_lock);
#line 960
  flags = _raw_spin_lock_irqsave(tmp);
#line 961
  tmp___0 = readw((void const volatile   *)(& reg->ctrl_status));
#line 961
  ha->pci_attr = (uint32_t )tmp___0;
#line 962
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 964
  return (0);
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2300_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned short tmp___3 ;

  {
#line 977
  flags = 0UL;
#line 979
  ha = vha->hw;
#line 980
  reg = & (ha->iobase)->isp;
#line 982
  pci_set_master(ha->pdev);
#line 983
  pci_try_set_mwi(ha->pdev);
#line 985
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 986
  w = (uint16_t )((unsigned int )w | 320U);
#line 988
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 989
    w = (unsigned int )w & 64511U;
  } else {

  }
#line 990
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 999
  if ((ha->device_type & 4U) != 0U) {
#line 1000
    tmp = spinlock_check(& ha->hardware_lock);
#line 1000
    flags = _raw_spin_lock_irqsave(tmp);
#line 1003
    writew(8192, (void volatile   *)(& reg->hccr));
#line 1004
    cnt = 0U;
#line 1004
    goto ldv_60917;
    ldv_60916: 
#line 1005
    tmp___0 = readw((void const volatile   *)(& reg->hccr));
#line 1005
    if (((int )tmp___0 & 32) != 0) {
#line 1006
      goto ldv_60915;
    } else {

    }
#line 1008
    __const_udelay(42950UL);
#line 1004
    cnt = cnt + 1U;
    ldv_60917: ;
#line 1004
    if (cnt <= 29999U) {
#line 1006
      goto ldv_60916;
    } else {

    }
    ldv_60915: 
#line 1012
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 1013
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1016
    ha->fb_rev = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1018
    if ((unsigned int )ha->fb_rev == 6U) {
#line 1019
      pci_clear_mwi(ha->pdev);
    } else {

    }
#line 1022
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 1023
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1026
    writew(12288, (void volatile   *)(& reg->hccr));
#line 1027
    cnt = 0U;
#line 1027
    goto ldv_60920;
    ldv_60919: 
#line 1028
    tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 1028
    if (((int )tmp___1 & 32) == 0) {
#line 1029
      goto ldv_60918;
    } else {

    }
#line 1031
    __const_udelay(42950UL);
#line 1027
    cnt = cnt + 1U;
    ldv_60920: ;
#line 1027
    if (cnt <= 29999U) {
#line 1029
      goto ldv_60919;
    } else {

    }
    ldv_60918: 
#line 1034
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1037
  pci_write_config_byte((struct pci_dev  const  *)ha->pdev, 13, 128);
#line 1039
  pci_disable_rom(ha->pdev);
#line 1042
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 1042
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1043
  tmp___3 = readw((void const volatile   *)(& reg->ctrl_status));
#line 1043
  ha->pci_attr = (uint32_t )tmp___3;
#line 1044
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1046
  return (0);
}
}
#line 1056 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_pci_config(scsi_qla_host_t *vha ) 
{ 
  uint16_t w ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  bool tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1059
  flags = 0UL;
#line 1060
  ha = vha->hw;
#line 1061
  reg = & (ha->iobase)->isp24;
#line 1063
  pci_set_master(ha->pdev);
#line 1064
  pci_try_set_mwi(ha->pdev);
#line 1066
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 1067
  w = (uint16_t )((unsigned int )w | 320U);
#line 1068
  w = (unsigned int )w & 64511U;
#line 1069
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 1071
  pci_write_config_byte((struct pci_dev  const  *)ha->pdev, 13, 128);
#line 1074
  tmp = pci_find_capability(ha->pdev, 7);
#line 1074
  if (tmp != 0) {
#line 1075
    pcix_set_mmrbc(ha->pdev, 2048);
  } else {

  }
#line 1078
  tmp___0 = pci_is_pcie(ha->pdev);
#line 1078
  if ((int )tmp___0) {
#line 1079
    pcie_set_readrq(ha->pdev, 4096);
  } else {

  }
#line 1081
  pci_disable_rom(ha->pdev);
#line 1083
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 1086
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 1086
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1087
  ha->pci_attr = readl((void const volatile   *)(& reg->ctrl_status));
#line 1088
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1090
  return (0);
}
}
#line 1100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla25xx_pci_config(scsi_qla_host_t *vha ) 
{ 
  uint16_t w ;
  struct qla_hw_data *ha ;
  bool tmp ;

  {
#line 1103
  ha = vha->hw;
#line 1105
  pci_set_master(ha->pdev);
#line 1106
  pci_try_set_mwi(ha->pdev);
#line 1108
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 1109
  w = (uint16_t )((unsigned int )w | 320U);
#line 1110
  w = (unsigned int )w & 64511U;
#line 1111
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 1114
  tmp = pci_is_pcie(ha->pdev);
#line 1114
  if ((int )tmp) {
#line 1115
    pcie_set_readrq(ha->pdev, 4096);
  } else {

  }
#line 1117
  pci_disable_rom(ha->pdev);
#line 1119
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 1121
  return (0);
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_isp_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t loop_id ;
  uint16_t topo ;
  uint16_t sw_cap ;
  uint8_t domain ;
  uint8_t area ;
  uint8_t al_pa ;
  struct qla_hw_data *ha ;

  {
#line 1136
  ha = vha->hw;
#line 1139
  rval = 258;
#line 1141
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1142
    ql_log(2U, vha, 121, "RISC CODE NOT loaded.\n");
#line 1145
    rval = qla2x00_verify_checksum(vha, ha->fw_srisc_address);
#line 1146
    if (rval == 0) {
#line 1148
      rval = qla2x00_get_adapter_id(vha, & loop_id, & al_pa, & area, & domain, & topo,
                                    & sw_cap);
    } else {

    }
  } else {

  }
#line 1153
  if (rval != 0) {
#line 1154
    ql_dbg(1073741824U, vha, 122, "**** Load RISC code ****.\n");
  } else {

  }
#line 1157
  return (rval);
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_reset_chip(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint32_t cnt ;
  uint16_t cmd ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;

  {
#line 1169
  flags = 0UL;
#line 1170
  ha = vha->hw;
#line 1171
  reg = & (ha->iobase)->isp;
#line 1175
  tmp = pci_channel_offline(ha->pdev);
#line 1175
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 1175
  if (tmp___0 != 0L) {
#line 1176
    return;
  } else {

  }
#line 1178
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 1180
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 1180
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1183
  cmd = 0U;
#line 1184
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & cmd);
#line 1185
  cmd = (unsigned int )cmd & 65531U;
#line 1186
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )cmd);
#line 1188
  if ((ha->device_type & 1U) == 0U) {
#line 1190
    writew(8192, (void volatile   *)(& reg->hccr));
#line 1191
    if ((ha->device_type & 2U) != 0U || (ha->device_type & 4U) != 0U) {
#line 1192
      cnt = 0U;
#line 1192
      goto ldv_60963;
      ldv_60962: 
#line 1193
      tmp___2 = readw((void const volatile   *)(& reg->hccr));
#line 1193
      if (((int )tmp___2 & 32) != 0) {
#line 1195
        goto ldv_60961;
      } else {

      }
#line 1196
      __const_udelay(429500UL);
#line 1192
      cnt = cnt + 1U;
      ldv_60963: ;
#line 1192
      if (cnt <= 29999U) {
#line 1194
        goto ldv_60962;
      } else {

      }
      ldv_60961: ;
    } else {
#line 1199
      readw((void const volatile   *)(& reg->hccr));
#line 1200
      __const_udelay(42950UL);
    }
#line 1204
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 1205
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1208
    writew(256, (void volatile   *)(& reg->fpm_diag_config));
#line 1209
    readw((void const volatile   *)(& reg->fpm_diag_config));
#line 1212
    if ((ha->device_type & 2U) == 0U) {
#line 1213
      writew(0, (void volatile   *)(& reg->fpm_diag_config));
#line 1214
      readw((void const volatile   *)(& reg->fpm_diag_config));
    } else {

    }
#line 1218
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 1219
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1222
    if ((ha->device_type & 2U) != 0U) {
#line 1223
      writew(40960, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1224
      readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
    } else {
#line 1226
      writew(252, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1229
      cnt = 0U;
#line 1229
      goto ldv_60966;
      ldv_60965: 
#line 1230
      tmp___3 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->fb_cmd_2100 : & reg->u.isp2300.fb_cmd));
#line 1230
      if (((int )tmp___3 & 255) == 0) {
#line 1231
        goto ldv_60964;
      } else {

      }
#line 1232
      __const_udelay(429500UL);
#line 1229
      cnt = cnt + 1U;
      ldv_60966: ;
#line 1229
      if (cnt <= 2999U) {
#line 1231
        goto ldv_60965;
      } else {

      }
      ldv_60964: ;
    }
#line 1237
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 1238
    readw((void const volatile   *)(& reg->ctrl_status));
#line 1241
    writew(4096, (void volatile   *)(& reg->hccr));
#line 1242
    readw((void const volatile   *)(& reg->hccr));
#line 1245
    writew(12288, (void volatile   *)(& reg->hccr));
#line 1246
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1249
  writew(28672, (void volatile   *)(& reg->hccr));
#line 1250
  writew(24576, (void volatile   *)(& reg->hccr));
#line 1253
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 1256
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1262
    __const_udelay(85900UL);
#line 1263
    cnt = 30000U;
#line 1263
    goto ldv_60969;
    ldv_60968: 
#line 1264
    tmp___4 = readw((void const volatile   *)(& reg->ctrl_status));
#line 1264
    if (((int )tmp___4 & 1) == 0) {
#line 1266
      goto ldv_60967;
    } else {

    }
#line 1267
    __const_udelay(429500UL);
#line 1263
    cnt = cnt - 1U;
    ldv_60969: ;
#line 1263
    if (cnt != 0U) {
#line 1265
      goto ldv_60968;
    } else {

    }
    ldv_60967: ;
  } else {
#line 1270
    __const_udelay(42950UL);
  }
#line 1273
  writew(4096, (void volatile   *)(& reg->hccr));
#line 1275
  writew(0, (void volatile   *)(& reg->semaphore));
#line 1278
  writew(12288, (void volatile   *)(& reg->hccr));
#line 1279
  readw((void const volatile   *)(& reg->hccr));
#line 1281
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1282
    cnt = 0U;
#line 1282
    goto ldv_60972;
    ldv_60971: 
#line 1283
    tmp___5 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1283
    if ((unsigned int )tmp___5 != 4U) {
#line 1284
      goto ldv_60970;
    } else {

    }
#line 1286
    __const_udelay(429500UL);
#line 1282
    cnt = cnt + 1U;
    ldv_60972: ;
#line 1282
    if (cnt <= 29999U) {
#line 1284
      goto ldv_60971;
    } else {

    }
    ldv_60970: ;
  } else {
#line 1289
    __const_udelay(429500UL);
  }
#line 1292
  cmd = (uint16_t )((unsigned int )cmd | 4U);
#line 1293
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )cmd);
#line 1296
  if ((ha->device_type & 1U) == 0U) {
#line 1297
    writew(16385, (void volatile   *)(& reg->hccr));
#line 1298
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1301
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1302
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla81xx_reset_mpi(scsi_qla_host_t *vha ) 
{ 
  uint16_t mb[4U] ;
  int tmp ;

  {
#line 1312
  mb[0] = 4112U;
#line 1312
  mb[1] = 0U;
#line 1312
  mb[2] = 1U;
#line 1312
  mb[3] = 0U;
#line 1314
  if (((vha->hw)->device_type & 8192U) == 0U) {
#line 1315
    return (0);
  } else {

  }
#line 1317
  tmp = qla81xx_write_mpi_register(vha, (uint16_t *)(& mb));
#line 1317
  return (tmp);
}
}
#line 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
__inline static void qla24xx_reset_risc(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t cnt ;
  uint32_t d2 ;
  uint16_t wd ;
  int abts_cnt ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;

  {
#line 1329
  flags = 0UL;
#line 1330
  ha = vha->hw;
#line 1331
  reg = & (ha->iobase)->isp24;
#line 1336
  tmp = spinlock_check(& ha->hardware_lock);
#line 1336
  flags = _raw_spin_lock_irqsave(tmp);
#line 1339
  writel(65584U, (void volatile   *)(& reg->ctrl_status));
#line 1340
  cnt = 0U;
#line 1340
  goto ldv_60992;
  ldv_60991: 
#line 1341
  tmp___0 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1341
  if ((tmp___0 & 131072U) == 0U) {
#line 1342
    goto ldv_60990;
  } else {

  }
#line 1344
  __const_udelay(42950UL);
#line 1340
  cnt = cnt + 1U;
  ldv_60992: ;
#line 1340
  if (cnt <= 29999U) {
#line 1342
    goto ldv_60991;
  } else {

  }
  ldv_60990: 
#line 1347
  writel(65585U, (void volatile   *)(& reg->ctrl_status));
#line 1349
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 1351
  __const_udelay(429500UL);
#line 1353
  tmp___1 = readw((void const volatile   *)(& reg->mailbox0));
#line 1353
  d2 = (unsigned int )tmp___1;
#line 1354
  cnt = 10000U;
#line 1354
  goto ldv_60994;
  ldv_60993: 
#line 1355
  __const_udelay(21475UL);
#line 1356
  tmp___2 = readw((void const volatile   *)(& reg->mailbox0));
#line 1356
  d2 = (unsigned int )tmp___2;
#line 1357
  __asm__  volatile   ("": : : "memory");
#line 1354
  cnt = cnt - 1U;
  ldv_60994: ;
#line 1354
  if (cnt != 0U && d2 != 0U) {
#line 1356
    goto ldv_60993;
  } else {

  }
#line 1361
  d2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1362
  cnt = 6000000U;
#line 1362
  goto ldv_60997;
  ldv_60996: 
#line 1363
  __const_udelay(21475UL);
#line 1364
  d2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1365
  __asm__  volatile   ("": : : "memory");
#line 1362
  cnt = cnt - 1U;
  ldv_60997: ;
#line 1362
  if (cnt != 0U && (int )d2 & 1) {
#line 1364
    goto ldv_60996;
  } else {

  }
#line 1369
  tmp___4 = test_and_clear_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1369
  if (tmp___4 != 0) {
#line 1370
    tmp___3 = qla81xx_reset_mpi(vha);
#line 1370
    if (tmp___3 != 0) {
#line 1371
      abts_cnt = abts_cnt + 1;
#line 1371
      if (abts_cnt <= 4) {
#line 1372
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1373
        set_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 1379
        abts_cnt = 0;
#line 1380
        vha->flags.online = 0U;
      }
    } else {

    }
  } else {

  }
#line 1385
  writel(268435456U, (void volatile   *)(& reg->hccr));
#line 1386
  readl((void const volatile   *)(& reg->hccr));
#line 1388
  writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 1389
  readl((void const volatile   *)(& reg->hccr));
#line 1391
  writel(536870912U, (void volatile   *)(& reg->hccr));
#line 1392
  readl((void const volatile   *)(& reg->hccr));
#line 1394
  tmp___5 = readw((void const volatile   *)(& reg->mailbox0));
#line 1394
  d2 = (unsigned int )tmp___5;
#line 1395
  cnt = 6000000U;
#line 1395
  goto ldv_61000;
  ldv_60999: 
#line 1396
  __const_udelay(21475UL);
#line 1397
  tmp___6 = readw((void const volatile   *)(& reg->mailbox0));
#line 1397
  d2 = (unsigned int )tmp___6;
#line 1398
  __asm__  volatile   ("": : : "memory");
#line 1395
  cnt = cnt - 1U;
  ldv_61000: ;
#line 1395
  if (cnt != 0U && d2 != 0U) {
#line 1397
    goto ldv_60999;
  } else {

  }
#line 1401
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1403
  if ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1404
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 1405
  return;
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla25xx_read_risc_sema_reg(scsi_qla_host_t *vha , uint32_t *data ) 
{ 
  struct device_reg_24xx *reg ;

  {
#line 1410
  reg = & ((vha->hw)->iobase)->isp24;
#line 1412
  writel(28688U, (void volatile   *)(& reg->iobase_addr));
#line 1413
  *data = readl((void const volatile   *)(& reg->iobase_window) + 6U);
#line 1414
  return;
}
}
#line 1418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla25xx_write_risc_sema_reg(scsi_qla_host_t *vha , uint32_t data ) 
{ 
  struct device_reg_24xx *reg ;

  {
#line 1420
  reg = & ((vha->hw)->iobase)->isp24;
#line 1422
  writel(28688U, (void volatile   *)(& reg->iobase_addr));
#line 1423
  writel(data, (void volatile   *)(& reg->iobase_window) + 6U);
#line 1424
  return;
}
}
#line 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t wd32 ;
  uint delta_msec ;
  uint elapsed_msec ;
  uint timeout_msec ;
  ulong n ;
  ulong tmp ;
  ulong tmp___0 ;

  {
#line 1429
  ha = vha->hw;
#line 1430
  wd32 = 0U;
#line 1431
  delta_msec = 100U;
#line 1432
  elapsed_msec = 0U;
#line 1436
  if ((ha->device_type & 2048U) == 0U && (ha->device_type & 32768U) == 0U) {
#line 1437
    return;
  } else {

  }
  attempt: 
#line 1440
  timeout_msec = 2500U;
#line 1441
  n = (ulong )(timeout_msec / delta_msec);
#line 1442
  goto ldv_61025;
  ldv_61024: 
#line 1443
  qla25xx_write_risc_sema_reg(vha, 65537U);
#line 1444
  qla25xx_read_risc_sema_reg(vha, & wd32);
#line 1445
  if ((int )wd32 & 1) {
#line 1446
    goto ldv_61022;
  } else {

  }
#line 1447
  msleep(delta_msec);
#line 1448
  elapsed_msec = elapsed_msec + delta_msec;
#line 1449
  if (elapsed_msec > 4500U) {
#line 1450
    goto force;
  } else {

  }
  ldv_61025: 
#line 1442
  tmp = n;
#line 1442
  n = n - 1UL;
#line 1442
  if (tmp != 0UL) {
#line 1444
    goto ldv_61024;
  } else {

  }
  ldv_61022: ;
#line 1453
  if (((unsigned long )wd32 & 1UL) == 0UL) {
#line 1454
    goto force;
  } else {

  }
#line 1456
  if (((unsigned long )wd32 & 32768UL) == 0UL) {
#line 1457
    goto acquired;
  } else {

  }
#line 1459
  qla25xx_write_risc_sema_reg(vha, 65536U);
#line 1460
  timeout_msec = 2000U;
#line 1461
  n = (ulong )(timeout_msec / delta_msec);
#line 1462
  goto ldv_61029;
  ldv_61028: 
#line 1463
  qla25xx_read_risc_sema_reg(vha, & wd32);
#line 1464
  if (((unsigned long )wd32 & 32768UL) == 0UL) {
#line 1465
    goto ldv_61027;
  } else {

  }
#line 1466
  msleep(delta_msec);
#line 1467
  elapsed_msec = elapsed_msec + delta_msec;
#line 1468
  if (elapsed_msec > 4500U) {
#line 1469
    goto force;
  } else {

  }
  ldv_61029: 
#line 1462
  tmp___0 = n;
#line 1462
  n = n - 1UL;
#line 1462
  if (tmp___0 != 0UL) {
#line 1464
    goto ldv_61028;
  } else {

  }
  ldv_61027: ;
#line 1472
  if (((unsigned long )wd32 & 32768UL) != 0UL) {
#line 1473
    qla25xx_write_risc_sema_reg(vha, 2147483648U);
  } else {

  }
#line 1475
  goto attempt;
  force: 
#line 1478
  qla25xx_write_risc_sema_reg(vha, 2147516416U);
  acquired: ;
#line 1481
  return;
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla24xx_reset_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1493
  ha = vha->hw;
#line 1495
  tmp = pci_channel_offline(ha->pdev);
#line 1495
  if (tmp != 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 1497
    return;
  } else {

  }
#line 1500
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 1502
  qla25xx_manipulate_risc_semaphore(vha);
#line 1505
  qla24xx_reset_risc(vha);
#line 1506
  return;
}
}
#line 1515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_chip_diag(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  unsigned long flags ;
  uint16_t data ;
  uint32_t cnt ;
  uint16_t mb[5U] ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1518
  ha = vha->hw;
#line 1519
  reg = & (ha->iobase)->isp;
#line 1520
  flags = 0UL;
#line 1524
  req = *(ha->req_q_map);
#line 1527
  rval = 258;
#line 1529
  ql_dbg(1073741824U, vha, 123, "Testing device at %lx.\n", (unsigned long )(& reg->flash_address));
#line 1532
  tmp = spinlock_check(& ha->hardware_lock);
#line 1532
  flags = _raw_spin_lock_irqsave(tmp);
#line 1535
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 1541
  __const_udelay(85900UL);
#line 1542
  data = qla2x00_debounce_register((uint16_t volatile   *)(& reg->ctrl_status));
#line 1543
  cnt = 6000000U;
#line 1543
  goto ldv_61049;
  ldv_61048: 
#line 1544
  __const_udelay(21475UL);
#line 1545
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 1546
  __asm__  volatile   ("": : : "memory");
#line 1543
  cnt = cnt - 1U;
  ldv_61049: ;
#line 1543
  if (cnt != 0U && (int )data & 1) {
#line 1545
    goto ldv_61048;
  } else {

  }

#line 1549
  if (cnt == 0U) {
#line 1550
    goto chip_diag_failed;
  } else {

  }
#line 1552
  ql_dbg(1073741824U, vha, 124, "Reset register cleared by chip reset.\n");
#line 1556
  writew(4096, (void volatile   *)(& reg->hccr));
#line 1557
  writew(12288, (void volatile   *)(& reg->hccr));
#line 1560
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 1561
    data = qla2x00_debounce_register((uint16_t volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1562
    cnt = 6000000U;
#line 1562
    goto ldv_61053;
    ldv_61052: 
#line 1563
    __const_udelay(21475UL);
#line 1564
    data = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1565
    __asm__  volatile   ("": : : "memory");
#line 1562
    cnt = cnt - 1U;
    ldv_61053: ;
#line 1562
    if (cnt != 0U && (unsigned int )data == 4U) {
#line 1564
      goto ldv_61052;
    } else {

    }

  } else {
#line 1568
    __const_udelay(42950UL);
  }
#line 1570
  if (cnt == 0U) {
#line 1571
    goto chip_diag_failed;
  } else {

  }
#line 1574
  ql_dbg(1073741824U, vha, 125, "Checking product Id of chip.\n");
#line 1576
  mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 1577
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 1578
  mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 1579
  mb[4] = qla2x00_debounce_register((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (uint16_t volatile   *)(& reg->u.isp2100.mailbox0) + 4U : (uint16_t volatile   *)(& reg->u.isp2300.mailbox0) + 4U);
#line 1580
  if (((unsigned int )mb[1] != 18771U || ((unsigned int )mb[2] != 0U && (unsigned int )mb[2] != 20512U)) || (unsigned int )mb[3] != 8224U) {
#line 1582
    ql_log(1U, vha, 98, "Wrong product ID = 0x%x,0x%x,0x%x.\n", (int )mb[1], (int )mb[2],
           (int )mb[3]);
#line 1586
    goto chip_diag_failed;
  } else {

  }
#line 1588
  ha->product_id[0] = mb[1];
#line 1589
  ha->product_id[1] = mb[2];
#line 1590
  ha->product_id[2] = mb[3];
#line 1591
  ha->product_id[3] = mb[4];
#line 1594
  if ((unsigned int )req->length > 1024U) {
#line 1595
    ha->fw_transfer_size = 65536U;
  } else {
#line 1597
    ha->fw_transfer_size = (uint32_t )req->length * 64U;
  }
#line 1600
  if ((ha->device_type & 2U) != 0U) {
#line 1600
    tmp___0 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 1600
    if ((unsigned int )tmp___0 == 4U) {
#line 1603
      ql_dbg(1073741824U, vha, 126, "Found QLA2200A Chip.\n");
#line 1605
      ha->device_type = ha->device_type | 1073741824U;
#line 1606
      ha->fw_transfer_size = 128U;
    } else {

    }
  } else {

  }
#line 1610
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1612
  ql_dbg(1073741824U, vha, 127, "Checking mailboxes.\n");
#line 1613
  rval = qla2x00_mbx_reg_test(vha);
#line 1614
  if (rval != 0) {
#line 1615
    ql_log(1U, vha, 128, "Failed mailbox send register test.\n");
  } else {
#line 1619
    rval = 0;
  }
#line 1620
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 1620
  flags = _raw_spin_lock_irqsave(tmp___1);
  chip_diag_failed: ;
#line 1623
  if (rval != 0) {
#line 1624
    ql_log(2U, vha, 129, "Chip diagnostics **** FAILED ****.\n");
  } else {

  }
#line 1627
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1629
  return (rval);
}
}
#line 1639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_chip_diag(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;

  {
#line 1642
  ha = vha->hw;
#line 1643
  req = *(ha->req_q_map);
#line 1645
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1646
    return (0);
  } else {

  }
#line 1648
  ha->fw_transfer_size = (uint32_t )req->length * 64U;
#line 1650
  rval = qla2x00_mbx_reg_test(vha);
#line 1651
  if (rval != 0) {
#line 1652
    ql_log(1U, vha, 130, "Failed mailbox send register test.\n");
  } else {
#line 1656
    rval = 0;
  }
#line 1659
  return (rval);
}
}
#line 1663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_alloc_fw_dump(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t dump_size ;
  uint32_t fixed_size ;
  uint32_t mem_size ;
  uint32_t req_q_size ;
  uint32_t rsp_q_size ;
  uint32_t eft_size ;
  uint32_t fce_size ;
  uint32_t mq_size ;
  dma_addr_t tc_dma ;
  void *tc ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 1670
  ha = vha->hw;
#line 1671
  req = *(ha->req_q_map);
#line 1672
  rsp = *(ha->rsp_q_map);
#line 1674
  if ((unsigned long )ha->fw_dump != (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1675
    ql_dbg(1073741824U, vha, 189, "Firmware dump already allocated.\n");
#line 1677
    return;
  } else {

  }
#line 1680
  ha->fw_dumped = 0;
#line 1681
  mq_size = 0U;
#line 1681
  fce_size = mq_size;
#line 1681
  eft_size = fce_size;
#line 1681
  mem_size = eft_size;
#line 1681
  fixed_size = mem_size;
#line 1682
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 1683
    fixed_size = 123634U;
  } else
#line 1684
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 1685
    fixed_size = 136098U;
#line 1686
    mem_size = (ha->fw_memory_size + 2147414017U) * 2U;
  } else
#line 1688
  if ((ha->device_type & 134217728U) != 0U) {
#line 1689
    if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1690
      fixed_size = 51192U;
    } else
#line 1691
    if ((ha->device_type & 8192U) != 0U) {
#line 1692
      fixed_size = 39416U;
    } else
#line 1693
    if ((ha->device_type & 2048U) != 0U) {
#line 1694
      fixed_size = 39224U;
    } else {
#line 1696
      fixed_size = 37972U;
    }
#line 1697
    mem_size = (ha->fw_memory_size + 1072693249U) * 4U;
#line 1699
    if ((unsigned int )ha->mqenable != 0U) {
#line 1700
      if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1701
        mq_size = 524U;
      } else {

      }
#line 1706
      mq_size = ((uint32_t )ha->max_req_queues * (uint32_t )req->length) * 64U + mq_size;
#line 1708
      mq_size = ((uint32_t )ha->max_rsp_queues * (uint32_t )rsp->length) * 64U + mq_size;
    } else {

    }
#line 1711
    if ((unsigned long )ha->tgt.atio_ring != (unsigned long )((struct atio *)0)) {
#line 1712
      mq_size = (uint32_t )ha->tgt.atio_q_length * 64U + mq_size;
    } else {

    }
#line 1714
    if (((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 1715
      goto try_eft;
    } else {

    }
#line 1717
    tc = dma_alloc_attrs(& (ha->pdev)->dev, 65536UL, & tc_dma, 208U, (struct dma_attrs *)0);
#line 1719
    if ((unsigned long )tc == (unsigned long )((void *)0)) {
#line 1720
      ql_log(1U, vha, 190, "Unable to allocate (%d KB) for FCE.\n", 64);
#line 1723
      goto try_eft;
    } else {

    }
#line 1726
    memset(tc, 0, 65536UL);
#line 1727
    rval = qla2x00_enable_fce_trace(vha, tc_dma, 64, (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 1729
    if (rval != 0) {
#line 1730
      ql_log(1U, vha, 191, "Unable to initialize FCE (%d).\n", rval);
#line 1732
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, tc, tc_dma, (struct dma_attrs *)0);
#line 1734
      ha->flags.fce_enabled = 0U;
#line 1735
      goto try_eft;
    } else {

    }
#line 1737
    ql_dbg(1073741824U, vha, 192, "Allocate (%d KB) for FCE...\n", 64);
#line 1740
    fce_size = 65588U;
#line 1741
    ha->flags.fce_enabled = 1U;
#line 1742
    ha->fce_dma = tc_dma;
#line 1743
    ha->fce = tc;
    try_eft: 
#line 1746
    tc = dma_alloc_attrs(& (ha->pdev)->dev, 65536UL, & tc_dma, 208U, (struct dma_attrs *)0);
#line 1748
    if ((unsigned long )tc == (unsigned long )((void *)0)) {
#line 1749
      ql_log(1U, vha, 193, "Unable to allocate (%d KB) for EFT.\n", 64);
#line 1752
      goto cont_alloc;
    } else {

    }
#line 1755
    memset(tc, 0, 65536UL);
#line 1756
    rval = qla2x00_enable_eft_trace(vha, tc_dma, 4);
#line 1757
    if (rval != 0) {
#line 1758
      ql_log(1U, vha, 194, "Unable to initialize EFT (%d).\n", rval);
#line 1760
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, tc, tc_dma, (struct dma_attrs *)0);
#line 1762
      goto cont_alloc;
    } else {

    }
#line 1764
    ql_dbg(1073741824U, vha, 195, "Allocated (%d KB) EFT ...\n", 64);
#line 1767
    eft_size = 65536U;
#line 1768
    ha->eft_dma = tc_dma;
#line 1769
    ha->eft = tc;
  } else {

  }
  cont_alloc: 
#line 1772
  req_q_size = (uint32_t )req->length * 64U;
#line 1773
  rsp_q_size = (uint32_t )rsp->length * 64U;
#line 1775
  dump_size = 72U;
#line 1776
  dump_size = ((((fixed_size + mem_size) + req_q_size) + rsp_q_size) + eft_size) + dump_size;
#line 1777
  ha->chain_offset = dump_size;
#line 1778
  dump_size = (mq_size + fce_size) + dump_size;
#line 1780
  tmp = vmalloc((unsigned long )dump_size);
#line 1780
  ha->fw_dump = (struct qla2xxx_fw_dump *)tmp;
#line 1781
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1782
    ql_log(1U, vha, 196, "Unable to allocate (%d KB) for firmware dump.\n", dump_size / 1024U);
#line 1786
    if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 1787
      dma_free_attrs(& (ha->pdev)->dev, 65536UL, ha->fce, ha->fce_dma, (struct dma_attrs *)0);
#line 1789
      ha->fce = (void *)0;
#line 1790
      ha->fce_dma = 0ULL;
    } else {

    }
#line 1793
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 1794
      dma_free_attrs(& (ha->pdev)->dev, (size_t )eft_size, ha->eft, ha->eft_dma, (struct dma_attrs *)0);
#line 1796
      ha->eft = (void *)0;
#line 1797
      ha->eft_dma = 0ULL;
    } else {

    }
#line 1799
    return;
  } else {

  }
#line 1801
  ql_dbg(1073741824U, vha, 197, "Allocated (%d KB) for firmware dump.\n", dump_size / 1024U);
#line 1804
  ha->fw_dump_len = dump_size;
#line 1805
  (ha->fw_dump)->signature[0] = 81U;
#line 1806
  (ha->fw_dump)->signature[1] = 76U;
#line 1807
  (ha->fw_dump)->signature[2] = 71U;
#line 1808
  (ha->fw_dump)->signature[3] = 67U;
#line 1809
  (ha->fw_dump)->version = 16777216U;
#line 1811
  tmp___0 = __fswab32(fixed_size);
#line 1811
  (ha->fw_dump)->fixed_size = tmp___0;
#line 1812
  tmp___1 = __fswab32(mem_size);
#line 1812
  (ha->fw_dump)->mem_size = tmp___1;
#line 1813
  tmp___2 = __fswab32(req_q_size);
#line 1813
  (ha->fw_dump)->req_q_size = tmp___2;
#line 1814
  tmp___3 = __fswab32(rsp_q_size);
#line 1814
  (ha->fw_dump)->rsp_q_size = tmp___3;
#line 1816
  tmp___4 = __fswab32(eft_size);
#line 1816
  (ha->fw_dump)->eft_size = tmp___4;
#line 1817
  tmp___5 = __fswab32((unsigned int )ha->eft_dma);
#line 1817
  (ha->fw_dump)->eft_addr_l = tmp___5;
#line 1818
  tmp___6 = __fswab32((unsigned int )(ha->eft_dma >> 32ULL));
#line 1818
  (ha->fw_dump)->eft_addr_h = tmp___6;
#line 1820
  (ha->fw_dump)->header_size = 1207959552U;
#line 1821
  return;
}
}
#line 1825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla81xx_mpi_sync(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t dc ;
  uint32_t dw ;

  {
#line 1832
  if (((vha->hw)->device_type & 8192U) == 0U) {
#line 1833
    return (0);
  } else {

  }
#line 1835
  rval = qla2x00_write_ram_word(vha, 31744U, 1U);
#line 1836
  if (rval != 0) {
#line 1837
    ql_log(1U, vha, 261, "Unable to acquire semaphore.\n");
#line 1839
    goto done;
  } else {

  }
#line 1842
  pci_read_config_word((struct pci_dev  const  *)(vha->hw)->pdev, 84, & dc);
#line 1843
  rval = qla2x00_read_ram_word(vha, 31253U, & dw);
#line 1844
  if (rval != 0) {
#line 1845
    ql_log(1U, vha, 103, "Unable to read sync.\n");
#line 1846
    goto done_release;
  } else {

  }
#line 1849
  dc = (unsigned int )dc & 224U;
#line 1850
  if ((uint32_t )dc == (dw & 224U)) {
#line 1851
    goto done_release;
  } else {

  }
#line 1853
  dw = dw & 4294967071U;
#line 1854
  dw = (uint32_t )dc | dw;
#line 1855
  rval = qla2x00_write_ram_word(vha, 31253U, dw);
#line 1856
  if (rval != 0) {
#line 1857
    ql_log(1U, vha, 276, "Unable to gain sync.\n");
  } else {

  }
  done_release: 
#line 1861
  rval = qla2x00_write_ram_word(vha, 31744U, 0U);
#line 1862
  if (rval != 0) {
#line 1863
    ql_log(1U, vha, 109, "Unable to release semaphore.\n");
  } else {

  }
  done: ;
#line 1868
  return (rval);
}
}
#line 1872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha , struct req_que *req ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1875
  if ((unsigned long )req->outstanding_cmds != (unsigned long )((srb_t **)0)) {
#line 1876
    return (0);
  } else {

  }
#line 1878
  if ((ha->device_type & 134217728U) == 0U || ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0) && (ql2xmultique_tag != 0 || ql2xmaxqueues > 1))) {
#line 1880
    req->num_outstanding_cmds = 1024U;
  } else
#line 1882
  if ((int )ha->fw_xcb_count <= (int )ha->fw_iocb_count) {
#line 1883
    req->num_outstanding_cmds = ha->fw_xcb_count;
  } else {
#line 1885
    req->num_outstanding_cmds = ha->fw_iocb_count;
  }
#line 1888
  tmp = kzalloc((unsigned long )req->num_outstanding_cmds * 8UL, 208U);
#line 1888
  req->outstanding_cmds = (srb_t **)tmp;
#line 1891
  if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1896
    req->num_outstanding_cmds = 128U;
#line 1897
    tmp___0 = kzalloc((unsigned long )req->num_outstanding_cmds * 8UL, 208U);
#line 1897
    req->outstanding_cmds = (srb_t **)tmp___0;
#line 1900
    if ((unsigned long )req->outstanding_cmds == (unsigned long )((srb_t **)0)) {
#line 1901
      ql_log(0U, (scsi_qla_host_t *)0, 294, "Failed to allocate memory for outstanding_cmds for req_que %p.\n",
             req);
#line 1904
      req->num_outstanding_cmds = 0U;
#line 1905
      return (258);
    } else {

    }
  } else {

  }
#line 1909
  return (0);
}
}
#line 1919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_setup_chip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t srisc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  unsigned long flags ;
  uint16_t fw_major_version ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  uint32_t size ;

  {
#line 1922
  srisc_address = 0U;
#line 1923
  ha = vha->hw;
#line 1924
  reg = & (ha->iobase)->isp;
#line 1928
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1929
    rval = (*((ha->isp_ops)->load_risc))(vha, & srisc_address);
#line 1930
    if (rval == 0) {
#line 1931
      qla2x00_stop_firmware(vha);
#line 1932
      goto enable_82xx_npiv;
    } else {
#line 1934
      goto failed;
    }
  } else {

  }
#line 1937
  if (((ha->device_type & 134217728U) == 0U && (ha->device_type & 1U) == 0U) && (ha->device_type & 2U) == 0U) {
#line 1939
    tmp = spinlock_check(& ha->hardware_lock);
#line 1939
    flags = _raw_spin_lock_irqsave(tmp);
#line 1940
    writew(40960, (void volatile   *)(& reg->hccr));
#line 1941
    readw((void const volatile   *)(& reg->hccr));
#line 1942
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1945
  qla81xx_mpi_sync(vha);
#line 1948
  rval = (*((ha->isp_ops)->load_risc))(vha, & srisc_address);
#line 1949
  if (rval == 0) {
#line 1950
    ql_dbg(1073741824U, vha, 201, "Verifying Checksum of loaded RISC code.\n");
#line 1953
    rval = qla2x00_verify_checksum(vha, srisc_address);
#line 1954
    if (rval == 0) {
#line 1956
      ql_dbg(1073741824U, vha, 202, "Starting firmware.\n");
#line 1959
      rval = qla2x00_execute_fw(vha, srisc_address);
#line 1961
      if (rval == 0) {
        enable_82xx_npiv: 
#line 1963
        fw_major_version = ha->fw_major_version;
#line 1964
        if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1965
          qla82xx_check_md_needed(vha);
        } else {
#line 1967
          rval = qla2x00_get_fw_version(vha);
        }
#line 1968
        if (rval != 0) {
#line 1969
          goto failed;
        } else {

        }
#line 1970
        ha->flags.npiv_supported = 0U;
#line 1971
        if (((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) && ((int )ha->fw_attributes & 4) != 0) {
#line 1973
          ha->flags.npiv_supported = 1U;
#line 1974
          if ((unsigned int )ha->max_npiv_vports == 0U || ((unsigned int )((int )ha->max_npiv_vports + 1) & 63U) != 0U) {
#line 1977
            ha->max_npiv_vports = 63U;
          } else {

          }
        } else {

        }
#line 1980
        qla2x00_get_resource_cnts(vha, (uint16_t *)0U, & ha->fw_xcb_count, (uint16_t *)0U,
                                  & ha->fw_iocb_count, & ha->max_npiv_vports, (uint16_t *)0U);
#line 1988
        rval = qla2x00_alloc_outstanding_cmds(ha, vha->req);
#line 1990
        if (rval != 0) {
#line 1991
          goto failed;
        } else {

        }
#line 1993
        if (((unsigned int )fw_major_version == 0U && ql2xallocfwdump != 0) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 1995
          qla2x00_alloc_fw_dump(vha);
        } else {

        }
      } else {

      }
    } else {
#line 1998
      ql_log(0U, vha, 205, "ISP Firmware failed checksum.\n");
#line 2000
      goto failed;
    }
  } else {
#line 2003
    goto failed;
  }
#line 2005
  if (((ha->device_type & 134217728U) == 0U && (ha->device_type & 1U) == 0U) && (ha->device_type & 2U) == 0U) {
#line 2007
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2007
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 2008
    if ((ha->device_type & 4U) != 0U) {
#line 2010
      writew(40961, (void volatile   *)(& reg->hccr));
    } else {
#line 2013
      writew(40967, (void volatile   *)(& reg->hccr));
    }
#line 2014
    readw((void const volatile   *)(& reg->hccr));
#line 2015
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2018
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 2019
    goto skip_fac_check;
  } else {

  }
#line 2021
  if (rval == 0 && ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U))) {
#line 2024
    rval = qla81xx_fac_get_sector_size(vha, & size);
#line 2025
    if (rval == 0) {
#line 2026
      ha->flags.fac_supported = 1U;
#line 2027
      ha->fdt_block_size = size << 2;
    } else {
#line 2029
      ql_log(1U, vha, 206, "Unsupported FAC firmware (%d.%02d.%02d).\n", (int )ha->fw_major_version,
             (int )ha->fw_minor_version, (int )ha->fw_subminor_version);
      skip_fac_check: ;
#line 2034
      if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 2035
        ha->flags.fac_supported = 0U;
#line 2036
        rval = 0;
      } else {

      }
    }
  } else {

  }
  failed: ;
#line 2041
  if (rval != 0) {
#line 2042
    ql_log(0U, vha, 207, "Setup chip ****FAILED****.\n");
  } else {

  }
#line 2046
  return (rval);
}
}
#line 2059 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_init_response_q_entries(struct rsp_que *rsp ) 
{ 
  uint16_t cnt ;
  response_t *pkt ;

  {
#line 2064
  rsp->ring_ptr = rsp->ring;
#line 2065
  rsp->ring_index = 0U;
#line 2066
  rsp->status_srb = (srb_t *)0;
#line 2067
  pkt = rsp->ring_ptr;
#line 2068
  cnt = 0U;
#line 2068
  goto ldv_61120;
  ldv_61119: 
#line 2069
  pkt->signature = 3735936685U;
#line 2070
  pkt = pkt + 1;
#line 2068
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61120: ;
#line 2068
  if ((int )rsp->length > (int )cnt) {
#line 2070
    goto ldv_61119;
  } else {

  }

#line 2075
  return;
}
}
#line 2081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_update_fw_options(struct scsi_qla_host *vha ) 
{ 
  uint16_t swing ;
  uint16_t emphasis ;
  uint16_t tx_sens ;
  uint16_t rx_sens ;
  struct qla_hw_data *ha ;

  {
#line 2084
  ha = vha->hw;
#line 2086
  memset((void *)(& ha->fw_options), 0, 32UL);
#line 2087
  qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2089
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 2090
    return;
  } else {

  }
#line 2093
  ql_dbg(1073872896U, vha, 277, "Serial link options.\n");
#line 2095
  ql_dump_buffer(1073872896U, vha, 265, (uint8_t *)(& ha->fw_seriallink_options),
                 4U);
#line 2099
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 2100
  if (((int )ha->fw_seriallink_options[3] & 4) != 0) {
#line 2101
    ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 256U);
#line 2104
    swing = (unsigned int )((uint16_t )ha->fw_seriallink_options[2]) & 7U;
#line 2105
    emphasis = (uint16_t )(((int )ha->fw_seriallink_options[2] & 24) >> 3);
#line 2107
    tx_sens = (unsigned int )((uint16_t )ha->fw_seriallink_options[0]) & 15U;
#line 2109
    rx_sens = (uint16_t )((int )ha->fw_seriallink_options[0] >> 4);
#line 2111
    ha->fw_options[10] = (uint16_t )((int )((short )((int )emphasis << 14)) | (int )((short )((int )swing << 8)));
#line 2112
    if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 2113
      if ((unsigned int )rx_sens == 0U) {
#line 2114
        rx_sens = 3U;
      } else {

      }
#line 2115
      ha->fw_options[10] = (uint16_t )((int )((short )ha->fw_options[10]) | ((int )((short )((int )tx_sens << 4)) | (int )((short )rx_sens)));
    } else
#line 2116
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2117
      ha->fw_options[10] = (uint16_t )((int )((short )ha->fw_options[10]) | (((int )((short )(((int )rx_sens & 3) << 2)) | 32) | ((int )((short )tx_sens) & 3)));
    } else {

    }
#line 2122
    swing = (uint16_t )((int )ha->fw_seriallink_options[2] >> 5);
#line 2124
    emphasis = (unsigned int )((uint16_t )ha->fw_seriallink_options[3]) & 3U;
#line 2125
    tx_sens = (unsigned int )((uint16_t )ha->fw_seriallink_options[1]) & 15U;
#line 2127
    rx_sens = (uint16_t )((int )ha->fw_seriallink_options[1] >> 4);
#line 2129
    ha->fw_options[11] = (uint16_t )((int )((short )((int )emphasis << 14)) | (int )((short )((int )swing << 8)));
#line 2130
    if (((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 32U) != 0U) {
#line 2131
      if ((unsigned int )rx_sens == 0U) {
#line 2132
        rx_sens = 3U;
      } else {

      }
#line 2133
      ha->fw_options[11] = (uint16_t )((int )((short )ha->fw_options[11]) | ((int )((short )((int )tx_sens << 4)) | (int )((short )rx_sens)));
    } else
#line 2134
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2135
      ha->fw_options[11] = (uint16_t )((int )((short )ha->fw_options[11]) | (((int )((short )(((int )rx_sens & 3) << 2)) | 32) | ((int )((short )tx_sens) & 3)));
    } else {

    }
  } else {

  }
#line 2142
  ha->fw_options[3] = (uint16_t )((unsigned int )ha->fw_options[3] | 8192U);
#line 2145
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2146
    ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 4096U);
  } else {

  }
#line 2149
  if ((ha->device_type & 32U) != 0U) {
#line 2150
    ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 8192U);
  } else {

  }
#line 2153
  qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2154
  return;
}
}
#line 2157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla24xx_update_fw_options(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 2160
  ha = vha->hw;
#line 2162
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2163
    return;
  } else {

  }
#line 2166
  if (((int )ha->fw_seriallink_options24[0] & 1) == 0) {
#line 2167
    return;
  } else {

  }
#line 2169
  rval = qla2x00_set_serdes_params(vha, (int )ha->fw_seriallink_options24[1], (int )ha->fw_seriallink_options24[2],
                                   (int )ha->fw_seriallink_options24[3]);
#line 2173
  if (rval != 0) {
#line 2174
    ql_log(1U, vha, 260, "Unable to update Serial Link options (%x).\n", rval);
  } else {

  }
#line 2176
  return;
}
}
#line 2180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 2182
  ha = vha->hw;
#line 2183
  reg = & (ha->iobase)->isp;
#line 2184
  req = *(ha->req_q_map);
#line 2185
  rsp = *(ha->rsp_q_map);
#line 2188
  (ha->init_cb)->request_q_outpointer = 0U;
#line 2189
  (ha->init_cb)->response_q_inpointer = 0U;
#line 2190
  (ha->init_cb)->request_q_length = req->length;
#line 2191
  (ha->init_cb)->response_q_length = rsp->length;
#line 2192
  (ha->init_cb)->request_q_address[0] = (unsigned int )req->dma;
#line 2193
  (ha->init_cb)->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 2194
  (ha->init_cb)->response_q_address[0] = (unsigned int )rsp->dma;
#line 2195
  (ha->init_cb)->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 2197
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 2198
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_out));
#line 2199
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_in));
#line 2200
  writew(0, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 2201
  readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 2202
  return;
}
}
#line 2205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla24xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  device_reg_t *reg ;
  struct device_reg_2xxx *ioreg ;
  struct qla_msix_entry *msix ;
  struct init_cb_24xx *icb ;
  uint16_t rid ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 2207
  ha = vha->hw;
#line 2208
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase : ha->iobase;
#line 2209
  ioreg = & (ha->iobase)->isp;
#line 2212
  rid = 0U;
#line 2213
  req = *(ha->req_q_map);
#line 2214
  rsp = *(ha->rsp_q_map);
#line 2217
  icb = (struct init_cb_24xx *)ha->init_cb;
#line 2218
  icb->request_q_outpointer = 0U;
#line 2219
  icb->response_q_inpointer = 0U;
#line 2220
  icb->request_q_length = req->length;
#line 2221
  icb->response_q_length = rsp->length;
#line 2222
  icb->request_q_address[0] = (unsigned int )req->dma;
#line 2223
  icb->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 2224
  icb->response_q_address[0] = (unsigned int )rsp->dma;
#line 2225
  icb->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 2228
  icb->atio_q_inpointer = 0U;
#line 2229
  icb->atio_q_length = ha->tgt.atio_q_length;
#line 2230
  icb->atio_q_address[0] = (unsigned int )ha->tgt.atio_dma;
#line 2231
  icb->atio_q_address[1] = (unsigned int )(ha->tgt.atio_dma >> 32ULL);
#line 2233
  if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 2234
    icb->qos = 5U;
#line 2235
    icb->rid = rid;
#line 2236
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2237
      msix = ha->msix_entries + 1UL;
#line 2238
      ql_dbg(1073741824U, vha, 253, "Registering vector 0x%x for base que.\n", (int )msix->entry);
#line 2241
      icb->msix = msix->entry;
    } else {

    }
#line 2244
    if ((unsigned int )((unsigned char )((int )rid >> 8)) != 0U) {
#line 2245
      icb->firmware_options_2 = icb->firmware_options_2 | 524288U;
    } else {

    }
#line 2248
    if ((unsigned int )((unsigned char )rid) != 0U) {
#line 2249
      icb->firmware_options_2 = icb->firmware_options_2 | 262144U;
    } else {

    }
#line 2253
    if ((((int )ha->fw_attributes & 64) != 0 && ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U))) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 2255
      icb->firmware_options_2 = icb->firmware_options_2 & 4290772991U;
#line 2257
      ha->flags.disable_msix_handshake = 1U;
#line 2258
      ql_dbg(1073741824U, vha, 254, "MSIX Handshake Disable Mode turned on.\n");
    } else {
#line 2261
      icb->firmware_options_2 = icb->firmware_options_2 | 4194304U;
    }
#line 2264
    icb->firmware_options_2 = icb->firmware_options_2 | 8388608U;
#line 2266
    writel(0U, (void volatile   *)(& reg->isp25mq.req_q_in));
#line 2267
    writel(0U, (void volatile   *)(& reg->isp25mq.req_q_out));
#line 2268
    writel(0U, (void volatile   *)(& reg->isp25mq.rsp_q_in));
#line 2269
    writel(0U, (void volatile   *)(& reg->isp25mq.rsp_q_out));
  } else {
#line 2271
    writel(0U, (void volatile   *)(& reg->isp24.req_q_in));
#line 2272
    writel(0U, (void volatile   *)(& reg->isp24.req_q_out));
#line 2273
    writel(0U, (void volatile   *)(& reg->isp24.rsp_q_in));
#line 2274
    writel(0U, (void volatile   *)(& reg->isp24.rsp_q_out));
  }
#line 2276
  qlt_24xx_config_rings(vha);
#line 2279
  readl((void const volatile   *)(& ioreg->hccr));
#line 2280
  return;
}
}
#line 2292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_init_rings(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  int cnt ;
  int que ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct mid_init_cb_24xx *mid_init_cb ;
  raw_spinlock_t *tmp ;

  {
#line 2295
  flags = 0UL;
#line 2297
  ha = vha->hw;
#line 2300
  mid_init_cb = (struct mid_init_cb_24xx *)ha->init_cb;
#line 2303
  tmp = spinlock_check(& ha->hardware_lock);
#line 2303
  flags = _raw_spin_lock_irqsave(tmp);
#line 2306
  que = 0;
#line 2306
  goto ldv_61172;
  ldv_61171: 
#line 2307
  req = *(ha->req_q_map + (unsigned long )que);
#line 2308
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 2309
    goto ldv_61167;
  } else {

  }
#line 2310
  cnt = 1;
#line 2310
  goto ldv_61169;
  ldv_61168: 
#line 2311
  *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 2310
  cnt = cnt + 1;
  ldv_61169: ;
#line 2310
  if ((int )req->num_outstanding_cmds > cnt) {
#line 2312
    goto ldv_61168;
  } else {

  }
#line 2313
  req->current_outstanding_cmd = 1U;
#line 2316
  req->ring_ptr = req->ring;
#line 2317
  req->ring_index = 0U;
#line 2318
  req->cnt = req->length;
  ldv_61167: 
#line 2306
  que = que + 1;
  ldv_61172: ;
#line 2306
  if ((int )ha->max_req_queues > que) {
#line 2308
    goto ldv_61171;
  } else {

  }
#line 2321
  que = 0;
#line 2321
  goto ldv_61176;
  ldv_61175: 
#line 2322
  rsp = *(ha->rsp_q_map + (unsigned long )que);
#line 2323
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2324
    goto ldv_61174;
  } else {

  }
#line 2326
  if ((ha->device_type & 131072U) != 0U) {
#line 2327
    qlafx00_init_response_q_entries(rsp);
  } else {
#line 2329
    qla2x00_init_response_q_entries(rsp);
  }
  ldv_61174: 
#line 2321
  que = que + 1;
  ldv_61176: ;
#line 2321
  if ((int )ha->max_rsp_queues > que) {
#line 2323
    goto ldv_61175;
  } else {

  }
#line 2332
  ha->tgt.atio_ring_ptr = ha->tgt.atio_ring;
#line 2333
  ha->tgt.atio_ring_index = 0U;
#line 2335
  qlt_init_atio_q_entries(vha);
#line 2337
  (*((ha->isp_ops)->config_rings))(vha);
#line 2339
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2341
  ql_dbg(1073741824U, vha, 209, "Issue init firmware.\n");
#line 2343
  if ((ha->device_type & 131072U) != 0U) {
#line 2344
    rval = qlafx00_init_firmware(vha, (int )((uint16_t )ha->init_cb_size));
#line 2345
    goto next_check;
  } else {

  }
#line 2349
  (*((ha->isp_ops)->update_fw_options))(vha);
#line 2351
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2352
    if ((unsigned int )ha->operating_mode == 0U && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) {
#line 2353
      ha->max_npiv_vports = 63U;
    } else {

    }
#line 2354
    mid_init_cb->count = ha->max_npiv_vports;
  } else {

  }
#line 2357
  if ((ha->device_type & 134217728U) != 0U) {
#line 2358
    mid_init_cb->options = 2U;
#line 2359
    mid_init_cb->init_cb.execution_throttle = ha->fw_xcb_count;
  } else {

  }
#line 2363
  rval = qla2x00_init_firmware(vha, (int )((uint16_t )ha->init_cb_size));
  next_check: ;
#line 2365
  if (rval != 0) {
#line 2366
    ql_log(0U, vha, 210, "Init Firmware **** FAILED ****.\n");
  } else {
#line 2369
    ql_dbg(1073741824U, vha, 211, "Init Firmware -- success.\n");
  }
#line 2373
  return (rval);
}
}
#line 2383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  unsigned long mtime ;
  unsigned long cs84xx_time ;
  uint16_t min_wait ;
  uint16_t wait_time ;
  uint16_t state[5U] ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2390
  ha = vha->hw;
#line 2392
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 2393
    tmp = qlafx00_fw_ready(vha);
#line 2393
    return (tmp);
  } else {

  }
#line 2395
  rval = 0;
#line 2398
  min_wait = 20U;
#line 2404
  wait_time = (unsigned int )((int )((uint16_t )ha->retry_count) * (int )((uint16_t )ha->login_timeout)) + 5U;
#line 2404
  if ((int )wait_time < (int )min_wait) {
#line 2405
    wait_time = min_wait;
  } else {

  }
#line 2409
  mtime = (unsigned long )((int )min_wait * 250) + (unsigned long )jiffies;
#line 2412
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 2415
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2416
    ql_log(2U, vha, 32798, "Waiting for LIP to complete.\n");
  } else {

  }
  ldv_61209: 
#line 2420
  memset((void *)(& state), -1, 10UL);
#line 2421
  rval = qla2x00_get_firmware_state(vha, (uint16_t *)(& state));
#line 2422
  if (rval == 0) {
#line 2423
    if ((unsigned int )state[0] <= 3U) {
#line 2424
      vha->device_flags = vha->device_flags & 4294967293U;
    } else {

    }
#line 2426
    if ((ha->device_type & 4096U) != 0U && (unsigned int )state[0] != 3U) {
#line 2427
      ql_dbg(4194304U, vha, 32799, "fw_state=%x 84xx=%x.\n", (int )state[0], (int )state[2]);
#line 2430
      if (((int )state[2] & 8) != 0 && ((int )state[2] & 16) != 0) {
#line 2432
        ql_dbg(4194304U, vha, 32808, "Sending verify iocb.\n");
#line 2435
        cs84xx_time = jiffies;
#line 2436
        rval = qla84xx_init_chip(vha);
#line 2437
        if (rval != 0) {
#line 2438
          ql_log(1U, vha, 32775, "Init chip failed.\n");
#line 2441
          goto ldv_61190;
        } else {

        }
#line 2445
        cs84xx_time = (unsigned long )jiffies - cs84xx_time;
#line 2446
        wtime = wtime + cs84xx_time;
#line 2447
        mtime = mtime + cs84xx_time;
#line 2448
        ql_dbg(4194304U, vha, 32776, "Increasing wait time by %ld. New time %ld.\n",
               cs84xx_time, wtime);
      } else {

      }
    } else
#line 2453
    if ((unsigned int )state[0] == 3U) {
#line 2454
      ql_dbg(4194304U, vha, 32823, "F/W Ready - OK.\n");
#line 2457
      qla2x00_get_retry_cnt(vha, & ha->retry_count, & ha->login_timeout, & ha->r_a_tov);
#line 2460
      rval = 0;
#line 2461
      goto ldv_61190;
    } else {

    }
#line 2464
    rval = 258;
#line 2466
    tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 2466
    if (tmp___0 != 0 && (unsigned int )state[0] != 3U) {
#line 2471
      if ((long )((unsigned long )jiffies - mtime) >= 0L) {
#line 2472
        ql_log(2U, vha, 32824, "Cable is unplugged...\n");
#line 2475
        vha->device_flags = vha->device_flags | 2U;
#line 2476
        goto ldv_61190;
      } else {

      }
    } else {

    }
  } else
#line 2481
  if ((long )((unsigned long )jiffies - mtime) >= 0L || *((unsigned long *)ha + 2UL) != 0UL) {
#line 2483
    goto ldv_61190;
  } else {

  }
#line 2486
  if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 2487
    goto ldv_61190;
  } else {

  }
#line 2490
  msleep(500U);
#line 2491
  goto ldv_61209;
  ldv_61190: 
#line 2493
  ql_dbg(4194304U, vha, 32826, "fw_state=%x (%x, %x, %x, %x) curr time=%lx.\n", (int )state[0],
         (int )state[1], (int )state[2], (int )state[3], (int )state[4], jiffies);
#line 2497
  if (rval != 0 && (vha->device_flags & 2U) == 0U) {
#line 2498
    ql_log(1U, vha, 32827, "Firmware ready **** FAILED ****.\n");
  } else {

  }
#line 2502
  return (rval);
}
}
#line 2519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_configure_hba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t loop_id ;
  uint16_t topo ;
  uint16_t sw_cap ;
  uint8_t al_pa ;
  uint8_t area ;
  uint8_t domain ;
  char connect_type[22U] ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;

  {
#line 2529
  ha = vha->hw;
#line 2531
  tmp = pci_get_drvdata(ha->pdev);
#line 2531
  base_vha = (scsi_qla_host_t *)tmp;
#line 2534
  rval = qla2x00_get_adapter_id(vha, & loop_id, & al_pa, & area, & domain, & topo,
                                & sw_cap);
#line 2536
  if (rval != 0) {
#line 2537
    tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2537
    if (tmp___1 != 0) {
#line 2540
      ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
    } else {
#line 2537
      tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2537
      if (tmp___2 != 0) {
#line 2540
        ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
      } else {
#line 2537
        tmp___3 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 2537
        if (tmp___3 == 2) {
#line 2540
          ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
        } else {
#line 2537
          tmp___4 = atomic_read((atomic_t const   *)(& ha->loop_down_timer));
#line 2537
          if (tmp___4 != 0) {
#line 2540
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else
#line 2537
          if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 2540
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else
#line 2537
          if (rval == 5 && (unsigned int )loop_id == 7U) {
#line 2540
            ql_dbg(268435456U, vha, 8200, "Loop is in a transition state.\n");
          } else {
#line 2543
            ql_log(1U, vha, 8201, "Unable to get host loop ID.\n");
#line 2545
            if (((ha->device_type & 134217728U) != 0U && (unsigned long )vha == (unsigned long )base_vha) && (rval == 5 && (unsigned int )loop_id == 27U)) {
#line 2547
              ql_log(1U, vha, 4433, "Doing link init.\n");
#line 2549
              tmp___0 = qla24xx_link_initialize(vha);
#line 2549
              if (tmp___0 == 0) {
#line 2550
                return (rval);
              } else {

              }
            } else {

            }
#line 2552
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
          }
        }
      }
    }
#line 2554
    return (rval);
  } else {

  }
#line 2557
  if ((unsigned int )topo == 4U) {
#line 2558
    ql_log(2U, vha, 8202, "Cannot get topology - retrying.\n");
#line 2560
    return (258);
  } else {

  }
#line 2563
  vha->loop_id = loop_id;
#line 2566
  ha->min_external_loopid = 129U;
#line 2567
  ha->operating_mode = 0U;
#line 2568
  ha->switch_cap = 0U;
#line 2570
  switch ((int )topo) {
  case 0: 
#line 2572
  ql_dbg(268435456U, vha, 8203, "HBA in NL topology.\n");
#line 2573
  ha->current_topology = 1U;
#line 2574
  strcpy((char *)(& connect_type), "(Loop)");
#line 2575
  goto ldv_61225;
  case 1: 
#line 2578
  ql_dbg(268435456U, vha, 8204, "HBA in FL topology.\n");
#line 2579
  ha->switch_cap = sw_cap;
#line 2580
  ha->current_topology = 4U;
#line 2581
  strcpy((char *)(& connect_type), "(FL_Port)");
#line 2582
  goto ldv_61225;
  case 2: 
#line 2585
  ql_dbg(268435456U, vha, 8205, "HBA in N P2P topology.\n");
#line 2586
  ha->operating_mode = 1U;
#line 2587
  ha->current_topology = 2U;
#line 2588
  strcpy((char *)(& connect_type), "(N_Port-to-N_Port)");
#line 2589
  goto ldv_61225;
  case 3: 
#line 2592
  ql_dbg(268435456U, vha, 8206, "HBA in F P2P topology.\n");
#line 2593
  ha->switch_cap = sw_cap;
#line 2594
  ha->operating_mode = 1U;
#line 2595
  ha->current_topology = 8U;
#line 2596
  strcpy((char *)(& connect_type), "(F_Port)");
#line 2597
  goto ldv_61225;
  default: 
#line 2600
  ql_dbg(268435456U, vha, 8207, "HBA in unknown topology %x, using NL.\n", (int )topo);
#line 2602
  ha->current_topology = 1U;
#line 2603
  strcpy((char *)(& connect_type), "(Loop)");
#line 2604
  goto ldv_61225;
  }
  ldv_61225: 
#line 2609
  vha->d_id.b.domain = domain;
#line 2610
  vha->d_id.b.area = area;
#line 2611
  vha->d_id.b.al_pa = al_pa;
#line 2613
  tmp___5 = spinlock_check(& ha->vport_slock);
#line 2613
  flags = _raw_spin_lock_irqsave(tmp___5);
#line 2614
  qlt_update_vp_map(vha, 2);
#line 2615
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 2617
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2618
    ql_log(2U, vha, 8208, "Topology - %s, Host Loop address 0x%x.\n", (char *)(& connect_type),
           (int )vha->loop_id);
  } else {

  }
#line 2622
  return (rval);
}
}
#line 2626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
__inline void qla2x00_set_model_info(scsi_qla_host_t *vha , uint8_t *model , size_t len ,
                                     char *def ) 
{ 
  char *st ;
  char *en ;
  uint16_t index ;
  struct qla_hw_data *ha ;
  int use_tbl ;
  char *tmp ;
  int tmp___0 ;

  {
#line 2631
  ha = vha->hw;
#line 2632
  use_tbl = ((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U;
#line 2635
  tmp___0 = memcmp((void const   *)model, (void const   *)"", len);
#line 2635
  if (tmp___0 != 0) {
#line 2636
    strncpy((char *)(& ha->model_number), (char const   *)model, len);
#line 2637
    en = (char *)(& ha->model_number);
#line 2637
    st = en;
#line 2638
    en = en + (len + 0xffffffffffffffffUL);
#line 2639
    goto ldv_61246;
    ldv_61245: ;
#line 2640
    if ((int )((signed char )*en) != 32 && (int )((signed char )*en) != 0) {
#line 2641
      goto ldv_61244;
    } else {

    }
#line 2642
    tmp = en;
#line 2642
    en = en - 1;
#line 2642
    *tmp = 0;
    ldv_61246: ;
#line 2639
    if ((unsigned long )en > (unsigned long )st) {
#line 2641
      goto ldv_61245;
    } else {

    }
    ldv_61244: 
#line 2645
    index = (unsigned int )(ha->pdev)->subsystem_device & 255U;
#line 2646
    if ((use_tbl != 0 && (unsigned int )(ha->pdev)->subsystem_vendor == 4215U) && (unsigned int )index <= 91U) {
#line 2649
      strncpy((char *)(& ha->model_desc), (char const   *)qla2x00_model_name[(int )index * 2 + 1],
              79UL);
    } else {

    }
  } else {
#line 2653
    index = (unsigned int )(ha->pdev)->subsystem_device & 255U;
#line 2654
    if ((use_tbl != 0 && (unsigned int )(ha->pdev)->subsystem_vendor == 4215U) && (unsigned int )index <= 91U) {
#line 2657
      strcpy((char *)(& ha->model_number), (char const   *)qla2x00_model_name[(int )index * 2]);
#line 2659
      strncpy((char *)(& ha->model_desc), (char const   *)qla2x00_model_name[(int )index * 2 + 1],
              79UL);
    } else {
#line 2663
      strcpy((char *)(& ha->model_number), (char const   *)def);
    }
  }
#line 2666
  if ((ha->device_type & 134217728U) != 0U) {
#line 2667
    qla2xxx_get_vpd_field(vha, (char *)"\202", (char *)(& ha->model_desc), 80UL);
  } else {

  }
#line 2668
  return;
}
}
#line 2674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2xxx_nvram_wwn_from_ofw(scsi_qla_host_t *vha , nvram_t *nv ) 
{ 


  {
#line 2676
  return;
}
}
#line 2707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  uint8_t chksum ;
  uint16_t cnt ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  struct qla_hw_data *ha ;
  init_cb_t *icb ;
  nvram_t *nv ;
  uint8_t *ptr ;
  struct device_reg_2xxx *reg ;
  unsigned short tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint16_t tmp___3 ;
  uint8_t *tmp___4 ;
  uint8_t *tmp___5 ;
  uint16_t tmp___6 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;

  {
#line 2710
  chksum = 0U;
#line 2713
  ha = vha->hw;
#line 2714
  icb = ha->init_cb;
#line 2715
  nv = (nvram_t *)ha->nvram;
#line 2716
  ptr = (uint8_t *)ha->nvram;
#line 2717
  reg = & (ha->iobase)->isp;
#line 2719
  rval = 0;
#line 2722
  ha->nvram_size = 256U;
#line 2723
  ha->nvram_base = 0U;
#line 2724
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 2725
    tmp = readw((void const volatile   *)(& reg->ctrl_status));
#line 2725
    if ((unsigned int )((int )tmp >> 14) == 1U) {
#line 2726
      ha->nvram_base = 128U;
    } else {

    }
  } else {

  }
#line 2729
  (*((ha->isp_ops)->read_nvram))(vha, ptr, (uint32_t )ha->nvram_base, (uint32_t )ha->nvram_size);
#line 2730
  cnt = 0U;
#line 2730
  chksum = 0U;
#line 2730
  goto ldv_61265;
  ldv_61264: 
#line 2731
  tmp___0 = ptr;
#line 2731
  ptr = ptr + 1;
#line 2731
  chksum = (int )*tmp___0 + (int )chksum;
#line 2730
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61265: ;
#line 2730
  if ((int )ha->nvram_size > (int )cnt) {
#line 2732
    goto ldv_61264;
  } else {

  }
#line 2733
  ql_dbg(1073872896U, vha, 271, "Contents of NVRAM.\n");
#line 2735
  ql_dump_buffer(1073872896U, vha, 272, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 2739
  if ((((((unsigned int )chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 2742
    ql_log(1U, vha, 100, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           (int )chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 2746
    ql_log(1U, vha, 101, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 2753
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 2754
    nv->parameter_block_version = 1U;
#line 2756
    if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2757
      nv->firmware_options[0] = 6U;
#line 2758
      nv->firmware_options[1] = 160U;
#line 2759
      nv->add_firmware_options[0] = 32U;
#line 2760
      nv->add_firmware_options[1] = 48U;
#line 2761
      nv->frame_payload_size = 2048U;
#line 2762
      nv->special_options[1] = 128U;
    } else
#line 2763
    if ((ha->device_type & 2U) != 0U) {
#line 2764
      nv->firmware_options[0] = 6U;
#line 2765
      nv->firmware_options[1] = 160U;
#line 2766
      nv->add_firmware_options[0] = 32U;
#line 2767
      nv->add_firmware_options[1] = 48U;
#line 2768
      nv->frame_payload_size = 1024U;
    } else
#line 2769
    if ((int )ha->device_type & 1) {
#line 2770
      nv->firmware_options[0] = 10U;
#line 2771
      nv->firmware_options[1] = 32U;
#line 2772
      nv->frame_payload_size = 1024U;
    } else {

    }
#line 2775
    nv->max_iocb_allocation = 256U;
#line 2776
    nv->execution_throttle = 16U;
#line 2777
    nv->retry_count = 8U;
#line 2778
    nv->retry_delay = 1U;
#line 2780
    nv->port_name[0] = 33U;
#line 2781
    nv->port_name[3] = 224U;
#line 2782
    nv->port_name[4] = 139U;
#line 2784
    qla2xxx_nvram_wwn_from_ofw(vha, nv);
#line 2786
    nv->login_timeout = 4U;
#line 2791
    nv->host_p[1] = 4U;
#line 2792
    nv->reset_delay = 5U;
#line 2793
    nv->port_down_retry_count = 8U;
#line 2794
    nv->max_luns_per_target = 8U;
#line 2795
    nv->link_down_timeout = 60U;
#line 2797
    rval = 1;
  } else {

  }
#line 2815
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 2820
  nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 66U);
#line 2821
  nv->firmware_options[0] = (unsigned int )nv->firmware_options[0] & 207U;
#line 2822
  nv->firmware_options[1] = (uint8_t )((unsigned int )nv->firmware_options[1] | 33U);
#line 2823
  nv->firmware_options[1] = (unsigned int )nv->firmware_options[1] & 239U;
#line 2825
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2826
    nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 4U);
#line 2827
    nv->firmware_options[0] = (unsigned int )nv->firmware_options[0] & 247U;
#line 2828
    nv->special_options[0] = (unsigned int )nv->special_options[0] & 191U;
#line 2829
    nv->add_firmware_options[1] = (uint8_t )((unsigned int )nv->add_firmware_options[1] | 48U);
#line 2831
    if ((ha->device_type & 4U) != 0U) {
#line 2832
      if ((unsigned int )ha->fb_rev == 7U) {
#line 2833
        strcpy((char *)(& ha->model_number), "QLA2310");
      } else {
#line 2835
        strcpy((char *)(& ha->model_number), "QLA2300");
      }
    } else {
#line 2838
      qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_number), 16UL, (char *)"QLA23xx");
    }
  } else
#line 2841
  if ((ha->device_type & 2U) != 0U) {
#line 2842
    nv->firmware_options[0] = (uint8_t )((unsigned int )nv->firmware_options[0] | 4U);
#line 2847
    if (((int )nv->add_firmware_options[0] & 112) == 48) {
#line 2850
      nv->add_firmware_options[0] = (unsigned int )nv->add_firmware_options[0] & 143U;
#line 2851
      nv->add_firmware_options[0] = (uint8_t )((unsigned int )nv->add_firmware_options[0] | 32U);
    } else {

    }
#line 2853
    strcpy((char *)(& ha->model_number), "QLA22xx");
  } else {
#line 2855
    strcpy((char *)(& ha->model_number), "QLA2100");
  }
#line 2861
  dptr1 = (uint8_t *)icb;
#line 2862
  dptr2 = & nv->parameter_block_version;
#line 2863
  cnt = 32U;
#line 2864
  goto ldv_61268;
  ldv_61267: 
#line 2865
  tmp___1 = dptr1;
#line 2865
  dptr1 = dptr1 + 1;
#line 2865
  tmp___2 = dptr2;
#line 2865
  dptr2 = dptr2 + 1;
#line 2865
  *tmp___1 = *tmp___2;
  ldv_61268: 
#line 2864
  tmp___3 = cnt;
#line 2864
  cnt = (uint16_t )((int )cnt - 1);
#line 2864
  if ((unsigned int )tmp___3 != 0U) {
#line 2866
    goto ldv_61267;
  } else {

  }
#line 2868
  dptr1 = (uint8_t *)(& icb->add_firmware_options);
#line 2869
  cnt = 6U;
#line 2870
  goto ldv_61271;
  ldv_61270: 
#line 2871
  tmp___4 = dptr1;
#line 2871
  dptr1 = dptr1 + 1;
#line 2871
  tmp___5 = dptr2;
#line 2871
  dptr2 = dptr2 + 1;
#line 2871
  *tmp___4 = *tmp___5;
  ldv_61271: 
#line 2870
  tmp___6 = cnt;
#line 2870
  cnt = (uint16_t )((int )cnt - 1);
#line 2870
  if ((unsigned int )tmp___6 != 0U) {
#line 2872
    goto ldv_61270;
  } else {

  }

#line 2874
  if ((int )((signed char )nv->host_p[1]) < 0) {
#line 2875
    __len = 8UL;
#line 2875
    if (__len > 63UL) {
#line 2875
      __ret = __memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                       __len);
    } else {
#line 2875
      __ret = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                               __len);
    }
#line 2876
    __len___0 = 8UL;
#line 2876
    if (__len___0 > 63UL) {
#line 2876
      __ret___0 = __memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                           __len___0);
    } else {
#line 2876
      __ret___0 = __builtin_memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                                   __len___0);
    }
  } else {

  }
#line 2880
  if (((int )icb->firmware_options[1] & 64) == 0) {
#line 2885
    __len___1 = 8UL;
#line 2885
    if (__len___1 > 63UL) {
#line 2885
      __ret___1 = __memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                           __len___1);
    } else {
#line 2885
      __ret___1 = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                                   __len___1);
    }
#line 2886
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 2897
  if ((int )((signed char )nv->host_p[0]) < 0) {
#line 2898
    ql2xextended_error_logging = 507510784;
  } else {

  }
#line 2899
  ha->flags.disable_risc_code_load = ((int )nv->host_p[0] & 16) != 0;
#line 2901
  if ((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) {
#line 2902
    ha->flags.disable_risc_code_load = 0U;
  } else {

  }
#line 2903
  ha->flags.enable_lip_reset = ((int )nv->host_p[1] & 2) != 0;
#line 2904
  ha->flags.enable_lip_full_login = ((int )nv->host_p[1] & 4) != 0;
#line 2905
  ha->flags.enable_target_reset = ((int )nv->host_p[1] & 8) != 0;
#line 2906
  ha->flags.enable_led_scheme = ((int )nv->special_options[1] & 16) != 0;
#line 2907
  ha->flags.disable_serdes = 0U;
#line 2909
  ha->operating_mode = (uint8_t )(((int )icb->add_firmware_options[0] & 112) >> 4);
#line 2912
  __len___2 = 4UL;
#line 2912
  if (__len___2 > 63UL) {
#line 2912
    __ret___2 = __memcpy((void *)(& ha->fw_seriallink_options), (void const   *)(& nv->seriallink_options),
                         __len___2);
  } else {
#line 2912
    __ret___2 = __builtin_memcpy((void *)(& ha->fw_seriallink_options), (void const   *)(& nv->seriallink_options),
                                 __len___2);
  }
#line 2916
  ha->serial0 = icb->port_name[5];
#line 2917
  ha->serial1 = icb->port_name[6];
#line 2918
  ha->serial2 = icb->port_name[7];
#line 2919
  __len___3 = 8UL;
#line 2919
  if (__len___3 > 63UL) {
#line 2919
    __ret___3 = __memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                         __len___3);
  } else {
#line 2919
    __ret___3 = __builtin_memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                                 __len___3);
  }
#line 2920
  __len___4 = 8UL;
#line 2920
  if (__len___4 > 63UL) {
#line 2920
    __ret___4 = __memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                         __len___4);
  } else {
#line 2920
    __ret___4 = __builtin_memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                                 __len___4);
  }
#line 2922
  icb->execution_throttle = 65535U;
#line 2924
  ha->retry_count = nv->retry_count;
#line 2927
  if ((int )nv->login_timeout != ql2xlogintimeout) {
#line 2928
    nv->login_timeout = (uint8_t )ql2xlogintimeout;
  } else {

  }
#line 2929
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 2930
    nv->login_timeout = 4U;
  } else {

  }
#line 2931
  ha->login_timeout = nv->login_timeout;
#line 2932
  icb->login_timeout = nv->login_timeout;
#line 2935
  ha->r_a_tov = 100U;
#line 2937
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 2949
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 2950
    ha->loop_down_abort_time = 195U;
  } else {
#line 2953
    ha->link_down_timeout = nv->link_down_timeout;
#line 2954
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 2961
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 2962
  if (qlport_down_retry != 0) {
#line 2963
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 2965
  ha->login_retry_count = (uint32_t )nv->retry_count;
#line 2966
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 2968
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 2969
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 2970
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 2971
  if (ql2xloginretrycount != 0) {
#line 2972
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 2974
  icb->lun_enables = 0U;
#line 2975
  icb->command_resource_count = 0U;
#line 2976
  icb->immediate_notify_resource_count = 0U;
#line 2977
  icb->timeout = 0U;
#line 2979
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 2981
    icb->firmware_options[0] = (unsigned int )icb->firmware_options[0] & 247U;
#line 2982
    icb->add_firmware_options[0] = (unsigned int )icb->add_firmware_options[0] & 240U;
#line 2984
    icb->add_firmware_options[0] = (uint8_t )((unsigned int )icb->add_firmware_options[0] | 4U);
#line 2985
    icb->response_accumulation_timer = 3U;
#line 2986
    icb->interrupt_delay_timer = 5U;
#line 2988
    vha->flags.process_response_queue = 1U;
  } else {
#line 2991
    if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2992
      ha->zio_mode = (unsigned int )((uint16_t )icb->add_firmware_options[0]) & 15U;
#line 2994
      ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? (uint16_t )icb->interrupt_delay_timer : 2U;
    } else {

    }
#line 2997
    icb->add_firmware_options[0] = (unsigned int )icb->add_firmware_options[0] & 240U;
#line 2999
    vha->flags.process_response_queue = 0U;
#line 3000
    if ((unsigned int )ha->zio_mode != 0U) {
#line 3001
      ha->zio_mode = 6U;
#line 3003
      ql_log(2U, vha, 104, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
             (int )ha->zio_timer * 100);
#line 3007
      icb->add_firmware_options[0] = (uint8_t )((int )icb->add_firmware_options[0] | (int )((unsigned char )ha->zio_mode));
#line 3008
      icb->interrupt_delay_timer = (unsigned char )ha->zio_timer;
#line 3009
      vha->flags.process_response_queue = 1U;
    } else {

    }
  }
#line 3013
  if (rval != 0) {
#line 3014
    ql_log(1U, vha, 105, "NVRAM configuration failed.\n");
  } else {

  }
#line 3017
  return (rval);
}
}
#line 3021 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_rport_del(void *data ) 
{ 
  fc_port_t *fcport ;
  struct fc_rport *rport ;
  scsi_qla_host_t *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3023
  fcport = (fc_port_t *)data;
#line 3025
  vha = fcport->vha;
#line 3028
  tmp = spinlock_check(((fcport->vha)->host)->host_lock);
#line 3028
  flags = _raw_spin_lock_irqsave(tmp);
#line 3029
  rport = (unsigned long )fcport->drport != (unsigned long )((struct fc_rport *)0) ? fcport->drport : fcport->rport;
#line 3030
  fcport->drport = (struct fc_rport *)0;
#line 3031
  spin_unlock_irqrestore(((fcport->vha)->host)->host_lock, flags);
#line 3032
  if ((unsigned long )rport != (unsigned long )((struct fc_rport *)0)) {
#line 3033
    fc_remote_port_delete(rport);
#line 3038
    qlt_fc_port_deleted(vha, fcport);
  } else {

  }
#line 3040
  return;
}
}
#line 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
fc_port_t *qla2x00_alloc_fcport(scsi_qla_host_t *vha , gfp_t flags ) 
{ 
  fc_port_t *fcport ;
  void *tmp ;

  {
#line 3054
  tmp = kzalloc(128UL, flags);
#line 3054
  fcport = (fc_port_t *)tmp;
#line 3055
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 3056
    return ((fc_port_t *)0);
  } else {

  }
#line 3059
  fcport->vha = vha;
#line 3060
  fcport->port_type = 0;
#line 3061
  fcport->loop_id = 4096U;
#line 3062
  qla2x00_set_fcport_state___0(fcport, 1);
#line 3063
  fcport->supported_classes = 0U;
#line 3065
  return (fcport);
}
}
#line 3081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_configure_loop(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  unsigned long save_flags ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 3085
  ha = vha->hw;
#line 3086
  rval = 0;
#line 3089
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3089
  if (tmp != 0) {
#line 3090
    rval = qla2x00_configure_hba(vha);
#line 3091
    if (rval != 0) {
#line 3092
      ql_dbg(268435456U, vha, 8211, "Unable to configure HBA.\n");
#line 3094
      return (rval);
    } else {

    }
  } else {

  }
#line 3098
  flags = vha->dpc_flags;
#line 3098
  save_flags = flags;
#line 3099
  ql_dbg(268435456U, vha, 8212, "Configure loop -- dpc flags = 0x%lx.\n", flags);
#line 3106
  clear_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3107
  clear_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3109
  qla2x00_get_data_rate(vha);
#line 3112
  if ((unsigned int )ha->current_topology == 4U) {
#line 3112
    tmp___2 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3112
    if (tmp___2 != 0) {
#line 3115
      set_bit(7L, (unsigned long volatile   *)(& flags));
    } else {
#line 3112
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3117
  if ((unsigned int )ha->current_topology == 8U) {
#line 3117
    tmp___1 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3117
    if (tmp___1 != 0) {
#line 3120
      set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3121
      clear_bit(6L, (unsigned long volatile   *)(& flags));
    } else {
#line 3117
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3123
  if ((unsigned int )ha->current_topology == 2U) {
#line 3124
    clear_bit(7L, (unsigned long volatile   *)(& flags));
  } else
#line 3126
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 3129
    set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3130
    set_bit(6L, (unsigned long volatile   *)(& flags));
  } else {
#line 3126
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& flags));
#line 3126
    if (tmp___0 != 0) {
#line 3129
      set_bit(7L, (unsigned long volatile   *)(& flags));
#line 3130
      set_bit(6L, (unsigned long volatile   *)(& flags));
    } else {

    }
  }
#line 3133
  tmp___4 = constant_test_bit(6L, (unsigned long const volatile   *)(& flags));
#line 3133
  if (tmp___4 != 0) {
#line 3134
    tmp___3 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3134
    if (tmp___3 != 0) {
#line 3135
      ql_dbg(268435456U, vha, 8213, "Loop resync needed, failing.\n");
#line 3137
      rval = 258;
    } else {
#line 3139
      rval = qla2x00_configure_local_loop(vha);
    }
  } else {

  }
#line 3142
  if (rval == 0) {
#line 3142
    tmp___8 = constant_test_bit(7L, (unsigned long const volatile   *)(& flags));
#line 3142
    if (tmp___8 != 0) {
#line 3143
      tmp___5 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3143
      if (tmp___5 != 0) {
#line 3144
        ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3146
        rval = 258;
      } else {
#line 3143
        tmp___6 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3143
        if (tmp___6 != 0) {
#line 3144
          ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3146
          rval = 258;
        } else {
#line 3143
          tmp___7 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 3143
          if (tmp___7 == 2) {
#line 3144
            ql_dbg(268435456U, vha, 8222, "Needs RSCN update and loop transition.\n");
#line 3146
            rval = 258;
          } else {
#line 3149
            rval = qla2x00_configure_fabric(vha);
          }
        }
      }
    } else {

    }
  } else {

  }
#line 3152
  if (rval == 0) {
#line 3153
    tmp___9 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3153
    if (tmp___9 != 0) {
#line 3155
      rval = 258;
    } else {
#line 3153
      tmp___10 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3153
      if (tmp___10 != 0) {
#line 3155
        rval = 258;
      } else {
#line 3157
        atomic_set(& vha->loop_state, 5);
#line 3158
        ql_dbg(268435456U, vha, 8297, "LOOP READY.\n");
      }
    }
  } else {

  }
#line 3163
  if (rval != 0) {
#line 3164
    ql_dbg(268435456U, vha, 8298, "%s *** FAILED ***.\n", "qla2x00_configure_loop");
  } else {
#line 3167
    ql_dbg(268435456U, vha, 8299, "%s: exiting normally.\n", "qla2x00_configure_loop");
  }
#line 3172
  tmp___13 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3172
  if (tmp___13 != 0) {
#line 3173
    tmp___11 = constant_test_bit(6L, (unsigned long const volatile   *)(& save_flags));
#line 3173
    if (tmp___11 != 0) {
#line 3174
      set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
#line 3175
    tmp___12 = constant_test_bit(7L, (unsigned long const volatile   *)(& save_flags));
#line 3175
    if (tmp___12 != 0) {
#line 3176
      set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 3180
  return (rval);
}
}
#line 3196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_configure_local_loop(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int rval2 ;
  int found_devs ;
  int found ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  uint16_t index ;
  uint16_t entries ;
  char *id_iter ;
  uint16_t loop_id ;
  uint8_t domain ;
  uint8_t area ;
  uint8_t al_pa ;
  struct qla_hw_data *ha ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  struct list_head  const  *__mptr___2 ;

  {
#line 3208
  ha = vha->hw;
#line 3210
  found_devs = 0;
#line 3211
  new_fcport = (fc_port_t *)0;
#line 3212
  entries = 128U;
#line 3215
  tmp = qla2x00_gid_list_size(ha);
#line 3215
  memset((void *)ha->gid_list, 0, (size_t )tmp);
#line 3216
  rval = qla2x00_get_id_list(vha, (void *)ha->gid_list, ha->gid_list_dma, & entries);
#line 3218
  if (rval != 0) {
#line 3219
    goto cleanup_allocation;
  } else {

  }
#line 3221
  ql_dbg(268435456U, vha, 8215, "Entries in ID list (%d).\n", (int )entries);
#line 3223
  ql_dump_buffer(268566528U, vha, 8309, (uint8_t *)ha->gid_list, (uint32_t )entries * 8U);
#line 3228
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3229
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3230
    ql_log(1U, vha, 8216, "Memory allocation failed for fcport.\n");
#line 3232
    rval = 259;
#line 3233
    goto cleanup_allocation;
  } else {

  }
#line 3235
  new_fcport->flags = new_fcport->flags & 4294967294U;
#line 3240
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3240
  fcport = (fc_port_t *)__mptr;
#line 3240
  goto ldv_61337;
  ldv_61336: 
#line 3241
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3241
  if ((tmp___0 == 4 && (unsigned int )fcport->port_type != 3U) && (fcport->flags & 1U) == 0U) {
#line 3245
    ql_dbg(268435456U, vha, 8217, "Marking port lost loop_id=0x%04x.\n", (int )fcport->loop_id);
#line 3249
    qla2x00_set_fcport_state___0(fcport, 3);
  } else {

  }
#line 3240
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3240
  fcport = (fc_port_t *)__mptr___0;
  ldv_61337: ;
#line 3240
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3242
    goto ldv_61336;
  } else {

  }
#line 3254
  id_iter = (char *)ha->gid_list;
#line 3255
  index = 0U;
#line 3255
  goto ldv_61352;
  ldv_61351: 
#line 3256
  domain = ((struct gid_list_info *)id_iter)->domain;
#line 3257
  area = ((struct gid_list_info *)id_iter)->area;
#line 3258
  al_pa = ((struct gid_list_info *)id_iter)->al_pa;
#line 3259
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 3260
    loop_id = (unsigned short )((struct gid_list_info *)id_iter)->loop_id_2100;
  } else {
#line 3263
    loop_id = ((struct gid_list_info *)id_iter)->loop_id;
  }
#line 3265
  id_iter = id_iter + (unsigned long )ha->gid_list_info_size;
#line 3268
  if (((int )domain & 240) == 240) {
#line 3269
    goto ldv_61339;
  } else {

  }
#line 3272
  if (((unsigned int )area != 0U && (unsigned int )domain != 0U) && ((int )vha->d_id.b.area != (int )area || (int )vha->d_id.b.domain != (int )domain)) {
#line 3274
    goto ldv_61339;
  } else {

  }
#line 3277
  if ((unsigned int )loop_id > 125U) {
#line 3278
    goto ldv_61339;
  } else {

  }
#line 3280
  memset((void *)new_fcport, 0, 128UL);
#line 3283
  new_fcport->d_id.b.domain = domain;
#line 3284
  new_fcport->d_id.b.area = area;
#line 3285
  new_fcport->d_id.b.al_pa = al_pa;
#line 3286
  new_fcport->loop_id = loop_id;
#line 3287
  rval2 = qla2x00_get_port_database(vha, new_fcport, 0);
#line 3288
  if (rval2 != 0) {
#line 3289
    ql_dbg(268435456U, vha, 8218, "Failed to retrieve fcport information -- get_port_database=%x, loop_id=0x%04x.\n",
           rval2, (int )new_fcport->loop_id);
#line 3293
    ql_dbg(268435456U, vha, 8219, "Scheduling resync.\n");
#line 3295
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3296
    goto ldv_61339;
  } else {

  }
#line 3300
  found = 0;
#line 3301
  fcport = (fc_port_t *)0;
#line 3302
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3302
  fcport = (fc_port_t *)__mptr___1;
#line 3302
  goto ldv_61350;
  ldv_61349: 
#line 3303
  tmp___1 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 3303
  if (tmp___1 != 0) {
#line 3305
    goto ldv_61344;
  } else {

  }
#line 3307
  fcport->flags = fcport->flags & 4294967294U;
#line 3308
  fcport->loop_id = new_fcport->loop_id;
#line 3309
  fcport->port_type = new_fcport->port_type;
#line 3310
  fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3311
  __len = 8UL;
#line 3311
  if (__len > 63UL) {
#line 3311
    __ret = __memcpy((void *)(& fcport->node_name), (void const   *)(& new_fcport->node_name),
                     __len);
  } else {
#line 3311
    __ret = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& new_fcport->node_name),
                             __len);
  }
#line 3314
  found = found + 1;
#line 3315
  goto ldv_61348;
  ldv_61344: 
#line 3302
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 3302
  fcport = (fc_port_t *)__mptr___2;
  ldv_61350: ;
#line 3302
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3304
    goto ldv_61349;
  } else {

  }
  ldv_61348: ;
#line 3318
  if (found == 0) {
#line 3320
    list_add_tail(& new_fcport->list, & vha->vp_fcports);
#line 3323
    fcport = new_fcport;
#line 3324
    new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3325
    if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3326
      ql_log(1U, vha, 8220, "Failed to allocate memory for fcport.\n");
#line 3328
      rval = 259;
#line 3329
      goto cleanup_allocation;
    } else {

    }
#line 3331
    new_fcport->flags = new_fcport->flags & 4294967294U;
  } else {

  }
#line 3335
  fcport->fp_speed = ha->link_data_rate;
#line 3337
  qla2x00_update_fcport(vha, fcport);
#line 3339
  found_devs = found_devs + 1;
  ldv_61339: 
#line 3255
  index = (uint16_t )((int )index + 1);
  ldv_61352: ;
#line 3255
  if ((int )index < (int )entries) {
#line 3257
    goto ldv_61351;
  } else {

  }

  cleanup_allocation: 
#line 3343
  kfree((void const   *)new_fcport);
#line 3345
  if (rval != 0) {
#line 3346
    ql_dbg(268435456U, vha, 8221, "Configure local loop error exit: rval=%x.\n", rval);
  } else {

  }
#line 3350
  return (rval);
}
}
#line 3354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_iidma_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  uint16_t mb[4U] ;
  struct qla_hw_data *ha ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 3358
  ha = vha->hw;
#line 3360
  if ((ha->device_type & 67108864U) == 0U) {
#line 3361
    return;
  } else {

  }
#line 3363
  tmp = atomic_read((atomic_t const   *)(& fcport->state));
#line 3363
  if (tmp != 4) {
#line 3364
    return;
  } else {

  }
#line 3366
  if ((unsigned int )fcport->fp_speed == 65535U || (int )fcport->fp_speed > (int )ha->link_data_rate) {
#line 3368
    return;
  } else {

  }
#line 3370
  rval = qla2x00_set_idma_speed(vha, (int )fcport->loop_id, (int )fcport->fp_speed,
                                (uint16_t *)(& mb));
#line 3372
  if (rval != 0) {
#line 3373
    ql_dbg(268435456U, vha, 8196, "Unable to adjust iIDMA %8phN -- %04x %x %04x %04x.\n",
           (uint8_t *)(& fcport->port_name), rval, (int )fcport->fp_speed, (int )mb[0],
           (int )mb[1]);
  } else {
#line 3377
    tmp___0 = qla2x00_get_link_speed_str(ha, (int )fcport->fp_speed);
#line 3377
    ql_dbg(268435456U, vha, 8197, "iIDMA adjusted to %s GB/s on %8phN.\n", tmp___0,
           (uint8_t *)(& fcport->port_name));
  }
#line 3381
  return;
}
}
#line 3385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla2x00_reg_remote_port(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  struct fc_rport_identifiers rport_ids ;
  struct fc_rport *rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3391
  qla2x00_rport_del((void *)fcport);
#line 3393
  rport_ids.node_name = wwn_to_u64((u8 *)(& fcport->node_name));
#line 3394
  rport_ids.port_name = wwn_to_u64((u8 *)(& fcport->port_name));
#line 3395
  rport_ids.port_id = (u32 )((((int )fcport->d_id.b.domain << 16) | ((int )fcport->d_id.b.area << 8)) | (int )fcport->d_id.b.al_pa);
#line 3397
  rport_ids.roles = 0U;
#line 3398
  rport = fc_remote_port_add(vha->host, 0, & rport_ids);
#line 3398
  fcport->rport = rport;
#line 3399
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 3400
    ql_log(1U, vha, 8198, "Unable to allocate fc remote port.\n");
#line 3402
    return;
  } else {

  }
#line 3408
  qlt_fc_port_added(vha, fcport);
#line 3410
  tmp = spinlock_check(((fcport->vha)->host)->host_lock);
#line 3410
  flags = _raw_spin_lock_irqsave(tmp);
#line 3411
  *((fc_port_t **)rport->dd_data) = fcport;
#line 3412
  spin_unlock_irqrestore(((fcport->vha)->host)->host_lock, flags);
#line 3414
  rport->supported_classes = fcport->supported_classes;
#line 3416
  rport_ids.roles = 0U;
#line 3417
  if ((unsigned int )fcport->port_type == 4U) {
#line 3418
    rport_ids.roles = rport_ids.roles | 2U;
  } else {

  }
#line 3419
  if ((unsigned int )fcport->port_type == 5U) {
#line 3420
    rport_ids.roles = rport_ids.roles | 1U;
  } else {

  }
#line 3421
  fc_remote_port_rolechg(rport, rport_ids.roles);
#line 3422
  return;
}
}
#line 3440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_update_fcport(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 


  {
#line 3442
  fcport->vha = vha;
#line 3444
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 3445
    qla2x00_set_fcport_state___0(fcport, 4);
#line 3446
    qla2x00_reg_remote_port(vha, fcport);
#line 3447
    return;
  } else {

  }
#line 3449
  fcport->login_retry = 0;
#line 3450
  fcport->flags = fcport->flags & 4294967285U;
#line 3452
  qla2x00_set_fcport_state___0(fcport, 4);
#line 3453
  qla2x00_iidma_fcport(vha, fcport);
#line 3454
  qla24xx_update_fcport_fcp_prio(vha, fcport);
#line 3455
  qla2x00_reg_remote_port(vha, fcport);
#line 3456
  return;
}
}
#line 3470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_configure_fabric(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  fc_port_t *fcport ;
  fc_port_t *fcptemp ;
  uint16_t next_loopid ;
  uint16_t mb[32U] ;
  uint16_t loop_id ;
  struct list_head new_fcports ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___6 ;
  int tmp___7 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  int tmp___8 ;
  int tmp___9 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  int tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  struct list_head  const  *__mptr___9 ;
  struct list_head  const  *__mptr___10 ;

  {
#line 3477
  new_fcports.next = & new_fcports;
#line 3477
  new_fcports.prev = & new_fcports;
#line 3478
  ha = vha->hw;
#line 3479
  tmp = pci_get_drvdata(ha->pdev);
#line 3479
  base_vha = (struct scsi_qla_host *)tmp;
#line 3482
  if ((ha->device_type & 134217728U) != 0U) {
#line 3483
    loop_id = 2046U;
  } else {
#line 3485
    loop_id = 126U;
  }
#line 3486
  rval = qla2x00_get_port_name(vha, (int )loop_id, (uint8_t *)(& vha->fabric_node_name),
                               1);
#line 3487
  if (rval != 0) {
#line 3488
    ql_dbg(268435456U, vha, 8223, "MBX_GET_PORT_NAME failed, No FL Port.\n");
#line 3491
    vha->device_flags = vha->device_flags & 4294967294U;
#line 3492
    return (0);
  } else {

  }
#line 3494
  vha->device_flags = vha->device_flags | 1U;
#line 3498
  if (ql2xfdmienable != 0) {
#line 3498
    tmp___0 = test_and_clear_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3498
    if (tmp___0 != 0) {
#line 3500
      qla2x00_fdmi_register(vha);
    } else {

    }
  } else {

  }
#line 3503
  if ((ha->device_type & 134217728U) != 0U) {
#line 3504
    loop_id = 2044U;
  } else {
#line 3506
    loop_id = 128U;
  }
#line 3507
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )loop_id, 255, 255, 252, (uint16_t *)(& mb),
                                          3);
#line 3509
  if (rval != 0) {
#line 3510
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3511
    return (rval);
  } else {

  }
#line 3513
  if ((unsigned int )mb[0] != 16384U) {
#line 3514
    ql_dbg(268435456U, vha, 8258, "Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
           (int )loop_id, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6], (int )mb[7]);
#line 3518
    return (0);
  } else {

  }
#line 3521
  tmp___5 = test_and_clear_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3521
  if (tmp___5 != 0) {
#line 3522
    tmp___1 = qla2x00_rft_id(vha);
#line 3522
    if (tmp___1 != 0) {
#line 3524
      ql_dbg(268435456U, vha, 8261, "Register FC-4 TYPE failed.\n");
    } else {

    }
#line 3527
    tmp___2 = qla2x00_rff_id(vha);
#line 3527
    if (tmp___2 != 0) {
#line 3529
      ql_dbg(268435456U, vha, 8265, "Register FC-4 Features failed.\n");
    } else {

    }
#line 3532
    tmp___4 = qla2x00_rnn_id(vha);
#line 3532
    if (tmp___4 != 0) {
#line 3534
      ql_dbg(268435456U, vha, 8271, "Register Node Name failed.\n");
    } else {
#line 3536
      tmp___3 = qla2x00_rsnn_nn(vha);
#line 3536
      if (tmp___3 != 0) {
#line 3538
        ql_dbg(268435456U, vha, 8275, "Register Symobilic Node Name failed.\n");
      } else {

      }
    }
  } else {

  }
#line 3546
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 3546
  fcport = (fc_port_t *)__mptr;
#line 3546
  goto ldv_61392;
  ldv_61391: 
#line 3547
  fcport->scan_state = 1U;
#line 3546
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3546
  fcport = (fc_port_t *)__mptr___0;
  ldv_61392: ;
#line 3546
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3548
    goto ldv_61391;
  } else {

  }
#line 3550
  rval = qla2x00_find_all_fabric_devs(vha, & new_fcports);
#line 3551
  if (rval != 0) {
#line 3552
    goto ldv_61394;
  } else {

  }
#line 3558
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3558
  fcport = (fc_port_t *)__mptr___1;
#line 3558
  goto ldv_61402;
  ldv_61401: 
#line 3559
  tmp___6 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3559
  if (tmp___6 != 0) {
#line 3560
    goto ldv_61399;
  } else {

  }
#line 3562
  if ((fcport->flags & 1U) == 0U) {
#line 3563
    goto ldv_61400;
  } else {

  }
#line 3565
  if ((unsigned int )fcport->scan_state == 1U) {
#line 3565
    tmp___7 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3565
    if (tmp___7 == 4) {
#line 3567
      qla2x00_mark_device_lost(vha, fcport, ql2xplogiabsentdevice, 0);
#line 3569
      if ((((unsigned int )fcport->loop_id != 4096U && (fcport->flags & 4U) == 0U) && (unsigned int )fcport->port_type != 4U) && (unsigned int )fcport->port_type != 3U) {
#line 3573
        (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3578
        fcport->loop_id = 4096U;
      } else {

      }
    } else {

    }
  } else {

  }
  ldv_61400: 
#line 3558
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 3558
  fcport = (fc_port_t *)__mptr___2;
  ldv_61402: ;
#line 3558
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3560
    goto ldv_61401;
  } else {

  }
  ldv_61399: 
#line 3584
  next_loopid = ha->min_external_loopid;
#line 3590
  __mptr___3 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3590
  fcport = (fc_port_t *)__mptr___3;
#line 3590
  goto ldv_61410;
  ldv_61409: 
#line 3591
  tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3591
  if (tmp___8 != 0) {
#line 3593
    goto ldv_61407;
  } else {
#line 3591
    tmp___9 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3591
    if (tmp___9 != 0) {
#line 3593
      goto ldv_61407;
    } else {

    }
  }
#line 3595
  if ((fcport->flags & 1U) == 0U || (fcport->flags & 2U) == 0U) {
#line 3597
    goto ldv_61408;
  } else {

  }
#line 3599
  if ((unsigned int )fcport->loop_id == 4096U) {
#line 3600
    fcport->loop_id = next_loopid;
#line 3601
    rval = qla2x00_find_new_loop_id(base_vha, fcport);
#line 3603
    if (rval != 0) {
#line 3605
      goto ldv_61407;
    } else {

    }
  } else {

  }
#line 3609
  qla2x00_fabric_dev_login(vha, fcport, & next_loopid);
  ldv_61408: 
#line 3590
  __mptr___4 = (struct list_head  const  *)fcport->list.next;
#line 3590
  fcport = (fc_port_t *)__mptr___4;
  ldv_61410: ;
#line 3590
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3592
    goto ldv_61409;
  } else {

  }
  ldv_61407: ;
#line 3613
  if (rval != 0) {
#line 3614
    goto ldv_61394;
  } else {

  }
#line 3620
  __mptr___5 = (struct list_head  const  *)new_fcports.next;
#line 3620
  fcport = (fc_port_t *)__mptr___5;
#line 3620
  __mptr___6 = (struct list_head  const  *)fcport->list.next;
#line 3620
  fcptemp = (fc_port_t *)__mptr___6;
#line 3620
  goto ldv_61419;
  ldv_61418: 
#line 3621
  tmp___10 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3621
  if (tmp___10 != 0) {
#line 3623
    goto ldv_61417;
  } else {
#line 3621
    tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3621
    if (tmp___11 != 0) {
#line 3623
      goto ldv_61417;
    } else {

    }
  }
#line 3626
  fcport->loop_id = next_loopid;
#line 3627
  rval = qla2x00_find_new_loop_id(base_vha, fcport);
#line 3628
  if (rval != 0) {
#line 3630
    goto ldv_61417;
  } else {

  }
#line 3634
  qla2x00_fabric_dev_login(vha, fcport, & next_loopid);
#line 3636
  list_move_tail(& fcport->list, & vha->vp_fcports);
#line 3620
  fcport = fcptemp;
#line 3620
  __mptr___7 = (struct list_head  const  *)fcptemp->list.next;
#line 3620
  fcptemp = (fc_port_t *)__mptr___7;
  ldv_61419: ;
#line 3620
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 3622
    goto ldv_61418;
  } else {

  }
  ldv_61417: ;
  ldv_61394: 
#line 3641
  __mptr___8 = (struct list_head  const  *)new_fcports.next;
#line 3641
  fcport = (fc_port_t *)__mptr___8;
#line 3641
  __mptr___9 = (struct list_head  const  *)fcport->list.next;
#line 3641
  fcptemp = (fc_port_t *)__mptr___9;
#line 3641
  goto ldv_61427;
  ldv_61426: 
#line 3642
  list_del(& fcport->list);
#line 3643
  kfree((void const   *)fcport);
#line 3641
  fcport = fcptemp;
#line 3641
  __mptr___10 = (struct list_head  const  *)fcptemp->list.next;
#line 3641
  fcptemp = (fc_port_t *)__mptr___10;
  ldv_61427: ;
#line 3641
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 3643
    goto ldv_61426;
  } else {

  }

#line 3646
  if (rval != 0) {
#line 3647
    ql_dbg(268435456U, vha, 8296, "Configure fabric error exit rval=%d.\n", rval);
  } else {

  }
#line 3651
  return (rval);
}
}
#line 3668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha , struct list_head *new_fcports ) 
{ 
  int rval ;
  uint16_t loop_id ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  fc_port_t *fcptemp ;
  int found ;
  sw_info_t *swl ;
  int swl_idx ;
  int first_dev ;
  int last_dev ;
  port_id_t wrap ;
  port_id_t nxt_d_id ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___9 ;
  struct list_head  const  *__mptr___2 ;
  int tmp___10 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 3679
  wrap.b24 = 0U;
#line 3680
  ha = vha->hw;
#line 3681
  tmp = pci_get_drvdata(ha->pdev);
#line 3681
  base_vha = (struct scsi_qla_host *)tmp;
#line 3683
  rval = 0;
#line 3686
  if ((unsigned long )ha->swl == (unsigned long )((void *)0)) {
#line 3687
    ha->swl = kcalloc((size_t )ha->max_fibre_devices, 32UL, 208U);
  } else {

  }
#line 3689
  swl = (sw_info_t *)ha->swl;
#line 3690
  if ((unsigned long )swl == (unsigned long )((sw_info_t *)0)) {
#line 3692
    ql_dbg(268435456U, vha, 8276, "GID_PT allocations failed, fallback on GA_NXT.\n");
  } else {
#line 3695
    memset((void *)swl, 0, (unsigned long )ha->max_fibre_devices * 32UL);
#line 3696
    tmp___3 = qla2x00_gid_pt(vha, swl);
#line 3696
    if (tmp___3 != 0) {
#line 3697
      swl = (sw_info_t *)0;
    } else {
#line 3698
      tmp___2 = qla2x00_gpn_id(vha, swl);
#line 3698
      if (tmp___2 != 0) {
#line 3699
        swl = (sw_info_t *)0;
      } else {
#line 3700
        tmp___1 = qla2x00_gnn_id(vha, swl);
#line 3700
        if (tmp___1 != 0) {
#line 3701
          swl = (sw_info_t *)0;
        } else
#line 3702
        if (ql2xiidmaenable != 0) {
#line 3702
          tmp___0 = qla2x00_gfpn_id(vha, swl);
#line 3702
          if (tmp___0 == 0) {
#line 3704
            qla2x00_gpsc(vha, swl);
          } else {

          }
        } else {

        }
      }
    }
#line 3708
    if ((unsigned long )swl != (unsigned long )((sw_info_t *)0)) {
#line 3709
      qla2x00_gff_id(vha, swl);
    } else {

    }
  }
#line 3711
  swl_idx = 0;
#line 3714
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3715
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3716
    ql_log(1U, vha, 8286, "Failed to allocate memory for fcport.\n");
#line 3718
    return (259);
  } else {

  }
#line 3720
  new_fcport->flags = new_fcport->flags | 3U;
#line 3722
  first_dev = 1;
#line 3723
  last_dev = 0;
#line 3726
  loop_id = ha->min_external_loopid;
#line 3727
  goto ldv_61479;
  ldv_61478: 
#line 3728
  tmp___4 = qla2x00_is_reserved_id(vha, (int )loop_id);
#line 3728
  if (tmp___4 != 0) {
#line 3729
    goto ldv_61447;
  } else {

  }
#line 3731
  if ((unsigned int )ha->current_topology == 4U) {
#line 3731
    tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 3731
    if (tmp___5 != 0) {
#line 3734
      atomic_set(& vha->loop_down_timer, 0);
#line 3735
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3736
      set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3737
      goto ldv_61448;
    } else {
#line 3731
      tmp___6 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3731
      if (tmp___6 != 0) {
#line 3734
        atomic_set(& vha->loop_down_timer, 0);
#line 3735
        set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3736
        set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3737
        goto ldv_61448;
      } else {
#line 3731
        tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3731
        if (tmp___7 != 0) {
#line 3734
          atomic_set(& vha->loop_down_timer, 0);
#line 3735
          set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3736
          set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3737
          goto ldv_61448;
        } else {
#line 3731
          tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 3731
          if (tmp___8 == 2) {
#line 3734
            atomic_set(& vha->loop_down_timer, 0);
#line 3735
            set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3736
            set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3737
            goto ldv_61448;
          } else {

          }
        }
      }
    }
  } else {

  }
#line 3740
  if ((unsigned long )swl != (unsigned long )((sw_info_t *)0)) {
#line 3741
    if (last_dev != 0) {
#line 3742
      wrap.b24 = new_fcport->d_id.b24;
    } else {
#line 3744
      new_fcport->d_id.b24 = (swl + (unsigned long )swl_idx)->d_id.b24;
#line 3745
      __len = 8UL;
#line 3745
      if (__len > 63UL) {
#line 3745
        __ret = __memcpy((void *)(& new_fcport->node_name), (void const   *)(& (swl + (unsigned long )swl_idx)->node_name),
                         __len);
      } else {
#line 3745
        __ret = __builtin_memcpy((void *)(& new_fcport->node_name), (void const   *)(& (swl + (unsigned long )swl_idx)->node_name),
                                 __len);
      }
#line 3747
      __len___0 = 8UL;
#line 3747
      if (__len___0 > 63UL) {
#line 3747
        __ret___0 = __memcpy((void *)(& new_fcport->port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->port_name),
                             __len___0);
      } else {
#line 3747
        __ret___0 = __builtin_memcpy((void *)(& new_fcport->port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->port_name),
                                     __len___0);
      }
#line 3749
      __len___1 = 8UL;
#line 3749
      if (__len___1 > 63UL) {
#line 3749
        __ret___1 = __memcpy((void *)(& new_fcport->fabric_port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->fabric_port_name),
                             __len___1);
      } else {
#line 3749
        __ret___1 = __builtin_memcpy((void *)(& new_fcport->fabric_port_name), (void const   *)(& (swl + (unsigned long )swl_idx)->fabric_port_name),
                                     __len___1);
      }
#line 3751
      new_fcport->fp_speed = (swl + (unsigned long )swl_idx)->fp_speed;
#line 3752
      new_fcport->fc4_type = (swl + (unsigned long )swl_idx)->fc4_type;
#line 3754
      if ((unsigned int )(swl + (unsigned long )swl_idx)->d_id.b.rsvd_1 != 0U) {
#line 3755
        last_dev = 1;
      } else {

      }
#line 3757
      swl_idx = swl_idx + 1;
    }
  } else {
#line 3761
    rval = qla2x00_ga_nxt(vha, new_fcport);
#line 3762
    if (rval != 0) {
#line 3763
      ql_log(1U, vha, 8292, "SNS scan failed -- assuming zero-entry result.\n");
#line 3766
      __mptr = (struct list_head  const  *)new_fcports->next;
#line 3766
      fcport = (fc_port_t *)__mptr;
#line 3766
      __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 3766
      fcptemp = (fc_port_t *)__mptr___0;
#line 3766
      goto ldv_61465;
      ldv_61464: 
#line 3768
      list_del(& fcport->list);
#line 3769
      kfree((void const   *)fcport);
#line 3766
      fcport = fcptemp;
#line 3766
      __mptr___1 = (struct list_head  const  *)fcptemp->list.next;
#line 3766
      fcptemp = (fc_port_t *)__mptr___1;
      ldv_61465: ;
#line 3766
      if ((unsigned long )(& fcport->list) != (unsigned long )new_fcports) {
#line 3768
        goto ldv_61464;
      } else {

      }
#line 3771
      rval = 0;
#line 3772
      goto ldv_61448;
    } else {

    }
  }
#line 3777
  if (first_dev != 0) {
#line 3778
    wrap.b24 = new_fcport->d_id.b24;
#line 3779
    first_dev = 0;
  } else
#line 3780
  if (new_fcport->d_id.b24 == wrap.b24) {
#line 3781
    ql_dbg(268435456U, vha, 8293, "Device wrap (%02x%02x%02x).\n", (int )new_fcport->d_id.b.domain,
           (int )new_fcport->d_id.b.area, (int )new_fcport->d_id.b.al_pa);
#line 3786
    goto ldv_61448;
  } else {

  }
#line 3790
  if (new_fcport->d_id.b24 == base_vha->d_id.b24) {
#line 3791
    goto ldv_61447;
  } else {

  }
#line 3794
  tmp___9 = qla2x00_is_a_vp_did(vha, new_fcport->d_id.b24);
#line 3794
  if (tmp___9 != 0) {
#line 3795
    goto ldv_61447;
  } else {

  }
#line 3798
  if ((((int )new_fcport->d_id.b24 ^ (int )vha->d_id.b24) & 16776960) == 0 && (unsigned int )ha->current_topology == 4U) {
#line 3801
    goto ldv_61447;
  } else {

  }
#line 3804
  if (((int )new_fcport->d_id.b.domain & 240) == 240) {
#line 3805
    goto ldv_61447;
  } else {

  }
#line 3808
  if (ql2xgffidenable != 0 && ((unsigned int )new_fcport->fc4_type != 8U && (unsigned int )new_fcport->fc4_type != 255U)) {
#line 3811
    goto ldv_61447;
  } else {

  }
#line 3814
  found = 0;
#line 3815
  __mptr___2 = (struct list_head  const  *)vha->vp_fcports.next;
#line 3815
  fcport = (fc_port_t *)__mptr___2;
#line 3815
  goto ldv_61477;
  ldv_61476: 
#line 3816
  tmp___10 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                    8UL);
#line 3816
  if (tmp___10 != 0) {
#line 3818
    goto ldv_61471;
  } else {

  }
#line 3820
  fcport->scan_state = 2U;
#line 3822
  found = found + 1;
#line 3825
  __len___2 = 8UL;
#line 3825
  if (__len___2 > 63UL) {
#line 3825
    __ret___2 = __memcpy((void *)(& fcport->fabric_port_name), (void const   *)(& new_fcport->fabric_port_name),
                         __len___2);
  } else {
#line 3825
    __ret___2 = __builtin_memcpy((void *)(& fcport->fabric_port_name), (void const   *)(& new_fcport->fabric_port_name),
                                 __len___2);
  }
#line 3827
  fcport->fp_speed = new_fcport->fp_speed;
#line 3833
  if (fcport->d_id.b24 == new_fcport->d_id.b24) {
#line 3833
    tmp___11 = atomic_read((atomic_t const   *)(& fcport->state));
#line 3833
    if (tmp___11 == 4) {
#line 3835
      goto ldv_61475;
    } else {

    }
  } else {

  }
#line 3841
  if ((fcport->flags & 1U) == 0U) {
#line 3842
    fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3843
    qla2x00_clear_loop_id(fcport);
#line 3844
    fcport->flags = fcport->flags | 3U;
#line 3846
    goto ldv_61475;
  } else {

  }
#line 3854
  fcport->d_id.b24 = new_fcport->d_id.b24;
#line 3855
  fcport->flags = fcport->flags | 2U;
#line 3856
  if (((((unsigned int )fcport->loop_id != 4096U && (fcport->flags & 4U) == 0U) && (fcport->flags & 8U) == 0U) && (unsigned int )fcport->port_type != 4U) && (unsigned int )fcport->port_type != 3U) {
#line 3861
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3864
    qla2x00_clear_loop_id(fcport);
  } else {

  }
#line 3867
  goto ldv_61475;
  ldv_61471: 
#line 3815
  __mptr___3 = (struct list_head  const  *)fcport->list.next;
#line 3815
  fcport = (fc_port_t *)__mptr___3;
  ldv_61477: ;
#line 3815
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 3817
    goto ldv_61476;
  } else {

  }
  ldv_61475: ;
#line 3870
  if (found != 0) {
#line 3871
    goto ldv_61447;
  } else {

  }
#line 3873
  list_add_tail(& new_fcport->list, new_fcports);
#line 3876
  nxt_d_id.b24 = new_fcport->d_id.b24;
#line 3877
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 3878
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 3879
    ql_log(1U, vha, 8294, "Memory allocation failed for fcport.\n");
#line 3881
    return (259);
  } else {

  }
#line 3883
  new_fcport->flags = new_fcport->flags | 3U;
#line 3884
  new_fcport->d_id.b24 = nxt_d_id.b24;
  ldv_61447: 
#line 3727
  loop_id = (uint16_t )((int )loop_id + 1);
  ldv_61479: ;
#line 3727
  if ((int )ha->max_loop_id >= (int )loop_id) {
#line 3729
    goto ldv_61478;
  } else {

  }
  ldv_61448: 
#line 3887
  kfree((void const   *)new_fcport);
#line 3889
  return (rval);
}
}
#line 3907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_find_new_loop_id(scsi_qla_host_t *vha , fc_port_t *dev ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 3910
  ha = vha->hw;
#line 3911
  flags = 0UL;
#line 3913
  rval = 0;
#line 3915
  tmp = spinlock_check(& ha->vport_slock);
#line 3915
  flags = _raw_spin_lock_irqsave(tmp);
#line 3917
  tmp___0 = find_first_zero_bit((unsigned long const   *)ha->loop_id_map, (unsigned long )ha->max_fibre_devices);
#line 3917
  dev->loop_id = (uint16_t )tmp___0;
#line 3919
  if ((int )dev->loop_id >= (int )ha->max_fibre_devices) {
#line 3921
    dev->loop_id = 4096U;
#line 3922
    rval = 258;
  } else {
#line 3919
    tmp___1 = qla2x00_is_reserved_id(vha, (int )dev->loop_id);
#line 3919
    if (tmp___1 != 0) {
#line 3921
      dev->loop_id = 4096U;
#line 3922
      rval = 258;
    } else {
#line 3924
      set_bit((long )dev->loop_id, (unsigned long volatile   *)ha->loop_id_map);
    }
  }
#line 3926
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 3928
  if (rval == 0) {
#line 3929
    ql_dbg(268435456U, dev->vha, 8326, "Assigning new loopid=%x, portid=%x.\n", (int )dev->loop_id,
           (int )dev->d_id.b24);
  } else {
#line 3933
    ql_log(1U, dev->vha, 8327, "No loop_id\'s available, portid=%x.\n", (int )dev->d_id.b24);
  }
#line 3937
  return (rval);
}
}
#line 3957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_fabric_dev_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) 
{ 
  int rval ;
  int retry ;
  uint8_t opts ;
  struct qla_hw_data *ha ;

  {
#line 3963
  ha = vha->hw;
#line 3965
  rval = 0;
#line 3966
  retry = 0;
#line 3968
  if ((((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) || (ha->device_type & 134217728U) != 0U) {
#line 3969
    if ((fcport->flags & 8U) != 0U) {
#line 3970
      return (rval);
    } else {

    }
#line 3971
    fcport->flags = fcport->flags | 8U;
#line 3972
    rval = qla2x00_post_async_login_work(vha, fcport, (uint16_t *)0U);
#line 3973
    if (rval == 0) {
#line 3974
      return (rval);
    } else {

    }
  } else {

  }
#line 3977
  fcport->flags = fcport->flags & 4294967287U;
#line 3978
  rval = qla2x00_fabric_login(vha, fcport, next_loopid);
#line 3979
  if (rval == 0) {
#line 3981
    opts = 0U;
#line 3982
    if ((fcport->flags & 4U) != 0U) {
#line 3983
      opts = (uint8_t )((unsigned int )opts | 2U);
    } else {

    }
#line 3984
    rval = qla2x00_get_port_database(vha, fcport, (int )opts);
#line 3985
    if (rval != 0) {
#line 3986
      (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                        (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 3989
      qla2x00_mark_device_lost(vha, fcport, 1, 0);
    } else {
#line 3991
      qla2x00_update_fcport(vha, fcport);
    }
  } else {
#line 3995
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
  }
#line 3998
  return (rval);
}
}
#line 4016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_fabric_login(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *next_loopid ) 
{ 
  int rval ;
  int retry ;
  uint16_t tmp_loopid ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;

  {
#line 4023
  ha = vha->hw;
#line 4025
  retry = 0;
#line 4026
  tmp_loopid = 0U;
  ldv_61510: 
#line 4029
  ql_dbg(268435456U, vha, 8192, "Trying Fabric Login w/loop id 0x%04x for port %02x%02x%02x.\n",
         (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa);
#line 4036
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                          (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
                                          (uint16_t *)(& mb), 1);
#line 4039
  if (rval != 0) {
#line 4040
    return (rval);
  } else {

  }
#line 4042
  if ((unsigned int )mb[0] == 16391U) {
#line 4050
    retry = retry + 1;
#line 4051
    tmp_loopid = fcport->loop_id;
#line 4052
    fcport->loop_id = mb[1];
#line 4054
    ql_dbg(268435456U, vha, 8193, "Fabric Login: port in use - next loop id=0x%04x, port id= %02x%02x%02x.\n",
           (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa);
  } else
#line 4060
  if ((unsigned int )mb[0] == 16384U) {
#line 4064
    if (retry != 0) {
#line 4066
      *next_loopid = tmp_loopid;
    } else {
#line 4072
      *next_loopid = (unsigned int )fcport->loop_id + 1U;
    }
#line 4075
    if ((int )mb[1] & 1) {
#line 4076
      fcport->port_type = 4;
    } else {
#line 4078
      fcport->port_type = 5;
#line 4079
      if (((int )mb[1] & 2) != 0) {
#line 4080
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    }
#line 4084
    if ((int )mb[10] & 1) {
#line 4085
      fcport->supported_classes = fcport->supported_classes | 4U;
    } else {

    }
#line 4086
    if (((int )mb[10] & 2) != 0) {
#line 4087
      fcport->supported_classes = fcport->supported_classes | 8U;
    } else {

    }
#line 4089
    if ((ha->device_type & 134217728U) != 0U) {
#line 4090
      if (((int )mb[10] & 128) != 0) {
#line 4091
        fcport->flags = fcport->flags | 16U;
      } else {

      }
    } else {

    }
#line 4095
    rval = 0;
#line 4096
    goto ldv_61509;
  } else
#line 4097
  if ((unsigned int )mb[0] == 16392U) {
#line 4101
    fcport->loop_id = (uint16_t )((int )fcport->loop_id + 1);
#line 4102
    rval = qla2x00_find_new_loop_id(vha, fcport);
#line 4103
    if (rval != 0) {
#line 4105
      goto ldv_61509;
    } else {

    }
  } else
#line 4107
  if ((unsigned int )mb[0] == 16389U) {
#line 4113
    *next_loopid = fcport->loop_id;
#line 4114
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 4117
    qla2x00_mark_device_lost(vha, fcport, 1, 0);
#line 4119
    rval = 1;
#line 4120
    goto ldv_61509;
  } else {
#line 4125
    ql_dbg(268435456U, vha, 8194, "Failed=%x port_id=%02x%02x%02x loop_id=%x jiffies=%lx.\n",
           (int )mb[0], (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
           (int )fcport->loop_id, jiffies);
#line 4131
    *next_loopid = fcport->loop_id;
#line 4132
    (*((ha->isp_ops)->fabric_logout))(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                                      (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 4135
    qla2x00_clear_loop_id(fcport);
#line 4136
    fcport->login_retry = 0;
#line 4138
    rval = 3;
#line 4139
    goto ldv_61509;
  }
#line 4141
  goto ldv_61510;
  ldv_61509: ;
#line 4143
  return (rval);
}
}
#line 4160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_local_device_login(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  uint16_t mb[32U] ;

  {
#line 4165
  memset((void *)(& mb), 0, 64UL);
#line 4166
  rval = qla2x00_login_local_device(vha, fcport, (uint16_t *)(& mb), 1);
#line 4167
  if (rval == 0) {
#line 4169
    if ((unsigned int )mb[0] == 16389U) {
#line 4170
      rval = 1;
    } else
#line 4171
    if ((unsigned int )mb[0] == 16390U) {
#line 4173
      rval = 3;
    } else {

    }
  } else {

  }
#line 4176
  return (rval);
}
}
#line 4190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_loop_resync(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t wait_time ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4192
  rval = 0;
#line 4197
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 4198
    req = *((vha->hw)->req_q_map);
  } else {
#line 4200
    req = vha->req;
  }
#line 4201
  rsp = req->rsp;
#line 4203
  clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4204
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4205
    rval = qla2x00_fw_ready(vha);
#line 4205
    if (rval == 0) {
#line 4207
      wait_time = 256U;
      ldv_61524: ;
#line 4209
      if (((vha->hw)->device_type & 131072U) == 0U) {
#line 4214
        qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 4216
        vha->marker_needed = 0U;
      } else {

      }
#line 4220
      clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4222
      if (((vha->hw)->device_type & 131072U) != 0U) {
#line 4223
        qlafx00_configure_devices(vha);
      } else {
#line 4225
        qla2x00_configure_loop(vha);
      }
#line 4227
      wait_time = wait_time - 1U;
#line 4231
      tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4231
      if (tmp == 0) {
#line 4231
        tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4231
        if (tmp___0 == 0) {
#line 4231
          if (wait_time != 0U) {
#line 4231
            tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4231
            if (tmp___1 != 0) {
#line 4232
              goto ldv_61524;
            } else {
#line 4235
              goto ldv_61525;
            }
          } else {
#line 4235
            goto ldv_61525;
          }
        } else {
#line 4235
          goto ldv_61525;
        }
      } else {

      }
      ldv_61525: ;
    } else {

    }
  } else {

  }
#line 4235
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4235
  if (tmp___2 != 0) {
#line 4236
    return (258);
  } else {

  }
#line 4238
  if (rval != 0) {
#line 4239
    ql_dbg(268435456U, vha, 8300, "%s *** FAILED ***.\n", "qla2x00_loop_resync");
  } else {

  }
#line 4242
  return (rval);
}
}
#line 4253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_perform_loop_resync(scsi_qla_host_t *ha ) 
{ 
  int32_t rval ;
  int tmp ;

  {
#line 4255
  rval = 0;
#line 4257
  tmp = test_and_set_bit(5L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4257
  if (tmp == 0) {
#line 4259
    atomic_set(& ha->loop_down_timer, 0);
#line 4260
    if ((ha->device_flags & 2U) == 0U) {
#line 4261
      atomic_set(& ha->loop_state, 3);
#line 4262
      set_bit(6L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4263
      set_bit(9L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4264
      set_bit(4L, (unsigned long volatile   *)(& ha->dpc_flags));
#line 4266
      rval = qla2x00_loop_resync(ha);
    } else {
#line 4268
      atomic_set(& ha->loop_state, 6);
    }
#line 4270
    clear_bit(5L, (unsigned long volatile   *)(& ha->dpc_flags));
  } else {

  }
#line 4273
  return (rval);
}
}
#line 4277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_update_fcports(scsi_qla_host_t *base_vha ) 
{ 
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 4281
  ha = base_vha->hw;
#line 4284
  tmp = spinlock_check(& ha->vport_slock);
#line 4284
  flags = _raw_spin_lock_irqsave(tmp);
#line 4286
  __mptr = (struct list_head  const  *)(base_vha->hw)->vp_list.next;
#line 4286
  vha = (struct scsi_qla_host *)__mptr;
#line 4286
  goto ldv_61556;
  ldv_61555: 
#line 4287
  atomic_inc(& vha->vref_count);
#line 4288
  __mptr___0 = (struct list_head  const  *)vha->vp_fcports.next;
#line 4288
  fcport = (fc_port_t *)__mptr___0;
#line 4288
  goto ldv_61553;
  ldv_61552: ;
#line 4289
  if ((unsigned long )fcport->drport != (unsigned long )((struct fc_rport *)0)) {
#line 4289
    tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 4289
    if (tmp___1 != 1) {
#line 4291
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4292
      qla2x00_rport_del((void *)fcport);
#line 4293
      tmp___0 = spinlock_check(& ha->vport_slock);
#line 4293
      flags = _raw_spin_lock_irqsave(tmp___0);
    } else {

    }
  } else {

  }
#line 4288
  __mptr___1 = (struct list_head  const  *)fcport->list.next;
#line 4288
  fcport = (fc_port_t *)__mptr___1;
  ldv_61553: ;
#line 4288
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 4290
    goto ldv_61552;
  } else {

  }
#line 4296
  atomic_dec(& vha->vref_count);
#line 4286
  __mptr___2 = (struct list_head  const  *)vha->list.next;
#line 4286
  vha = (struct scsi_qla_host *)__mptr___2;
  ldv_61556: ;
#line 4286
  if ((unsigned long )(& vha->list) != (unsigned long )(& (base_vha->hw)->vp_list)) {
#line 4288
    goto ldv_61555;
  } else {

  }
#line 4298
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4299
  return;
}
}
#line 4303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla83xx_reset_ownership(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t drv_presence ;
  uint32_t drv_presence_mask ;
  uint32_t dev_part_info1 ;
  uint32_t dev_part_info2 ;
  uint32_t class_type ;
  uint32_t class_type_mask ;
  uint16_t fcoe_other_function ;
  uint16_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4305
  ha = vha->hw;
#line 4308
  class_type_mask = 3U;
#line 4309
  fcoe_other_function = 65535U;
#line 4311
  if ((ha->device_type & 262144U) != 0U) {
#line 4312
    tmp = qla8044_rd_direct(vha, 3U);
#line 4312
    drv_presence = (uint32_t )tmp;
#line 4314
    tmp___0 = qla8044_rd_direct(vha, 7U);
#line 4314
    dev_part_info1 = (uint32_t )tmp___0;
#line 4316
    tmp___1 = qla8044_rd_direct(vha, 14308U);
#line 4316
    dev_part_info2 = (uint32_t )tmp___1;
  } else {
#line 4319
    qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4320
    qla83xx_rd_reg(vha, 571483104U, & dev_part_info1);
#line 4321
    qla83xx_rd_reg(vha, 571483108U, & dev_part_info2);
  }
#line 4323
  i = 0U;
#line 4323
  goto ldv_61572;
  ldv_61571: 
#line 4324
  class_type = (dev_part_info1 >> (int )i * 4) & class_type_mask;
#line 4325
  if (class_type == 2U && (int )ha->portnum != (int )i) {
#line 4327
    fcoe_other_function = i;
#line 4328
    goto ldv_61570;
  } else {

  }
#line 4323
  i = (uint16_t )((int )i + 1);
  ldv_61572: ;
#line 4323
  if ((unsigned int )i <= 7U) {
#line 4325
    goto ldv_61571;
  } else {

  }
  ldv_61570: ;
#line 4331
  if ((unsigned int )fcoe_other_function == 65535U) {
#line 4332
    i = 0U;
#line 4332
    goto ldv_61575;
    ldv_61574: 
#line 4333
    class_type = (dev_part_info2 >> (int )i * 4) & class_type_mask;
#line 4335
    if (class_type == 2U && (int )i + 8 != (int )ha->portnum) {
#line 4337
      fcoe_other_function = (unsigned int )i + 8U;
#line 4338
      goto ldv_61573;
    } else {

    }
#line 4332
    i = (uint16_t )((int )i + 1);
    ldv_61575: ;
#line 4332
    if ((unsigned int )i <= 7U) {
#line 4334
      goto ldv_61574;
    } else {

    }
    ldv_61573: ;
  } else {

  }
#line 4346
  drv_presence_mask = (uint32_t )(~ ((1 << (int )ha->portnum) | ((unsigned int )fcoe_other_function != 65535U ? 1 << (int )fcoe_other_function : 0)));
#line 4353
  if ((drv_presence & drv_presence_mask) == 0U && (int )ha->portnum < (int )fcoe_other_function) {
#line 4355
    ql_dbg(524288U, vha, 45183, "This host is Reset owner.\n");
#line 4357
    ha->flags.nic_core_reset_owner = 1U;
  } else {

  }
#line 4359
  return;
}
}
#line 4362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int __qla83xx_set_drv_ack(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;

  {
#line 4364
  rval = 0;
#line 4365
  ha = vha->hw;
#line 4368
  rval = qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4369
  if (rval == 0) {
#line 4370
    drv_ack = (uint32_t )(1 << (int )ha->portnum) | drv_ack;
#line 4371
    rval = qla83xx_wr_reg(vha, 571483020U, drv_ack);
  } else {

  }
#line 4374
  return (rval);
}
}
#line 4378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int __qla83xx_clear_drv_ack(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t drv_ack ;

  {
#line 4380
  rval = 0;
#line 4381
  ha = vha->hw;
#line 4384
  rval = qla83xx_rd_reg(vha, 571483020U, & drv_ack);
#line 4385
  if (rval == 0) {
#line 4386
    drv_ack = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_ack;
#line 4387
    rval = qla83xx_wr_reg(vha, 571483020U, drv_ack);
  } else {

  }
#line 4390
  return (rval);
}
}
#line 4394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static char const   *qla83xx_dev_state_to_string(uint32_t dev_state ) 
{ 


  {
#line 4396
  switch (dev_state) {
  case 1U: ;
#line 4398
  return ("COLD/RE-INIT");
  case 2U: ;
#line 4400
  return ("INITIALIZING");
  case 3U: ;
#line 4402
  return ("READY");
  case 4U: ;
#line 4404
  return ("NEED RESET");
  case 5U: ;
#line 4406
  return ("NEED QUIESCENT");
  case 6U: ;
#line 4408
  return ("FAILED");
  case 7U: ;
#line 4410
  return ("QUIESCENT");
  default: ;
#line 4412
  return ("Unknown");
  }
}
}
#line 4418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla83xx_idc_audit(scsi_qla_host_t *vha , int audit_type ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t idc_audit_reg ;
  uint32_t duration_secs ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 4420
  ha = vha->hw;
#line 4421
  idc_audit_reg = 0U;
#line 4421
  duration_secs = 0U;
#line 4423
  switch (audit_type) {
  case 0: 
#line 4425
  tmp = jiffies_to_msecs(jiffies);
#line 4425
  ha->idc_audit_ts = tmp / 1000U;
#line 4426
  idc_audit_reg = (uint32_t )ha->portnum | (ha->idc_audit_ts << 8);
#line 4428
  qla83xx_wr_reg(vha, 571483028U, idc_audit_reg);
#line 4429
  goto ldv_61607;
  case 1: 
#line 4432
  tmp___0 = jiffies_to_msecs(jiffies);
#line 4432
  tmp___1 = jiffies_to_msecs((unsigned long const   )ha->idc_audit_ts);
#line 4432
  duration_secs = (tmp___0 - tmp___1) / 1000U;
#line 4434
  idc_audit_reg = ((unsigned int )ha->portnum | 128U) | (duration_secs << 8);
#line 4436
  qla83xx_wr_reg(vha, 571483028U, idc_audit_reg);
#line 4437
  goto ldv_61607;
  default: 
#line 4440
  ql_log(1U, vha, 45176, "Invalid audit type specified.\n");
#line 4442
  goto ldv_61607;
  }
  ldv_61607: ;
#line 4445
  return;
}
}
#line 4448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla83xx_initiating_reset(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t idc_control ;
  uint32_t dev_state ;
  char const   *state ;
  char const   *tmp ;

  {
#line 4450
  ha = vha->hw;
#line 4453
  __qla83xx_get_idc_control(vha, & idc_control);
#line 4454
  if ((int )idc_control & 1) {
#line 4455
    ql_log(2U, vha, 45184, "NIC Core reset has been disabled. idc-control=0x%x\n",
           idc_control);
#line 4458
    return (258);
  } else {

  }
#line 4462
  qla83xx_rd_reg(vha, 571483012U, & dev_state);
#line 4463
  if (*((unsigned long *)ha + 2UL) != 0UL && dev_state == 3U) {
#line 4464
    qla83xx_wr_reg(vha, 571483012U, 4U);
#line 4466
    ql_log(2U, vha, 45142, "HW State: NEED RESET.\n");
#line 4467
    qla83xx_idc_audit(vha, 0);
  } else {
#line 4469
    tmp = qla83xx_dev_state_to_string(dev_state);
#line 4469
    state = tmp;
#line 4470
    ql_log(2U, vha, 45143, "HW State: %s.\n", state);
#line 4474
    goto ldv_61618;
    ldv_61617: 
#line 4475
    qla83xx_idc_unlock(vha, 0);
#line 4476
    msleep(200U);
#line 4477
    qla83xx_idc_lock(vha, 0);
#line 4478
    qla83xx_rd_reg(vha, 571483012U, & dev_state);
    ldv_61618: ;
#line 4474
    if (dev_state == 3U) {
#line 4476
      goto ldv_61617;
    } else {

    }

  }
#line 4483
  __qla83xx_set_drv_ack(vha);
#line 4485
  return (0);
}
}
#line 4489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int __qla83xx_set_idc_control(scsi_qla_host_t *vha , uint32_t idc_control ) 
{ 
  int tmp ;

  {
#line 4491
  tmp = qla83xx_wr_reg(vha, 571483024U, idc_control);
#line 4491
  return (tmp);
}
}
#line 4495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int __qla83xx_get_idc_control(scsi_qla_host_t *vha , uint32_t *idc_control ) 
{ 
  int tmp ;

  {
#line 4497
  tmp = qla83xx_rd_reg(vha, 571483024U, idc_control);
#line 4497
  return (tmp);
}
}
#line 4501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla83xx_check_driver_presence(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_presence ;
  struct qla_hw_data *ha ;

  {
#line 4503
  drv_presence = 0U;
#line 4504
  ha = vha->hw;
#line 4506
  qla83xx_rd_reg(vha, 571483016U, & drv_presence);
#line 4507
  if (((uint32_t )(1 << (int )ha->portnum) & drv_presence) != 0U) {
#line 4508
    return (0);
  } else {
#line 4510
    return (3);
  }
}
}
#line 4514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla83xx_nic_core_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 4516
  rval = 0;
#line 4517
  ha = vha->hw;
#line 4519
  ql_dbg(524288U, vha, 45144, "Entered  %s().\n", "qla83xx_nic_core_reset");
#line 4522
  if ((vha->device_flags & 32U) != 0U) {
#line 4523
    ql_log(1U, vha, 45145, "Device in unrecoverable FAILED state.\n");
#line 4525
    return (258);
  } else {

  }
#line 4528
  qla83xx_idc_lock(vha, 0);
#line 4530
  tmp = qla83xx_check_driver_presence(vha);
#line 4530
  if (tmp != 0) {
#line 4531
    ql_log(1U, vha, 45146, "Function=0x%x has been removed from IDC participation.\n",
           (int )ha->portnum);
#line 4534
    rval = 258;
#line 4535
    goto exit;
  } else {

  }
#line 4538
  qla83xx_reset_ownership(vha);
#line 4540
  rval = qla83xx_initiating_reset(vha);
#line 4546
  if (rval == 0) {
#line 4547
    rval = qla83xx_idc_state_handler(vha);
#line 4549
    if (rval == 0) {
#line 4550
      ha->flags.nic_core_hung = 0U;
    } else {

    }
#line 4551
    __qla83xx_clear_drv_ack(vha);
  } else {

  }
  exit: 
#line 4555
  qla83xx_idc_unlock(vha, 0);
#line 4557
  ql_dbg(524288U, vha, 45147, "Exiting %s.\n", "qla83xx_nic_core_reset");
#line 4559
  return (rval);
}
}
#line 4563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2xxx_mctp_dump(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 4565
  ha = vha->hw;
#line 4566
  rval = 258;
#line 4568
  if ((ha->device_type & 32768U) == 0U || ((int )ha->fw_attributes_ext[0] & 1) == 0) {
#line 4570
    ql_log(2U, vha, 20589, "This board is not MCTP capable\n");
#line 4572
    return (rval);
  } else {

  }
#line 4575
  if ((unsigned long )ha->mctp_dump == (unsigned long )((void *)0)) {
#line 4576
    ha->mctp_dump = dma_alloc_attrs(& (ha->pdev)->dev, 548964UL, & ha->mctp_dump_dma,
                                    208U, (struct dma_attrs *)0);
#line 4579
    if ((unsigned long )ha->mctp_dump == (unsigned long )((void *)0)) {
#line 4580
      ql_log(1U, vha, 20590, "Failed to allocate memory for mctp dump\n");
#line 4582
      return (rval);
    } else {

    }
  } else {

  }
#line 4587
  rval = qla2x00_dump_mctp_data(vha, ha->mctp_dump_dma, 0U, 137241U);
#line 4589
  if (rval != 0) {
#line 4590
    ql_log(1U, vha, 20591, "Failed to capture mctp dump\n");
  } else {
#line 4593
    ql_log(2U, vha, 20592, "Mctp dump capture for host (%ld/%p).\n", vha->host_no,
           ha->mctp_dump);
#line 4596
    ha->mctp_dumped = 1;
  }
#line 4599
  if (*((unsigned long *)ha + 2UL) == 0UL && (unsigned int )ha->portnum == 0U) {
#line 4600
    ha->flags.nic_core_reset_hdlr_active = 1U;
#line 4601
    rval = qla83xx_restart_nic_firmware(vha);
#line 4602
    if (rval != 0) {
#line 4604
      ql_log(1U, vha, 20593, "Failed to restart nic firmware\n");
    } else {
#line 4607
      ql_dbg(524288U, vha, 45188, "Restarted NIC firmware successfully.\n");
    }
#line 4609
    ha->flags.nic_core_reset_hdlr_active = 0U;
  } else {

  }
#line 4612
  return (rval);
}
}
#line 4625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_quiesce_io(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 4627
  ha = vha->hw;
#line 4630
  ql_dbg(67108864U, vha, 16413, "Quiescing I/O - ha=%p.\n", ha);
#line 4633
  atomic_set(& ha->loop_down_timer, 255);
#line 4634
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 4634
  if (tmp___0 != 2) {
#line 4635
    atomic_set(& vha->loop_state, 2);
#line 4636
    qla2x00_mark_all_devices_lost(vha, 0);
#line 4637
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4637
    vp = (struct scsi_qla_host *)__mptr;
#line 4637
    goto ldv_61655;
    ldv_61654: 
#line 4638
    qla2x00_mark_all_devices_lost(vp, 0);
#line 4637
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4637
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_61655: ;
#line 4637
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4639
      goto ldv_61654;
    } else {

    }

  } else {
#line 4640
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4640
    if (tmp == 0) {
#line 4641
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 4645
  qla2x00_eh_wait_for_pending_commands(vha, 0U, 0U, 0);
#line 4646
  return;
}
}
#line 4649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_abort_isp_cleanup(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  unsigned long flags ;
  fc_port_t *fcport ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  raw_spinlock_t *tmp___3 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  raw_spinlock_t *tmp___4 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 4651
  ha = vha->hw;
#line 4659
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4660
    vha->flags.online = 0U;
  } else {

  }
#line 4661
  ha->flags.chip_reset_done = 0U;
#line 4662
  clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4663
  vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 4665
  ql_log(2U, vha, 175, "Performing ISP error recovery - ha=%p.\n", ha);
#line 4672
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4673
    (*((ha->isp_ops)->reset_chip))(vha);
  } else {

  }
#line 4675
  atomic_set(& vha->loop_down_timer, 255);
#line 4676
  tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 4676
  if (tmp___2 != 2) {
#line 4677
    atomic_set(& vha->loop_state, 2);
#line 4678
    qla2x00_mark_all_devices_lost(vha, 0);
#line 4680
    tmp = spinlock_check(& ha->vport_slock);
#line 4680
    flags = _raw_spin_lock_irqsave(tmp);
#line 4681
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4681
    vp = (struct scsi_qla_host *)__mptr;
#line 4681
    goto ldv_61675;
    ldv_61674: 
#line 4682
    atomic_inc(& vp->vref_count);
#line 4683
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4685
    qla2x00_mark_all_devices_lost(vp, 0);
#line 4687
    tmp___0 = spinlock_check(& ha->vport_slock);
#line 4687
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 4688
    atomic_dec(& vp->vref_count);
#line 4681
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4681
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_61675: ;
#line 4681
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4683
      goto ldv_61674;
    } else {

    }
#line 4690
    spin_unlock_irqrestore(& ha->vport_slock, flags);
  } else {
#line 4692
    tmp___1 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4692
    if (tmp___1 == 0) {
#line 4693
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 4698
  __mptr___1 = (struct list_head  const  *)vha->vp_fcports.next;
#line 4698
  fcport = (fc_port_t *)__mptr___1;
#line 4698
  goto ldv_61682;
  ldv_61681: 
#line 4699
  fcport->flags = fcport->flags & 4294967285U;
#line 4698
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 4698
  fcport = (fc_port_t *)__mptr___2;
  ldv_61682: ;
#line 4698
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 4700
    goto ldv_61681;
  } else {

  }
#line 4700
  tmp___3 = spinlock_check(& ha->vport_slock);
#line 4700
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 4701
  __mptr___3 = (struct list_head  const  *)ha->vp_list.next;
#line 4701
  vp = (struct scsi_qla_host *)__mptr___3;
#line 4701
  goto ldv_61702;
  ldv_61701: 
#line 4702
  atomic_inc(& vp->vref_count);
#line 4703
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4705
  __mptr___4 = (struct list_head  const  *)vp->vp_fcports.next;
#line 4705
  fcport = (fc_port_t *)__mptr___4;
#line 4705
  goto ldv_61696;
  ldv_61695: 
#line 4706
  fcport->flags = fcport->flags & 4294967285U;
#line 4705
  __mptr___5 = (struct list_head  const  *)fcport->list.next;
#line 4705
  fcport = (fc_port_t *)__mptr___5;
  ldv_61696: ;
#line 4705
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vp->vp_fcports)) {
#line 4707
    goto ldv_61695;
  } else {

  }
#line 4708
  tmp___4 = spinlock_check(& ha->vport_slock);
#line 4708
  flags = _raw_spin_lock_irqsave(tmp___4);
#line 4709
  atomic_dec(& vp->vref_count);
#line 4701
  __mptr___6 = (struct list_head  const  *)vp->list.next;
#line 4701
  vp = (struct scsi_qla_host *)__mptr___6;
  ldv_61702: ;
#line 4701
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4703
    goto ldv_61701;
  } else {

  }
#line 4711
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4713
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 4715
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 4716
      qla82xx_chip_reset_cleanup(vha);
#line 4717
      ql_log(2U, vha, 180, "Done chip reset cleanup.\n");
#line 4723
      vha->flags.online = 0U;
    } else {

    }
#line 4727
    qla2x00_abort_all_cmds(vha, 524288);
  } else {

  }
#line 4729
  return;
}
}
#line 4742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint8_t status ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vp ;
  struct req_que *req ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  raw_spinlock_t *tmp___6 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___7 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___8 ;

  {
#line 4745
  status = 0U;
#line 4746
  ha = vha->hw;
#line 4748
  req = *(ha->req_q_map);
#line 4751
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4752
    qla2x00_abort_isp_cleanup(vha);
#line 4754
    if ((ha->device_type & 65536U) != 0U) {
#line 4755
      ql_dbg(524288U, vha, 45148, "Clearing fcoe driver presence.\n");
#line 4757
      tmp = qla83xx_clear_drv_presence(vha);
#line 4757
      if (tmp != 0) {
#line 4758
        ql_dbg(524288U, vha, 45171, "Error while clearing DRV-Presence.\n");
      } else {

      }
    } else {

    }
#line 4762
    tmp___0 = pci_channel_offline(ha->pdev);
#line 4762
    tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 4762
    if (tmp___1 != 0L) {
#line 4762
      tmp___2 = ldv__builtin_expect(*((unsigned long *)ha + 2UL) != 0UL, 0L);
#line 4762
      if (tmp___2 != 0L) {
#line 4764
        clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4765
        status = 0U;
#line 4766
        return ((int )status);
      } else {

      }
    } else {

    }
#line 4769
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 4771
    (*((ha->isp_ops)->nvram_config))(vha);
#line 4773
    tmp___5 = qla2x00_restart_isp(vha);
#line 4773
    if (tmp___5 == 0) {
#line 4774
      clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4776
      tmp___3 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4776
      if (tmp___3 == 0) {
#line 4781
        vha->marker_needed = 1U;
      } else {

      }
#line 4784
      vha->flags.online = 1U;
#line 4786
      (*((ha->isp_ops)->enable_intrs))(ha);
#line 4788
      ha->isp_abort_cnt = 0U;
#line 4789
      clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4791
      if ((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 4792
        qla2x00_get_fw_version(vha);
      } else {

      }
#line 4793
      if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 4794
        ha->flags.fce_enabled = 1U;
#line 4795
        memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 4797
        rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                        (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 4800
        if (rval != 0) {
#line 4801
          ql_log(1U, vha, 32819, "Unable to reinitialize FCE (%d).\n", rval);
#line 4804
          ha->flags.fce_enabled = 0U;
        } else {

        }
      } else {

      }
#line 4808
      if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 4809
        memset(ha->eft, 0, 65536UL);
#line 4810
        rval = qla2x00_enable_eft_trace(vha, ha->eft_dma, 4);
#line 4812
        if (rval != 0) {
#line 4813
          ql_log(1U, vha, 32820, "Unable to reinitialize EFT (%d).\n", rval);
        } else {

        }
      } else {

      }
    } else {
#line 4819
      vha->flags.online = 1U;
#line 4820
      tmp___4 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4820
      if (tmp___4 != 0) {
#line 4821
        if (ha->isp_abort_cnt == 0U) {
#line 4822
          ql_log(0U, vha, 32821, "ISP error recover failed - board disabled.\n");
#line 4829
          (*((ha->isp_ops)->reset_adapter))(vha);
#line 4830
          vha->flags.online = 0U;
#line 4831
          clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4833
          status = 0U;
        } else {
#line 4835
          ha->isp_abort_cnt = ha->isp_abort_cnt - 1U;
#line 4836
          ql_dbg(4194304U, vha, 32800, "ISP abort - retry remaining %d.\n", ha->isp_abort_cnt);
#line 4839
          status = 1U;
        }
      } else {
#line 4842
        ha->isp_abort_cnt = 5U;
#line 4843
        ql_dbg(4194304U, vha, 32801, "ISP error recovery - retrying (%d) more times.\n",
               ha->isp_abort_cnt);
#line 4846
        set_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4847
        status = 1U;
      }
    }
  } else {

  }
#line 4853
  if ((unsigned int )status == 0U) {
#line 4854
    ql_dbg(4194304U, vha, 32802, "%s succeeded.\n", "qla2x00_abort_isp");
#line 4856
    tmp___6 = spinlock_check(& ha->vport_slock);
#line 4856
    flags = _raw_spin_lock_irqsave(tmp___6);
#line 4857
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 4857
    vp = (struct scsi_qla_host *)__mptr;
#line 4857
    goto ldv_61725;
    ldv_61724: ;
#line 4858
    if ((unsigned int )vp->vp_idx != 0U) {
#line 4859
      atomic_inc(& vp->vref_count);
#line 4860
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4862
      qla2x00_vp_abort_isp(vp);
#line 4864
      tmp___7 = spinlock_check(& ha->vport_slock);
#line 4864
      flags = _raw_spin_lock_irqsave(tmp___7);
#line 4865
      atomic_dec(& vp->vref_count);
    } else {

    }
#line 4857
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 4857
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_61725: ;
#line 4857
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 4859
      goto ldv_61724;
    } else {

    }
#line 4868
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 4870
    if ((ha->device_type & 65536U) != 0U) {
#line 4871
      ql_dbg(524288U, vha, 45149, "Setting back fcoe driver presence.\n");
#line 4873
      tmp___8 = qla83xx_set_drv_presence(vha);
#line 4873
      if (tmp___8 != 0) {
#line 4874
        ql_dbg(524288U, vha, 45172, "Error while setting DRV-Presence.\n");
      } else {

      }
    } else {

    }
  } else {
#line 4878
    ql_log(1U, vha, 32803, "%s **** FAILED ****.\n", "qla2x00_abort_isp");
  }
#line 4882
  return ((int )status);
}
}
#line 4896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla2x00_restart_isp(scsi_qla_host_t *vha ) 
{ 
  int status ;
  uint32_t wait_time ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4898
  status = 0;
#line 4900
  ha = vha->hw;
#line 4901
  req = *(ha->req_q_map);
#line 4902
  rsp = *(ha->rsp_q_map);
#line 4906
  tmp = qla2x00_isp_firmware(vha);
#line 4906
  if (tmp != 0) {
#line 4907
    vha->flags.online = 0U;
#line 4908
    status = (*((ha->isp_ops)->chip_diag))(vha);
#line 4909
    if (status == 0) {
#line 4910
      status = qla2x00_setup_chip(vha);
    } else {

    }
  } else {

  }
#line 4913
  if (status == 0) {
#line 4913
    status = qla2x00_init_rings(vha);
#line 4913
    if (status == 0) {
#line 4914
      clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4915
      ha->flags.chip_reset_done = 1U;
#line 4917
      qla25xx_init_queues(ha);
#line 4919
      status = qla2x00_fw_ready(vha);
#line 4920
      if (status == 0) {
#line 4921
        ql_dbg(4194304U, vha, 32817, "Start configure loop status = %d.\n", status);
#line 4925
        qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 4927
        vha->flags.online = 1U;
#line 4933
        tmp___0 = spinlock_check(& ha->hardware_lock);
#line 4933
        flags = _raw_spin_lock_irqsave(tmp___0);
#line 4934
        tmp___1 = qla_tgt_mode_enabled(vha);
#line 4934
        if ((int )tmp___1) {
#line 4935
          qlt_24xx_process_atio_queue(vha);
        } else {

        }
#line 4936
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4939
        wait_time = 256U;
        ldv_61739: 
#line 4941
        clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4942
        qla2x00_configure_loop(vha);
#line 4943
        wait_time = wait_time - 1U;
#line 4947
        tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 4947
        if (tmp___2 == 0) {
#line 4947
          tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4947
          if (tmp___3 == 0) {
#line 4947
            if (wait_time != 0U) {
#line 4947
              tmp___4 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 4947
              if (tmp___4 != 0) {
#line 4948
                goto ldv_61739;
              } else {
#line 4951
                goto ldv_61740;
              }
            } else {
#line 4951
              goto ldv_61740;
            }
          } else {
#line 4951
            goto ldv_61740;
          }
        } else {

        }
        ldv_61740: ;
      } else {

      }
#line 4951
      if ((vha->device_flags & 2U) != 0U) {
#line 4952
        status = 0;
      } else {

      }
#line 4954
      ql_dbg(4194304U, vha, 32818, "Configure loop done, status = 0x%x.\n", status);
    } else {

    }
  } else {

  }
#line 4957
  return (status);
}
}
#line 4961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla25xx_init_queues(struct qla_hw_data *ha ) 
{ 
  struct rsp_que *rsp ;
  struct req_que *req ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  int ret ;
  int i ;

  {
#line 4963
  rsp = (struct rsp_que *)0;
#line 4964
  req = (struct req_que *)0;
#line 4965
  tmp = pci_get_drvdata(ha->pdev);
#line 4965
  base_vha = (struct scsi_qla_host *)tmp;
#line 4966
  ret = -1;
#line 4969
  i = 1;
#line 4969
  goto ldv_61751;
  ldv_61750: 
#line 4970
  rsp = *(ha->rsp_q_map + (unsigned long )i);
#line 4971
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 4972
    rsp->options = (unsigned int )rsp->options & 65534U;
#line 4973
    ret = qla25xx_init_rsp_que(base_vha, rsp);
#line 4974
    if (ret != 0) {
#line 4975
      ql_dbg(1073741824U, base_vha, 255, "%s Rsp que: %d init failed.\n", "qla25xx_init_queues",
             (int )rsp->id);
    } else {
#line 4979
      ql_dbg(1073741824U, base_vha, 256, "%s Rsp que: %d inited.\n", "qla25xx_init_queues",
             (int )rsp->id);
    }
  } else {

  }
#line 4969
  i = i + 1;
  ldv_61751: ;
#line 4969
  if ((int )ha->max_rsp_queues > i) {
#line 4971
    goto ldv_61750;
  } else {

  }
#line 4984
  i = 1;
#line 4984
  goto ldv_61754;
  ldv_61753: 
#line 4985
  req = *(ha->req_q_map + (unsigned long )i);
#line 4986
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 4988
    req->options = (unsigned int )req->options & 65534U;
#line 4989
    ret = qla25xx_init_req_que(base_vha, req);
#line 4990
    if (ret != 0) {
#line 4991
      ql_dbg(1073741824U, base_vha, 257, "%s Req que: %d init failed.\n", "qla25xx_init_queues",
             (int )req->id);
    } else {
#line 4995
      ql_dbg(1073741824U, base_vha, 258, "%s Req que: %d inited.\n", "qla25xx_init_queues",
             (int )req->id);
    }
  } else {

  }
#line 4984
  i = i + 1;
  ldv_61754: ;
#line 4984
  if ((int )ha->max_req_queues > i) {
#line 4986
    goto ldv_61753;
  } else {

  }

#line 5000
  return (ret);
}
}
#line 5011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_reset_adapter(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 5013
  flags = 0UL;
#line 5014
  ha = vha->hw;
#line 5015
  reg = & (ha->iobase)->isp;
#line 5017
  vha->flags.online = 0U;
#line 5018
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 5020
  tmp = spinlock_check(& ha->hardware_lock);
#line 5020
  flags = _raw_spin_lock_irqsave(tmp);
#line 5021
  writew(4096, (void volatile   *)(& reg->hccr));
#line 5022
  readw((void const volatile   *)(& reg->hccr));
#line 5023
  writew(12288, (void volatile   *)(& reg->hccr));
#line 5024
  readw((void const volatile   *)(& reg->hccr));
#line 5025
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5026
  return;
}
}
#line 5029 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla24xx_reset_adapter(struct scsi_qla_host *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 5031
  flags = 0UL;
#line 5032
  ha = vha->hw;
#line 5033
  reg = & (ha->iobase)->isp24;
#line 5035
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 5036
    return;
  } else {

  }
#line 5038
  vha->flags.online = 0U;
#line 5039
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 5041
  tmp = spinlock_check(& ha->hardware_lock);
#line 5041
  flags = _raw_spin_lock_irqsave(tmp);
#line 5042
  writel(268435456U, (void volatile   *)(& reg->hccr));
#line 5043
  readl((void const volatile   *)(& reg->hccr));
#line 5044
  writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 5045
  readl((void const volatile   *)(& reg->hccr));
#line 5046
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5048
  if ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 5049
    (*((ha->isp_ops)->enable_intrs))(ha);
  } else {

  }
#line 5050
  return;
}
}
#line 5055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void qla24xx_nvram_wwn_from_ofw(scsi_qla_host_t *vha , struct nvram_24xx *nv ) 
{ 


  {
#line 5057
  return;
}
}
#line 5076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct init_cb_24xx *icb ;
  struct nvram_24xx *nv ;
  uint32_t *dptr ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  uint32_t chksum ;
  uint16_t cnt ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint16_t tmp___4 ;
  uint8_t *tmp___5 ;
  uint8_t *tmp___6 ;
  uint16_t tmp___7 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;

  {
#line 5085
  ha = vha->hw;
#line 5087
  rval = 0;
#line 5088
  icb = (struct init_cb_24xx *)ha->init_cb;
#line 5089
  nv = (struct nvram_24xx *)ha->nvram;
#line 5092
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5093
    ha->nvram_base = 128U;
#line 5094
    ha->vpd_base = 0U;
  } else {
#line 5096
    ha->nvram_base = 384U;
#line 5097
    ha->vpd_base = 256U;
  }
#line 5099
  ha->nvram_size = 512U;
#line 5100
  ha->vpd_size = 512U;
#line 5103
  ha->vpd = ha->nvram + 2048UL;
#line 5104
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->vpd, (uint32_t )((int )ha->nvram_base + -128),
                                 2048U);
#line 5108
  dptr = (uint32_t *)nv;
#line 5109
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)dptr, (uint32_t )ha->nvram_base,
                                 (uint32_t )ha->nvram_size);
#line 5111
  cnt = 0U;
#line 5111
  chksum = 0U;
#line 5111
  goto ldv_61791;
  ldv_61790: 
#line 5112
  tmp = dptr;
#line 5112
  dptr = dptr + 1;
#line 5112
  chksum = *tmp + chksum;
#line 5111
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61791: ;
#line 5111
  if ((int )ha->nvram_size >> 2 > (int )cnt) {
#line 5113
    goto ldv_61790;
  } else {

  }
#line 5114
  ql_dbg(1073872896U, vha, 106, "Contents of NVRAM\n");
#line 5116
  ql_dump_buffer(1073872896U, vha, 269, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 5120
  if (((((chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 5124
    ql_log(1U, vha, 107, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 5127
    ql_log(1U, vha, 108, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 5134
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 5135
    nv->nvram_version = 1U;
#line 5136
    nv->version = 1U;
#line 5137
    nv->frame_payload_size = 2048U;
#line 5138
    nv->execution_throttle = 65535U;
#line 5139
    nv->exchange_count = 0U;
#line 5140
    nv->hard_address = 124U;
#line 5141
    nv->port_name[0] = 33U;
#line 5142
    nv->port_name[1] = ha->port_no;
#line 5143
    nv->port_name[2] = 0U;
#line 5144
    nv->port_name[3] = 224U;
#line 5145
    nv->port_name[4] = 139U;
#line 5146
    nv->port_name[5] = 28U;
#line 5147
    nv->port_name[6] = 85U;
#line 5148
    nv->port_name[7] = 134U;
#line 5149
    nv->node_name[0] = 32U;
#line 5150
    nv->node_name[1] = 0U;
#line 5151
    nv->node_name[2] = 0U;
#line 5152
    nv->node_name[3] = 224U;
#line 5153
    nv->node_name[4] = 139U;
#line 5154
    nv->node_name[5] = 28U;
#line 5155
    nv->node_name[6] = 85U;
#line 5156
    nv->node_name[7] = 134U;
#line 5157
    qla24xx_nvram_wwn_from_ofw(vha, nv);
#line 5158
    nv->login_retry_count = 8U;
#line 5159
    nv->interrupt_delay_timer = 0U;
#line 5160
    nv->login_timeout = 0U;
#line 5161
    nv->firmware_options_1 = 24582U;
#line 5163
    nv->firmware_options_2 = 32U;
#line 5164
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 5165
    nv->firmware_options_3 = 16384U;
#line 5166
    nv->host_p = 3072U;
#line 5167
    nv->efi_parameters = 0U;
#line 5168
    nv->reset_delay = 5U;
#line 5169
    nv->max_luns_per_target = 128U;
#line 5170
    nv->port_down_retry_count = 30U;
#line 5171
    nv->link_down_timeout = 30U;
#line 5173
    rval = 1;
  } else {

  }
#line 5176
  tmp___0 = qla_ini_mode_enabled(vha);
#line 5176
  if (tmp___0) {
#line 5176
    tmp___1 = 0;
  } else {
#line 5176
    tmp___1 = 1;
  }
#line 5176
  if (tmp___1) {
#line 5178
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 5180
    nv->host_p = nv->host_p & 4294966271U;
  } else {

  }
#line 5183
  qlt_24xx_config_nvram_stage1(vha, nv);
#line 5186
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 5189
  dptr1 = (uint8_t *)icb;
#line 5190
  dptr2 = (uint8_t *)(& nv->version);
#line 5191
  cnt = 28U;
#line 5192
  goto ldv_61794;
  ldv_61793: 
#line 5193
  tmp___2 = dptr1;
#line 5193
  dptr1 = dptr1 + 1;
#line 5193
  tmp___3 = dptr2;
#line 5193
  dptr2 = dptr2 + 1;
#line 5193
  *tmp___2 = *tmp___3;
  ldv_61794: 
#line 5192
  tmp___4 = cnt;
#line 5192
  cnt = (uint16_t )((int )cnt - 1);
#line 5192
  if ((unsigned int )tmp___4 != 0U) {
#line 5194
    goto ldv_61793;
  } else {

  }
#line 5195
  icb->login_retry_count = nv->login_retry_count;
#line 5196
  icb->link_down_on_nos = nv->link_down_on_nos;
#line 5199
  dptr1 = (uint8_t *)(& icb->interrupt_delay_timer);
#line 5200
  dptr2 = (uint8_t *)(& nv->interrupt_delay_timer);
#line 5201
  cnt = 20U;
#line 5203
  goto ldv_61797;
  ldv_61796: 
#line 5204
  tmp___5 = dptr1;
#line 5204
  dptr1 = dptr1 + 1;
#line 5204
  tmp___6 = dptr2;
#line 5204
  dptr2 = dptr2 + 1;
#line 5204
  *tmp___5 = *tmp___6;
  ldv_61797: 
#line 5203
  tmp___7 = cnt;
#line 5203
  cnt = (uint16_t )((int )cnt - 1);
#line 5203
  if ((unsigned int )tmp___7 != 0U) {
#line 5205
    goto ldv_61796;
  } else {

  }
#line 5209
  qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_name), 16UL, (char *)"QLA2462");
#line 5212
  qlt_24xx_config_nvram_stage2(vha, icb);
#line 5214
  if ((nv->host_p & 32768U) != 0U) {
#line 5216
    __len = 8UL;
#line 5216
    if (__len > 63UL) {
#line 5216
      __ret = __memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                       __len);
    } else {
#line 5216
      __ret = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                               __len);
    }
#line 5217
    __len___0 = 8UL;
#line 5217
    if (__len___0 > 63UL) {
#line 5217
      __ret___0 = __memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                           __len___0);
    } else {
#line 5217
      __ret___0 = __builtin_memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                                   __len___0);
    }
  } else {

  }
#line 5221
  if ((icb->firmware_options_1 & 16384U) == 0U) {
#line 5226
    __len___1 = 8UL;
#line 5226
    if (__len___1 > 63UL) {
#line 5226
      __ret___1 = __memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                           __len___1);
    } else {
#line 5226
      __ret___1 = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                                   __len___1);
    }
#line 5227
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 5231
  ha->flags.disable_risc_code_load = 0U;
#line 5232
  ha->flags.enable_lip_reset = 0U;
#line 5233
  ha->flags.enable_lip_full_login = (nv->host_p & 1024U) != 0U;
#line 5235
  ha->flags.enable_target_reset = (nv->host_p & 2048U) != 0U;
#line 5237
  ha->flags.enable_led_scheme = 0U;
#line 5238
  ha->flags.disable_serdes = (nv->host_p & 32U) != 0U;
#line 5240
  ha->operating_mode = (uint8_t )((icb->firmware_options_2 & 112U) >> 4);
#line 5243
  __len___2 = 8UL;
#line 5243
  if (__len___2 > 63UL) {
#line 5243
    __ret___2 = __memcpy((void *)(& ha->fw_seriallink_options24), (void const   *)(& nv->seriallink_options),
                         __len___2);
  } else {
#line 5243
    __ret___2 = __builtin_memcpy((void *)(& ha->fw_seriallink_options24), (void const   *)(& nv->seriallink_options),
                                 __len___2);
  }
#line 5247
  ha->serial0 = icb->port_name[5];
#line 5248
  ha->serial1 = icb->port_name[6];
#line 5249
  ha->serial2 = icb->port_name[7];
#line 5250
  __len___3 = 8UL;
#line 5250
  if (__len___3 > 63UL) {
#line 5250
    __ret___3 = __memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                         __len___3);
  } else {
#line 5250
    __ret___3 = __builtin_memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                                 __len___3);
  }
#line 5251
  __len___4 = 8UL;
#line 5251
  if (__len___4 > 63UL) {
#line 5251
    __ret___4 = __memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                         __len___4);
  } else {
#line 5251
    __ret___4 = __builtin_memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                                 __len___4);
  }
#line 5253
  icb->execution_throttle = 65535U;
#line 5255
  ha->retry_count = (uint8_t )nv->login_retry_count;
#line 5258
  if ((int )nv->login_timeout < ql2xlogintimeout) {
#line 5259
    nv->login_timeout = (unsigned short )ql2xlogintimeout;
  } else {

  }
#line 5260
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 5261
    nv->login_timeout = 4U;
  } else {

  }
#line 5262
  ha->login_timeout = (uint8_t )nv->login_timeout;
#line 5263
  icb->login_timeout = nv->login_timeout;
#line 5266
  ha->r_a_tov = 100U;
#line 5268
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 5280
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 5281
    ha->loop_down_abort_time = 195U;
  } else {
#line 5284
    ha->link_down_timeout = (uint8_t )nv->link_down_timeout;
#line 5285
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 5290
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 5291
  if (qlport_down_retry != 0) {
#line 5292
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 5295
  ha->login_retry_count = (uint32_t )nv->login_retry_count;
#line 5296
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 5299
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 5300
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 5301
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 5302
  if (ql2xloginretrycount != 0) {
#line 5303
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 5306
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 5307
    ha->zio_mode = (unsigned int )((uint16_t )icb->firmware_options_2) & 15U;
#line 5309
    ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? icb->interrupt_delay_timer : 2U;
  } else {

  }
#line 5312
  icb->firmware_options_2 = icb->firmware_options_2 & 4294967280U;
#line 5314
  vha->flags.process_response_queue = 0U;
#line 5315
  if ((unsigned int )ha->zio_mode != 0U) {
#line 5316
    ha->zio_mode = 6U;
#line 5318
    ql_log(2U, vha, 111, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
           (int )ha->zio_timer * 100);
#line 5322
    icb->firmware_options_2 = icb->firmware_options_2 | (uint32_t )ha->zio_mode;
#line 5324
    icb->interrupt_delay_timer = ha->zio_timer;
#line 5325
    vha->flags.process_response_queue = 1U;
  } else {

  }
#line 5328
  if (rval != 0) {
#line 5329
    ql_log(1U, vha, 112, "NVRAM configuration failed.\n");
  } else {

  }
#line 5332
  return (rval);
}
}
#line 5336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla24xx_load_risc_flash(scsi_qla_host_t *vha , uint32_t *srisc_addr , uint32_t faddr ) 
{ 
  int rval ;
  int segments ;
  int fragment ;
  uint32_t *dcode ;
  uint32_t dlen ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t i ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 5339
  rval = 0;
#line 5345
  ha = vha->hw;
#line 5346
  req = *(ha->req_q_map);
#line 5348
  ql_dbg(1073741824U, vha, 139, "FW: Loading firmware from flash (%x).\n", faddr);
#line 5351
  rval = 0;
#line 5353
  segments = 2;
#line 5354
  dcode = (uint32_t *)req->ring;
#line 5355
  *srisc_addr = 0U;
#line 5358
  qla24xx_read_flash_data(vha, dcode, faddr + 4U, 4U);
#line 5359
  i = 0U;
#line 5359
  goto ldv_61833;
  ldv_61832: 
#line 5360
  tmp = __fswab32(*(dcode + (unsigned long )i));
#line 5360
  *(dcode + (unsigned long )i) = tmp;
#line 5359
  i = i + 1U;
  ldv_61833: ;
#line 5359
  if (i <= 3U) {
#line 5361
    goto ldv_61832;
  } else {

  }

#line 5361
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 5365
    ql_log(0U, vha, 140, "Unable to verify the integrity of flash firmware image.\n");
#line 5368
    ql_log(0U, vha, 141, "Firmware data: %08x %08x %08x %08x.\n", *dcode, *(dcode + 1UL),
           *(dcode + 2UL), *(dcode + 3UL));
#line 5372
    return (258);
  } else {

  }
#line 5375
  goto ldv_61842;
  ldv_61841: 
#line 5377
  qla24xx_read_flash_data(vha, dcode, faddr, 4U);
#line 5379
  tmp___0 = __fswab32(*(dcode + 2UL));
#line 5379
  risc_addr = tmp___0;
#line 5380
  *srisc_addr = *srisc_addr != 0U ? *srisc_addr : risc_addr;
#line 5381
  tmp___1 = __fswab32(*(dcode + 3UL));
#line 5381
  risc_size = tmp___1;
#line 5383
  fragment = 0;
#line 5384
  goto ldv_61840;
  ldv_61839: 
#line 5385
  dlen = ha->fw_transfer_size >> 2;
#line 5386
  if (dlen > risc_size) {
#line 5387
    dlen = risc_size;
  } else {

  }
#line 5389
  ql_dbg(1073741824U, vha, 142, "Loading risc segment@ risc addr %x number of dwords 0x%x offset 0x%x.\n",
         risc_addr, dlen, faddr);
#line 5394
  qla24xx_read_flash_data(vha, dcode, faddr, dlen);
#line 5395
  i = 0U;
#line 5395
  goto ldv_61836;
  ldv_61835: 
#line 5396
  tmp___2 = __fswab32(*(dcode + (unsigned long )i));
#line 5396
  *(dcode + (unsigned long )i) = tmp___2;
#line 5395
  i = i + 1U;
  ldv_61836: ;
#line 5395
  if (i < dlen) {
#line 5397
    goto ldv_61835;
  } else {

  }
#line 5398
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);
#line 5400
  if (rval != 0) {
#line 5401
    ql_log(0U, vha, 143, "Failed to load segment %d of firmware.\n", fragment);
#line 5404
    goto ldv_61838;
  } else {

  }
#line 5407
  faddr = faddr + dlen;
#line 5408
  risc_addr = risc_addr + dlen;
#line 5409
  risc_size = risc_size - dlen;
#line 5410
  fragment = fragment + 1;
  ldv_61840: ;
#line 5384
  if (risc_size != 0U && rval == 0) {
#line 5386
    goto ldv_61839;
  } else {

  }
  ldv_61838: 
#line 5414
  segments = segments - 1;
  ldv_61842: ;
#line 5375
  if (segments != 0 && rval == 0) {
#line 5377
    goto ldv_61841;
  } else {

  }

#line 5417
  return (rval);
}
}
#line 5423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla2x00_load_risc(struct scsi_qla_host *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int i ;
  int fragment ;
  uint16_t *wcode ;
  uint16_t *fwcode ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t fwclen ;
  uint32_t wlen ;
  uint32_t *seg ;
  struct fw_blob *blob ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 5430
  ha = vha->hw;
#line 5431
  req = *(ha->req_q_map);
#line 5434
  blob = qla2x00_request_firmware(vha);
#line 5435
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 5436
    ql_log(2U, vha, 131, "Fimware image unavailable.\n");
#line 5438
    ql_log(2U, vha, 132, "Firmware images can be retrieved from: http://ldriver.qlogic.com/firmware/.\n");
#line 5440
    return (258);
  } else {

  }
#line 5443
  rval = 0;
#line 5445
  wcode = (uint16_t *)req->ring;
#line 5446
  *srisc_addr = 0U;
#line 5447
  fwcode = (uint16_t *)(blob->fw)->data;
#line 5448
  fwclen = 0U;
#line 5451
  if ((unsigned long )(blob->fw)->size <= 15UL) {
#line 5452
    ql_log(0U, vha, 133, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5455
    goto fail_fw_integrity;
  } else {

  }
#line 5457
  i = 0;
#line 5457
  goto ldv_61863;
  ldv_61862: 
#line 5458
  tmp = __fswab16((int )*(fwcode + ((unsigned long )i + 4UL)));
#line 5458
  *(wcode + (unsigned long )i) = tmp;
#line 5457
  i = i + 1;
  ldv_61863: ;
#line 5457
  if (i <= 3) {
#line 5459
    goto ldv_61862;
  } else {

  }

#line 5459
  if (((((unsigned int )*wcode == 65535U && (unsigned int )*(wcode + 1UL) == 65535U) && (unsigned int )*(wcode + 2UL) == 65535U) && (unsigned int )*(wcode + 3UL) == 65535U) || ((((unsigned int )*wcode == 0U && (unsigned int )*(wcode + 1UL) == 0U) && (unsigned int )*(wcode + 2UL) == 0U) && (unsigned int )*(wcode + 3UL) == 0U)) {
#line 5462
    ql_log(0U, vha, 134, "Unable to verify integrity of firmware image.\n");
#line 5464
    ql_log(0U, vha, 135, "Firmware data: %04x %04x %04x %04x.\n", (int )*wcode, (int )*(wcode + 1UL),
           (int )*(wcode + 2UL), (int )*(wcode + 3UL));
#line 5467
    goto fail_fw_integrity;
  } else {

  }
#line 5470
  seg = (uint32_t *)(& blob->segs);
#line 5471
  goto ldv_61872;
  ldv_61871: 
#line 5472
  risc_addr = *seg;
#line 5473
  *srisc_addr = *srisc_addr == 0U ? *seg : *srisc_addr;
#line 5474
  tmp___0 = __fswab16((int )*(fwcode + 3UL));
#line 5474
  risc_size = (uint32_t )tmp___0;
#line 5477
  fwclen = risc_size * 2U + fwclen;
#line 5478
  if ((unsigned long )(blob->fw)->size < (unsigned long )fwclen) {
#line 5479
    ql_log(0U, vha, 136, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5482
    goto fail_fw_integrity;
  } else {

  }
#line 5485
  fragment = 0;
#line 5486
  goto ldv_61870;
  ldv_61869: 
#line 5487
  wlen = (uint32_t )((unsigned short )(ha->fw_transfer_size >> 1));
#line 5488
  if (wlen > risc_size) {
#line 5489
    wlen = risc_size;
  } else {

  }
#line 5490
  ql_dbg(1073741824U, vha, 137, "Loading risc segment@ risc addr %x number of words 0x%x.\n",
         risc_addr, wlen);
#line 5494
  i = 0;
#line 5494
  goto ldv_61866;
  ldv_61865: 
#line 5495
  tmp___1 = __fswab16((int )*(fwcode + (unsigned long )i));
#line 5495
  *(wcode + (unsigned long )i) = tmp___1;
#line 5494
  i = i + 1;
  ldv_61866: ;
#line 5494
  if ((uint32_t )i < wlen) {
#line 5496
    goto ldv_61865;
  } else {

  }
#line 5497
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, wlen);
#line 5499
  if (rval != 0) {
#line 5500
    ql_log(0U, vha, 138, "Failed to load segment %d of firmware.\n", fragment);
#line 5503
    goto ldv_61868;
  } else {

  }
#line 5506
  fwcode = fwcode + (unsigned long )wlen;
#line 5507
  risc_addr = risc_addr + wlen;
#line 5508
  risc_size = risc_size - wlen;
#line 5509
  fragment = fragment + 1;
  ldv_61870: ;
#line 5486
  if (risc_size != 0U && rval == 0) {
#line 5488
    goto ldv_61869;
  } else {

  }
  ldv_61868: 
#line 5513
  seg = seg + 1;
  ldv_61872: ;
#line 5471
  if (*seg != 0U && rval == 0) {
#line 5473
    goto ldv_61871;
  } else {

  }

#line 5515
  return (rval);
  fail_fw_integrity: ;
#line 5518
  return (258);
}
}
#line 5522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla24xx_load_risc_blob(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int segments ;
  int fragment ;
  uint32_t *dcode ;
  uint32_t dlen ;
  uint32_t risc_addr ;
  uint32_t risc_size ;
  uint32_t i ;
  struct fw_blob *blob ;
  uint32_t *fwcode ;
  uint32_t fwclen ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 5532
  ha = vha->hw;
#line 5533
  req = *(ha->req_q_map);
#line 5536
  blob = qla2x00_request_firmware(vha);
#line 5537
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 5538
    ql_log(1U, vha, 144, "Fimware image unavailable.\n");
#line 5540
    ql_log(1U, vha, 145, "Firmware images can be retrieved from: http://ldriver.qlogic.com/firmware/.\n");
#line 5544
    return (258);
  } else {

  }
#line 5547
  ql_dbg(1073741824U, vha, 146, "FW: Loading via request-firmware.\n");
#line 5550
  rval = 0;
#line 5552
  segments = 2;
#line 5553
  dcode = (uint32_t *)req->ring;
#line 5554
  *srisc_addr = 0U;
#line 5555
  fwcode = (uint32_t *)(blob->fw)->data;
#line 5556
  fwclen = 0U;
#line 5559
  if ((unsigned long )(blob->fw)->size <= 31UL) {
#line 5560
    ql_log(0U, vha, 147, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5563
    goto fail_fw_integrity;
  } else {

  }
#line 5565
  i = 0U;
#line 5565
  goto ldv_61893;
  ldv_61892: 
#line 5566
  tmp = __fswab32(*(fwcode + (unsigned long )(i + 4U)));
#line 5566
  *(dcode + (unsigned long )i) = tmp;
#line 5565
  i = i + 1U;
  ldv_61893: ;
#line 5565
  if (i <= 3U) {
#line 5567
    goto ldv_61892;
  } else {

  }

#line 5567
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 5571
    ql_log(0U, vha, 148, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5574
    ql_log(0U, vha, 149, "Firmware data: %08x %08x %08x %08x.\n", *dcode, *(dcode + 1UL),
           *(dcode + 2UL), *(dcode + 3UL));
#line 5577
    goto fail_fw_integrity;
  } else {

  }
#line 5580
  goto ldv_61902;
  ldv_61901: 
#line 5581
  tmp___0 = __fswab32(*(fwcode + 2UL));
#line 5581
  risc_addr = tmp___0;
#line 5582
  *srisc_addr = *srisc_addr != 0U ? *srisc_addr : risc_addr;
#line 5583
  tmp___1 = __fswab32(*(fwcode + 3UL));
#line 5583
  risc_size = tmp___1;
#line 5586
  fwclen = risc_size * 4U + fwclen;
#line 5587
  if ((unsigned long )(blob->fw)->size < (unsigned long )fwclen) {
#line 5588
    ql_log(0U, vha, 150, "Unable to verify integrity of firmware image (%Zd).\n",
           (blob->fw)->size);
#line 5592
    goto fail_fw_integrity;
  } else {

  }
#line 5595
  fragment = 0;
#line 5596
  goto ldv_61900;
  ldv_61899: 
#line 5597
  dlen = ha->fw_transfer_size >> 2;
#line 5598
  if (dlen > risc_size) {
#line 5599
    dlen = risc_size;
  } else {

  }
#line 5601
  ql_dbg(1073741824U, vha, 151, "Loading risc segment@ risc addr %x number of dwords 0x%x.\n",
         risc_addr, dlen);
#line 5605
  i = 0U;
#line 5605
  goto ldv_61896;
  ldv_61895: 
#line 5606
  tmp___2 = __fswab32(*(fwcode + (unsigned long )i));
#line 5606
  *(dcode + (unsigned long )i) = tmp___2;
#line 5605
  i = i + 1U;
  ldv_61896: ;
#line 5605
  if (i < dlen) {
#line 5607
    goto ldv_61895;
  } else {

  }
#line 5608
  rval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);
#line 5610
  if (rval != 0) {
#line 5611
    ql_log(0U, vha, 152, "Failed to load segment %d of firmware.\n", fragment);
#line 5614
    goto ldv_61898;
  } else {

  }
#line 5617
  fwcode = fwcode + (unsigned long )dlen;
#line 5618
  risc_addr = risc_addr + dlen;
#line 5619
  risc_size = risc_size - dlen;
#line 5620
  fragment = fragment + 1;
  ldv_61900: ;
#line 5596
  if (risc_size != 0U && rval == 0) {
#line 5598
    goto ldv_61899;
  } else {

  }
  ldv_61898: 
#line 5624
  segments = segments - 1;
  ldv_61902: ;
#line 5580
  if (segments != 0 && rval == 0) {
#line 5582
    goto ldv_61901;
  } else {

  }

#line 5626
  return (rval);
  fail_fw_integrity: ;
#line 5629
  return (258);
}
}
#line 5633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  int tmp ;
  int tmp___0 ;

  {
#line 5637
  if (ql2xfwloadbin == 1) {
#line 5638
    tmp = qla81xx_load_risc(vha, srisc_addr);
#line 5638
    return (tmp);
  } else {

  }
#line 5645
  rval = qla24xx_load_risc_blob(vha, srisc_addr);
#line 5646
  if (rval == 0) {
#line 5647
    return (rval);
  } else {

  }
#line 5649
  tmp___0 = qla24xx_load_risc_flash(vha, srisc_addr, (vha->hw)->flt_region_fw);
#line 5649
  return (tmp___0);
}
}
#line 5654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla81xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 5657
  ha = vha->hw;
#line 5659
  if (ql2xfwloadbin == 2) {
#line 5660
    goto try_blob_fw;
  } else {

  }
#line 5668
  rval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw);
#line 5669
  if (rval == 0) {
#line 5670
    return (rval);
  } else {

  }
  try_blob_fw: 
#line 5673
  rval = qla24xx_load_risc_blob(vha, srisc_addr);
#line 5674
  if (rval == 0 || ha->flt_region_gold_fw == 0U) {
#line 5675
    return (rval);
  } else {

  }
#line 5677
  ql_log(2U, vha, 153, "Attempting to fallback to golden firmware.\n");
#line 5679
  rval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_gold_fw);
#line 5680
  if (rval != 0) {
#line 5681
    return (rval);
  } else {

  }
#line 5683
  ql_log(2U, vha, 154, "Update operational firmware.\n");
#line 5684
  ha->flags.running_gold_fw = 1U;
#line 5685
  return (rval);
}
}
#line 5689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla2x00_try_to_stop_firmware(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  int retries ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 5692
  ha = vha->hw;
#line 5694
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5695
    return;
  } else {

  }
#line 5696
  if ((ha->device_type & 134217728U) == 0U) {
#line 5697
    return;
  } else {

  }
#line 5698
  if ((unsigned int )ha->fw_major_version == 0U) {
#line 5699
    return;
  } else {

  }
#line 5701
  ret = qla2x00_stop_firmware(vha);
#line 5702
  retries = 5;
#line 5702
  goto ldv_61924;
  ldv_61923: 
#line 5704
  (*((ha->isp_ops)->reset_chip))(vha);
#line 5705
  tmp = (*((ha->isp_ops)->chip_diag))(vha);
#line 5705
  if (tmp != 0) {
#line 5706
    goto ldv_61922;
  } else {

  }
#line 5707
  tmp___0 = qla2x00_setup_chip(vha);
#line 5707
  if (tmp___0 != 0) {
#line 5708
    goto ldv_61922;
  } else {

  }
#line 5709
  ql_log(2U, vha, 32789, "Attempting retry of stop-firmware command.\n");
#line 5711
  ret = qla2x00_stop_firmware(vha);
  ldv_61922: 
#line 5703
  retries = retries - 1;
  ldv_61924: ;
#line 5702
  if (((ret != 0 && ret != 256) && ret != 1) && retries != 0) {
#line 5705
    goto ldv_61923;
  } else {

  }

#line 5710
  return;
}
}
#line 5716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_configure_vhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int rval2 ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 5718
  rval = 0;
#line 5721
  ha = vha->hw;
#line 5722
  tmp = pci_get_drvdata(ha->pdev);
#line 5722
  base_vha = (struct scsi_qla_host *)tmp;
#line 5726
  if ((unsigned int )vha->vp_idx == 0U) {
#line 5727
    return (-22);
  } else {

  }
#line 5729
  rval = qla2x00_fw_ready(base_vha);
#line 5730
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 5731
    req = *(ha->req_q_map);
  } else {
#line 5733
    req = vha->req;
  }
#line 5734
  rsp = req->rsp;
#line 5736
  if (rval == 0) {
#line 5737
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5738
    qla2x00_marker(vha, req, rsp, 0, 0, 2);
  } else {

  }
#line 5741
  vha->flags.management_server_logged_in = 0U;
#line 5744
  rval2 = (*((ha->isp_ops)->fabric_login))(vha, 2044, 255, 255, 252, (uint16_t *)(& mb),
                                           2);
#line 5746
  if (rval2 != 0 || (unsigned int )mb[0] != 16384U) {
#line 5747
    if (rval2 == 259) {
#line 5748
      ql_dbg(1073741824U, vha, 288, "Failed SNS login: loop_id=%x, rval2=%d\n", 2044,
             rval2);
    } else {
#line 5752
      ql_dbg(1073741824U, vha, 259, "Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
             2044, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6], (int )mb[7]);
    }
#line 5756
    return (258);
  } else {

  }
#line 5759
  atomic_set(& vha->loop_down_timer, 0);
#line 5760
  atomic_set(& vha->loop_state, 3);
#line 5761
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5762
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 5763
  rval = qla2x00_loop_resync(base_vha);
#line 5765
  return (rval);
}
}
#line 5770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static struct list_head qla_cs84xx_list  =    {& qla_cs84xx_list, & qla_cs84xx_list};
#line 5771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static struct mutex qla_cs84xx_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_cs84xx_mutex.wait_lock",
                                                           0, 0UL}}}}, {& qla_cs84xx_mutex.wait_list,
                                                                        & qla_cs84xx_mutex.wait_list},
    0, 0, (void *)(& qla_cs84xx_mutex), {0, {0, 0}, "qla_cs84xx_mutex", 0, 0UL}};
#line 5774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_chip_state_84xx *cs84xx ;
  struct qla_hw_data *ha ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 5777
  ha = vha->hw;
#line 5779
  mutex_lock_nested(& qla_cs84xx_mutex, 0U);
#line 5782
  __mptr = (struct list_head  const  *)qla_cs84xx_list.next;
#line 5782
  cs84xx = (struct qla_chip_state_84xx *)__mptr;
#line 5782
  goto ldv_61950;
  ldv_61949: ;
#line 5783
  if ((unsigned long )cs84xx->bus == (unsigned long )((void *)(ha->pdev)->bus)) {
#line 5784
    kref_get(& cs84xx->kref);
#line 5785
    goto done;
  } else {

  }
#line 5782
  __mptr___0 = (struct list_head  const  *)cs84xx->list.next;
#line 5782
  cs84xx = (struct qla_chip_state_84xx *)__mptr___0;
  ldv_61950: ;
#line 5782
  if ((unsigned long )(& cs84xx->list) != (unsigned long )(& qla_cs84xx_list)) {
#line 5784
    goto ldv_61949;
  } else {

  }
#line 5789
  tmp = kzalloc(296UL, 208U);
#line 5789
  cs84xx = (struct qla_chip_state_84xx *)tmp;
#line 5790
  if ((unsigned long )cs84xx == (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 5791
    goto done;
  } else {

  }
#line 5793
  kref_init(& cs84xx->kref);
#line 5794
  spinlock_check(& cs84xx->access_lock);
#line 5794
  __raw_spin_lock_init(& cs84xx->access_lock.ldv_6105.rlock, "&(&cs84xx->access_lock)->rlock",
                       & __key);
#line 5795
  __mutex_init(& cs84xx->fw_update_mutex, "&cs84xx->fw_update_mutex", & __key___0);
#line 5796
  cs84xx->bus = (void *)(ha->pdev)->bus;
#line 5798
  list_add_tail(& cs84xx->list, & qla_cs84xx_list);
  done: 
#line 5800
  mutex_unlock(& qla_cs84xx_mutex);
#line 5801
  return (cs84xx);
}
}
#line 5805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static void __qla84xx_chip_release(struct kref *kref ) 
{ 
  struct qla_chip_state_84xx *cs84xx ;
  struct kref  const  *__mptr ;

  {
#line 5808
  __mptr = (struct kref  const  *)kref;
#line 5808
  cs84xx = (struct qla_chip_state_84xx *)__mptr + 0xfffffffffffffff0UL;
#line 5810
  mutex_lock_nested(& qla_cs84xx_mutex, 0U);
#line 5811
  list_del(& cs84xx->list);
#line 5812
  mutex_unlock(& qla_cs84xx_mutex);
#line 5813
  kfree((void const   *)cs84xx);
#line 5814
  return;
}
}
#line 5817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla84xx_put_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 5819
  ha = vha->hw;
#line 5820
  if ((unsigned long )ha->cs84xx != (unsigned long )((struct qla_chip_state_84xx *)0)) {
#line 5821
    kref_put(& (ha->cs84xx)->kref, & __qla84xx_chip_release);
  } else {

  }
#line 5822
  return;
}
}
#line 5825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla84xx_init_chip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint16_t status[2U] ;
  struct qla_hw_data *ha ;

  {
#line 5829
  ha = vha->hw;
#line 5831
  mutex_lock_nested(& (ha->cs84xx)->fw_update_mutex, 0U);
#line 5833
  rval = qla84xx_verify_chip(vha, (uint16_t *)(& status));
#line 5835
  mutex_unlock(& (ha->cs84xx)->fw_update_mutex);
#line 5837
  return (rval != 0 || (unsigned int )status[0] != 0U ? 258 : 0);
}
}
#line 5844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla81xx_nvram_config(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct init_cb_81xx *icb ;
  struct nvram_81xx *nv ;
  uint32_t *dptr ;
  uint8_t *dptr1 ;
  uint8_t *dptr2 ;
  uint32_t chksum ;
  uint16_t cnt ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint16_t tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;
  uint16_t tmp___5 ;
  size_t __len ;
  void *__ret ;
  int tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;

  {
#line 5853
  ha = vha->hw;
#line 5855
  rval = 0;
#line 5856
  icb = (struct init_cb_81xx *)ha->init_cb;
#line 5857
  nv = (struct nvram_81xx *)ha->nvram;
#line 5860
  ha->nvram_size = 512U;
#line 5861
  ha->vpd_size = 512U;
#line 5862
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || (ha->device_type & 65536U) != 0U) {
#line 5863
    ha->vpd_size = 1024U;
  } else {

  }
#line 5866
  ha->vpd = ha->nvram + 2048UL;
#line 5867
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->vpd, ha->flt_region_vpd << 2,
                                  (uint32_t )ha->vpd_size);
#line 5871
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->nvram, ha->flt_region_nvram << 2,
                                  (uint32_t )ha->nvram_size);
#line 5873
  dptr = (uint32_t *)nv;
#line 5874
  cnt = 0U;
#line 5874
  chksum = 0U;
#line 5874
  goto ldv_61983;
  ldv_61982: 
#line 5875
  tmp = dptr;
#line 5875
  dptr = dptr + 1;
#line 5875
  chksum = *tmp + chksum;
#line 5874
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61983: ;
#line 5874
  if ((int )ha->nvram_size >> 2 > (int )cnt) {
#line 5876
    goto ldv_61982;
  } else {

  }
#line 5877
  ql_dbg(1073872896U, vha, 273, "Contents of NVRAM:\n");
#line 5879
  ql_dump_buffer(1073872896U, vha, 274, (uint8_t *)nv, (uint32_t )ha->nvram_size);
#line 5883
  if (((((chksum != 0U || (unsigned int )nv->id[0] != 73U) || (unsigned int )nv->id[1] != 83U) || (unsigned int )nv->id[2] != 80U) || (unsigned int )nv->id[3] != 32U) || (unsigned int )nv->nvram_version == 0U) {
#line 5887
    ql_log(2U, vha, 115, "Inconsistent NVRAM detected: checksum=0x%x id=%c version=0x%x.\n",
           chksum, (int )nv->id[0], (int )nv->nvram_version);
#line 5891
    ql_log(2U, vha, 116, "Falling back to functioning (yet invalid -- WWPN) defaults.\n");
#line 5898
    memset((void *)nv, 0, (size_t )ha->nvram_size);
#line 5899
    nv->nvram_version = 1U;
#line 5900
    nv->version = 1U;
#line 5901
    nv->frame_payload_size = 2048U;
#line 5902
    nv->execution_throttle = 65535U;
#line 5903
    nv->exchange_count = 0U;
#line 5904
    nv->port_name[0] = 33U;
#line 5905
    nv->port_name[1] = ha->port_no;
#line 5906
    nv->port_name[2] = 0U;
#line 5907
    nv->port_name[3] = 224U;
#line 5908
    nv->port_name[4] = 139U;
#line 5909
    nv->port_name[5] = 28U;
#line 5910
    nv->port_name[6] = 85U;
#line 5911
    nv->port_name[7] = 134U;
#line 5912
    nv->node_name[0] = 32U;
#line 5913
    nv->node_name[1] = 0U;
#line 5914
    nv->node_name[2] = 0U;
#line 5915
    nv->node_name[3] = 224U;
#line 5916
    nv->node_name[4] = 139U;
#line 5917
    nv->node_name[5] = 28U;
#line 5918
    nv->node_name[6] = 85U;
#line 5919
    nv->node_name[7] = 134U;
#line 5920
    nv->login_retry_count = 8U;
#line 5921
    nv->interrupt_delay_timer = 0U;
#line 5922
    nv->login_timeout = 0U;
#line 5923
    nv->firmware_options_1 = 24582U;
#line 5925
    nv->firmware_options_2 = 32U;
#line 5926
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 5927
    nv->firmware_options_3 = 16384U;
#line 5928
    nv->host_p = 3072U;
#line 5929
    nv->efi_parameters = 0U;
#line 5930
    nv->reset_delay = 5U;
#line 5931
    nv->max_luns_per_target = 128U;
#line 5932
    nv->port_down_retry_count = 30U;
#line 5933
    nv->link_down_timeout = 180U;
#line 5934
    nv->enode_mac[0] = 0U;
#line 5935
    nv->enode_mac[1] = 192U;
#line 5936
    nv->enode_mac[2] = 221U;
#line 5937
    nv->enode_mac[3] = 4U;
#line 5938
    nv->enode_mac[4] = 5U;
#line 5939
    nv->enode_mac[5] = (unsigned int )ha->port_no + 6U;
#line 5941
    rval = 1;
  } else {

  }
#line 5944
  if ((ha->device_type & 33554432U) != 0U) {
#line 5945
    nv->frame_payload_size = (unsigned int )nv->frame_payload_size & 65528U;
  } else {

  }
#line 5947
  qlt_81xx_config_nvram_stage1(vha, nv);
#line 5950
  memset((void *)icb, 0, (size_t )ha->init_cb_size);
#line 5953
  dptr1 = (uint8_t *)icb;
#line 5954
  dptr2 = (uint8_t *)(& nv->version);
#line 5955
  cnt = 28U;
#line 5956
  goto ldv_61986;
  ldv_61985: 
#line 5957
  tmp___0 = dptr1;
#line 5957
  dptr1 = dptr1 + 1;
#line 5957
  tmp___1 = dptr2;
#line 5957
  dptr2 = dptr2 + 1;
#line 5957
  *tmp___0 = *tmp___1;
  ldv_61986: 
#line 5956
  tmp___2 = cnt;
#line 5956
  cnt = (uint16_t )((int )cnt - 1);
#line 5956
  if ((unsigned int )tmp___2 != 0U) {
#line 5958
    goto ldv_61985;
  } else {

  }
#line 5959
  icb->login_retry_count = nv->login_retry_count;
#line 5962
  dptr1 = (uint8_t *)(& icb->interrupt_delay_timer);
#line 5963
  dptr2 = (uint8_t *)(& nv->interrupt_delay_timer);
#line 5964
  cnt = 16U;
#line 5966
  goto ldv_61989;
  ldv_61988: 
#line 5967
  tmp___3 = dptr1;
#line 5967
  dptr1 = dptr1 + 1;
#line 5967
  tmp___4 = dptr2;
#line 5967
  dptr2 = dptr2 + 1;
#line 5967
  *tmp___3 = *tmp___4;
  ldv_61989: 
#line 5966
  tmp___5 = cnt;
#line 5966
  cnt = (uint16_t )((int )cnt - 1);
#line 5966
  if ((unsigned int )tmp___5 != 0U) {
#line 5968
    goto ldv_61988;
  } else {

  }
#line 5969
  __len = 6UL;
#line 5969
  if (__len > 63UL) {
#line 5969
    __ret = __memcpy((void *)(& icb->enode_mac), (void const   *)(& nv->enode_mac),
                     __len);
  } else {
#line 5969
    __ret = __builtin_memcpy((void *)(& icb->enode_mac), (void const   *)(& nv->enode_mac),
                             __len);
  }
#line 5971
  tmp___6 = memcmp((void const   *)(& icb->enode_mac), (void const   *)"", 6UL);
#line 5971
  if (tmp___6 == 0) {
#line 5972
    icb->enode_mac[0] = 0U;
#line 5973
    icb->enode_mac[1] = 192U;
#line 5974
    icb->enode_mac[2] = 221U;
#line 5975
    icb->enode_mac[3] = 4U;
#line 5976
    icb->enode_mac[4] = 5U;
#line 5977
    icb->enode_mac[5] = (unsigned int )ha->port_no + 6U;
  } else {

  }
#line 5981
  __len___0 = 64UL;
#line 5981
  if (__len___0 > 63UL) {
#line 5981
    __ret___0 = __memcpy((void *)ha->ex_init_cb, (void const   *)(& nv->ex_version),
                         __len___0);
  } else {
#line 5981
    __ret___0 = __builtin_memcpy((void *)ha->ex_init_cb, (void const   *)(& nv->ex_version),
                                 __len___0);
  }
#line 5986
  qla2x00_set_model_info(vha, (uint8_t *)(& nv->model_name), 16UL, (char *)"QLE8XXX");
#line 5989
  qlt_81xx_config_nvram_stage2(vha, icb);
#line 5992
  if ((nv->host_p & 32768U) != 0U) {
#line 5993
    __len___1 = 8UL;
#line 5993
    if (__len___1 > 63UL) {
#line 5993
      __ret___1 = __memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                           __len___1);
    } else {
#line 5993
      __ret___1 = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& nv->alternate_node_name),
                                   __len___1);
    }
#line 5994
    __len___2 = 8UL;
#line 5994
    if (__len___2 > 63UL) {
#line 5994
      __ret___2 = __memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                           __len___2);
    } else {
#line 5994
      __ret___2 = __builtin_memcpy((void *)(& icb->port_name), (void const   *)(& nv->alternate_port_name),
                                   __len___2);
    }
  } else {

  }
#line 5998
  if ((icb->firmware_options_1 & 16384U) == 0U) {
#line 6003
    __len___3 = 8UL;
#line 6003
    if (__len___3 > 63UL) {
#line 6003
      __ret___3 = __memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                           __len___3);
    } else {
#line 6003
      __ret___3 = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& icb->port_name),
                                   __len___3);
    }
#line 6004
    icb->node_name[0] = (unsigned int )icb->node_name[0] & 240U;
  } else {

  }
#line 6008
  ha->flags.disable_risc_code_load = 0U;
#line 6009
  ha->flags.enable_lip_reset = 0U;
#line 6010
  ha->flags.enable_lip_full_login = (nv->host_p & 1024U) != 0U;
#line 6012
  ha->flags.enable_target_reset = (nv->host_p & 2048U) != 0U;
#line 6014
  ha->flags.enable_led_scheme = 0U;
#line 6015
  ha->flags.disable_serdes = (nv->host_p & 32U) != 0U;
#line 6017
  ha->operating_mode = (uint8_t )((icb->firmware_options_2 & 112U) >> 4);
#line 6021
  ha->serial0 = icb->port_name[5];
#line 6022
  ha->serial1 = icb->port_name[6];
#line 6023
  ha->serial2 = icb->port_name[7];
#line 6024
  __len___4 = 8UL;
#line 6024
  if (__len___4 > 63UL) {
#line 6024
    __ret___4 = __memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                         __len___4);
  } else {
#line 6024
    __ret___4 = __builtin_memcpy((void *)(& vha->node_name), (void const   *)(& icb->node_name),
                                 __len___4);
  }
#line 6025
  __len___5 = 8UL;
#line 6025
  if (__len___5 > 63UL) {
#line 6025
    __ret___5 = __memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                         __len___5);
  } else {
#line 6025
    __ret___5 = __builtin_memcpy((void *)(& vha->port_name), (void const   *)(& icb->port_name),
                                 __len___5);
  }
#line 6027
  icb->execution_throttle = 65535U;
#line 6029
  ha->retry_count = (uint8_t )nv->login_retry_count;
#line 6032
  if ((int )nv->login_timeout < ql2xlogintimeout) {
#line 6033
    nv->login_timeout = (unsigned short )ql2xlogintimeout;
  } else {

  }
#line 6034
  if ((unsigned int )nv->login_timeout <= 3U) {
#line 6035
    nv->login_timeout = 4U;
  } else {

  }
#line 6036
  ha->login_timeout = (uint8_t )nv->login_timeout;
#line 6037
  icb->login_timeout = nv->login_timeout;
#line 6040
  ha->r_a_tov = 100U;
#line 6042
  ha->loop_reset_delay = (uint16_t )nv->reset_delay;
#line 6054
  if ((unsigned int )nv->link_down_timeout == 0U) {
#line 6055
    ha->loop_down_abort_time = 195U;
  } else {
#line 6058
    ha->link_down_timeout = (uint8_t )nv->link_down_timeout;
#line 6059
    ha->loop_down_abort_time = ~ ((int )ha->link_down_timeout);
  }
#line 6064
  ha->port_down_retry_count = (int )nv->port_down_retry_count;
#line 6065
  if (qlport_down_retry != 0) {
#line 6066
    ha->port_down_retry_count = qlport_down_retry;
  } else {

  }
#line 6069
  ha->login_retry_count = (uint32_t )nv->login_retry_count;
#line 6070
  if (ha->port_down_retry_count == (int )nv->port_down_retry_count && ha->port_down_retry_count > 3) {
#line 6073
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else
#line 6074
  if (ha->port_down_retry_count > (int )ha->login_retry_count) {
#line 6075
    ha->login_retry_count = (uint32_t )ha->port_down_retry_count;
  } else {

  }
#line 6076
  if (ql2xloginretrycount != 0) {
#line 6077
    ha->login_retry_count = (uint32_t )ql2xloginretrycount;
  } else {

  }
#line 6080
  if (*((unsigned long *)vha->hw + 2UL) == 0UL && ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 6081
    icb->firmware_options_2 = icb->firmware_options_2 | 4194304U;
  } else {

  }
#line 6084
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 6085
    ha->zio_mode = (unsigned int )((uint16_t )icb->firmware_options_2) & 15U;
#line 6087
    ha->zio_timer = (unsigned int )icb->interrupt_delay_timer != 0U ? icb->interrupt_delay_timer : 2U;
  } else {

  }
#line 6090
  icb->firmware_options_2 = icb->firmware_options_2 & 4294967280U;
#line 6092
  vha->flags.process_response_queue = 0U;
#line 6093
  if ((unsigned int )ha->zio_mode != 0U) {
#line 6094
    ha->zio_mode = 6U;
#line 6096
    ql_log(2U, vha, 117, "ZIO mode %d enabled; timer delay (%d us).\n", (int )ha->zio_mode,
           (int )ha->zio_timer * 100);
#line 6101
    icb->firmware_options_2 = icb->firmware_options_2 | (uint32_t )ha->zio_mode;
#line 6103
    icb->interrupt_delay_timer = ha->zio_timer;
#line 6104
    vha->flags.process_response_queue = 1U;
  } else {

  }
#line 6107
  if (rval != 0) {
#line 6108
    ql_log(1U, vha, 118, "NVRAM configuration failed.\n");
  } else {

  }
#line 6111
  return (rval);
}
}
#line 6115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla82xx_restart_isp(scsi_qla_host_t *vha ) 
{ 
  int status ;
  int rval ;
  uint32_t wait_time ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_qla_host *vp ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___4 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 6119
  ha = vha->hw;
#line 6120
  req = *(ha->req_q_map);
#line 6121
  rsp = *(ha->rsp_q_map);
#line 6125
  status = qla2x00_init_rings(vha);
#line 6126
  if (status == 0) {
#line 6127
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6128
    ha->flags.chip_reset_done = 1U;
#line 6130
    status = qla2x00_fw_ready(vha);
#line 6131
    if (status == 0) {
#line 6132
      ql_log(2U, vha, 32828, "Start configure loop, status =%d.\n", status);
#line 6136
      qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 6138
      vha->flags.online = 1U;
#line 6140
      wait_time = 256U;
      ldv_62023: 
#line 6142
      clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6143
      qla2x00_configure_loop(vha);
#line 6144
      wait_time = wait_time - 1U;
#line 6148
      tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 6148
      if (tmp == 0) {
#line 6148
        tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 6148
        if (tmp___0 == 0) {
#line 6148
          if (wait_time != 0U) {
#line 6148
            tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 6148
            if (tmp___1 != 0) {
#line 6149
              goto ldv_62023;
            } else {
#line 6152
              goto ldv_62024;
            }
          } else {
#line 6152
            goto ldv_62024;
          }
        } else {
#line 6152
          goto ldv_62024;
        }
      } else {

      }
      ldv_62024: ;
    } else {

    }
#line 6152
    if ((vha->device_flags & 2U) != 0U) {
#line 6153
      status = 0;
    } else {

    }
#line 6155
    ql_log(2U, vha, 32768, "Configure loop done, status = 0x%x.\n", status);
  } else {

  }
#line 6159
  if (status == 0) {
#line 6160
    clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6162
    tmp___2 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 6162
    if (tmp___2 == 0) {
#line 6167
      vha->marker_needed = 1U;
    } else {

    }
#line 6170
    vha->flags.online = 1U;
#line 6172
    (*((ha->isp_ops)->enable_intrs))(ha);
#line 6174
    ha->isp_abort_cnt = 0U;
#line 6175
    clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 6178
    status = qla82xx_check_md_needed(vha);
#line 6180
    if ((unsigned long )ha->fce != (unsigned long )((void *)0)) {
#line 6181
      ha->flags.fce_enabled = 1U;
#line 6182
      memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 6184
      rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                      (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 6187
      if (rval != 0) {
#line 6188
        ql_log(1U, vha, 32769, "Unable to reinitialize FCE (%d).\n", rval);
#line 6191
        ha->flags.fce_enabled = 0U;
      } else {

      }
    } else {

    }
#line 6195
    if ((unsigned long )ha->eft != (unsigned long )((void *)0)) {
#line 6196
      memset(ha->eft, 0, 65536UL);
#line 6197
      rval = qla2x00_enable_eft_trace(vha, ha->eft_dma, 4);
#line 6199
      if (rval != 0) {
#line 6200
        ql_log(1U, vha, 32784, "Unable to reinitialize EFT (%d).\n", rval);
      } else {

      }
    } else {

    }
  } else {

  }
#line 6207
  if (status == 0) {
#line 6208
    ql_dbg(4194304U, vha, 32785, "qla82xx_restart_isp succeeded.\n");
#line 6211
    tmp___3 = spinlock_check(& ha->vport_slock);
#line 6211
    flags = _raw_spin_lock_irqsave(tmp___3);
#line 6212
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 6212
    vp = (struct scsi_qla_host *)__mptr;
#line 6212
    goto ldv_62036;
    ldv_62035: ;
#line 6213
    if ((unsigned int )vp->vp_idx != 0U) {
#line 6214
      atomic_inc(& vp->vref_count);
#line 6215
      spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 6217
      qla2x00_vp_abort_isp(vp);
#line 6219
      tmp___4 = spinlock_check(& ha->vport_slock);
#line 6219
      flags = _raw_spin_lock_irqsave(tmp___4);
#line 6220
      atomic_dec(& vp->vref_count);
    } else {

    }
#line 6212
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 6212
    vp = (struct scsi_qla_host *)__mptr___0;
    ldv_62036: ;
#line 6212
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 6214
      goto ldv_62035;
    } else {

    }
#line 6223
    spin_unlock_irqrestore(& ha->vport_slock, flags);
  } else {
#line 6226
    ql_log(1U, vha, 32790, "qla82xx_restart_isp **** FAILED ****.\n");
  }
#line 6230
  return (status);
}
}
#line 6234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void qla81xx_update_fw_options(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 6236
  ha = vha->hw;
#line 6238
  if (ql2xetsenable == 0) {
#line 6239
    return;
  } else {

  }
#line 6242
  memset((void *)(& ha->fw_options), 0, 32UL);
#line 6243
  ha->fw_options[2] = (uint16_t )((unsigned int )ha->fw_options[2] | 512U);
#line 6244
  qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 6245
  return;
}
}
#line 6266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
static int qla24xx_get_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int i ;
  int entries ;
  uint8_t pid_match ;
  uint8_t wwn_match ;
  int priority ;
  uint32_t pid1 ;
  uint32_t pid2 ;
  uint64_t wwn1 ;
  uint64_t wwn2 ;
  struct qla_fcp_prio_entry *pri_entry ;
  struct qla_hw_data *ha ;

  {
#line 6274
  ha = vha->hw;
#line 6276
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0) || *((unsigned long *)ha + 2UL) == 0UL) {
#line 6277
    return (-1);
  } else {

  }
#line 6279
  priority = -1;
#line 6280
  entries = (int )(ha->fcp_prio_cfg)->num_entries;
#line 6281
  pri_entry = (struct qla_fcp_prio_entry *)(& (ha->fcp_prio_cfg)->entry);
#line 6283
  i = 0;
#line 6283
  goto ldv_62060;
  ldv_62059: 
#line 6284
  wwn_match = 0U;
#line 6284
  pid_match = wwn_match;
#line 6286
  if (((int )pri_entry->flags & 1) == 0) {
#line 6287
    pri_entry = pri_entry + 1;
#line 6288
    goto ldv_62057;
  } else {

  }
#line 6292
  if (((int )pri_entry->flags & 4) != 0) {
#line 6293
    pid1 = pri_entry->src_pid & 16777215U;
#line 6294
    pid2 = vha->d_id.b24;
#line 6295
    if (pid1 == 16777215U) {
#line 6296
      pid_match = (uint8_t )((int )pid_match + 1);
    } else
#line 6297
    if (pid1 == pid2) {
#line 6298
      pid_match = (uint8_t )((int )pid_match + 1);
    } else {

    }
  } else {

  }
#line 6302
  if (((int )pri_entry->flags & 8) != 0) {
#line 6303
    pid1 = pri_entry->dst_pid & 16777215U;
#line 6304
    pid2 = fcport->d_id.b24;
#line 6305
    if (pid1 == 16777215U) {
#line 6306
      pid_match = (uint8_t )((int )pid_match + 1);
    } else
#line 6307
    if (pid1 == pid2) {
#line 6308
      pid_match = (uint8_t )((int )pid_match + 1);
    } else {

    }
  } else {

  }
#line 6312
  if (((int )pri_entry->flags & 64) != 0) {
#line 6313
    wwn1 = wwn_to_u64((u8 *)(& vha->port_name));
#line 6314
    wwn2 = wwn_to_u64((u8 *)(& pri_entry->src_wwpn));
#line 6315
    if (wwn2 == 0xffffffffffffffffULL) {
#line 6316
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else
#line 6317
    if (wwn1 == wwn2) {
#line 6318
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else {

    }
  } else {

  }
#line 6322
  if (((int )pri_entry->flags & 128) != 0) {
#line 6323
    wwn1 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 6324
    wwn2 = wwn_to_u64((u8 *)(& pri_entry->dst_wwpn));
#line 6325
    if (wwn2 == 0xffffffffffffffffULL) {
#line 6326
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else
#line 6327
    if (wwn1 == wwn2) {
#line 6328
      wwn_match = (uint8_t )((int )wwn_match + 1);
    } else {

    }
  } else {

  }
#line 6331
  if ((unsigned int )pid_match == 2U || (unsigned int )wwn_match == 2U) {
#line 6333
    if (((int )pri_entry->flags & 2) != 0) {
#line 6334
      priority = (int )pri_entry->tag;
    } else {

    }
#line 6335
    goto ldv_62058;
  } else {

  }
#line 6338
  pri_entry = pri_entry + 1;
  ldv_62057: 
#line 6283
  i = i + 1;
  ldv_62060: ;
#line 6283
  if (i < entries) {
#line 6285
    goto ldv_62059;
  } else {

  }
  ldv_62058: ;
#line 6341
  return (priority);
}
}
#line 6359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int ret ;
  int priority ;
  uint16_t mb[5U] ;

  {
#line 6365
  if ((unsigned int )fcport->port_type != 5U || (unsigned int )fcport->loop_id == 4096U) {
#line 6367
    return (258);
  } else {

  }
#line 6369
  priority = qla24xx_get_fcp_prio(vha, fcport);
#line 6370
  if (priority < 0) {
#line 6371
    return (258);
  } else {

  }
#line 6373
  if (((vha->hw)->device_type & 16384U) != 0U || ((vha->hw)->device_type & 262144U) != 0U) {
#line 6374
    fcport->fcp_prio = (unsigned int )((uint8_t )priority) & 15U;
#line 6375
    return (0);
  } else {

  }
#line 6378
  ret = qla24xx_set_fcp_prio(vha, (int )fcport->loop_id, (int )((uint16_t )priority),
                             (uint16_t *)(& mb));
#line 6379
  if (ret == 0) {
#line 6380
    if ((int )fcport->fcp_prio != priority) {
#line 6381
      ql_dbg(8388608U, vha, 28830, "Updated FCP_CMND priority - value=%d loop_id=%d port_id=%02x%02x%02x.\n",
             priority, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
             (int )fcport->d_id.b.al_pa);
    } else {

    }
#line 6386
    fcport->fcp_prio = (unsigned int )((uint8_t )priority) & 15U;
  } else {
#line 6388
    ql_dbg(8388608U, vha, 28751, "Unable to update FCP_CMND priority - ret=0x%x for loop_id=%d port_id=%02x%02x%02x.\n",
           ret, (int )fcport->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa);
  }
#line 6393
  return (ret);
}
}
#line 6410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int qla24xx_update_all_fcp_prio(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 6415
  ret = 258;
#line 6417
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 6417
  fcport = (fc_port_t *)__mptr;
#line 6417
  goto ldv_62078;
  ldv_62077: 
#line 6418
  ret = qla24xx_update_fcport_fcp_prio(vha, fcport);
#line 6417
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 6417
  fcport = (fc_port_t *)__mptr___0;
  ldv_62078: ;
#line 6417
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 6419
    goto ldv_62077;
  } else {

  }

#line 6420
  return (ret);
}
}
#line 6424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int reg_timer_3(struct timer_list *timer ) 
{ 


  {
#line 6425
  ldv_timer_list_3 = timer;
#line 6426
  ldv_timer_state_3 = 1;
#line 6427
  return (0);
}
}
#line 6430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 6430
  if ((unsigned long )ldv_timer_list_3 == (unsigned long )timer) {
#line 6431
    if (ldv_timer_state_3 == 2 || pending_flag != 0) {
#line 6432
      ldv_timer_list_3 = timer;
#line 6433
      ldv_timer_list_3->data = data;
#line 6434
      ldv_timer_state_3 = 1;
    } else {

    }
#line 6436
    return;
  } else {

  }
#line 6438
  reg_timer_3(timer);
#line 6439
  ldv_timer_list_3->data = data;
#line 6440
  return;
}
}
#line 6443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) 
{ 


  {
#line 6444
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_3) {
#line 6445
    ldv_timer_state_3 = 0;
#line 6446
    return;
  } else {

  }
#line 6448
  return;
}
}
#line 6451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
void choose_timer_3(struct timer_list *timer ) 
{ 


  {
#line 6452
  LDV_IN_INTERRUPT = 2;
#line 6453
  (*(timer->function))(timer->data);
#line 6454
  LDV_IN_INTERRUPT = 1;
#line 6455
  ldv_timer_state_3 = 2;
#line 6456
  return;
}
}
#line 6458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int ldv_del_timer_17(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 6462
  tmp = del_timer(ldv_func_arg1);
#line 6462
  ldv_func_res = tmp;
#line 6464
  disable_suitable_timer_7(ldv_func_arg1);
#line 6466
  return (ldv_func_res);
}
}
#line 6469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int ldv_scsi_add_host_with_dma_18(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 6473
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 6473
  ldv_func_res = tmp;
#line 6475
  if (ldv_func_res == 0) {
#line 6476
    ldv_state_variable_72 = 1;
#line 6476
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 6480
  return (ldv_func_res);
}
}
#line 6483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_init.o.c.prepared"
int ldv_del_timer_19(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 6487
  tmp = del_timer(ldv_func_arg1);
#line 6487
  ldv_func_res = tmp;
#line 6489
  disable_suitable_timer_7(ldv_func_arg1);
#line 6491
  return (ldv_func_res);
}
}
#line 59 "include/uapi/linux/byteorder/little_endian.h"
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 


  {
#line 61
  return ((__le16 )*p);
}
}
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 807 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 809
  __edi = __edi;
#line 809
  __esi = __esi;
#line 809
  __edx = __edx;
#line 809
  __ecx = __ecx;
#line 809
  __eax = __eax;
#line 809
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 809
  if (tmp != 0L) {
#line 809
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (809), "i" (12UL));
    ldv_4645: ;
#line 809
    goto ldv_4645;
  } else {

  }
#line 809
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 811
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 814
  __edi = __edi;
#line 814
  __esi = __esi;
#line 814
  __edx = __edx;
#line 814
  __ecx = __ecx;
#line 814
  __eax = __eax;
#line 814
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 814
  if (tmp != 0L) {
#line 814
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (814), "i" (12UL));
    ldv_4654: ;
#line 814
    goto ldv_4654;
  } else {

  }
#line 814
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (46UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 816
  return;
}
}
#line 822 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
#line 826
  f = arch_local_save_flags();
#line 827
  arch_local_irq_disable();
#line 828
  return (f);
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 83 "include/linux/completion.h"
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_23(struct timer_list *ldv_func_arg1 ) ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 242
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 282
void choose_timer_4(struct timer_list *timer ) ;
#line 285
int reg_timer_4(struct timer_list *timer ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_24(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 400 "include/scsi/scsi_device.h"
extern void int_to_scsilun(unsigned int  , struct scsi_lun * ) ;
#line 824 "include/scsi/scsi_transport_fc.h"
__inline static void fc_vport_set_state(struct fc_vport *vport , enum fc_vport_state new_state ) 
{ 


  {
#line 826
  if ((unsigned int )new_state != 0U && (unsigned int )new_state != 4U) {
#line 828
    vport->vport_last_state = vport->vport_state;
  } else {

  }
#line 829
  vport->vport_state = new_state;
#line 830
  return;
}
}
#line 58 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla2x00_get_thermal_temp(scsi_qla_host_t *vha , uint16_t *temp ) ;
#line 139
int qla81xx_restart_mpi_firmware(scsi_qla_host_t *vha ) ;
#line 173
int qla24xx_control_vp(scsi_qla_host_t *vha , int cmd ) ;
#line 174
int qla24xx_modify_vp_config(scsi_qla_host_t *vha ) ;
#line 178
void qla24xx_report_id_acquisition(scsi_qla_host_t *vha , struct vp_rpt_id_entry_24xx *rptid_entry ) ;
#line 229
int qla2x00_dump_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr , uint32_t size ) ;
#line 250
int qla2x00_issue_iocb(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                       size_t size ) ;
#line 272
int qla2x00_get_node_name_list(scsi_qla_host_t *vha , void **out_data , int *out_len ) ;
#line 290
int qla2x00_send_sns(scsi_qla_host_t *vha , dma_addr_t sns_phys_address , uint16_t cmd_size ,
                     size_t buf_size ) ;
#line 320
int qla2x00_get_fcal_position_map(scsi_qla_host_t *vha , char *pos_map ) ;
#line 323
int qla2x00_get_link_status(scsi_qla_host_t *vha , uint16_t loop_id , struct link_statistics *stats ,
                            dma_addr_t stats_dma ) ;
#line 327
int qla24xx_get_isp_stats(scsi_qla_host_t *vha , struct link_statistics *stats , dma_addr_t stats_dma ) ;
#line 339
int qla2x00_system_error(scsi_qla_host_t *vha ) ;
#line 366
int qla2x00_read_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                     uint16_t off , uint16_t len , uint16_t opt ) ;
#line 370
int qla2x00_write_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                      uint16_t off , uint16_t len , uint16_t opt ) ;
#line 384
int qla81xx_fac_do_write_enable(scsi_qla_host_t *vha , int enable ) ;
#line 387
int qla81xx_fac_erase_sector(scsi_qla_host_t *vha , uint32_t start , uint32_t finish ) ;
#line 390
int qla2x00_get_xgmac_stats(scsi_qla_host_t *vha , dma_addr_t stats_dma , uint16_t size_in_bytes ,
                            uint16_t *actual_size ) ;
#line 393
int qla2x00_get_dcbx_params(scsi_qla_host_t *vha , dma_addr_t tlv_dma , uint16_t size ) ;
#line 410
int qla81xx_set_port_config(scsi_qla_host_t *vha , uint16_t *mb ) ;
#line 413
int qla2x00_port_logout(scsi_qla_host_t *vha , struct fc_port *fcport ) ;
#line 509
void ql_dump_regs(uint32_t level , scsi_qla_host_t *vha , int32_t id ) ;
#line 548
int qla2x00_loopback_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) ;
#line 549
int qla2x00_echo_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) ;
#line 657
void qla82xx_poll(int irq , void *dev_id ) ;
#line 678
int qla82xx_mbx_intr_enable(scsi_qla_host_t *vha ) ;
#line 679
int qla82xx_mbx_intr_disable(scsi_qla_host_t *vha ) ;
#line 684
int qla81xx_set_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) ;
#line 685
int qla81xx_get_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) ;
#line 686
int qla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha , int enable ) ;
#line 689
int qla82xx_read_temperature(scsi_qla_host_t *vha ) ;
#line 690
int qla8044_read_temperature(scsi_qla_host_t *vha ) ;
#line 695
int qla84xx_reset_chip(scsi_qla_host_t *vha , uint16_t enable_diagnostic ) ;
#line 696
int qla2x00_issue_iocb_timeout(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                               size_t size , uint32_t tov ) ;
#line 698
int qla2x00_get_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t *port_speed ,
                           uint16_t *mb ) ;
#line 705
int qla82xx_md_get_template_size(scsi_qla_host_t *vha ) ;
#line 706
int qla82xx_md_get_template(scsi_qla_host_t *vha ) ;
#line 731
int qla8044_md_get_template(scsi_qla_host_t *vha ) ;
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_poll(struct rsp_que *rsp ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 60
  ha = rsp->hw;
#line 61
  flags = arch_local_irq_save();
#line 61
  trace_hardirqs_off();
#line 62
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 63
    qla82xx_poll(0, (void *)rsp);
  } else {
#line 65
    (*((ha->isp_ops)->intr_handler))(0, (void *)rsp);
  }
#line 66
  tmp = arch_irqs_disabled_flags(flags);
#line 66
  if (tmp != 0) {
#line 66
    arch_local_irq_restore(flags);
#line 66
    trace_hardirqs_off();
  } else {
#line 66
    trace_hardirqs_on();
#line 66
    arch_local_irq_restore(flags);
  }
#line 68
  return;
}
}
#line 70 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint8_t *host_to_fcp_swap(uint8_t *fcp , uint32_t bsize ) 
{ 
  uint32_t *ifcp ;
  uint32_t *ofcp ;
  uint32_t iter ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  __u32 tmp___1 ;

  {
#line 72
  ifcp = (uint32_t *)fcp;
#line 73
  ofcp = (uint32_t *)fcp;
#line 74
  iter = bsize >> 2;
#line 76
  goto ldv_43322;
  ldv_43321: 
#line 77
  tmp = ofcp;
#line 77
  ofcp = ofcp + 1;
#line 77
  tmp___0 = ifcp;
#line 77
  ifcp = ifcp + 1;
#line 77
  tmp___1 = __fswab32(*tmp___0);
#line 77
  *tmp = tmp___1;
#line 76
  iter = iter - 1U;
  ldv_43322: ;
#line 76
  if (iter != 0U) {
#line 78
    goto ldv_43321;
  } else {

  }

#line 79
  return (fcp);
}
}
#line 1000 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_modify_vp_config(struct scsi_qla_host *vha , struct vp_config_entry_24xx *vpmod ) ;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
static int qla2x00_mailbox_command(scsi_qla_host_t *vha , mbx_cmd_t *mcp ) 
{ 
  int rval ;
  unsigned long flags ;
  device_reg_t *reg ;
  uint8_t abort_active ;
  uint8_t io_lock_on ;
  uint16_t command ;
  uint16_t *iptr ;
  uint16_t *optr ;
  uint32_t cnt ;
  uint32_t mboxes ;
  unsigned long wait_time ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int tmp___6 ;
  uint16_t *iptr2 ;
  uint16_t mb0 ;
  uint32_t ictrl ;
  unsigned short tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 336
  flags = 0UL;
#line 340
  command = 0U;
#line 346
  ha = vha->hw;
#line 347
  tmp = pci_get_drvdata(ha->pdev);
#line 347
  base_vha = (scsi_qla_host_t *)tmp;
#line 349
  ql_dbg(536870912U, vha, 4096, "Entered %s.\n", "qla2x00_mailbox_command");
#line 351
  if ((ha->pdev)->error_state > 2U) {
#line 352
    ql_log(1U, vha, 4097, "error_state is greater than pci_channel_io_frozen, exiting.\n");
#line 355
    return (256);
  } else {

  }
#line 358
  if ((vha->device_flags & 32U) != 0U) {
#line 359
    ql_log(1U, vha, 4098, "Device in failed state, exiting.\n");
#line 361
    return (256);
  } else {

  }
#line 364
  reg = ha->iobase;
#line 365
  io_lock_on = (uint8_t )base_vha->flags.init_done;
#line 367
  rval = 0;
#line 368
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 368
  abort_active = (uint8_t )tmp___0;
#line 371
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 372
    ql_log(1U, vha, 4099, "Perm failure on EEH timeout MBX, exiting.\n");
#line 374
    return (256);
  } else {

  }
#line 377
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 379
    mcp->mb[0] = 16395U;
#line 380
    ql_log(1U, vha, 4100, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 382
    return (256);
  } else {

  }
#line 390
  tmp___1 = wait_for_completion_timeout(& ha->mbx_cmd_comp, (unsigned long )(mcp->tov * 250U));
#line 390
  if (tmp___1 == 0UL) {
#line 392
    ql_log(1U, vha, 4101, "Cmd access timeout, cmd=0x%x, Exiting.\n", (int )mcp->mb[0]);
#line 395
    return (256);
  } else {

  }
#line 398
  ha->flags.mbox_busy = 1U;
#line 400
  ha->mcp = mcp;
#line 402
  ql_dbg(536870912U, vha, 4102, "Prepare to issue mbox cmd=0x%x.\n", (int )mcp->mb[0]);
#line 405
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 405
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 408
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 409
    optr = (uint16_t *)(& reg->isp82.mailbox_in);
  } else
#line 410
  if ((ha->device_type & 134217728U) != 0U && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 411
    optr = & reg->isp24.mailbox0;
  } else {
#line 413
    optr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox0 : & reg->isp.u.isp2300.mailbox0;
  }
#line 415
  iptr = (uint16_t *)(& mcp->mb);
#line 416
  command = mcp->mb[0];
#line 417
  mboxes = mcp->out_mb;
#line 419
  ql_dbg(537001984U, vha, 4369, "Mailbox registers (OUT):\n");
#line 421
  cnt = 0U;
#line 421
  goto ldv_60740;
  ldv_60739: ;
#line 422
  if ((ha->device_type & 2U) != 0U && cnt == 8U) {
#line 423
    optr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u_end.isp2200.mailbox8 : & reg->isp.u.isp2300.mailbox0 + 8UL;
  } else {

  }
#line 425
  if ((int )mboxes & 1) {
#line 426
    ql_dbg(536870912U, vha, 4370, "mbox[%d]<-0x%04x\n", cnt, (int )*iptr);
#line 428
    writew((int )*iptr, (void volatile   *)optr);
  } else {

  }
#line 431
  mboxes = mboxes >> 1;
#line 432
  optr = optr + 1;
#line 433
  iptr = iptr + 1;
#line 421
  cnt = cnt + 1U;
  ldv_60740: ;
#line 421
  if ((uint32_t )ha->mbx_count > cnt) {
#line 423
    goto ldv_60739;
  } else {

  }
#line 436
  ql_dbg(537001984U, vha, 4375, "I/O Address = %p.\n", optr);
#line 440
  ha->flags.mbox_int = 0U;
#line 441
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 444
  ql_dbg(536870912U, vha, 4111, "Going to unlock irq & waiting for interrupts. jiffies=%lx.\n",
         jiffies);
#line 450
  if (((unsigned int )abort_active == 0U && (unsigned int )io_lock_on != 0U) || ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && *((unsigned long *)ha + 2UL) != 0UL)) {
#line 451
    set_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 453
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 454
      tmp___3 = readl((void const volatile   *)(& reg->isp82.hint));
#line 454
      if ((int )tmp___3 & 1) {
#line 456
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 458
        ha->flags.mbox_busy = 0U;
#line 459
        ql_dbg(536870912U, vha, 4112, "Pending mailbox timeout, exiting.\n");
#line 461
        rval = 256;
#line 462
        goto premature_exit;
      } else {

      }
#line 464
      writel(1U, (void volatile   *)(& reg->isp82.hint));
    } else
#line 465
    if ((ha->device_type & 134217728U) != 0U) {
#line 466
      writel(1342177280U, (void volatile   *)(& reg->isp24.hccr));
    } else {
#line 468
      writew(20480, (void volatile   *)(& reg->isp.hccr));
    }
#line 469
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 471
    tmp___5 = wait_for_completion_timeout(& ha->mbx_intr_comp, (unsigned long )(mcp->tov * 250U));
#line 471
    if (tmp___5 == 0UL) {
#line 473
      ql_dbg(536870912U, vha, 4474, "cmd=%x Timeout.\n", (int )command);
#line 475
      tmp___4 = spinlock_check(& ha->hardware_lock);
#line 475
      flags = _raw_spin_lock_irqsave(tmp___4);
#line 476
      clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 477
      spin_unlock_irqrestore(& ha->hardware_lock, flags);
    } else {

    }
  } else {
#line 480
    ql_dbg(536870912U, vha, 4113, "Cmd=%x Polling Mode.\n", (int )command);
#line 483
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 484
      tmp___6 = readl((void const volatile   *)(& reg->isp82.hint));
#line 484
      if ((int )tmp___6 & 1) {
#line 486
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 488
        ha->flags.mbox_busy = 0U;
#line 489
        ql_dbg(536870912U, vha, 4114, "Pending mailbox timeout, exiting.\n");
#line 491
        rval = 256;
#line 492
        goto premature_exit;
      } else {

      }
#line 494
      writel(1U, (void volatile   *)(& reg->isp82.hint));
    } else
#line 495
    if ((ha->device_type & 134217728U) != 0U) {
#line 496
      writel(1342177280U, (void volatile   *)(& reg->isp24.hccr));
    } else {
#line 498
      writew(20480, (void volatile   *)(& reg->isp.hccr));
    }
#line 499
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 501
    wait_time = (unsigned long )(mcp->tov * 250U) + (unsigned long )jiffies;
#line 502
    goto ldv_60754;
    ldv_60753: ;
#line 503
    if ((long )(wait_time - (unsigned long )jiffies) < 0L) {
#line 504
      goto ldv_60752;
    } else {

    }
#line 507
    qla2x00_poll(*(ha->rsp_q_map));
#line 509
    if (*((unsigned long *)ha + 2UL) == 0UL && ((ha->device_type & 2U) == 0U || (unsigned int )command != 11U)) {
#line 512
      msleep(10U);
    } else {

    }
    ldv_60754: ;
#line 502
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 504
      goto ldv_60753;
    } else {

    }
    ldv_60752: 
#line 514
    ql_dbg(536870912U, vha, 4115, "Waited %d sec.\n", (unsigned int )((((unsigned long )(mcp->tov * 250U) - wait_time) + (unsigned long )jiffies) / 250UL));
  }
#line 520
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 523
    ql_dbg(536870912U, vha, 4116, "Cmd=%x completed.\n", (int )command);
#line 527
    ha->flags.mbox_int = 0U;
#line 528
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 530
    if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 531
      ha->flags.mbox_busy = 0U;
#line 533
      mcp->mb[0] = 16395U;
#line 534
      ha->mcp = (mbx_cmd_t *)0;
#line 535
      rval = 258;
#line 536
      ql_log(1U, vha, 4117, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 538
      goto premature_exit;
    } else {

    }
#line 541
    if ((unsigned int )ha->mailbox_out[0] != 16384U) {
#line 542
      rval = 258;
    } else {

    }
#line 545
    iptr2 = (uint16_t *)(& mcp->mb);
#line 546
    iptr = (uint16_t *)(& ha->mailbox_out);
#line 547
    mboxes = mcp->in_mb;
#line 549
    ql_dbg(536870912U, vha, 4371, "Mailbox registers (IN):\n");
#line 551
    cnt = 0U;
#line 551
    goto ldv_60757;
    ldv_60756: ;
#line 552
    if ((int )mboxes & 1) {
#line 553
      *iptr2 = *iptr;
#line 554
      ql_dbg(536870912U, vha, 4372, "mbox[%d]->0x%04x\n", cnt, (int )*iptr2);
    } else {

    }
#line 558
    mboxes = mboxes >> 1;
#line 559
    iptr2 = iptr2 + 1;
#line 560
    iptr = iptr + 1;
#line 551
    cnt = cnt + 1U;
    ldv_60757: ;
#line 551
    if ((uint32_t )ha->mbx_count > cnt) {
#line 553
      goto ldv_60756;
    } else {

    }

  } else {
#line 567
    if ((ha->device_type & 134217728U) != 0U) {
#line 568
      mb0 = readw((void const volatile   *)(& reg->isp24.mailbox0));
#line 569
      ictrl = readl((void const volatile   *)(& reg->isp24.ictrl));
    } else {
#line 571
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox0 : & reg->isp.u.isp2300.mailbox0));
#line 572
      tmp___7 = readw((void const volatile   *)(& reg->isp.ictrl));
#line 572
      ictrl = (uint32_t )tmp___7;
    }
#line 574
    ql_dbg(537001984U, vha, 4377, "MBX Command timeout for cmd %x, iocontrol=%x jiffies=%lx mb[0]=0x%x\n",
           (int )command, ictrl, jiffies, (int )mb0);
#line 577
    ql_dump_regs(537001984U, vha, 4121);
#line 584
    if ((unsigned int )mcp->mb[0] != 42U) {
#line 585
      (*((ha->isp_ops)->fw_dump))(vha, 0);
    } else {

    }
#line 587
    rval = 256;
  }
#line 590
  ha->flags.mbox_busy = 0U;
#line 593
  ha->mcp = (mbx_cmd_t *)0;
#line 595
  if (((unsigned int )abort_active != 0U || (unsigned int )io_lock_on == 0U) && ((((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) || *((unsigned long *)ha + 2UL) == 0UL)) {
#line 596
    ql_dbg(536870912U, vha, 4122, "Checking for additional resp interrupt.\n");
#line 600
    qla2x00_poll(*(ha->rsp_q_map));
  } else {

  }
#line 603
  if (rval == 256 && (unsigned int )mcp->mb[0] != 42U) {
#line 605
    if (((unsigned int )io_lock_on == 0U || ((int )mcp->flags & 4) != 0) || *((unsigned long *)ha + 2UL) != 0UL) {
#line 608
      ql_dbg(536870912U, vha, 4123, "Timeout, schedule isp_abort_needed.\n");
#line 611
      tmp___8 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 611
      if (tmp___8 == 0) {
#line 611
        tmp___9 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 611
        if (tmp___9 == 0) {
#line 611
          tmp___10 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 611
          if (tmp___10 == 0) {
#line 614
            if ((ha->device_type & 16384U) != 0U) {
#line 615
              ql_dbg(536870912U, vha, 4394, "disabling pause transmit on port 0 & 1.\n");
#line 618
              qla82xx_wr_32(ha, 106954904UL, 9U);
            } else {

            }
#line 623
            ql_log(2U, base_vha, 4124, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP abort.\n",
                   (int )command, (int )mcp->mb[0], (int )ha->flags.eeh_busy);
#line 628
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 629
            qla2xxx_wake_dpc(vha);
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 631
    if ((unsigned int )abort_active == 0U) {
#line 633
      ql_dbg(536870912U, vha, 4125, "Timeout, calling abort_isp.\n");
#line 636
      tmp___12 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 636
      if (tmp___12 == 0) {
#line 636
        tmp___13 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 636
        if (tmp___13 == 0) {
#line 636
          tmp___14 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 636
          if (tmp___14 == 0) {
#line 639
            if ((ha->device_type & 16384U) != 0U) {
#line 640
              ql_dbg(536870912U, vha, 4395, "disabling pause transmit on port 0 & 1.\n");
#line 643
              qla82xx_wr_32(ha, 106954904UL, 9U);
            } else {

            }
#line 648
            ql_log(2U, base_vha, 4126, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x. Scheduling ISP abort ",
                   (int )command, (int )mcp->mb[0]);
#line 652
            set_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 653
            clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 655
            complete(& ha->mbx_cmd_comp);
#line 656
            tmp___11 = (*((ha->isp_ops)->abort_isp))(vha);
#line 656
            if (tmp___11 != 0) {
#line 658
              set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
            } else {

            }
#line 661
            clear_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 662
            ql_dbg(536870912U, vha, 4127, "Finished abort_isp.\n");
#line 664
            goto mbx_done;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  premature_exit: 
#line 671
  complete(& ha->mbx_cmd_comp);
  mbx_done: ;
#line 674
  if (rval != 0) {
#line 675
    ql_log(1U, base_vha, 4128, "**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\n",
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )command);
  } else {
#line 679
    ql_dbg(536870912U, base_vha, 4129, "Done %s.\n", "qla2x00_mailbox_command");
  }
#line 682
  return (rval);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_load_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t risc_addr ,
                     uint32_t risc_code_size ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 690
  ha = vha->hw;
#line 692
  mcp = & mc;
#line 694
  ql_dbg(536903680U, vha, 4130, "Entered %s.\n", "qla2x00_load_ram");
#line 697
  if ((unsigned int )((unsigned short )(risc_addr >> 16)) != 0U || (ha->device_type & 134217728U) != 0U) {
#line 698
    mcp->mb[0] = 11U;
#line 699
    mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 700
    mcp->out_mb = 257U;
  } else {
#line 702
    mcp->mb[0] = 9U;
#line 703
    mcp->out_mb = 1U;
  }
#line 705
  mcp->mb[1] = (unsigned short )risc_addr;
#line 706
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 707
  mcp->mb[3] = (unsigned short )req_dma;
#line 708
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 709
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 710
  mcp->out_mb = mcp->out_mb | 206U;
#line 711
  if ((ha->device_type & 134217728U) != 0U) {
#line 712
    mcp->mb[4] = (unsigned short )(risc_code_size >> 16);
#line 713
    mcp->mb[5] = (unsigned short )risc_code_size;
#line 714
    mcp->out_mb = mcp->out_mb | 48U;
  } else {
#line 716
    mcp->mb[4] = (unsigned short )risc_code_size;
#line 717
    mcp->out_mb = mcp->out_mb | 16U;
  }
#line 720
  mcp->in_mb = 1U;
#line 721
  mcp->tov = 30U;
#line 722
  mcp->flags = 0U;
#line 723
  rval = qla2x00_mailbox_command(vha, mcp);
#line 725
  if (rval != 0) {
#line 726
    ql_dbg(536870912U, vha, 4131, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 729
    ql_dbg(536903680U, vha, 4132, "Done %s.\n", "qla2x00_load_ram");
  }
#line 733
  return (rval);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_execute_fw(scsi_qla_host_t *vha , uint32_t risc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct nvram_81xx *nv ;

  {
#line 756
  ha = vha->hw;
#line 758
  mcp = & mc;
#line 760
  ql_dbg(536903680U, vha, 4133, "Entered %s.\n", "qla2x00_execute_fw");
#line 763
  mcp->mb[0] = 2U;
#line 764
  mcp->out_mb = 1U;
#line 765
  mcp->in_mb = 1U;
#line 766
  if ((ha->device_type & 134217728U) != 0U) {
#line 767
    mcp->mb[1] = (unsigned short )(risc_addr >> 16);
#line 768
    mcp->mb[2] = (unsigned short )risc_addr;
#line 769
    mcp->mb[3] = 0U;
#line 770
    if ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 771
      nv = (struct nvram_81xx *)ha->nvram;
#line 772
      mcp->mb[4] = (unsigned int )((uint16_t )nv->enhanced_features) & 1U;
    } else {
#line 775
      mcp->mb[4] = 0U;
    }
#line 776
    mcp->out_mb = mcp->out_mb | 30U;
#line 777
    mcp->in_mb = mcp->in_mb | 2U;
  } else {
#line 779
    mcp->mb[1] = (unsigned short )risc_addr;
#line 780
    mcp->out_mb = mcp->out_mb | 2U;
#line 781
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 782
      mcp->mb[2] = 0U;
#line 783
      mcp->out_mb = mcp->out_mb | 4U;
    } else {

    }
  }
#line 787
  mcp->tov = 30U;
#line 788
  mcp->flags = 0U;
#line 789
  rval = qla2x00_mailbox_command(vha, mcp);
#line 791
  if (rval != 0) {
#line 792
    ql_dbg(536870912U, vha, 4134, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else
#line 795
  if ((ha->device_type & 134217728U) != 0U) {
#line 796
    ql_dbg(536903680U, vha, 4135, "Done exchanges=%x.\n", (int )mcp->mb[1]);
  } else {
#line 799
    ql_dbg(536903680U, vha, 4136, "Done %s.\n", "qla2x00_execute_fw");
  }
#line 804
  return (rval);
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_fw_version(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 828
  mcp = & mc;
#line 829
  ha = vha->hw;
#line 831
  ql_dbg(536903680U, vha, 4137, "Entered %s.\n", "qla2x00_get_fw_version");
#line 834
  mcp->mb[0] = 8U;
#line 835
  mcp->out_mb = 1U;
#line 836
  mcp->in_mb = 127U;
#line 837
  if ((((vha->hw)->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 838
    mcp->in_mb = mcp->in_mb | 16128U;
  } else {

  }
#line 839
  if ((ha->device_type & 134217728U) != 0U) {
#line 840
    mcp->in_mb = mcp->in_mb | 229376U;
  } else {

  }
#line 841
  mcp->flags = 0U;
#line 842
  mcp->tov = 30U;
#line 843
  rval = qla2x00_mailbox_command(vha, mcp);
#line 844
  if (rval != 0) {
#line 845
    goto failed;
  } else {

  }
#line 848
  ha->fw_major_version = mcp->mb[1];
#line 849
  ha->fw_minor_version = mcp->mb[2];
#line 850
  ha->fw_subminor_version = mcp->mb[3];
#line 851
  ha->fw_attributes = mcp->mb[6];
#line 852
  if ((int )(vha->hw)->device_type & 1 || ((vha->hw)->device_type & 2U) != 0U) {
#line 853
    ha->fw_memory_size = 131071U;
  } else {
#line 855
    ha->fw_memory_size = (uint32_t )(((int )mcp->mb[5] << 16) | (int )mcp->mb[4]);
  }
#line 856
  if ((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 857
    ha->mpi_version[0] = (uint8_t )mcp->mb[10];
#line 858
    ha->mpi_version[1] = (uint8_t )((int )mcp->mb[11] >> 8);
#line 859
    ha->mpi_version[2] = (uint8_t )mcp->mb[11];
#line 860
    ha->mpi_capabilities = (uint32_t )(((int )mcp->mb[12] << 16) | (int )mcp->mb[13]);
#line 861
    ha->phy_version[0] = (uint8_t )mcp->mb[8];
#line 862
    ha->phy_version[1] = (uint8_t )((int )mcp->mb[9] >> 8);
#line 863
    ha->phy_version[2] = (uint8_t )mcp->mb[9];
  } else {

  }
#line 865
  if ((ha->device_type & 134217728U) != 0U) {
#line 866
    ha->fw_attributes_h = mcp->mb[15];
#line 867
    ha->fw_attributes_ext[0] = mcp->mb[16];
#line 868
    ha->fw_attributes_ext[1] = mcp->mb[17];
#line 869
    ql_dbg(536903680U, vha, 4409, "%s: FW_attributes Upper: 0x%x, Lower: 0x%x.\n",
           "qla2x00_get_fw_version", (int )mcp->mb[15], (int )mcp->mb[6]);
#line 872
    ql_dbg(536903680U, vha, 4399, "%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",
           "qla2x00_get_fw_version", (int )mcp->mb[17], (int )mcp->mb[16]);
  } else {

  }
  failed: ;
#line 878
  if (rval != 0) {
#line 880
    ql_dbg(536870912U, vha, 4138, "Failed=%x.\n", rval);
  } else {
#line 883
    ql_dbg(536903680U, vha, 4139, "Done %s.\n", "qla2x00_get_fw_version");
  }
#line 886
  return (rval);
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 908
  mcp = & mc;
#line 910
  ql_dbg(536903680U, vha, 4140, "Entered %s.\n", "qla2x00_get_fw_options");
#line 913
  mcp->mb[0] = 40U;
#line 914
  mcp->out_mb = 1U;
#line 915
  mcp->in_mb = 15U;
#line 916
  mcp->tov = 30U;
#line 917
  mcp->flags = 0U;
#line 918
  rval = qla2x00_mailbox_command(vha, mcp);
#line 920
  if (rval != 0) {
#line 922
    ql_dbg(536870912U, vha, 4141, "Failed=%x.\n", rval);
  } else {
#line 924
    *fwopts = mcp->mb[0];
#line 925
    *(fwopts + 1UL) = mcp->mb[1];
#line 926
    *(fwopts + 2UL) = mcp->mb[2];
#line 927
    *(fwopts + 3UL) = mcp->mb[3];
#line 929
    ql_dbg(536903680U, vha, 4142, "Done %s.\n", "qla2x00_get_fw_options");
  }
#line 933
  return (rval);
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_set_fw_options(scsi_qla_host_t *vha , uint16_t *fwopts ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 956
  mcp = & mc;
#line 958
  ql_dbg(536903680U, vha, 4143, "Entered %s.\n", "qla2x00_set_fw_options");
#line 961
  mcp->mb[0] = 56U;
#line 962
  mcp->mb[1] = *(fwopts + 1UL);
#line 963
  mcp->mb[2] = *(fwopts + 2UL);
#line 964
  mcp->mb[3] = *(fwopts + 3UL);
#line 965
  mcp->out_mb = 15U;
#line 966
  mcp->in_mb = 1U;
#line 967
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 968
    mcp->in_mb = mcp->in_mb | 2U;
  } else {
#line 970
    mcp->mb[10] = *(fwopts + 10UL);
#line 971
    mcp->mb[11] = *(fwopts + 11UL);
#line 972
    mcp->mb[12] = 0U;
#line 973
    mcp->out_mb = mcp->out_mb | 7168U;
  }
#line 975
  mcp->tov = 30U;
#line 976
  mcp->flags = 0U;
#line 977
  rval = qla2x00_mailbox_command(vha, mcp);
#line 979
  *fwopts = mcp->mb[0];
#line 981
  if (rval != 0) {
#line 983
    ql_dbg(536870912U, vha, 4144, "Failed=%x (%x/%x).\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 987
    ql_dbg(536903680U, vha, 4145, "Done %s.\n", "qla2x00_set_fw_options");
  }
#line 991
  return (rval);
}
}
#line 1010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_mbx_reg_test(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1014
  mcp = & mc;
#line 1016
  ql_dbg(536903680U, vha, 4146, "Entered %s.\n", "qla2x00_mbx_reg_test");
#line 1019
  mcp->mb[0] = 6U;
#line 1020
  mcp->mb[1] = 43690U;
#line 1021
  mcp->mb[2] = 21845U;
#line 1022
  mcp->mb[3] = 43605U;
#line 1023
  mcp->mb[4] = 21930U;
#line 1024
  mcp->mb[5] = 42405U;
#line 1025
  mcp->mb[6] = 23130U;
#line 1026
  mcp->mb[7] = 9509U;
#line 1027
  mcp->out_mb = 255U;
#line 1028
  mcp->in_mb = 255U;
#line 1029
  mcp->tov = 30U;
#line 1030
  mcp->flags = 0U;
#line 1031
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1033
  if (rval == 0) {
#line 1034
    if ((((unsigned int )mcp->mb[1] != 43690U || (unsigned int )mcp->mb[2] != 21845U) || (unsigned int )mcp->mb[3] != 43605U) || (unsigned int )mcp->mb[4] != 21930U) {
#line 1036
      rval = 258;
    } else {

    }
#line 1037
    if (((unsigned int )mcp->mb[5] != 42405U || (unsigned int )mcp->mb[6] != 23130U) || (unsigned int )mcp->mb[7] != 9509U) {
#line 1039
      rval = 258;
    } else {

    }
  } else {

  }
#line 1042
  if (rval != 0) {
#line 1044
    ql_dbg(536870912U, vha, 4147, "Failed=%x.\n", rval);
  } else {
#line 1047
    ql_dbg(536903680U, vha, 4148, "Done %s.\n", "qla2x00_mbx_reg_test");
  }
#line 1051
  return (rval);
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_verify_checksum(scsi_qla_host_t *vha , uint32_t risc_addr ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1074
  mcp = & mc;
#line 1076
  ql_dbg(536903680U, vha, 4149, "Entered %s.\n", "qla2x00_verify_checksum");
#line 1079
  mcp->mb[0] = 7U;
#line 1080
  mcp->out_mb = 1U;
#line 1081
  mcp->in_mb = 1U;
#line 1082
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1083
    mcp->mb[1] = (unsigned short )(risc_addr >> 16);
#line 1084
    mcp->mb[2] = (unsigned short )risc_addr;
#line 1085
    mcp->out_mb = mcp->out_mb | 6U;
#line 1086
    mcp->in_mb = mcp->in_mb | 6U;
  } else {
#line 1088
    mcp->mb[1] = (unsigned short )risc_addr;
#line 1089
    mcp->out_mb = mcp->out_mb | 2U;
#line 1090
    mcp->in_mb = mcp->in_mb | 2U;
  }
#line 1093
  mcp->tov = 30U;
#line 1094
  mcp->flags = 0U;
#line 1095
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1097
  if (rval != 0) {
#line 1098
    ql_dbg(536870912U, vha, 4150, "Failed=%x chm sum=%x.\n", rval, ((vha->hw)->device_type & 134217728U) != 0U ? ((int )mcp->mb[2] << 16) | (int )mcp->mb[1] : (int )mcp->mb[1]);
  } else {
#line 1102
    ql_dbg(536903680U, vha, 4151, "Done %s.\n", "qla2x00_verify_checksum");
  }
#line 1106
  return (rval);
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_issue_iocb_timeout(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                               size_t size , uint32_t tov ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  sts_entry_t *sts_entry ;

  {
#line 1133
  mcp = & mc;
#line 1135
  ql_dbg(536903680U, vha, 4152, "Entered %s.\n", "qla2x00_issue_iocb_timeout");
#line 1138
  mcp->mb[0] = 84U;
#line 1139
  mcp->mb[1] = 0U;
#line 1140
  mcp->mb[2] = (unsigned short )((unsigned int )phys_addr >> 16);
#line 1141
  mcp->mb[3] = (unsigned short )phys_addr;
#line 1142
  mcp->mb[6] = (unsigned short )((unsigned int )(phys_addr >> 32ULL) >> 16);
#line 1143
  mcp->mb[7] = (unsigned short )(phys_addr >> 32ULL);
#line 1144
  mcp->out_mb = 207U;
#line 1145
  mcp->in_mb = 5U;
#line 1146
  mcp->tov = tov;
#line 1147
  mcp->flags = 0U;
#line 1148
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1150
  if (rval != 0) {
#line 1152
    ql_dbg(536870912U, vha, 4153, "Failed=%x.\n", rval);
  } else {
#line 1154
    sts_entry = (sts_entry_t *)buffer;
#line 1157
    sts_entry->entry_status = (uint8_t )((int )((signed char )sts_entry->entry_status) & (((vha->hw)->device_type & 134217728U) != 0U ? 60 : 126));
#line 1159
    ql_dbg(536903680U, vha, 4154, "Done %s.\n", "qla2x00_issue_iocb_timeout");
  }
#line 1163
  return (rval);
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_issue_iocb(scsi_qla_host_t *vha , void *buffer , dma_addr_t phys_addr ,
                       size_t size ) 
{ 
  int tmp ;

  {
#line 1170
  tmp = qla2x00_issue_iocb_timeout(vha, buffer, phys_addr, size, 30U);
#line 1170
  return (tmp);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_abort_command(srb_t *sp ) 
{ 
  unsigned long flags ;
  int rval ;
  uint32_t handle ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  fc_port_t *fcport ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct scsi_cmnd *cmd ;
  raw_spinlock_t *tmp ;

  {
#line 1191
  flags = 0UL;
#line 1193
  handle = 0U;
#line 1195
  mcp = & mc;
#line 1196
  fcport = sp->fcport;
#line 1197
  vha = fcport->vha;
#line 1198
  ha = vha->hw;
#line 1199
  req = vha->req;
#line 1200
  cmd = sp->u.scmd.cmd;
#line 1202
  ql_dbg(536903680U, vha, 4155, "Entered %s.\n", "qla2x00_abort_command");
#line 1205
  tmp = spinlock_check(& ha->hardware_lock);
#line 1205
  flags = _raw_spin_lock_irqsave(tmp);
#line 1206
  handle = 1U;
#line 1206
  goto ldv_60860;
  ldv_60859: ;
#line 1207
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 1208
    goto ldv_60858;
  } else {

  }
#line 1206
  handle = handle + 1U;
  ldv_60860: ;
#line 1206
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 1208
    goto ldv_60859;
  } else {

  }
  ldv_60858: 
#line 1210
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1212
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1214
    return (258);
  } else {

  }
#line 1217
  mcp->mb[0] = 21U;
#line 1218
  if ((int )ha->device_type < 0) {
#line 1219
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 1221
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 1222
  mcp->mb[2] = (unsigned short )handle;
#line 1223
  mcp->mb[3] = (unsigned short )(handle >> 16);
#line 1224
  mcp->mb[6] = (unsigned short )(cmd->device)->lun;
#line 1225
  mcp->out_mb = 79U;
#line 1226
  mcp->in_mb = 1U;
#line 1227
  mcp->tov = 30U;
#line 1228
  mcp->flags = 0U;
#line 1229
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1231
  if (rval != 0) {
#line 1232
    ql_dbg(536870912U, vha, 4156, "Failed=%x.\n", rval);
  } else {
#line 1234
    ql_dbg(536903680U, vha, 4157, "Done %s.\n", "qla2x00_abort_command");
  }
#line 1238
  return (rval);
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_abort_target(struct fc_port *fcport , unsigned int l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 1246
  mcp = & mc;
#line 1251
  l = l;
#line 1252
  vha = fcport->vha;
#line 1254
  ql_dbg(536903680U, vha, 4158, "Entered %s.\n", "qla2x00_abort_target");
#line 1257
  req = *((vha->hw)->req_q_map);
#line 1258
  rsp = req->rsp;
#line 1259
  mcp->mb[0] = 23U;
#line 1260
  mcp->out_mb = 519U;
#line 1261
  if ((int )(vha->hw)->device_type < 0) {
#line 1262
    mcp->mb[1] = fcport->loop_id;
#line 1263
    mcp->mb[10] = 0U;
#line 1264
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 1266
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 1268
  mcp->mb[2] = (vha->hw)->loop_reset_delay;
#line 1269
  mcp->mb[9] = vha->vp_idx;
#line 1271
  mcp->in_mb = 1U;
#line 1272
  mcp->tov = 30U;
#line 1273
  mcp->flags = 0U;
#line 1274
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1275
  if (rval != 0) {
#line 1276
    ql_dbg(536903680U, vha, 4159, "Failed=%x.\n", rval);
  } else {

  }
#line 1281
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, 0, 1);
#line 1283
  if (rval2 != 0) {
#line 1284
    ql_dbg(536870912U, vha, 4160, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 1287
    ql_dbg(536903680U, vha, 4161, "Done %s.\n", "qla2x00_abort_target");
  }
#line 1291
  return (rval);
}
}
#line 1295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_lun_reset(struct fc_port *fcport , unsigned int l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 1299
  mcp = & mc;
#line 1304
  vha = fcport->vha;
#line 1306
  ql_dbg(536903680U, vha, 4162, "Entered %s.\n", "qla2x00_lun_reset");
#line 1309
  req = *((vha->hw)->req_q_map);
#line 1310
  rsp = req->rsp;
#line 1311
  mcp->mb[0] = 126U;
#line 1312
  mcp->out_mb = 527U;
#line 1313
  if ((int )(vha->hw)->device_type < 0) {
#line 1314
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 1316
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 1317
  mcp->mb[2] = (uint16_t )l;
#line 1318
  mcp->mb[3] = 0U;
#line 1319
  mcp->mb[9] = vha->vp_idx;
#line 1321
  mcp->in_mb = 1U;
#line 1322
  mcp->tov = 30U;
#line 1323
  mcp->flags = 0U;
#line 1324
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1325
  if (rval != 0) {
#line 1326
    ql_dbg(536870912U, vha, 4163, "Failed=%x.\n", rval);
  } else {

  }
#line 1330
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, (int )((uint16_t )l),
                         0);
#line 1332
  if (rval2 != 0) {
#line 1333
    ql_dbg(536870912U, vha, 4164, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 1336
    ql_dbg(536903680U, vha, 4165, "Done %s.\n", "qla2x00_lun_reset");
  }
#line 1340
  return (rval);
}
}
#line 1364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_adapter_id(scsi_qla_host_t *vha , uint16_t *id , uint8_t *al_pa ,
                           uint8_t *area , uint8_t *domain , uint16_t *top , uint16_t *sw_cap ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1369
  mcp = & mc;
#line 1371
  ql_dbg(536903680U, vha, 4166, "Entered %s.\n", "qla2x00_get_adapter_id");
#line 1374
  mcp->mb[0] = 32U;
#line 1375
  mcp->mb[9] = vha->vp_idx;
#line 1376
  mcp->out_mb = 513U;
#line 1377
  mcp->in_mb = 719U;
#line 1378
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1379
    mcp->in_mb = mcp->in_mb | 15360U;
  } else {

  }
#line 1380
  mcp->tov = 30U;
#line 1381
  mcp->flags = 0U;
#line 1382
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1383
  if ((unsigned int )mcp->mb[0] == 16389U) {
#line 1384
    rval = 5;
  } else
#line 1385
  if ((unsigned int )mcp->mb[0] == 16385U) {
#line 1386
    rval = 1;
  } else {

  }
#line 1389
  *id = mcp->mb[1];
#line 1390
  *al_pa = (unsigned char )mcp->mb[2];
#line 1391
  *area = (unsigned char )((int )mcp->mb[2] >> 8);
#line 1392
  *domain = (unsigned char )mcp->mb[3];
#line 1393
  *top = mcp->mb[6];
#line 1394
  *sw_cap = mcp->mb[7];
#line 1396
  if (rval != 0) {
#line 1398
    ql_dbg(536870912U, vha, 4167, "Failed=%x.\n", rval);
  } else {
#line 1400
    ql_dbg(536903680U, vha, 4168, "Done %s.\n", "qla2x00_get_adapter_id");
#line 1403
    if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 1404
      vha->fcoe_vlan_id = (unsigned int )mcp->mb[9] & 4095U;
#line 1405
      vha->fcoe_fcf_idx = mcp->mb[10];
#line 1406
      vha->fcoe_vn_port_mac[5] = (uint8_t )((int )mcp->mb[11] >> 8);
#line 1407
      vha->fcoe_vn_port_mac[4] = (uint8_t )mcp->mb[11];
#line 1408
      vha->fcoe_vn_port_mac[3] = (uint8_t )((int )mcp->mb[12] >> 8);
#line 1409
      vha->fcoe_vn_port_mac[2] = (uint8_t )mcp->mb[12];
#line 1410
      vha->fcoe_vn_port_mac[1] = (uint8_t )((int )mcp->mb[13] >> 8);
#line 1411
      vha->fcoe_vn_port_mac[0] = (uint8_t )mcp->mb[13];
    } else {

    }
  }
#line 1415
  return (rval);
}
}
#line 1434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_retry_cnt(scsi_qla_host_t *vha , uint8_t *retry_cnt , uint8_t *tov ,
                          uint16_t *r_a_tov ) 
{ 
  int rval ;
  uint16_t ratov ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1440
  mcp = & mc;
#line 1442
  ql_dbg(536903680U, vha, 4169, "Entered %s.\n", "qla2x00_get_retry_cnt");
#line 1445
  mcp->mb[0] = 34U;
#line 1446
  mcp->out_mb = 1U;
#line 1447
  mcp->in_mb = 15U;
#line 1448
  mcp->tov = 30U;
#line 1449
  mcp->flags = 0U;
#line 1450
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1452
  if (rval != 0) {
#line 1454
    ql_dbg(536870912U, vha, 4170, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 1458
    *r_a_tov = (uint16_t )((unsigned int )mcp->mb[3] / 2U);
#line 1459
    ratov = (uint16_t )((unsigned int )mcp->mb[3] / 20U);
#line 1460
    if ((int )mcp->mb[1] * (int )ratov > (int )*retry_cnt * (int )*tov) {
#line 1462
      *retry_cnt = (unsigned char )mcp->mb[1];
#line 1463
      *tov = (uint8_t )ratov;
    } else {

    }
#line 1466
    ql_dbg(536903680U, vha, 4171, "Done %s mb3=%d ratov=%d.\n", "qla2x00_get_retry_cnt",
           (int )mcp->mb[3], (int )ratov);
  }
#line 1470
  return (rval);
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 1495
  mcp = & mc;
#line 1496
  ha = vha->hw;
#line 1498
  ql_dbg(536903680U, vha, 4172, "Entered %s.\n", "qla2x00_init_firmware");
#line 1501
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) && ql2xdbwr != 0) {
#line 1502
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, (u32 )(((int )ha->portnum << 5) | 4));
  } else {

  }
#line 1505
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1506
    mcp->mb[0] = 72U;
  } else {
#line 1508
    mcp->mb[0] = 96U;
  }
#line 1510
  mcp->mb[1] = 0U;
#line 1511
  mcp->mb[2] = (unsigned short )((unsigned int )ha->init_cb_dma >> 16);
#line 1512
  mcp->mb[3] = (unsigned short )ha->init_cb_dma;
#line 1513
  mcp->mb[6] = (unsigned short )((unsigned int )(ha->init_cb_dma >> 32ULL) >> 16);
#line 1514
  mcp->mb[7] = (unsigned short )(ha->init_cb_dma >> 32ULL);
#line 1515
  mcp->out_mb = 207U;
#line 1516
  if (((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && (unsigned int )(ha->ex_init_cb)->ex_version != 0U) {
#line 1517
    mcp->mb[1] = 1U;
#line 1518
    mcp->mb[10] = (unsigned short )((unsigned int )ha->ex_init_cb_dma >> 16);
#line 1519
    mcp->mb[11] = (unsigned short )ha->ex_init_cb_dma;
#line 1520
    mcp->mb[12] = (unsigned short )((unsigned int )(ha->ex_init_cb_dma >> 32ULL) >> 16);
#line 1521
    mcp->mb[13] = (unsigned short )(ha->ex_init_cb_dma >> 32ULL);
#line 1522
    mcp->mb[14] = 64U;
#line 1523
    mcp->out_mb = mcp->out_mb | 31744U;
  } else {

  }
#line 1526
  mcp->in_mb = 7U;
#line 1527
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1529
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 1530
  mcp->buf_size = (long )size;
#line 1531
  mcp->flags = 2U;
#line 1532
  mcp->tov = 30U;
#line 1533
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1535
  if (rval != 0) {
#line 1537
    ql_dbg(536870912U, vha, 4173, "Failed=%x mb[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x,.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3]);
  } else {
#line 1542
    ql_dbg(536903680U, vha, 4174, "Done %s.\n", "qla2x00_init_firmware");
  }
#line 1546
  return (rval);
}
}
#line 1566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_node_name_list(scsi_qla_host_t *vha , void **out_data , int *out_len ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_port_24xx_data *list ;
  void *pmap ;
  mbx_cmd_t mc ;
  dma_addr_t pmap_dma ;
  ulong dma_size ;
  int rval ;
  int left ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1568
  ha = vha->hw;
#line 1569
  list = (struct qla_port_24xx_data *)0;
#line 1576
  left = 1;
#line 1577
  goto ldv_60941;
  ldv_60940: 
#line 1578
  dma_size = (unsigned long )left * 12UL;
#line 1579
  pmap = dma_alloc_attrs(& (ha->pdev)->dev, dma_size, & pmap_dma, 208U, (struct dma_attrs *)0);
#line 1581
  if ((unsigned long )pmap == (unsigned long )((void *)0)) {
#line 1582
    ql_log(1U, vha, 4415, "%s(%ld): DMA Alloc failed of %ld\n", "qla2x00_get_node_name_list",
           vha->host_no, dma_size);
#line 1585
    rval = 259;
#line 1586
    goto out;
  } else {

  }
#line 1589
  mc.mb[0] = 117U;
#line 1590
  mc.mb[1] = 10U;
#line 1591
  mc.mb[2] = (unsigned short )((unsigned int )pmap_dma >> 16);
#line 1592
  mc.mb[3] = (unsigned short )pmap_dma;
#line 1593
  mc.mb[6] = (unsigned short )((unsigned int )(pmap_dma >> 32ULL) >> 16);
#line 1594
  mc.mb[7] = (unsigned short )(pmap_dma >> 32ULL);
#line 1595
  mc.mb[8] = (uint16_t )dma_size;
#line 1596
  mc.out_mb = 463U;
#line 1597
  mc.in_mb = 3U;
#line 1598
  mc.tov = 30U;
#line 1599
  mc.flags = 1U;
#line 1601
  rval = qla2x00_mailbox_command(vha, & mc);
#line 1602
  if (rval != 0) {
#line 1603
    if ((unsigned int )mc.mb[0] == 16389U && (unsigned int )mc.mb[1] == 10U) {
#line 1605
      left = (int )((unsigned int )mc.mb[2] / 12U + (unsigned int )left);
#line 1607
      goto restart;
    } else {

    }
#line 1609
    goto out_free;
  } else {

  }
#line 1612
  left = 0;
#line 1614
  tmp = kzalloc(dma_size, 208U);
#line 1614
  list = (struct qla_port_24xx_data *)tmp;
#line 1615
  if ((unsigned long )list == (unsigned long )((struct qla_port_24xx_data *)0)) {
#line 1616
    ql_log(1U, vha, 4416, "%s(%ld): failed to allocate node names list structure.\n",
           "qla2x00_get_node_name_list", vha->host_no);
#line 1619
    rval = 259;
#line 1620
    goto out_free;
  } else {

  }
#line 1623
  __len = dma_size;
#line 1623
  __ret = __builtin_memcpy((void *)list, (void const   *)pmap, __len);
  restart: 
#line 1625
  dma_free_attrs(& (ha->pdev)->dev, dma_size, pmap, pmap_dma, (struct dma_attrs *)0);
  ldv_60941: ;
#line 1577
  if (left > 0) {
#line 1579
    goto ldv_60940;
  } else {

  }
#line 1628
  *out_data = (void *)list;
#line 1629
  *out_len = (int )dma_size;
  out: ;
#line 1632
  return (rval);
  out_free: 
#line 1635
  dma_free_attrs(& (ha->pdev)->dev, dma_size, pmap, pmap_dma, (struct dma_attrs *)0);
#line 1636
  return (rval);
}
}
#line 1656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_port_database(scsi_qla_host_t *vha , fc_port_t *fcport , uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  port_database_t *pd ;
  struct port_database_24xx *pd24 ;
  dma_addr_t pd_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;
  int _max1 ;
  int _max2 ;
  uint64_t zero ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  uint64_t zero___0 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 1660
  mcp = & mc;
#line 1664
  ha = vha->hw;
#line 1666
  ql_dbg(536903680U, vha, 4175, "Entered %s.\n", "qla2x00_get_port_database");
#line 1669
  pd24 = (struct port_database_24xx *)0;
#line 1670
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & pd_dma);
#line 1670
  pd = (port_database_t *)tmp;
#line 1671
  if ((unsigned long )pd == (unsigned long )((port_database_t *)0)) {
#line 1672
    ql_log(1U, vha, 4176, "Failed to allocate port database structure.\n");
#line 1674
    return (259);
  } else {

  }
#line 1676
  _max1 = 128;
#line 1676
  _max2 = 64;
#line 1676
  memset((void *)pd, 0, (size_t )(_max1 > _max2 ? _max1 : _max2));
#line 1678
  mcp->mb[0] = 100U;
#line 1679
  if ((unsigned int )opt != 0U && (ha->device_type & 134217728U) == 0U) {
#line 1680
    mcp->mb[0] = 71U;
  } else {

  }
#line 1681
  mcp->mb[2] = (unsigned short )((unsigned int )pd_dma >> 16);
#line 1682
  mcp->mb[3] = (unsigned short )pd_dma;
#line 1683
  mcp->mb[6] = (unsigned short )((unsigned int )(pd_dma >> 32ULL) >> 16);
#line 1684
  mcp->mb[7] = (unsigned short )(pd_dma >> 32ULL);
#line 1685
  mcp->mb[9] = vha->vp_idx;
#line 1686
  mcp->out_mb = 717U;
#line 1687
  mcp->in_mb = 1U;
#line 1688
  if ((ha->device_type & 134217728U) != 0U) {
#line 1689
    mcp->mb[1] = fcport->loop_id;
#line 1690
    mcp->mb[10] = (uint16_t )opt;
#line 1691
    mcp->out_mb = mcp->out_mb | 1026U;
#line 1692
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 1693
  if ((int )ha->device_type < 0) {
#line 1694
    mcp->mb[1] = fcport->loop_id;
#line 1695
    mcp->mb[10] = (uint16_t )opt;
#line 1696
    mcp->out_mb = mcp->out_mb | 1026U;
  } else {
#line 1698
    mcp->mb[1] = (uint16_t )((int )((short )((int )fcport->loop_id << 8)) | (int )((short )opt));
#line 1699
    mcp->out_mb = mcp->out_mb | 2U;
  }
#line 1701
  mcp->buf_size = (ha->device_type & 134217728U) != 0U ? 64L : 128L;
#line 1703
  mcp->flags = 1U;
#line 1704
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 1705
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1706
  if (rval != 0) {
#line 1707
    goto gpd_error_out;
  } else {

  }
#line 1709
  if ((ha->device_type & 134217728U) != 0U) {
#line 1710
    zero = 0ULL;
#line 1711
    pd24 = (struct port_database_24xx *)pd;
#line 1714
    if ((unsigned int )pd24->current_login_state != 6U && (unsigned int )pd24->last_login_state != 6U) {
#line 1716
      ql_dbg(536870912U, vha, 4177, "Unable to verify login-state (%x/%x) for loop_id %x.\n",
             (int )pd24->current_login_state, (int )pd24->last_login_state, (int )fcport->loop_id);
#line 1720
      rval = 258;
#line 1721
      goto gpd_error_out;
    } else {

    }
#line 1724
    if ((unsigned int )fcport->loop_id == 4096U) {
#line 1728
      rval = 10;
#line 1729
      goto gpd_error_out;
    } else {
#line 1724
      tmp___0 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& zero),
                       8UL);
#line 1724
      if (tmp___0 != 0) {
#line 1724
        tmp___1 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& pd24->port_name),
                         8UL);
#line 1724
        if (tmp___1 != 0) {
#line 1728
          rval = 10;
#line 1729
          goto gpd_error_out;
        } else {

        }
      } else {

      }
    }
#line 1733
    __len = 8UL;
#line 1733
    if (__len > 63UL) {
#line 1733
      __ret = __memcpy((void *)(& fcport->node_name), (void const   *)(& pd24->node_name),
                       __len);
    } else {
#line 1733
      __ret = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& pd24->node_name),
                               __len);
    }
#line 1734
    __len___0 = 8UL;
#line 1734
    if (__len___0 > 63UL) {
#line 1734
      __ret___0 = __memcpy((void *)(& fcport->port_name), (void const   *)(& pd24->port_name),
                           __len___0);
    } else {
#line 1734
      __ret___0 = __builtin_memcpy((void *)(& fcport->port_name), (void const   *)(& pd24->port_name),
                                   __len___0);
    }
#line 1737
    fcport->d_id.b.domain = pd24->port_id[0];
#line 1738
    fcport->d_id.b.area = pd24->port_id[1];
#line 1739
    fcport->d_id.b.al_pa = pd24->port_id[2];
#line 1740
    fcport->d_id.b.rsvd_1 = 0U;
#line 1743
    if (((int )pd24->prli_svc_param_word_3[0] & 16) == 0) {
#line 1744
      fcport->port_type = 4;
    } else {
#line 1746
      fcport->port_type = 5;
    }
#line 1749
    fcport->supported_classes = ((int )pd24->flags & 16) != 0 ? 4U : 8U;
#line 1752
    if ((int )((signed char )pd24->prli_svc_param_word_3[0]) < 0) {
#line 1753
      fcport->flags = fcport->flags | 16U;
    } else {

    }
  } else {
#line 1755
    zero___0 = 0ULL;
#line 1758
    if ((unsigned int )pd->master_state != 6U && (unsigned int )pd->slave_state != 6U) {
#line 1760
      ql_dbg(536870912U, vha, 4106, "Unable to verify login-state (%x/%x) - portid=%02x%02x%02x.\n",
             (int )pd->master_state, (int )pd->slave_state, (int )fcport->d_id.b.domain,
             (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 1765
      rval = 258;
#line 1766
      goto gpd_error_out;
    } else {

    }
#line 1769
    if ((unsigned int )fcport->loop_id == 4096U) {
#line 1773
      rval = 10;
#line 1774
      goto gpd_error_out;
    } else {
#line 1769
      tmp___2 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& zero___0),
                       8UL);
#line 1769
      if (tmp___2 != 0) {
#line 1769
        tmp___3 = memcmp((void const   *)(& fcport->port_name), (void const   *)(& pd->port_name),
                         8UL);
#line 1769
        if (tmp___3 != 0) {
#line 1773
          rval = 10;
#line 1774
          goto gpd_error_out;
        } else {

        }
      } else {

      }
    }
#line 1778
    __len___1 = 8UL;
#line 1778
    if (__len___1 > 63UL) {
#line 1778
      __ret___1 = __memcpy((void *)(& fcport->node_name), (void const   *)(& pd->node_name),
                           __len___1);
    } else {
#line 1778
      __ret___1 = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& pd->node_name),
                                   __len___1);
    }
#line 1779
    __len___2 = 8UL;
#line 1779
    if (__len___2 > 63UL) {
#line 1779
      __ret___2 = __memcpy((void *)(& fcport->port_name), (void const   *)(& pd->port_name),
                           __len___2);
    } else {
#line 1779
      __ret___2 = __builtin_memcpy((void *)(& fcport->port_name), (void const   *)(& pd->port_name),
                                   __len___2);
    }
#line 1782
    fcport->d_id.b.domain = pd->port_id[0];
#line 1783
    fcport->d_id.b.area = pd->port_id[3];
#line 1784
    fcport->d_id.b.al_pa = pd->port_id[2];
#line 1785
    fcport->d_id.b.rsvd_1 = 0U;
#line 1788
    if (((int )pd->prli_svc_param_word_3[0] & 16) == 0) {
#line 1789
      fcport->port_type = 4;
    } else {
#line 1791
      fcport->port_type = 5;
    }
#line 1794
    fcport->supported_classes = ((int )pd->options & 16) != 0 ? 4U : 8U;
  }
  gpd_error_out: 
#line 1799
  dma_pool_free(ha->s_dma_pool, (void *)pd, pd_dma);
#line 1801
  if (rval != 0) {
#line 1802
    ql_dbg(536870912U, vha, 4178, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 1806
    ql_dbg(536903680U, vha, 4179, "Done %s.\n", "qla2x00_get_port_database");
  }
#line 1810
  return (rval);
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_firmware_state(scsi_qla_host_t *vha , uint16_t *states ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1834
  mcp = & mc;
#line 1836
  ql_dbg(536903680U, vha, 4180, "Entered %s.\n", "qla2x00_get_firmware_state");
#line 1839
  mcp->mb[0] = 105U;
#line 1840
  mcp->out_mb = 1U;
#line 1841
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1842
    mcp->in_mb = 63U;
  } else {
#line 1844
    mcp->in_mb = 3U;
  }
#line 1845
  mcp->tov = 30U;
#line 1846
  mcp->flags = 0U;
#line 1847
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1850
  *states = mcp->mb[1];
#line 1851
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 1852
    *(states + 1UL) = mcp->mb[2];
#line 1853
    *(states + 2UL) = mcp->mb[3];
#line 1854
    *(states + 3UL) = mcp->mb[4];
#line 1855
    *(states + 4UL) = mcp->mb[5];
  } else {

  }
#line 1858
  if (rval != 0) {
#line 1860
    ql_dbg(536870912U, vha, 4181, "Failed=%x.\n", rval);
  } else {
#line 1863
    ql_dbg(536903680U, vha, 4182, "Done %s.\n", "qla2x00_get_firmware_state");
  }
#line 1867
  return (rval);
}
}
#line 1889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_port_name(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t *name ,
                          uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1894
  mcp = & mc;
#line 1896
  ql_dbg(536903680U, vha, 4183, "Entered %s.\n", "qla2x00_get_port_name");
#line 1899
  mcp->mb[0] = 106U;
#line 1900
  mcp->mb[9] = vha->vp_idx;
#line 1901
  mcp->out_mb = 515U;
#line 1902
  if ((int )(vha->hw)->device_type < 0) {
#line 1903
    mcp->mb[1] = loop_id;
#line 1904
    mcp->mb[10] = (uint16_t )opt;
#line 1905
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 1907
    mcp->mb[1] = (uint16_t )((int )((short )((int )loop_id << 8)) | (int )((short )opt));
  }
#line 1910
  mcp->in_mb = 207U;
#line 1911
  mcp->tov = 30U;
#line 1912
  mcp->flags = 0U;
#line 1913
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1915
  if (rval != 0) {
#line 1917
    ql_dbg(536870912U, vha, 4184, "Failed=%x.\n", rval);
  } else {
#line 1919
    if ((unsigned long )name != (unsigned long )((uint8_t *)0U)) {
#line 1921
      *name = (unsigned char )((int )mcp->mb[2] >> 8);
#line 1922
      *(name + 1UL) = (unsigned char )mcp->mb[2];
#line 1923
      *(name + 2UL) = (unsigned char )((int )mcp->mb[3] >> 8);
#line 1924
      *(name + 3UL) = (unsigned char )mcp->mb[3];
#line 1925
      *(name + 4UL) = (unsigned char )((int )mcp->mb[6] >> 8);
#line 1926
      *(name + 5UL) = (unsigned char )mcp->mb[6];
#line 1927
      *(name + 6UL) = (unsigned char )((int )mcp->mb[7] >> 8);
#line 1928
      *(name + 7UL) = (unsigned char )mcp->mb[7];
    } else {

    }
#line 1931
    ql_dbg(536903680U, vha, 4185, "Done %s.\n", "qla2x00_get_port_name");
  }
#line 1935
  return (rval);
}
}
#line 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_link_initialize(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 1958
  mcp = & mc;
#line 1960
  ql_dbg(536903680U, vha, 4434, "Entered %s.\n", "qla24xx_link_initialize");
#line 1963
  if (((vha->hw)->device_type & 134217728U) == 0U || (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U)) {
#line 1964
    return (258);
  } else {

  }
#line 1966
  mcp->mb[0] = 114U;
#line 1967
  mcp->mb[1] = 16U;
#line 1968
  if ((unsigned int )(vha->hw)->operating_mode == 0U) {
#line 1969
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 64U);
  } else {
#line 1971
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 32U);
  }
#line 1972
  mcp->mb[2] = 0U;
#line 1973
  mcp->mb[3] = 0U;
#line 1974
  mcp->out_mb = 15U;
#line 1975
  mcp->in_mb = 1U;
#line 1976
  mcp->tov = 30U;
#line 1977
  mcp->flags = 0U;
#line 1978
  rval = qla2x00_mailbox_command(vha, mcp);
#line 1980
  if (rval != 0) {
#line 1981
    ql_dbg(536870912U, vha, 4435, "Failed=%x.\n", rval);
  } else {
#line 1983
    ql_dbg(536903680U, vha, 4436, "Done %s.\n", "qla24xx_link_initialize");
  }
#line 1987
  return (rval);
}
}
#line 2006 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_lip_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2010
  mcp = & mc;
#line 2012
  ql_dbg(536903680U, vha, 4186, "Entered %s.\n", "qla2x00_lip_reset");
#line 2015
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 2017
    mcp->mb[0] = 114U;
#line 2018
    mcp->mb[1] = 2U;
#line 2019
    mcp->mb[2] = 0U;
#line 2020
    mcp->out_mb = 7U;
  } else
#line 2021
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 2022
    mcp->mb[0] = 114U;
#line 2023
    mcp->mb[1] = 64U;
#line 2024
    mcp->mb[2] = 0U;
#line 2025
    mcp->mb[3] = (vha->hw)->loop_reset_delay;
#line 2026
    mcp->out_mb = 15U;
  } else {
#line 2028
    mcp->mb[0] = 108U;
#line 2029
    mcp->out_mb = 15U;
#line 2030
    if ((int )(vha->hw)->device_type < 0) {
#line 2031
      mcp->mb[1] = 255U;
#line 2032
      mcp->mb[10] = 0U;
#line 2033
      mcp->out_mb = mcp->out_mb | 1024U;
    } else {
#line 2035
      mcp->mb[1] = 65280U;
    }
#line 2037
    mcp->mb[2] = (vha->hw)->loop_reset_delay;
#line 2038
    mcp->mb[3] = 0U;
  }
#line 2040
  mcp->in_mb = 1U;
#line 2041
  mcp->tov = 30U;
#line 2042
  mcp->flags = 0U;
#line 2043
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2045
  if (rval != 0) {
#line 2047
    ql_dbg(536870912U, vha, 4187, "Failed=%x.\n", rval);
  } else {
#line 2050
    ql_dbg(536903680U, vha, 4188, "Done %s.\n", "qla2x00_lip_reset");
  }
#line 2054
  return (rval);
}
}
#line 2076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_send_sns(scsi_qla_host_t *vha , dma_addr_t sns_phys_address , uint16_t cmd_size ,
                     size_t buf_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2081
  mcp = & mc;
#line 2083
  ql_dbg(536903680U, vha, 4189, "Entered %s.\n", "qla2x00_send_sns");
#line 2086
  ql_dbg(536903680U, vha, 4190, "Retry cnt=%d ratov=%d total tov=%d.\n", (int )(vha->hw)->retry_count,
         (int )(vha->hw)->login_timeout, mcp->tov);
#line 2090
  mcp->mb[0] = 110U;
#line 2091
  mcp->mb[1] = cmd_size;
#line 2092
  mcp->mb[2] = (unsigned short )((unsigned int )sns_phys_address >> 16);
#line 2093
  mcp->mb[3] = (unsigned short )sns_phys_address;
#line 2094
  mcp->mb[6] = (unsigned short )((unsigned int )(sns_phys_address >> 32ULL) >> 16);
#line 2095
  mcp->mb[7] = (unsigned short )(sns_phys_address >> 32ULL);
#line 2096
  mcp->out_mb = 207U;
#line 2097
  mcp->in_mb = 3U;
#line 2098
  mcp->buf_size = (long )buf_size;
#line 2099
  mcp->flags = 3U;
#line 2100
  mcp->tov = (uint32_t )((int )(vha->hw)->login_timeout * 2 + (int )((unsigned int )(vha->hw)->login_timeout / 2U));
#line 2101
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2103
  if (rval != 0) {
#line 2105
    ql_dbg(536870912U, vha, 4191, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 2110
    ql_dbg(536903680U, vha, 4192, "Done %s.\n", "qla2x00_send_sns");
  }
#line 2114
  return (rval);
}
}
#line 2118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) 
{ 
  int rval ;
  struct logio_entry_24xx *lg ;
  dma_addr_t lg_dma ;
  uint32_t iop[2U] ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 2126
  ha = vha->hw;
#line 2130
  ql_dbg(536903680U, vha, 4193, "Entered %s.\n", "qla24xx_login_fabric");
#line 2133
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2134
    req = *(ha->req_q_map);
  } else {
#line 2136
    req = vha->req;
  }
#line 2137
  rsp = req->rsp;
#line 2139
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & lg_dma);
#line 2139
  lg = (struct logio_entry_24xx *)tmp;
#line 2140
  if ((unsigned long )lg == (unsigned long )((struct logio_entry_24xx *)0)) {
#line 2141
    ql_log(1U, vha, 4194, "Failed to allocate login IOCB.\n");
#line 2143
    return (259);
  } else {

  }
#line 2145
  memset((void *)lg, 0, 64UL);
#line 2147
  lg->entry_type = 82U;
#line 2148
  lg->entry_count = 1U;
#line 2149
  lg->handle = ((unsigned int )req->id << 16) | lg->handle;
#line 2150
  lg->nport_handle = loop_id;
#line 2151
  lg->control_flags = 0U;
#line 2152
  if ((int )opt & 1) {
#line 2153
    lg->control_flags = (uint16_t )((unsigned int )lg->control_flags | 16U);
  } else {

  }
#line 2154
  if (((int )opt & 2) != 0) {
#line 2155
    lg->control_flags = (uint16_t )((unsigned int )lg->control_flags | 32U);
  } else {

  }
#line 2156
  lg->port_id[0] = al_pa;
#line 2157
  lg->port_id[1] = area;
#line 2158
  lg->port_id[2] = domain;
#line 2159
  lg->vp_index = (uint8_t )vha->vp_idx;
#line 2160
  rval = qla2x00_issue_iocb_timeout(vha, (void *)lg, lg_dma, 0UL, (uint32_t )(((int )((unsigned int )ha->r_a_tov / 10U) + 1) * 2));
#line 2162
  if (rval != 0) {
#line 2163
    ql_dbg(536870912U, vha, 4195, "Failed to issue login IOCB (%x).\n", rval);
  } else
#line 2165
  if ((unsigned int )lg->entry_status != 0U) {
#line 2166
    ql_dbg(536870912U, vha, 4196, "Failed to complete IOCB -- error status (%x).\n",
           (int )lg->entry_status);
#line 2169
    rval = 258;
  } else
#line 2170
  if ((unsigned int )lg->comp_status != 0U) {
#line 2171
    iop[0] = lg->io_parameter[0];
#line 2172
    iop[1] = lg->io_parameter[1];
#line 2174
    ql_dbg(536870912U, vha, 4197, "Failed to complete IOCB -- completion  status (%x) ioparam=%x/%x.\n",
           (int )lg->comp_status, iop[0], iop[1]);
#line 2179
    switch (iop[0]) {
    case 26U: 
#line 2181
    *mb = 16391U;
#line 2182
    *(mb + 1UL) = (unsigned short )iop[1];
#line 2183
    goto ldv_61034;
    case 27U: 
#line 2185
    *mb = 16392U;
#line 2186
    goto ldv_61034;
    case 1U: ;
    case 2U: ;
    case 3U: ;
    case 4U: ;
    case 5U: ;
    case 7U: ;
    case 9U: ;
    case 10U: ;
    case 24U: ;
    case 25U: ;
    case 28U: ;
    case 29U: ;
    case 31U: ;
    default: 
#line 2201
    *mb = 16389U;
#line 2202
    goto ldv_61034;
    }
    ldv_61034: ;
  } else {
#line 2205
    ql_dbg(536903680U, vha, 4198, "Done %s.\n", "qla24xx_login_fabric");
#line 2208
    iop[0] = lg->io_parameter[0];
#line 2210
    *mb = 16384U;
#line 2211
    *(mb + 1UL) = 0U;
#line 2212
    if ((iop[0] & 16U) != 0U) {
#line 2213
      if ((iop[0] & 256U) != 0U) {
#line 2214
        *(mb + 1UL) = (uint16_t )((unsigned int )*(mb + 1UL) | 2U);
      } else {

      }
    } else {
#line 2216
      *(mb + 1UL) = 1U;
    }
#line 2219
    *(mb + 10UL) = 0U;
#line 2220
    if (lg->io_parameter[7] != 0U || lg->io_parameter[8] != 0U) {
#line 2221
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 1U);
    } else {

    }
#line 2222
    if (lg->io_parameter[9] != 0U || lg->io_parameter[10] != 0U) {
#line 2223
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 2U);
    } else {

    }
#line 2224
    if ((lg->io_parameter[0] & 128U) != 0U) {
#line 2225
      *(mb + 10UL) = (uint16_t )((unsigned int )*(mb + 10UL) | 128U);
    } else {

    }
  }
#line 2230
  dma_pool_free(ha->s_dma_pool, (void *)lg, lg_dma);
#line 2232
  return (rval);
}
}
#line 2257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_login_fabric(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                         uint8_t area , uint8_t al_pa , uint16_t *mb , uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 2262
  mcp = & mc;
#line 2263
  ha = vha->hw;
#line 2265
  ql_dbg(536903680U, vha, 4199, "Entered %s.\n", "qla2x00_login_fabric");
#line 2268
  mcp->mb[0] = 111U;
#line 2269
  mcp->out_mb = 15U;
#line 2270
  if ((int )ha->device_type < 0) {
#line 2271
    mcp->mb[1] = loop_id;
#line 2272
    mcp->mb[10] = (uint16_t )opt;
#line 2273
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 2275
    mcp->mb[1] = (uint16_t )((int )((short )((int )loop_id << 8)) | (int )((short )opt));
  }
#line 2277
  mcp->mb[2] = (uint16_t )domain;
#line 2278
  mcp->mb[3] = (uint16_t )((int )((short )((int )area << 8)) | (int )((short )al_pa));
#line 2280
  mcp->in_mb = 199U;
#line 2281
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2282
  mcp->flags = 0U;
#line 2283
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2286
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 2287
    *mb = mcp->mb[0];
#line 2288
    *(mb + 1UL) = mcp->mb[1];
#line 2289
    *(mb + 2UL) = mcp->mb[2];
#line 2290
    *(mb + 6UL) = mcp->mb[6];
#line 2291
    *(mb + 7UL) = mcp->mb[7];
#line 2293
    *(mb + 10UL) = 0U;
  } else {

  }
#line 2296
  if (rval != 0) {
#line 2303
    if (((((unsigned int )mcp->mb[0] == 16385U || (unsigned int )mcp->mb[0] == 16386U) || (unsigned int )mcp->mb[0] == 16387U) || (unsigned int )mcp->mb[0] == 16389U) || (unsigned int )mcp->mb[0] == 16390U) {
#line 2306
      rval = 0;
    } else {

    }
#line 2309
    ql_dbg(536870912U, vha, 4200, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 2314
    ql_dbg(536903680U, vha, 4201, "Done %s.\n", "qla2x00_login_fabric");
  }
#line 2318
  return (rval);
}
}
#line 2338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_login_local_device(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t *mb_ret ,
                               uint8_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2343
  mcp = & mc;
#line 2344
  ha = vha->hw;
#line 2346
  ql_dbg(536903680U, vha, 4202, "Entered %s.\n", "qla2x00_login_local_device");
#line 2349
  if ((ha->device_type & 134217728U) != 0U) {
#line 2350
    tmp = qla24xx_login_fabric(vha, (int )fcport->loop_id, (int )fcport->d_id.b.domain,
                               (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
                               mb_ret, (int )opt);
#line 2350
    return (tmp);
  } else {

  }
#line 2354
  mcp->mb[0] = 116U;
#line 2355
  if ((int )ha->device_type < 0) {
#line 2356
    mcp->mb[1] = fcport->loop_id;
  } else {
#line 2358
    mcp->mb[1] = (int )fcport->loop_id << 8U;
  }
#line 2359
  mcp->mb[2] = (uint16_t )opt;
#line 2360
  mcp->out_mb = 7U;
#line 2361
  mcp->in_mb = 195U;
#line 2362
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2363
  mcp->flags = 0U;
#line 2364
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2367
  if ((unsigned long )mb_ret != (unsigned long )((uint16_t *)0U)) {
#line 2368
    *mb_ret = mcp->mb[0];
#line 2369
    *(mb_ret + 1UL) = mcp->mb[1];
#line 2370
    *(mb_ret + 6UL) = mcp->mb[6];
#line 2371
    *(mb_ret + 7UL) = mcp->mb[7];
  } else {

  }
#line 2374
  if (rval != 0) {
#line 2381
    if ((unsigned int )mcp->mb[0] == 16389U || (unsigned int )mcp->mb[0] == 16390U) {
#line 2382
      rval = 0;
    } else {

    }
#line 2384
    ql_dbg(536870912U, vha, 4203, "Failed=%x mb[0]=%x mb[1]=%x mb[6]=%x mb[7]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[6], (int )mcp->mb[7]);
  } else {
#line 2389
    ql_dbg(536903680U, vha, 4204, "Done %s.\n", "qla2x00_login_local_device");
  }
#line 2393
  return (rval);
}
}
#line 2397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) 
{ 
  int rval ;
  struct logio_entry_24xx *lg ;
  dma_addr_t lg_dma ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 2403
  ha = vha->hw;
#line 2407
  ql_dbg(536903680U, vha, 4205, "Entered %s.\n", "qla24xx_fabric_logout");
#line 2410
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & lg_dma);
#line 2410
  lg = (struct logio_entry_24xx *)tmp;
#line 2411
  if ((unsigned long )lg == (unsigned long )((struct logio_entry_24xx *)0)) {
#line 2412
    ql_log(1U, vha, 4206, "Failed to allocate logout IOCB.\n");
#line 2414
    return (259);
  } else {

  }
#line 2416
  memset((void *)lg, 0, 64UL);
#line 2418
  if (ql2xmaxqueues > 1) {
#line 2419
    req = *(ha->req_q_map);
  } else {
#line 2421
    req = vha->req;
  }
#line 2422
  rsp = req->rsp;
#line 2423
  lg->entry_type = 82U;
#line 2424
  lg->entry_count = 1U;
#line 2425
  lg->handle = ((unsigned int )req->id << 16) | lg->handle;
#line 2426
  lg->nport_handle = loop_id;
#line 2427
  lg->control_flags = 152U;
#line 2430
  lg->port_id[0] = al_pa;
#line 2431
  lg->port_id[1] = area;
#line 2432
  lg->port_id[2] = domain;
#line 2433
  lg->vp_index = (uint8_t )vha->vp_idx;
#line 2434
  rval = qla2x00_issue_iocb_timeout(vha, (void *)lg, lg_dma, 0UL, (uint32_t )(((int )((unsigned int )ha->r_a_tov / 10U) + 1) * 2));
#line 2436
  if (rval != 0) {
#line 2437
    ql_dbg(536870912U, vha, 4207, "Failed to issue logout IOCB (%x).\n", rval);
  } else
#line 2439
  if ((unsigned int )lg->entry_status != 0U) {
#line 2440
    ql_dbg(536870912U, vha, 4208, "Failed to complete IOCB -- error status (%x).\n",
           (int )lg->entry_status);
#line 2443
    rval = 258;
  } else
#line 2444
  if ((unsigned int )lg->comp_status != 0U) {
#line 2445
    ql_dbg(536870912U, vha, 4209, "Failed to complete IOCB -- completion status (%x) ioparam=%x/%x.\n",
           (int )lg->comp_status, lg->io_parameter[0], lg->io_parameter[1]);
  } else {
#line 2452
    ql_dbg(536903680U, vha, 4210, "Done %s.\n", "qla24xx_fabric_logout");
  }
#line 2456
  dma_pool_free(ha->s_dma_pool, (void *)lg, lg_dma);
#line 2458
  return (rval);
}
}
#line 2478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_fabric_logout(scsi_qla_host_t *vha , uint16_t loop_id , uint8_t domain ,
                          uint8_t area , uint8_t al_pa ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2483
  mcp = & mc;
#line 2485
  ql_dbg(536903680U, vha, 4211, "Entered %s.\n", "qla2x00_fabric_logout");
#line 2488
  mcp->mb[0] = 113U;
#line 2489
  mcp->out_mb = 3U;
#line 2490
  if ((int )(vha->hw)->device_type < 0) {
#line 2491
    mcp->mb[1] = loop_id;
#line 2492
    mcp->mb[10] = 0U;
#line 2493
    mcp->out_mb = mcp->out_mb | 1024U;
  } else {
#line 2495
    mcp->mb[1] = (int )loop_id << 8U;
  }
#line 2498
  mcp->in_mb = 3U;
#line 2499
  mcp->tov = 30U;
#line 2500
  mcp->flags = 0U;
#line 2501
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2503
  if (rval != 0) {
#line 2505
    ql_dbg(536870912U, vha, 4212, "Failed=%x mb[1]=%x.\n", rval, (int )mcp->mb[1]);
  } else {
#line 2509
    ql_dbg(536903680U, vha, 4213, "Done %s.\n", "qla2x00_fabric_logout");
  }
#line 2513
  return (rval);
}
}
#line 2532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_full_login_lip(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2536
  mcp = & mc;
#line 2538
  ql_dbg(536903680U, vha, 4214, "Entered %s.\n", "qla2x00_full_login_lip");
#line 2541
  mcp->mb[0] = 114U;
#line 2542
  mcp->mb[1] = ((vha->hw)->device_type & 134217728U) != 0U ? 8U : 0U;
#line 2543
  mcp->mb[2] = 0U;
#line 2544
  mcp->mb[3] = 0U;
#line 2545
  mcp->out_mb = 15U;
#line 2546
  mcp->in_mb = 1U;
#line 2547
  mcp->tov = 30U;
#line 2548
  mcp->flags = 0U;
#line 2549
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2551
  if (rval != 0) {
#line 2553
    ql_dbg(536870912U, vha, 4215, "Failed=%x.\n", rval);
  } else {
#line 2556
    ql_dbg(536903680U, vha, 4216, "Done %s.\n", "qla2x00_full_login_lip");
  }
#line 2560
  return (rval);
}
}
#line 2576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_id_list(scsi_qla_host_t *vha , void *id_list , dma_addr_t id_list_dma ,
                        uint16_t *entries ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2581
  mcp = & mc;
#line 2583
  ql_dbg(536903680U, vha, 4217, "Entered %s.\n", "qla2x00_get_id_list");
#line 2586
  if ((unsigned long )id_list == (unsigned long )((void *)0)) {
#line 2587
    return (258);
  } else {

  }
#line 2589
  mcp->mb[0] = 124U;
#line 2590
  mcp->out_mb = 1U;
#line 2591
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 2592
    mcp->mb[2] = (unsigned short )((unsigned int )id_list_dma >> 16);
#line 2593
    mcp->mb[3] = (unsigned short )id_list_dma;
#line 2594
    mcp->mb[6] = (unsigned short )((unsigned int )(id_list_dma >> 32ULL) >> 16);
#line 2595
    mcp->mb[7] = (unsigned short )(id_list_dma >> 32ULL);
#line 2596
    mcp->mb[8] = 0U;
#line 2597
    mcp->mb[9] = vha->vp_idx;
#line 2598
    mcp->out_mb = mcp->out_mb | 972U;
  } else {
#line 2600
    mcp->mb[1] = (unsigned short )((unsigned int )id_list_dma >> 16);
#line 2601
    mcp->mb[2] = (unsigned short )id_list_dma;
#line 2602
    mcp->mb[3] = (unsigned short )((unsigned int )(id_list_dma >> 32ULL) >> 16);
#line 2603
    mcp->mb[6] = (unsigned short )(id_list_dma >> 32ULL);
#line 2604
    mcp->out_mb = mcp->out_mb | 78U;
  }
#line 2606
  mcp->in_mb = 3U;
#line 2607
  mcp->tov = 30U;
#line 2608
  mcp->flags = 0U;
#line 2609
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2611
  if (rval != 0) {
#line 2613
    ql_dbg(536870912U, vha, 4218, "Failed=%x.\n", rval);
  } else {
#line 2615
    *entries = mcp->mb[1];
#line 2616
    ql_dbg(536903680U, vha, 4219, "Done %s.\n", "qla2x00_get_id_list");
  }
#line 2620
  return (rval);
}
}
#line 2637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_resource_cnts(scsi_qla_host_t *vha , uint16_t *cur_xchg_cnt , uint16_t *orig_xchg_cnt ,
                              uint16_t *cur_iocb_cnt , uint16_t *orig_iocb_cnt , uint16_t *max_npiv_vports ,
                              uint16_t *max_fcfs ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 2643
  mcp = & mc;
#line 2645
  ql_dbg(536903680U, vha, 4220, "Entered %s.\n", "qla2x00_get_resource_cnts");
#line 2648
  mcp->mb[0] = 66U;
#line 2649
  mcp->out_mb = 1U;
#line 2650
  mcp->in_mb = 3279U;
#line 2651
  if (((vha->hw)->device_type & 8192U) != 0U || (((vha->hw)->device_type & 32768U) != 0U || ((vha->hw)->device_type & 65536U) != 0U)) {
#line 2652
    mcp->in_mb = mcp->in_mb | 4096U;
  } else {

  }
#line 2653
  mcp->tov = 30U;
#line 2654
  mcp->flags = 0U;
#line 2655
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2657
  if (rval != 0) {
#line 2659
    ql_dbg(536870912U, vha, 4221, "Failed mb[0]=%x.\n", (int )mcp->mb[0]);
  } else {
#line 2662
    ql_dbg(536903680U, vha, 4222, "Done %s mb1=%x mb2=%x mb3=%x mb6=%x mb7=%x mb10=%x mb11=%x mb12=%x.\n",
           "qla2x00_get_resource_cnts", (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[6], (int )mcp->mb[7], (int )mcp->mb[10], (int )mcp->mb[11],
           (int )mcp->mb[12]);
#line 2668
    if ((unsigned long )cur_xchg_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2669
      *cur_xchg_cnt = mcp->mb[3];
    } else {

    }
#line 2670
    if ((unsigned long )orig_xchg_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2671
      *orig_xchg_cnt = mcp->mb[6];
    } else {

    }
#line 2672
    if ((unsigned long )cur_iocb_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2673
      *cur_iocb_cnt = mcp->mb[7];
    } else {

    }
#line 2674
    if ((unsigned long )orig_iocb_cnt != (unsigned long )((uint16_t *)0U)) {
#line 2675
      *orig_iocb_cnt = mcp->mb[10];
    } else {

    }
#line 2676
    if (*((unsigned long *)vha->hw + 2UL) != 0UL && (unsigned long )max_npiv_vports != (unsigned long )((uint16_t *)0U)) {
#line 2677
      *max_npiv_vports = mcp->mb[11];
    } else {

    }
#line 2678
    if ((((vha->hw)->device_type & 8192U) != 0U || (((vha->hw)->device_type & 32768U) != 0U || ((vha->hw)->device_type & 65536U) != 0U)) && (unsigned long )max_fcfs != (unsigned long )((uint16_t *)0U)) {
#line 2679
      *max_fcfs = mcp->mb[12];
    } else {

    }
  }
#line 2682
  return (rval);
}
}
#line 2700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_fcal_position_map(scsi_qla_host_t *vha , char *pos_map ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  char *pmap ;
  dma_addr_t pmap_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2704
  mcp = & mc;
#line 2707
  ha = vha->hw;
#line 2709
  ql_dbg(536903680U, vha, 4223, "Entered %s.\n", "qla2x00_get_fcal_position_map");
#line 2712
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & pmap_dma);
#line 2712
  pmap = (char *)tmp;
#line 2713
  if ((unsigned long )pmap == (unsigned long )((char *)0)) {
#line 2714
    ql_log(1U, vha, 4224, "Memory alloc failed.\n");
#line 2716
    return (259);
  } else {

  }
#line 2718
  memset((void *)pmap, 0, 128UL);
#line 2720
  mcp->mb[0] = 99U;
#line 2721
  mcp->mb[2] = (unsigned short )((unsigned int )pmap_dma >> 16);
#line 2722
  mcp->mb[3] = (unsigned short )pmap_dma;
#line 2723
  mcp->mb[6] = (unsigned short )((unsigned int )(pmap_dma >> 32ULL) >> 16);
#line 2724
  mcp->mb[7] = (unsigned short )(pmap_dma >> 32ULL);
#line 2725
  mcp->out_mb = 205U;
#line 2726
  mcp->in_mb = 3U;
#line 2727
  mcp->buf_size = 128L;
#line 2728
  mcp->flags = 1U;
#line 2729
  mcp->tov = (uint32_t )((int )ha->login_timeout * 2 + (int )((unsigned int )ha->login_timeout / 2U));
#line 2730
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2732
  if (rval == 0) {
#line 2733
    ql_dbg(537001984U, vha, 4225, "mb0/mb1=%x/%X FC/AL position map size (%x).\n",
           (int )mcp->mb[0], (int )mcp->mb[1], (unsigned int )*pmap);
#line 2736
    ql_dump_buffer(537001984U, vha, 4381, (uint8_t *)pmap, (uint32_t )((int )*pmap + 1));
#line 2739
    if ((unsigned long )pos_map != (unsigned long )((char *)0)) {
#line 2740
      __len = 128UL;
#line 2740
      if (__len > 63UL) {
#line 2740
        __ret = __memcpy((void *)pos_map, (void const   *)pmap, __len);
      } else {
#line 2740
        __ret = __builtin_memcpy((void *)pos_map, (void const   *)pmap, __len);
      }
    } else {

    }
  } else {

  }
#line 2742
  dma_pool_free(ha->s_dma_pool, (void *)pmap, pmap_dma);
#line 2744
  if (rval != 0) {
#line 2745
    ql_dbg(536870912U, vha, 4226, "Failed=%x.\n", rval);
  } else {
#line 2747
    ql_dbg(536903680U, vha, 4227, "Done %s.\n", "qla2x00_get_fcal_position_map");
  }
#line 2751
  return (rval);
}
}
#line 2768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_link_status(scsi_qla_host_t *vha , uint16_t loop_id , struct link_statistics *stats ,
                            dma_addr_t stats_dma ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint32_t *siter ;
  uint32_t *diter ;
  uint32_t dwords ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2773
  mcp = & mc;
#line 2775
  ha = vha->hw;
#line 2777
  ql_dbg(536903680U, vha, 4228, "Entered %s.\n", "qla2x00_get_link_status");
#line 2780
  mcp->mb[0] = 107U;
#line 2781
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 2782
  mcp->mb[3] = (unsigned short )stats_dma;
#line 2783
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 2784
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 2785
  mcp->out_mb = 205U;
#line 2786
  mcp->in_mb = 1U;
#line 2787
  if ((ha->device_type & 134217728U) != 0U) {
#line 2788
    mcp->mb[1] = loop_id;
#line 2789
    mcp->mb[4] = 0U;
#line 2790
    mcp->mb[10] = 0U;
#line 2791
    mcp->out_mb = mcp->out_mb | 1042U;
#line 2792
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 2793
  if ((int )ha->device_type < 0) {
#line 2794
    mcp->mb[1] = loop_id;
#line 2795
    mcp->mb[10] = 0U;
#line 2796
    mcp->out_mb = mcp->out_mb | 1026U;
  } else {
#line 2798
    mcp->mb[1] = (int )loop_id << 8U;
#line 2799
    mcp->out_mb = mcp->out_mb | 2U;
  }
#line 2801
  mcp->tov = 30U;
#line 2802
  mcp->flags = 4U;
#line 2803
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2805
  if (rval == 0) {
#line 2806
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 2807
      ql_dbg(536870912U, vha, 4229, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
#line 2809
      rval = 258;
    } else {
#line 2812
      ql_dbg(536903680U, vha, 4230, "Done %s.\n", "qla2x00_get_link_status");
#line 2814
      dwords = 7U;
#line 2815
      diter = & stats->link_fail_cnt;
#line 2815
      siter = diter;
#line 2816
      goto ldv_61159;
      ldv_61158: 
#line 2817
      tmp = diter;
#line 2817
      diter = diter + 1;
#line 2817
      tmp___0 = siter;
#line 2817
      siter = siter + 1;
#line 2817
      *tmp = *tmp___0;
      ldv_61159: 
#line 2816
      tmp___1 = dwords;
#line 2816
      dwords = dwords - 1U;
#line 2816
      if (tmp___1 != 0U) {
#line 2818
        goto ldv_61158;
      } else {

      }

    }
  } else {
#line 2821
    ql_dbg(536870912U, vha, 4231, "Failed=%x.\n", rval);
  }
#line 2824
  return (rval);
}
}
#line 2828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_get_isp_stats(scsi_qla_host_t *vha , struct link_statistics *stats , dma_addr_t stats_dma ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint32_t *siter ;
  uint32_t *diter ;
  uint32_t dwords ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 2833
  mcp = & mc;
#line 2836
  ql_dbg(536903680U, vha, 4232, "Entered %s.\n", "qla24xx_get_isp_stats");
#line 2839
  mcp->mb[0] = 109U;
#line 2840
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 2841
  mcp->mb[3] = (unsigned short )stats_dma;
#line 2842
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 2843
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 2844
  mcp->mb[8] = 39U;
#line 2845
  mcp->mb[9] = vha->vp_idx;
#line 2846
  mcp->mb[10] = 0U;
#line 2847
  mcp->out_mb = 1997U;
#line 2848
  mcp->in_mb = 7U;
#line 2849
  mcp->tov = 30U;
#line 2850
  mcp->flags = 4U;
#line 2851
  rval = qla2x00_mailbox_command(vha, mcp);
#line 2853
  if (rval == 0) {
#line 2854
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 2855
      ql_dbg(536870912U, vha, 4233, "Failed mb[0]=%x.\n", (int )mcp->mb[0]);
#line 2857
      rval = 258;
    } else {
#line 2859
      ql_dbg(536903680U, vha, 4234, "Done %s.\n", "qla24xx_get_isp_stats");
#line 2862
      dwords = 39U;
#line 2863
      diter = & stats->link_fail_cnt;
#line 2863
      siter = diter;
#line 2864
      goto ldv_61174;
      ldv_61173: 
#line 2865
      tmp = diter;
#line 2865
      diter = diter + 1;
#line 2865
      tmp___0 = siter;
#line 2865
      siter = siter + 1;
#line 2865
      *tmp = *tmp___0;
      ldv_61174: 
#line 2864
      tmp___1 = dwords;
#line 2864
      dwords = dwords - 1U;
#line 2864
      if (tmp___1 != 0U) {
#line 2866
        goto ldv_61173;
      } else {

      }

    }
  } else {
#line 2869
    ql_dbg(536870912U, vha, 4235, "Failed=%x.\n", rval);
  }
#line 2872
  return (rval);
}
}
#line 2876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_abort_command(srb_t *sp ) 
{ 
  int rval ;
  unsigned long flags ;
  struct abort_entry_24xx *abt ;
  dma_addr_t abt_dma ;
  uint32_t handle ;
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 2879
  flags = 0UL;
#line 2884
  fcport = sp->fcport;
#line 2885
  vha = fcport->vha;
#line 2886
  ha = vha->hw;
#line 2887
  req = vha->req;
#line 2889
  ql_dbg(536903680U, vha, 4236, "Entered %s.\n", "qla24xx_abort_command");
#line 2892
  tmp = spinlock_check(& ha->hardware_lock);
#line 2892
  flags = _raw_spin_lock_irqsave(tmp);
#line 2893
  handle = 1U;
#line 2893
  goto ldv_61194;
  ldv_61193: ;
#line 2894
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 2895
    goto ldv_61192;
  } else {

  }
#line 2893
  handle = handle + 1U;
  ldv_61194: ;
#line 2893
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2895
    goto ldv_61193;
  } else {

  }
  ldv_61192: 
#line 2897
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2898
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2900
    return (258);
  } else {

  }
#line 2903
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & abt_dma);
#line 2903
  abt = (struct abort_entry_24xx *)tmp___0;
#line 2904
  if ((unsigned long )abt == (unsigned long )((struct abort_entry_24xx *)0)) {
#line 2905
    ql_log(1U, vha, 4237, "Failed to allocate abort IOCB.\n");
#line 2907
    return (259);
  } else {

  }
#line 2909
  memset((void *)abt, 0, 64UL);
#line 2911
  abt->entry_type = 51U;
#line 2912
  abt->entry_count = 1U;
#line 2913
  abt->handle = ((unsigned int )req->id << 16) | abt->handle;
#line 2914
  abt->nport_handle = fcport->loop_id;
#line 2915
  abt->handle_to_abort = ((unsigned int )req->id << 16) | handle;
#line 2916
  abt->port_id[0] = fcport->d_id.b.al_pa;
#line 2917
  abt->port_id[1] = fcport->d_id.b.area;
#line 2918
  abt->port_id[2] = fcport->d_id.b.domain;
#line 2919
  abt->vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2921
  abt->req_que_no = req->id;
#line 2923
  rval = qla2x00_issue_iocb(vha, (void *)abt, abt_dma, 0UL);
#line 2924
  if (rval != 0) {
#line 2925
    ql_dbg(536870912U, vha, 4238, "Failed to issue IOCB (%x).\n", rval);
  } else
#line 2927
  if ((unsigned int )abt->entry_status != 0U) {
#line 2928
    ql_dbg(536870912U, vha, 4239, "Failed to complete IOCB -- error status (%x).\n",
           (int )abt->entry_status);
#line 2931
    rval = 258;
  } else
#line 2932
  if ((unsigned int )abt->nport_handle != 0U) {
#line 2933
    ql_dbg(536870912U, vha, 4240, "Failed to complete IOCB -- completion status (%x).\n",
           (int )abt->nport_handle);
#line 2936
    rval = 258;
  } else {
#line 2938
    ql_dbg(536903680U, vha, 4241, "Done %s.\n", "qla24xx_abort_command");
  }
#line 2942
  dma_pool_free(ha->s_dma_pool, (void *)abt, abt_dma);
#line 2944
  return (rval);
}
}
#line 2955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
static int __qla24xx_issue_tmf(char *name , uint32_t type , struct fc_port *fcport ,
                               unsigned int l , int tag ) 
{ 
  int rval ;
  int rval2 ;
  struct tsk_mgmt_cmd *tsk ;
  struct sts_entry_24xx *sts ;
  dma_addr_t tsk_dma ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  void *tmp ;

  {
#line 2967
  vha = fcport->vha;
#line 2968
  ha = vha->hw;
#line 2969
  req = vha->req;
#line 2971
  ql_dbg(536903680U, vha, 4242, "Entered %s.\n", "__qla24xx_issue_tmf");
#line 2974
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2975
    rsp = *(ha->rsp_q_map + ((unsigned long )tag + 1UL));
  } else {
#line 2977
    rsp = req->rsp;
  }
#line 2978
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & tsk_dma);
#line 2978
  tsk = (struct tsk_mgmt_cmd *)tmp;
#line 2979
  if ((unsigned long )tsk == (unsigned long )((struct tsk_mgmt_cmd *)0)) {
#line 2980
    ql_log(1U, vha, 4243, "Failed to allocate task management IOCB.\n");
#line 2982
    return (259);
  } else {

  }
#line 2984
  memset((void *)tsk, 0, 64UL);
#line 2986
  tsk->p.tsk.entry_type = 20U;
#line 2987
  tsk->p.tsk.entry_count = 1U;
#line 2988
  tsk->p.tsk.handle = ((unsigned int )req->id << 16) | tsk->p.tsk.handle;
#line 2989
  tsk->p.tsk.nport_handle = fcport->loop_id;
#line 2990
  tsk->p.tsk.timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2991
  tsk->p.tsk.control_flags = type;
#line 2992
  tsk->p.tsk.port_id[0] = fcport->d_id.b.al_pa;
#line 2993
  tsk->p.tsk.port_id[1] = fcport->d_id.b.area;
#line 2994
  tsk->p.tsk.port_id[2] = fcport->d_id.b.domain;
#line 2995
  tsk->p.tsk.vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2996
  if (type == 16U) {
#line 2997
    int_to_scsilun(l, & tsk->p.tsk.lun);
#line 2998
    host_to_fcp_swap((uint8_t *)(& tsk->p.tsk.lun), 8U);
  } else {

  }
#line 3002
  sts = & tsk->p.sts;
#line 3003
  rval = qla2x00_issue_iocb(vha, (void *)tsk, tsk_dma, 0UL);
#line 3004
  if (rval != 0) {
#line 3005
    ql_dbg(536870912U, vha, 4244, "Failed to issue %s reset IOCB (%x).\n", name, rval);
  } else
#line 3007
  if ((unsigned int )sts->entry_status != 0U) {
#line 3008
    ql_dbg(536870912U, vha, 4245, "Failed to complete IOCB -- error status (%x).\n",
           (int )sts->entry_status);
#line 3011
    rval = 258;
  } else
#line 3012
  if ((unsigned int )sts->comp_status != 0U) {
#line 3014
    ql_dbg(536870912U, vha, 4246, "Failed to complete IOCB -- completion status (%x).\n",
           (int )sts->comp_status);
#line 3017
    rval = 258;
  } else
#line 3018
  if (((int )sts->scsi_status & 256) != 0) {
#line 3020
    if (sts->rsp_data_len <= 3U) {
#line 3021
      ql_dbg(536903680U, vha, 4247, "Ignoring inconsistent data length -- not enough response info (%d).\n",
             sts->rsp_data_len);
    } else
#line 3025
    if ((unsigned int )sts->data[3] != 0U) {
#line 3026
      ql_dbg(536870912U, vha, 4248, "Failed to complete IOCB -- response (%x).\n",
             (int )sts->data[3]);
#line 3029
      rval = 258;
    } else {

    }
  } else {

  }
#line 3034
  rval2 = qla2x00_marker(vha, req, rsp, (int )fcport->loop_id, (int )((uint16_t )l),
                         type != 16U);
#line 3036
  if (rval2 != 0) {
#line 3037
    ql_dbg(536870912U, vha, 4249, "Failed to issue marker IOCB (%x).\n", rval2);
  } else {
#line 3040
    ql_dbg(536903680U, vha, 4250, "Done %s.\n", "__qla24xx_issue_tmf");
  }
#line 3044
  dma_pool_free(ha->s_dma_pool, (void *)tsk, tsk_dma);
#line 3046
  return (rval);
}
}
#line 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_abort_target(struct fc_port *fcport , unsigned int l , int tag ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 3052
  ha = (fcport->vha)->hw;
#line 3054
  if (ql2xasynctmfenable != 0 && (ha->device_type & 134217728U) != 0U) {
#line 3055
    tmp = qla2x00_async_tm_cmd(fcport, 2U, l, (uint32_t )tag);
#line 3055
    return (tmp);
  } else {

  }
#line 3057
  tmp___0 = __qla24xx_issue_tmf((char *)"Target", 2U, fcport, l, tag);
#line 3057
  return (tmp___0);
}
}
#line 3061 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_lun_reset(struct fc_port *fcport , unsigned int l , int tag ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 3063
  ha = (fcport->vha)->hw;
#line 3065
  if (ql2xasynctmfenable != 0 && (ha->device_type & 134217728U) != 0U) {
#line 3066
    tmp = qla2x00_async_tm_cmd(fcport, 16U, l, (uint32_t )tag);
#line 3066
    return (tmp);
  } else {

  }
#line 3068
  tmp___0 = __qla24xx_issue_tmf((char *)"Lun", 16U, fcport, l, tag);
#line 3068
  return (tmp___0);
}
}
#line 3072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_system_error(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 3076
  mcp = & mc;
#line 3077
  ha = vha->hw;
#line 3079
  if ((((((ha->device_type & 4U) == 0U && (ha->device_type & 8U) == 0U) && (ha->device_type & 16U) == 0U) && (ha->device_type & 32U) == 0U) && (ha->device_type & 64U) == 0U) && (ha->device_type & 134217728U) == 0U) {
#line 3080
    return (258);
  } else {

  }
#line 3082
  ql_dbg(536903680U, vha, 4251, "Entered %s.\n", "qla2x00_system_error");
#line 3085
  mcp->mb[0] = 42U;
#line 3086
  mcp->out_mb = 1U;
#line 3087
  mcp->in_mb = 1U;
#line 3088
  mcp->tov = 5U;
#line 3089
  mcp->flags = 0U;
#line 3090
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3092
  if (rval != 0) {
#line 3093
    ql_dbg(536870912U, vha, 4252, "Failed=%x.\n", rval);
  } else {
#line 3095
    ql_dbg(536903680U, vha, 4253, "Done %s.\n", "qla2x00_system_error");
  }
#line 3099
  return (rval);
}
}
#line 3109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_set_serdes_params(scsi_qla_host_t *vha , uint16_t sw_em_1g , uint16_t sw_em_2g ,
                              uint16_t sw_em_4g ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3114
  mcp = & mc;
#line 3116
  ql_dbg(536903680U, vha, 4254, "Entered %s.\n", "qla2x00_set_serdes_params");
#line 3119
  mcp->mb[0] = 16U;
#line 3120
  mcp->mb[1] = 1U;
#line 3121
  mcp->mb[2] = (uint16_t )((unsigned int )sw_em_1g | 32768U);
#line 3122
  mcp->mb[3] = (uint16_t )((unsigned int )sw_em_2g | 32768U);
#line 3123
  mcp->mb[4] = (uint16_t )((unsigned int )sw_em_4g | 32768U);
#line 3124
  mcp->out_mb = 31U;
#line 3125
  mcp->in_mb = 1U;
#line 3126
  mcp->tov = 30U;
#line 3127
  mcp->flags = 0U;
#line 3128
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3130
  if (rval != 0) {
#line 3132
    ql_dbg(536870912U, vha, 4255, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3136
    ql_dbg(536903680U, vha, 4256, "Done %s.\n", "qla2x00_set_serdes_params");
  }
#line 3140
  return (rval);
}
}
#line 3144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_stop_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3148
  mcp = & mc;
#line 3150
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3151
    return (258);
  } else {

  }
#line 3153
  ql_dbg(536903680U, vha, 4257, "Entered %s.\n", "qla2x00_stop_firmware");
#line 3156
  mcp->mb[0] = 20U;
#line 3157
  mcp->mb[1] = 0U;
#line 3158
  mcp->out_mb = 3U;
#line 3159
  mcp->in_mb = 1U;
#line 3160
  mcp->tov = 5U;
#line 3161
  mcp->flags = 0U;
#line 3162
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3164
  if (rval != 0) {
#line 3165
    ql_dbg(536870912U, vha, 4258, "Failed=%x.\n", rval);
#line 3166
    if ((unsigned int )mcp->mb[0] == 16385U) {
#line 3167
      rval = 1;
    } else {

    }
  } else {
#line 3169
    ql_dbg(536903680U, vha, 4259, "Done %s.\n", "qla2x00_stop_firmware");
  }
#line 3173
  return (rval);
}
}
#line 3177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_enable_eft_trace(scsi_qla_host_t *vha , dma_addr_t eft_dma , uint16_t buffers ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3182
  mcp = & mc;
#line 3184
  ql_dbg(536903680U, vha, 4260, "Entered %s.\n", "qla2x00_enable_eft_trace");
#line 3187
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3188
    return (258);
  } else {

  }
#line 3190
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3190
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3190
  if (tmp___0 != 0L) {
#line 3191
    return (258);
  } else {

  }
#line 3193
  mcp->mb[0] = 39U;
#line 3194
  mcp->mb[1] = 4U;
#line 3195
  mcp->mb[2] = (unsigned short )eft_dma;
#line 3196
  mcp->mb[3] = (unsigned short )((unsigned int )eft_dma >> 16);
#line 3197
  mcp->mb[4] = (unsigned short )(eft_dma >> 32ULL);
#line 3198
  mcp->mb[5] = (unsigned short )((unsigned int )(eft_dma >> 32ULL) >> 16);
#line 3199
  mcp->mb[6] = buffers;
#line 3200
  mcp->mb[7] = 0U;
#line 3201
  mcp->out_mb = 255U;
#line 3202
  mcp->in_mb = 3U;
#line 3203
  mcp->tov = 30U;
#line 3204
  mcp->flags = 0U;
#line 3205
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3206
  if (rval != 0) {
#line 3207
    ql_dbg(536870912U, vha, 4261, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3211
    ql_dbg(536903680U, vha, 4262, "Done %s.\n", "qla2x00_enable_eft_trace");
  }
#line 3215
  return (rval);
}
}
#line 3219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_disable_eft_trace(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3223
  mcp = & mc;
#line 3225
  ql_dbg(536903680U, vha, 4263, "Entered %s.\n", "qla2x00_disable_eft_trace");
#line 3228
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3229
    return (258);
  } else {

  }
#line 3231
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3231
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3231
  if (tmp___0 != 0L) {
#line 3232
    return (258);
  } else {

  }
#line 3234
  mcp->mb[0] = 39U;
#line 3235
  mcp->mb[1] = 5U;
#line 3236
  mcp->out_mb = 3U;
#line 3237
  mcp->in_mb = 3U;
#line 3238
  mcp->tov = 30U;
#line 3239
  mcp->flags = 0U;
#line 3240
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3241
  if (rval != 0) {
#line 3242
    ql_dbg(536870912U, vha, 4264, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3246
    ql_dbg(536903680U, vha, 4265, "Done %s.\n", "qla2x00_disable_eft_trace");
  }
#line 3250
  return (rval);
}
}
#line 3254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_enable_fce_trace(scsi_qla_host_t *vha , dma_addr_t fce_dma , uint16_t buffers ,
                             uint16_t *mb , uint32_t *dwords ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 3259
  mcp = & mc;
#line 3261
  ql_dbg(536903680U, vha, 4266, "Entered %s.\n", "qla2x00_enable_fce_trace");
#line 3264
  if ((((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 8192U) == 0U) && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) {
#line 3266
    return (258);
  } else {

  }
#line 3268
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3268
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3268
  if (tmp___0 != 0L) {
#line 3269
    return (258);
  } else {

  }
#line 3271
  mcp->mb[0] = 39U;
#line 3272
  mcp->mb[1] = 8U;
#line 3273
  mcp->mb[2] = (unsigned short )fce_dma;
#line 3274
  mcp->mb[3] = (unsigned short )((unsigned int )fce_dma >> 16);
#line 3275
  mcp->mb[4] = (unsigned short )(fce_dma >> 32ULL);
#line 3276
  mcp->mb[5] = (unsigned short )((unsigned int )(fce_dma >> 32ULL) >> 16);
#line 3277
  mcp->mb[6] = buffers;
#line 3278
  mcp->mb[7] = 0U;
#line 3279
  mcp->mb[8] = 0U;
#line 3280
  mcp->mb[9] = 2112U;
#line 3281
  mcp->mb[10] = 2112U;
#line 3282
  mcp->out_mb = 2047U;
#line 3284
  mcp->in_mb = 127U;
#line 3285
  mcp->tov = 30U;
#line 3286
  mcp->flags = 0U;
#line 3287
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3288
  if (rval != 0) {
#line 3289
    ql_dbg(536870912U, vha, 4267, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3293
    ql_dbg(536903680U, vha, 4268, "Done %s.\n", "qla2x00_enable_fce_trace");
#line 3296
    if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3297
      __len = 16UL;
#line 3297
      if (__len > 63UL) {
#line 3297
        __ret = __memcpy((void *)mb, (void const   *)(& mcp->mb), __len);
      } else {
#line 3297
        __ret = __builtin_memcpy((void *)mb, (void const   *)(& mcp->mb), __len);
      }
    } else {

    }
#line 3298
    if ((unsigned long )dwords != (unsigned long )((uint32_t *)0U)) {
#line 3299
      *dwords = (uint32_t )buffers;
    } else {

    }
  }
#line 3302
  return (rval);
}
}
#line 3306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_disable_fce_trace(scsi_qla_host_t *vha , uint64_t *wr , uint64_t *rd ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int tmp ;
  long tmp___0 ;

  {
#line 3310
  mcp = & mc;
#line 3312
  ql_dbg(536903680U, vha, 4269, "Entered %s.\n", "qla2x00_disable_fce_trace");
#line 3315
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 3316
    return (258);
  } else {

  }
#line 3318
  tmp = pci_channel_offline((vha->hw)->pdev);
#line 3318
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3318
  if (tmp___0 != 0L) {
#line 3319
    return (258);
  } else {

  }
#line 3321
  mcp->mb[0] = 39U;
#line 3322
  mcp->mb[1] = 9U;
#line 3323
  mcp->mb[2] = 1U;
#line 3324
  mcp->out_mb = 7U;
#line 3325
  mcp->in_mb = 1023U;
#line 3327
  mcp->tov = 30U;
#line 3328
  mcp->flags = 0U;
#line 3329
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3330
  if (rval != 0) {
#line 3331
    ql_dbg(536870912U, vha, 4270, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 3335
    ql_dbg(536903680U, vha, 4271, "Done %s.\n", "qla2x00_disable_fce_trace");
#line 3338
    if ((unsigned long )wr != (unsigned long )((uint64_t *)0ULL)) {
#line 3339
      *wr = ((((unsigned long long )mcp->mb[5] << 48) | ((unsigned long long )mcp->mb[4] << 32)) | ((unsigned long long )mcp->mb[3] << 16)) | (unsigned long long )mcp->mb[2];
    } else {

    }
#line 3343
    if ((unsigned long )rd != (unsigned long )((uint64_t *)0ULL)) {
#line 3344
      *rd = ((((unsigned long long )mcp->mb[9] << 48) | ((unsigned long long )mcp->mb[8] << 32)) | ((unsigned long long )mcp->mb[7] << 16)) | (unsigned long long )mcp->mb[6];
    } else {

    }
  }
#line 3350
  return (rval);
}
}
#line 3354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t *port_speed ,
                           uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint16_t tmp ;

  {
#line 3359
  mcp = & mc;
#line 3361
  ql_dbg(536903680U, vha, 4272, "Entered %s.\n", "qla2x00_get_idma_speed");
#line 3364
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 3365
    return (258);
  } else {

  }
#line 3367
  mcp->mb[0] = 26U;
#line 3368
  mcp->mb[1] = loop_id;
#line 3369
  tmp = 0U;
#line 3369
  mcp->mb[3] = tmp;
#line 3369
  mcp->mb[2] = tmp;
#line 3370
  mcp->mb[9] = vha->vp_idx;
#line 3371
  mcp->out_mb = 527U;
#line 3372
  mcp->in_mb = 11U;
#line 3373
  mcp->tov = 30U;
#line 3374
  mcp->flags = 0U;
#line 3375
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3378
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3379
    *mb = mcp->mb[0];
#line 3380
    *(mb + 1UL) = mcp->mb[1];
#line 3381
    *(mb + 3UL) = mcp->mb[3];
  } else {

  }
#line 3384
  if (rval != 0) {
#line 3385
    ql_dbg(536870912U, vha, 4273, "Failed=%x.\n", rval);
  } else {
#line 3387
    ql_dbg(536903680U, vha, 4274, "Done %s.\n", "qla2x00_get_idma_speed");
#line 3389
    if ((unsigned long )port_speed != (unsigned long )((uint16_t *)0U)) {
#line 3390
      *port_speed = mcp->mb[3];
    } else {

    }
  }
#line 3393
  return (rval);
}
}
#line 3397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_set_idma_speed(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t port_speed ,
                           uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3402
  mcp = & mc;
#line 3404
  ql_dbg(536903680U, vha, 4275, "Entered %s.\n", "qla2x00_set_idma_speed");
#line 3407
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 3408
    return (258);
  } else {

  }
#line 3410
  mcp->mb[0] = 26U;
#line 3411
  mcp->mb[1] = loop_id;
#line 3412
  mcp->mb[2] = 1U;
#line 3413
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 3414
    mcp->mb[3] = (unsigned int )port_speed & 63U;
  } else {
#line 3416
    mcp->mb[3] = (unsigned int )port_speed & 7U;
  }
#line 3417
  mcp->mb[9] = vha->vp_idx;
#line 3418
  mcp->out_mb = 527U;
#line 3419
  mcp->in_mb = 11U;
#line 3420
  mcp->tov = 30U;
#line 3421
  mcp->flags = 0U;
#line 3422
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3425
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 3426
    *mb = mcp->mb[0];
#line 3427
    *(mb + 1UL) = mcp->mb[1];
#line 3428
    *(mb + 3UL) = mcp->mb[3];
  } else {

  }
#line 3431
  if (rval != 0) {
#line 3432
    ql_dbg(536870912U, vha, 4276, "Failed=%x.\n", rval);
  } else {
#line 3435
    ql_dbg(536903680U, vha, 4277, "Done %s.\n", "qla2x00_set_idma_speed");
  }
#line 3439
  return (rval);
}
}
#line 3443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void qla24xx_report_id_acquisition(scsi_qla_host_t *vha , struct vp_rpt_id_entry_24xx *rptid_entry ) 
{ 
  uint8_t vp_idx ;
  uint16_t stat ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  unsigned long flags ;
  int found ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3447
  stat = rptid_entry->vp_idx;
#line 3448
  ha = vha->hw;
#line 3453
  ql_dbg(536903680U, vha, 4278, "Entered %s.\n", "qla24xx_report_id_acquisition");
#line 3456
  if ((unsigned int )rptid_entry->entry_status != 0U) {
#line 3457
    return;
  } else {

  }
#line 3459
  if ((unsigned int )rptid_entry->format == 0U) {
#line 3460
    ql_dbg(536903680U, vha, 4279, "Format 0 : Number of VPs setup %d, number of VPs acquired %d.\n",
           (int )((unsigned char )((int )rptid_entry->vp_count >> 8)), (int )((unsigned char )rptid_entry->vp_count));
#line 3465
    ql_dbg(536903680U, vha, 4280, "Primary port id %02x%02x%02x.\n", (int )rptid_entry->port_id[2],
           (int )rptid_entry->port_id[1], (int )rptid_entry->port_id[0]);
  } else
#line 3469
  if ((unsigned int )rptid_entry->format == 1U) {
#line 3470
    vp_idx = (unsigned char )stat;
#line 3471
    ql_dbg(536903680U, vha, 4281, "Format 1: VP[%d] enabled - status %d - with port id %02x%02x%02x.\n",
           (int )vp_idx, (int )((unsigned char )((int )stat >> 8)), (int )rptid_entry->port_id[2],
           (int )rptid_entry->port_id[1], (int )rptid_entry->port_id[0]);
#line 3477
    vp = vha;
#line 3478
    if ((unsigned int )vp_idx == 0U && (unsigned int )((unsigned char )((int )stat >> 8)) != 1U) {
#line 3479
      goto reg_needed;
    } else {

    }
#line 3481
    if ((unsigned int )((unsigned char )((int )stat >> 8)) != 0U && (unsigned int )((unsigned char )((int )stat >> 8)) != 2U) {
#line 3482
      ql_dbg(536870912U, vha, 4282, "Could not acquire ID for VP[%d].\n", (int )vp_idx);
#line 3484
      return;
    } else {

    }
#line 3487
    found = 0;
#line 3488
    tmp = spinlock_check(& ha->vport_slock);
#line 3488
    flags = _raw_spin_lock_irqsave(tmp);
#line 3489
    __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 3489
    vp = (scsi_qla_host_t *)__mptr;
#line 3489
    goto ldv_61334;
    ldv_61333: ;
#line 3490
    if ((int )((unsigned short )vp_idx) == (int )vp->vp_idx) {
#line 3491
      found = 1;
#line 3492
      goto ldv_61332;
    } else {

    }
#line 3489
    __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 3489
    vp = (scsi_qla_host_t *)__mptr___0;
    ldv_61334: ;
#line 3489
    if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 3491
      goto ldv_61333;
    } else {

    }
    ldv_61332: 
#line 3495
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 3497
    if (found == 0) {
#line 3498
      return;
    } else {

    }
#line 3500
    vp->d_id.b.domain = rptid_entry->port_id[2];
#line 3501
    vp->d_id.b.area = rptid_entry->port_id[1];
#line 3502
    vp->d_id.b.al_pa = rptid_entry->port_id[0];
#line 3508
    set_bit(0L, (unsigned long volatile   *)(& vp->vp_flags));
    reg_needed: 
#line 3511
    set_bit(9L, (unsigned long volatile   *)(& vp->dpc_flags));
#line 3512
    set_bit(12L, (unsigned long volatile   *)(& vp->dpc_flags));
#line 3513
    set_bit(14L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3514
    qla2xxx_wake_dpc(vha);
  } else {

  }
#line 3516
  return;
}
}
#line 3532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_modify_vp_config(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct vp_config_entry_24xx *vpmod ;
  dma_addr_t vpmod_dma ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 3537
  ha = vha->hw;
#line 3538
  tmp = pci_get_drvdata(ha->pdev);
#line 3538
  base_vha = (struct scsi_qla_host *)tmp;
#line 3542
  ql_dbg(536903680U, vha, 4283, "Entered %s.\n", "qla24xx_modify_vp_config");
#line 3545
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & vpmod_dma);
#line 3545
  vpmod = (struct vp_config_entry_24xx *)tmp___0;
#line 3546
  if ((unsigned long )vpmod == (unsigned long )((struct vp_config_entry_24xx *)0)) {
#line 3547
    ql_log(1U, vha, 4284, "Failed to allocate modify VP IOCB.\n");
#line 3549
    return (259);
  } else {

  }
#line 3552
  memset((void *)vpmod, 0, 64UL);
#line 3553
  vpmod->entry_type = 49U;
#line 3554
  vpmod->entry_count = 1U;
#line 3555
  vpmod->command = 1U;
#line 3556
  vpmod->vp_count = 1U;
#line 3557
  vpmod->vp_index1 = (uint8_t )vha->vp_idx;
#line 3558
  vpmod->options_idx1 = 56U;
#line 3560
  qlt_modify_vp_config(vha, vpmod);
#line 3562
  __len = 8UL;
#line 3562
  if (__len > 63UL) {
#line 3562
    __ret = __memcpy((void *)(& vpmod->node_name_idx1), (void const   *)(& vha->node_name),
                     __len);
  } else {
#line 3562
    __ret = __builtin_memcpy((void *)(& vpmod->node_name_idx1), (void const   *)(& vha->node_name),
                             __len);
  }
#line 3563
  __len___0 = 8UL;
#line 3563
  if (__len___0 > 63UL) {
#line 3563
    __ret___0 = __memcpy((void *)(& vpmod->port_name_idx1), (void const   *)(& vha->port_name),
                         __len___0);
  } else {
#line 3563
    __ret___0 = __builtin_memcpy((void *)(& vpmod->port_name_idx1), (void const   *)(& vha->port_name),
                                 __len___0);
  }
#line 3564
  vpmod->entry_count = 1U;
#line 3566
  rval = qla2x00_issue_iocb(base_vha, (void *)vpmod, vpmod_dma, 0UL);
#line 3567
  if (rval != 0) {
#line 3568
    ql_dbg(536870912U, vha, 4285, "Failed to issue VP config IOCB (%x).\n", rval);
  } else
#line 3570
  if ((unsigned int )vpmod->comp_status != 0U) {
#line 3571
    ql_dbg(536870912U, vha, 4286, "Failed to complete IOCB -- error status (%x).\n",
           (int )vpmod->comp_status);
#line 3574
    rval = 258;
  } else
#line 3575
  if ((unsigned int )vpmod->comp_status != 0U) {
#line 3576
    ql_dbg(536870912U, vha, 4287, "Failed to complete IOCB -- completion status (%x).\n",
           (int )vpmod->comp_status);
#line 3579
    rval = 258;
  } else {
#line 3582
    ql_dbg(536903680U, vha, 4288, "Done %s.\n", "qla24xx_modify_vp_config");
#line 3584
    fc_vport_set_state(vha->fc_vport, 4);
  }
#line 3586
  dma_pool_free(ha->s_dma_pool, (void *)vpmod, vpmod_dma);
#line 3588
  return (rval);
}
}
#line 3607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_control_vp(scsi_qla_host_t *vha , int cmd ) 
{ 
  int rval ;
  int map ;
  int pos ;
  struct vp_ctrl_entry_24xx *vce ;
  dma_addr_t vce_dma ;
  struct qla_hw_data *ha ;
  int vp_index ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3613
  ha = vha->hw;
#line 3614
  vp_index = (int )vha->vp_idx;
#line 3615
  tmp = pci_get_drvdata(ha->pdev);
#line 3615
  base_vha = (struct scsi_qla_host *)tmp;
#line 3617
  ql_dbg(536903680U, vha, 4289, "Entered %s enabling index %d.\n", "qla24xx_control_vp",
         vp_index);
#line 3620
  if (vp_index == 0 || (int )ha->max_npiv_vports <= vp_index) {
#line 3621
    return (6);
  } else {

  }
#line 3623
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & vce_dma);
#line 3623
  vce = (struct vp_ctrl_entry_24xx *)tmp___0;
#line 3624
  if ((unsigned long )vce == (unsigned long )((struct vp_ctrl_entry_24xx *)0)) {
#line 3625
    ql_log(1U, vha, 4290, "Failed to allocate VP control IOCB.\n");
#line 3627
    return (259);
  } else {

  }
#line 3629
  memset((void *)vce, 0, 64UL);
#line 3631
  vce->entry_type = 48U;
#line 3632
  vce->entry_count = 1U;
#line 3633
  vce->command = (unsigned short )cmd;
#line 3634
  vce->vp_count = 1U;
#line 3639
  map = (vp_index + -1) / 8;
#line 3640
  pos = (vp_index + -1) & 7;
#line 3641
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 3642
  vce->vp_idx_map[map] = (uint8_t )((int )((signed char )vce->vp_idx_map[map]) | (int )((signed char )(1 << pos)));
#line 3643
  mutex_unlock(& ha->vport_lock);
#line 3645
  rval = qla2x00_issue_iocb(base_vha, (void *)vce, vce_dma, 0UL);
#line 3646
  if (rval != 0) {
#line 3647
    ql_dbg(536870912U, vha, 4291, "Failed to issue VP control IOCB (%x).\n", rval);
  } else
#line 3649
  if ((unsigned int )vce->entry_status != 0U) {
#line 3650
    ql_dbg(536870912U, vha, 4292, "Failed to complete IOCB -- error status (%x).\n",
           (int )vce->entry_status);
#line 3653
    rval = 258;
  } else
#line 3654
  if ((unsigned int )vce->comp_status != 0U) {
#line 3655
    ql_dbg(536870912U, vha, 4293, "Failed to complet IOCB -- completion status (%x).\n",
           (int )vce->comp_status);
#line 3658
    rval = 258;
  } else {
#line 3660
    ql_dbg(536903680U, vha, 4294, "Done %s.\n", "qla24xx_control_vp");
  }
#line 3664
  dma_pool_free(ha->s_dma_pool, (void *)vce, vce_dma);
#line 3666
  return (rval);
}
}
#line 3691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_send_change_request(scsi_qla_host_t *vha , uint16_t format , uint16_t vp_idx ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3696
  mcp = & mc;
#line 3698
  ql_dbg(536903680U, vha, 4295, "Entered %s.\n", "qla2x00_send_change_request");
#line 3701
  mcp->mb[0] = 112U;
#line 3702
  mcp->mb[1] = format;
#line 3703
  mcp->mb[9] = vp_idx;
#line 3704
  mcp->out_mb = 515U;
#line 3705
  mcp->in_mb = 3U;
#line 3706
  mcp->tov = 30U;
#line 3707
  mcp->flags = 0U;
#line 3708
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3710
  if (rval == 0) {
#line 3711
    if ((unsigned int )mcp->mb[0] != 16384U) {
#line 3712
      rval = 2;
    } else {

    }
  } else {
#line 3715
    rval = 2;
  }
#line 3717
  return (rval);
}
}
#line 3721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_dump_ram(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr , uint32_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 3726
  mcp = & mc;
#line 3728
  ql_dbg(536903680U, vha, 4105, "Entered %s.\n", "qla2x00_dump_ram");
#line 3731
  if ((unsigned int )((unsigned short )(addr >> 16)) != 0U || ((vha->hw)->device_type & 134217728U) != 0U) {
#line 3732
    mcp->mb[0] = 12U;
#line 3733
    mcp->mb[8] = (unsigned short )(addr >> 16);
#line 3734
    mcp->out_mb = 257U;
  } else {
#line 3736
    mcp->mb[0] = 10U;
#line 3737
    mcp->out_mb = 1U;
  }
#line 3739
  mcp->mb[1] = (unsigned short )addr;
#line 3740
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 3741
  mcp->mb[3] = (unsigned short )req_dma;
#line 3742
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 3743
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 3744
  mcp->out_mb = mcp->out_mb | 206U;
#line 3745
  if (((vha->hw)->device_type & 134217728U) != 0U) {
#line 3746
    mcp->mb[4] = (unsigned short )(size >> 16);
#line 3747
    mcp->mb[5] = (unsigned short )size;
#line 3748
    mcp->out_mb = mcp->out_mb | 48U;
  } else {
#line 3750
    mcp->mb[4] = (unsigned short )size;
#line 3751
    mcp->out_mb = mcp->out_mb | 16U;
  }
#line 3754
  mcp->in_mb = 1U;
#line 3755
  mcp->tov = 30U;
#line 3756
  mcp->flags = 0U;
#line 3757
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3759
  if (rval != 0) {
#line 3760
    ql_dbg(536870912U, vha, 4104, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3763
    ql_dbg(536903680U, vha, 4103, "Done %s.\n", "qla2x00_dump_ram");
  }
#line 3767
  return (rval);
}
}
#line 3779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla84xx_verify_chip(struct scsi_qla_host *vha , uint16_t *status ) 
{ 
  int rval ;
  int retry ;
  struct cs84xx_mgmt_cmd *mn ;
  dma_addr_t mn_dma ;
  uint16_t options ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 3786
  ha = vha->hw;
#line 3788
  ql_dbg(536903680U, vha, 4296, "Entered %s.\n", "qla84xx_verify_chip");
#line 3791
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 3791
  mn = (struct cs84xx_mgmt_cmd *)tmp;
#line 3792
  if ((unsigned long )mn == (unsigned long )((struct cs84xx_mgmt_cmd *)0)) {
#line 3793
    return (259);
  } else {

  }
#line 3797
  options = (ha->cs84xx)->fw_update != 0U ? 2U : 0U;
#line 3801
  options = (uint16_t )((unsigned int )options | 16384U);
  ldv_61403: 
#line 3804
  retry = 0;
#line 3805
  memset((void *)mn, 0, 64UL);
#line 3806
  mn->p.req.entry_type = 27U;
#line 3807
  mn->p.req.entry_count = 1U;
#line 3808
  mn->p.req.options = options;
#line 3810
  ql_dbg(537001984U, vha, 4380, "Dump of Verify Request.\n");
#line 3812
  ql_dump_buffer(537001984U, vha, 4382, (uint8_t *)mn, 64U);
#line 3815
  rval = qla2x00_issue_iocb_timeout(vha, (void *)mn, mn_dma, 0UL, 120U);
#line 3816
  if (rval != 0) {
#line 3817
    ql_dbg(536870912U, vha, 4299, "Failed to issue verify IOCB (%x).\n", rval);
#line 3819
    goto verify_done;
  } else {

  }
#line 3822
  ql_dbg(537001984U, vha, 4368, "Dump of Verify Response.\n");
#line 3824
  ql_dump_buffer(537001984U, vha, 4376, (uint8_t *)mn, 64U);
#line 3827
  *status = mn->p.rsp.comp_status;
#line 3828
  *(status + 1UL) = (unsigned int )*status == 3U ? mn->p.rsp.failure_code : 0U;
#line 3830
  ql_dbg(536903680U, vha, 4302, "cs=%x fc=%x.\n", (int )*status, (int )*(status + 1UL));
#line 3833
  if ((unsigned int )*status != 0U) {
#line 3834
    rval = 258;
#line 3835
    if (((int )options & 1) == 0) {
#line 3836
      ql_dbg(536870912U, vha, 4303, "Firmware update failed. Retrying without update firmware.\n");
#line 3839
      options = (uint16_t )((unsigned int )options | 1U);
#line 3840
      options = (unsigned int )options & 65533U;
#line 3841
      retry = 1;
    } else {

    }
  } else {
#line 3844
    ql_dbg(536903680U, vha, 4304, "Firmware updated to %x.\n", mn->p.rsp.fw_ver);
#line 3849
    tmp___0 = spinlock_check(& (ha->cs84xx)->access_lock);
#line 3849
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 3850
    (ha->cs84xx)->op_fw_version = mn->p.rsp.fw_ver;
#line 3852
    spin_unlock_irqrestore(& (ha->cs84xx)->access_lock, flags);
  }
#line 3855
  if (retry != 0) {
#line 3857
    goto ldv_61403;
  } else {

  }

  verify_done: 
#line 3858
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
#line 3860
  if (rval != 0) {
#line 3861
    ql_dbg(536870912U, vha, 4305, "Failed=%x.\n", rval);
  } else {
#line 3864
    ql_dbg(536903680U, vha, 4306, "Done %s.\n", "qla84xx_verify_chip");
  }
#line 3868
  return (rval);
}
}
#line 3872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla25xx_init_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  int rval ;
  unsigned long flags ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;

  {
#line 3877
  mcp = & mc;
#line 3878
  ha = vha->hw;
#line 3880
  ql_dbg(536903680U, vha, 4307, "Entered %s.\n", "qla25xx_init_req_que");
#line 3883
  mcp->mb[0] = 31U;
#line 3884
  mcp->mb[1] = req->options;
#line 3885
  mcp->mb[2] = (unsigned short )((unsigned int )req->dma >> 16);
#line 3886
  mcp->mb[3] = (unsigned short )req->dma;
#line 3887
  mcp->mb[6] = (unsigned short )((unsigned int )(req->dma >> 32ULL) >> 16);
#line 3888
  mcp->mb[7] = (unsigned short )(req->dma >> 32ULL);
#line 3889
  mcp->mb[5] = req->length;
#line 3890
  if ((unsigned long )req->rsp != (unsigned long )((struct rsp_que *)0)) {
#line 3891
    mcp->mb[10] = (req->rsp)->id;
  } else {

  }
#line 3892
  mcp->mb[12] = req->qos;
#line 3893
  mcp->mb[11] = req->vp_idx;
#line 3894
  mcp->mb[13] = req->rid;
#line 3895
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 3896
    mcp->mb[15] = 0U;
  } else {

  }
#line 3898
  mcp->mb[4] = req->id;
#line 3900
  mcp->mb[8] = 0U;
#line 3902
  mcp->mb[9] = 0U;
#line 3903
  mcp->out_mb = 32767U;
#line 3905
  mcp->in_mb = 1U;
#line 3906
  mcp->flags = 2U;
#line 3907
  mcp->tov = 60U;
#line 3909
  if ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 3910
    mcp->in_mb = mcp->in_mb | 2U;
  } else {

  }
#line 3911
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 3912
    mcp->out_mb = mcp->out_mb | 32768U;
#line 3914
    mcp->in_mb = mcp->in_mb | 896U;
  } else {

  }
#line 3917
  tmp = spinlock_check(& ha->hardware_lock);
#line 3917
  flags = _raw_spin_lock_irqsave(tmp);
#line 3918
  if (((int )req->options & 1) == 0) {
#line 3919
    writel(0U, (void volatile   *)req->req_q_in);
#line 3920
    if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 3921
      writel(0U, (void volatile   *)req->req_q_out);
    } else {

    }
  } else {

  }
#line 3923
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3925
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3926
  if (rval != 0) {
#line 3927
    ql_dbg(536870912U, vha, 4308, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3930
    ql_dbg(536903680U, vha, 4309, "Done %s.\n", "qla25xx_init_req_que");
  }
#line 3934
  return (rval);
}
}
#line 3938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla25xx_init_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  int rval ;
  unsigned long flags ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;

  {
#line 3943
  mcp = & mc;
#line 3944
  ha = vha->hw;
#line 3946
  ql_dbg(536903680U, vha, 4310, "Entered %s.\n", "qla25xx_init_rsp_que");
#line 3949
  mcp->mb[0] = 31U;
#line 3950
  mcp->mb[1] = rsp->options;
#line 3951
  mcp->mb[2] = (unsigned short )((unsigned int )rsp->dma >> 16);
#line 3952
  mcp->mb[3] = (unsigned short )rsp->dma;
#line 3953
  mcp->mb[6] = (unsigned short )((unsigned int )(rsp->dma >> 32ULL) >> 16);
#line 3954
  mcp->mb[7] = (unsigned short )(rsp->dma >> 32ULL);
#line 3955
  mcp->mb[5] = rsp->length;
#line 3956
  mcp->mb[14] = (rsp->msix)->entry;
#line 3957
  mcp->mb[13] = rsp->rid;
#line 3958
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 3959
    mcp->mb[15] = 0U;
  } else {

  }
#line 3961
  mcp->mb[4] = rsp->id;
#line 3963
  mcp->mb[8] = 0U;
#line 3965
  mcp->mb[9] = 0U;
#line 3966
  mcp->out_mb = 25599U;
#line 3968
  mcp->in_mb = 1U;
#line 3969
  mcp->flags = 2U;
#line 3970
  mcp->tov = 60U;
#line 3972
  if ((ha->device_type & 8192U) != 0U) {
#line 3973
    mcp->out_mb = mcp->out_mb | 7168U;
#line 3974
    mcp->in_mb = mcp->in_mb | 2U;
  } else
#line 3975
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 3976
    mcp->out_mb = mcp->out_mb | 39936U;
#line 3977
    mcp->in_mb = mcp->in_mb | 2U;
#line 3979
    mcp->in_mb = mcp->in_mb | 896U;
  } else {

  }
#line 3982
  tmp = spinlock_check(& ha->hardware_lock);
#line 3982
  flags = _raw_spin_lock_irqsave(tmp);
#line 3983
  if (((int )rsp->options & 1) == 0) {
#line 3984
    writel(0U, (void volatile   *)rsp->rsp_q_out);
#line 3985
    if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 3986
      writel(0U, (void volatile   *)rsp->rsp_q_in);
    } else {

    }
  } else {

  }
#line 3989
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3991
  rval = qla2x00_mailbox_command(vha, mcp);
#line 3992
  if (rval != 0) {
#line 3993
    ql_dbg(536870912U, vha, 4311, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 3996
    ql_dbg(536903680U, vha, 4312, "Done %s.\n", "qla25xx_init_rsp_que");
  }
#line 4000
  return (rval);
}
}
#line 4004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_idc_ack(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  size_t __len ;
  void *__ret ;

  {
#line 4008
  mcp = & mc;
#line 4010
  ql_dbg(536903680U, vha, 4313, "Entered %s.\n", "qla81xx_idc_ack");
#line 4013
  mcp->mb[0] = 257U;
#line 4014
  __len = 14UL;
#line 4014
  if (__len > 63UL) {
#line 4014
    __ret = __memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, __len);
  } else {
#line 4014
    __ret = __builtin_memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, __len);
  }
#line 4015
  mcp->out_mb = 255U;
#line 4016
  mcp->in_mb = 1U;
#line 4017
  mcp->tov = 30U;
#line 4018
  mcp->flags = 0U;
#line 4019
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4021
  if (rval != 0) {
#line 4022
    ql_dbg(536870912U, vha, 4314, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4025
    ql_dbg(536903680U, vha, 4315, "Done %s.\n", "qla81xx_idc_ack");
  }
#line 4029
  return (rval);
}
}
#line 4033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_fac_get_sector_size(scsi_qla_host_t *vha , uint32_t *sector_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4037
  mcp = & mc;
#line 4039
  ql_dbg(536903680U, vha, 4316, "Entered %s.\n", "qla81xx_fac_get_sector_size");
#line 4042
  if (((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) {
#line 4043
    return (258);
  } else {

  }
#line 4045
  mcp->mb[0] = 62U;
#line 4046
  mcp->mb[1] = 5U;
#line 4047
  mcp->out_mb = 3U;
#line 4048
  mcp->in_mb = 3U;
#line 4049
  mcp->tov = 30U;
#line 4050
  mcp->flags = 0U;
#line 4051
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4053
  if (rval != 0) {
#line 4054
    ql_dbg(536870912U, vha, 4317, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4058
    ql_dbg(536903680U, vha, 4318, "Done %s.\n", "qla81xx_fac_get_sector_size");
#line 4060
    *sector_size = (uint32_t )mcp->mb[1];
  }
#line 4063
  return (rval);
}
}
#line 4067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_fac_do_write_enable(scsi_qla_host_t *vha , int enable ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4071
  mcp = & mc;
#line 4073
  if (((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) {
#line 4074
    return (258);
  } else {

  }
#line 4076
  ql_dbg(536903680U, vha, 4319, "Entered %s.\n", "qla81xx_fac_do_write_enable");
#line 4079
  mcp->mb[0] = 62U;
#line 4080
  mcp->mb[1] = enable != 0;
#line 4082
  mcp->out_mb = 3U;
#line 4083
  mcp->in_mb = 3U;
#line 4084
  mcp->tov = 30U;
#line 4085
  mcp->flags = 0U;
#line 4086
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4088
  if (rval != 0) {
#line 4089
    ql_dbg(536870912U, vha, 4320, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4093
    ql_dbg(536903680U, vha, 4321, "Done %s.\n", "qla81xx_fac_do_write_enable");
  }
#line 4097
  return (rval);
}
}
#line 4101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_fac_erase_sector(scsi_qla_host_t *vha , uint32_t start , uint32_t finish ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4105
  mcp = & mc;
#line 4107
  if (((vha->hw)->device_type & 8192U) == 0U && (((vha->hw)->device_type & 32768U) == 0U && ((vha->hw)->device_type & 65536U) == 0U)) {
#line 4108
    return (258);
  } else {

  }
#line 4110
  ql_dbg(536903680U, vha, 4322, "Entered %s.\n", "qla81xx_fac_erase_sector");
#line 4113
  mcp->mb[0] = 62U;
#line 4114
  mcp->mb[1] = 2U;
#line 4115
  mcp->mb[2] = (unsigned short )start;
#line 4116
  mcp->mb[3] = (unsigned short )(start >> 16);
#line 4117
  mcp->mb[4] = (unsigned short )finish;
#line 4118
  mcp->mb[5] = (unsigned short )(finish >> 16);
#line 4119
  mcp->out_mb = 63U;
#line 4120
  mcp->in_mb = 7U;
#line 4121
  mcp->tov = 30U;
#line 4122
  mcp->flags = 0U;
#line 4123
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4125
  if (rval != 0) {
#line 4126
    ql_dbg(536870912U, vha, 4323, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4130
    ql_dbg(536903680U, vha, 4324, "Done %s.\n", "qla81xx_fac_erase_sector");
  }
#line 4134
  return (rval);
}
}
#line 4138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_restart_mpi_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4140
  rval = 0;
#line 4142
  mcp = & mc;
#line 4144
  ql_dbg(536903680U, vha, 4325, "Entered %s.\n", "qla81xx_restart_mpi_firmware");
#line 4147
  mcp->mb[0] = 61U;
#line 4148
  mcp->out_mb = 1U;
#line 4149
  mcp->in_mb = 3U;
#line 4150
  mcp->tov = 30U;
#line 4151
  mcp->flags = 0U;
#line 4152
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4154
  if (rval != 0) {
#line 4155
    ql_dbg(536870912U, vha, 4326, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4159
    ql_dbg(536903680U, vha, 4327, "Done %s.\n", "qla81xx_restart_mpi_firmware");
  }
#line 4163
  return (rval);
}
}
#line 4167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_set_driver_version(scsi_qla_host_t *vha , char *version ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int i ;
  int len ;
  uint16_t *str ;
  struct qla_hw_data *ha ;
  size_t tmp ;

  {
#line 4171
  mcp = & mc;
#line 4175
  ha = vha->hw;
#line 4177
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4178
    return (258);
  } else {

  }
#line 4180
  ql_dbg(536903680U, vha, 4475, "Entered %s.\n", "qla82xx_set_driver_version");
#line 4183
  str = (uint16_t *)version;
#line 4184
  tmp = strlen((char const   *)version);
#line 4184
  len = (int )tmp;
#line 4186
  mcp->mb[0] = 89U;
#line 4187
  mcp->mb[1] = 2304U;
#line 4188
  mcp->out_mb = 3U;
#line 4189
  i = 4;
#line 4189
  goto ldv_61487;
  ldv_61486: 
#line 4190
  mcp->mb[i] = __cpu_to_le16p((__u16 const   *)str);
#line 4191
  mcp->out_mb = mcp->out_mb | (uint32_t )(1 << i);
#line 4189
  i = i + 1;
#line 4189
  str = str + 1;
#line 4189
  len = len + -2;
  ldv_61487: ;
#line 4189
  if (i <= 15 && len != 0) {
#line 4191
    goto ldv_61486;
  } else {

  }

#line 4193
  goto ldv_61490;
  ldv_61489: 
#line 4194
  mcp->mb[i] = 0U;
#line 4195
  mcp->out_mb = mcp->out_mb | (uint32_t )(1 << i);
#line 4193
  i = i + 1;
  ldv_61490: ;
#line 4193
  if (i <= 15) {
#line 4195
    goto ldv_61489;
  } else {

  }
#line 4197
  mcp->in_mb = 3U;
#line 4198
  mcp->tov = 30U;
#line 4199
  mcp->flags = 0U;
#line 4200
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4202
  if (rval != 0) {
#line 4203
    ql_dbg(536870912U, vha, 4476, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4206
    ql_dbg(536903680U, vha, 4477, "Done %s.\n", "qla82xx_set_driver_version");
  }
#line 4210
  return (rval);
}
}
#line 4214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla25xx_set_driver_version(scsi_qla_host_t *vha , char *version ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int len ;
  uint16_t dwlen ;
  uint8_t *str ;
  dma_addr_t str_dma ;
  struct qla_hw_data *ha ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 4218
  mcp = & mc;
#line 4223
  ha = vha->hw;
#line 4225
  if ((((ha->device_type & 134217728U) == 0U || ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U)) || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U)) {
#line 4227
    return (258);
  } else {

  }
#line 4229
  ql_dbg(536903680U, vha, 4478, "Entered %s.\n", "qla25xx_set_driver_version");
#line 4232
  tmp = dma_pool_alloc(ha->s_dma_pool, 208U, & str_dma);
#line 4232
  str = (uint8_t *)tmp;
#line 4233
  if ((unsigned long )str == (unsigned long )((uint8_t *)0U)) {
#line 4234
    ql_log(1U, vha, 4479, "Failed to allocate driver version param.\n");
#line 4236
    return (259);
  } else {

  }
#line 4239
  __len = 4UL;
#line 4239
  if (__len > 63UL) {
#line 4239
    __ret = __memcpy((void *)str, (void const   *)"\a\003\021", __len);
  } else {
#line 4239
    __ret = __builtin_memcpy((void *)str, (void const   *)"\a\003\021", __len);
  }
#line 4240
  dwlen = (uint16_t )*str;
#line 4241
  len = ((int )dwlen + -1) * 4;
#line 4242
  memset((void *)str + 4U, 0, (size_t )len);
#line 4243
  tmp___1 = strlen((char const   *)version);
#line 4243
  if ((size_t )len > tmp___1) {
#line 4244
    tmp___0 = strlen((char const   *)version);
#line 4244
    len = (int )tmp___0;
  } else {

  }
#line 4245
  __len___0 = (size_t )len;
#line 4245
  __ret___0 = __builtin_memcpy((void *)str + 4U, (void const   *)version, __len___0);
#line 4247
  mcp->mb[0] = 89U;
#line 4248
  mcp->mb[1] = (uint16_t )((unsigned int )dwlen | 2304U);
#line 4249
  mcp->mb[2] = (unsigned short )((unsigned int )str_dma >> 16);
#line 4250
  mcp->mb[3] = (unsigned short )str_dma;
#line 4251
  mcp->mb[6] = (unsigned short )((unsigned int )(str_dma >> 32ULL) >> 16);
#line 4252
  mcp->mb[7] = (unsigned short )(str_dma >> 32ULL);
#line 4253
  mcp->out_mb = 207U;
#line 4254
  mcp->in_mb = 3U;
#line 4255
  mcp->tov = 30U;
#line 4256
  mcp->flags = 0U;
#line 4257
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4259
  if (rval != 0) {
#line 4260
    ql_dbg(536870912U, vha, 4480, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4263
    ql_dbg(536903680U, vha, 4481, "Done %s.\n", "qla25xx_set_driver_version");
  }
#line 4267
  dma_pool_free(ha->s_dma_pool, (void *)str, str_dma);
#line 4269
  return (rval);
}
}
#line 4273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
static int qla2x00_read_asic_temperature(scsi_qla_host_t *vha , uint16_t *temp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4277
  mcp = & mc;
#line 4279
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4280
    return (258);
  } else {

  }
#line 4282
  ql_dbg(536903680U, vha, 4441, "Entered %s.\n", "qla2x00_read_asic_temperature");
#line 4285
  mcp->mb[0] = 90U;
#line 4286
  mcp->mb[1] = 3072U;
#line 4287
  mcp->out_mb = 3U;
#line 4288
  mcp->in_mb = 3U;
#line 4289
  mcp->tov = 30U;
#line 4290
  mcp->flags = 0U;
#line 4291
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4292
  *temp = mcp->mb[1];
#line 4294
  if (rval != 0) {
#line 4295
    ql_dbg(536870912U, vha, 4442, "Failed=%x mb[0]=%x,%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4298
    ql_dbg(536903680U, vha, 4443, "Done %s.\n", "qla2x00_read_asic_temperature");
  }
#line 4302
  return (rval);
}
}
#line 4306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_read_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                     uint16_t off , uint16_t len , uint16_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4311
  mcp = & mc;
#line 4312
  ha = vha->hw;
#line 4314
  ql_dbg(536903680U, vha, 4328, "Entered %s.\n", "qla2x00_read_sfp");
#line 4317
  if ((ha->device_type & 134217728U) == 0U) {
#line 4318
    return (258);
  } else {

  }
#line 4320
  if ((unsigned int )len == 1U) {
#line 4321
    opt = (uint16_t )((unsigned int )opt | 1U);
  } else {

  }
#line 4323
  mcp->mb[0] = 49U;
#line 4324
  mcp->mb[1] = dev;
#line 4325
  mcp->mb[2] = (unsigned short )((unsigned int )sfp_dma >> 16);
#line 4326
  mcp->mb[3] = (unsigned short )sfp_dma;
#line 4327
  mcp->mb[6] = (unsigned short )((unsigned int )(sfp_dma >> 32ULL) >> 16);
#line 4328
  mcp->mb[7] = (unsigned short )(sfp_dma >> 32ULL);
#line 4329
  mcp->mb[8] = len;
#line 4330
  mcp->mb[9] = off;
#line 4331
  mcp->mb[10] = opt;
#line 4332
  mcp->out_mb = 1999U;
#line 4333
  mcp->in_mb = 3U;
#line 4334
  mcp->tov = 30U;
#line 4335
  mcp->flags = 0U;
#line 4336
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4338
  if ((int )opt & 1) {
#line 4339
    *sfp = (uint8_t )mcp->mb[1];
  } else {

  }
#line 4341
  if (rval != 0) {
#line 4342
    ql_dbg(536870912U, vha, 4329, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4345
    ql_dbg(536903680U, vha, 4330, "Done %s.\n", "qla2x00_read_sfp");
  }
#line 4349
  return (rval);
}
}
#line 4353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_write_sfp(scsi_qla_host_t *vha , dma_addr_t sfp_dma , uint8_t *sfp , uint16_t dev ,
                      uint16_t off , uint16_t len , uint16_t opt ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4358
  mcp = & mc;
#line 4359
  ha = vha->hw;
#line 4361
  ql_dbg(536903680U, vha, 4331, "Entered %s.\n", "qla2x00_write_sfp");
#line 4364
  if ((ha->device_type & 134217728U) == 0U) {
#line 4365
    return (258);
  } else {

  }
#line 4367
  if ((unsigned int )len == 1U) {
#line 4368
    opt = (uint16_t )((unsigned int )opt | 1U);
  } else {

  }
#line 4370
  if ((int )opt & 1) {
#line 4371
    len = (uint16_t )*sfp;
  } else {

  }
#line 4373
  mcp->mb[0] = 48U;
#line 4374
  mcp->mb[1] = dev;
#line 4375
  mcp->mb[2] = (unsigned short )((unsigned int )sfp_dma >> 16);
#line 4376
  mcp->mb[3] = (unsigned short )sfp_dma;
#line 4377
  mcp->mb[6] = (unsigned short )((unsigned int )(sfp_dma >> 32ULL) >> 16);
#line 4378
  mcp->mb[7] = (unsigned short )(sfp_dma >> 32ULL);
#line 4379
  mcp->mb[8] = len;
#line 4380
  mcp->mb[9] = off;
#line 4381
  mcp->mb[10] = opt;
#line 4382
  mcp->out_mb = 1999U;
#line 4383
  mcp->in_mb = 3U;
#line 4384
  mcp->tov = 30U;
#line 4385
  mcp->flags = 0U;
#line 4386
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4388
  if (rval != 0) {
#line 4389
    ql_dbg(536870912U, vha, 4332, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4392
    ql_dbg(536903680U, vha, 4333, "Done %s.\n", "qla2x00_write_sfp");
  }
#line 4396
  return (rval);
}
}
#line 4400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_xgmac_stats(scsi_qla_host_t *vha , dma_addr_t stats_dma , uint16_t size_in_bytes ,
                            uint16_t *actual_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4405
  mcp = & mc;
#line 4407
  ql_dbg(536903680U, vha, 4334, "Entered %s.\n", "qla2x00_get_xgmac_stats");
#line 4410
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 4411
    return (258);
  } else {

  }
#line 4413
  mcp->mb[0] = 122U;
#line 4414
  mcp->mb[2] = (unsigned short )((unsigned int )stats_dma >> 16);
#line 4415
  mcp->mb[3] = (unsigned short )stats_dma;
#line 4416
  mcp->mb[6] = (unsigned short )((unsigned int )(stats_dma >> 32ULL) >> 16);
#line 4417
  mcp->mb[7] = (unsigned short )(stats_dma >> 32ULL);
#line 4418
  mcp->mb[8] = (uint16_t )((int )size_in_bytes >> 2);
#line 4419
  mcp->out_mb = 461U;
#line 4420
  mcp->in_mb = 7U;
#line 4421
  mcp->tov = 30U;
#line 4422
  mcp->flags = 0U;
#line 4423
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4425
  if (rval != 0) {
#line 4426
    ql_dbg(536870912U, vha, 4335, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4430
    ql_dbg(536903680U, vha, 4336, "Done %s.\n", "qla2x00_get_xgmac_stats");
#line 4434
    *actual_size = (int )mcp->mb[2] << 2U;
  }
#line 4437
  return (rval);
}
}
#line 4441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_dcbx_params(scsi_qla_host_t *vha , dma_addr_t tlv_dma , uint16_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4446
  mcp = & mc;
#line 4448
  ql_dbg(536903680U, vha, 4337, "Entered %s.\n", "qla2x00_get_dcbx_params");
#line 4451
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 4452
    return (258);
  } else {

  }
#line 4454
  mcp->mb[0] = 81U;
#line 4455
  mcp->mb[1] = 0U;
#line 4456
  mcp->mb[2] = (unsigned short )((unsigned int )tlv_dma >> 16);
#line 4457
  mcp->mb[3] = (unsigned short )tlv_dma;
#line 4458
  mcp->mb[6] = (unsigned short )((unsigned int )(tlv_dma >> 32ULL) >> 16);
#line 4459
  mcp->mb[7] = (unsigned short )(tlv_dma >> 32ULL);
#line 4460
  mcp->mb[8] = size;
#line 4461
  mcp->out_mb = 463U;
#line 4462
  mcp->in_mb = 7U;
#line 4463
  mcp->tov = 30U;
#line 4464
  mcp->flags = 0U;
#line 4465
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4467
  if (rval != 0) {
#line 4468
    ql_dbg(536870912U, vha, 4338, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n", rval,
           (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2]);
  } else {
#line 4472
    ql_dbg(536903680U, vha, 4339, "Done %s.\n", "qla2x00_get_dcbx_params");
  }
#line 4476
  return (rval);
}
}
#line 4480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_read_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4484
  mcp = & mc;
#line 4486
  ql_dbg(536903680U, vha, 4340, "Entered %s.\n", "qla2x00_read_ram_word");
#line 4489
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4490
    return (258);
  } else {

  }
#line 4492
  mcp->mb[0] = 15U;
#line 4493
  mcp->mb[1] = (unsigned short )risc_addr;
#line 4494
  mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 4495
  mcp->out_mb = 259U;
#line 4496
  mcp->in_mb = 13U;
#line 4497
  mcp->tov = 30U;
#line 4498
  mcp->flags = 0U;
#line 4499
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4500
  if (rval != 0) {
#line 4501
    ql_dbg(536870912U, vha, 4341, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4504
    ql_dbg(536903680U, vha, 4342, "Done %s.\n", "qla2x00_read_ram_word");
#line 4506
    *data = (uint32_t )(((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  }
#line 4509
  return (rval);
}
}
#line 4513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_loopback_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  size_t __len ;
  void *__ret ;

  {
#line 4518
  mcp = & mc;
#line 4520
  ql_dbg(536903680U, vha, 4343, "Entered %s.\n", "qla2x00_loopback_test");
#line 4523
  memset((void *)(& mcp->mb), 0, 64UL);
#line 4524
  mcp->mb[0] = 69U;
#line 4525
  mcp->mb[1] = (uint16_t )((unsigned int )mreq->options | 64U);
#line 4528
  mcp->mb[10] = (unsigned short )mreq->transfer_size;
#line 4529
  mcp->mb[11] = (unsigned short )(mreq->transfer_size >> 16);
#line 4532
  mcp->mb[14] = (unsigned short )mreq->send_dma;
#line 4533
  mcp->mb[15] = (unsigned short )((unsigned int )mreq->send_dma >> 16);
#line 4534
  mcp->mb[20] = (unsigned short )(mreq->send_dma >> 32ULL);
#line 4535
  mcp->mb[21] = (unsigned short )((unsigned int )(mreq->send_dma >> 32ULL) >> 16);
#line 4538
  mcp->mb[16] = (unsigned short )mreq->rcv_dma;
#line 4539
  mcp->mb[17] = (unsigned short )((unsigned int )mreq->rcv_dma >> 16);
#line 4540
  mcp->mb[6] = (unsigned short )(mreq->rcv_dma >> 32ULL);
#line 4541
  mcp->mb[7] = (unsigned short )((unsigned int )(mreq->rcv_dma >> 32ULL) >> 16);
#line 4544
  mcp->mb[18] = (unsigned short )mreq->iteration_count;
#line 4545
  mcp->mb[19] = (unsigned short )(mreq->iteration_count >> 16);
#line 4547
  mcp->out_mb = 4193475U;
#line 4549
  if (((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 16384U) != 0U) || ((vha->hw)->device_type & 65536U) != 0U) || ((vha->hw)->device_type & 262144U) != 0U) {
#line 4550
    mcp->out_mb = mcp->out_mb | 4U;
  } else {

  }
#line 4551
  mcp->in_mb = 786447U;
#line 4553
  mcp->buf_size = (long )mreq->transfer_size;
#line 4554
  mcp->tov = 30U;
#line 4555
  mcp->flags = 7U;
#line 4557
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4559
  if (rval != 0) {
#line 4560
    ql_dbg(536870912U, vha, 4344, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[18]=%x mb[19]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[18], (int )mcp->mb[19]);
  } else {
#line 4565
    ql_dbg(536903680U, vha, 4345, "Done %s.\n", "qla2x00_loopback_test");
  }
#line 4570
  __len = 64UL;
#line 4570
  if (__len > 63UL) {
#line 4570
    __ret = __memcpy((void *)mresp, (void const   *)(& mcp->mb), __len);
  } else {
#line 4570
    __ret = __builtin_memcpy((void *)mresp, (void const   *)(& mcp->mb), __len);
  }
#line 4571
  return (rval);
}
}
#line 4575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_echo_test(scsi_qla_host_t *vha , struct msg_echo_lb *mreq , uint16_t *mresp ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 4580
  mcp = & mc;
#line 4581
  ha = vha->hw;
#line 4583
  ql_dbg(536903680U, vha, 4346, "Entered %s.\n", "qla2x00_echo_test");
#line 4586
  memset((void *)(& mcp->mb), 0, 64UL);
#line 4587
  mcp->mb[0] = 68U;
#line 4588
  mcp->mb[1] = (uint16_t )((unsigned int )mreq->options | 64U);
#line 4589
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 4590
    mcp->mb[1] = (uint16_t )((unsigned int )mcp->mb[1] | 32768U);
#line 4591
    mcp->mb[2] = vha->fcoe_fcf_idx;
  } else {

  }
#line 4593
  mcp->mb[16] = (unsigned short )mreq->rcv_dma;
#line 4594
  mcp->mb[17] = (unsigned short )((unsigned int )mreq->rcv_dma >> 16);
#line 4595
  mcp->mb[6] = (unsigned short )(mreq->rcv_dma >> 32ULL);
#line 4596
  mcp->mb[7] = (unsigned short )((unsigned int )(mreq->rcv_dma >> 32ULL) >> 16);
#line 4598
  mcp->mb[10] = (unsigned short )mreq->transfer_size;
#line 4600
  mcp->mb[14] = (unsigned short )mreq->send_dma;
#line 4601
  mcp->mb[15] = (unsigned short )((unsigned int )mreq->send_dma >> 16);
#line 4602
  mcp->mb[20] = (unsigned short )(mreq->send_dma >> 32ULL);
#line 4603
  mcp->mb[21] = (unsigned short )((unsigned int )(mreq->send_dma >> 32ULL) >> 16);
#line 4605
  mcp->out_mb = 3392707U;
#line 4607
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 4608
    mcp->out_mb = mcp->out_mb | 4U;
  } else {

  }
#line 4610
  mcp->in_mb = 1U;
#line 4611
  if (((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) {
#line 4613
    mcp->in_mb = mcp->in_mb | 2U;
  } else {

  }
#line 4614
  if (((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) || (ha->device_type & 32768U) != 0U) {
#line 4615
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 4617
  mcp->tov = 30U;
#line 4618
  mcp->flags = 7U;
#line 4619
  mcp->buf_size = (long )mreq->transfer_size;
#line 4621
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4623
  if (rval != 0) {
#line 4624
    ql_dbg(536870912U, vha, 4347, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 4628
    ql_dbg(536903680U, vha, 4348, "Done %s.\n", "qla2x00_echo_test");
  }
#line 4633
  __len = 64UL;
#line 4633
  if (__len > 63UL) {
#line 4633
    __ret = __memcpy((void *)mresp, (void const   *)(& mcp->mb), __len);
  } else {
#line 4633
    __ret = __builtin_memcpy((void *)mresp, (void const   *)(& mcp->mb), __len);
  }
#line 4634
  return (rval);
}
}
#line 4638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla84xx_reset_chip(scsi_qla_host_t *vha , uint16_t enable_diagnostic ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4642
  mcp = & mc;
#line 4644
  ql_dbg(536903680U, vha, 4349, "Entered %s enable_diag=%d.\n", "qla84xx_reset_chip",
         (int )enable_diagnostic);
#line 4647
  mcp->mb[0] = 58U;
#line 4648
  mcp->mb[1] = enable_diagnostic;
#line 4649
  mcp->out_mb = 3U;
#line 4650
  mcp->in_mb = 3U;
#line 4651
  mcp->tov = 30U;
#line 4652
  mcp->flags = 7U;
#line 4653
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4655
  if (rval != 0) {
#line 4656
    ql_dbg(536870912U, vha, 4350, "Failed=%x.\n", rval);
  } else {
#line 4658
    ql_dbg(536903680U, vha, 4351, "Done %s.\n", "qla84xx_reset_chip");
  }
#line 4661
  return (rval);
}
}
#line 4665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_write_ram_word(scsi_qla_host_t *vha , uint32_t risc_addr , uint32_t data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4669
  mcp = & mc;
#line 4671
  ql_dbg(536903680U, vha, 4352, "Entered %s.\n", "qla2x00_write_ram_word");
#line 4674
  if (((vha->hw)->device_type & 134217728U) == 0U) {
#line 4675
    return (258);
  } else {

  }
#line 4677
  mcp->mb[0] = 13U;
#line 4678
  mcp->mb[1] = (unsigned short )risc_addr;
#line 4679
  mcp->mb[2] = (unsigned short )data;
#line 4680
  mcp->mb[3] = (unsigned short )(data >> 16);
#line 4681
  mcp->mb[8] = (unsigned short )(risc_addr >> 16);
#line 4682
  mcp->out_mb = 271U;
#line 4683
  mcp->in_mb = 1U;
#line 4684
  mcp->tov = 30U;
#line 4685
  mcp->flags = 0U;
#line 4686
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4687
  if (rval != 0) {
#line 4688
    ql_dbg(536870912U, vha, 4353, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4691
    ql_dbg(536903680U, vha, 4354, "Done %s.\n", "qla2x00_write_ram_word");
  }
#line 4695
  return (rval);
}
}
#line 4699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_write_mpi_register(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  uint32_t stat ;
  uint32_t timer ;
  uint16_t mb0 ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;

  {
#line 4703
  mb0 = 0U;
#line 4704
  ha = vha->hw;
#line 4705
  reg = & (ha->iobase)->isp24;
#line 4707
  rval = 0;
#line 4709
  ql_dbg(536903680U, vha, 4355, "Entered %s.\n", "qla81xx_write_mpi_register");
#line 4712
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4715
  writew(1, (void volatile   *)(& reg->mailbox0));
#line 4716
  writew((int )*mb, (void volatile   *)(& reg->mailbox1));
#line 4717
  writew((int )*(mb + 1UL), (void volatile   *)(& reg->mailbox2));
#line 4718
  writew((int )*(mb + 2UL), (void volatile   *)(& reg->mailbox3));
#line 4719
  writew((int )*(mb + 3UL), (void volatile   *)(& reg->mailbox4));
#line 4721
  writel(1342177280U, (void volatile   *)(& reg->hccr));
#line 4724
  timer = 6000000U;
#line 4724
  goto ldv_61630;
  ldv_61629: 
#line 4726
  stat = readl((void const volatile   *)(& reg->host_status));
#line 4727
  if ((stat & 32768U) != 0U) {
#line 4728
    stat = stat & 255U;
#line 4730
    if (((stat == 1U || stat == 2U) || stat == 16U) || stat == 17U) {
#line 4732
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4734
      mb0 = readw((void const volatile   *)(& reg->mailbox0));
#line 4735
      writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 4737
      readl((void const volatile   *)(& reg->hccr));
#line 4738
      goto ldv_61628;
    } else {

    }
  } else {

  }
#line 4741
  __const_udelay(21475UL);
#line 4724
  timer = timer - 1U;
  ldv_61630: ;
#line 4724
  if (timer != 0U) {
#line 4726
    goto ldv_61629;
  } else {

  }
  ldv_61628: 
#line 4744
  tmp = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 4744
  if (tmp != 0) {
#line 4745
    rval = (int )mb0 & 16383;
  } else {
#line 4747
    rval = 258;
  }
#line 4749
  if (rval != 0) {
#line 4750
    ql_dbg(536870912U, vha, 4356, "Failed=%x mb[0]=%x.\n", rval, (int )*mb);
  } else {
#line 4753
    ql_dbg(536903680U, vha, 4357, "Done %s.\n", "qla81xx_write_mpi_register");
  }
#line 4757
  return (rval);
}
}
#line 4761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_data_rate(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4765
  mcp = & mc;
#line 4766
  ha = vha->hw;
#line 4768
  ql_dbg(536903680U, vha, 4358, "Entered %s.\n", "qla2x00_get_data_rate");
#line 4771
  if ((ha->device_type & 134217728U) == 0U) {
#line 4772
    return (258);
  } else {

  }
#line 4774
  mcp->mb[0] = 93U;
#line 4775
  mcp->mb[1] = 0U;
#line 4776
  mcp->out_mb = 3U;
#line 4777
  mcp->in_mb = 7U;
#line 4778
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 4779
    mcp->in_mb = mcp->in_mb | 8U;
  } else {

  }
#line 4780
  mcp->tov = 30U;
#line 4781
  mcp->flags = 0U;
#line 4782
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4783
  if (rval != 0) {
#line 4784
    ql_dbg(536870912U, vha, 4359, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4787
    ql_dbg(536903680U, vha, 4360, "Done %s.\n", "qla2x00_get_data_rate");
#line 4789
    if ((unsigned int )mcp->mb[1] != 7U) {
#line 4790
      ha->link_data_rate = mcp->mb[1];
    } else {

    }
  }
#line 4793
  return (rval);
}
}
#line 4797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_get_port_config(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 4801
  mcp = & mc;
#line 4802
  ha = vha->hw;
#line 4804
  ql_dbg(536903680U, vha, 4361, "Entered %s.\n", "qla81xx_get_port_config");
#line 4807
  if (((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) && (ha->device_type & 262144U) == 0U) {
#line 4808
    return (258);
  } else {

  }
#line 4809
  mcp->mb[0] = 291U;
#line 4810
  mcp->out_mb = 1U;
#line 4811
  mcp->in_mb = 31U;
#line 4812
  mcp->tov = 30U;
#line 4813
  mcp->flags = 0U;
#line 4815
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4817
  if (rval != 0) {
#line 4818
    ql_dbg(536870912U, vha, 4362, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4822
    __len = 8UL;
#line 4822
    if (__len > 63UL) {
#line 4822
      __ret = __memcpy((void *)mb, (void const   *)(& mcp->mb) + 1U, __len);
    } else {
#line 4822
      __ret = __builtin_memcpy((void *)mb, (void const   *)(& mcp->mb) + 1U, __len);
    }
#line 4824
    ql_dbg(536903680U, vha, 4363, "Done %s.\n", "qla81xx_get_port_config");
  }
#line 4827
  return (rval);
}
}
#line 4831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_set_port_config(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  size_t __len ;
  void *__ret ;

  {
#line 4835
  mcp = & mc;
#line 4837
  ql_dbg(536903680U, vha, 4364, "Entered %s.\n", "qla81xx_set_port_config");
#line 4840
  mcp->mb[0] = 290U;
#line 4842
  __len = 8UL;
#line 4842
  if (__len > 63UL) {
#line 4842
    __ret = __memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, __len);
  } else {
#line 4842
    __ret = __builtin_memcpy((void *)(& mcp->mb) + 1U, (void const   *)mb, __len);
  }
#line 4843
  mcp->out_mb = 31U;
#line 4844
  mcp->in_mb = 1U;
#line 4845
  mcp->tov = 30U;
#line 4846
  mcp->flags = 0U;
#line 4847
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4849
  if (rval != 0) {
#line 4850
    ql_dbg(536870912U, vha, 4365, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4853
    ql_dbg(536903680U, vha, 4366, "Done %s.\n", "qla81xx_set_port_config");
  }
#line 4856
  return (rval);
}
}
#line 4861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla24xx_set_fcp_prio(scsi_qla_host_t *vha , uint16_t loop_id , uint16_t priority ,
                         uint16_t *mb ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 4866
  mcp = & mc;
#line 4867
  ha = vha->hw;
#line 4869
  ql_dbg(536903680U, vha, 4367, "Entered %s.\n", "qla24xx_set_fcp_prio");
#line 4872
  if (((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) {
#line 4873
    return (258);
  } else {

  }
#line 4875
  mcp->mb[0] = 26U;
#line 4876
  mcp->mb[1] = loop_id;
#line 4877
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4878
    mcp->mb[2] = 2U;
  } else {
#line 4880
    mcp->mb[2] = 4U;
  }
#line 4881
  mcp->mb[4] = (unsigned int )priority & 15U;
#line 4882
  mcp->mb[9] = vha->vp_idx;
#line 4883
  mcp->out_mb = 543U;
#line 4884
  mcp->in_mb = 27U;
#line 4885
  mcp->tov = 30U;
#line 4886
  mcp->flags = 0U;
#line 4887
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4888
  if ((unsigned long )mb != (unsigned long )((uint16_t *)0U)) {
#line 4889
    *mb = mcp->mb[0];
#line 4890
    *(mb + 1UL) = mcp->mb[1];
#line 4891
    *(mb + 3UL) = mcp->mb[3];
#line 4892
    *(mb + 4UL) = mcp->mb[4];
  } else {

  }
#line 4895
  if (rval != 0) {
#line 4896
    ql_dbg(536870912U, vha, 4301, "Failed=%x.\n", rval);
  } else {
#line 4898
    ql_dbg(536903680U, vha, 4300, "Done %s.\n", "qla24xx_set_fcp_prio");
  }
#line 4902
  return (rval);
}
}
#line 4906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_get_thermal_temp(scsi_qla_host_t *vha , uint16_t *temp ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint8_t byte ;
  int tmp ;
  int tmp___0 ;

  {
#line 4908
  rval = 258;
#line 4909
  ha = vha->hw;
#line 4912
  if (((ha->device_type & 134217728U) == 0U || ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U)) || (ha->device_type & 8192U) != 0U) {
#line 4913
    ql_dbg(536870912U, vha, 4432, "Thermal not supported by this card.\n");
#line 4915
    return (rval);
  } else {

  }
#line 4918
  if ((ha->device_type & 2048U) != 0U) {
#line 4919
    if ((unsigned int )(ha->pdev)->subsystem_vendor == 4215U && (unsigned int )(ha->pdev)->subsystem_device == 373U) {
#line 4921
      rval = qla2x00_read_sfp(vha, 0ULL, & byte, 152, 1, 1, 8193);
#line 4923
      *temp = (uint16_t )byte;
#line 4924
      return (rval);
    } else {

    }
#line 4926
    if ((unsigned int )(ha->pdev)->subsystem_vendor == 4156U && (unsigned int )(ha->pdev)->subsystem_device == 13198U) {
#line 4928
      rval = qla2x00_read_sfp(vha, 0ULL, & byte, 152, 1, 1, 49153);
#line 4930
      *temp = (uint16_t )byte;
#line 4931
      return (rval);
    } else {

    }
#line 4933
    ql_dbg(536870912U, vha, 4297, "Thermal not supported by this card.\n");
#line 4935
    return (rval);
  } else {

  }
#line 4938
  if ((ha->device_type & 16384U) != 0U) {
#line 4939
    tmp = qla82xx_read_temperature(vha);
#line 4939
    *temp = (uint16_t )tmp;
#line 4940
    rval = 0;
#line 4941
    return (rval);
  } else
#line 4942
  if ((ha->device_type & 262144U) != 0U) {
#line 4943
    tmp___0 = qla8044_read_temperature(vha);
#line 4943
    *temp = (uint16_t )tmp___0;
#line 4944
    rval = 0;
#line 4945
    return (rval);
  } else {

  }
#line 4948
  rval = qla2x00_read_asic_temperature(vha, temp);
#line 4949
  return (rval);
}
}
#line 4953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_mbx_intr_enable(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4956
  ha = vha->hw;
#line 4958
  mcp = & mc;
#line 4960
  ql_dbg(536903680U, vha, 4119, "Entered %s.\n", "qla82xx_mbx_intr_enable");
#line 4963
  if ((ha->device_type & 134217728U) == 0U) {
#line 4964
    return (258);
  } else {

  }
#line 4966
  memset((void *)mcp, 0, 96UL);
#line 4967
  mcp->mb[0] = 16U;
#line 4968
  mcp->mb[1] = 1U;
#line 4970
  mcp->out_mb = 3U;
#line 4971
  mcp->in_mb = 1U;
#line 4972
  mcp->tov = 30U;
#line 4973
  mcp->flags = 0U;
#line 4975
  rval = qla2x00_mailbox_command(vha, mcp);
#line 4976
  if (rval != 0) {
#line 4977
    ql_dbg(536870912U, vha, 4118, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 4980
    ql_dbg(536903680U, vha, 4110, "Done %s.\n", "qla82xx_mbx_intr_enable");
  }
#line 4984
  return (rval);
}
}
#line 4988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_mbx_intr_disable(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 4991
  ha = vha->hw;
#line 4993
  mcp = & mc;
#line 4995
  ql_dbg(536903680U, vha, 4109, "Entered %s.\n", "qla82xx_mbx_intr_disable");
#line 4998
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 4999
    return (258);
  } else {

  }
#line 5001
  memset((void *)mcp, 0, 96UL);
#line 5002
  mcp->mb[0] = 16U;
#line 5003
  mcp->mb[1] = 0U;
#line 5005
  mcp->out_mb = 3U;
#line 5006
  mcp->in_mb = 1U;
#line 5007
  mcp->tov = 30U;
#line 5008
  mcp->flags = 0U;
#line 5010
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5011
  if (rval != 0) {
#line 5012
    ql_dbg(536870912U, vha, 4108, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5015
    ql_dbg(536903680U, vha, 4107, "Done %s.\n", "qla82xx_mbx_intr_disable");
  }
#line 5019
  return (rval);
}
}
#line 5023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_md_get_template_size(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;

  {
#line 5025
  ha = vha->hw;
#line 5027
  mcp = & mc;
#line 5028
  rval = 258;
#line 5030
  ql_dbg(536903680U, vha, 4383, "Entered %s.\n", "qla82xx_md_get_template_size");
#line 5033
  memset((void *)(& mcp->mb), 0, 64UL);
#line 5034
  mcp->mb[0] = 297U;
#line 5035
  mcp->mb[1] = 0U;
#line 5036
  mcp->mb[2] = 0U;
#line 5037
  mcp->mb[3] = 0U;
#line 5039
  mcp->out_mb = 15U;
#line 5040
  mcp->in_mb = 32767U;
#line 5043
  mcp->flags = 7U;
#line 5044
  mcp->tov = 30U;
#line 5045
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5048
  if (rval != 0) {
#line 5049
    ql_dbg(536870912U, vha, 4384, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  } else {
#line 5054
    ql_dbg(536903680U, vha, 4385, "Done %s.\n", "qla82xx_md_get_template_size");
#line 5056
    ha->md_template_size = (uint32_t )(((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
#line 5057
    if (ha->md_template_size == 0U) {
#line 5058
      ql_dbg(536870912U, vha, 4386, "Null template size obtained.\n");
#line 5060
      rval = 258;
    } else {

    }
  }
#line 5063
  return (rval);
}
}
#line 5067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_md_get_template(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;

  {
#line 5069
  ha = vha->hw;
#line 5071
  mcp = & mc;
#line 5072
  rval = 258;
#line 5074
  ql_dbg(536903680U, vha, 4387, "Entered %s.\n", "qla82xx_md_get_template");
#line 5077
  ha->md_tmplt_hdr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size,
                                     & ha->md_tmplt_hdr_dma, 208U, (struct dma_attrs *)0);
#line 5079
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0)) {
#line 5080
    ql_log(1U, vha, 4388, "Unable to allocate memory for Minidump template.\n");
#line 5082
    return (rval);
  } else {

  }
#line 5085
  memset((void *)(& mcp->mb), 0, 64UL);
#line 5086
  mcp->mb[0] = 297U;
#line 5087
  mcp->mb[1] = 0U;
#line 5088
  mcp->mb[2] = 1U;
#line 5089
  mcp->mb[3] = 0U;
#line 5090
  mcp->mb[4] = (unsigned short )ha->md_tmplt_hdr_dma;
#line 5091
  mcp->mb[5] = (unsigned short )((unsigned int )ha->md_tmplt_hdr_dma >> 16);
#line 5092
  mcp->mb[6] = (unsigned short )(ha->md_tmplt_hdr_dma >> 32ULL);
#line 5093
  mcp->mb[7] = (unsigned short )((unsigned int )(ha->md_tmplt_hdr_dma >> 32ULL) >> 16);
#line 5094
  mcp->mb[8] = (unsigned short )ha->md_template_size;
#line 5095
  mcp->mb[9] = (unsigned short )(ha->md_template_size >> 16);
#line 5097
  mcp->flags = 7U;
#line 5098
  mcp->tov = 30U;
#line 5099
  mcp->out_mb = 4095U;
#line 5101
  mcp->in_mb = 15U;
#line 5102
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5104
  if (rval != 0) {
#line 5105
    ql_dbg(536870912U, vha, 4389, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
  } else {
#line 5110
    ql_dbg(536903680U, vha, 4390, "Done %s.\n", "qla82xx_md_get_template");
  }
#line 5112
  return (rval);
}
}
#line 5116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla8044_md_get_template(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  int rval ;
  int offset ;
  int size ;

  {
#line 5118
  ha = vha->hw;
#line 5120
  mcp = & mc;
#line 5121
  rval = 258;
#line 5122
  offset = 0;
#line 5122
  size = 36864;
#line 5123
  ql_dbg(536903680U, vha, 45343, "Entered %s.\n", "qla8044_md_get_template");
#line 5126
  ha->md_tmplt_hdr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size,
                                     & ha->md_tmplt_hdr_dma, 208U, (struct dma_attrs *)0);
#line 5128
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0)) {
#line 5129
    ql_log(1U, vha, 45339, "Unable to allocate memory for Minidump template.\n");
#line 5131
    return (rval);
  } else {

  }
#line 5134
  memset((void *)(& mcp->mb), 0, 64UL);
#line 5135
  goto ldv_61723;
  ldv_61722: 
#line 5136
  mcp->mb[0] = 297U;
#line 5137
  mcp->mb[1] = 0U;
#line 5138
  mcp->mb[2] = 1U;
#line 5139
  mcp->mb[3] = 0U;
#line 5140
  mcp->mb[4] = (int )((unsigned short )ha->md_tmplt_hdr_dma) + (int )((unsigned short )offset);
#line 5141
  mcp->mb[5] = (unsigned short )(((unsigned int )ha->md_tmplt_hdr_dma + (unsigned int )offset) >> 16);
#line 5142
  mcp->mb[6] = (unsigned short )((ha->md_tmplt_hdr_dma + (dma_addr_t )offset) >> 32ULL);
#line 5143
  mcp->mb[7] = (unsigned short )((unsigned int )((ha->md_tmplt_hdr_dma + (dma_addr_t )offset) >> 32ULL) >> 16);
#line 5144
  mcp->mb[8] = (unsigned short )size;
#line 5145
  mcp->mb[9] = (unsigned short )((unsigned int )size >> 16);
#line 5146
  mcp->mb[10] = (uint16_t )offset;
#line 5147
  mcp->mb[11] = 0U;
#line 5148
  mcp->flags = 7U;
#line 5149
  mcp->tov = 30U;
#line 5150
  mcp->out_mb = 4095U;
#line 5152
  mcp->in_mb = 15U;
#line 5153
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5155
  if (rval != 0) {
#line 5156
    ql_dbg(536870912U, vha, 45340, "mailbox command FAILED=0x%x, subcode=%x.\n", ((int )mcp->mb[1] << 16) | (int )mcp->mb[0],
           ((int )mcp->mb[3] << 16) | (int )mcp->mb[2]);
#line 5160
    return (rval);
  } else {
#line 5162
    ql_dbg(536903680U, vha, 45341, "Done %s.\n", "qla8044_md_get_template");
  }
#line 5164
  offset = offset + size;
  ldv_61723: ;
#line 5135
  if ((uint32_t )offset < ha->md_template_size) {
#line 5137
    goto ldv_61722;
  } else {

  }

#line 5166
  return (rval);
}
}
#line 5170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_set_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5173
  ha = vha->hw;
#line 5175
  mcp = & mc;
#line 5177
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5178
    return (258);
  } else {

  }
#line 5180
  ql_dbg(536903680U, vha, 4403, "Entered %s.\n", "qla81xx_set_led_config");
#line 5183
  memset((void *)mcp, 0, 96UL);
#line 5184
  mcp->mb[0] = 293U;
#line 5185
  mcp->mb[1] = *led_cfg;
#line 5186
  mcp->mb[2] = *(led_cfg + 1UL);
#line 5187
  if ((ha->device_type & 65536U) != 0U) {
#line 5188
    mcp->mb[3] = *(led_cfg + 2UL);
#line 5189
    mcp->mb[4] = *(led_cfg + 3UL);
#line 5190
    mcp->mb[5] = *(led_cfg + 4UL);
#line 5191
    mcp->mb[6] = *(led_cfg + 5UL);
  } else {

  }
#line 5194
  mcp->out_mb = 7U;
#line 5195
  if ((ha->device_type & 65536U) != 0U) {
#line 5196
    mcp->out_mb = mcp->out_mb | 120U;
  } else {

  }
#line 5197
  mcp->in_mb = 1U;
#line 5198
  mcp->tov = 30U;
#line 5199
  mcp->flags = 0U;
#line 5201
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5202
  if (rval != 0) {
#line 5203
    ql_dbg(536870912U, vha, 4404, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5206
    ql_dbg(536903680U, vha, 4405, "Done %s.\n", "qla81xx_set_led_config");
  }
#line 5210
  return (rval);
}
}
#line 5214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla81xx_get_led_config(scsi_qla_host_t *vha , uint16_t *led_cfg ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5217
  ha = vha->hw;
#line 5219
  mcp = & mc;
#line 5221
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5222
    return (258);
  } else {

  }
#line 5224
  ql_dbg(536903680U, vha, 4406, "Entered %s.\n", "qla81xx_get_led_config");
#line 5227
  memset((void *)mcp, 0, 96UL);
#line 5228
  mcp->mb[0] = 294U;
#line 5230
  mcp->out_mb = 1U;
#line 5231
  mcp->in_mb = 7U;
#line 5232
  if ((ha->device_type & 65536U) != 0U) {
#line 5233
    mcp->in_mb = mcp->in_mb | 120U;
  } else {

  }
#line 5234
  mcp->tov = 30U;
#line 5235
  mcp->flags = 0U;
#line 5237
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5238
  if (rval != 0) {
#line 5239
    ql_dbg(536870912U, vha, 4407, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5242
    *led_cfg = mcp->mb[1];
#line 5243
    *(led_cfg + 1UL) = mcp->mb[2];
#line 5244
    if ((ha->device_type & 65536U) != 0U) {
#line 5245
      *(led_cfg + 2UL) = mcp->mb[3];
#line 5246
      *(led_cfg + 3UL) = mcp->mb[4];
#line 5247
      *(led_cfg + 4UL) = mcp->mb[5];
#line 5248
      *(led_cfg + 5UL) = mcp->mb[6];
    } else {

    }
#line 5250
    ql_dbg(536903680U, vha, 4408, "Done %s.\n", "qla81xx_get_led_config");
  }
#line 5254
  return (rval);
}
}
#line 5258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha , int enable ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5261
  ha = vha->hw;
#line 5263
  mcp = & mc;
#line 5265
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 5266
    return (258);
  } else {

  }
#line 5268
  ql_dbg(536903680U, vha, 4391, "Entered %s.\n", "qla82xx_mbx_beacon_ctl");
#line 5271
  memset((void *)mcp, 0, 96UL);
#line 5272
  mcp->mb[0] = 293U;
#line 5273
  if (enable != 0) {
#line 5274
    mcp->mb[7] = 14U;
  } else {
#line 5276
    mcp->mb[7] = 13U;
  }
#line 5278
  mcp->out_mb = 129U;
#line 5279
  mcp->in_mb = 1U;
#line 5280
  mcp->tov = 30U;
#line 5281
  mcp->flags = 0U;
#line 5283
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5284
  if (rval != 0) {
#line 5285
    ql_dbg(536870912U, vha, 4392, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5288
    ql_dbg(536903680U, vha, 4393, "Done %s.\n", "qla82xx_mbx_beacon_ctl");
  }
#line 5292
  return (rval);
}
}
#line 5296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla83xx_wr_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t data ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5299
  ha = vha->hw;
#line 5301
  mcp = & mc;
#line 5303
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5304
    return (258);
  } else {

  }
#line 5306
  ql_dbg(536903680U, vha, 4400, "Entered %s.\n", "qla83xx_wr_reg");
#line 5309
  mcp->mb[0] = 1U;
#line 5310
  mcp->mb[1] = (unsigned short )reg;
#line 5311
  mcp->mb[2] = (unsigned short )(reg >> 16);
#line 5312
  mcp->mb[3] = (unsigned short )data;
#line 5313
  mcp->mb[4] = (unsigned short )(data >> 16);
#line 5314
  mcp->out_mb = 31U;
#line 5316
  mcp->in_mb = 3U;
#line 5317
  mcp->tov = 30U;
#line 5318
  mcp->flags = 0U;
#line 5319
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5321
  if (rval != 0) {
#line 5322
    ql_dbg(536870912U, vha, 4401, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5325
    ql_dbg(536903680U, vha, 4402, "Done %s.\n", "qla83xx_wr_reg");
  }
#line 5329
  return (rval);
}
}
#line 5333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_port_logout(scsi_qla_host_t *vha , struct fc_port *fcport ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5336
  ha = vha->hw;
#line 5338
  mcp = & mc;
#line 5340
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 5341
    ql_dbg(536903680U, vha, 4411, "Implicit LOGO Unsupported.\n");
#line 5343
    return (258);
  } else {

  }
#line 5347
  ql_dbg(536903680U, vha, 4412, "Entering %s.\n", "qla2x00_port_logout");
#line 5351
  mcp->mb[0] = 86U;
#line 5352
  mcp->mb[1] = fcport->loop_id;
#line 5353
  mcp->mb[10] = 32768U;
#line 5354
  mcp->out_mb = 1027U;
#line 5355
  mcp->in_mb = 1U;
#line 5356
  mcp->tov = 30U;
#line 5357
  mcp->flags = 0U;
#line 5358
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5359
  if (rval != 0) {
#line 5360
    ql_dbg(536870912U, vha, 4413, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5363
    ql_dbg(536903680U, vha, 4414, "Done %s.\n", "qla2x00_port_logout");
  }
#line 5366
  return (rval);
}
}
#line 5370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla83xx_rd_reg(scsi_qla_host_t *vha , uint32_t reg , uint32_t *data ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;
  unsigned long retry_max_time ;

  {
#line 5374
  mcp = & mc;
#line 5375
  ha = vha->hw;
#line 5376
  retry_max_time = (unsigned long )jiffies + 500UL;
#line 5378
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5379
    return (258);
  } else {

  }
#line 5381
  ql_dbg(536870912U, vha, 4427, "Entered %s.\n", "qla83xx_rd_reg");
  retry_rd_reg: 
#line 5384
  mcp->mb[0] = 9U;
#line 5385
  mcp->mb[1] = (unsigned short )reg;
#line 5386
  mcp->mb[2] = (unsigned short )(reg >> 16);
#line 5387
  mcp->out_mb = 7U;
#line 5388
  mcp->in_mb = 27U;
#line 5389
  mcp->tov = 30U;
#line 5390
  mcp->flags = 0U;
#line 5391
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5393
  if (rval != 0) {
#line 5394
    ql_dbg(536870912U, vha, 4428, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
  } else {
#line 5398
    *data = (uint32_t )((int )mcp->mb[3] | ((int )mcp->mb[4] << 16));
#line 5399
    if (*data == 3134241488U) {
#line 5405
      if ((long )(retry_max_time - (unsigned long )jiffies) < 0L) {
#line 5406
        ql_dbg(536870912U, vha, 4417, "Failure to read CAMRAM register. data=0x%x.\n",
               *data);
#line 5409
        return (258);
      } else {

      }
#line 5411
      msleep(100U);
#line 5412
      goto retry_rd_reg;
    } else {

    }
#line 5414
    ql_dbg(536870912U, vha, 4418, "Done %s.\n", "qla83xx_rd_reg");
  }
#line 5417
  return (rval);
}
}
#line 5421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla83xx_restart_nic_firmware(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  struct qla_hw_data *ha ;

  {
#line 5425
  mcp = & mc;
#line 5426
  ha = vha->hw;
#line 5428
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 5429
    return (258);
  } else {

  }
#line 5431
  ql_dbg(536870912U, vha, 4419, "Entered %s.\n", "qla83xx_restart_nic_firmware");
#line 5433
  mcp->mb[0] = 61U;
#line 5434
  mcp->out_mb = 1U;
#line 5435
  mcp->in_mb = 3U;
#line 5436
  mcp->tov = 30U;
#line 5437
  mcp->flags = 0U;
#line 5438
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5440
  if (rval != 0) {
#line 5441
    ql_dbg(536870912U, vha, 4420, "Failed=%x mb[0]=%x mb[1]=%x.\n", rval, (int )mcp->mb[0],
           (int )mcp->mb[1]);
#line 5444
    (*((ha->isp_ops)->fw_dump))(vha, 0);
  } else {
#line 5446
    ql_dbg(536870912U, vha, 4421, "Done %s.\n", "qla83xx_restart_nic_firmware");
  }
#line 5449
  return (rval);
}
}
#line 5453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla83xx_access_control(scsi_qla_host_t *vha , uint16_t options , uint32_t start_addr ,
                           uint32_t end_addr , uint16_t *sector_size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;
  uint8_t subcode ;
  struct qla_hw_data *ha ;

  {
#line 5458
  mcp = & mc;
#line 5459
  subcode = (unsigned char )options;
#line 5460
  ha = vha->hw;
#line 5462
  if ((ha->device_type & 65536U) == 0U) {
#line 5463
    return (258);
  } else {

  }
#line 5465
  ql_dbg(536870912U, vha, 4422, "Entered %s.\n", "qla83xx_access_control");
#line 5467
  mcp->mb[0] = 62U;
#line 5468
  mcp->mb[1] = options;
#line 5469
  mcp->out_mb = 3U;
#line 5470
  if (((int )subcode & 4) != 0) {
#line 5471
    mcp->mb[2] = (unsigned short )start_addr;
#line 5472
    mcp->mb[3] = (unsigned short )(start_addr >> 16);
#line 5473
    mcp->mb[4] = (unsigned short )end_addr;
#line 5474
    mcp->mb[5] = (unsigned short )(end_addr >> 16);
#line 5475
    mcp->out_mb = mcp->out_mb | 60U;
  } else {

  }
#line 5477
  mcp->in_mb = 7U;
#line 5478
  if (((int )subcode & 36) == 0) {
#line 5479
    mcp->in_mb = mcp->in_mb | 24U;
  } else {

  }
#line 5480
  mcp->tov = 30U;
#line 5481
  mcp->flags = 0U;
#line 5482
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5484
  if (rval != 0) {
#line 5485
    ql_dbg(536870912U, vha, 4423, "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[4]=%x.\n",
           rval, (int )mcp->mb[0], (int )mcp->mb[1], (int )mcp->mb[2], (int )mcp->mb[3],
           (int )mcp->mb[4]);
#line 5489
    (*((ha->isp_ops)->fw_dump))(vha, 0);
  } else {
#line 5491
    if (((int )subcode & 32) != 0) {
#line 5492
      *sector_size = mcp->mb[1];
    } else
#line 5493
    if (((int )subcode & 192) != 0) {
#line 5494
      ql_dbg(536870912U, vha, 4424, "Driver-lock id=%x%x", (int )mcp->mb[4], (int )mcp->mb[3]);
    } else
#line 5496
    if (((int )subcode & 24) != 0) {
#line 5497
      ql_dbg(536870912U, vha, 4425, "Flash-lock id=%x%x", (int )mcp->mb[4], (int )mcp->mb[3]);
    } else {

    }
#line 5500
    ql_dbg(536870912U, vha, 4426, "Done %s.\n", "qla83xx_access_control");
  }
#line 5503
  return (rval);
}
}
#line 5507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int qla2x00_dump_mctp_data(scsi_qla_host_t *vha , dma_addr_t req_dma , uint32_t addr ,
                           uint32_t size ) 
{ 
  int rval ;
  mbx_cmd_t mc ;
  mbx_cmd_t *mcp ;

  {
#line 5512
  mcp = & mc;
#line 5514
  if (((vha->hw)->device_type & 32768U) == 0U || ((int )(vha->hw)->fw_attributes_ext[0] & 1) == 0) {
#line 5515
    return (258);
  } else {

  }
#line 5517
  ql_dbg(536903680U, vha, 4431, "Entered %s.\n", "qla2x00_dump_mctp_data");
#line 5520
  mcp->mb[0] = 12U;
#line 5521
  mcp->mb[1] = (unsigned short )addr;
#line 5522
  mcp->mb[2] = (unsigned short )((unsigned int )req_dma >> 16);
#line 5523
  mcp->mb[3] = (unsigned short )req_dma;
#line 5524
  mcp->mb[4] = (unsigned short )(size >> 16);
#line 5525
  mcp->mb[5] = (unsigned short )size;
#line 5526
  mcp->mb[6] = (unsigned short )((unsigned int )(req_dma >> 32ULL) >> 16);
#line 5527
  mcp->mb[7] = (unsigned short )(req_dma >> 32ULL);
#line 5528
  mcp->mb[8] = (unsigned short )(addr >> 16);
#line 5530
  mcp->mb[10] = (uint16_t )((unsigned int )mcp->mb[10] | 128U);
#line 5532
  mcp->mb[10] = (uint16_t )((unsigned int )mcp->mb[10] | 64U);
#line 5534
  mcp->out_mb = mcp->out_mb | 1535U;
#line 5537
  mcp->in_mb = 1U;
#line 5538
  mcp->tov = 30U;
#line 5539
  mcp->flags = 0U;
#line 5540
  rval = qla2x00_mailbox_command(vha, mcp);
#line 5542
  if (rval != 0) {
#line 5543
    ql_dbg(536870912U, vha, 4430, "Failed=%x mb[0]=%x.\n", rval, (int )mcp->mb[0]);
  } else {
#line 5546
    ql_dbg(536903680U, vha, 4429, "Done %s.\n", "qla2x00_dump_mctp_data");
  }
#line 5550
  return (rval);
}
}
#line 5554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5554
  if ((unsigned long )ldv_timer_list_4 == (unsigned long )timer) {
#line 5555
    if (ldv_timer_state_4 == 2 || pending_flag != 0) {
#line 5556
      ldv_timer_list_4 = timer;
#line 5557
      ldv_timer_list_4->data = data;
#line 5558
      ldv_timer_state_4 = 1;
    } else {

    }
#line 5560
    return;
  } else {

  }
#line 5562
  reg_timer_4(timer);
#line 5563
  ldv_timer_list_4->data = data;
#line 5564
  return;
}
}
#line 5567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5568
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_4) {
#line 5569
    ldv_timer_state_4 = 0;
#line 5570
    return;
  } else {

  }
#line 5572
  return;
}
}
#line 5575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
void choose_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5576
  LDV_IN_INTERRUPT = 2;
#line 5577
  (*(timer->function))(timer->data);
#line 5578
  LDV_IN_INTERRUPT = 1;
#line 5579
  ldv_timer_state_4 = 2;
#line 5580
  return;
}
}
#line 5583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int reg_timer_4(struct timer_list *timer ) 
{ 


  {
#line 5584
  ldv_timer_list_4 = timer;
#line 5585
  ldv_timer_state_4 = 1;
#line 5586
  return (0);
}
}
#line 5588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int ldv_del_timer_23(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 5592
  tmp = del_timer(ldv_func_arg1);
#line 5592
  ldv_func_res = tmp;
#line 5594
  disable_suitable_timer_7(ldv_func_arg1);
#line 5596
  return (ldv_func_res);
}
}
#line 5599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mbx.o.c.prepared"
int ldv_scsi_add_host_with_dma_24(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 5603
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 5603
  ldv_func_res = tmp;
#line 5605
  if (ldv_func_res == 0) {
#line 5606
    ldv_state_variable_72 = 1;
#line 5606
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 5610
  return (ldv_func_res);
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_27(struct timer_list *ldv_func_arg1 ) ;
#line 58 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned short __readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 58
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
#line 58
  return (ret);
}
}
#line 59 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 59
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 59
  return (ret);
}
}
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 61
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 62
  return;
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void choose_timer_5(struct timer_list *timer ) ;
#line 224
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 293
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 297
int reg_timer_5(struct timer_list *timer ) ;
#line 755 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 757
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 95 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 98
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 98
  if (tmp != 0L) {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
    ldv_20741: ;
#line 98
    goto ldv_20741;
  } else {

  }
#line 99
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 99
  if (tmp___0 != 0L) {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
    ldv_20742: ;
#line 99
    goto ldv_20742;
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 218 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 220
  tmp = sg_page(sg);
#line 220
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 220
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 224
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 42 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 46
  tmp = get_dma_ops(dev);
#line 46
  ops = tmp;
#line 50
  i = 0;
#line 50
  s = sg;
#line 50
  goto ldv_21291;
  ldv_21290: 
#line 51
  tmp___0 = sg_virt(s);
#line 51
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 50
  i = i + 1;
#line 50
  s = sg_next(s);
  ldv_21291: ;
#line 50
  if (i < nents) {
#line 52
    goto ldv_21290;
  } else {

  }
#line 52
  tmp___1 = valid_dma_direction((int )dir);
#line 52
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 52
  if (tmp___2 != 0L) {
#line 52
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (52), "i" (12UL));
    ldv_21293: ;
#line 52
    goto ldv_21293;
  } else {

  }
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 56
  return (ents);
}
}
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_28(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 919 "include/scsi/scsi_host.h"
__inline static unsigned char scsi_host_get_guard(struct Scsi_Host *shost ) 
{ 


  {
#line 921
  return (shost->prot_guard_type);
}
}
#line 816 "include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 


  {
#line 818
  return ((sector_t )rq->__sector);
}
}
#line 161 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 163
  return (cmd->sdb.table.nents);
}
}
#line 166 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 168
  return (cmd->sdb.table.sgl);
}
}
#line 171 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 173
  return (cmd->sdb.length);
}
}
#line 269 "include/scsi/scsi_cmnd.h"
__inline static unsigned char scsi_get_prot_type(struct scsi_cmnd *scmd ) 
{ 


  {
#line 271
  return (scmd->prot_type);
}
}
#line 274 "include/scsi/scsi_cmnd.h"
__inline static sector_t scsi_get_lba(struct scsi_cmnd *scmd ) 
{ 
  sector_t tmp ;

  {
#line 276
  tmp = blk_rq_pos((struct request  const  *)scmd->request);
#line 276
  return (tmp);
}
}
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void *qla2x00_alloc_iocbs(struct scsi_qla_host *vha , srb_t *sp ) ;
#line 216
int qla2x00_start_bidir(srb_t *sp , struct scsi_qla_host *vha , uint32_t tot_dsds ) ;
#line 220
int qla2x00_issue_marker(scsi_qla_host_t *vha , int ha_locked ) ;
#line 424
void qla2x00_process_response_queue(struct rsp_que *rsp ) ;
#line 426
void qla24xx_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) ;
#line 610
void qlafx00_tm_iocb(srb_t *sp , struct tsk_mgmt_entry_fx00 *ptm_iocb ) ;
#line 611
void qlafx00_abort_iocb(srb_t *sp , struct abort_iocb_entry_fx00 *pabt_iocb ) ;
#line 612
void qlafx00_fxdisc_iocb(srb_t *sp , struct fxdisc_entry_fx00 *pfxiocb ) ;
#line 648
void qla2x00_start_iocbs(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 680
void qla82xx_start_iocbs(scsi_qla_host_t *vha ) ;
#line 17 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla24xx_calc_iocbs(scsi_qla_host_t *vha , uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 21
  iocbs = 1U;
#line 22
  if ((unsigned int )dsds > 1U) {
#line 23
    iocbs = (int )((uint16_t )(((int )dsds + -1) / 5)) + (int )iocbs;
#line 24
    if (((int )dsds + -1) % 5 != 0) {
#line 25
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 27
  return (iocbs);
}
}
#line 41 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static uint16_t qla2x00_debounce_register___0(uint16_t volatile   *addr ) 
{ 
  uint16_t volatile   first ;
  uint16_t volatile   second ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
  ldv_43294: 
#line 47
  tmp = readw((void const volatile   *)addr);
#line 47
  first = tmp;
#line 48
  __asm__  volatile   ("": : : "memory");
#line 49
  cpu_relax();
#line 50
  tmp___0 = readw((void const volatile   *)addr);
#line 50
  second = tmp___0;
#line 51
  if ((int )((unsigned short )first) != (int )((unsigned short )second)) {
#line 53
    goto ldv_43294;
  } else {

  }

#line 53
  return ((uint16_t )first);
}
}
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_hba_err_chk_enabled(srb_t *sp ) 
{ 
  unsigned char tmp ;

  {
#line 178
  tmp = scsi_get_prot_op(sp->u.scmd.cmd);
#line 178
  switch ((int )tmp) {
  case 3: ;
  case 4: ;
#line 181
  if (ql2xenablehba_err_chk > 0) {
#line 182
    return (1);
  } else {

  }
#line 183
  goto ldv_43377;
  case 5: ;
  case 6: ;
#line 186
  if (ql2xenablehba_err_chk > 1) {
#line 187
    return (1);
  } else {

  }
#line 188
  goto ldv_43377;
  case 1: ;
  case 2: ;
#line 191
  return (1);
  }
  ldv_43377: ;
#line 193
  return (0);
}
}
#line 98 "include/scsi/scsi_tcq.h"
__inline static int scsi_populate_tag_msg(struct scsi_cmnd *cmd , char *msg ) 
{ 
  struct request *req ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 100
  req = cmd->request;
#line 102
  if ((req->cmd_flags & 1048576U) != 0U) {
#line 103
    tmp = msg;
#line 103
    msg = msg + 1;
#line 103
    *tmp = 32;
#line 104
    tmp___0 = msg;
#line 104
    msg = msg + 1;
#line 104
    *tmp___0 = (char )req->tag;
#line 105
    return (2);
  } else {

  }
#line 108
  return (0);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla25xx_set_que(srb_t *sp , struct rsp_que **rsp ) ;
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static uint16_t qla2x00_get_cmd_direction(srb_t *sp ) 
{ 
  uint16_t cflags ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 325
  cmd = sp->u.scmd.cmd;
#line 326
  vha = (sp->fcport)->vha;
#line 328
  cflags = 0U;
#line 331
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 332
    cflags = 64U;
#line 333
    tmp = scsi_bufflen(cmd);
#line 333
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp;
#line 334
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 335
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 336
    cflags = 32U;
#line 337
    tmp___0 = scsi_bufflen(cmd);
#line 337
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___0;
#line 338
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 340
  return (cflags);
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
uint16_t qla2x00_calc_iocbs_32(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 356
  iocbs = 1U;
#line 357
  if ((unsigned int )dsds > 3U) {
#line 358
    iocbs = (int )((uint16_t )(((int )dsds + -3) / 7)) + (int )iocbs;
#line 359
    if (((int )dsds + -3) % 7 != 0) {
#line 360
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 362
  return (iocbs);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
uint16_t qla2x00_calc_iocbs_64(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 378
  iocbs = 1U;
#line 379
  if ((unsigned int )dsds > 2U) {
#line 380
    iocbs = (int )((uint16_t )(((int )dsds + -2) / 5)) + (int )iocbs;
#line 381
    if (((int )dsds + -2) % 5 != 0) {
#line 382
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 384
  return (iocbs);
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static cont_entry_t *qla2x00_prep_cont_type0_iocb(struct scsi_qla_host *vha ) 
{ 
  cont_entry_t *cont_pkt ;
  struct req_que *req ;

  {
#line 397
  req = vha->req;
#line 399
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 400
  if ((int )req->ring_index == (int )req->length) {
#line 401
    req->ring_index = 0U;
#line 402
    req->ring_ptr = req->ring;
  } else {
#line 404
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 407
  cont_pkt = (cont_entry_t *)req->ring_ptr;
#line 410
  *((uint32_t *)(& cont_pkt->entry_type)) = 2U;
#line 413
  return (cont_pkt);
}
}
#line 423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static cont_a64_entry_t *qla2x00_prep_cont_type1_iocb(scsi_qla_host_t *vha ,
                                                               struct req_que *req ) 
{ 
  cont_a64_entry_t *cont_pkt ;

  {
#line 428
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 429
  if ((int )req->ring_index == (int )req->length) {
#line 430
    req->ring_index = 0U;
#line 431
    req->ring_ptr = req->ring;
  } else {
#line 433
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 436
  cont_pkt = (cont_a64_entry_t *)req->ring_ptr;
#line 439
  *((uint32_t *)(& cont_pkt->entry_type)) = ((vha->hw)->device_type & 131072U) != 0U ? 3U : 10U;
#line 443
  return (cont_pkt);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static int qla24xx_configure_prot_mode(srb_t *sp , uint16_t *fw_prot_opts ) 
{ 
  struct scsi_cmnd *cmd ;
  uint8_t guard ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 449
  cmd = sp->u.scmd.cmd;
#line 450
  tmp = scsi_host_get_guard((cmd->device)->host);
#line 450
  guard = tmp;
#line 453
  *fw_prot_opts = 0U;
#line 456
  tmp___0 = scsi_get_prot_op(cmd);
#line 456
  switch ((int )tmp___0) {
  case 3: 
#line 458
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 1U);
#line 459
  goto ldv_60791;
  case 4: 
#line 461
  *fw_prot_opts = *fw_prot_opts;
#line 462
  goto ldv_60791;
  case 1: 
#line 464
  *fw_prot_opts = *fw_prot_opts;
#line 465
  goto ldv_60791;
  case 2: 
#line 467
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 1U);
#line 468
  goto ldv_60791;
  case 5: ;
  case 6: ;
#line 471
  if (((int )guard & 2) != 0) {
#line 472
    *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 6U);
  } else {
#line 474
    *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 2U);
  }
#line 475
  goto ldv_60791;
  default: 
#line 477
  *fw_prot_opts = (uint16_t )((unsigned int )*fw_prot_opts | 2U);
#line 478
  goto ldv_60791;
  }
  ldv_60791: 
#line 481
  tmp___1 = scsi_prot_sg_count(cmd);
#line 481
  return ((int )tmp___1);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void qla2x00_build_scsi_iocbs_32(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  unsigned int tmp ;
  uint16_t tmp___0 ;
  cont_entry_t *cont_pkt ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 502
  cmd = sp->u.scmd.cmd;
#line 505
  *((uint32_t *)(& cmd_pkt->entry_type)) = 17U;
#line 509
  tmp = scsi_bufflen(cmd);
#line 509
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 510
    cmd_pkt->byte_count = 0U;
#line 511
    return;
  } else {

  }
#line 514
  vha = (sp->fcport)->vha;
#line 515
  tmp___0 = qla2x00_get_cmd_direction(sp);
#line 515
  cmd_pkt->control_flags = (uint16_t )((int )cmd_pkt->control_flags | (int )tmp___0);
#line 518
  avail_dsds = 3U;
#line 519
  cur_dsd = & cmd_pkt->dseg_0_address;
#line 522
  i = 0;
#line 522
  sg = scsi_sglist(cmd);
#line 522
  goto ldv_60811;
  ldv_60810: ;
#line 526
  if ((unsigned int )avail_dsds == 0U) {
#line 531
    cont_pkt = qla2x00_prep_cont_type0_iocb(vha);
#line 532
    cur_dsd = & cont_pkt->dseg_0_address;
#line 533
    avail_dsds = 7U;
  } else {

  }
#line 536
  tmp___1 = cur_dsd;
#line 536
  cur_dsd = cur_dsd + 1;
#line 536
  *tmp___1 = (unsigned int )sg->dma_address;
#line 537
  tmp___2 = cur_dsd;
#line 537
  cur_dsd = cur_dsd + 1;
#line 537
  *tmp___2 = sg->dma_length;
#line 538
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 522
  i = i + 1;
#line 522
  sg = sg_next(sg);
  ldv_60811: ;
#line 522
  if ((int )tot_dsds > i) {
#line 524
    goto ldv_60810;
  } else {

  }

#line 529
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void qla2x00_build_scsi_iocbs_64(srb_t *sp , cmd_entry_t *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  unsigned int tmp ;
  uint16_t tmp___0 ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;

  {
#line 560
  cmd = sp->u.scmd.cmd;
#line 563
  *((uint32_t *)(& cmd_pkt->entry_type)) = 25U;
#line 567
  tmp = scsi_bufflen(cmd);
#line 567
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 568
    cmd_pkt->byte_count = 0U;
#line 569
    return;
  } else {

  }
#line 572
  vha = (sp->fcport)->vha;
#line 573
  tmp___0 = qla2x00_get_cmd_direction(sp);
#line 573
  cmd_pkt->control_flags = (uint16_t )((int )cmd_pkt->control_flags | (int )tmp___0);
#line 576
  avail_dsds = 2U;
#line 577
  cur_dsd = & cmd_pkt->dseg_0_address;
#line 580
  i = 0;
#line 580
  sg = scsi_sglist(cmd);
#line 580
  goto ldv_60827;
  ldv_60826: ;
#line 585
  if ((unsigned int )avail_dsds == 0U) {
#line 590
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 591
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 592
    avail_dsds = 5U;
  } else {

  }
#line 595
  sle_dma = sg->dma_address;
#line 596
  tmp___1 = cur_dsd;
#line 596
  cur_dsd = cur_dsd + 1;
#line 596
  *tmp___1 = (unsigned int )sle_dma;
#line 597
  tmp___2 = cur_dsd;
#line 597
  cur_dsd = cur_dsd + 1;
#line 597
  *tmp___2 = (unsigned int )(sle_dma >> 32ULL);
#line 598
  tmp___3 = cur_dsd;
#line 598
  cur_dsd = cur_dsd + 1;
#line 598
  *tmp___3 = sg->dma_length;
#line 599
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 580
  i = i + 1;
#line 580
  sg = sg_next(sg);
  ldv_60827: ;
#line 580
  if ((int )tot_dsds > i) {
#line 582
    goto ldv_60826;
  } else {

  }

#line 587
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla2x00_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  cmd_entry_t *cmd_pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct device_reg_2xxx *reg ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  char tag[2U] ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  size_t __len ;
  void *__ret ;

  {
#line 630
  ret = 0;
#line 631
  vha = (sp->fcport)->vha;
#line 632
  ha = vha->hw;
#line 633
  reg = & (ha->iobase)->isp;
#line 634
  cmd = sp->u.scmd.cmd;
#line 635
  req = *(ha->req_q_map);
#line 636
  rsp = *(ha->rsp_q_map);
#line 638
  tot_dsds = 0U;
#line 641
  if ((unsigned int )vha->marker_needed != 0U) {
#line 642
    tmp = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 642
    if (tmp != 0) {
#line 644
      return (258);
    } else {

    }
#line 646
    vha->marker_needed = 0U;
  } else {

  }
#line 650
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 650
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 653
  handle = req->current_outstanding_cmd;
#line 654
  index = 1U;
#line 654
  goto ldv_60854;
  ldv_60853: 
#line 655
  handle = handle + 1U;
#line 656
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 657
    handle = 1U;
  } else {

  }
#line 658
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 659
    goto ldv_60852;
  } else {

  }
#line 654
  index = index + 1U;
  ldv_60854: ;
#line 654
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 656
    goto ldv_60853;
  } else {

  }
  ldv_60852: ;
#line 661
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 662
    goto queuing_error;
  } else {

  }
#line 665
  tmp___4 = scsi_sg_count(cmd);
#line 665
  if (tmp___4 != 0U) {
#line 666
    tmp___1 = scsi_sg_count(cmd);
#line 666
    tmp___2 = scsi_sglist(cmd);
#line 666
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 668
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 668
    if (tmp___3 != 0L) {
#line 669
      goto queuing_error;
    } else {

    }
  } else {
#line 671
    nseg = 0;
  }
#line 673
  tot_dsds = (uint16_t )nseg;
#line 676
  req_cnt = (*((ha->isp_ops)->calc_req_entries))((int )tot_dsds);
#line 677
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 678
    cnt = __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_out));
#line 679
    if ((int )req->ring_index < (int )cnt) {
#line 680
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 682
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 685
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 686
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 690
  req->current_outstanding_cmd = handle;
#line 691
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 692
  sp->handle = handle;
#line 693
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 694
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 696
  cmd_pkt = (cmd_entry_t *)req->ring_ptr;
#line 697
  cmd_pkt->handle = handle;
#line 699
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 700
  memset((void *)clr_ptr, 0, 56UL);
#line 701
  cmd_pkt->dseg_count = tot_dsds;
#line 704
  if ((int )ha->device_type < 0) {
#line 704
    cmd_pkt->target.extended = (sp->fcport)->loop_id;
  } else {
#line 704
    cmd_pkt->target.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 705
  cmd_pkt->lun = (unsigned short )(cmd->device)->lun;
#line 708
  tmp___5 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 708
  if (tmp___5 != 0) {
#line 709
    switch ((int )tag[0]) {
    case 33: 
#line 711
    cmd_pkt->control_flags = 2U;
#line 713
    goto ldv_60857;
    case 34: 
#line 715
    cmd_pkt->control_flags = 4U;
#line 717
    goto ldv_60857;
    default: 
#line 719
    cmd_pkt->control_flags = 8U;
#line 721
    goto ldv_60857;
    }
    ldv_60857: ;
  } else {
#line 724
    cmd_pkt->control_flags = 8U;
  }
#line 728
  __len = (size_t )cmd->cmd_len;
#line 728
  __ret = __builtin_memcpy((void *)(& cmd_pkt->scsi_cdb), (void const   *)cmd->cmnd,
                           __len);
#line 729
  cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 732
  (*((ha->isp_ops)->build_iocbs))(sp, cmd_pkt, (int )tot_dsds);
#line 735
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 736
  __asm__  volatile   ("sfence": : : "memory");
#line 739
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 740
  if ((int )req->ring_index == (int )req->length) {
#line 741
    req->ring_index = 0U;
#line 742
    req->ring_ptr = req->ring;
  } else {
#line 744
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 746
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 749
  writew((int )req->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 750
  __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox4 : & reg->u.isp2300.req_q_in));
#line 753
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 755
    qla2x00_process_response_queue(rsp);
  } else {

  }
#line 757
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 758
  return (0);
  queuing_error: ;
#line 761
  if ((unsigned int )tot_dsds != 0U) {
#line 762
    scsi_dma_unmap(cmd);
  } else {

  }
#line 764
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 766
  return (258);
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void qla2x00_start_iocbs(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  struct qla_hw_data *ha ;
  device_reg_t *reg ;

  {
#line 775
  ha = vha->hw;
#line 776
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase + (unsigned long )((int )req->id * 4096) : ha->iobase;
#line 778
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 779
    qla82xx_start_iocbs(vha);
  } else {
#line 782
    req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 783
    if ((int )req->ring_index == (int )req->length) {
#line 784
      req->ring_index = 0U;
#line 785
      req->ring_ptr = req->ring;
    } else {
#line 787
      req->ring_ptr = req->ring_ptr + 1;
    }
#line 790
    if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 791
      writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 792
      __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
    } else
#line 793
    if ((ha->device_type & 131072U) != 0U) {
#line 794
      writel((unsigned int )req->ring_index, (void volatile   *)(& reg->ispfx00.req_q_in));
#line 795
      __readl((void const volatile   *)(& reg->ispfx00.req_q_in));
#line 796
      writel(ha->rqstq_intr_code, (void volatile   *)ha->cregbase + 133636U);
    } else
#line 797
    if ((ha->device_type & 134217728U) != 0U) {
#line 798
      writel((unsigned int )req->ring_index, (void volatile   *)(& reg->isp24.req_q_in));
#line 799
      __readl((void const volatile   *)(& reg->isp24.req_q_in));
    } else {
#line 801
      writew((int )req->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_in));
#line 803
      __readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_in));
    }
  }
#line 806
  return;
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static int __qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                            uint16_t loop_id , uint16_t lun , uint8_t type ) 
{ 
  mrk_entry_t *mrk ;
  struct mrk_entry_24xx *mrk24 ;
  struct mrk_entry_fx00 *mrkfx ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 825
  mrk24 = (struct mrk_entry_24xx *)0;
#line 826
  mrkfx = (struct mrk_entry_fx00 *)0;
#line 828
  ha = vha->hw;
#line 829
  tmp = pci_get_drvdata(ha->pdev);
#line 829
  base_vha = (scsi_qla_host_t *)tmp;
#line 831
  req = *(ha->req_q_map);
#line 832
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 832
  mrk = (mrk_entry_t *)tmp___0;
#line 833
  if ((unsigned long )mrk == (unsigned long )((mrk_entry_t *)0)) {
#line 834
    ql_log(1U, base_vha, 12326, "Failed to allocate Marker IOCB.\n");
#line 837
    return (258);
  } else {

  }
#line 840
  mrk->entry_type = 4U;
#line 841
  mrk->modifier = type;
#line 842
  if ((unsigned int )type != 2U) {
#line 843
    if ((ha->device_type & 131072U) != 0U) {
#line 844
      mrkfx = (struct mrk_entry_fx00 *)mrk;
#line 845
      mrkfx->handle = ((unsigned int )req->id << 16) | mrkfx->handle;
#line 846
      mrkfx->handle_hi = 0U;
#line 847
      mrkfx->tgt_id = loop_id;
#line 848
      mrkfx->lun[1] = (unsigned char )lun;
#line 849
      mrkfx->lun[2] = (unsigned char )((int )lun >> 8);
#line 850
      host_to_fcp_swap((uint8_t *)(& mrkfx->lun), 8U);
    } else
#line 851
    if ((ha->device_type & 134217728U) != 0U) {
#line 852
      mrk24 = (struct mrk_entry_24xx *)mrk;
#line 853
      mrk24->nport_handle = loop_id;
#line 854
      mrk24->lun[1] = (unsigned char )lun;
#line 855
      mrk24->lun[2] = (unsigned char )((int )lun >> 8);
#line 856
      host_to_fcp_swap((uint8_t *)(& mrk24->lun), 8U);
#line 857
      mrk24->vp_index = (uint8_t )vha->vp_idx;
#line 858
      mrk24->handle = ((unsigned int )req->id << 16) | mrk24->handle;
    } else {
#line 860
      if ((int )ha->device_type < 0) {
#line 860
        mrk->target.extended = loop_id;
      } else {
#line 860
        mrk->target.id.standard = (unsigned char )loop_id;
      }
#line 861
      mrk->lun = lun;
    }
  } else {

  }
#line 864
  __asm__  volatile   ("sfence": : : "memory");
#line 866
  qla2x00_start_iocbs(vha, req);
#line 868
  return (0);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla2x00_marker(struct scsi_qla_host *vha , struct req_que *req , struct rsp_que *rsp ,
                   uint16_t loop_id , uint16_t lun , uint8_t type ) 
{ 
  int ret ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 877
  flags = 0UL;
#line 879
  tmp = spinlock_check(& (vha->hw)->hardware_lock);
#line 879
  flags = _raw_spin_lock_irqsave(tmp);
#line 880
  ret = __qla2x00_marker(vha, req, rsp, (int )loop_id, (int )lun, (int )type);
#line 881
  spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
#line 883
  return (ret);
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla2x00_issue_marker(scsi_qla_host_t *vha , int ha_locked ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 895
  if (ha_locked != 0) {
#line 896
    tmp = __qla2x00_marker(vha, vha->req, (vha->req)->rsp, 0, 0, 2);
#line 896
    if (tmp != 0) {
#line 898
      return (258);
    } else {

    }
  } else {
#line 900
    tmp___0 = qla2x00_marker(vha, vha->req, (vha->req)->rsp, 0, 0, 2);
#line 900
    if (tmp___0 != 0) {
#line 902
      return (258);
    } else {

    }
  }
#line 904
  vha->marker_needed = 0U;
#line 906
  return (0);
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static int qla24xx_build_scsi_type_6_iocbs(srb_t *sp , struct cmd_type_6 *cmd_pkt ,
                                                    uint16_t tot_dsds ) 
{ 
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *cur_seg ;
  uint32_t *dsd_seg ;
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint8_t first_iocb ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct ct6_dsd *ctx ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  struct list_head  const  *__mptr ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  dma_addr_t sle_dma ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;

  {
#line 913
  cur_dsd = (uint32_t *)0U;
#line 921
  first_iocb = 1U;
#line 926
  cmd = sp->u.scmd.cmd;
#line 929
  *((uint32_t *)(& cmd_pkt->entry_type)) = 72U;
#line 933
  tmp = scsi_bufflen(cmd);
#line 933
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 934
    cmd_pkt->byte_count = 0U;
#line 935
    return (0);
  } else {

  }
#line 938
  vha = (sp->fcport)->vha;
#line 939
  ha = vha->hw;
#line 942
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 943
    cmd_pkt->control_flags = 1U;
#line 945
    tmp___0 = scsi_bufflen(cmd);
#line 945
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
#line 946
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 947
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 948
    cmd_pkt->control_flags = 2U;
#line 950
    tmp___1 = scsi_bufflen(cmd);
#line 950
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
#line 951
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 954
  cur_seg = scsi_sglist(cmd);
#line 955
  ctx = (struct ct6_dsd *)sp->u.scmd.ctx;
#line 957
  goto ldv_60923;
  ldv_60922: 
#line 958
  avail_dsds = (unsigned int )tot_dsds <= 37U ? (uint8_t )tot_dsds : 37U;
#line 960
  tot_dsds = (int )tot_dsds - (int )((uint16_t )avail_dsds);
#line 961
  dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 963
  __mptr = (struct list_head  const  *)ha->gbl_dsd_list.next;
#line 963
  dsd_ptr = (struct dsd_dma *)__mptr;
#line 965
  next_dsd = dsd_ptr->dsd_addr;
#line 966
  list_del(& dsd_ptr->list);
#line 967
  ha->gbl_dsd_avail = (uint16_t )((int )ha->gbl_dsd_avail - 1);
#line 968
  list_add_tail(& dsd_ptr->list, & ctx->dsd_list);
#line 969
  ctx->dsd_use_cnt = ctx->dsd_use_cnt + 1;
#line 970
  ha->gbl_dsd_inuse = (uint16_t )((int )ha->gbl_dsd_inuse + 1);
#line 972
  if ((unsigned int )first_iocb != 0U) {
#line 973
    first_iocb = 0U;
#line 974
    dsd_seg = (uint32_t *)(& cmd_pkt->fcp_data_dseg_address);
#line 975
    tmp___2 = dsd_seg;
#line 975
    dsd_seg = dsd_seg + 1;
#line 975
    *tmp___2 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 976
    tmp___3 = dsd_seg;
#line 976
    dsd_seg = dsd_seg + 1;
#line 976
    *tmp___3 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 977
    cmd_pkt->fcp_data_dseg_len = dsd_list_len;
  } else {
#line 979
    tmp___4 = cur_dsd;
#line 979
    cur_dsd = cur_dsd + 1;
#line 979
    *tmp___4 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 980
    tmp___5 = cur_dsd;
#line 980
    cur_dsd = cur_dsd + 1;
#line 980
    *tmp___5 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 981
    tmp___6 = cur_dsd;
#line 981
    cur_dsd = cur_dsd + 1;
#line 981
    *tmp___6 = dsd_list_len;
  }
#line 983
  cur_dsd = (uint32_t *)next_dsd;
#line 984
  goto ldv_60920;
  ldv_60919: 
#line 987
  sle_dma = cur_seg->dma_address;
#line 988
  tmp___7 = cur_dsd;
#line 988
  cur_dsd = cur_dsd + 1;
#line 988
  *tmp___7 = (unsigned int )sle_dma;
#line 989
  tmp___8 = cur_dsd;
#line 989
  cur_dsd = cur_dsd + 1;
#line 989
  *tmp___8 = (unsigned int )(sle_dma >> 32ULL);
#line 990
  tmp___9 = cur_dsd;
#line 990
  cur_dsd = cur_dsd + 1;
#line 990
  *tmp___9 = cur_seg->dma_length;
#line 991
  cur_seg = sg_next(cur_seg);
#line 992
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
  ldv_60920: ;
#line 984
  if ((unsigned int )avail_dsds != 0U) {
#line 986
    goto ldv_60919;
  } else {

  }

  ldv_60923: ;
#line 957
  if ((unsigned int )tot_dsds != 0U) {
#line 959
    goto ldv_60922;
  } else {

  }
#line 997
  tmp___10 = cur_dsd;
#line 997
  cur_dsd = cur_dsd + 1;
#line 997
  *tmp___10 = 0U;
#line 998
  tmp___11 = cur_dsd;
#line 998
  cur_dsd = cur_dsd + 1;
#line 998
  *tmp___11 = 0U;
#line 999
  tmp___12 = cur_dsd;
#line 999
  cur_dsd = cur_dsd + 1;
#line 999
  *tmp___12 = 0U;
#line 1000
  cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 4U);
#line 1001
  return (0);
}
}
#line 1013 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline uint16_t qla24xx_calc_dsd_lists(uint16_t dsds ) 
{ 
  uint16_t dsd_lists ;

  {
#line 1015
  dsd_lists = 0U;
#line 1017
  dsd_lists = (uint16_t )((unsigned int )dsds / 37U);
#line 1018
  if ((unsigned int )dsds % 37U != 0U) {
#line 1019
    dsd_lists = (uint16_t )((int )dsd_lists + 1);
  } else {

  }
#line 1020
  return (dsd_lists);
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline void qla24xx_build_scsi_iocbs(srb_t *sp , struct cmd_type_7 *cmd_pkt , uint16_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  struct req_que *req ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 1044
  cmd = sp->u.scmd.cmd;
#line 1047
  *((uint32_t *)(& cmd_pkt->entry_type)) = 24U;
#line 1051
  tmp = scsi_bufflen(cmd);
#line 1051
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 1052
    cmd_pkt->byte_count = 0U;
#line 1053
    return;
  } else {

  }
#line 1056
  vha = (sp->fcport)->vha;
#line 1057
  req = vha->req;
#line 1060
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 1061
    cmd_pkt->task_mgmt_flags = 1U;
#line 1063
    tmp___0 = scsi_bufflen(cmd);
#line 1063
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
#line 1064
    vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
  } else
#line 1065
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 1066
    cmd_pkt->task_mgmt_flags = 2U;
#line 1068
    tmp___1 = scsi_bufflen(cmd);
#line 1068
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
#line 1069
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
  } else {

  }
#line 1073
  avail_dsds = 1U;
#line 1074
  cur_dsd = (uint32_t *)(& cmd_pkt->dseg_0_address);
#line 1078
  i = 0;
#line 1078
  sg = scsi_sglist(cmd);
#line 1078
  goto ldv_60944;
  ldv_60943: ;
#line 1083
  if ((unsigned int )avail_dsds == 0U) {
#line 1088
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 1089
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 1090
    avail_dsds = 5U;
  } else {

  }
#line 1093
  sle_dma = sg->dma_address;
#line 1094
  tmp___2 = cur_dsd;
#line 1094
  cur_dsd = cur_dsd + 1;
#line 1094
  *tmp___2 = (unsigned int )sle_dma;
#line 1095
  tmp___3 = cur_dsd;
#line 1095
  cur_dsd = cur_dsd + 1;
#line 1095
  *tmp___3 = (unsigned int )(sle_dma >> 32ULL);
#line 1096
  tmp___4 = cur_dsd;
#line 1096
  cur_dsd = cur_dsd + 1;
#line 1096
  *tmp___4 = sg->dma_length;
#line 1097
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 1078
  i = i + 1;
#line 1078
  sg = sg_next(sg);
  ldv_60944: ;
#line 1078
  if ((int )tot_dsds > i) {
#line 1080
    goto ldv_60943;
  } else {

  }

#line 1085
  return;
}
}
#line 1113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static void qla24xx_set_t10dif_tags(srb_t *sp , struct fw_dif_context *pkt ,
                                             unsigned int protcnt ) 
{ 
  struct scsi_cmnd *cmd ;
  unsigned char tmp ;
  sector_t tmp___0 ;
  int tmp___1 ;
  sector_t tmp___2 ;
  int tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  uint8_t tmp___6 ;
  sector_t tmp___7 ;
  int tmp___8 ;

  {
#line 1116
  cmd = sp->u.scmd.cmd;
#line 1118
  tmp = scsi_get_prot_type(cmd);
#line 1118
  switch ((int )tmp) {
  case 0: 
#line 1124
  tmp___0 = scsi_get_lba(cmd);
#line 1124
  pkt->ref_tag = (unsigned int )tmp___0;
#line 1127
  tmp___1 = qla2x00_hba_err_chk_enabled(sp);
#line 1127
  if (tmp___1 == 0) {
#line 1128
    goto ldv_60958;
  } else {

  }
#line 1130
  pkt->ref_tag_mask[0] = 255U;
#line 1131
  pkt->ref_tag_mask[1] = 255U;
#line 1132
  pkt->ref_tag_mask[2] = 255U;
#line 1133
  pkt->ref_tag_mask[3] = 255U;
#line 1134
  goto ldv_60958;
  case 2: 
#line 1141
  pkt->app_tag = 0U;
#line 1142
  pkt->app_tag_mask[0] = 0U;
#line 1143
  pkt->app_tag_mask[1] = 0U;
#line 1145
  tmp___2 = scsi_get_lba(cmd);
#line 1145
  pkt->ref_tag = (unsigned int )tmp___2;
#line 1148
  tmp___3 = qla2x00_hba_err_chk_enabled(sp);
#line 1148
  if (tmp___3 == 0) {
#line 1149
    goto ldv_60958;
  } else {

  }
#line 1152
  pkt->ref_tag_mask[0] = 255U;
#line 1153
  pkt->ref_tag_mask[1] = 255U;
#line 1154
  pkt->ref_tag_mask[2] = 255U;
#line 1155
  pkt->ref_tag_mask[3] = 255U;
#line 1156
  goto ldv_60958;
  case 3: 
#line 1160
  tmp___6 = 0U;
#line 1160
  pkt->ref_tag_mask[3] = tmp___6;
#line 1160
  tmp___5 = tmp___6;
#line 1160
  pkt->ref_tag_mask[2] = tmp___5;
#line 1160
  tmp___4 = tmp___5;
#line 1160
  pkt->ref_tag_mask[1] = tmp___4;
#line 1160
  pkt->ref_tag_mask[0] = tmp___4;
#line 1163
  goto ldv_60958;
  case 1: 
#line 1170
  tmp___7 = scsi_get_lba(cmd);
#line 1170
  pkt->ref_tag = (unsigned int )tmp___7;
#line 1172
  pkt->app_tag = 0U;
#line 1173
  pkt->app_tag_mask[0] = 0U;
#line 1174
  pkt->app_tag_mask[1] = 0U;
#line 1176
  tmp___8 = qla2x00_hba_err_chk_enabled(sp);
#line 1176
  if (tmp___8 == 0) {
#line 1177
    goto ldv_60958;
  } else {

  }
#line 1180
  pkt->ref_tag_mask[0] = 255U;
#line 1181
  pkt->ref_tag_mask[1] = 255U;
#line 1182
  pkt->ref_tag_mask[2] = 255U;
#line 1183
  pkt->ref_tag_mask[3] = 255U;
#line 1184
  goto ldv_60958;
  }
  ldv_60958: ;
#line 1187
  return;
}
}
#line 1206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static int qla24xx_get_one_block_sg(uint32_t blk_sz , struct qla2_sgx *sgx , uint32_t *partial ) 
{ 
  struct scatterlist *sg ;
  uint32_t cumulative_partial ;
  uint32_t sg_len ;
  dma_addr_t sg_dma_addr ;

  {
#line 1213
  if (sgx->num_bytes == sgx->tot_bytes) {
#line 1214
    return (0);
  } else {

  }
#line 1216
  sg = sgx->cur_sg;
#line 1217
  cumulative_partial = sgx->tot_partial;
#line 1219
  sg_dma_addr = sg->dma_address;
#line 1220
  sg_len = sg->dma_length;
#line 1222
  sgx->dma_addr = (dma_addr_t )sgx->bytes_consumed + sg_dma_addr;
#line 1224
  if ((sg_len - sgx->bytes_consumed) + cumulative_partial >= blk_sz) {
#line 1225
    sgx->dma_len = blk_sz - cumulative_partial;
#line 1226
    sgx->tot_partial = 0U;
#line 1227
    sgx->num_bytes = sgx->num_bytes + blk_sz;
#line 1228
    *partial = 0U;
  } else {
#line 1230
    sgx->dma_len = sg_len - sgx->bytes_consumed;
#line 1231
    sgx->tot_partial = sgx->tot_partial + sgx->dma_len;
#line 1232
    *partial = 1U;
  }
#line 1235
  sgx->bytes_consumed = sgx->bytes_consumed + sgx->dma_len;
#line 1237
  if (sgx->bytes_consumed == sg_len) {
#line 1238
    sg = sg_next(sg);
#line 1239
    sgx->num_sg = sgx->num_sg + 1U;
#line 1240
    sgx->cur_sg = sg;
#line 1241
    sgx->bytes_consumed = 0U;
  } else {

  }
#line 1244
  return (1);
}
}
#line 1248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static int qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha , srb_t *sp ,
                                                 uint32_t *dsd , uint16_t tot_dsds ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg_prot ;
  uint32_t *cur_dsd ;
  uint16_t used_dsds ;
  uint32_t prot_int ;
  uint32_t partial ;
  struct qla2_sgx sgx ;
  dma_addr_t sle_dma ;
  uint32_t sle_dma_len ;
  uint32_t tot_prot_dma_len ;
  struct scsi_cmnd *cmd ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  int tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;

  {
#line 1252
  avail_dsds = 0U;
#line 1256
  cur_dsd = dsd;
#line 1257
  used_dsds = tot_dsds;
#line 1263
  tot_prot_dma_len = 0U;
#line 1264
  cmd = sp->u.scmd.cmd;
#line 1266
  prot_int = (cmd->device)->sector_size;
#line 1268
  memset((void *)(& sgx), 0, 48UL);
#line 1269
  sgx.tot_bytes = scsi_bufflen(cmd);
#line 1270
  sgx.cur_sg = scsi_sglist(cmd);
#line 1271
  sgx.sp = sp;
#line 1273
  sg_prot = scsi_prot_sglist(cmd);
#line 1275
  goto ldv_61003;
  ldv_61002: 
#line 1277
  sle_dma = sgx.dma_addr;
#line 1278
  sle_dma_len = sgx.dma_len;
  alloc_and_fill: ;
#line 1281
  if ((unsigned int )avail_dsds == 0U) {
#line 1282
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 1284
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 1285
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 1288
    tmp = kzalloc(32UL, 32U);
#line 1288
    dsd_ptr = (struct dsd_dma *)tmp;
#line 1289
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 1290
      return (1);
    } else {

    }
#line 1293
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 1293
    dsd_ptr->dsd_addr = next_dsd;
#line 1297
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 1302
      kfree((void const   *)dsd_ptr);
#line 1303
      return (1);
    } else {

    }
#line 1306
    list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 1309
    sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
#line 1312
    tmp___0 = cur_dsd;
#line 1312
    cur_dsd = cur_dsd + 1;
#line 1312
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1313
    tmp___1 = cur_dsd;
#line 1313
    cur_dsd = cur_dsd + 1;
#line 1313
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1314
    tmp___2 = cur_dsd;
#line 1314
    cur_dsd = cur_dsd + 1;
#line 1314
    *tmp___2 = dsd_list_len;
#line 1315
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1317
  tmp___3 = cur_dsd;
#line 1317
  cur_dsd = cur_dsd + 1;
#line 1317
  *tmp___3 = (unsigned int )sle_dma;
#line 1318
  tmp___4 = cur_dsd;
#line 1318
  cur_dsd = cur_dsd + 1;
#line 1318
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1319
  tmp___5 = cur_dsd;
#line 1319
  cur_dsd = cur_dsd + 1;
#line 1319
  *tmp___5 = sle_dma_len;
#line 1320
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1322
  if (partial == 0U) {
#line 1324
    sle_dma = sg_prot->dma_address + (dma_addr_t )tot_prot_dma_len;
#line 1325
    sle_dma_len = 8U;
#line 1327
    tot_prot_dma_len = tot_prot_dma_len + sle_dma_len;
#line 1328
    if (sg_prot->dma_length == tot_prot_dma_len) {
#line 1329
      tot_prot_dma_len = 0U;
#line 1330
      sg_prot = sg_next(sg_prot);
    } else {

    }
#line 1333
    partial = 1U;
#line 1334
    goto alloc_and_fill;
  } else {

  }
  ldv_61003: 
#line 1275
  tmp___6 = qla24xx_get_one_block_sg(prot_int, & sgx, & partial);
#line 1275
  if (tmp___6 != 0) {
#line 1277
    goto ldv_61002;
  } else {

  }
#line 1338
  tmp___7 = cur_dsd;
#line 1338
  cur_dsd = cur_dsd + 1;
#line 1338
  *tmp___7 = 0U;
#line 1339
  tmp___8 = cur_dsd;
#line 1339
  cur_dsd = cur_dsd + 1;
#line 1339
  *tmp___8 = 0U;
#line 1340
  tmp___9 = cur_dsd;
#line 1340
  cur_dsd = cur_dsd + 1;
#line 1340
  *tmp___9 = 0U;
#line 1341
  return (0);
}
}
#line 1345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static int qla24xx_walk_and_build_sglist(struct qla_hw_data *ha , srb_t *sp , uint32_t *dsd ,
                                         uint16_t tot_dsds ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg ;
  uint32_t *cur_dsd ;
  int i ;
  uint16_t used_dsds ;
  struct scsi_cmnd *cmd ;
  dma_addr_t sle_dma ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;

  {
#line 1349
  avail_dsds = 0U;
#line 1353
  cur_dsd = dsd;
#line 1355
  used_dsds = tot_dsds;
#line 1356
  cmd = sp->u.scmd.cmd;
#line 1358
  i = 0;
#line 1358
  sg = scsi_sglist(cmd);
#line 1358
  goto ldv_61022;
  ldv_61021: ;
#line 1362
  if ((unsigned int )avail_dsds == 0U) {
#line 1363
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 1365
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 1366
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 1369
    tmp = kzalloc(32UL, 32U);
#line 1369
    dsd_ptr = (struct dsd_dma *)tmp;
#line 1370
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 1371
      return (1);
    } else {

    }
#line 1374
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 1374
    dsd_ptr->dsd_addr = next_dsd;
#line 1378
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 1383
      kfree((void const   *)dsd_ptr);
#line 1384
      return (1);
    } else {

    }
#line 1387
    list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 1390
    sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
#line 1393
    tmp___0 = cur_dsd;
#line 1393
    cur_dsd = cur_dsd + 1;
#line 1393
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1394
    tmp___1 = cur_dsd;
#line 1394
    cur_dsd = cur_dsd + 1;
#line 1394
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1395
    tmp___2 = cur_dsd;
#line 1395
    cur_dsd = cur_dsd + 1;
#line 1395
    *tmp___2 = dsd_list_len;
#line 1396
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1398
  sle_dma = sg->dma_address;
#line 1400
  tmp___3 = cur_dsd;
#line 1400
  cur_dsd = cur_dsd + 1;
#line 1400
  *tmp___3 = (unsigned int )sle_dma;
#line 1401
  tmp___4 = cur_dsd;
#line 1401
  cur_dsd = cur_dsd + 1;
#line 1401
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1402
  tmp___5 = cur_dsd;
#line 1402
  cur_dsd = cur_dsd + 1;
#line 1402
  *tmp___5 = sg->dma_length;
#line 1403
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1358
  i = i + 1;
#line 1358
  sg = sg_next(sg);
  ldv_61022: ;
#line 1358
  if ((int )tot_dsds > i) {
#line 1360
    goto ldv_61021;
  } else {

  }
#line 1407
  tmp___6 = cur_dsd;
#line 1407
  cur_dsd = cur_dsd + 1;
#line 1407
  *tmp___6 = 0U;
#line 1408
  tmp___7 = cur_dsd;
#line 1408
  cur_dsd = cur_dsd + 1;
#line 1408
  *tmp___7 = 0U;
#line 1409
  tmp___8 = cur_dsd;
#line 1409
  cur_dsd = cur_dsd + 1;
#line 1409
  *tmp___8 = 0U;
#line 1410
  return (0);
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static int qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha , srb_t *sp ,
                                              uint32_t *dsd , uint16_t tot_dsds ) 
{ 
  void *next_dsd ;
  uint8_t avail_dsds ;
  uint32_t dsd_list_len ;
  struct dsd_dma *dsd_ptr ;
  struct scatterlist *sg ;
  int i ;
  struct scsi_cmnd *cmd ;
  uint32_t *cur_dsd ;
  uint16_t used_dsds ;
  dma_addr_t sle_dma ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;

  {
#line 1419
  avail_dsds = 0U;
#line 1425
  cur_dsd = dsd;
#line 1426
  used_dsds = tot_dsds;
#line 1428
  cmd = sp->u.scmd.cmd;
#line 1429
  i = 0;
#line 1429
  sg = scsi_prot_sglist(cmd);
#line 1429
  goto ldv_61041;
  ldv_61040: ;
#line 1433
  if ((unsigned int )avail_dsds == 0U) {
#line 1434
    avail_dsds = (unsigned int )used_dsds <= 37U ? (uint8_t )used_dsds : 37U;
#line 1436
    dsd_list_len = (uint32_t )(((int )avail_dsds + 1) * 12);
#line 1437
    used_dsds = (int )used_dsds - (int )((uint16_t )avail_dsds);
#line 1440
    tmp = kzalloc(32UL, 32U);
#line 1440
    dsd_ptr = (struct dsd_dma *)tmp;
#line 1441
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 1442
      return (1);
    } else {

    }
#line 1445
    next_dsd = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 1445
    dsd_ptr->dsd_addr = next_dsd;
#line 1449
    if ((unsigned long )next_dsd == (unsigned long )((void *)0)) {
#line 1454
      kfree((void const   *)dsd_ptr);
#line 1455
      return (1);
    } else {

    }
#line 1458
    list_add_tail(& dsd_ptr->list, & ((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
#line 1461
    sp->flags = (uint16_t )((unsigned int )sp->flags | 32U);
#line 1464
    tmp___0 = cur_dsd;
#line 1464
    cur_dsd = cur_dsd + 1;
#line 1464
    *tmp___0 = (unsigned int )dsd_ptr->dsd_list_dma;
#line 1465
    tmp___1 = cur_dsd;
#line 1465
    cur_dsd = cur_dsd + 1;
#line 1465
    *tmp___1 = (unsigned int )(dsd_ptr->dsd_list_dma >> 32ULL);
#line 1466
    tmp___2 = cur_dsd;
#line 1466
    cur_dsd = cur_dsd + 1;
#line 1466
    *tmp___2 = dsd_list_len;
#line 1467
    cur_dsd = (uint32_t *)next_dsd;
  } else {

  }
#line 1469
  sle_dma = sg->dma_address;
#line 1471
  tmp___3 = cur_dsd;
#line 1471
  cur_dsd = cur_dsd + 1;
#line 1471
  *tmp___3 = (unsigned int )sle_dma;
#line 1472
  tmp___4 = cur_dsd;
#line 1472
  cur_dsd = cur_dsd + 1;
#line 1472
  *tmp___4 = (unsigned int )(sle_dma >> 32ULL);
#line 1473
  tmp___5 = cur_dsd;
#line 1473
  cur_dsd = cur_dsd + 1;
#line 1473
  *tmp___5 = sg->dma_length;
#line 1475
  avail_dsds = (uint8_t )((int )avail_dsds - 1);
#line 1429
  i = i + 1;
#line 1429
  sg = sg_next(sg);
  ldv_61041: ;
#line 1429
  if ((int )tot_dsds > i) {
#line 1431
    goto ldv_61040;
  } else {

  }
#line 1478
  tmp___6 = cur_dsd;
#line 1478
  cur_dsd = cur_dsd + 1;
#line 1478
  *tmp___6 = 0U;
#line 1479
  tmp___7 = cur_dsd;
#line 1479
  cur_dsd = cur_dsd + 1;
#line 1479
  *tmp___7 = 0U;
#line 1480
  tmp___8 = cur_dsd;
#line 1480
  cur_dsd = cur_dsd + 1;
#line 1480
  *tmp___8 = 0U;
#line 1481
  return (0);
}
}
#line 1493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
__inline static int qla24xx_build_scsi_crc_2_iocbs(srb_t *sp , struct cmd_type_crc_2 *cmd_pkt ,
                                                   uint16_t tot_dsds , uint16_t tot_prot_dsds ,
                                                   uint16_t fw_prot_opts ) 
{ 
  uint32_t *cur_dsd ;
  uint32_t *fcp_dl ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  int sgc ;
  uint32_t total_bytes ;
  uint32_t data_bytes ;
  uint32_t dif_bytes ;
  uint8_t bundling ;
  uint16_t blk_size ;
  uint8_t *clr_ptr ;
  struct crc_context *crc_ctx_pkt ;
  struct qla_hw_data *ha ;
  uint8_t additional_fcpcdb_len ;
  uint16_t fcp_cmnd_len ;
  struct fcp_cmnd *fcp_cmnd ;
  dma_addr_t crc_ctx_dma ;
  char tag[2U] ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  void *tmp___3 ;
  size_t __len ;
  void *__ret ;
  int tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;
  __u32 tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1500
  total_bytes = 0U;
#line 1503
  bundling = 1U;
#line 1506
  crc_ctx_pkt = (struct crc_context *)0;
#line 1514
  cmd = sp->u.scmd.cmd;
#line 1516
  sgc = 0;
#line 1518
  *((uint32_t *)(& cmd_pkt->entry_type)) = 106U;
#line 1521
  vha = (sp->fcport)->vha;
#line 1522
  ha = vha->hw;
#line 1525
  data_bytes = scsi_bufflen(cmd);
#line 1526
  if (data_bytes == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 1527
    cmd_pkt->byte_count = 0U;
#line 1528
    return (0);
  } else {

  }
#line 1531
  cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1534
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 1535
    cmd_pkt->control_flags = 1U;
  } else
#line 1537
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 1538
    cmd_pkt->control_flags = 2U;
  } else {

  }
#line 1542
  tmp = scsi_get_prot_op(cmd);
#line 1542
  if ((unsigned int )tmp == 1U) {
#line 1546
    bundling = 0U;
  } else {
#line 1542
    tmp___0 = scsi_get_prot_op(cmd);
#line 1542
    if ((unsigned int )tmp___0 == 2U) {
#line 1546
      bundling = 0U;
    } else {
#line 1542
      tmp___1 = scsi_get_prot_op(cmd);
#line 1542
      if ((unsigned int )tmp___1 == 3U) {
#line 1546
        bundling = 0U;
      } else {
#line 1542
        tmp___2 = scsi_get_prot_op(cmd);
#line 1542
        if ((unsigned int )tmp___2 == 4U) {
#line 1546
          bundling = 0U;
        } else {

        }
      }
    }
  }
#line 1549
  tmp___3 = dma_pool_alloc(ha->dl_dma_pool, 32U, & crc_ctx_dma);
#line 1549
  sp->u.scmd.ctx = tmp___3;
#line 1549
  crc_ctx_pkt = (struct crc_context *)tmp___3;
#line 1552
  if ((unsigned long )crc_ctx_pkt == (unsigned long )((struct crc_context *)0)) {
#line 1553
    goto crc_queuing_error;
  } else {

  }
#line 1556
  clr_ptr = (uint8_t *)crc_ctx_pkt;
#line 1557
  memset((void *)clr_ptr, 0, 360UL);
#line 1559
  crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
#line 1561
  sp->flags = (uint16_t )((unsigned int )sp->flags | 4U);
#line 1564
  crc_ctx_pkt->handle = cmd_pkt->handle;
#line 1566
  INIT_LIST_HEAD(& crc_ctx_pkt->dsd_list);
#line 1568
  qla24xx_set_t10dif_tags(sp, (struct fw_dif_context *)(& crc_ctx_pkt->ref_tag), (unsigned int )tot_prot_dsds);
#line 1571
  cmd_pkt->crc_context_address[0] = (unsigned int )crc_ctx_dma;
#line 1572
  cmd_pkt->crc_context_address[1] = (unsigned int )(crc_ctx_dma >> 32ULL);
#line 1573
  cmd_pkt->crc_context_len = 64U;
#line 1576
  if ((unsigned int )cmd->cmd_len > 16U) {
#line 1577
    additional_fcpcdb_len = (unsigned int )((uint8_t )cmd->cmd_len) + 240U;
#line 1578
    if (((unsigned int )cmd->cmd_len & 3U) != 0U) {
#line 1580
      goto crc_queuing_error;
    } else {

    }
#line 1582
    fcp_cmnd_len = (unsigned int )cmd->cmd_len + 16U;
  } else {
#line 1584
    additional_fcpcdb_len = 0U;
#line 1585
    fcp_cmnd_len = 32U;
  }
#line 1588
  fcp_cmnd = & crc_ctx_pkt->fcp_cmnd;
#line 1590
  fcp_cmnd->additional_cdb_len = additional_fcpcdb_len;
#line 1591
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 1592
    fcp_cmnd->additional_cdb_len = (uint8_t )((unsigned int )fcp_cmnd->additional_cdb_len | 1U);
  } else
#line 1593
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 1594
    fcp_cmnd->additional_cdb_len = (uint8_t )((unsigned int )fcp_cmnd->additional_cdb_len | 2U);
  } else {

  }
#line 1596
  int_to_scsilun((cmd->device)->lun, & fcp_cmnd->lun);
#line 1597
  __len = (size_t )cmd->cmd_len;
#line 1597
  __ret = __builtin_memcpy((void *)(& fcp_cmnd->cdb), (void const   *)cmd->cmnd, __len);
#line 1598
  cmd_pkt->fcp_cmnd_dseg_len = fcp_cmnd_len;
#line 1599
  cmd_pkt->fcp_cmnd_dseg_address[0] = (unsigned int )crc_ctx_dma + 64U;
#line 1601
  cmd_pkt->fcp_cmnd_dseg_address[1] = (unsigned int )((crc_ctx_dma + 64ULL) >> 32ULL);
#line 1603
  fcp_cmnd->task_management = 0U;
#line 1608
  tmp___4 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 1608
  if (tmp___4 != 0) {
#line 1609
    switch ((int )tag[0]) {
    case 33: 
#line 1611
    fcp_cmnd->task_attribute = 1U;
#line 1612
    goto ldv_61073;
    case 34: 
#line 1614
    fcp_cmnd->task_attribute = 2U;
#line 1615
    goto ldv_61073;
    default: 
#line 1617
    fcp_cmnd->task_attribute = 0U;
#line 1618
    goto ldv_61073;
    }
    ldv_61073: ;
  } else {
#line 1621
    fcp_cmnd->task_attribute = 0U;
  }
#line 1624
  cmd_pkt->fcp_rsp_dseg_len = 0U;
#line 1627
  dif_bytes = 0U;
#line 1628
  blk_size = (uint16_t )(cmd->device)->sector_size;
#line 1629
  dif_bytes = (data_bytes / (uint32_t )blk_size) * 8U;
#line 1631
  tmp___5 = scsi_get_prot_op(sp->u.scmd.cmd);
#line 1631
  switch ((int )tmp___5) {
  case 1: ;
  case 2: 
#line 1634
  total_bytes = data_bytes;
#line 1635
  data_bytes = data_bytes + dif_bytes;
#line 1636
  goto ldv_61078;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: 
#line 1642
  total_bytes = data_bytes + dif_bytes;
#line 1643
  goto ldv_61078;
  default: 
#line 1645
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"),
                       "i" (1645), "i" (12UL));
  ldv_61084: ;
#line 1645
  goto ldv_61084;
  }
  ldv_61078: 
#line 1648
  tmp___9 = qla2x00_hba_err_chk_enabled(sp);
#line 1648
  if (tmp___9 == 0) {
#line 1649
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 16U);
  } else
#line 1651
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1652
    tmp___7 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1652
    if ((unsigned int )tmp___7 == 1U) {
#line 1655
      fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1024U);
    } else {
#line 1652
      tmp___8 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1652
      if ((unsigned int )tmp___8 == 2U) {
#line 1655
        fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 1024U);
      } else {
#line 1656
        tmp___6 = scsi_get_prot_type(sp->u.scmd.cmd);
#line 1656
        if ((unsigned int )tmp___6 == 3U) {
#line 1658
          fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 2048U);
        } else {

        }
      }
    }
  } else {

  }
#line 1661
  if ((unsigned int )bundling == 0U) {
#line 1662
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.nobundling.data_address);
  } else {
#line 1668
    fw_prot_opts = (uint16_t )((unsigned int )fw_prot_opts | 256U);
#line 1669
    crc_ctx_pkt->u.bundling.dif_byte_count = dif_bytes;
#line 1670
    crc_ctx_pkt->u.bundling.dseg_count = (int )tot_dsds - (int )tot_prot_dsds;
#line 1672
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.data_address);
  }
#line 1676
  crc_ctx_pkt->blk_size = blk_size;
#line 1677
  crc_ctx_pkt->prot_opts = fw_prot_opts;
#line 1678
  crc_ctx_pkt->byte_count = data_bytes;
#line 1679
  crc_ctx_pkt->guard_seed = 0U;
#line 1681
  cmd_pkt->byte_count = total_bytes;
#line 1682
  fcp_dl = (uint32_t *)(& crc_ctx_pkt->fcp_cmnd.cdb) + ((unsigned long )additional_fcpcdb_len + 16UL);
#line 1684
  tmp___10 = __fswab32(total_bytes);
#line 1684
  *fcp_dl = tmp___10;
#line 1686
  if (data_bytes == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 1687
    cmd_pkt->byte_count = 0U;
#line 1688
    return (0);
  } else {

  }
#line 1692
  cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 4U);
#line 1695
  if ((unsigned int )bundling == 0U && (unsigned int )tot_prot_dsds != 0U) {
#line 1696
    tmp___11 = qla24xx_walk_and_build_sglist_no_difb(ha, sp, cur_dsd, (int )tot_dsds);
#line 1696
    if (tmp___11 != 0) {
#line 1698
      goto crc_queuing_error;
    } else {

    }
  } else {
#line 1699
    tmp___12 = qla24xx_walk_and_build_sglist(ha, sp, cur_dsd, (int )tot_dsds - (int )tot_prot_dsds);
#line 1699
    if (tmp___12 != 0) {
#line 1701
      goto crc_queuing_error;
    } else {

    }
  }
#line 1703
  if ((unsigned int )bundling != 0U && (unsigned int )tot_prot_dsds != 0U) {
#line 1705
    cmd_pkt->control_flags = (uint16_t )((unsigned int )cmd_pkt->control_flags | 8U);
#line 1707
    cur_dsd = (uint32_t *)(& crc_ctx_pkt->u.bundling.dif_address);
#line 1708
    tmp___13 = qla24xx_walk_and_build_prot_sglist(ha, sp, cur_dsd, (int )tot_prot_dsds);
#line 1708
    if (tmp___13 != 0) {
#line 1710
      goto crc_queuing_error;
    } else {

    }
  } else {

  }
#line 1712
  return (0);
  crc_queuing_error: ;
#line 1717
  return (258);
}
}
#line 1727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla24xx_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  struct cmd_type_7 *cmd_pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  char tag[2U] ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  size_t __len ;
  void *__ret ;

  {
#line 1738
  req = (struct req_que *)0;
#line 1739
  rsp = (struct rsp_que *)0;
#line 1740
  cmd = sp->u.scmd.cmd;
#line 1741
  vha = (sp->fcport)->vha;
#line 1742
  ha = vha->hw;
#line 1746
  ret = 0;
#line 1748
  qla25xx_set_que(sp, & rsp);
#line 1749
  req = vha->req;
#line 1752
  tot_dsds = 0U;
#line 1755
  if ((unsigned int )vha->marker_needed != 0U) {
#line 1756
    tmp = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 1756
    if (tmp != 0) {
#line 1758
      return (258);
    } else {

    }
#line 1759
    vha->marker_needed = 0U;
  } else {

  }
#line 1763
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1763
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1766
  handle = req->current_outstanding_cmd;
#line 1767
  index = 1U;
#line 1767
  goto ldv_61109;
  ldv_61108: 
#line 1768
  handle = handle + 1U;
#line 1769
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1770
    handle = 1U;
  } else {

  }
#line 1771
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 1772
    goto ldv_61107;
  } else {

  }
#line 1767
  index = index + 1U;
  ldv_61109: ;
#line 1767
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 1769
    goto ldv_61108;
  } else {

  }
  ldv_61107: ;
#line 1774
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 1775
    goto queuing_error;
  } else {

  }
#line 1778
  tmp___4 = scsi_sg_count(cmd);
#line 1778
  if (tmp___4 != 0U) {
#line 1779
    tmp___1 = scsi_sg_count(cmd);
#line 1779
    tmp___2 = scsi_sglist(cmd);
#line 1779
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1781
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 1781
    if (tmp___3 != 0L) {
#line 1782
      goto queuing_error;
    } else {

    }
  } else {
#line 1784
    nseg = 0;
  }
#line 1786
  tot_dsds = (uint16_t )nseg;
#line 1787
  req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 1788
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 1789
    tmp___5 = __readl((void const volatile   *)req->req_q_out);
#line 1789
    cnt = (uint16_t )tmp___5;
#line 1791
    if ((int )req->ring_index < (int )cnt) {
#line 1792
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 1794
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 1796
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 1797
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 1801
  req->current_outstanding_cmd = handle;
#line 1802
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 1803
  sp->handle = handle;
#line 1804
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 1805
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 1807
  cmd_pkt = (struct cmd_type_7 *)req->ring_ptr;
#line 1808
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 1812
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 1813
  memset((void *)clr_ptr, 0, 56UL);
#line 1814
  cmd_pkt->dseg_count = tot_dsds;
#line 1817
  cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 1818
  cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 1819
  cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 1820
  cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 1821
  cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 1823
  int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 1824
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 1827
  tmp___6 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 1827
  if (tmp___6 != 0) {
#line 1828
    switch ((int )tag[0]) {
    case 33: 
#line 1830
    cmd_pkt->task = 1U;
#line 1831
    goto ldv_61112;
    case 34: 
#line 1833
    cmd_pkt->task = 2U;
#line 1834
    goto ldv_61112;
    default: 
#line 1836
    cmd_pkt->task = 0U;
#line 1837
    goto ldv_61112;
    }
    ldv_61112: ;
  } else {
#line 1840
    cmd_pkt->task = 0U;
  }
#line 1844
  __len = (size_t )cmd->cmd_len;
#line 1844
  __ret = __builtin_memcpy((void *)(& cmd_pkt->fcp_cdb), (void const   *)cmd->cmnd,
                           __len);
#line 1845
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->fcp_cdb), 16U);
#line 1847
  cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 1850
  qla24xx_build_scsi_iocbs(sp, cmd_pkt, (int )tot_dsds);
#line 1853
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 1855
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 1856
  __asm__  volatile   ("sfence": : : "memory");
#line 1858
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 1859
  if ((int )req->ring_index == (int )req->length) {
#line 1860
    req->ring_index = 0U;
#line 1861
    req->ring_ptr = req->ring;
  } else {
#line 1863
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 1865
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 1868
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 1869
  __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
#line 1872
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 1874
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 1876
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1877
  return (0);
  queuing_error: ;
#line 1880
  if ((unsigned int )tot_dsds != 0U) {
#line 1881
    scsi_dma_unmap(cmd);
  } else {

  }
#line 1883
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1885
  return (258);
}
}
#line 1895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla24xx_dif_start_scsi(srb_t *sp ) 
{ 
  int nseg ;
  unsigned long flags ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  uint16_t tot_prot_dsds ;
  uint16_t fw_prot_opts ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct cmd_type_crc_2 *cmd_pkt ;
  uint32_t status ;
  int tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  struct scatterlist *tmp___4 ;
  long tmp___5 ;
  struct qla2_sgx sgx ;
  uint32_t partial ;
  int tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  struct scatterlist *tmp___11 ;
  long tmp___12 ;
  unsigned int tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;

  {
#line 1903
  req_cnt = 0U;
#line 1906
  fw_prot_opts = 0U;
#line 1907
  req = (struct req_que *)0;
#line 1908
  rsp = (struct rsp_que *)0;
#line 1909
  cmd = sp->u.scmd.cmd;
#line 1910
  vha = (sp->fcport)->vha;
#line 1911
  ha = vha->hw;
#line 1913
  status = 0U;
#line 1918
  tmp___0 = scsi_get_prot_op(cmd);
#line 1918
  if ((unsigned int )tmp___0 == 0U) {
#line 1919
    if ((unsigned int )cmd->cmd_len <= 16U) {
#line 1920
      tmp = qla24xx_start_scsi(sp);
#line 1920
      return (tmp);
    } else {

    }
  } else {

  }
#line 1925
  qla25xx_set_que(sp, & rsp);
#line 1926
  req = vha->req;
#line 1929
  tot_dsds = 0U;
#line 1932
  if ((unsigned int )vha->marker_needed != 0U) {
#line 1933
    tmp___1 = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 1933
    if (tmp___1 != 0) {
#line 1935
      return (258);
    } else {

    }
#line 1936
    vha->marker_needed = 0U;
  } else {

  }
#line 1940
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 1940
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1943
  handle = req->current_outstanding_cmd;
#line 1944
  index = 1U;
#line 1944
  goto ldv_61143;
  ldv_61142: 
#line 1945
  handle = handle + 1U;
#line 1946
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 1947
    handle = 1U;
  } else {

  }
#line 1948
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 1949
    goto ldv_61141;
  } else {

  }
#line 1944
  index = index + 1U;
  ldv_61143: ;
#line 1944
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 1946
    goto ldv_61142;
  } else {

  }
  ldv_61141: ;
#line 1952
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 1953
    goto queuing_error;
  } else {

  }
#line 1957
  tmp___9 = scsi_sg_count(cmd);
#line 1957
  if (tmp___9 != 0U) {
#line 1958
    tmp___3 = scsi_sg_count(cmd);
#line 1958
    tmp___4 = scsi_sglist(cmd);
#line 1958
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___4, (int )tmp___3, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1960
    tmp___5 = ldv__builtin_expect(nseg == 0, 0L);
#line 1960
    if (tmp___5 != 0L) {
#line 1961
      goto queuing_error;
    } else {
#line 1963
      sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
    }
#line 1965
    tmp___7 = scsi_get_prot_op(cmd);
#line 1965
    if ((unsigned int )tmp___7 == 1U) {
#line 1965
      goto _L;
    } else {
#line 1965
      tmp___8 = scsi_get_prot_op(cmd);
#line 1965
      if ((unsigned int )tmp___8 == 2U) {
        _L: /* CIL Label */ 
#line 1970
        memset((void *)(& sgx), 0, 48UL);
#line 1971
        sgx.tot_bytes = scsi_bufflen(cmd);
#line 1972
        sgx.cur_sg = scsi_sglist(cmd);
#line 1973
        sgx.sp = sp;
#line 1975
        nseg = 0;
#line 1976
        goto ldv_61148;
        ldv_61147: 
#line 1978
        nseg = nseg + 1;
        ldv_61148: 
#line 1976
        tmp___6 = qla24xx_get_one_block_sg((cmd->device)->sector_size, & sgx, & partial);
#line 1976
        if (tmp___6 != 0) {
#line 1978
          goto ldv_61147;
        } else {

        }

      } else {

      }
    }
  } else {
#line 1981
    nseg = 0;
  }
#line 1984
  tot_dsds = (uint16_t )nseg;
#line 1987
  tmp___16 = qla24xx_configure_prot_mode(sp, & fw_prot_opts);
#line 1987
  if (tmp___16 != 0) {
#line 1988
    tmp___10 = scsi_prot_sg_count(cmd);
#line 1988
    tmp___11 = scsi_prot_sglist(cmd);
#line 1988
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___11, (int )tmp___10, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 1990
    tmp___12 = ldv__builtin_expect(nseg == 0, 0L);
#line 1990
    if (tmp___12 != 0L) {
#line 1991
      goto queuing_error;
    } else {
#line 1993
      sp->flags = (uint16_t )((unsigned int )sp->flags | 16U);
    }
#line 1995
    tmp___14 = scsi_get_prot_op(cmd);
#line 1995
    if ((unsigned int )tmp___14 == 1U) {
#line 1997
      tmp___13 = scsi_bufflen(cmd);
#line 1997
      nseg = (int )(tmp___13 / (cmd->device)->sector_size);
    } else {
#line 1995
      tmp___15 = scsi_get_prot_op(cmd);
#line 1995
      if ((unsigned int )tmp___15 == 2U) {
#line 1997
        tmp___13 = scsi_bufflen(cmd);
#line 1997
        nseg = (int )(tmp___13 / (cmd->device)->sector_size);
      } else {

      }
    }
  } else {
#line 2000
    nseg = 0;
  }
#line 2003
  req_cnt = 1U;
#line 2005
  tot_prot_dsds = (uint16_t )nseg;
#line 2006
  tot_dsds = (int )((uint16_t )nseg) + (int )tot_dsds;
#line 2007
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 2008
    tmp___17 = __readl((void const volatile   *)req->req_q_out);
#line 2008
    cnt = (uint16_t )tmp___17;
#line 2010
    if ((int )req->ring_index < (int )cnt) {
#line 2011
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 2013
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 2015
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2016
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 2019
  status = status | 1U;
#line 2022
  req->current_outstanding_cmd = handle;
#line 2023
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 2024
  sp->handle = handle;
#line 2025
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 2026
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 2029
  cmd_pkt = (struct cmd_type_crc_2 *)req->ring_ptr;
#line 2030
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 2032
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 2033
  memset((void *)clr_ptr, 0, 56UL);
#line 2036
  cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 2037
  cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2038
  cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2039
  cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2041
  int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 2042
  host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 2045
  cmd_pkt->dseg_count = tot_dsds;
#line 2048
  tmp___18 = qla24xx_build_scsi_crc_2_iocbs(sp, (struct cmd_type_crc_2 *)req->ring_ptr,
                                            (int )tot_dsds, (int )tot_prot_dsds, (int )fw_prot_opts);
#line 2048
  if (tmp___18 != 0) {
#line 2051
    goto queuing_error;
  } else {

  }
#line 2053
  cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 2055
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 2056
  cmd_pkt->timeout = 0U;
#line 2057
  __asm__  volatile   ("sfence": : : "memory");
#line 2060
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 2061
  if ((int )req->ring_index == (int )req->length) {
#line 2062
    req->ring_index = 0U;
#line 2063
    req->ring_ptr = req->ring;
  } else {
#line 2065
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 2068
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 2069
  __readl((void const volatile   *)(& (ha->iobase)->isp24.hccr));
#line 2072
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 2074
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 2076
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2078
  return (0);
  queuing_error: ;
#line 2081
  if ((int )status & 1) {
#line 2082
    *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2083
    req->cnt = (int )req->cnt + (int )req_cnt;
  } else {

  }
#line 2087
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2088
  return (258);
}
}
#line 2092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla25xx_set_que(srb_t *sp , struct rsp_que **rsp ) 
{ 
  struct scsi_cmnd *cmd ;
  struct qla_hw_data *ha ;
  int affinity ;

  {
#line 2094
  cmd = sp->u.scmd.cmd;
#line 2095
  ha = ((sp->fcport)->vha)->hw;
#line 2096
  affinity = (cmd->request)->cpu;
#line 2098
  if ((*((unsigned long *)ha + 2UL) != 0UL && affinity >= 0) && (int )ha->max_rsp_queues + -1 > affinity) {
#line 2100
    *rsp = *(ha->rsp_q_map + ((unsigned long )affinity + 1UL));
  } else {
#line 2102
    *rsp = *(ha->rsp_q_map);
  }
#line 2103
  return;
}
}
#line 2107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void *qla2x00_alloc_iocbs(struct scsi_qla_host *vha , srb_t *sp ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  device_reg_t *reg ;
  uint32_t index ;
  uint32_t handle ;
  request_t *pkt ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2109
  ha = vha->hw;
#line 2110
  req = *(ha->req_q_map);
#line 2111
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase + (unsigned long )((int )req->id * 4096) : ha->iobase;
#line 2116
  pkt = (request_t *)0;
#line 2117
  req_cnt = 1U;
#line 2118
  handle = 0U;
#line 2120
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2121
    goto skip_cmd_array;
  } else {

  }
#line 2124
  handle = req->current_outstanding_cmd;
#line 2125
  index = 1U;
#line 2125
  goto ldv_61172;
  ldv_61171: 
#line 2126
  handle = handle + 1U;
#line 2127
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2128
    handle = 1U;
  } else {

  }
#line 2129
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 2130
    goto ldv_61170;
  } else {

  }
#line 2125
  index = index + 1U;
  ldv_61172: ;
#line 2125
  if ((unsigned int )req->num_outstanding_cmds != 0U) {
#line 2127
    goto ldv_61171;
  } else {

  }
  ldv_61170: ;
#line 2132
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 2133
    ql_log(1U, vha, 28683, "No room on outstanding cmd array.\n");
#line 2135
    goto queuing_error;
  } else {

  }
#line 2139
  req->current_outstanding_cmd = handle;
#line 2140
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 2141
  sp->handle = handle;
#line 2144
  if ((unsigned int )sp->type != 8U) {
#line 2145
    req_cnt = (uint16_t )sp->iocbs;
  } else {

  }
  skip_cmd_array: ;
#line 2149
  if ((int )req->cnt < (int )req_cnt) {
#line 2150
    if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 2151
      tmp = readl((void const volatile   *)(& reg->isp25mq.req_q_out));
#line 2151
      cnt = (uint16_t )tmp;
    } else
#line 2152
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2153
      tmp___0 = readl((void const volatile   *)(& reg->isp82.req_q_out));
#line 2153
      cnt = (uint16_t )tmp___0;
    } else
#line 2154
    if ((ha->device_type & 134217728U) != 0U) {
#line 2155
      tmp___1 = readl((void const volatile   *)(& reg->isp24.req_q_out));
#line 2155
      cnt = (uint16_t )tmp___1;
    } else
#line 2156
    if ((ha->device_type & 131072U) != 0U) {
#line 2157
      tmp___2 = readl((void const volatile   *)(& reg->ispfx00.req_q_out));
#line 2157
      cnt = (uint16_t )tmp___2;
    } else {
#line 2159
      cnt = qla2x00_debounce_register___0((uint16_t volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->isp.u.isp2100.mailbox4 : & reg->isp.u.isp2300.req_q_out));
    }
#line 2162
    if ((int )req->ring_index < (int )cnt) {
#line 2163
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 2165
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
  } else {

  }
#line 2168
  if ((int )req->cnt < (int )req_cnt) {
#line 2169
    goto queuing_error;
  } else {

  }
#line 2172
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 2173
  pkt = req->ring_ptr;
#line 2174
  memset((void *)pkt, 0, 64UL);
#line 2175
  if ((ha->device_type & 131072U) != 0U) {
#line 2176
    writeb((int )((unsigned char )req_cnt), (void volatile   *)(& pkt->entry_count));
#line 2177
    writew((int )((unsigned short )handle), (void volatile   *)(& pkt->handle));
  } else {
#line 2179
    pkt->entry_count = (uint8_t )req_cnt;
#line 2180
    pkt->handle = handle;
  }
  queuing_error: ;
#line 2184
  return ((void *)pkt);
}
}
#line 2188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_login_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 
  struct srb_iocb *lio ;

  {
#line 2190
  lio = & sp->u.iocb_cmd;
#line 2192
  logio->entry_type = 82U;
#line 2193
  logio->control_flags = 0U;
#line 2194
  if (((int )lio->u.logio.flags & 2) != 0) {
#line 2195
    logio->control_flags = (uint16_t )((unsigned int )logio->control_flags | 16U);
  } else {

  }
#line 2196
  if (((int )lio->u.logio.flags & 4) != 0) {
#line 2197
    logio->control_flags = (uint16_t )((unsigned int )logio->control_flags | 32U);
  } else {

  }
#line 2198
  logio->nport_handle = (sp->fcport)->loop_id;
#line 2199
  logio->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2200
  logio->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2201
  logio->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2202
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2203
  return;
}
}
#line 2206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla2x00_login_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;
  struct srb_iocb *lio ;
  uint16_t opts ;

  {
#line 2208
  ha = ((sp->fcport)->vha)->hw;
#line 2209
  lio = & sp->u.iocb_cmd;
#line 2212
  mbx->entry_type = 57U;
#line 2213
  if ((int )ha->device_type < 0) {
#line 2213
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 2213
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 2214
  mbx->mb0 = 111U;
#line 2215
  opts = ((int )lio->u.logio.flags & 2) != 0;
#line 2216
  opts = (uint16_t )((((int )lio->u.logio.flags & 4) != 0 ? 2 : 0) | (int )((short )opts));
#line 2217
  if ((int )ha->device_type < 0) {
#line 2218
    mbx->mb1 = (sp->fcport)->loop_id;
#line 2219
    mbx->mb10 = opts;
  } else {
#line 2221
    mbx->mb1 = (unsigned short )((int )((short )((int )(sp->fcport)->loop_id << 8)) | (int )((short )opts));
  }
#line 2223
  mbx->mb2 = (unsigned short )(sp->fcport)->d_id.b.domain;
#line 2224
  mbx->mb3 = (unsigned short )((int )((short )((int )(sp->fcport)->d_id.b.area << 8)) | (int )((short )(sp->fcport)->d_id.b.al_pa));
#line 2226
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 2227
  return;
}
}
#line 2230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_logout_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 


  {
#line 2232
  logio->entry_type = 82U;
#line 2233
  logio->control_flags = 24U;
#line 2235
  logio->nport_handle = (sp->fcport)->loop_id;
#line 2236
  logio->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2237
  logio->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2238
  logio->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2239
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2240
  return;
}
}
#line 2243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla2x00_logout_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2245
  ha = ((sp->fcport)->vha)->hw;
#line 2247
  mbx->entry_type = 57U;
#line 2248
  if ((int )ha->device_type < 0) {
#line 2248
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 2248
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 2249
  mbx->mb0 = 113U;
#line 2250
  mbx->mb1 = (int )ha->device_type < 0 ? (sp->fcport)->loop_id : (uint16_t )((int )(sp->fcport)->loop_id << 8U);
#line 2253
  mbx->mb2 = (unsigned short )(sp->fcport)->d_id.b.domain;
#line 2254
  mbx->mb3 = (unsigned short )((int )((short )((int )(sp->fcport)->d_id.b.area << 8)) | (int )((short )(sp->fcport)->d_id.b.al_pa));
#line 2256
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 2257
  return;
}
}
#line 2261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_adisc_iocb(srb_t *sp , struct logio_entry_24xx *logio ) 
{ 


  {
#line 2263
  logio->entry_type = 82U;
#line 2264
  logio->control_flags = 3U;
#line 2265
  logio->nport_handle = (sp->fcport)->loop_id;
#line 2266
  logio->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2267
  return;
}
}
#line 2270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla2x00_adisc_iocb(srb_t *sp , struct mbx_entry *mbx ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2272
  ha = ((sp->fcport)->vha)->hw;
#line 2274
  mbx->entry_type = 57U;
#line 2275
  if ((int )ha->device_type < 0) {
#line 2275
    mbx->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 2275
    mbx->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 2276
  mbx->mb0 = 100U;
#line 2277
  if ((int )ha->device_type < 0) {
#line 2278
    mbx->mb1 = (sp->fcport)->loop_id;
#line 2279
    mbx->mb10 = 1U;
  } else {
#line 2281
    mbx->mb1 = (unsigned short )((int )((short )((int )(sp->fcport)->loop_id << 8)) | 1);
  }
#line 2283
  mbx->mb2 = (unsigned short )((unsigned int )ha->async_pd_dma >> 16);
#line 2284
  mbx->mb3 = (unsigned short )ha->async_pd_dma;
#line 2285
  mbx->mb6 = (unsigned short )((unsigned int )(ha->async_pd_dma >> 32ULL) >> 16);
#line 2286
  mbx->mb7 = (unsigned short )(ha->async_pd_dma >> 32ULL);
#line 2287
  mbx->mb9 = ((sp->fcport)->vha)->vp_idx;
#line 2288
  return;
}
}
#line 2291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_tm_iocb(srb_t *sp , struct tsk_mgmt_entry *tsk ) 
{ 
  uint32_t flags ;
  unsigned int lun ;
  struct fc_port *fcport ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct srb_iocb *iocb ;
  struct req_que *req ;

  {
#line 2295
  fcport = sp->fcport;
#line 2296
  vha = fcport->vha;
#line 2297
  ha = vha->hw;
#line 2298
  iocb = & sp->u.iocb_cmd;
#line 2299
  req = vha->req;
#line 2301
  flags = iocb->u.tmf.flags;
#line 2302
  lun = iocb->u.tmf.lun;
#line 2304
  tsk->entry_type = 20U;
#line 2305
  tsk->entry_count = 1U;
#line 2306
  tsk->handle = ((unsigned int )req->id << 16) | tsk->handle;
#line 2307
  tsk->nport_handle = fcport->loop_id;
#line 2308
  tsk->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2309
  tsk->control_flags = flags;
#line 2310
  tsk->port_id[0] = fcport->d_id.b.al_pa;
#line 2311
  tsk->port_id[1] = fcport->d_id.b.area;
#line 2312
  tsk->port_id[2] = fcport->d_id.b.domain;
#line 2313
  tsk->vp_index = (uint8_t )(fcport->vha)->vp_idx;
#line 2315
  if (flags == 16U) {
#line 2316
    int_to_scsilun(lun, & tsk->lun);
#line 2317
    host_to_fcp_swap((uint8_t *)(& tsk->lun), 8U);
  } else {

  }
#line 2319
  return;
}
}
#line 2323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_els_iocb(srb_t *sp , struct els_entry_24xx *els_iocb ) 
{ 
  struct fc_bsg_job *bsg_job ;

  {
#line 2325
  bsg_job = sp->u.bsg_job;
#line 2327
  els_iocb->entry_type = 83U;
#line 2328
  els_iocb->entry_count = 1U;
#line 2329
  els_iocb->sys_define = 0U;
#line 2330
  els_iocb->entry_status = 0U;
#line 2331
  els_iocb->handle = sp->handle;
#line 2332
  els_iocb->nport_handle = (sp->fcport)->loop_id;
#line 2333
  els_iocb->tx_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2334
  els_iocb->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2335
  els_iocb->sof_type = 16U;
#line 2336
  els_iocb->rx_dsd_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2338
  els_iocb->opcode = (unsigned int )sp->type == 3U ? (bsg_job->request)->rqst_data.r_els.els_code : (bsg_job->request)->rqst_data.h_els.command_code;
#line 2342
  els_iocb->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2343
  els_iocb->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2344
  els_iocb->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2345
  els_iocb->control_flags = 0U;
#line 2346
  els_iocb->rx_byte_count = bsg_job->reply_payload.payload_len;
#line 2348
  els_iocb->tx_byte_count = bsg_job->request_payload.payload_len;
#line 2351
  els_iocb->tx_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2353
  els_iocb->tx_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2355
  els_iocb->tx_len = (bsg_job->request_payload.sg_list)->dma_length;
#line 2358
  els_iocb->rx_address[0] = (unsigned int )(bsg_job->reply_payload.sg_list)->dma_address;
#line 2360
  els_iocb->rx_address[1] = (unsigned int )((bsg_job->reply_payload.sg_list)->dma_address >> 32ULL);
#line 2362
  els_iocb->rx_len = (bsg_job->reply_payload.sg_list)->dma_length;
#line 2365
  ((sp->fcport)->vha)->qla_stats.control_requests = ((sp->fcport)->vha)->qla_stats.control_requests + 1U;
#line 2366
  return;
}
}
#line 2369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla2x00_ct_iocb(srb_t *sp , ms_iocb_entry_t *ct_iocb ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  struct scatterlist *sg ;
  int index ;
  uint16_t tot_dsds ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct fc_bsg_job *bsg_job ;
  int loop_iterartion ;
  int cont_iocb_prsnt ;
  int entry_count ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 2376
  vha = (sp->fcport)->vha;
#line 2377
  ha = vha->hw;
#line 2378
  bsg_job = sp->u.bsg_job;
#line 2379
  loop_iterartion = 0;
#line 2380
  cont_iocb_prsnt = 0;
#line 2381
  entry_count = 1;
#line 2383
  memset((void *)ct_iocb, 0, 64UL);
#line 2384
  ct_iocb->entry_type = 41U;
#line 2385
  ct_iocb->entry_status = 0U;
#line 2386
  ct_iocb->handle1 = sp->handle;
#line 2387
  if ((int )ha->device_type < 0) {
#line 2387
    ct_iocb->loop_id.extended = (sp->fcport)->loop_id;
  } else {
#line 2387
    ct_iocb->loop_id.id.standard = (unsigned char )(sp->fcport)->loop_id;
  }
#line 2388
  ct_iocb->status = 0U;
#line 2389
  ct_iocb->control_flags = 0U;
#line 2390
  ct_iocb->timeout = 0U;
#line 2391
  ct_iocb->cmd_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2393
  ct_iocb->total_dsd_count = (unsigned int )((unsigned short )bsg_job->request_payload.sg_cnt) + 1U;
#line 2395
  ct_iocb->req_bytecount = bsg_job->request_payload.payload_len;
#line 2397
  ct_iocb->rsp_bytecount = bsg_job->reply_payload.payload_len;
#line 2400
  ct_iocb->dseg_req_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2402
  ct_iocb->dseg_req_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2404
  ct_iocb->dseg_req_length = ct_iocb->req_bytecount;
#line 2406
  ct_iocb->dseg_rsp_address[0] = (unsigned int )(bsg_job->reply_payload.sg_list)->dma_address;
#line 2408
  ct_iocb->dseg_rsp_address[1] = (unsigned int )((bsg_job->reply_payload.sg_list)->dma_address >> 32ULL);
#line 2410
  ct_iocb->dseg_rsp_length = ct_iocb->rsp_bytecount;
#line 2412
  avail_dsds = 1U;
#line 2413
  cur_dsd = (uint32_t *)(& ct_iocb->dseg_rsp_address);
#line 2414
  index = 0;
#line 2415
  tot_dsds = (uint16_t )bsg_job->reply_payload.sg_cnt;
#line 2417
  index = 0;
#line 2417
  sg = bsg_job->reply_payload.sg_list;
#line 2417
  goto ldv_61238;
  ldv_61237: ;
#line 2422
  if ((unsigned int )avail_dsds == 0U) {
#line 2427
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, *((vha->hw)->req_q_map));
#line 2429
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 2430
    avail_dsds = 5U;
#line 2431
    cont_iocb_prsnt = 1;
#line 2432
    entry_count = entry_count + 1;
  } else {

  }
#line 2435
  sle_dma = sg->dma_address;
#line 2436
  tmp = cur_dsd;
#line 2436
  cur_dsd = cur_dsd + 1;
#line 2436
  *tmp = (unsigned int )sle_dma;
#line 2437
  tmp___0 = cur_dsd;
#line 2437
  cur_dsd = cur_dsd + 1;
#line 2437
  *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 2438
  tmp___1 = cur_dsd;
#line 2438
  cur_dsd = cur_dsd + 1;
#line 2438
  *tmp___1 = sg->dma_length;
#line 2439
  loop_iterartion = loop_iterartion + 1;
#line 2440
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2417
  index = index + 1;
#line 2417
  sg = sg_next(sg);
  ldv_61238: ;
#line 2417
  if ((int )tot_dsds > index) {
#line 2419
    goto ldv_61237;
  } else {

  }
#line 2442
  ct_iocb->entry_count = (uint8_t )entry_count;
#line 2444
  ((sp->fcport)->vha)->qla_stats.control_requests = ((sp->fcport)->vha)->qla_stats.control_requests + 1U;
#line 2445
  return;
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla24xx_ct_iocb(srb_t *sp , struct ct_entry_24xx *ct_iocb ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  struct scatterlist *sg ;
  int index ;
  uint16_t tot_dsds ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct fc_bsg_job *bsg_job ;
  int loop_iterartion ;
  int cont_iocb_prsnt ;
  int entry_count ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 2455
  vha = (sp->fcport)->vha;
#line 2456
  ha = vha->hw;
#line 2457
  bsg_job = sp->u.bsg_job;
#line 2458
  loop_iterartion = 0;
#line 2459
  cont_iocb_prsnt = 0;
#line 2460
  entry_count = 1;
#line 2462
  ct_iocb->entry_type = 41U;
#line 2463
  ct_iocb->entry_status = 0U;
#line 2464
  ct_iocb->sys_define = 0U;
#line 2465
  ct_iocb->handle = sp->handle;
#line 2467
  ct_iocb->nport_handle = (sp->fcport)->loop_id;
#line 2468
  ct_iocb->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2469
  ct_iocb->comp_status = 0U;
#line 2471
  ct_iocb->cmd_dsd_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2473
  ct_iocb->timeout = 0U;
#line 2474
  ct_iocb->rsp_dsd_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2476
  ct_iocb->rsp_byte_count = bsg_job->reply_payload.payload_len;
#line 2478
  ct_iocb->cmd_byte_count = bsg_job->request_payload.payload_len;
#line 2480
  ct_iocb->dseg_0_address[0] = (unsigned int )(bsg_job->request_payload.sg_list)->dma_address;
#line 2482
  ct_iocb->dseg_0_address[1] = (unsigned int )((bsg_job->request_payload.sg_list)->dma_address >> 32ULL);
#line 2484
  ct_iocb->dseg_0_len = (bsg_job->request_payload.sg_list)->dma_length;
#line 2487
  avail_dsds = 1U;
#line 2488
  cur_dsd = (uint32_t *)(& ct_iocb->dseg_1_address);
#line 2489
  index = 0;
#line 2490
  tot_dsds = (uint16_t )bsg_job->reply_payload.sg_cnt;
#line 2492
  index = 0;
#line 2492
  sg = bsg_job->reply_payload.sg_list;
#line 2492
  goto ldv_61258;
  ldv_61257: ;
#line 2497
  if ((unsigned int )avail_dsds == 0U) {
#line 2502
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, *(ha->req_q_map));
#line 2504
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 2505
    avail_dsds = 5U;
#line 2506
    cont_iocb_prsnt = 1;
#line 2507
    entry_count = entry_count + 1;
  } else {

  }
#line 2510
  sle_dma = sg->dma_address;
#line 2511
  tmp = cur_dsd;
#line 2511
  cur_dsd = cur_dsd + 1;
#line 2511
  *tmp = (unsigned int )sle_dma;
#line 2512
  tmp___0 = cur_dsd;
#line 2512
  cur_dsd = cur_dsd + 1;
#line 2512
  *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 2513
  tmp___1 = cur_dsd;
#line 2513
  cur_dsd = cur_dsd + 1;
#line 2513
  *tmp___1 = sg->dma_length;
#line 2514
  loop_iterartion = loop_iterartion + 1;
#line 2515
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 2492
  index = index + 1;
#line 2492
  sg = sg_next(sg);
  ldv_61258: ;
#line 2492
  if ((int )tot_dsds > index) {
#line 2494
    goto ldv_61257;
  } else {

  }
#line 2517
  ct_iocb->entry_count = (uint8_t )entry_count;
#line 2518
  return;
}
}
#line 2527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla82xx_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  struct scsi_cmnd *cmd ;
  uint32_t *clr_ptr ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct device_reg_82xx *reg ;
  uint32_t dbval ;
  uint32_t *fcp_dl ;
  uint8_t additional_cdb_len ;
  struct ct6_dsd *ctx ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  char tag[2U] ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  struct cmd_type_6 *cmd_pkt ;
  uint16_t more_dsd_lists ;
  struct dsd_dma *dsd_ptr ;
  uint16_t i ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __len ;
  void *__ret ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  struct cmd_type_7 *cmd_pkt___0 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned int tmp___15 ;

  {
#line 2543
  vha = (sp->fcport)->vha;
#line 2544
  ha = vha->hw;
#line 2545
  req = (struct req_que *)0;
#line 2546
  rsp = (struct rsp_que *)0;
#line 2550
  ret = 0;
#line 2551
  reg = & (ha->iobase)->isp82;
#line 2552
  cmd = sp->u.scmd.cmd;
#line 2553
  req = vha->req;
#line 2554
  rsp = *(ha->rsp_q_map);
#line 2557
  tot_dsds = 0U;
#line 2559
  dbval = (uint32_t )(((int )ha->portnum << 5) | 4);
#line 2562
  if ((unsigned int )vha->marker_needed != 0U) {
#line 2563
    tmp = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 2563
    if (tmp != 0) {
#line 2565
      ql_log(1U, vha, 12300, "qla2x00_marker failed for cmd=%p.\n", cmd);
#line 2567
      return (258);
    } else {

    }
#line 2569
    vha->marker_needed = 0U;
  } else {

  }
#line 2573
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2573
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2576
  handle = req->current_outstanding_cmd;
#line 2577
  index = 1U;
#line 2577
  goto ldv_61288;
  ldv_61287: 
#line 2578
  handle = handle + 1U;
#line 2579
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 2580
    handle = 1U;
  } else {

  }
#line 2581
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 2582
    goto ldv_61286;
  } else {

  }
#line 2577
  index = index + 1U;
  ldv_61288: ;
#line 2577
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 2579
    goto ldv_61287;
  } else {

  }
  ldv_61286: ;
#line 2584
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 2585
    goto queuing_error;
  } else {

  }
#line 2588
  tmp___4 = scsi_sg_count(cmd);
#line 2588
  if (tmp___4 != 0U) {
#line 2589
    tmp___1 = scsi_sg_count(cmd);
#line 2589
    tmp___2 = scsi_sglist(cmd);
#line 2589
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 2591
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 2591
    if (tmp___3 != 0L) {
#line 2592
      goto queuing_error;
    } else {

    }
  } else {
#line 2594
    nseg = 0;
  }
#line 2596
  tot_dsds = (uint16_t )nseg;
#line 2598
  if ((int )tot_dsds > ql2xshiftctondsd) {
#line 2600
    more_dsd_lists = 0U;
#line 2604
    more_dsd_lists = qla24xx_calc_dsd_lists((int )tot_dsds);
#line 2605
    if ((int )more_dsd_lists + (int )ha->gbl_dsd_inuse > 4095) {
#line 2606
      ql_dbg(134217728U, vha, 12301, "Num of DSD list %d is than %d for cmd=%p.\n",
             (int )more_dsd_lists + (int )ha->gbl_dsd_inuse, 4096, cmd);
#line 2610
      goto queuing_error;
    } else {

    }
#line 2613
    if ((int )ha->gbl_dsd_avail >= (int )more_dsd_lists) {
#line 2614
      goto sufficient_dsds;
    } else {
#line 2616
      more_dsd_lists = (int )more_dsd_lists - (int )ha->gbl_dsd_avail;
    }
#line 2618
    i = 0U;
#line 2618
    goto ldv_61296;
    ldv_61295: 
#line 2619
    tmp___5 = kzalloc(32UL, 32U);
#line 2619
    dsd_ptr = (struct dsd_dma *)tmp___5;
#line 2620
    if ((unsigned long )dsd_ptr == (unsigned long )((struct dsd_dma *)0)) {
#line 2621
      ql_log(0U, vha, 12302, "Failed to allocate memory for dsd_dma for cmd=%p.\n",
             cmd);
#line 2624
      goto queuing_error;
    } else {

    }
#line 2627
    dsd_ptr->dsd_addr = dma_pool_alloc(ha->dl_dma_pool, 32U, & dsd_ptr->dsd_list_dma);
#line 2629
    if ((unsigned long )dsd_ptr->dsd_addr == (unsigned long )((void *)0)) {
#line 2630
      kfree((void const   *)dsd_ptr);
#line 2631
      ql_log(0U, vha, 12303, "Failed to allocate memory for dsd_addr for cmd=%p.\n",
             cmd);
#line 2634
      goto queuing_error;
    } else {

    }
#line 2636
    list_add_tail(& dsd_ptr->list, & ha->gbl_dsd_list);
#line 2637
    ha->gbl_dsd_avail = (uint16_t )((int )ha->gbl_dsd_avail + 1);
#line 2618
    i = (uint16_t )((int )i + 1);
    ldv_61296: ;
#line 2618
    if ((int )i < (int )more_dsd_lists) {
#line 2620
      goto ldv_61295;
    } else {

    }

    sufficient_dsds: 
#line 2641
    req_cnt = 1U;
#line 2643
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2644
      tmp___6 = __readl((void const volatile   *)(& reg->req_q_out));
#line 2644
      cnt = (unsigned short )tmp___6;
#line 2646
      if ((int )req->ring_index < (int )cnt) {
#line 2647
        req->cnt = (int )cnt - (int )req->ring_index;
      } else {
#line 2649
        req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
      }
#line 2651
      if ((int )req->cnt < (int )req_cnt + 2) {
#line 2652
        goto queuing_error;
      } else {

      }
    } else {

    }
#line 2655
    tmp___7 = mempool_alloc(ha->ctx_mempool, 32U);
#line 2655
    sp->u.scmd.ctx = tmp___7;
#line 2655
    ctx = (struct ct6_dsd *)tmp___7;
#line 2657
    if ((unsigned long )ctx == (unsigned long )((struct ct6_dsd *)0)) {
#line 2658
      ql_log(0U, vha, 12304, "Failed to allocate ctx for cmd=%p.\n", cmd);
#line 2660
      goto queuing_error;
    } else {

    }
#line 2663
    memset((void *)ctx, 0, 48UL);
#line 2664
    tmp___8 = dma_pool_alloc(ha->fcp_cmnd_dma_pool, 32U, & ctx->fcp_cmnd_dma);
#line 2664
    ctx->fcp_cmnd = (struct fcp_cmnd *)tmp___8;
#line 2666
    if ((unsigned long )ctx->fcp_cmnd == (unsigned long )((struct fcp_cmnd *)0)) {
#line 2667
      ql_log(0U, vha, 12305, "Failed to allocate fcp_cmnd for cmd=%p.\n", cmd);
#line 2669
      goto queuing_error;
    } else {

    }
#line 2673
    INIT_LIST_HEAD(& ctx->dsd_list);
#line 2674
    ctx->dsd_use_cnt = 0;
#line 2676
    if ((unsigned int )cmd->cmd_len > 16U) {
#line 2677
      additional_cdb_len = (unsigned int )((uint8_t )cmd->cmd_len) + 240U;
#line 2678
      if (((unsigned int )cmd->cmd_len & 3U) != 0U) {
#line 2682
        ql_log(1U, vha, 12306, "scsi cmd len %d not multiple of 4 for cmd=%p.\n",
               (int )cmd->cmd_len, cmd);
#line 2685
        goto queuing_error_fcp_cmnd;
      } else {

      }
#line 2687
      ctx->fcp_cmnd_len = (unsigned int )cmd->cmd_len + 16U;
    } else {
#line 2689
      additional_cdb_len = 0U;
#line 2690
      ctx->fcp_cmnd_len = 32U;
    }
#line 2693
    cmd_pkt = (struct cmd_type_6 *)req->ring_ptr;
#line 2694
    cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 2698
    clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 2699
    memset((void *)clr_ptr, 0, 56UL);
#line 2700
    cmd_pkt->dseg_count = tot_dsds;
#line 2703
    cmd_pkt->nport_handle = (sp->fcport)->loop_id;
#line 2704
    cmd_pkt->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2705
    cmd_pkt->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2706
    cmd_pkt->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2707
    cmd_pkt->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2710
    tmp___9 = qla24xx_build_scsi_type_6_iocbs(sp, cmd_pkt, (int )tot_dsds);
#line 2710
    if (tmp___9 != 0) {
#line 2711
      goto queuing_error_fcp_cmnd;
    } else {

    }
#line 2713
    int_to_scsilun((cmd->device)->lun, & cmd_pkt->lun);
#line 2714
    host_to_fcp_swap((uint8_t *)(& cmd_pkt->lun), 8U);
#line 2717
    memset((void *)ctx->fcp_cmnd, 0, 272UL);
#line 2718
    int_to_scsilun((cmd->device)->lun, & (ctx->fcp_cmnd)->lun);
#line 2719
    (ctx->fcp_cmnd)->additional_cdb_len = additional_cdb_len;
#line 2721
    if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 2722
      (ctx->fcp_cmnd)->additional_cdb_len = (uint8_t )((unsigned int )(ctx->fcp_cmnd)->additional_cdb_len | 1U);
    } else
#line 2723
    if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 2724
      (ctx->fcp_cmnd)->additional_cdb_len = (uint8_t )((unsigned int )(ctx->fcp_cmnd)->additional_cdb_len | 2U);
    } else {

    }
#line 2729
    tmp___10 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 2729
    if (tmp___10 != 0) {
#line 2730
      switch ((int )tag[0]) {
      case 33: 
#line 2732
      (ctx->fcp_cmnd)->task_attribute = 1U;
#line 2734
      goto ldv_61300;
      case 34: 
#line 2736
      (ctx->fcp_cmnd)->task_attribute = 2U;
#line 2738
      goto ldv_61300;
      }
      ldv_61300: ;
    } else {

    }
#line 2743
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2744
      (ctx->fcp_cmnd)->task_attribute = (uint8_t )((int )((signed char )(ctx->fcp_cmnd)->task_attribute) | (int )((signed char )((int )(sp->fcport)->fcp_prio << 3)));
    } else {

    }
#line 2747
    __len = (size_t )cmd->cmd_len;
#line 2747
    __ret = __builtin_memcpy((void *)(& (ctx->fcp_cmnd)->cdb), (void const   *)cmd->cmnd,
                             __len);
#line 2749
    fcp_dl = (uint32_t *)(& (ctx->fcp_cmnd)->cdb) + ((unsigned long )additional_cdb_len + 16UL);
#line 2751
    tmp___11 = scsi_bufflen(cmd);
#line 2751
    tmp___12 = __fswab32(tmp___11);
#line 2751
    *fcp_dl = tmp___12;
#line 2753
    cmd_pkt->fcp_cmnd_dseg_len = ctx->fcp_cmnd_len;
#line 2754
    cmd_pkt->fcp_cmnd_dseg_address[0] = (unsigned int )ctx->fcp_cmnd_dma;
#line 2756
    cmd_pkt->fcp_cmnd_dseg_address[1] = (unsigned int )(ctx->fcp_cmnd_dma >> 32ULL);
#line 2759
    sp->flags = (uint16_t )((unsigned int )sp->flags | 4096U);
#line 2760
    cmd_pkt->byte_count = scsi_bufflen(cmd);
#line 2762
    cmd_pkt->entry_count = (unsigned char )req_cnt;
#line 2766
    cmd_pkt->entry_status = (unsigned char )rsp->id;
  } else {
#line 2769
    req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 2770
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2771
      tmp___13 = __readl((void const volatile   *)(& reg->req_q_out));
#line 2771
      cnt = (unsigned short )tmp___13;
#line 2773
      if ((int )req->ring_index < (int )cnt) {
#line 2774
        req->cnt = (int )cnt - (int )req->ring_index;
      } else {
#line 2776
        req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
      }
    } else {

    }
#line 2779
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 2780
      goto queuing_error;
    } else {

    }
#line 2782
    cmd_pkt___0 = (struct cmd_type_7 *)req->ring_ptr;
#line 2783
    cmd_pkt___0->handle = ((unsigned int )req->id << 16) | handle;
#line 2787
    clr_ptr = (uint32_t *)cmd_pkt___0 + 2UL;
#line 2788
    memset((void *)clr_ptr, 0, 56UL);
#line 2789
    cmd_pkt___0->dseg_count = tot_dsds;
#line 2792
    cmd_pkt___0->nport_handle = (sp->fcport)->loop_id;
#line 2793
    cmd_pkt___0->port_id[0] = (sp->fcport)->d_id.b.al_pa;
#line 2794
    cmd_pkt___0->port_id[1] = (sp->fcport)->d_id.b.area;
#line 2795
    cmd_pkt___0->port_id[2] = (sp->fcport)->d_id.b.domain;
#line 2796
    cmd_pkt___0->vp_index = (uint8_t )((sp->fcport)->vha)->vp_idx;
#line 2798
    int_to_scsilun((cmd->device)->lun, & cmd_pkt___0->lun);
#line 2799
    host_to_fcp_swap((uint8_t *)(& cmd_pkt___0->lun), 8U);
#line 2805
    tmp___14 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 2805
    if (tmp___14 != 0) {
#line 2806
      switch ((int )tag[0]) {
      case 33: 
#line 2808
      cmd_pkt___0->task = 1U;
#line 2809
      goto ldv_61307;
      case 34: 
#line 2811
      cmd_pkt___0->task = 2U;
#line 2812
      goto ldv_61307;
      }
      ldv_61307: ;
    } else {

    }
#line 2817
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2818
      cmd_pkt___0->task = (uint8_t )((int )((signed char )cmd_pkt___0->task) | (int )((signed char )((int )(sp->fcport)->fcp_prio << 3)));
    } else {

    }
#line 2821
    __len___0 = (size_t )cmd->cmd_len;
#line 2821
    __ret___0 = __builtin_memcpy((void *)(& cmd_pkt___0->fcp_cdb), (void const   *)cmd->cmnd,
                                 __len___0);
#line 2822
    host_to_fcp_swap((uint8_t *)(& cmd_pkt___0->fcp_cdb), 16U);
#line 2824
    cmd_pkt___0->byte_count = scsi_bufflen(cmd);
#line 2827
    qla24xx_build_scsi_iocbs(sp, cmd_pkt___0, (int )tot_dsds);
#line 2830
    cmd_pkt___0->entry_count = (unsigned char )req_cnt;
#line 2834
    cmd_pkt___0->entry_status = (unsigned char )rsp->id;
  }
#line 2838
  req->current_outstanding_cmd = handle;
#line 2839
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 2840
  sp->handle = handle;
#line 2841
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 2842
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 2843
  __asm__  volatile   ("sfence": : : "memory");
#line 2846
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 2847
  if ((int )req->ring_index == (int )req->length) {
#line 2848
    req->ring_index = 0U;
#line 2849
    req->ring_ptr = req->ring;
  } else {
#line 2851
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 2853
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 2857
  dbval = ((uint32_t )((int )req->id << 8) | dbval) | (uint32_t )((int )req->ring_index << 16);
#line 2858
  if (ql2xdbwr != 0) {
#line 2859
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, dbval);
  } else {
#line 2861
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2864
    __asm__  volatile   ("sfence": : : "memory");
#line 2865
    goto ldv_61313;
    ldv_61312: 
#line 2866
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 2869
    __asm__  volatile   ("sfence": : : "memory");
    ldv_61313: 
#line 2865
    tmp___15 = readl((void const volatile   *)ha->nxdb_rd_ptr);
#line 2865
    if (tmp___15 != dbval) {
#line 2867
      goto ldv_61312;
    } else {

    }

  }
#line 2874
  if (*((unsigned long *)vha + 19UL) != 0UL && (rsp->ring_ptr)->signature != 3735936685U) {
#line 2876
    qla24xx_process_response_queue(vha, rsp);
  } else {

  }
#line 2878
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2879
  return (0);
  queuing_error_fcp_cmnd: 
#line 2882
  dma_pool_free(ha->fcp_cmnd_dma_pool, (void *)ctx->fcp_cmnd, ctx->fcp_cmnd_dma);
  queuing_error: ;
#line 2884
  if ((unsigned int )tot_dsds != 0U) {
#line 2885
    scsi_dma_unmap(cmd);
  } else {

  }
#line 2887
  if ((unsigned long )sp->u.scmd.ctx != (unsigned long )((void *)0)) {
#line 2888
    mempool_free(sp->u.scmd.ctx, ha->ctx_mempool);
#line 2889
    sp->u.scmd.ctx = (void *)0;
  } else {

  }
#line 2891
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2893
  return (258);
}
}
#line 2897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla2x00_start_sp(srb_t *sp ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  void *pkt ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 2900
  ha = ((sp->fcport)->vha)->hw;
#line 2904
  rval = 258;
#line 2905
  tmp = spinlock_check(& ha->hardware_lock);
#line 2905
  flags = _raw_spin_lock_irqsave(tmp);
#line 2906
  pkt = qla2x00_alloc_iocbs((sp->fcport)->vha, sp);
#line 2907
  if ((unsigned long )pkt == (unsigned long )((void *)0)) {
#line 2908
    ql_log(1U, (sp->fcport)->vha, 28684, "qla2x00_alloc_iocbs failed.\n");
#line 2910
    goto done;
  } else {

  }
#line 2913
  rval = 0;
#line 2914
  switch ((int )sp->type) {
  case 1: ;
#line 2917
  if ((ha->device_type & 134217728U) != 0U) {
#line 2917
    qla24xx_login_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2918
    qla2x00_login_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2919
  goto ldv_61327;
  case 2: ;
#line 2922
  if ((ha->device_type & 134217728U) != 0U) {
#line 2922
    qla24xx_logout_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2923
    qla2x00_logout_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2924
  goto ldv_61327;
  case 3: ;
  case 4: 
#line 2927
  qla24xx_els_iocb(sp, (struct els_entry_24xx *)pkt);
#line 2928
  goto ldv_61327;
  case 5: ;
#line 2931
  if ((ha->device_type & 134217728U) != 0U) {
#line 2931
    qla24xx_ct_iocb(sp, (struct ct_entry_24xx *)pkt);
  } else {
#line 2932
    qla2x00_ct_iocb(sp, (ms_iocb_entry_t *)pkt);
  }
#line 2933
  goto ldv_61327;
  case 6: ;
#line 2936
  if ((ha->device_type & 134217728U) != 0U) {
#line 2936
    qla24xx_adisc_iocb(sp, (struct logio_entry_24xx *)pkt);
  } else {
#line 2937
    qla2x00_adisc_iocb(sp, (struct mbx_entry *)pkt);
  }
#line 2938
  goto ldv_61327;
  case 7: ;
#line 2941
  if ((ha->device_type & 131072U) != 0U) {
#line 2941
    qlafx00_tm_iocb(sp, (struct tsk_mgmt_entry_fx00 *)pkt);
  } else {
#line 2942
    qla24xx_tm_iocb(sp, (struct tsk_mgmt_entry *)pkt);
  }
#line 2943
  goto ldv_61327;
  case 10: ;
  case 11: 
#line 2946
  qlafx00_fxdisc_iocb(sp, (struct fxdisc_entry_fx00 *)pkt);
#line 2947
  goto ldv_61327;
  case 12: 
#line 2949
  qlafx00_abort_iocb(sp, (struct abort_iocb_entry_fx00 *)pkt);
#line 2950
  goto ldv_61327;
  default: ;
#line 2952
  goto ldv_61327;
  }
  ldv_61327: 
#line 2955
  __asm__  volatile   ("sfence": : : "memory");
#line 2956
  qla2x00_start_iocbs((sp->fcport)->vha, *(ha->req_q_map));
  done: 
#line 2958
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2959
  return (rval);
}
}
#line 2963 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
static void qla25xx_build_bidir_iocb(srb_t *sp , struct scsi_qla_host *vha , struct cmd_bidir *cmd_pkt ,
                                     uint32_t tot_dsds ) 
{ 
  uint16_t avail_dsds ;
  uint32_t *cur_dsd ;
  uint32_t req_data_len ;
  uint32_t rsp_data_len ;
  struct scatterlist *sg ;
  int index ;
  int entry_count ;
  struct fc_bsg_job *bsg_job ;
  unsigned long tmp ;
  dma_addr_t sle_dma ;
  cont_a64_entry_t *cont_pkt ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  dma_addr_t sle_dma___0 ;
  cont_a64_entry_t *cont_pkt___0 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;

  {
#line 2968
  req_data_len = 0U;
#line 2969
  rsp_data_len = 0U;
#line 2972
  entry_count = 1;
#line 2973
  bsg_job = sp->u.bsg_job;
#line 2976
  *((uint32_t *)(& cmd_pkt->entry_type)) = 117U;
#line 2983
  cmd_pkt->wr_dseg_count = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 2984
  cmd_pkt->rd_dseg_count = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 2985
  cmd_pkt->control_flags = 11U;
#line 2989
  rsp_data_len = bsg_job->request_payload.payload_len;
#line 2989
  req_data_len = rsp_data_len;
#line 2990
  cmd_pkt->wr_byte_count = req_data_len;
#line 2991
  cmd_pkt->rd_byte_count = rsp_data_len;
#line 2992
  tmp = qla2x00_get_async_timeout(vha);
#line 2992
  cmd_pkt->timeout = (unsigned int )((unsigned short )tmp) + 2U;
#line 2994
  vha->bidi_stats.transfer_bytes = vha->bidi_stats.transfer_bytes + (unsigned long long )req_data_len;
#line 2995
  vha->bidi_stats.io_count = vha->bidi_stats.io_count + 1ULL;
#line 2997
  vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )req_data_len;
#line 2998
  vha->qla_stats.output_requests = vha->qla_stats.output_requests + 1ULL;
#line 3003
  avail_dsds = 1U;
#line 3004
  cur_dsd = (uint32_t *)(& cmd_pkt->fcp_data_dseg_address);
#line 3006
  index = 0;
#line 3008
  index = 0;
#line 3008
  sg = bsg_job->request_payload.sg_list;
#line 3008
  goto ldv_61355;
  ldv_61354: ;
#line 3014
  if ((unsigned int )avail_dsds == 0U) {
#line 3018
    cont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 3019
    cur_dsd = (uint32_t *)(& cont_pkt->dseg_0_address);
#line 3020
    avail_dsds = 5U;
#line 3021
    entry_count = entry_count + 1;
  } else {

  }
#line 3023
  sle_dma = sg->dma_address;
#line 3024
  tmp___0 = cur_dsd;
#line 3024
  cur_dsd = cur_dsd + 1;
#line 3024
  *tmp___0 = (unsigned int )sle_dma;
#line 3025
  tmp___1 = cur_dsd;
#line 3025
  cur_dsd = cur_dsd + 1;
#line 3025
  *tmp___1 = (unsigned int )(sle_dma >> 32ULL);
#line 3026
  tmp___2 = cur_dsd;
#line 3026
  cur_dsd = cur_dsd + 1;
#line 3026
  *tmp___2 = sg->dma_length;
#line 3027
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 3008
  index = index + 1;
#line 3008
  sg = sg_next(sg);
  ldv_61355: ;
#line 3008
  if (bsg_job->request_payload.sg_cnt > index) {
#line 3010
    goto ldv_61354;
  } else {

  }
#line 3034
  index = 0;
#line 3034
  sg = bsg_job->reply_payload.sg_list;
#line 3034
  goto ldv_61360;
  ldv_61359: ;
#line 3040
  if ((unsigned int )avail_dsds == 0U) {
#line 3044
    cont_pkt___0 = qla2x00_prep_cont_type1_iocb(vha, vha->req);
#line 3045
    cur_dsd = (uint32_t *)(& cont_pkt___0->dseg_0_address);
#line 3046
    avail_dsds = 5U;
#line 3047
    entry_count = entry_count + 1;
  } else {

  }
#line 3049
  sle_dma___0 = sg->dma_address;
#line 3050
  tmp___3 = cur_dsd;
#line 3050
  cur_dsd = cur_dsd + 1;
#line 3050
  *tmp___3 = (unsigned int )sle_dma___0;
#line 3051
  tmp___4 = cur_dsd;
#line 3051
  cur_dsd = cur_dsd + 1;
#line 3051
  *tmp___4 = (unsigned int )(sle_dma___0 >> 32ULL);
#line 3052
  tmp___5 = cur_dsd;
#line 3052
  cur_dsd = cur_dsd + 1;
#line 3052
  *tmp___5 = sg->dma_length;
#line 3053
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 3034
  index = index + 1;
#line 3034
  sg = sg_next(sg);
  ldv_61360: ;
#line 3034
  if (bsg_job->reply_payload.sg_cnt > index) {
#line 3036
    goto ldv_61359;
  } else {

  }
#line 3056
  cmd_pkt->entry_count = (uint8_t )entry_count;
#line 3057
  return;
}
}
#line 3060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int qla2x00_start_bidir(srb_t *sp , struct scsi_qla_host *vha , uint32_t tot_dsds ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  uint32_t handle ;
  uint32_t index ;
  uint16_t req_cnt ;
  uint16_t cnt ;
  uint32_t *clr_ptr ;
  struct cmd_bidir *cmd_pkt ;
  struct rsp_que *rsp ;
  struct req_que *req ;
  int rval ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 3063
  ha = vha->hw;
#line 3070
  cmd_pkt = (struct cmd_bidir *)0;
#line 3073
  rval = 0;
#line 3075
  rval = 0;
#line 3077
  rsp = *(ha->rsp_q_map);
#line 3078
  req = vha->req;
#line 3081
  if ((unsigned int )vha->marker_needed != 0U) {
#line 3082
    tmp = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 3082
    if (tmp != 0) {
#line 3084
      return (11);
    } else {

    }
#line 3085
    vha->marker_needed = 0U;
  } else {

  }
#line 3089
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 3089
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3092
  handle = req->current_outstanding_cmd;
#line 3093
  index = 1U;
#line 3093
  goto ldv_61383;
  ldv_61382: 
#line 3094
  handle = handle + 1U;
#line 3095
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 3096
    handle = 1U;
  } else {

  }
#line 3097
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 3098
    goto ldv_61381;
  } else {

  }
#line 3093
  index = index + 1U;
  ldv_61383: ;
#line 3093
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 3095
    goto ldv_61382;
  } else {

  }
  ldv_61381: ;
#line 3101
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 3102
    rval = 2;
#line 3103
    goto queuing_error;
  } else {

  }
#line 3107
  req_cnt = qla24xx_calc_iocbs(vha, (int )((uint16_t )tot_dsds));
#line 3110
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 3111
    tmp___1 = __readl((void const volatile   *)req->req_q_out);
#line 3111
    cnt = (uint16_t )tmp___1;
#line 3113
    if ((int )req->ring_index < (int )cnt) {
#line 3114
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 3116
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
  } else {

  }
#line 3119
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 3120
    rval = 2;
#line 3121
    goto queuing_error;
  } else {

  }
#line 3124
  cmd_pkt = (struct cmd_bidir *)req->ring_ptr;
#line 3125
  cmd_pkt->handle = ((unsigned int )req->id << 16) | handle;
#line 3129
  clr_ptr = (uint32_t *)cmd_pkt + 2UL;
#line 3130
  memset((void *)clr_ptr, 0, 56UL);
#line 3133
  cmd_pkt->nport_handle = vha->self_login_loop_id;
#line 3134
  cmd_pkt->port_id[0] = vha->d_id.b.al_pa;
#line 3135
  cmd_pkt->port_id[1] = vha->d_id.b.area;
#line 3136
  cmd_pkt->port_id[2] = vha->d_id.b.domain;
#line 3138
  qla25xx_build_bidir_iocb(sp, vha, cmd_pkt, tot_dsds);
#line 3139
  cmd_pkt->entry_status = (unsigned char )rsp->id;
#line 3141
  req->current_outstanding_cmd = handle;
#line 3142
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 3143
  sp->handle = handle;
#line 3144
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 3147
  __asm__  volatile   ("sfence": : : "memory");
#line 3148
  qla2x00_start_iocbs(vha, req);
  queuing_error: 
#line 3150
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3151
  return (rval);
}
}
#line 3155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void choose_timer_5(struct timer_list *timer ) 
{ 


  {
#line 3156
  LDV_IN_INTERRUPT = 2;
#line 3157
  (*(timer->function))(timer->data);
#line 3158
  LDV_IN_INTERRUPT = 1;
#line 3159
  ldv_timer_state_5 = 2;
#line 3160
  return;
}
}
#line 3163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 3164
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_5) {
#line 3165
    ldv_timer_state_5 = 0;
#line 3166
    return;
  } else {

  }
#line 3168
  return;
}
}
#line 3171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3171
  if ((unsigned long )ldv_timer_list_5 == (unsigned long )timer) {
#line 3172
    if (ldv_timer_state_5 == 2 || pending_flag != 0) {
#line 3173
      ldv_timer_list_5 = timer;
#line 3174
      ldv_timer_list_5->data = data;
#line 3175
      ldv_timer_state_5 = 1;
    } else {

    }
#line 3177
    return;
  } else {

  }
#line 3179
  reg_timer_5(timer);
#line 3180
  ldv_timer_list_5->data = data;
#line 3181
  return;
}
}
#line 3184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int reg_timer_5(struct timer_list *timer ) 
{ 


  {
#line 3185
  ldv_timer_list_5 = timer;
#line 3186
  ldv_timer_state_5 = 1;
#line 3187
  return (0);
}
}
#line 3189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int ldv_del_timer_27(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 3193
  tmp = del_timer(ldv_func_arg1);
#line 3193
  ldv_func_res = tmp;
#line 3195
  disable_suitable_timer_7(ldv_func_arg1);
#line 3197
  return (ldv_func_res);
}
}
#line 3200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_iocb.o.c.prepared"
int ldv_scsi_add_host_with_dma_28(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 3204
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 3204
  ldv_func_res = tmp;
#line 3206
  if (ldv_func_res == 0) {
#line 3207
    ldv_state_variable_72 = 1;
#line 3207
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 3211
  return (ldv_func_res);
}
}
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 316 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 318
  _raw_spin_lock_irq(& lock->ldv_6105.rlock);
#line 319
  return;
}
}
#line 341 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 343
  _raw_spin_unlock_irq(& lock->ldv_6105.rlock);
#line 344
  return;
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_31(struct timer_list *ldv_func_arg1 ) ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void choose_timer_6(struct timer_list *timer ) ;
#line 236
int reg_timer_6(struct timer_list *timer ) ;
#line 269
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 270
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 1005 "include/linux/device.h"
extern int dev_printk(char const   * , struct device  const  * , char const   *  , ...) ;
#line 1188 "include/linux/pci.h"
extern int pci_enable_msi_block(struct pci_dev * , unsigned int  ) ;
#line 1191
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1193
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1195
extern void pci_disable_msix(struct pci_dev * ) ;
#line 124 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 129 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 132
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 132
  return (tmp);
}
}
#line 143
extern void free_irq(unsigned int  , void * ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_32(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 176 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 178
  cmd->sdb.resid = resid;
#line 179
  return;
}
}
#line 302 "include/scsi/scsi_cmnd.h"
__inline static void set_host_byte(struct scsi_cmnd *cmd , char status ) 
{ 


  {
#line 304
  cmd->result = (int )(((unsigned int )cmd->result & 4278255615U) | (unsigned int )((int )status << 16));
#line 305
  return;
}
}
#line 307 "include/scsi/scsi_cmnd.h"
__inline static void set_driver_byte(struct scsi_cmnd *cmd , char status ) 
{ 


  {
#line 309
  cmd->result = (cmd->result & 16777215) | ((int )status << 24);
#line 310
  return;
}
}
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___1[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_alert_all_vps(struct rsp_que *rsp , uint16_t *mb ) ;
#line 198
void qla2x00_async_event(scsi_qla_host_t *vha , struct rsp_que *rsp , uint16_t *mb ) ;
#line 433
srb_t *qla2x00_get_sp_from_handle(scsi_qla_host_t *vha , char const   *func , struct req_que *req ,
                                  void *iocb ) ;
#line 436
void qla2x00_process_completed_request(struct scsi_qla_host *vha , struct req_que *req ,
                                       uint32_t index ) ;
#line 562
int qla25xx_request_irq(struct rsp_que *rsp ) ;
#line 653
irqreturn_t qla82xx_msix_default(int irq , void *dev_id ) ;
#line 654
irqreturn_t qla82xx_msix_rsp_q(int irq , void *dev_id ) ;
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_do_host_ramp_up(scsi_qla_host_t *vha ) 
{ 


  {
#line 266
  if ((vha->hw)->cfg_lun_q_depth >= ql2xmaxqdepth) {
#line 267
    return;
  } else {

  }
#line 270
  if ((long )(((unsigned long )jiffies - (vha->hw)->host_last_rampdown_time) - 15000UL) < 0L) {
#line 272
    return;
  } else {

  }
#line 275
  if ((long )(((unsigned long )jiffies - (vha->hw)->host_last_rampup_time) - 7500UL) < 0L) {
#line 277
    return;
  } else {

  }
#line 279
  set_bit(23L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 280
  return;
}
}
#line 283 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_handle_mbx_completion(struct qla_hw_data *ha , int status ) 
{ 
  int tmp ;

  {
#line 285
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& ha->mbx_cmd_flags));
#line 285
  if ((tmp != 0 && status & 1) && *((unsigned long *)ha + 2UL) != 0UL) {
#line 287
    set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 288
    clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 289
    complete(& ha->mbx_intr_comp);
  } else {

  }
#line 291
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
int ql2x_ini_mode ;
#line 977
void qlt_response_pkt_all_vps(struct scsi_qla_host *vha , response_t *pkt ) ;
#line 983
void qlt_async_event(uint16_t code , struct scsi_qla_host *vha , uint16_t *mailbox ) ;
#line 998
int qlt_24xx_process_response_error(struct scsi_qla_host *vha , struct sts_entry_24xx *pkt ) ;
#line 1007
irqreturn_t qla83xx_msix_atio_q(int irq , void *dev_id ) ;
#line 61 "include/scsi/scsi_eh.h"
extern void scsi_build_sense_buffer(int  , u8 * , u8  , u8  , u8  ) ;
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) ;
#line 316
static void qla2x00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) ;
#line 317
static void qla2x00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) ;
#line 318
static void qla2x00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , sts_entry_t *pkt ) ;
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
irqreturn_t qla2100_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int status ;
  unsigned long iter ;
  uint16_t hccr ;
  uint16_t mb[4U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 343
  rsp = (struct rsp_que *)dev_id;
#line 344
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 345
    ql_log(2U, (scsi_qla_host_t *)0, 20573, "%s: NULL response queue pointer.\n",
           "qla2100_intr_handler");
#line 347
    return (0);
  } else {

  }
#line 350
  ha = rsp->hw;
#line 351
  reg = & (ha->iobase)->isp;
#line 352
  status = 0;
#line 354
  tmp = spinlock_check(& ha->hardware_lock);
#line 354
  flags = _raw_spin_lock_irqsave(tmp);
#line 355
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 355
  vha = (scsi_qla_host_t *)tmp___0;
#line 356
  iter = 50UL;
#line 356
  goto ldv_60862;
  ldv_60861: 
#line 357
  hccr = readw((void const volatile   *)(& reg->hccr));
#line 358
  if (((int )hccr & 32) != 0) {
#line 359
    tmp___1 = pci_channel_offline(ha->pdev);
#line 359
    if (tmp___1 != 0) {
#line 360
      goto ldv_60860;
    } else {

    }
#line 367
    writew(4096, (void volatile   *)(& reg->hccr));
#line 368
    readw((void const volatile   *)(& reg->hccr));
#line 370
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 371
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 372
    goto ldv_60860;
  } else {
#line 373
    tmp___2 = readw((void const volatile   *)(& reg->istatus));
#line 373
    if (((int )tmp___2 & 8) == 0) {
#line 374
      goto ldv_60860;
    } else {

    }
  }
#line 376
  tmp___3 = readw((void const volatile   *)(& reg->semaphore));
#line 376
  if ((int )tmp___3 & 1) {
#line 377
    writew(28672, (void volatile   *)(& reg->hccr));
#line 378
    readw((void const volatile   *)(& reg->hccr));
#line 381
    mb[0] = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 382
    if ((unsigned int )mb[0] > 16383U && (int )((short )mb[0]) >= 0) {
#line 383
      qla2x00_mbx_completion(vha, (int )mb[0]);
#line 384
      status = status | 1;
    } else
#line 385
    if ((int )((short )mb[0]) < 0 && (unsigned int )mb[0] <= 49151U) {
#line 386
      mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 387
      mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 388
      mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 389
      qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
    } else {
#line 392
      ql_dbg(33554432U, vha, 20517, "Unrecognized interrupt type (%d).\n", (int )mb[0]);
    }
#line 397
    writew(0, (void volatile   *)(& reg->semaphore));
#line 398
    readw((void const volatile   *)(& reg->semaphore));
  } else {
#line 400
    qla2x00_process_response_queue(rsp);
#line 402
    writew(28672, (void volatile   *)(& reg->hccr));
#line 403
    readw((void const volatile   *)(& reg->hccr));
  }
  ldv_60862: 
#line 356
  tmp___4 = iter;
#line 356
  iter = iter - 1UL;
#line 356
  if (tmp___4 != 0UL) {
#line 358
    goto ldv_60861;
  } else {

  }
  ldv_60860: 
#line 406
  qla2x00_handle_mbx_completion(ha, status);
#line 407
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 409
  return (1);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
irqreturn_t qla2300_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct device_reg_2xxx *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t hccr ;
  uint16_t mb[4U] ;
  struct rsp_que *rsp ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 435
  rsp = (struct rsp_que *)dev_id;
#line 436
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 437
    ql_log(2U, (scsi_qla_host_t *)0, 20568, "%s: NULL response queue pointer.\n",
           "qla2300_intr_handler");
#line 439
    return (0);
  } else {

  }
#line 442
  ha = rsp->hw;
#line 443
  reg = & (ha->iobase)->isp;
#line 444
  status = 0;
#line 446
  tmp = spinlock_check(& ha->hardware_lock);
#line 446
  flags = _raw_spin_lock_irqsave(tmp);
#line 447
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 447
  vha = (scsi_qla_host_t *)tmp___0;
#line 448
  iter = 50UL;
#line 448
  goto ldv_60893;
  ldv_60892: 
#line 449
  stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 450
  if ((stat & 256U) != 0U) {
#line 451
    tmp___1 = pci_channel_offline(ha->pdev);
#line 451
    tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 451
    if (tmp___2 != 0L) {
#line 452
      goto ldv_60881;
    } else {

    }
#line 454
    hccr = readw((void const volatile   *)(& reg->hccr));
#line 455
    if (((int )hccr & 43264) != 0) {
#line 456
      ql_log(1U, vha, 20518, "Parity error -- HCCR=%x, Dumping firmware.\n", (int )hccr);
    } else {
#line 460
      ql_log(1U, vha, 20519, "RISC paused -- HCCR=%x, Dumping firmware.\n", (int )hccr);
    }
#line 469
    writew(4096, (void volatile   *)(& reg->hccr));
#line 470
    readw((void const volatile   *)(& reg->hccr));
#line 472
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 473
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 474
    goto ldv_60881;
  } else
#line 475
  if ((stat & 32768U) == 0U) {
#line 476
    goto ldv_60881;
  } else {

  }
#line 478
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 483
  qla2x00_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 484
  status = status | 1;
#line 487
  writew(0, (void volatile   *)(& reg->semaphore));
#line 488
  goto ldv_60886;
  case 18U: 
#line 490
  mb[0] = (unsigned short )(stat >> 16);
#line 491
  mb[1] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 492
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 493
  mb[3] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 494
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 495
  goto ldv_60886;
  case 19U: 
#line 497
  qla2x00_process_response_queue(rsp);
#line 498
  goto ldv_60886;
  case 21U: 
#line 500
  mb[0] = 32817U;
#line 501
  mb[1] = (unsigned short )(stat >> 16);
#line 502
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 503
  goto ldv_60886;
  case 22U: 
#line 505
  mb[0] = 32800U;
#line 506
  mb[1] = (unsigned short )(stat >> 16);
#line 507
  mb[2] = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 508
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 509
  goto ldv_60886;
  default: 
#line 511
  ql_dbg(33554432U, vha, 20520, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 513
  goto ldv_60886;
  }
  ldv_60886: 
#line 515
  writew(28672, (void volatile   *)(& reg->hccr));
#line 516
  __readw((void const volatile   *)(& reg->hccr));
  ldv_60893: 
#line 448
  tmp___3 = iter;
#line 448
  iter = iter - 1UL;
#line 448
  if (tmp___3 != 0UL) {
#line 450
    goto ldv_60892;
  } else {

  }
  ldv_60881: 
#line 518
  qla2x00_handle_mbx_completion(ha, status);
#line 519
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 521
  return (1);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint32_t mboxes ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;

  {
#line 535
  ha = vha->hw;
#line 536
  reg = & (ha->iobase)->isp;
#line 539
  mboxes = (uint32_t )((1 << (int )ha->mbx_count) + -1);
#line 540
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 541
    ql_dbg(33554432U, vha, 20481, "MBX pointer OLD_ERROR.\n");
  } else {
#line 543
    mboxes = (ha->mcp)->in_mb;
  }
#line 546
  ha->flags.mbox_int = 1U;
#line 547
  ha->mailbox_out[0] = mb0;
#line 548
  mboxes = mboxes >> 1;
#line 549
  wptr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 + 1UL : & reg->u.isp2300.mailbox0 + 1UL;
#line 551
  cnt = 1U;
#line 551
  goto ldv_60904;
  ldv_60903: ;
#line 552
  if ((ha->device_type & 2U) != 0U && (unsigned int )cnt == 8U) {
#line 553
    wptr = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u_end.isp2200.mailbox8 : & reg->u.isp2300.mailbox0 + 8UL;
  } else {

  }
#line 554
  if (((unsigned int )cnt == 4U || (unsigned int )cnt == 5U) && (int )mboxes & 1) {
#line 555
    ha->mailbox_out[(int )cnt] = qla2x00_debounce_register___0((uint16_t volatile   *)wptr);
  } else
#line 556
  if ((int )mboxes & 1) {
#line 557
    ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
  } else {

  }
#line 559
  wptr = wptr + 1;
#line 560
  mboxes = mboxes >> 1;
#line 551
  cnt = (uint16_t )((int )cnt + 1);
  ldv_60904: ;
#line 551
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 553
    goto ldv_60903;
  } else {

  }

#line 558
  return;
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla81xx_idc_event(scsi_qla_host_t *vha , uint16_t aen , uint16_t descr ) 
{ 
  char *event[3U] ;
  int rval ;
  struct device_reg_24xx *reg24 ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t timeout ;
  uint16_t mb[7U] ;

  {
#line 567
  event[0] = (char *)"Complete";
#line 567
  event[1] = (char *)"Request Notification";
#line 567
  event[2] = (char *)"Time Extension";
#line 570
  reg24 = & ((vha->hw)->iobase)->isp24;
#line 575
  wptr = & reg24->mailbox1;
#line 576
  cnt = 0U;
#line 576
  goto ldv_60919;
  ldv_60918: 
#line 577
  mb[(int )cnt] = readw((void const volatile   *)wptr);
#line 576
  cnt = (uint16_t )((int )cnt + 1);
#line 576
  wptr = wptr + 1;
  ldv_60919: ;
#line 576
  if ((unsigned int )cnt <= 6U) {
#line 578
    goto ldv_60918;
  } else {

  }
#line 579
  ql_dbg(33554432U, vha, 20513, "Inter-Driver Communication %s -- %04x %04x %04x %04x %04x %04x %04x.\n",
         event[(int )aen & 255], (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[3],
         (int )mb[4], (int )mb[5], (int )mb[6]);
#line 584
  switch ((int )aen) {
  case 33024: ;
#line 587
  if ((int )((short )mb[1]) < 0) {
#line 588
    (vha->hw)->flags.idc_compl_status = 1U;
#line 589
    if ((vha->hw)->notify_dcbx_comp != 0) {
#line 590
      complete(& (vha->hw)->dcbx_comp);
    } else {

    }
  } else {

  }
#line 592
  goto ldv_60922;
  case 33025: 
#line 596
  timeout = (unsigned int )((uint16_t )((int )descr >> 8)) & 15U;
#line 597
  ql_dbg(33554432U, vha, 20514, "%lu Inter-Driver Communication %s -- ACK timeout=%d.\n",
         vha->host_no, event[(int )aen & 255], (int )timeout);
#line 601
  if ((unsigned int )timeout == 0U) {
#line 602
    return;
  } else {

  }
#line 603
  rval = qla2x00_post_idc_ack_work(vha, (uint16_t *)(& mb));
#line 604
  if (rval != 0) {
#line 605
    ql_log(1U, vha, 20515, "IDC failed to post ACK.\n");
  } else {

  }
#line 607
  goto ldv_60922;
  case 33026: 
#line 609
  (vha->hw)->idc_extend_tmo = (uint32_t )descr;
#line 610
  ql_dbg(33554432U, vha, 20615, "%lu Inter-Driver Communication %s -- Extend timeout by=%d.\n",
         vha->host_no, event[(int )aen & 255], (vha->hw)->idc_extend_tmo);
#line 614
  goto ldv_60922;
  }
  ldv_60922: ;
#line 617
  return;
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
char const   *qla2x00_get_link_speed_str(struct qla_hw_data *ha , uint16_t speed ) 
{ 
  char const   *link_speeds[7U] ;

  {
#line 622
  link_speeds[0] = "1";
#line 622
  link_speeds[1] = "2";
#line 622
  link_speeds[2] = "?";
#line 622
  link_speeds[3] = "4";
#line 622
  link_speeds[4] = "8";
#line 622
  link_speeds[5] = "16";
#line 622
  link_speeds[6] = "10";
#line 626
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 627
    return (link_speeds[0]);
  } else
#line 628
  if ((unsigned int )speed == 19U) {
#line 629
    return (link_speeds[6]);
  } else
#line 630
  if ((unsigned int )speed <= 5U) {
#line 631
    return (link_speeds[(int )speed]);
  } else {
#line 633
    return (link_speeds[2]);
  }
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla83xx_handle_8200_aen(scsi_qla_host_t *vha , uint16_t *mb ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t protocol_engine_id ;
  uint32_t fw_err_code ;
  uint32_t err_level ;
  uint16_t peg_fw_state ;
  uint16_t nw_interface_link_up ;
  uint16_t nw_interface_signal_detect ;
  uint16_t sfp_status ;
  uint16_t htbt_counter ;
  uint16_t htbt_monitor_enable ;
  uint16_t sfp_additonal_info ;
  uint16_t sfp_multirate ;
  uint16_t sfp_tx_fault ;
  uint16_t link_speed ;
  uint16_t dcbx_status ;

  {
#line 639
  ha = vha->hw;
#line 652
  ql_dbg(33554432U, vha, 20587, "AEN Code: mb[0] = 0x%x AEN reason: mb[1] = 0x%x PH-status1: mb[2] = 0x%x PH-status1: mb[6] = 0x%x.\n",
         (int )*mb, (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 6UL));
#line 655
  ql_dbg(33554432U, vha, 20588, "PH-status2: mb[3] = 0x%x PH-status2: mb[7] = 0x%x Device-State: mb[4] = 0x%x Drv-Presence: mb[5] = 0x%x.\n",
         (int )*(mb + 3UL), (int )*(mb + 7UL), (int )*(mb + 4UL), (int )*(mb + 5UL));
#line 659
  if (((int )*(mb + 1UL) & 14) != 0) {
#line 661
    ha->flags.nic_core_hung = 1U;
#line 662
    ql_log(1U, vha, 20576, "83XX: F/W Error Reported: Check if reset required.\n");
#line 665
    if (((int )*(mb + 1UL) & 2) != 0) {
#line 681
      protocol_engine_id = (uint32_t )*(mb + 2UL) & 255U;
#line 682
      fw_err_code = (uint32_t )(((int )*(mb + 2UL) >> 8) | (((int )*(mb + 6UL) & 8191) << 8));
#line 684
      err_level = (uint32_t )((int )*(mb + 6UL) >> 13);
#line 685
      ql_log(1U, vha, 20577, "PegHalt Status-1 Register: protocol_engine_id=0x%x fw_err_code=0x%x err_level=0x%x.\n",
             protocol_engine_id, fw_err_code, err_level);
#line 689
      ql_log(1U, vha, 20578, "PegHalt Status-2 Register: 0x%x%x.\n", (int )*(mb + 7UL),
             (int )*(mb + 3UL));
#line 691
      if (err_level == 1U) {
#line 692
        ql_log(1U, vha, 20579, "Not a fatal error, f/w has recovered iteself.\n");
      } else
#line 695
      if (err_level == 2U) {
#line 696
        ql_log(0U, vha, 20580, "Recoverable Fatal error: Chip reset required.\n");
#line 699
        qla83xx_schedule_work(vha, 1);
      } else
#line 701
      if (err_level == 4U) {
#line 702
        ql_log(0U, vha, 20581, "Unrecoverable Fatal error: Set FAILED state, reboot required.\n");
#line 705
        qla83xx_schedule_work(vha, 3);
      } else {

      }
    } else {

    }
#line 710
    if (((int )*(mb + 1UL) & 4) != 0) {
#line 748
      peg_fw_state = (unsigned int )*(mb + 2UL) & 255U;
#line 749
      nw_interface_link_up = (uint16_t )(((int )*(mb + 2UL) & 256) >> 8);
#line 750
      nw_interface_signal_detect = (uint16_t )(((int )*(mb + 2UL) & 512) >> 9);
#line 751
      sfp_status = (uint16_t )(((int )*(mb + 2UL) & 3072) >> 10);
#line 752
      htbt_counter = (uint16_t )(((int )*(mb + 2UL) & 28672) >> 12);
#line 753
      htbt_monitor_enable = (int )*(mb + 2UL) >> 15;
#line 754
      sfp_additonal_info = (unsigned int )*(mb + 6UL) & 3U;
#line 755
      sfp_multirate = (uint16_t )(((int )*(mb + 6UL) & 4) >> 2);
#line 756
      sfp_tx_fault = (uint16_t )(((int )*(mb + 6UL) & 8) >> 3);
#line 757
      link_speed = (uint16_t )(((int )*(mb + 6UL) & 112) >> 4);
#line 758
      dcbx_status = (uint16_t )(((int )*(mb + 6UL) & 28672) >> 12);
#line 760
      ql_log(1U, vha, 20582, "Peg-to-Fc Status Register:\npeg_fw_state=0x%x, nw_interface_link_up=0x%x, nw_interface_signal_detect=0x%x\nsfp_statis=0x%x.\n ",
             (int )peg_fw_state, (int )nw_interface_link_up, (int )nw_interface_signal_detect,
             (int )sfp_status);
#line 767
      ql_log(1U, vha, 20583, "htbt_counter=0x%x, htbt_monitor_enable=0x%x, sfp_additonal_info=0x%x, sfp_multirate=0x%x.\n ",
             (int )htbt_counter, (int )htbt_monitor_enable, (int )sfp_additonal_info,
             (int )sfp_multirate);
#line 772
      ql_log(1U, vha, 20584, "sfp_tx_fault=0x%x, link_state=0x%x, dcbx_status=0x%x.\n",
             (int )sfp_tx_fault, (int )link_speed, (int )dcbx_status);
#line 777
      qla83xx_schedule_work(vha, 1);
    } else {

    }
#line 780
    if (((int )*(mb + 1UL) & 8) != 0) {
#line 781
      ql_log(1U, vha, 20585, "Heartbeat Failure encountered, chip reset required.\n");
#line 785
      qla83xx_schedule_work(vha, 1);
    } else {

    }
  } else {

  }
#line 789
  if ((int )*(mb + 1UL) & 1) {
#line 790
    ql_log(2U, vha, 20586, "IDC Device-State changed = 0x%x.\n", (int )*(mb + 4UL));
#line 792
    if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 793
      return;
    } else {

    }
#line 794
    qla83xx_schedule_work(vha, 33280);
  } else {

  }
#line 796
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int qla2x00_is_a_vp_did(scsi_qla_host_t *vha , uint32_t rscn_entry ) 
{ 
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  uint32_t vp_did ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 801
  ha = vha->hw;
#line 805
  ret = 0;
#line 807
  if ((unsigned int )ha->num_vhosts == 0U) {
#line 808
    return (ret);
  } else {

  }
#line 810
  tmp = spinlock_check(& ha->vport_slock);
#line 810
  flags = _raw_spin_lock_irqsave(tmp);
#line 811
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 811
  vp = (scsi_qla_host_t *)__mptr;
#line 811
  goto ldv_60967;
  ldv_60966: 
#line 812
  vp_did = vp->d_id.b24;
#line 813
  if (vp_did == rscn_entry) {
#line 814
    ret = 1;
#line 815
    goto ldv_60965;
  } else {

  }
#line 811
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 811
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_60967: ;
#line 811
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 813
    goto ldv_60966;
  } else {

  }
  ldv_60965: 
#line 818
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 820
  return (ret);
}
}
#line 829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void qla2x00_async_event(scsi_qla_host_t *vha , struct rsp_que *rsp , uint16_t *mb ) 
{ 
  uint16_t handle_cnt ;
  uint16_t cnt ;
  uint16_t mbx ;
  uint32_t handles[5U] ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  struct device_reg_82xx *reg82 ;
  uint32_t rscn_entry ;
  uint32_t host_pid ;
  unsigned long flags ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  bool tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  raw_spinlock_t *tmp___22 ;
  int tmp___23 ;

  {
#line 834
  ha = vha->hw;
#line 835
  reg = & (ha->iobase)->isp;
#line 836
  reg24 = & (ha->iobase)->isp24;
#line 837
  reg82 = & (ha->iobase)->isp82;
#line 842
  handle_cnt = 0U;
#line 843
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 844
    goto skip_rio;
  } else {

  }
#line 845
  switch ((int )*mb) {
  case 32800: 
#line 847
  handles[0] = (unsigned int )(((int )*(mb + 2UL) << 16) | (int )*(mb + 1UL));
#line 848
  handle_cnt = 1U;
#line 849
  goto ldv_60986;
  case 32817: 
#line 851
  handles[0] = (uint32_t )*(mb + 1UL);
#line 852
  handle_cnt = 1U;
#line 853
  *mb = 32800U;
#line 854
  goto ldv_60986;
  case 32818: 
#line 856
  handles[0] = (uint32_t )*(mb + 1UL);
#line 857
  handles[1] = (uint32_t )*(mb + 2UL);
#line 858
  handle_cnt = 2U;
#line 859
  *mb = 32800U;
#line 860
  goto ldv_60986;
  case 32819: 
#line 862
  handles[0] = (uint32_t )*(mb + 1UL);
#line 863
  handles[1] = (uint32_t )*(mb + 2UL);
#line 864
  handles[2] = (uint32_t )*(mb + 3UL);
#line 865
  handle_cnt = 3U;
#line 866
  *mb = 32800U;
#line 867
  goto ldv_60986;
  case 32820: 
#line 869
  handles[0] = (uint32_t )*(mb + 1UL);
#line 870
  handles[1] = (uint32_t )*(mb + 2UL);
#line 871
  handles[2] = (uint32_t )*(mb + 3UL);
#line 872
  tmp = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 872
  handles[3] = (unsigned int )tmp;
#line 873
  handle_cnt = 4U;
#line 874
  *mb = 32800U;
#line 875
  goto ldv_60986;
  case 32821: 
#line 877
  handles[0] = (uint32_t )*(mb + 1UL);
#line 878
  handles[1] = (uint32_t )*(mb + 2UL);
#line 879
  handles[2] = (uint32_t )*(mb + 3UL);
#line 880
  tmp___0 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 880
  handles[3] = (unsigned int )tmp___0;
#line 881
  tmp___1 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 881
  handles[4] = (unsigned int )tmp___1;
#line 882
  handle_cnt = 5U;
#line 883
  *mb = 32800U;
#line 884
  goto ldv_60986;
  case 32834: 
#line 886
  handles[0] = (unsigned int )(((int )*(mb + 2UL) << 16) | (int )*(mb + 1UL));
#line 887
  tmp___2 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 887
  tmp___3 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 887
  handles[1] = (unsigned int )((int )tmp___2 << 16) | (unsigned int )tmp___3;
#line 890
  handle_cnt = 2U;
#line 891
  *mb = 32800U;
#line 892
  goto ldv_60986;
  default: ;
#line 894
  goto ldv_60986;
  }
  ldv_60986: ;
  skip_rio: ;
#line 897
  switch ((int )*mb) {
  case 32800: ;
#line 899
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 900
    goto ldv_60995;
  } else {

  }
#line 902
  cnt = 0U;
#line 902
  goto ldv_60997;
  ldv_60996: 
#line 903
  qla2x00_process_completed_request(vha, rsp->req, handles[(int )cnt]);
#line 902
  cnt = (uint16_t )((int )cnt + 1);
  ldv_60997: ;
#line 902
  if ((int )cnt < (int )handle_cnt) {
#line 904
    goto ldv_60996;
  } else {

  }

#line 905
  goto ldv_60995;
  case 32769: 
#line 908
  ql_dbg(33554432U, vha, 20482, "Asynchronous RESET.\n");
#line 911
  set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 912
  goto ldv_60995;
  case 32770: ;
#line 915
  if ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 915
    tmp___4 = readw((void const volatile   *)(& reg24->mailbox7));
#line 915
    mbx = tmp___4;
  } else {
#line 915
    mbx = 0U;
  }
#line 917
  ql_log(1U, vha, 20483, "ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh mbx7=%xh.\n",
         (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL), (int )mbx);
#line 921
  (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 923
  if ((ha->device_type & 134217728U) != 0U) {
#line 924
    if ((unsigned int )*(mb + 1UL) == 0U && (unsigned int )*(mb + 2UL) == 0U) {
#line 925
      ql_log(0U, vha, 20484, "Unrecoverable Hardware Error: adapter marked OFFLINE!\n");
#line 928
      vha->flags.online = 0U;
#line 929
      vha->device_flags = vha->device_flags | 32U;
    } else {
#line 932
      if (((int )mbx & 8) != 0 && *((unsigned long *)ha + 2UL) != 0UL) {
#line 933
        set_bit(19L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {

      }
#line 936
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
  } else
#line 938
  if ((unsigned int )*(mb + 1UL) == 0U) {
#line 939
    ql_log(0U, vha, 20485, "Unrecoverable Hardware Error: adapter marked OFFLINE!\n");
#line 942
    vha->flags.online = 0U;
#line 943
    vha->device_flags = vha->device_flags | 32U;
  } else {
#line 945
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 946
  goto ldv_60995;
  case 32771: 
#line 949
  ql_log(1U, vha, 20486, "ISP Request Transfer Error (%x).\n", (int )*(mb + 1UL));
#line 952
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 953
  goto ldv_60995;
  case 32772: 
#line 956
  ql_log(1U, vha, 20487, "ISP Response Transfer Error.\n");
#line 959
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 960
  goto ldv_60995;
  case 32773: 
#line 963
  ql_dbg(33554432U, vha, 20488, "Asynchronous WAKEUP_THRES.\n");
#line 966
  goto ldv_60995;
  case 32784: 
#line 968
  ql_dbg(33554432U, vha, 20489, "LIP occurred (%x).\n", (int )*(mb + 1UL));
#line 971
  tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 971
  if (tmp___5 != 2) {
#line 972
    atomic_set(& vha->loop_state, 2);
#line 973
    atomic_set(& vha->loop_down_timer, 255);
#line 974
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 977
  if ((unsigned int )vha->vp_idx != 0U) {
#line 978
    atomic_set(& vha->vp_state, 2);
#line 979
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 982
  set_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 983
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 985
  vha->flags.management_server_logged_in = 0U;
#line 986
  qla2x00_post_aen_work(vha, 1, (u32 )*(mb + 1UL));
#line 987
  goto ldv_60995;
  case 32785: ;
#line 990
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 991
    ha->link_data_rate = 0U;
  } else {
#line 993
    ha->link_data_rate = *(mb + 1UL);
  }
#line 995
  tmp___6 = qla2x00_get_link_speed_str(ha, (int )ha->link_data_rate);
#line 995
  ql_dbg(33554432U, vha, 20490, "LOOP UP detected (%s Gbps).\n", tmp___6);
#line 999
  vha->flags.management_server_logged_in = 0U;
#line 1000
  qla2x00_post_aen_work(vha, 2, (u32 )ha->link_data_rate);
#line 1001
  goto ldv_60995;
  case 32786: ;
#line 1004
  if ((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 1004
    tmp___7 = readw((void const volatile   *)(& reg24->mailbox4));
#line 1004
    mbx = tmp___7;
  } else {
#line 1004
    mbx = 0U;
  }
#line 1006
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1006
    tmp___8 = readw((void const volatile   *)(& reg82->mailbox_out) + 4U);
#line 1006
    mbx = tmp___8;
  } else {
#line 1006
    mbx = mbx;
  }
#line 1008
  ql_dbg(33554432U, vha, 20491, "LOOP DOWN detected (%x %x %x %x).\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL), (int )mbx);
#line 1012
  tmp___9 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1012
  if (tmp___9 != 2) {
#line 1013
    atomic_set(& vha->loop_state, 2);
#line 1014
    atomic_set(& vha->loop_down_timer, 255);
#line 1015
    vha->device_flags = vha->device_flags | 2U;
#line 1016
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 1019
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1020
    atomic_set(& vha->vp_state, 2);
#line 1021
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 1024
  vha->flags.management_server_logged_in = 0U;
#line 1025
  ha->link_data_rate = 65535U;
#line 1026
  qla2x00_post_aen_work(vha, 3, 0U);
#line 1027
  goto ldv_60995;
  case 32787: 
#line 1030
  ql_dbg(33554432U, vha, 20492, "LIP reset occurred (%x).\n", (int )*(mb + 1UL));
#line 1033
  tmp___10 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1033
  if (tmp___10 != 2) {
#line 1034
    atomic_set(& vha->loop_state, 2);
#line 1035
    atomic_set(& vha->loop_down_timer, 255);
#line 1036
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 1039
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1040
    atomic_set(& vha->vp_state, 2);
#line 1041
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 1044
  set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1046
  ha->operating_mode = 0U;
#line 1047
  vha->flags.management_server_logged_in = 0U;
#line 1048
  qla2x00_post_aen_work(vha, 4, (u32 )*(mb + 1UL));
#line 1049
  goto ldv_60995;
  case 32816: ;
#line 1053
  if ((int )ha->device_type & 1) {
#line 1054
    goto ldv_60995;
  } else {

  }
#line 1056
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1057
    ql_dbg(33554432U, vha, 20493, "DCBX Completed -- %04x %04x %04x.\n", (int )*(mb + 1UL),
           (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1060
    if (ha->notify_dcbx_comp != 0) {
#line 1061
      complete(& ha->dcbx_comp);
    } else {

    }
  } else {
#line 1064
    ql_dbg(33554432U, vha, 20494, "Asynchronous P2P MODE received.\n");
  }
#line 1071
  tmp___12 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1071
  if (tmp___12 != 2) {
#line 1072
    atomic_set(& vha->loop_state, 2);
#line 1073
    tmp___11 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1073
    if (tmp___11 == 0) {
#line 1074
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
#line 1076
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 1079
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1080
    atomic_set(& vha->vp_state, 2);
#line 1081
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 1084
  tmp___13 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1084
  if (tmp___13 == 0) {
#line 1085
    set_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 1087
  set_bit(9L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1088
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1090
  ha->flags.gpsc_supported = 1U;
#line 1091
  vha->flags.management_server_logged_in = 0U;
#line 1092
  goto ldv_60995;
  case 32822: ;
#line 1095
  if ((int )ha->device_type & 1) {
#line 1096
    goto ldv_60995;
  } else {

  }
#line 1098
  ql_dbg(33554432U, vha, 20495, "Configuration change detected: value=%x.\n", (int )*(mb + 1UL));
#line 1101
  tmp___15 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1101
  if (tmp___15 != 2) {
#line 1102
    atomic_set(& vha->loop_state, 2);
#line 1103
    tmp___14 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1103
    if (tmp___14 == 0) {
#line 1104
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
#line 1106
    qla2x00_mark_all_devices_lost(vha, 1);
  } else {

  }
#line 1109
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1110
    atomic_set(& vha->vp_state, 2);
#line 1111
    fc_vport_set_state(vha->fc_vport, 9);
  } else {

  }
#line 1114
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1115
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1116
  goto ldv_60995;
  case 32788: ;
#line 1134
  if ((((((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || (ha->device_type & 8192U) != 0U) || (ha->device_type & 16384U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) || (ha->device_type & 262144U) != 0U) && (((unsigned int )*(mb + 1UL) == 65535U && ((int )*(mb + 3UL) & 255) != 255) || (unsigned int )*(mb + 1UL) != 65535U)) && (int )vha->vp_idx != ((int )*(mb + 3UL) & 255)) {
#line 1137
    goto ldv_60995;
  } else {

  }
#line 1140
  if ((unsigned int )*(mb + 1UL) == 65535U && (unsigned int )*(mb + 2UL) == 7U) {
#line 1141
    ql_dbg(33554432U, vha, 20496, "Port unavailable %04x %04x %04x.\n", (int )*(mb + 1UL),
           (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1144
    ql_log(1U, vha, 20574, "Link is offline.\n");
#line 1147
    tmp___16 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1147
    if (tmp___16 != 2) {
#line 1148
      atomic_set(& vha->loop_state, 2);
#line 1149
      atomic_set(& vha->loop_down_timer, 255);
#line 1151
      vha->device_flags = vha->device_flags | 2U;
#line 1152
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
#line 1155
    if ((unsigned int )vha->vp_idx != 0U) {
#line 1156
      atomic_set(& vha->vp_state, 2);
#line 1157
      fc_vport_set_state(vha->fc_vport, 9);
#line 1159
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
#line 1162
    vha->flags.management_server_logged_in = 0U;
#line 1163
    ha->link_data_rate = 65535U;
#line 1164
    goto ldv_60995;
  } else {

  }
#line 1172
  atomic_set(& vha->loop_down_timer, 0);
#line 1173
  if ((unsigned int )*(mb + 1UL) != 65535U || ((unsigned int )*(mb + 2UL) != 6U && (unsigned int )*(mb + 2UL) != 4U)) {
#line 1174
    ql_dbg(33554432U, vha, 20497, "Asynchronous PORT UPDATE ignored %04x/%04x/%04x.\n",
           (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1178
    qlt_async_event((int )*mb, vha, mb);
#line 1179
    goto ldv_60995;
  } else {

  }
#line 1182
  ql_dbg(33554432U, vha, 20498, "Port database changed %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1185
  tmp___17 = qla2x00_get_link_speed_str(ha, (int )ha->link_data_rate);
#line 1185
  ql_log(1U, vha, 20575, "Link is operational (%s Gbps).\n", tmp___17);
#line 1192
  atomic_set(& vha->loop_state, 3);
#line 1194
  qla2x00_mark_all_devices_lost(vha, 1);
#line 1196
  if ((unsigned int )vha->vp_idx == 0U) {
#line 1196
    tmp___18 = qla_ini_mode_enabled(vha);
#line 1196
    if (tmp___18) {
#line 1196
      tmp___19 = 0;
    } else {
#line 1196
      tmp___19 = 1;
    }
#line 1196
    if (tmp___19) {
#line 1197
      set_bit(21L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 1199
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1200
  set_bit(6L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1202
  qlt_async_event((int )*mb, vha, mb);
#line 1203
  goto ldv_60995;
  case 32789: ;
#line 1207
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1207
    tmp___20 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->vp_flags));
#line 1207
    if (tmp___20 != 0) {
#line 1208
      goto ldv_60995;
    } else {

    }
  } else {

  }
#line 1210
  if (*((unsigned long *)ha + 2UL) != 0UL && (int )vha->vp_idx != ((int )*(mb + 3UL) & 255)) {
#line 1211
    goto ldv_60995;
  } else {

  }
#line 1213
  ql_dbg(33554432U, vha, 20499, "RSCN database changed -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1217
  rscn_entry = (uint32_t )((((int )*(mb + 1UL) & 255) << 16) | (int )*(mb + 2UL));
#line 1218
  host_pid = (uint32_t )((((int )vha->d_id.b.domain << 16) | ((int )vha->d_id.b.area << 8)) | (int )vha->d_id.b.al_pa);
#line 1220
  if (rscn_entry == host_pid) {
#line 1221
    ql_dbg(33554432U, vha, 20500, "Ignoring RSCN update to local host port ID (%06x).\n",
           host_pid);
#line 1224
    goto ldv_60995;
  } else {

  }
#line 1228
  rscn_entry = (uint32_t )((((int )*(mb + 1UL) & 1023) << 16) | (int )*(mb + 2UL));
#line 1231
  tmp___21 = qla2x00_is_a_vp_did(vha, rscn_entry);
#line 1231
  if (tmp___21 != 0) {
#line 1232
    goto ldv_60995;
  } else {

  }
#line 1234
  atomic_set(& vha->loop_down_timer, 0);
#line 1235
  vha->flags.management_server_logged_in = 0U;
#line 1237
  set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1238
  set_bit(7L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1239
  qla2x00_post_aen_work(vha, 5, rscn_entry);
#line 1240
  goto ldv_60995;
  case 32832: 
#line 1244
  ql_dbg(33554432U, vha, 20501, "[R|Z]IO update completion.\n");
#line 1247
  if ((ha->device_type & 134217728U) != 0U) {
#line 1248
    qla24xx_process_response_queue(vha, rsp);
  } else {
#line 1250
    qla2x00_process_response_queue(rsp);
  }
#line 1251
  goto ldv_60995;
  case 32840: 
#line 1254
  ql_dbg(33554432U, vha, 20502, "Discard RND Frame -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1257
  goto ldv_60995;
  case 32808: 
#line 1260
  ql_dbg(33554432U, vha, 20503, "Trace Notification -- %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL));
#line 1262
  goto ldv_60995;
  case 32783: 
#line 1265
  ql_dbg(33554432U, vha, 20504, "ISP84XX Alert Notification -- %04x %04x %04x.\n",
         (int )*(mb + 1UL), (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1269
  tmp___22 = spinlock_check(& (ha->cs84xx)->access_lock);
#line 1269
  flags = _raw_spin_lock_irqsave(tmp___22);
#line 1270
  switch ((int )*(mb + 1UL)) {
  case 1: 
#line 1272
  ql_log(2U, vha, 20505, "Alert 84XX: panic recovery %04x %04x.\n", (int )*(mb + 2UL),
         (int )*(mb + 3UL));
#line 1275
  goto ldv_61020;
  case 2: 
#line 1277
  (ha->cs84xx)->op_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1278
  ql_log(2U, vha, 20506, "Alert 84XX: firmware version %x.\n", (ha->cs84xx)->op_fw_version);
#line 1281
  goto ldv_61020;
  case 3: 
#line 1283
  (ha->cs84xx)->diag_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1284
  ql_log(2U, vha, 20507, "Alert 84XX: diagnostic firmware version %x.\n", (ha->cs84xx)->diag_fw_version);
#line 1287
  goto ldv_61020;
  case 4: 
#line 1289
  (ha->cs84xx)->diag_fw_version = (uint32_t )(((int )*(mb + 3UL) << 16) | (int )*(mb + 2UL));
#line 1290
  (ha->cs84xx)->fw_update = 1U;
#line 1291
  ql_log(2U, vha, 20508, "Alert 84XX: gold firmware version %x.\n", (ha->cs84xx)->gold_fw_version);
#line 1294
  goto ldv_61020;
  default: 
#line 1296
  ql_log(1U, vha, 20509, "Alert 84xx: Invalid Alert %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
  }
  ldv_61020: 
#line 1300
  spin_unlock_irqrestore(& (ha->cs84xx)->access_lock, flags);
#line 1301
  goto ldv_60995;
  case 32790: 
#line 1303
  ql_dbg(33554432U, vha, 20510, "DCBX Started -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1306
  goto ldv_60995;
  case 32818: 
#line 1308
  ql_dbg(33554432U, vha, 20511, "DCBX Parameters Updated -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1311
  goto ldv_60995;
  case 32817: 
#line 1313
  ql_dbg(33554432U, vha, 20512, "FCF Configuration Error -- %04x %04x %04x.\n", (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
#line 1316
  goto ldv_60995;
  case 33025: ;
#line 1318
  if (((vha->hw)->device_type & 65536U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1319
    *(mb + 4UL) = readw((void const volatile   *)(& reg24->mailbox4));
#line 1320
    if ((((int )*(mb + 2UL) & 32767) == 288 || ((int )*(mb + 2UL) & 32767) == 290) && ((int )*(mb + 4UL) & 14) != 0) {
#line 1323
      set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1327
      tmp___23 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1327
      if (tmp___23 == 2) {
#line 1328
        atomic_set(& vha->loop_down_timer, 255);
      } else {

      }
#line 1330
      qla2xxx_wake_dpc(vha);
    } else {

    }
  } else {

  }
  case 33024: ;
#line 1334
  if (ha->notify_lb_portup_comp != 0) {
#line 1335
    complete(& ha->lb_portup_comp);
  } else {

  }
  case 33026: ;
#line 1338
  if ((((vha->hw)->device_type & 8192U) != 0U || ((vha->hw)->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1340
    qla81xx_idc_event(vha, (int )*mb, (int )*(mb + 1UL));
  } else {

  }
#line 1341
  goto ldv_60995;
  case 33280: 
#line 1344
  *(mb + 4UL) = readw((void const volatile   *)(& reg24->mailbox4));
#line 1345
  *(mb + 5UL) = readw((void const volatile   *)(& reg24->mailbox5));
#line 1346
  *(mb + 6UL) = readw((void const volatile   *)(& reg24->mailbox6));
#line 1347
  *(mb + 7UL) = readw((void const volatile   *)(& reg24->mailbox7));
#line 1348
  qla83xx_handle_8200_aen(vha, mb);
#line 1349
  goto ldv_60995;
  default: 
#line 1352
  ql_dbg(33554432U, vha, 20567, "Unknown AEN:%04x %04x %04x %04x\n", (int )*mb, (int )*(mb + 1UL),
         (int )*(mb + 2UL), (int )*(mb + 3UL));
  }
  ldv_60995: 
#line 1357
  qlt_async_event((int )*mb, vha, mb);
#line 1359
  if ((unsigned int )vha->vp_idx == 0U && (unsigned int )ha->num_vhosts != 0U) {
#line 1360
    qla2x00_alert_all_vps(rsp, mb);
  } else {

  }
#line 1361
  return;
}
}
#line 1369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void qla2x00_process_completed_request(struct scsi_qla_host *vha , struct req_que *req ,
                                       uint32_t index ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;

  {
#line 1373
  ha = vha->hw;
#line 1376
  if ((uint32_t )req->num_outstanding_cmds <= index) {
#line 1377
    ql_log(1U, vha, 12308, "Invalid SCSI command index (%x).\n", index);
#line 1380
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1381
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1383
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 1384
    return;
  } else {

  }
#line 1387
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 1388
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 1390
    *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
#line 1393
    (*(sp->done))((void *)ha, (void *)sp, 0);
  } else {
#line 1395
    ql_log(1U, vha, 12310, "Invalid SCSI SRB.\n");
#line 1397
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1398
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1400
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
  }
#line 1402
  return;
}
}
#line 1405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
srb_t *qla2x00_get_sp_from_handle(scsi_qla_host_t *vha , char const   *func , struct req_que *req ,
                                  void *iocb ) 
{ 
  struct qla_hw_data *ha ;
  sts_entry_t *pkt ;
  srb_t *sp ;
  uint16_t index ;

  {
#line 1408
  ha = vha->hw;
#line 1409
  pkt = (sts_entry_t *)iocb;
#line 1410
  sp = (srb_t *)0;
#line 1413
  index = (unsigned short )pkt->handle;
#line 1414
  if ((int )req->num_outstanding_cmds <= (int )index) {
#line 1415
    ql_log(1U, vha, 20529, "Invalid command index (%x).\n", (int )index);
#line 1417
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1418
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 1420
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 1421
    goto done;
  } else {

  }
#line 1423
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 1424
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1425
    ql_log(1U, vha, 20530, "Invalid completion handle (%x) -- timed-out.\n", (int )index);
#line 1427
    return (sp);
  } else {

  }
#line 1429
  if (sp->handle != (uint32_t )index) {
#line 1430
    ql_log(1U, vha, 20531, "SRB handle (%x) mismatch %x.\n", sp->handle, (int )index);
#line 1432
    return ((srb_t *)0);
  } else {

  }
#line 1435
  *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
  done: ;
#line 1438
  return (sp);
}
}
#line 1442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_mbx_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , struct mbx_entry *mbx ) 
{ 
  char func[9U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *lio ;
  uint16_t *data ;
  uint16_t status ;

  {
#line 1445
  func[0] = 'M';
#line 1445
  func[1] = 'B';
#line 1445
  func[2] = 'X';
#line 1445
  func[3] = '-';
#line 1445
  func[4] = 'I';
#line 1445
  func[5] = 'O';
#line 1445
  func[6] = 'C';
#line 1445
  func[7] = 'B';
#line 1445
  func[8] = '\000';
#line 1453
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)mbx);
#line 1454
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1455
    return;
  } else {

  }
#line 1457
  lio = & sp->u.iocb_cmd;
#line 1458
  type = (char const   *)sp->name;
#line 1459
  fcport = sp->fcport;
#line 1460
  data = (uint16_t *)(& lio->u.logio.data);
#line 1462
  *data = 16389U;
#line 1463
  *(data + 1UL) = (unsigned int )lio->u.logio.flags & 1U;
#line 1465
  if ((unsigned int )mbx->entry_status != 0U) {
#line 1466
    ql_dbg(33554432U, vha, 20547, "Async-%s error entry - hdl=%x portid=%02x%02x%02x entry-status=%x status=%x state-flag=%x status-flags=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )mbx->entry_status, (int )mbx->status,
           (int )mbx->state_flags, (int )mbx->status_flags);
#line 1475
    ql_dump_buffer(33685504U, vha, 20521, (uint8_t *)mbx, 64U);
#line 1478
    goto logio_done;
  } else {

  }
#line 1481
  status = mbx->status;
#line 1482
  if (((unsigned int )status == 48U && (unsigned int )sp->type == 1U) && (unsigned int )mbx->mb0 == 16384U) {
#line 1484
    status = 0U;
  } else {

  }
#line 1485
  if ((unsigned int )status == 0U && (unsigned int )mbx->mb0 == 16384U) {
#line 1486
    ql_dbg(33554432U, vha, 20549, "Async-%s complete - hdl=%x portid=%02x%02x%02x mbx1=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )mbx->mb1);
#line 1492
    *data = 16384U;
#line 1493
    if ((unsigned int )sp->type == 1U) {
#line 1494
      fcport->port_type = 5;
#line 1495
      if ((int )mbx->mb1 & 1) {
#line 1496
        fcport->port_type = 4;
      } else
#line 1497
      if (((int )mbx->mb1 & 2) != 0) {
#line 1498
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    } else {

    }
#line 1500
    goto logio_done;
  } else {

  }
#line 1503
  *data = mbx->mb0;
#line 1504
  switch ((int )*data) {
  case 16391: 
#line 1506
  *(data + 1UL) = mbx->mb1;
#line 1507
  goto ldv_61065;
  case 16392: ;
#line 1509
  goto ldv_61065;
  default: 
#line 1511
  *data = 16389U;
#line 1512
  goto ldv_61065;
  }
  ldv_61065: 
#line 1515
  ql_log(1U, vha, 20550, "Async-%s failed - hdl=%x portid=%02x%02x%02x status=%x mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n",
         type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, (int )status, (int )mbx->mb0, (int )mbx->mb1,
         (int )mbx->mb2, (int )mbx->mb6, (int )mbx->mb7);
  logio_done: 
#line 1524
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1525
  return;
}
}
#line 1528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_ct_entry(scsi_qla_host_t *vha , struct req_que *req , sts_entry_t *pkt ,
                             int iocb_type ) 
{ 
  char func[8U] ;
  char const   *type ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  uint16_t comp_status ;
  int res ;

  {
#line 1531
  func[0] = 'C';
#line 1531
  func[1] = 'T';
#line 1531
  func[2] = '_';
#line 1531
  func[3] = 'I';
#line 1531
  func[4] = 'O';
#line 1531
  func[5] = 'C';
#line 1531
  func[6] = 'B';
#line 1531
  func[7] = '\000';
#line 1538
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 1539
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1540
    return;
  } else {

  }
#line 1542
  bsg_job = sp->u.bsg_job;
#line 1544
  type = "ct pass-through";
#line 1546
  comp_status = pkt->comp_status;
#line 1551
  (bsg_job->reply)->reply_data.ctels_reply.status = 0U;
#line 1552
  bsg_job->reply_len = 16U;
#line 1554
  if ((unsigned int )comp_status != 0U) {
#line 1555
    if ((unsigned int )comp_status == 21U) {
#line 1556
      res = 0;
#line 1557
      (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )pkt->rsp_info_len;
#line 1560
      ql_log(1U, vha, 20552, "CT pass-through-%s error comp_status-status=0x%x total_byte = 0x%x.\n",
             type, (int )comp_status, (bsg_job->reply)->reply_payload_rcv_len);
    } else {
#line 1566
      ql_log(1U, vha, 20553, "CT pass-through-%s error comp_status-status=0x%x.\n",
             type, (int )comp_status);
#line 1569
      res = 458752;
#line 1570
      (bsg_job->reply)->reply_payload_rcv_len = 0U;
    }
#line 1572
    ql_dump_buffer(33685504U, vha, 20533, (uint8_t *)pkt, 64U);
  } else {
#line 1575
    res = 0;
#line 1576
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1578
    bsg_job->reply_len = 0U;
  }
#line 1581
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 1582
  return;
}
}
#line 1585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla24xx_els_ct_entry(scsi_qla_host_t *vha , struct req_que *req , struct sts_entry_24xx *pkt ,
                                 int iocb_type ) 
{ 
  char func[12U] ;
  char const   *type ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  uint16_t comp_status ;
  uint32_t fw_status[3U] ;
  uint8_t *fw_sts_ptr ;
  int res ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1588
  func[0] = 'E';
#line 1588
  func[1] = 'L';
#line 1588
  func[2] = 'S';
#line 1588
  func[3] = '_';
#line 1588
  func[4] = 'C';
#line 1588
  func[5] = 'T';
#line 1588
  func[6] = '_';
#line 1588
  func[7] = 'I';
#line 1588
  func[8] = 'O';
#line 1588
  func[9] = 'C';
#line 1588
  func[10] = 'B';
#line 1588
  func[11] = '\000';
#line 1597
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 1598
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1599
    return;
  } else {

  }
#line 1600
  bsg_job = sp->u.bsg_job;
#line 1602
  type = (char const   *)0;
#line 1603
  switch ((int )sp->type) {
  case 3: ;
  case 4: 
#line 1606
  type = "els";
#line 1607
  goto ldv_61096;
  case 5: 
#line 1609
  type = "ct pass-through";
#line 1610
  goto ldv_61096;
  default: 
#line 1612
  ql_dbg(8388608U, vha, 20542, "Unrecognized SRB: (%p) type=%d.\n", sp, (int )sp->type);
#line 1614
  return;
  }
  ldv_61096: 
#line 1617
  fw_status[0] = (uint32_t )pkt->comp_status;
#line 1617
  comp_status = (uint16_t )fw_status[0];
#line 1618
  fw_status[1] = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_1);
#line 1619
  fw_status[2] = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_2);
#line 1624
  (bsg_job->reply)->reply_data.ctels_reply.status = 0U;
#line 1625
  bsg_job->reply_len = 28U;
#line 1627
  if ((unsigned int )comp_status != 0U) {
#line 1628
    if ((unsigned int )comp_status == 21U) {
#line 1629
      res = 0;
#line 1630
      (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )((unsigned short )((struct els_sts_entry_24xx *)pkt)->total_byte_count);
#line 1633
      ql_dbg(8388608U, vha, 20543, "ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x error subcode 1=0x%x error subcode 2=0x%x total_byte = 0x%x.\n",
             type, sp->handle, (int )comp_status, fw_status[1], fw_status[2], (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->total_byte_count));
#line 1639
      fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 1640
      __len = 12UL;
#line 1640
      if (__len > 63UL) {
#line 1640
        __ret = __memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status), __len);
      } else {
#line 1640
        __ret = __builtin_memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status),
                                 __len);
      }
    } else {
#line 1643
      ql_dbg(8388608U, vha, 20544, "ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x error subcode 1=0x%x error subcode 2=0x%x.\n",
             type, sp->handle, (int )comp_status, (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_1),
             (int )((unsigned short )((struct els_sts_entry_24xx *)pkt)->error_subcode_2));
#line 1651
      res = 458752;
#line 1652
      (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 1653
      fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 1654
      __len___0 = 12UL;
#line 1654
      if (__len___0 > 63UL) {
#line 1654
        __ret___0 = __memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status), __len___0);
      } else {
#line 1654
        __ret___0 = __builtin_memcpy((void *)fw_sts_ptr, (void const   *)(& fw_status),
                                     __len___0);
      }
    }
#line 1656
    ql_dump_buffer(8519680U, vha, 20566, (uint8_t *)pkt, 64U);
  } else {
#line 1660
    res = 0;
#line 1661
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1662
    bsg_job->reply_len = 0U;
  }
#line 1665
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 1666
  return;
}
}
#line 1669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla24xx_logio_entry(scsi_qla_host_t *vha , struct req_que *req , struct logio_entry_24xx *logio ) 
{ 
  char func[11U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *lio ;
  uint16_t *data ;
  uint32_t iop[2U] ;

  {
#line 1672
  func[0] = 'L';
#line 1672
  func[1] = 'O';
#line 1672
  func[2] = 'G';
#line 1672
  func[3] = 'I';
#line 1672
  func[4] = 'O';
#line 1672
  func[5] = '-';
#line 1672
  func[6] = 'I';
#line 1672
  func[7] = 'O';
#line 1672
  func[8] = 'C';
#line 1672
  func[9] = 'B';
#line 1672
  func[10] = '\000';
#line 1680
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)logio);
#line 1681
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1682
    return;
  } else {

  }
#line 1684
  lio = & sp->u.iocb_cmd;
#line 1685
  type = (char const   *)sp->name;
#line 1686
  fcport = sp->fcport;
#line 1687
  data = (uint16_t *)(& lio->u.logio.data);
#line 1689
  *data = 16389U;
#line 1690
  *(data + 1UL) = (unsigned int )lio->u.logio.flags & 1U;
#line 1692
  if ((unsigned int )logio->entry_status != 0U) {
#line 1693
    ql_log(1U, fcport->vha, 20532, "Async-%s error entry - hdl=%xportid=%02x%02x%02x entry-status=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )logio->entry_status);
#line 1699
    ql_dump_buffer(33685504U, vha, 20557, (uint8_t *)logio, 64U);
#line 1702
    goto logio_done;
  } else {

  }
#line 1705
  if ((unsigned int )logio->comp_status == 0U) {
#line 1706
    ql_dbg(33554432U, fcport->vha, 20534, "Async-%s complete - hdl=%x portid=%02x%02x%02x iop0=%x.\n",
           type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, logio->io_parameter[0]);
#line 1712
    *data = 16384U;
#line 1713
    if ((unsigned int )sp->type != 1U) {
#line 1714
      goto logio_done;
    } else {

    }
#line 1716
    iop[0] = logio->io_parameter[0];
#line 1717
    if ((iop[0] & 16U) != 0U) {
#line 1718
      fcport->port_type = 5;
#line 1719
      if ((iop[0] & 256U) != 0U) {
#line 1720
        fcport->flags = fcport->flags | 4U;
      } else {

      }
    } else
#line 1721
    if ((iop[0] & 32U) != 0U) {
#line 1722
      fcport->port_type = 4;
    } else {

    }
#line 1724
    if ((iop[0] & 128U) != 0U) {
#line 1725
      fcport->flags = fcport->flags | 16U;
    } else {

    }
#line 1727
    if (logio->io_parameter[7] != 0U || logio->io_parameter[8] != 0U) {
#line 1728
      fcport->supported_classes = fcport->supported_classes | 4U;
    } else {

    }
#line 1729
    if (logio->io_parameter[9] != 0U || logio->io_parameter[10] != 0U) {
#line 1730
      fcport->supported_classes = fcport->supported_classes | 8U;
    } else {

    }
#line 1732
    goto logio_done;
  } else {

  }
#line 1735
  iop[0] = logio->io_parameter[0];
#line 1736
  iop[1] = logio->io_parameter[1];
#line 1737
  switch (iop[0]) {
  case 26U: 
#line 1739
  *data = 16391U;
#line 1740
  *(data + 1UL) = (unsigned short )iop[1];
#line 1741
  goto ldv_61119;
  case 27U: 
#line 1743
  *data = 16392U;
#line 1744
  goto ldv_61119;
  default: 
#line 1746
  *data = 16389U;
#line 1747
  goto ldv_61119;
  }
  ldv_61119: 
#line 1750
  ql_dbg(33554432U, fcport->vha, 20535, "Async-%s failed - hdl=%x portid=%02x%02x%02x comp=%x iop0=%x iop1=%x.\n",
         type, sp->handle, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
         (int )fcport->d_id.b.al_pa, (int )logio->comp_status, logio->io_parameter[0],
         logio->io_parameter[1]);
  logio_done: 
#line 1759
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1760
  return;
}
}
#line 1763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla24xx_tm_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , struct tsk_mgmt_entry *tsk ) 
{ 
  char func[9U] ;
  char const   *type ;
  fc_port_t *fcport ;
  srb_t *sp ;
  struct srb_iocb *iocb ;
  struct sts_entry_24xx *sts ;
  int error ;

  {
#line 1766
  func[0] = 'T';
#line 1766
  func[1] = 'M';
#line 1766
  func[2] = 'F';
#line 1766
  func[3] = '-';
#line 1766
  func[4] = 'I';
#line 1766
  func[5] = 'O';
#line 1766
  func[6] = 'C';
#line 1766
  func[7] = 'B';
#line 1766
  func[8] = '\000';
#line 1771
  sts = (struct sts_entry_24xx *)tsk;
#line 1772
  error = 1;
#line 1774
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)tsk);
#line 1775
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1776
    return;
  } else {

  }
#line 1778
  iocb = & sp->u.iocb_cmd;
#line 1779
  type = (char const   *)sp->name;
#line 1780
  fcport = sp->fcport;
#line 1782
  if ((unsigned int )sts->entry_status != 0U) {
#line 1783
    ql_log(1U, fcport->vha, 20536, "Async-%s error - hdl=%x entry-status(%x).\n",
           type, sp->handle, (int )sts->entry_status);
  } else
#line 1786
  if ((unsigned int )sts->comp_status != 0U) {
#line 1787
    ql_log(1U, fcport->vha, 20537, "Async-%s error - hdl=%x completion status(%x).\n",
           type, sp->handle, (int )sts->comp_status);
  } else
#line 1790
  if (((int )sts->scsi_status & 256) == 0) {
#line 1792
    ql_log(1U, fcport->vha, 20538, "Async-%s error - hdl=%x no response info(%x).\n",
           type, sp->handle, (int )sts->scsi_status);
  } else
#line 1795
  if (sts->rsp_data_len <= 3U) {
#line 1796
    ql_log(1U, fcport->vha, 20539, "Async-%s error - hdl=%x not enough response(%d).\n",
           type, sp->handle, sts->rsp_data_len);
  } else
#line 1799
  if ((unsigned int )sts->data[3] != 0U) {
#line 1800
    ql_log(1U, fcport->vha, 20540, "Async-%s error - hdl=%x response(%x).\n", type,
           sp->handle, (int )sts->data[3]);
  } else {
#line 1804
    error = 0;
  }
#line 1807
  if (error != 0) {
#line 1808
    iocb->u.tmf.data = (uint32_t )error;
#line 1809
    ql_dump_buffer(33685504U, vha, 20565, (uint8_t *)sts, 64U);
  } else {

  }
#line 1813
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 1814
  return;
}
}
#line 1821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void qla2x00_process_response_queue(struct rsp_que *rsp ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  sts_entry_t *pkt ;
  uint16_t handle_cnt ;
  uint16_t cnt ;
  void *tmp ;

  {
#line 1824
  ha = rsp->hw;
#line 1825
  reg = & (ha->iobase)->isp;
#line 1830
  tmp = pci_get_drvdata(ha->pdev);
#line 1830
  vha = (struct scsi_qla_host *)tmp;
#line 1832
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1833
    return;
  } else {

  }
#line 1835
  goto ldv_61143;
  ldv_61158: 
#line 1836
  pkt = (sts_entry_t *)rsp->ring_ptr;
#line 1838
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 1839
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 1840
    rsp->ring_index = 0U;
#line 1841
    rsp->ring_ptr = rsp->ring;
  } else {
#line 1843
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 1846
  if ((unsigned int )pkt->entry_status != 0U) {
#line 1847
    qla2x00_error_entry(vha, rsp, pkt);
#line 1848
    ((response_t *)pkt)->signature = 3735936685U;
#line 1849
    __asm__  volatile   ("sfence": : : "memory");
#line 1850
    goto ldv_61143;
  } else {

  }
#line 1853
  switch ((int )pkt->entry_type) {
  case 3: 
#line 1855
  qla2x00_status_entry(vha, rsp, (void *)pkt);
#line 1856
  goto ldv_61145;
  case 33: 
#line 1858
  handle_cnt = (uint16_t )((sts21_entry_t *)pkt)->handle_count;
#line 1859
  cnt = 0U;
#line 1859
  goto ldv_61148;
  ldv_61147: 
#line 1860
  qla2x00_process_completed_request(vha, rsp->req, ((sts21_entry_t *)pkt)->handle[(int )cnt]);
#line 1859
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61148: ;
#line 1859
  if ((int )cnt < (int )handle_cnt) {
#line 1861
    goto ldv_61147;
  } else {

  }

#line 1863
  goto ldv_61145;
  case 34: 
#line 1865
  handle_cnt = (uint16_t )((sts22_entry_t *)pkt)->handle_count;
#line 1866
  cnt = 0U;
#line 1866
  goto ldv_61152;
  ldv_61151: 
#line 1867
  qla2x00_process_completed_request(vha, rsp->req, (uint32_t )((sts22_entry_t *)pkt)->handle[(int )cnt]);
#line 1866
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61152: ;
#line 1866
  if ((int )cnt < (int )handle_cnt) {
#line 1868
    goto ldv_61151;
  } else {

  }

#line 1870
  goto ldv_61145;
  case 16: 
#line 1872
  qla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 1873
  goto ldv_61145;
  case 57: 
#line 1875
  qla2x00_mbx_iocb_entry(vha, rsp->req, (struct mbx_entry *)pkt);
#line 1877
  goto ldv_61145;
  case 41: 
#line 1879
  qla2x00_ct_entry(vha, rsp->req, pkt, 41);
#line 1880
  goto ldv_61145;
  default: 
#line 1883
  ql_log(1U, vha, 20554, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 1887
  goto ldv_61145;
  }
  ldv_61145: 
#line 1889
  ((response_t *)pkt)->signature = 3735936685U;
#line 1890
  __asm__  volatile   ("sfence": : : "memory");
  ldv_61143: ;
#line 1835
  if ((rsp->ring_ptr)->signature != 3735936685U) {
#line 1837
    goto ldv_61158;
  } else {

  }
#line 1894
  writew((int )rsp->ring_index, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox5 : & reg->u.isp2300.rsp_q_out));
#line 1895
  return;
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
__inline static void qla2x00_handle_sense(srb_t *sp , uint8_t *sense_data , uint32_t par_sense_len ,
                                          uint32_t sense_len , struct rsp_que *rsp ,
                                          int res ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cp ;
  uint32_t track_sense_len ;
  size_t __len ;
  void *__ret ;

  {
#line 1901
  vha = (sp->fcport)->vha;
#line 1902
  cp = sp->u.scmd.cmd;
#line 1905
  if (sense_len > 95U) {
#line 1906
    sense_len = 96U;
  } else {

  }
#line 1908
  sp->u.scmd.request_sense_length = sense_len;
#line 1909
  sp->u.scmd.request_sense_ptr = cp->sense_buffer;
#line 1910
  track_sense_len = sense_len;
#line 1912
  if (sense_len > par_sense_len) {
#line 1913
    sense_len = par_sense_len;
  } else {

  }
#line 1915
  __len = (size_t )sense_len;
#line 1915
  __ret = __builtin_memcpy((void *)cp->sense_buffer, (void const   *)sense_data, __len);
#line 1917
  sp->u.scmd.request_sense_ptr = cp->sense_buffer + (unsigned long )sense_len;
#line 1918
  track_sense_len = track_sense_len - sense_len;
#line 1919
  sp->u.scmd.request_sense_length = track_sense_len;
#line 1921
  if (track_sense_len != 0U) {
#line 1922
    rsp->status_srb = sp;
#line 1923
    cp->result = res;
  } else {

  }
#line 1926
  if (sense_len != 0U) {
#line 1927
    ql_dbg(134348800U, vha, 12316, "Check condition Sense data, nexus%ld:%d:%d cmd=%p.\n",
           ((sp->fcport)->vha)->host_no, (cp->device)->id, (cp->device)->lun, cp);
#line 1931
    ql_dump_buffer(134348800U, vha, 12331, cp->sense_buffer, sense_len);
  } else {

  }
#line 1934
  return;
}
}
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
__inline static int qla2x00_handle_dif_error(srb_t *sp , struct sts_entry_24xx *sts24 ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cmd ;
  uint8_t *ap ;
  uint8_t *ep ;
  uint32_t e_ref_tag ;
  uint32_t a_ref_tag ;
  uint16_t e_app_tag ;
  uint16_t a_app_tag ;
  uint16_t e_guard ;
  uint16_t a_guard ;
  sector_t tmp ;
  uint32_t blocks_done ;
  uint32_t resid ;
  sector_t lba_s ;
  sector_t tmp___0 ;
  unsigned int tmp___1 ;
  uint32_t i ;
  uint32_t j ;
  uint32_t k ;
  uint32_t num_ent ;
  struct scatterlist *sg ;
  struct sd_dif_tuple *spt ;
  unsigned int tmp___2 ;
  struct page *tmp___3 ;
  void *tmp___4 ;
  unsigned char tmp___5 ;
  unsigned int tmp___6 ;
  unsigned char tmp___7 ;

  {
#line 1951
  vha = (sp->fcport)->vha;
#line 1952
  cmd = sp->u.scmd.cmd;
#line 1953
  ap = (uint8_t *)(& sts24->data) + 12UL;
#line 1954
  ep = (uint8_t *)(& sts24->data) + 20UL;
#line 1963
  a_guard = *((uint16_t *)ap + 2U);
#line 1964
  a_app_tag = *((uint16_t *)ap);
#line 1965
  a_ref_tag = *((uint32_t *)ap + 4U);
#line 1966
  e_guard = *((uint16_t *)ep + 2U);
#line 1967
  e_app_tag = *((uint16_t *)ep);
#line 1968
  e_ref_tag = *((uint32_t *)ep + 4U);
#line 1970
  ql_dbg(134217728U, vha, 12323, "iocb(s) %p Returned STATUS.\n", sts24);
#line 1973
  tmp = scsi_get_lba(cmd);
#line 1973
  ql_dbg(134217728U, vha, 12324, "DIF OLD_ERROR in cmd 0x%x lba 0x%llx act ref tag=0x%x, exp ref_tag=0x%x, act app tag=0x%x, exp app tag=0x%x, act guard=0x%x, exp guard=0x%x.\n",
         (int )*(cmd->cmnd), (unsigned long long )tmp, a_ref_tag, e_ref_tag, (int )a_app_tag,
         (int )e_app_tag, (int )a_guard, (int )e_guard);
#line 1985
  if ((unsigned int )a_app_tag == 65535U) {
#line 1985
    tmp___7 = scsi_get_prot_type(cmd);
#line 1985
    if ((unsigned int )tmp___7 != 3U || a_ref_tag == 4294967295U) {
#line 1989
      tmp___0 = scsi_get_lba(cmd);
#line 1989
      lba_s = tmp___0;
#line 1992
      blocks_done = (e_ref_tag - (uint32_t )lba_s) + 1U;
#line 1994
      tmp___1 = scsi_bufflen(cmd);
#line 1994
      resid = tmp___1 - (cmd->device)->sector_size * blocks_done;
#line 1997
      scsi_set_resid(cmd, (int )resid);
#line 1998
      cmd->result = 0;
#line 2001
      tmp___6 = scsi_prot_sg_count(cmd);
#line 2001
      if (tmp___6 != 0U) {
#line 2002
        j = 0U;
#line 2002
        k = 0U;
#line 2007
        i = 0U;
#line 2007
        sg = scsi_prot_sglist(cmd);
#line 2007
        goto ldv_61204;
        ldv_61203: 
#line 2009
        num_ent = sg->dma_length / 8U;
#line 2010
        if (k + num_ent < blocks_done) {
#line 2011
          k = k + num_ent;
#line 2012
          goto ldv_61201;
        } else {

        }
#line 2014
        j = (blocks_done - k) - 1U;
#line 2015
        k = blocks_done;
#line 2016
        goto ldv_61202;
        ldv_61201: 
#line 2007
        i = i + 1U;
#line 2007
        sg = sg_next(sg);
        ldv_61204: 
#line 2007
        tmp___2 = scsi_prot_sg_count(cmd);
#line 2007
        if (tmp___2 > i) {
#line 2009
          goto ldv_61203;
        } else {

        }
        ldv_61202: ;
#line 2019
        if (k != blocks_done) {
#line 2020
          ql_log(1U, vha, 12335, "unexpected tag values tag:lba=%x:%llx)\n", e_ref_tag,
                 (unsigned long long )lba_s);
#line 2023
          return (1);
        } else {

        }
#line 2026
        tmp___3 = sg_page(sg);
#line 2026
        tmp___4 = lowmem_page_address((struct page  const  *)tmp___3);
#line 2026
        spt = (struct sd_dif_tuple *)tmp___4 + (unsigned long )sg->offset;
#line 2027
        spt = spt + (unsigned long )j;
#line 2029
        spt->app_tag = 65535U;
#line 2030
        tmp___5 = scsi_get_prot_type(cmd);
#line 2030
        if ((unsigned int )tmp___5 == 3U) {
#line 2031
          spt->ref_tag = 4294967295U;
        } else {

        }
      } else {

      }
#line 2034
      return (0);
    } else {

    }
  } else {

  }
#line 2038
  if ((int )e_guard != (int )a_guard) {
#line 2039
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 1);
#line 2041
    set_driver_byte(cmd, 8);
#line 2042
    set_host_byte(cmd, 5);
#line 2043
    cmd->result = cmd->result | 4;
#line 2044
    return (1);
  } else {

  }
#line 2048
  if (e_ref_tag != a_ref_tag) {
#line 2049
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 3);
#line 2051
    set_driver_byte(cmd, 8);
#line 2052
    set_host_byte(cmd, 5);
#line 2053
    cmd->result = cmd->result | 4;
#line 2054
    return (1);
  } else {

  }
#line 2058
  if ((int )e_app_tag != (int )a_app_tag) {
#line 2059
    scsi_build_sense_buffer(1, cmd->sense_buffer, 5, 16, 2);
#line 2061
    set_driver_byte(cmd, 8);
#line 2062
    set_host_byte(cmd, 5);
#line 2063
    cmd->result = cmd->result | 4;
#line 2064
    return (1);
  } else {

  }
#line 2067
  return (1);
}
}
#line 2071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla25xx_process_bidir_status_iocb(scsi_qla_host_t *vha , void *pkt , struct req_que *req ,
                                              uint32_t index ) 
{ 
  struct qla_hw_data *ha ;
  srb_t *sp ;
  uint16_t comp_status ;
  uint16_t scsi_status ;
  uint16_t thread_id ;
  uint32_t rval ;
  struct fc_bsg_job *bsg_job ;
  sts_entry_t *sts ;
  struct sts_entry_24xx *sts24 ;

  {
#line 2074
  ha = vha->hw;
#line 2079
  rval = 0U;
#line 2080
  bsg_job = (struct fc_bsg_job *)0;
#line 2083
  sts = (sts_entry_t *)pkt;
#line 2084
  sts24 = (struct sts_entry_24xx *)pkt;
#line 2087
  if ((uint32_t )req->num_outstanding_cmds <= index) {
#line 2088
    ql_log(1U, vha, 28847, "Invalid SCSI completion handle 0x%x.\n", index);
#line 2090
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2091
    return;
  } else {

  }
#line 2094
  sp = *(req->outstanding_cmds + (unsigned long )index);
#line 2095
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2097
    *(req->outstanding_cmds + (unsigned long )index) = (srb_t *)0;
#line 2098
    bsg_job = sp->u.bsg_job;
  } else {
#line 2100
    ql_log(1U, vha, 28848, "Req:%d: Invalid ISP SCSI completion handle(0x%x)\n", (int )req->id,
           index);
#line 2104
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2105
    return;
  }
#line 2108
  if ((ha->device_type & 134217728U) != 0U) {
#line 2109
    comp_status = sts24->comp_status;
#line 2110
    scsi_status = (unsigned int )sts24->scsi_status & 4095U;
  } else {
#line 2112
    comp_status = sts->comp_status;
#line 2113
    scsi_status = (unsigned int )sts->scsi_status & 4095U;
  }
#line 2116
  thread_id = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 2117
  switch ((int )comp_status) {
  case 0: ;
#line 2119
  if ((unsigned int )scsi_status == 0U) {
#line 2120
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 2122
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )(bsg_job->reply)->reply_payload_rcv_len;
#line 2124
    vha->qla_stats.input_requests = vha->qla_stats.input_requests + 1ULL;
#line 2125
    rval = 0U;
  } else {

  }
#line 2127
  goto done;
  case 7: 
#line 2130
  ql_dbg(8388608U, vha, 28849, "Command completed with date overrun thread_id=%d\n",
         (int )thread_id);
#line 2133
  rval = 7U;
#line 2134
  goto ldv_61223;
  case 21: 
#line 2137
  ql_dbg(8388608U, vha, 28850, "Command completed with date underrun thread_id=%d\n",
         (int )thread_id);
#line 2140
  rval = 8U;
#line 2141
  goto ldv_61223;
  case 1792: 
#line 2143
  ql_dbg(8388608U, vha, 28851, "Command completed with read data overrun thread_id=%d\n",
         (int )thread_id);
#line 2146
  rval = 7U;
#line 2147
  goto ldv_61223;
  case 1799: 
#line 2150
  ql_dbg(8388608U, vha, 28852, "Command completed with read and write data overrun thread_id=%d\n",
         (int )thread_id);
#line 2153
  rval = 7U;
#line 2154
  goto ldv_61223;
  case 1813: 
#line 2157
  ql_dbg(8388608U, vha, 28853, "Command completed with read data over and write data underrun thread_id=%d\n",
         (int )thread_id);
#line 2160
  rval = 7U;
#line 2161
  goto ldv_61223;
  case 5376: 
#line 2164
  ql_dbg(8388608U, vha, 28854, "Command completed with read data data underrun thread_id=%d\n",
         (int )thread_id);
#line 2167
  rval = 8U;
#line 2168
  goto ldv_61223;
  case 5383: 
#line 2171
  ql_dbg(8388608U, vha, 28855, "Command completed with read data under and write data overrun thread_id=%d\n",
         (int )thread_id);
#line 2174
  rval = 8U;
#line 2175
  goto ldv_61223;
  case 5397: 
#line 2178
  ql_dbg(8388608U, vha, 28856, "Command completed with read and write data underrun thread_id=%d\n",
         (int )thread_id);
#line 2181
  rval = 8U;
#line 2182
  goto ldv_61223;
  case 512: 
#line 2185
  ql_dbg(8388608U, vha, 28857, "Command completed with data DMA error thread_id=%d\n",
         (int )thread_id);
#line 2188
  rval = 29U;
#line 2189
  goto ldv_61223;
  case 6: 
#line 2192
  ql_dbg(8388608U, vha, 28858, "Command completed with timeout thread_id=%d\n", (int )thread_id);
#line 2195
  rval = 30U;
#line 2196
  goto ldv_61223;
  default: 
#line 2198
  ql_dbg(8388608U, vha, 28859, "Command completed with completion status=0x%x thread_id=%d\n",
         (int )comp_status, (int )thread_id);
#line 2201
  rval = 1U;
#line 2202
  goto ldv_61223;
  }
  ldv_61223: 
#line 2204
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
  done: 
#line 2208
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval;
#line 2209
  bsg_job->reply_len = 16U;
#line 2212
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2213
  return;
}
}
#line 2222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct scsi_cmnd *cp ;
  sts_entry_t *sts ;
  struct sts_entry_24xx *sts24 ;
  uint16_t comp_status ;
  uint16_t scsi_status ;
  uint16_t ox_id ;
  uint8_t lscsi_status ;
  int32_t resid ;
  uint32_t sense_len ;
  uint32_t par_sense_len ;
  uint32_t rsp_info_len ;
  uint32_t resid_len ;
  uint32_t fw_resid_len ;
  uint8_t *rsp_info ;
  uint8_t *sense_data ;
  struct qla_hw_data *ha ;
  uint32_t handle ;
  uint16_t que ;
  struct req_que *req ;
  int logit ;
  int res ;
  uint16_t state_flags ;
  long tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 2237
  ha = vha->hw;
#line 2241
  logit = 1;
#line 2242
  res = 0;
#line 2243
  state_flags = 0U;
#line 2245
  sts = (sts_entry_t *)pkt;
#line 2246
  sts24 = (struct sts_entry_24xx *)pkt;
#line 2247
  if ((ha->device_type & 134217728U) != 0U) {
#line 2248
    comp_status = sts24->comp_status;
#line 2249
    scsi_status = (unsigned int )sts24->scsi_status & 4095U;
#line 2250
    state_flags = sts24->state_flags;
  } else {
#line 2252
    comp_status = sts->comp_status;
#line 2253
    scsi_status = (unsigned int )sts->scsi_status & 4095U;
  }
#line 2255
  handle = (unsigned int )((unsigned short )sts->handle);
#line 2256
  que = (unsigned short )(sts->handle >> 16);
#line 2257
  req = *(ha->req_q_map + (unsigned long )que);
#line 2260
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2261
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 2263
    sp = (srb_t *)0;
  }
#line 2265
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2266
    ql_dbg(134217728U, vha, 12311, "Invalid status handle (0x%x).\n", sts->handle);
#line 2269
    if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2270
      set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {
#line 2272
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    }
#line 2273
    qla2xxx_wake_dpc(vha);
#line 2274
    return;
  } else {

  }
#line 2277
  tmp = ldv__builtin_expect(((int )state_flags & 2) != 0, 0L);
#line 2277
  if (tmp != 0L) {
#line 2277
    tmp___0 = ldv__builtin_expect((unsigned int )sp->type == 9U, 0L);
#line 2277
    if (tmp___0 != 0L) {
#line 2278
      qla25xx_process_bidir_status_iocb(vha, pkt, req, handle);
#line 2279
      return;
    } else {

    }
  } else {

  }
#line 2283
  if ((unsigned int )comp_status == 0U && (unsigned int )scsi_status == 0U) {
#line 2284
    qla2x00_do_host_ramp_up(vha);
#line 2285
    qla2x00_process_completed_request(vha, req, handle);
#line 2287
    return;
  } else {

  }
#line 2290
  *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2291
  cp = sp->u.scmd.cmd;
#line 2292
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2293
    ql_dbg(134217728U, vha, 12312, "Command already returned (0x%x/%p).\n", sts->handle,
           sp);
#line 2297
    return;
  } else {

  }
#line 2300
  lscsi_status = (unsigned int )((uint8_t )scsi_status) & 254U;
#line 2302
  fcport = sp->fcport;
#line 2304
  ox_id = 0U;
#line 2305
  fw_resid_len = 0U;
#line 2305
  resid_len = fw_resid_len;
#line 2305
  rsp_info_len = resid_len;
#line 2305
  par_sense_len = rsp_info_len;
#line 2305
  sense_len = par_sense_len;
#line 2307
  if ((ha->device_type & 134217728U) != 0U) {
#line 2308
    if (((int )scsi_status & 512) != 0) {
#line 2309
      sense_len = sts24->sense_len;
    } else {

    }
#line 2310
    if (((int )scsi_status & 256) != 0) {
#line 2311
      rsp_info_len = sts24->rsp_data_len;
    } else {

    }
#line 2312
    if (((int )scsi_status & 3072) != 0) {
#line 2313
      resid_len = sts24->rsp_residual_count;
    } else {

    }
#line 2314
    if ((unsigned int )comp_status == 21U) {
#line 2315
      fw_resid_len = sts24->residual_len;
    } else {

    }
#line 2316
    rsp_info = (uint8_t *)(& sts24->data);
#line 2317
    sense_data = (uint8_t *)(& sts24->data);
#line 2318
    host_to_fcp_swap((uint8_t *)(& sts24->data), 28U);
#line 2319
    ox_id = sts24->ox_id;
#line 2320
    par_sense_len = 28U;
  } else {
#line 2322
    if (((int )scsi_status & 512) != 0) {
#line 2323
      sense_len = (uint32_t )sts->req_sense_length;
    } else {

    }
#line 2324
    if (((int )scsi_status & 256) != 0) {
#line 2325
      rsp_info_len = (uint32_t )sts->rsp_info_len;
    } else {

    }
#line 2326
    resid_len = sts->residual_length;
#line 2327
    rsp_info = (uint8_t *)(& sts->rsp_info);
#line 2328
    sense_data = (uint8_t *)(& sts->req_sense_data);
#line 2329
    par_sense_len = 32U;
  }
#line 2333
  if (((int )scsi_status & 256) != 0) {
#line 2335
    if ((ha->device_type & 134217728U) != 0U) {
#line 2336
      sense_data = sense_data + (unsigned long )rsp_info_len;
#line 2337
      par_sense_len = par_sense_len - rsp_info_len;
    } else {

    }
#line 2339
    if (rsp_info_len > 3U && (unsigned int )*(rsp_info + 3UL) != 0U) {
#line 2340
      ql_dbg(134217728U, fcport->vha, 12313, "FCP I/O protocol failure (0x%x/0x%x).\n",
             rsp_info_len, (int )*(rsp_info + 3UL));
#line 2344
      res = 131072;
#line 2345
      goto out;
    } else {

    }
  } else {

  }
#line 2350
  if (((ha->device_type & 134217728U) != 0U && (unsigned int )comp_status == 0U) && ((int )scsi_status & 1024) != 0) {
#line 2352
    comp_status = 7U;
  } else {

  }
#line 2357
  switch ((int )comp_status) {
  case 0: ;
  case 28: ;
#line 2360
  if ((unsigned int )scsi_status == 0U) {
#line 2361
    res = 0;
#line 2362
    goto ldv_61266;
  } else {

  }
#line 2364
  if (((int )scsi_status & 3072) != 0) {
#line 2365
    resid = (int32_t )resid_len;
#line 2366
    scsi_set_resid(cp, resid);
#line 2368
    if ((unsigned int )lscsi_status == 0U) {
#line 2368
      tmp___2 = scsi_bufflen(cp);
#line 2368
      if (tmp___2 - (unsigned int )resid < cp->underflow) {
#line 2371
        tmp___1 = scsi_bufflen(cp);
#line 2371
        ql_dbg(134217728U, fcport->vha, 12314, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp___1);
#line 2376
        res = 458752;
#line 2377
        goto ldv_61266;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2380
  res = (int )lscsi_status;
#line 2382
  if ((unsigned int )lscsi_status == 40U) {
#line 2383
    ql_dbg(134217728U, fcport->vha, 12315, "QUEUE FULL detected.\n");
#line 2385
    goto ldv_61266;
  } else {

  }
#line 2387
  logit = 0;
#line 2388
  if ((unsigned int )lscsi_status != 2U) {
#line 2389
    goto ldv_61266;
  } else {

  }
#line 2391
  memset((void *)cp->sense_buffer, 0, 96UL);
#line 2392
  if (((int )scsi_status & 512) == 0) {
#line 2393
    goto ldv_61266;
  } else {

  }
#line 2395
  qla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
#line 2397
  goto ldv_61266;
  case 21: 
#line 2401
  resid = (int32_t )((ha->device_type & 134217728U) != 0U ? fw_resid_len : resid_len);
#line 2402
  scsi_set_resid(cp, resid);
#line 2403
  if (((int )scsi_status & 2048) != 0) {
#line 2404
    if ((ha->device_type & 134217728U) != 0U && fw_resid_len != resid_len) {
#line 2405
      tmp___3 = scsi_bufflen(cp);
#line 2405
      ql_dbg(134217728U, fcport->vha, 12317, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
             resid, tmp___3);
#line 2410
      res = (int )lscsi_status | 458752;
#line 2411
      goto check_scsi_status;
    } else {

    }
#line 2414
    if ((unsigned int )lscsi_status == 0U) {
#line 2414
      tmp___5 = scsi_bufflen(cp);
#line 2414
      if (tmp___5 - (unsigned int )resid < cp->underflow) {
#line 2417
        tmp___4 = scsi_bufflen(cp);
#line 2417
        ql_dbg(134217728U, fcport->vha, 12318, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp___4);
#line 2422
        res = 458752;
#line 2423
        goto ldv_61266;
      } else {

      }
    } else {

    }
  } else
#line 2425
  if ((unsigned int )lscsi_status != 40U && (unsigned int )lscsi_status != 8U) {
#line 2432
    tmp___6 = scsi_bufflen(cp);
#line 2432
    ql_dbg(134217728U, fcport->vha, 12319, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
           resid, tmp___6);
#line 2437
    res = (int )lscsi_status | 458752;
#line 2438
    goto check_scsi_status;
  } else {
#line 2440
    ql_dbg(134217728U, fcport->vha, 12336, "scsi_status: 0x%x, lscsi_status: 0x%x\n",
           (int )scsi_status, (int )lscsi_status);
  }
#line 2445
  res = (int )lscsi_status;
#line 2446
  logit = 0;
  check_scsi_status: ;
#line 2453
  if ((unsigned int )lscsi_status != 0U) {
#line 2454
    if ((unsigned int )lscsi_status == 40U) {
#line 2455
      ql_dbg(134217728U, fcport->vha, 12320, "QUEUE FULL detected.\n");
#line 2457
      logit = 1;
#line 2458
      goto ldv_61266;
    } else {

    }
#line 2460
    if ((unsigned int )lscsi_status != 2U) {
#line 2461
      goto ldv_61266;
    } else {

    }
#line 2463
    memset((void *)cp->sense_buffer, 0, 96UL);
#line 2464
    if (((int )scsi_status & 512) == 0) {
#line 2465
      goto ldv_61266;
    } else {

    }
#line 2467
    qla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
  } else {

  }
#line 2470
  goto ldv_61266;
  case 41: ;
  case 42: ;
  case 43: ;
  case 1: ;
  case 40: ;
  case 6: ;
  case 4: 
#line 2485
  res = 917504;
#line 2487
  if ((unsigned int )comp_status == 6U) {
#line 2488
    if ((ha->device_type & 134217728U) != 0U) {
#line 2489
      goto ldv_61266;
    } else
#line 2490
    if (((int )sts->status_flags & 8192) == 0) {
#line 2492
      goto ldv_61266;
    } else {

    }
  } else {

  }
#line 2495
  tmp___7 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2495
  ql_dbg(134217728U, fcport->vha, 12321, "Port to be marked lost on fcport=%02x%02x%02x, current port state= %s.\n",
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa,
         port_state_str___1[tmp___7]);
#line 2501
  tmp___8 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2501
  if (tmp___8 == 4) {
#line 2502
    qla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);
  } else {

  }
#line 2503
  goto ldv_61266;
  case 5: 
#line 2506
  res = 524288;
#line 2507
  goto ldv_61266;
  case 12: 
#line 2510
  logit = qla2x00_handle_dif_error(sp, sts24);
#line 2511
  res = cp->result;
#line 2512
  goto ldv_61266;
  case 3: 
#line 2515
  res = 458752;
#line 2517
  if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) || ((((int )ha->fw_attributes_h << 16) | (int )ha->fw_attributes) & 4194304) == 0) {
#line 2518
    goto ldv_61266;
  } else {

  }
#line 2520
  if (((int )state_flags & 16) != 0) {
#line 2521
    if ((unsigned long )(cp->request)->rq_disk != (unsigned long )((struct gendisk *)0)) {
#line 2521
      dev_printk("\f", (struct device  const  *)(& (cp->device)->sdev_gendev), "[%s] Unsupported device \'%s\' found.\n",
                 (char *)(& ((cp->request)->rq_disk)->disk_name), (cp->device)->vendor);
    } else {
#line 2521
      dev_printk("\f", (struct device  const  *)(& (cp->device)->sdev_gendev), "Unsupported device \'%s\' found.\n",
                 (cp->device)->vendor);
    }
  } else {

  }
#line 2524
  goto ldv_61266;
  default: 
#line 2527
  res = 458752;
#line 2528
  goto ldv_61266;
  }
  ldv_61266: ;
  out: ;
#line 2532
  if (logit != 0) {
#line 2533
    tmp___9 = scsi_bufflen(cp);
#line 2533
    ql_dbg(134217728U, fcport->vha, 12322, "FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%d portid=%02x%02x%02x oxid=0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x.\n",
           (int )comp_status, (int )scsi_status, res, vha->host_no, (cp->device)->id,
           (cp->device)->lun, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area,
           (int )fcport->d_id.b.al_pa, (int )ox_id, cp->cmnd, tmp___9, rsp_info_len,
           resid_len, fw_resid_len);
  } else {

  }
#line 2543
  if (res == 0) {
#line 2544
    qla2x00_do_host_ramp_up(vha);
  } else {

  }
#line 2546
  if ((unsigned long )rsp->status_srb == (unsigned long )((srb_t *)0)) {
#line 2547
    (*(sp->done))((void *)ha, (void *)sp, res);
  } else {

  }
#line 2548
  return;
}
}
#line 2558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) 
{ 
  uint8_t sense_sz ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  srb_t *sp ;
  struct scsi_cmnd *cp ;
  uint32_t sense_len ;
  uint8_t *sense_ptr ;
  size_t __len ;
  void *__ret ;

  {
#line 2560
  sense_sz = 0U;
#line 2561
  ha = rsp->hw;
#line 2562
  tmp = pci_get_drvdata(ha->pdev);
#line 2562
  vha = (struct scsi_qla_host *)tmp;
#line 2563
  sp = rsp->status_srb;
#line 2568
  if ((unsigned long )sp == (unsigned long )((srb_t *)0) || sp->u.scmd.request_sense_length == 0U) {
#line 2569
    return;
  } else {

  }
#line 2571
  sense_len = sp->u.scmd.request_sense_length;
#line 2572
  sense_ptr = sp->u.scmd.request_sense_ptr;
#line 2574
  cp = sp->u.scmd.cmd;
#line 2575
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2576
    ql_log(1U, vha, 12325, "cmd is NULL: already returned to OS (sp=%p).\n", sp);
#line 2579
    rsp->status_srb = (srb_t *)0;
#line 2580
    return;
  } else {

  }
#line 2583
  if (sense_len > 60U) {
#line 2584
    sense_sz = 60U;
  } else {
#line 2586
    sense_sz = (uint8_t )sense_len;
  }
#line 2589
  if ((ha->device_type & 134217728U) != 0U) {
#line 2590
    host_to_fcp_swap((uint8_t *)(& pkt->data), 60U);
  } else {

  }
#line 2591
  __len = (size_t )sense_sz;
#line 2591
  __ret = __builtin_memcpy((void *)sense_ptr, (void const   *)(& pkt->data), __len);
#line 2592
  ql_dump_buffer(134348800U, vha, 12332, sense_ptr, (uint32_t )sense_sz);
#line 2595
  sense_len = sense_len - (uint32_t )sense_sz;
#line 2596
  sense_ptr = sense_ptr + (unsigned long )sense_sz;
#line 2598
  sp->u.scmd.request_sense_ptr = sense_ptr;
#line 2599
  sp->u.scmd.request_sense_length = sense_len;
#line 2602
  if (sense_len == 0U) {
#line 2603
    rsp->status_srb = (srb_t *)0;
#line 2604
    (*(sp->done))((void *)ha, (void *)sp, cp->result);
  } else {

  }
#line 2606
  return;
}
}
#line 2614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2x00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , sts_entry_t *pkt ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  char func[11U] ;
  uint16_t que ;
  struct req_que *req ;
  int res ;

  {
#line 2617
  ha = vha->hw;
#line 2618
  func[0] = 'E';
#line 2618
  func[1] = 'R';
#line 2618
  func[2] = 'R';
#line 2618
  func[3] = 'O';
#line 2618
  func[4] = 'R';
#line 2618
  func[5] = '-';
#line 2618
  func[6] = 'I';
#line 2618
  func[7] = 'O';
#line 2618
  func[8] = 'C';
#line 2618
  func[9] = 'B';
#line 2618
  func[10] = '\000';
#line 2619
  que = (unsigned short )(pkt->handle >> 16);
#line 2620
  req = (struct req_que *)0;
#line 2621
  res = 458752;
#line 2623
  ql_dbg(33554432U, vha, 20522, "type of error status in response: 0x%x\n", (int )pkt->entry_status);
#line 2626
  if ((int )((unsigned short )ha->max_req_queues) <= (int )que || (unsigned long )*(ha->req_q_map + (unsigned long )que) == (unsigned long )((struct req_que *)0)) {
#line 2627
    goto fatal;
  } else {

  }
#line 2629
  req = *(ha->req_q_map + (unsigned long )que);
#line 2631
  if (((int )pkt->entry_status & 2) != 0) {
#line 2632
    res = 131072;
  } else {

  }
#line 2634
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2635
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2636
    (*(sp->done))((void *)ha, (void *)sp, res);
#line 2637
    return;
  } else {

  }
  fatal: 
#line 2640
  ql_log(1U, vha, 20528, "Error entry - invalid handle/queue.\n");
#line 2643
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2644
    set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 2646
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 2647
  qla2xxx_wake_dpc(vha);
#line 2648
  return;
}
}
#line 2656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla24xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint32_t mboxes ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;

  {
#line 2661
  ha = vha->hw;
#line 2662
  reg = & (ha->iobase)->isp24;
#line 2665
  mboxes = (uint32_t )((1 << (int )ha->mbx_count) + -1);
#line 2666
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 2667
    ql_dbg(33554432U, vha, 20558, "MBX pointer OLD_ERROR.\n");
  } else {
#line 2669
    mboxes = (ha->mcp)->in_mb;
  }
#line 2672
  ha->flags.mbox_int = 1U;
#line 2673
  ha->mailbox_out[0] = mb0;
#line 2674
  mboxes = mboxes >> 1;
#line 2675
  wptr = & reg->mailbox1;
#line 2677
  cnt = 1U;
#line 2677
  goto ldv_61316;
  ldv_61315: ;
#line 2678
  if ((int )mboxes & 1) {
#line 2679
    ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
  } else {

  }
#line 2681
  mboxes = mboxes >> 1;
#line 2682
  wptr = wptr + 1;
#line 2677
  cnt = (uint16_t )((int )cnt + 1);
  ldv_61316: ;
#line 2677
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 2679
    goto ldv_61315;
  } else {

  }

#line 2684
  return;
}
}
#line 2690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void qla24xx_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct sts_entry_24xx *pkt ;
  struct qla_hw_data *ha ;
  struct device_reg_82xx *reg ;

  {
#line 2694
  ha = vha->hw;
#line 2696
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2697
    return;
  } else {

  }
#line 2699
  goto ldv_61324;
  ldv_61339: 
#line 2700
  pkt = (struct sts_entry_24xx *)rsp->ring_ptr;
#line 2702
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 2703
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 2704
    rsp->ring_index = 0U;
#line 2705
    rsp->ring_ptr = rsp->ring;
  } else {
#line 2707
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 2710
  if ((unsigned int )pkt->entry_status != 0U) {
#line 2711
    qla2x00_error_entry(vha, rsp, (sts_entry_t *)pkt);
#line 2713
    qlt_24xx_process_response_error(vha, pkt);
#line 2715
    ((response_t *)pkt)->signature = 3735936685U;
#line 2716
    __asm__  volatile   ("sfence": : : "memory");
#line 2717
    goto ldv_61324;
  } else {

  }
#line 2720
  switch ((int )pkt->entry_type) {
  case 3: 
#line 2722
  qla2x00_status_entry(vha, rsp, (void *)pkt);
#line 2723
  goto ldv_61326;
  case 16: 
#line 2725
  qla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 2726
  goto ldv_61326;
  case 50: 
#line 2728
  qla24xx_report_id_acquisition(vha, (struct vp_rpt_id_entry_24xx *)pkt);
#line 2730
  goto ldv_61326;
  case 82: 
#line 2732
  qla24xx_logio_entry(vha, rsp->req, (struct logio_entry_24xx *)pkt);
#line 2734
  goto ldv_61326;
  case 20: 
#line 2736
  qla24xx_tm_iocb_entry(vha, rsp->req, (struct tsk_mgmt_entry *)pkt);
#line 2738
  goto ldv_61326;
  case 41: 
#line 2740
  qla24xx_els_ct_entry(vha, rsp->req, pkt, 41);
#line 2741
  goto ldv_61326;
  case 83: 
#line 2743
  qla24xx_els_ct_entry(vha, rsp->req, pkt, 83);
#line 2744
  goto ldv_61326;
  case 84: 
#line 2747
  qlt_24xx_process_atio_queue(vha);
  case 85: ;
  case 18: ;
  case 14: 
#line 2751
  qlt_response_pkt_all_vps(vha, (response_t *)pkt);
#line 2752
  goto ldv_61326;
  case 4: ;
#line 2757
  goto ldv_61326;
  default: 
#line 2760
  ql_dbg(33554432U, vha, 20546, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 2764
  goto ldv_61326;
  }
  ldv_61326: 
#line 2766
  ((response_t *)pkt)->signature = 3735936685U;
#line 2767
  __asm__  volatile   ("sfence": : : "memory");
  ldv_61324: ;
#line 2699
  if ((rsp->ring_ptr)->signature != 3735936685U) {
#line 2701
    goto ldv_61339;
  } else {

  }

#line 2771
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2772
    reg = & (ha->iobase)->isp82;
#line 2773
    writel((unsigned int )rsp->ring_index, (void volatile   *)(& reg->rsp_q_out));
  } else {
#line 2775
    writel((unsigned int )rsp->ring_index, (void volatile   *)rsp->rsp_q_out);
  }
#line 2776
  return;
}
}
#line 2779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla2xxx_check_risc_status(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2783
  ha = vha->hw;
#line 2784
  reg = & (ha->iobase)->isp24;
#line 2786
  if (((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 2787
    return;
  } else {

  }
#line 2789
  rval = 0;
#line 2790
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 2791
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2792
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2793
  cnt = 10000U;
#line 2793
  goto ldv_61350;
  ldv_61349: ;
#line 2795
  if (cnt != 0U) {
#line 2796
    writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2797
    __const_udelay(42950UL);
  } else {
#line 2799
    rval = 256;
  }
#line 2794
  cnt = cnt - 1U;
  ldv_61350: 
#line 2793
  tmp = readl((void const volatile   *)(& reg->iobase_window));
#line 2793
  if ((tmp & 1U) == 0U && rval == 0) {
#line 2796
    goto ldv_61349;
  } else {

  }

#line 2801
  if (rval == 0) {
#line 2802
    goto next_test;
  } else {

  }
#line 2804
  rval = 0;
#line 2805
  writel(3U, (void volatile   *)(& reg->iobase_window));
#line 2806
  cnt = 100U;
#line 2806
  goto ldv_61354;
  ldv_61353: ;
#line 2808
  if (cnt != 0U) {
#line 2809
    writel(3U, (void volatile   *)(& reg->iobase_window));
#line 2810
    __const_udelay(42950UL);
  } else {
#line 2812
    rval = 256;
  }
#line 2807
  cnt = cnt - 1U;
  ldv_61354: 
#line 2806
  tmp___0 = readl((void const volatile   *)(& reg->iobase_window));
#line 2806
  if ((tmp___0 & 1U) == 0U && rval == 0) {
#line 2809
    goto ldv_61353;
  } else {

  }

#line 2814
  if (rval != 0) {
#line 2815
    goto done;
  } else {

  }
  next_test: 
#line 2818
  tmp___1 = readl((void const volatile   *)(& reg->iobase_c8));
#line 2818
  if ((tmp___1 & 8U) != 0U) {
#line 2819
    ql_log(2U, vha, 20556, "Additional code -- 0x55AA.\n");
  } else {

  }
  done: 
#line 2823
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 2824
  readl((void const volatile   *)(& reg->iobase_window));
#line 2825
  return;
}
}
#line 2837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
irqreturn_t qla24xx_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint32_t hccr ;
  uint16_t mb[8U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long tmp___9 ;

  {
#line 2850
  rsp = (struct rsp_que *)dev_id;
#line 2851
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2852
    ql_log(2U, (scsi_qla_host_t *)0, 20569, "%s: NULL response queue pointer.\n",
           "qla24xx_intr_handler");
#line 2854
    return (0);
  } else {

  }
#line 2857
  ha = rsp->hw;
#line 2858
  reg = & (ha->iobase)->isp24;
#line 2859
  status = 0;
#line 2861
  tmp = pci_channel_offline(ha->pdev);
#line 2861
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2861
  if (tmp___0 != 0L) {
#line 2862
    return (1);
  } else {

  }
#line 2864
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2864
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2865
  tmp___2 = pci_get_drvdata(ha->pdev);
#line 2865
  vha = (scsi_qla_host_t *)tmp___2;
#line 2866
  iter = 50UL;
#line 2866
  goto ldv_61388;
  ldv_61387: 
#line 2867
  stat = readl((void const volatile   *)(& reg->host_status));
#line 2868
  if ((stat & 256U) != 0U) {
#line 2869
    tmp___3 = pci_channel_offline(ha->pdev);
#line 2869
    tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 2869
    if (tmp___4 != 0L) {
#line 2870
      goto ldv_61375;
    } else {

    }
#line 2872
    hccr = readl((void const volatile   *)(& reg->hccr));
#line 2874
    ql_log(1U, vha, 20555, "RISC paused -- HCCR=%x, Dumping firmware.\n", hccr);
#line 2878
    qla2xxx_check_risc_status(vha);
#line 2880
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 2881
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2882
    goto ldv_61375;
  } else
#line 2883
  if ((stat & 32768U) == 0U) {
#line 2884
    goto ldv_61375;
  } else {

  }
#line 2886
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 2891
  qla24xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2892
  status = status | 1;
#line 2894
  goto ldv_61380;
  case 18U: 
#line 2896
  mb[0] = (unsigned short )(stat >> 16);
#line 2897
  mb[1] = readw((void const volatile   *)(& reg->mailbox1));
#line 2898
  mb[2] = readw((void const volatile   *)(& reg->mailbox2));
#line 2899
  mb[3] = readw((void const volatile   *)(& reg->mailbox3));
#line 2900
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2901
  goto ldv_61380;
  case 19U: ;
  case 20U: 
#line 2904
  qla24xx_process_response_queue(vha, rsp);
#line 2905
  goto ldv_61380;
  case 28U: 
#line 2907
  qlt_24xx_process_atio_queue(vha);
#line 2908
  goto ldv_61380;
  case 29U: 
#line 2910
  qlt_24xx_process_atio_queue(vha);
#line 2911
  qla24xx_process_response_queue(vha, rsp);
#line 2912
  goto ldv_61380;
  default: 
#line 2914
  ql_dbg(33554432U, vha, 20559, "Unrecognized interrupt type (%d).\n", stat * 255U);
#line 2916
  goto ldv_61380;
  }
  ldv_61380: 
#line 2918
  writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2919
  __readl((void const volatile   *)(& reg->hccr));
#line 2920
  tmp___5 = ldv__builtin_expect((ha->device_type & 32768U) != 0U, 0L);
#line 2920
  if (tmp___5 != 0L) {
#line 2920
    tmp___7 = 1;
  } else {
#line 2920
    tmp___6 = ldv__builtin_expect((ha->device_type & 65536U) != 0U, 0L);
#line 2920
    if (tmp___6 != 0L) {
#line 2920
      tmp___7 = 1;
    } else {
#line 2920
      tmp___7 = 0;
    }
  }
#line 2920
  if (tmp___7 != 0) {
#line 2920
    tmp___8 = ldv__builtin_expect((unsigned int )(ha->pdev)->revision == 1U, 0L);
#line 2920
    if (tmp___8 != 0L) {
#line 2921
      __const_udelay(17500UL);
    } else {

    }
  } else {

  }
  ldv_61388: 
#line 2866
  tmp___9 = iter;
#line 2866
  iter = iter - 1UL;
#line 2866
  if (tmp___9 != 0UL) {
#line 2868
    goto ldv_61387;
  } else {

  }
  ldv_61375: 
#line 2923
  qla2x00_handle_mbx_completion(ha, status);
#line 2924
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2926
  return (1);
}
}
#line 2930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static irqreturn_t qla24xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  struct scsi_qla_host *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 2938
  rsp = (struct rsp_que *)dev_id;
#line 2939
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2940
    ql_log(2U, (scsi_qla_host_t *)0, 20570, "%s: NULL response queue pointer.\n",
           "qla24xx_msix_rsp_q");
#line 2942
    return (0);
  } else {

  }
#line 2944
  ha = rsp->hw;
#line 2945
  reg = & (ha->iobase)->isp24;
#line 2947
  tmp = spinlock_check(& ha->hardware_lock);
#line 2947
  flags = _raw_spin_lock_irqsave(tmp);
#line 2949
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2949
  vha = (struct scsi_qla_host *)tmp___0;
#line 2950
  qla24xx_process_response_queue(vha, rsp);
#line 2951
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2952
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2953
    __readl((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 2955
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2957
  return (1);
}
}
#line 2961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static irqreturn_t qla25xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 2968
  rsp = (struct rsp_que *)dev_id;
#line 2969
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2970
    ql_log(2U, (scsi_qla_host_t *)0, 20571, "%s: NULL response queue pointer.\n",
           "qla25xx_msix_rsp_q");
#line 2972
    return (0);
  } else {

  }
#line 2974
  ha = rsp->hw;
#line 2977
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2978
    reg = & (ha->iobase)->isp24;
#line 2979
    tmp = spinlock_check(& ha->hardware_lock);
#line 2979
    flags = _raw_spin_lock_irqsave(tmp);
#line 2980
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 2981
    __readl((void const volatile   *)(& reg->hccr));
#line 2982
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2984
  queue_work_on((int )rsp->id + -1, ha->wq, & rsp->q_work);
#line 2986
  return (1);
}
}
#line 2990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static irqreturn_t qla24xx_msix_default(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_24xx *reg ;
  int status ;
  uint32_t stat ;
  uint32_t hccr ;
  uint16_t mb[8U] ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 3002
  rsp = (struct rsp_que *)dev_id;
#line 3003
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3004
    ql_log(2U, (scsi_qla_host_t *)0, 20572, "%s: NULL response queue pointer.\n",
           "qla24xx_msix_default");
#line 3006
    return (0);
  } else {

  }
#line 3008
  ha = rsp->hw;
#line 3009
  reg = & (ha->iobase)->isp24;
#line 3010
  status = 0;
#line 3012
  tmp = spinlock_check(& ha->hardware_lock);
#line 3012
  flags = _raw_spin_lock_irqsave(tmp);
#line 3013
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 3013
  vha = (scsi_qla_host_t *)tmp___0;
#line 3015
  stat = readl((void const volatile   *)(& reg->host_status));
#line 3016
  if ((stat & 256U) != 0U) {
#line 3017
    tmp___1 = pci_channel_offline(ha->pdev);
#line 3017
    tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 3017
    if (tmp___2 != 0L) {
#line 3018
      goto ldv_61431;
    } else {

    }
#line 3020
    hccr = readl((void const volatile   *)(& reg->hccr));
#line 3022
    ql_log(2U, vha, 20560, "RISC paused -- HCCR=%x, Dumping firmware.\n", hccr);
#line 3026
    qla2xxx_check_risc_status(vha);
#line 3028
    (*((ha->isp_ops)->fw_dump))(vha, 1);
#line 3029
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3030
    goto ldv_61431;
  } else
#line 3031
  if ((stat & 32768U) == 0U) {
#line 3032
    goto ldv_61431;
  } else {

  }
#line 3034
  switch (stat & 255U) {
  case 1U: ;
  case 2U: ;
  case 16U: ;
  case 17U: 
#line 3039
  qla24xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 3040
  status = status | 1;
#line 3042
  goto ldv_61436;
  case 18U: 
#line 3044
  mb[0] = (unsigned short )(stat >> 16);
#line 3045
  mb[1] = readw((void const volatile   *)(& reg->mailbox1));
#line 3046
  mb[2] = readw((void const volatile   *)(& reg->mailbox2));
#line 3047
  mb[3] = readw((void const volatile   *)(& reg->mailbox3));
#line 3048
  qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 3049
  goto ldv_61436;
  case 19U: ;
  case 20U: 
#line 3052
  qla24xx_process_response_queue(vha, rsp);
#line 3053
  goto ldv_61436;
  case 28U: 
#line 3055
  qlt_24xx_process_atio_queue(vha);
#line 3056
  goto ldv_61436;
  case 29U: 
#line 3058
  qlt_24xx_process_atio_queue(vha);
#line 3059
  qla24xx_process_response_queue(vha, rsp);
#line 3060
  goto ldv_61436;
  default: 
#line 3062
  ql_dbg(33554432U, vha, 20561, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 3064
  goto ldv_61436;
  }
  ldv_61436: 
#line 3066
  writel(2684354560U, (void volatile   *)(& reg->hccr));
  ldv_61431: 
#line 3068
  qla2x00_handle_mbx_completion(ha, status);
#line 3069
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3071
  return (1);
}
}
#line 3081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static struct qla_init_msix_entry msix_entries[3U]  = {      {"qla2xxx (default)", & qla24xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla24xx_msix_rsp_q}, 
        {"qla2xxx (multiq)", & qla25xx_msix_rsp_q}};
#line 3087 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static struct qla_init_msix_entry qla82xx_msix_entries[2U]  = {      {"qla2xxx (default)", & qla82xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla82xx_msix_rsp_q}};
#line 3092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static struct qla_init_msix_entry qla83xx_msix_entries[3U]  = {      {"qla2xxx (default)", & qla24xx_msix_default}, 
        {"qla2xxx (rsp_q)", & qla24xx_msix_rsp_q}, 
        {"qla2xxx (atio_q)", & qla83xx_msix_atio_q}};
#line 3099 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static void qla24xx_disable_msix(struct qla_hw_data *ha ) 
{ 
  int i ;
  struct qla_msix_entry *qentry ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 3103
  tmp = pci_get_drvdata(ha->pdev);
#line 3103
  vha = (scsi_qla_host_t *)tmp;
#line 3105
  i = 0;
#line 3105
  goto ldv_61456;
  ldv_61455: 
#line 3106
  qentry = ha->msix_entries + (unsigned long )i;
#line 3107
  if (qentry->have_irq != 0) {
#line 3108
    free_irq(qentry->vector, (void *)qentry->rsp);
  } else {

  }
#line 3105
  i = i + 1;
  ldv_61456: ;
#line 3105
  if ((int )ha->msix_count > i) {
#line 3107
    goto ldv_61455;
  } else {

  }
#line 3110
  pci_disable_msix(ha->pdev);
#line 3111
  kfree((void const   *)ha->msix_entries);
#line 3112
  ha->msix_entries = (struct qla_msix_entry *)0;
#line 3113
  ha->flags.msix_enabled = 0U;
#line 3114
  ql_dbg(1073741824U, vha, 66, "Disabled the MSI.\n");
#line 3116
  return;
}
}
#line 3119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
static int qla24xx_enable_msix(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 
  int i ;
  int ret ;
  struct msix_entry *entries ;
  struct qla_msix_entry *qentry ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 3125
  tmp = pci_get_drvdata(ha->pdev);
#line 3125
  vha = (scsi_qla_host_t *)tmp;
#line 3127
  tmp___0 = kzalloc((unsigned long )ha->msix_count * 8UL, 208U);
#line 3127
  entries = (struct msix_entry *)tmp___0;
#line 3129
  if ((unsigned long )entries == (unsigned long )((struct msix_entry *)0)) {
#line 3130
    ql_log(1U, vha, 188, "Failed to allocate memory for msix_entry.\n");
#line 3132
    return (-12);
  } else {

  }
#line 3135
  i = 0;
#line 3135
  goto ldv_61468;
  ldv_61467: 
#line 3136
  (entries + (unsigned long )i)->entry = (u16 )i;
#line 3135
  i = i + 1;
  ldv_61468: ;
#line 3135
  if ((int )ha->msix_count > i) {
#line 3137
    goto ldv_61467;
  } else {

  }
#line 3138
  ret = pci_enable_msix(ha->pdev, entries, (int )ha->msix_count);
#line 3139
  if (ret != 0) {
#line 3140
    if (ret <= 1) {
#line 3141
      goto msix_failed;
    } else {

    }
#line 3143
    ql_log(1U, vha, 198, "MSI-X: Failed to enable support -- %d/%d\n Retry with %d vectors.\n",
           (int )ha->msix_count, ret, ret);
#line 3147
    ha->msix_count = (uint16_t )ret;
#line 3148
    ret = pci_enable_msix(ha->pdev, entries, (int )ha->msix_count);
#line 3149
    if (ret != 0) {
      msix_failed: 
#line 3151
      ql_log(0U, vha, 199, "MSI-X: Failed to enable support, giving   up -- %d/%d.\n",
             (int )ha->msix_count, ret);
#line 3155
      goto msix_out;
    } else {

    }
#line 3157
    ha->max_rsp_queues = (unsigned int )((uint8_t )ha->msix_count) + 255U;
  } else {

  }
#line 3159
  tmp___1 = kzalloc((unsigned long )ha->msix_count * 24UL, 208U);
#line 3159
  ha->msix_entries = (struct qla_msix_entry *)tmp___1;
#line 3161
  if ((unsigned long )ha->msix_entries == (unsigned long )((struct qla_msix_entry *)0)) {
#line 3162
    ql_log(0U, vha, 200, "Failed to allocate memory for ha->msix_entries.\n");
#line 3164
    ret = -12;
#line 3165
    goto msix_out;
  } else {

  }
#line 3167
  ha->flags.msix_enabled = 1U;
#line 3169
  i = 0;
#line 3169
  goto ldv_61473;
  ldv_61472: 
#line 3170
  qentry = ha->msix_entries + (unsigned long )i;
#line 3171
  qentry->vector = (entries + (unsigned long )i)->vector;
#line 3172
  qentry->entry = (entries + (unsigned long )i)->entry;
#line 3173
  qentry->have_irq = 0;
#line 3174
  qentry->rsp = (struct rsp_que *)0;
#line 3169
  i = i + 1;
  ldv_61473: ;
#line 3169
  if ((int )ha->msix_count > i) {
#line 3171
    goto ldv_61472;
  } else {

  }
#line 3178
  i = 0;
#line 3178
  goto ldv_61476;
  ldv_61475: 
#line 3179
  qentry = ha->msix_entries + (unsigned long )i;
#line 3180
  if (ql2x_ini_mode != 2 && ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 3181
    ret = request_irq(qentry->vector, qla83xx_msix_entries[i].handler, 0UL, qla83xx_msix_entries[i].name,
                      (void *)rsp);
  } else
#line 3184
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3185
    ret = request_irq(qentry->vector, qla82xx_msix_entries[i].handler, 0UL, qla82xx_msix_entries[i].name,
                      (void *)rsp);
  } else {
#line 3189
    ret = request_irq(qentry->vector, msix_entries[i].handler, 0UL, msix_entries[i].name,
                      (void *)rsp);
  }
#line 3193
  if (ret != 0) {
#line 3194
    ql_log(0U, vha, 203, "MSI-X: unable to register handler -- %x/%d.\n", qentry->vector,
           ret);
#line 3197
    qla24xx_disable_msix(ha);
#line 3198
    ha->mqenable = 0U;
#line 3199
    goto msix_out;
  } else {

  }
#line 3201
  qentry->have_irq = 1;
#line 3202
  qentry->rsp = rsp;
#line 3203
  rsp->msix = qentry;
#line 3178
  i = i + 1;
  ldv_61476: ;
#line 3178
  if ((int )ha->msix_count > i) {
#line 3180
    goto ldv_61475;
  } else {

  }

#line 3207
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 3208
    if (((unsigned long )ha->msixbase != (unsigned long )((device_reg_t *)0) && (unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0)) && ((unsigned int )ha->max_rsp_queues > 1U || (unsigned int )ha->max_req_queues > 1U)) {
#line 3210
      ha->mqenable = 1U;
    } else {

    }
  } else
#line 3212
  if ((unsigned long )ha->mqiobase != (unsigned long )((device_reg_t *)0) && ((unsigned int )ha->max_rsp_queues > 1U || (unsigned int )ha->max_req_queues > 1U)) {
#line 3214
    ha->mqenable = 1U;
  } else {

  }
#line 3215
  ql_dbg(1048576U, vha, 49157, "mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",
         ha->mqiobase, (int )ha->max_rsp_queues, (int )ha->max_req_queues);
#line 3218
  ql_dbg(1073741824U, vha, 85, "mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",
         ha->mqiobase, (int )ha->max_rsp_queues, (int )ha->max_req_queues);
  msix_out: 
#line 3223
  kfree((void const   *)entries);
#line 3224
  return (ret);
}
}
#line 3228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int qla2x00_request_irqs(struct qla_hw_data *ha , struct rsp_que *rsp ) 
{ 
  int ret ;
  device_reg_t *reg ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 3231
  reg = ha->iobase;
#line 3232
  tmp = pci_get_drvdata(ha->pdev);
#line 3232
  vha = (scsi_qla_host_t *)tmp;
#line 3235
  if ((((((ha->device_type & 256U) == 0U && (ha->device_type & 2048U) == 0U) && (ha->device_type & 4096U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) && (ha->device_type & 131072U) == 0U) {
#line 3237
    goto skip_msi;
  } else {

  }
#line 3239
  if ((unsigned int )(ha->pdev)->subsystem_vendor == 4156U && (((unsigned int )(ha->pdev)->subsystem_device == 28736U || (unsigned int )(ha->pdev)->subsystem_device == 28737U) || (unsigned int )(ha->pdev)->subsystem_device == 5893U)) {
#line 3243
    ql_log(1U, vha, 52, "MSI-X: Unsupported ISP 2432 SSVID/SSDID (0x%X,0x%X).\n",
           (int )(ha->pdev)->subsystem_vendor, (int )(ha->pdev)->subsystem_device);
#line 3247
    goto skip_msi;
  } else {

  }
#line 3250
  if ((ha->device_type & 256U) != 0U && (unsigned int )(ha->pdev)->revision <= 2U) {
#line 3251
    ql_log(1U, vha, 53, "MSI-X; Unsupported ISP2432 (0x%X, 0x%X).\n", (int )(ha->pdev)->revision,
           3);
#line 3254
    goto skip_msix;
  } else {

  }
#line 3257
  ret = qla24xx_enable_msix(ha, rsp);
#line 3258
  if (ret == 0) {
#line 3259
    ql_dbg(1073741824U, vha, 54, "MSI-X: Enabled (0x%X, 0x%X).\n", (int )ha->chip_revision,
           (int )ha->fw_attributes);
#line 3262
    goto clear_risc_ints;
  } else {

  }
#line 3264
  ql_log(2U, vha, 55, "MSI-X Falling back-to MSI mode -%d.\n", ret);
  skip_msix: ;
#line 3268
  if (((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && (ha->device_type & 2048U) == 0U) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 131072U) == 0U) {
#line 3270
    goto skip_msi;
  } else {

  }
#line 3272
  ret = pci_enable_msi_block(ha->pdev, 1U);
#line 3273
  if (ret == 0) {
#line 3274
    ql_dbg(1073741824U, vha, 56, "MSI: Enabled.\n");
#line 3276
    ha->flags.msi_enabled = 1U;
  } else {
#line 3278
    ql_log(1U, vha, 57, "MSI-X; Falling back-to INTa mode -- %d.\n", ret);
  }
#line 3282
  if (*((unsigned long *)ha + 2UL) == 0UL && (ha->device_type & 16384U) != 0U) {
#line 3283
    return (258);
  } else {

  }
  skip_msi: 
#line 3287
  ret = request_irq((ha->pdev)->irq, (ha->isp_ops)->intr_handler, *((unsigned long *)ha + 2UL) != 0UL ? 0UL : 128UL,
                    "qla2xxx", (void *)rsp);
#line 3290
  if (ret != 0) {
#line 3291
    ql_log(1U, vha, 58, "Failed to reserve interrupt %d already in use.\n", (ha->pdev)->irq);
#line 3294
    goto fail;
  } else
#line 3295
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3296
    ql_dbg(1073741824U, vha, 293, "INTa mode: Enabled.\n");
#line 3298
    ha->flags.mr_intr_valid = 1U;
  } else {

  }
  clear_risc_ints: 
#line 3303
  spin_lock_irq(& ha->hardware_lock);
#line 3304
  if ((ha->device_type & 134217728U) == 0U) {
#line 3305
    writew(0, (void volatile   *)(& reg->isp.semaphore));
  } else {

  }
#line 3306
  spin_unlock_irq(& ha->hardware_lock);
  fail: ;
#line 3309
  return (ret);
}
}
#line 3313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void qla2x00_free_irqs(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;

  {
#line 3315
  ha = vha->hw;
#line 3322
  if ((unsigned long )ha->rsp_q_map == (unsigned long )((struct rsp_que **)0) || (unsigned long )*(ha->rsp_q_map) == (unsigned long )((struct rsp_que *)0)) {
#line 3323
    return;
  } else {

  }
#line 3324
  rsp = *(ha->rsp_q_map);
#line 3326
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3327
    qla24xx_disable_msix(ha);
  } else
#line 3328
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3329
    free_irq((ha->pdev)->irq, (void *)rsp);
#line 3330
    pci_disable_msi(ha->pdev);
  } else {
#line 3332
    free_irq((ha->pdev)->irq, (void *)rsp);
  }
#line 3333
  return;
}
}
#line 3336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int qla25xx_request_irq(struct rsp_que *rsp ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_init_msix_entry *intr ;
  struct qla_msix_entry *msix ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int ret ;

  {
#line 3338
  ha = rsp->hw;
#line 3339
  intr = (struct qla_init_msix_entry *)(& msix_entries) + 2UL;
#line 3340
  msix = rsp->msix;
#line 3341
  tmp = pci_get_drvdata(ha->pdev);
#line 3341
  vha = (scsi_qla_host_t *)tmp;
#line 3344
  ret = request_irq(msix->vector, intr->handler, 0UL, intr->name, (void *)rsp);
#line 3345
  if (ret != 0) {
#line 3346
    ql_log(0U, vha, 230, "MSI-X: Unable to register handler -- %x/%d.\n", msix->vector,
           ret);
#line 3349
    return (ret);
  } else {

  }
#line 3351
  msix->have_irq = 1;
#line 3352
  msix->rsp = rsp;
#line 3353
  return (ret);
}
}
#line 3357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void choose_timer_6(struct timer_list *timer ) 
{ 


  {
#line 3358
  LDV_IN_INTERRUPT = 2;
#line 3359
  (*(timer->function))(timer->data);
#line 3360
  LDV_IN_INTERRUPT = 1;
#line 3361
  ldv_timer_state_6 = 2;
#line 3362
  return;
}
}
#line 3365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int reg_timer_6(struct timer_list *timer ) 
{ 


  {
#line 3366
  ldv_timer_list_6 = timer;
#line 3367
  ldv_timer_state_6 = 1;
#line 3368
  return (0);
}
}
#line 3371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 3372
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_6) {
#line 3373
    ldv_timer_state_6 = 0;
#line 3374
    return;
  } else {

  }
#line 3376
  return;
}
}
#line 3379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3379
  if ((unsigned long )ldv_timer_list_6 == (unsigned long )timer) {
#line 3380
    if (ldv_timer_state_6 == 2 || pending_flag != 0) {
#line 3381
      ldv_timer_list_6 = timer;
#line 3382
      ldv_timer_list_6->data = data;
#line 3383
      ldv_timer_state_6 = 1;
    } else {

    }
#line 3385
    return;
  } else {

  }
#line 3387
  reg_timer_6(timer);
#line 3388
  ldv_timer_list_6->data = data;
#line 3389
  return;
}
}
#line 3391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int ldv_del_timer_31(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 3395
  tmp = del_timer(ldv_func_arg1);
#line 3395
  ldv_func_res = tmp;
#line 3397
  disable_suitable_timer_7(ldv_func_arg1);
#line 3399
  return (ldv_func_res);
}
}
#line 3402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_isr.o.c.prepared"
int ldv_scsi_add_host_with_dma_32(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 3406
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 3406
  ldv_func_res = tmp;
#line 3408
  if (ldv_func_res == 0) {
#line 3409
    ldv_state_variable_72 = 1;
#line 3409
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 3413
  return (ldv_func_res);
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_35(struct timer_list *ldv_func_arg1 ) ;
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void choose_timer_7(struct timer_list *timer ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_36(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 533 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_get_sym_node_name(scsi_qla_host_t *vha , uint8_t *snn ) ;
#line 986 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_rff_id(struct scsi_qla_host *vha , struct ct_sns_req *ct_req ) ;
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) ;
#line 310
static int qla2x00_sns_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 311
static int qla2x00_sns_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 312
static int qla2x00_sns_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) ;
#line 313
static int qla2x00_sns_rft_id(scsi_qla_host_t *vha ) ;
#line 314
static int qla2x00_sns_rnn_id(scsi_qla_host_t *vha ) ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void *qla2x00_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;

  {
#line 327
  ha = vha->hw;
#line 330
  ms_pkt = ha->ms_iocb;
#line 331
  memset((void *)ms_pkt, 0, 64UL);
#line 333
  ms_pkt->entry_type = 41U;
#line 334
  ms_pkt->entry_count = 1U;
#line 335
  if ((int )ha->device_type < 0) {
#line 335
    ms_pkt->loop_id.extended = 128U;
  } else {
#line 335
    ms_pkt->loop_id.id.standard = 128U;
  }
#line 336
  ms_pkt->control_flags = 34U;
#line 337
  ms_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 338
  ms_pkt->cmd_dsd_count = 1U;
#line 339
  ms_pkt->total_dsd_count = 2U;
#line 340
  ms_pkt->rsp_bytecount = rsp_size;
#line 341
  ms_pkt->req_bytecount = req_size;
#line 343
  ms_pkt->dseg_req_address[0] = (unsigned int )ha->ct_sns_dma;
#line 344
  ms_pkt->dseg_req_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 345
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 347
  ms_pkt->dseg_rsp_address[0] = (unsigned int )ha->ct_sns_dma;
#line 348
  ms_pkt->dseg_rsp_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 349
  ms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;
#line 351
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 353
  return ((void *)ms_pkt);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void *qla24xx_prep_ms_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct qla_hw_data *ha ;
  struct ct_entry_24xx *ct_pkt ;

  {
#line 367
  ha = vha->hw;
#line 370
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 371
  memset((void *)ct_pkt, 0, 64UL);
#line 373
  ct_pkt->entry_type = 41U;
#line 374
  ct_pkt->entry_count = 1U;
#line 375
  ct_pkt->nport_handle = 2044U;
#line 376
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 377
  ct_pkt->cmd_dsd_count = 1U;
#line 378
  ct_pkt->rsp_dsd_count = 1U;
#line 379
  ct_pkt->rsp_byte_count = rsp_size;
#line 380
  ct_pkt->cmd_byte_count = req_size;
#line 382
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 383
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 384
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 386
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 387
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 388
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 389
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 391
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 393
  return ((void *)ct_pkt);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static struct ct_sns_req *qla2x00_prep_ct_req(struct ct_sns_pkt *p , uint16_t cmd ,
                                                       uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 407
  memset((void *)p, 0, 8208UL);
#line 409
  p->p.req.header.revision = 1U;
#line 410
  p->p.req.header.gs_type = 252U;
#line 411
  p->p.req.header.gs_subtype = 2U;
#line 412
  tmp = __fswab16((int )cmd);
#line 412
  p->p.req.command = tmp;
#line 413
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 413
  p->p.req.max_rsp_size = tmp___0;
#line 415
  return (& p->p.req);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_chk_ms_status(scsi_qla_host_t *vha , ms_iocb_entry_t *ms_pkt ,
                                 struct ct_sns_rsp *ct_rsp , char const   *routine ) 
{ 
  int rval ;
  uint16_t comp_status ;
  struct qla_hw_data *ha ;

  {
#line 424
  ha = vha->hw;
#line 426
  rval = 258;
#line 427
  if ((unsigned int )ms_pkt->entry_status != 0U) {
#line 428
    ql_dbg(268435456U, vha, 8241, "%s failed, error status (%x) on port_id: %02x%02x%02x.\n",
           routine, (int )ms_pkt->entry_status, (int )vha->d_id.b.domain, (int )vha->d_id.b.area,
           (int )vha->d_id.b.al_pa);
  } else {
#line 433
    if ((ha->device_type & 134217728U) != 0U) {
#line 434
      comp_status = ((struct ct_entry_24xx *)ms_pkt)->comp_status;
    } else {
#line 437
      comp_status = ms_pkt->status;
    }
#line 438
    switch ((int )comp_status) {
    case 0: ;
    case 21: ;
    case 7: ;
#line 442
    if ((unsigned int )ct_rsp->header.response != 640U) {
#line 444
      ql_dbg(268566528U, vha, 8311, "%s failed rejected request on port_id: %02x%02x%02x.\n",
             routine, (int )vha->d_id.b.domain, (int )vha->d_id.b.area, (int )vha->d_id.b.al_pa);
#line 449
      ql_dump_buffer(268566528U, vha, 8312, (uint8_t *)(& ct_rsp->header), 16U);
#line 452
      rval = 1;
    } else {
#line 454
      rval = 0;
    }
#line 455
    goto ldv_60765;
    default: 
#line 457
    ql_dbg(268435456U, vha, 8243, "%s failed, completion status (%x) on port_id: %02x%02x%02x.\n",
           routine, (int )comp_status, (int )vha->d_id.b.domain, (int )vha->d_id.b.area,
           (int )vha->d_id.b.al_pa);
#line 462
    goto ldv_60765;
    }
    ldv_60765: ;
  }
#line 465
  return (rval);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___1 ;

  {
#line 483
  ha = vha->hw;
#line 485
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 486
    tmp = qla2x00_sns_ga_nxt(vha, fcport);
#line 486
    return (tmp);
  } else {

  }
#line 490
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 636U);
#line 490
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 494
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 256, 636);
#line 496
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 499
  ct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;
#line 500
  ct_req->req.port_id.port_id[1] = fcport->d_id.b.area;
#line 501
  ct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;
#line 504
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 506
  if (rval != 0) {
#line 508
    ql_dbg(268435456U, vha, 8290, "GA_NXT issue IOCB failed (%d).\n", rval);
  } else {
#line 510
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GA_NXT");
#line 510
    if (tmp___1 != 0) {
#line 512
      rval = 258;
    } else {
#line 515
      fcport->d_id.b.domain = ct_rsp->rsp.ga_nxt.port_id[0];
#line 516
      fcport->d_id.b.area = ct_rsp->rsp.ga_nxt.port_id[1];
#line 517
      fcport->d_id.b.al_pa = ct_rsp->rsp.ga_nxt.port_id[2];
#line 519
      __len = 8UL;
#line 519
      if (__len > 63UL) {
#line 519
        __ret = __memcpy((void *)(& fcport->node_name), (void const   *)(& ct_rsp->rsp.ga_nxt.node_name),
                         __len);
      } else {
#line 519
        __ret = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& ct_rsp->rsp.ga_nxt.node_name),
                                 __len);
      }
#line 521
      __len___0 = 8UL;
#line 521
      if (__len___0 > 63UL) {
#line 521
        __ret___0 = __memcpy((void *)(& fcport->port_name), (void const   *)(& ct_rsp->rsp.ga_nxt.port_name),
                             __len___0);
      } else {
#line 521
        __ret___0 = __builtin_memcpy((void *)(& fcport->port_name), (void const   *)(& ct_rsp->rsp.ga_nxt.port_name),
                                     __len___0);
      }
#line 524
      fcport->fc4_type = (int )ct_rsp->rsp.ga_nxt.fc4_types[2] & 1 ? 8U : 0U;
#line 527
      if ((unsigned int )ct_rsp->rsp.ga_nxt.port_type != 1U && (unsigned int )ct_rsp->rsp.ga_nxt.port_type != 2U) {
#line 529
        fcport->d_id.b.domain = 240U;
      } else {

      }
#line 531
      ql_dbg(268435456U, vha, 8291, "GA_NXT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
             (uint8_t *)(& fcport->node_name), (uint8_t *)(& fcport->port_name), (int )fcport->d_id.b.domain,
             (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
    }
  }
#line 539
  return (rval);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static int qla2x00_gid_pt_rsp_size(scsi_qla_host_t *vha ) 
{ 


  {
#line 545
  return (((int )(vha->hw)->max_fibre_devices + 4) * 4);
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct ct_sns_gid_pt_data *gid_data ;
  struct qla_hw_data *ha ;
  uint16_t gid_pt_rsp_size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 568
  ha = vha->hw;
#line 571
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 572
    tmp = qla2x00_sns_gid_pt(vha, list);
#line 572
    return (tmp);
  } else {

  }
#line 574
  gid_data = (struct ct_sns_gid_pt_data *)0;
#line 575
  tmp___0 = qla2x00_gid_pt_rsp_size(vha);
#line 575
  gid_pt_rsp_size = (uint16_t )tmp___0;
#line 578
  tmp___1 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, (uint32_t )gid_pt_rsp_size);
#line 578
  ms_pkt = (ms_iocb_entry_t *)tmp___1;
#line 582
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 417, (int )gid_pt_rsp_size);
#line 583
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 586
  ct_req->req.gid_pt.port_type = 127U;
#line 589
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 591
  if (rval != 0) {
#line 593
    ql_dbg(268435456U, vha, 8277, "GID_PT issue IOCB failed (%d).\n", rval);
  } else {
#line 595
    tmp___2 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GID_PT");
#line 595
    if (tmp___2 != 0) {
#line 597
      rval = 258;
    } else {
#line 600
      i = 0U;
#line 600
      goto ldv_60799;
      ldv_60798: 
#line 601
      gid_data = (struct ct_sns_gid_pt_data *)(& ct_rsp->rsp.gid_pt.entries) + (unsigned long )i;
#line 602
      (list + (unsigned long )i)->d_id.b.domain = gid_data->port_id[0];
#line 603
      (list + (unsigned long )i)->d_id.b.area = gid_data->port_id[1];
#line 604
      (list + (unsigned long )i)->d_id.b.al_pa = gid_data->port_id[2];
#line 605
      memset((void *)(& (list + (unsigned long )i)->fabric_port_name), 0, 8UL);
#line 606
      (list + (unsigned long )i)->fp_speed = 65535U;
#line 609
      if ((int )((signed char )gid_data->control_byte) < 0) {
#line 610
        (list + (unsigned long )i)->d_id.b.rsvd_1 = gid_data->control_byte;
#line 611
        goto ldv_60797;
      } else {

      }
#line 600
      i = (uint16_t )((int )i + 1);
      ldv_60799: ;
#line 600
      if ((int )ha->max_fibre_devices > (int )i) {
#line 602
        goto ldv_60798;
      } else {

      }
      ldv_60797: ;
#line 621
      if ((int )ha->max_fibre_devices == (int )i) {
#line 622
        rval = 258;
      } else {

      }
    }
  }
#line 625
  return (rval);
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 638
  rval = 0;
#line 644
  ha = vha->hw;
#line 646
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 647
    tmp = qla2x00_sns_gpn_id(vha, list);
#line 647
    return (tmp);
  } else {

  }
#line 649
  i = 0U;
#line 649
  goto ldv_60815;
  ldv_60814: 
#line 652
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 652
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 656
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 274, 24);
#line 658
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 661
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 662
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 663
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 666
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 668
  if (rval != 0) {
#line 670
    ql_dbg(268435456U, vha, 8278, "GPN_ID issue IOCB failed (%d).\n", rval);
#line 672
    goto ldv_60810;
  } else {
#line 673
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GPN_ID");
#line 673
    if (tmp___1 != 0) {
#line 675
      rval = 258;
#line 676
      goto ldv_60810;
    } else {
#line 679
      __len = 8UL;
#line 679
      if (__len > 63UL) {
#line 679
        __ret = __memcpy((void *)(& (list + (unsigned long )i)->port_name), (void const   *)(& ct_rsp->rsp.gpn_id.port_name),
                         __len);
      } else {
#line 679
        __ret = __builtin_memcpy((void *)(& (list + (unsigned long )i)->port_name),
                                 (void const   *)(& ct_rsp->rsp.gpn_id.port_name),
                                 __len);
      }
    }
  }
#line 684
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 685
    goto ldv_60810;
  } else {

  }
#line 649
  i = (uint16_t )((int )i + 1);
  ldv_60815: ;
#line 649
  if ((int )ha->max_fibre_devices > (int )i) {
#line 651
    goto ldv_60814;
  } else {

  }
  ldv_60810: ;
#line 688
  return (rval);
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 701
  rval = 0;
#line 703
  ha = vha->hw;
#line 708
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 709
    tmp = qla2x00_sns_gnn_id(vha, list);
#line 709
    return (tmp);
  } else {

  }
#line 711
  i = 0U;
#line 711
  goto ldv_60831;
  ldv_60830: 
#line 714
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 714
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 718
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 275, 24);
#line 720
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 723
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 724
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 725
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 728
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 730
  if (rval != 0) {
#line 732
    ql_dbg(268435456U, vha, 8279, "GNN_ID issue IOCB failed (%d).\n", rval);
#line 734
    goto ldv_60826;
  } else {
#line 735
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GNN_ID");
#line 735
    if (tmp___1 != 0) {
#line 737
      rval = 258;
#line 738
      goto ldv_60826;
    } else {
#line 741
      __len = 8UL;
#line 741
      if (__len > 63UL) {
#line 741
        __ret = __memcpy((void *)(& (list + (unsigned long )i)->node_name), (void const   *)(& ct_rsp->rsp.gnn_id.node_name),
                         __len);
      } else {
#line 741
        __ret = __builtin_memcpy((void *)(& (list + (unsigned long )i)->node_name),
                                 (void const   *)(& ct_rsp->rsp.gnn_id.node_name),
                                 __len);
      }
#line 744
      ql_dbg(268435456U, vha, 8280, "GID_PT entry - nn %8phN pn %8phN portid=%02x%02x%02x.\n",
             (uint8_t *)(& (list + (unsigned long )i)->node_name), (uint8_t *)(& (list + (unsigned long )i)->port_name),
             (int )(list + (unsigned long )i)->d_id.b.domain, (int )(list + (unsigned long )i)->d_id.b.area,
             (int )(list + (unsigned long )i)->d_id.b.al_pa);
    }
  }
#line 753
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 754
    goto ldv_60826;
  } else {

  }
#line 711
  i = (uint16_t )((int )i + 1);
  ldv_60831: ;
#line 711
  if ((int )ha->max_fibre_devices > (int )i) {
#line 713
    goto ldv_60830;
  } else {

  }
  ldv_60826: ;
#line 757
  return (rval);
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_rft_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 770
  ha = vha->hw;
#line 775
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 776
    tmp = qla2x00_sns_rft_id(vha);
#line 776
    return (tmp);
  } else {

  }
#line 780
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 52U, 16U);
#line 780
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 784
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 535, 16);
#line 786
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 789
  ct_req->req.rft_id.port_id[0] = vha->d_id.b.domain;
#line 790
  ct_req->req.rft_id.port_id[1] = vha->d_id.b.area;
#line 791
  ct_req->req.rft_id.port_id[2] = vha->d_id.b.al_pa;
#line 793
  ct_req->req.rft_id.fc4_types[2] = 1U;
#line 796
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 798
  if (rval != 0) {
#line 800
    ql_dbg(268435456U, vha, 8259, "RFT_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 802
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFT_ID");
#line 802
    if (tmp___1 != 0) {
#line 804
      rval = 258;
    } else {
#line 806
      ql_dbg(268435456U, vha, 8260, "RFT_ID exiting normally.\n");
    }
  }
#line 810
  return (rval);
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_rff_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 823
  ha = vha->hw;
#line 828
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 829
    ql_dbg(268435456U, vha, 8262, "RFF_ID call not supported on ISP2100/ISP2200.\n");
#line 831
    return (0);
  } else {

  }
#line 836
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 24U, 16U);
#line 836
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 840
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 543, 16);
#line 842
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 845
  ct_req->req.rff_id.port_id[0] = vha->d_id.b.domain;
#line 846
  ct_req->req.rff_id.port_id[1] = vha->d_id.b.area;
#line 847
  ct_req->req.rff_id.port_id[2] = vha->d_id.b.al_pa;
#line 849
  qlt_rff_id(vha, ct_req);
#line 851
  ct_req->req.rff_id.fc4_type = 8U;
#line 854
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 856
  if (rval != 0) {
#line 858
    ql_dbg(268435456U, vha, 8263, "RFF_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 860
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFF_ID");
#line 860
    if (tmp___0 != 0) {
#line 862
      rval = 258;
    } else {
#line 864
      ql_dbg(268435456U, vha, 8264, "RFF_ID exiting normally.\n");
    }
  }
#line 868
  return (rval);
}
}
#line 878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_rnn_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 881
  ha = vha->hw;
#line 886
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 887
    tmp = qla2x00_sns_rnn_id(vha);
#line 887
    return (tmp);
  } else {

  }
#line 891
  tmp___0 = (*((ha->isp_ops)->prep_ms_iocb))(vha, 28U, 16U);
#line 891
  ms_pkt = (ms_iocb_entry_t *)tmp___0;
#line 895
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 531, 16);
#line 896
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 899
  ct_req->req.rnn_id.port_id[0] = vha->d_id.b.domain;
#line 900
  ct_req->req.rnn_id.port_id[1] = vha->d_id.b.area;
#line 901
  ct_req->req.rnn_id.port_id[2] = vha->d_id.b.al_pa;
#line 903
  __len = 8UL;
#line 903
  if (__len > 63UL) {
#line 903
    __ret = __memcpy((void *)(& ct_req->req.rnn_id.node_name), (void const   *)(& vha->node_name),
                     __len);
  } else {
#line 903
    __ret = __builtin_memcpy((void *)(& ct_req->req.rnn_id.node_name), (void const   *)(& vha->node_name),
                             __len);
  }
#line 906
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 908
  if (rval != 0) {
#line 910
    ql_dbg(268435456U, vha, 8269, "RNN_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 912
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RNN_ID");
#line 912
    if (tmp___1 != 0) {
#line 914
      rval = 258;
    } else {
#line 916
      ql_dbg(268435456U, vha, 8270, "RNN_ID exiting normally.\n");
    }
  }
#line 920
  return (rval);
}
}
#line 924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void qla2x00_get_sym_node_name(scsi_qla_host_t *vha , uint8_t *snn ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 926
  ha = vha->hw;
#line 928
  if ((ha->device_type & 131072U) != 0U) {
#line 929
    sprintf((char *)snn, "%s FW:v%s DVR:v%s", (uint8_t *)(& ha->model_number), (uint8_t *)(& ha->mr.fw_version),
            (char *)(& qla2x00_version_str));
  } else {
#line 932
    sprintf((char *)snn, "%s FW:v%d.%02d.%02d DVR:v%s", (uint8_t *)(& ha->model_number),
            (int )ha->fw_major_version, (int )ha->fw_minor_version, (int )ha->fw_subminor_version,
            (char *)(& qla2x00_version_str));
  }
#line 935
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_rsnn_nn(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 947
  ha = vha->hw;
#line 952
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 953
    ql_dbg(268435456U, vha, 8272, "RSNN_ID call unsupported on ISP2100/ISP2200.\n");
#line 955
    return (0);
  } else {

  }
#line 961
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 0U, 16U);
#line 961
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 964
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 569, 16);
#line 966
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 969
  __len = 8UL;
#line 969
  if (__len > 63UL) {
#line 969
    __ret = __memcpy((void *)(& ct_req->req.rsnn_nn.node_name), (void const   *)(& vha->node_name),
                     __len);
  } else {
#line 969
    __ret = __builtin_memcpy((void *)(& ct_req->req.rsnn_nn.node_name), (void const   *)(& vha->node_name),
                             __len);
  }
#line 972
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& ct_req->req.rsnn_nn.sym_node_name));
#line 975
  tmp___0 = strlen((char const   *)(& ct_req->req.rsnn_nn.sym_node_name));
#line 975
  ct_req->req.rsnn_nn.name_len = (unsigned char )tmp___0;
#line 979
  ms_pkt->req_bytecount = (unsigned int )((int )ct_req->req.rsnn_nn.name_len + 25);
#line 981
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 984
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 986
  if (rval != 0) {
#line 988
    ql_dbg(268435456U, vha, 8273, "RSNN_NN issue IOCB failed (%d).\n", rval);
  } else {
#line 990
    tmp___1 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RSNN_NN");
#line 990
    if (tmp___1 != 0) {
#line 992
      rval = 258;
    } else {
#line 994
      ql_dbg(268435456U, vha, 8274, "RSNN_NN exiting normally.\n");
    }
  }
#line 998
  return (rval);
}
}
#line 1011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static struct sns_cmd_pkt *qla2x00_prep_sns_cmd(scsi_qla_host_t *vha , uint16_t cmd ,
                                                         uint16_t scmd_len , uint16_t data_size ) 
{ 
  uint16_t wc ;
  struct sns_cmd_pkt *sns_cmd ;
  struct qla_hw_data *ha ;

  {
#line 1016
  ha = vha->hw;
#line 1018
  sns_cmd = ha->sns_cmd;
#line 1019
  memset((void *)sns_cmd, 0, 2064UL);
#line 1020
  wc = (uint16_t )((unsigned int )data_size / 2U);
#line 1021
  sns_cmd->p.cmd.buffer_length = wc;
#line 1022
  sns_cmd->p.cmd.buffer_address[0] = (unsigned int )ha->sns_cmd_dma;
#line 1023
  sns_cmd->p.cmd.buffer_address[1] = (unsigned int )(ha->sns_cmd_dma >> 32ULL);
#line 1024
  sns_cmd->p.cmd.subcommand_length = scmd_len;
#line 1025
  sns_cmd->p.cmd.subcommand = cmd;
#line 1026
  wc = (uint16_t )(((int )data_size + -16) / 4);
#line 1027
  sns_cmd->p.cmd.size = wc;
#line 1029
  vha->qla_stats.control_requests = vha->qla_stats.control_requests + 1U;
#line 1031
  return (sns_cmd);
}
}
#line 1044 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_ga_nxt(scsi_qla_host_t *vha , fc_port_t *fcport ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1046
  rval = 0;
#line 1047
  ha = vha->hw;
#line 1052
  sns_cmd = qla2x00_prep_sns_cmd(vha, 256, 6, 636);
#line 1056
  sns_cmd->p.cmd.param[0] = fcport->d_id.b.al_pa;
#line 1057
  sns_cmd->p.cmd.param[1] = fcport->d_id.b.area;
#line 1058
  sns_cmd->p.cmd.param[2] = fcport->d_id.b.domain;
#line 1061
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 1063
  if (rval != 0) {
#line 1065
    ql_dbg(268435456U, vha, 8287, "GA_NXT Send SNS failed (%d).\n", rval);
  } else
#line 1067
  if ((unsigned int )sns_cmd->p.gan_data[8] != 128U || (unsigned int )sns_cmd->p.gan_data[9] != 2U) {
#line 1069
    ql_dbg(268566528U, vha, 8324, "GA_NXT failed, rejected request ga_nxt_rsp:\n");
#line 1071
    ql_dump_buffer(268566528U, vha, 8308, (uint8_t *)(& sns_cmd->p.gan_data), 16U);
#line 1073
    rval = 258;
  } else {
#line 1076
    fcport->d_id.b.domain = sns_cmd->p.gan_data[17];
#line 1077
    fcport->d_id.b.area = sns_cmd->p.gan_data[18];
#line 1078
    fcport->d_id.b.al_pa = sns_cmd->p.gan_data[19];
#line 1080
    __len = 8UL;
#line 1080
    if (__len > 63UL) {
#line 1080
      __ret = __memcpy((void *)(& fcport->node_name), (void const   *)(& sns_cmd->p.gan_data) + 284U,
                       __len);
    } else {
#line 1080
      __ret = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& sns_cmd->p.gan_data) + 284U,
                               __len);
    }
#line 1081
    __len___0 = 8UL;
#line 1081
    if (__len___0 > 63UL) {
#line 1081
      __ret___0 = __memcpy((void *)(& fcport->port_name), (void const   *)(& sns_cmd->p.gan_data) + 20U,
                           __len___0);
    } else {
#line 1081
      __ret___0 = __builtin_memcpy((void *)(& fcport->port_name), (void const   *)(& sns_cmd->p.gan_data) + 20U,
                                   __len___0);
    }
#line 1083
    if ((unsigned int )sns_cmd->p.gan_data[16] != 1U && (unsigned int )sns_cmd->p.gan_data[16] != 2U) {
#line 1085
      fcport->d_id.b.domain = 240U;
    } else {

    }
#line 1087
    ql_dbg(268435456U, vha, 8289, "GA_NXT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
           (uint8_t *)(& fcport->node_name), (uint8_t *)(& fcport->port_name), (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  }
#line 1095
  return (rval);
}
}
#line 1110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_gid_pt(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  uint8_t *entry ;
  struct sns_cmd_pkt *sns_cmd ;
  uint16_t gid_pt_sns_data_size ;
  int tmp ;

  {
#line 1113
  ha = vha->hw;
#line 1119
  tmp = qla2x00_gid_pt_rsp_size(vha);
#line 1119
  gid_pt_sns_data_size = (uint16_t )tmp;
#line 1123
  sns_cmd = qla2x00_prep_sns_cmd(vha, 417, 6, (int )gid_pt_sns_data_size);
#line 1127
  sns_cmd->p.cmd.param[0] = 127U;
#line 1130
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 1132
  if (rval != 0) {
#line 1134
    ql_dbg(268435456U, vha, 8301, "GID_PT Send SNS failed (%d).\n", rval);
  } else
#line 1136
  if ((unsigned int )sns_cmd->p.gid_data[8] != 128U || (unsigned int )sns_cmd->p.gid_data[9] != 2U) {
#line 1138
    ql_dbg(268435456U, vha, 8239, "GID_PT failed, rejected request, gid_rsp:\n");
#line 1140
    ql_dump_buffer(268566528U, vha, 8321, (uint8_t *)(& sns_cmd->p.gid_data), 16U);
#line 1142
    rval = 258;
  } else {
#line 1145
    i = 0U;
#line 1145
    goto ldv_60909;
    ldv_60908: 
#line 1146
    entry = (uint8_t *)(& sns_cmd->p.gid_data) + ((unsigned long )((int )i * 4) + 16UL);
#line 1147
    (list + (unsigned long )i)->d_id.b.domain = *(entry + 1UL);
#line 1148
    (list + (unsigned long )i)->d_id.b.area = *(entry + 2UL);
#line 1149
    (list + (unsigned long )i)->d_id.b.al_pa = *(entry + 3UL);
#line 1152
    if ((int )((signed char )*entry) < 0) {
#line 1153
      (list + (unsigned long )i)->d_id.b.rsvd_1 = *entry;
#line 1154
      goto ldv_60907;
    } else {

    }
#line 1145
    i = (uint16_t )((int )i + 1);
    ldv_60909: ;
#line 1145
    if ((int )ha->max_fibre_devices > (int )i) {
#line 1147
      goto ldv_60908;
    } else {

    }
    ldv_60907: ;
#line 1164
    if ((int )ha->max_fibre_devices == (int )i) {
#line 1165
      rval = 258;
    } else {

    }
  }
#line 1168
  return (rval);
}
}
#line 1181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_gpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  struct sns_cmd_pkt *sns_cmd ;
  size_t __len ;
  void *__ret ;

  {
#line 1183
  rval = 0;
#line 1184
  ha = vha->hw;
#line 1188
  i = 0U;
#line 1188
  goto ldv_60923;
  ldv_60922: 
#line 1191
  sns_cmd = qla2x00_prep_sns_cmd(vha, 274, 6, 24);
#line 1195
  sns_cmd->p.cmd.param[0] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 1196
  sns_cmd->p.cmd.param[1] = (list + (unsigned long )i)->d_id.b.area;
#line 1197
  sns_cmd->p.cmd.param[2] = (list + (unsigned long )i)->d_id.b.domain;
#line 1200
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 1202
  if (rval != 0) {
#line 1204
    ql_dbg(268435456U, vha, 8242, "GPN_ID Send SNS failed (%d).\n", rval);
  } else
#line 1206
  if ((unsigned int )sns_cmd->p.gpn_data[8] != 128U || (unsigned int )sns_cmd->p.gpn_data[9] != 2U) {
#line 1208
    ql_dbg(268566528U, vha, 8318, "GPN_ID failed, rejected request, gpn_rsp:\n");
#line 1210
    ql_dump_buffer(268566528U, vha, 8319, (uint8_t *)(& sns_cmd->p.gpn_data), 16U);
#line 1212
    rval = 258;
  } else {
#line 1215
    __len = 8UL;
#line 1215
    if (__len > 63UL) {
#line 1215
      __ret = __memcpy((void *)(& (list + (unsigned long )i)->port_name), (void const   *)(& sns_cmd->p.gpn_data) + 16U,
                       __len);
    } else {
#line 1215
      __ret = __builtin_memcpy((void *)(& (list + (unsigned long )i)->port_name),
                               (void const   *)(& sns_cmd->p.gpn_data) + 16U, __len);
    }
  }
#line 1220
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 1221
    goto ldv_60921;
  } else {

  }
#line 1188
  i = (uint16_t )((int )i + 1);
  ldv_60923: ;
#line 1188
  if ((int )ha->max_fibre_devices > (int )i) {
#line 1190
    goto ldv_60922;
  } else {

  }
  ldv_60921: ;
#line 1224
  return (rval);
}
}
#line 1237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_gnn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint16_t i ;
  struct sns_cmd_pkt *sns_cmd ;
  size_t __len ;
  void *__ret ;

  {
#line 1239
  rval = 0;
#line 1240
  ha = vha->hw;
#line 1244
  i = 0U;
#line 1244
  goto ldv_60937;
  ldv_60936: 
#line 1247
  sns_cmd = qla2x00_prep_sns_cmd(vha, 275, 6, 24);
#line 1251
  sns_cmd->p.cmd.param[0] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 1252
  sns_cmd->p.cmd.param[1] = (list + (unsigned long )i)->d_id.b.area;
#line 1253
  sns_cmd->p.cmd.param[2] = (list + (unsigned long )i)->d_id.b.domain;
#line 1256
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 14, 2064UL);
#line 1258
  if (rval != 0) {
#line 1260
    ql_dbg(268435456U, vha, 8255, "GNN_ID Send SNS failed (%d).\n", rval);
  } else
#line 1262
  if ((unsigned int )sns_cmd->p.gnn_data[8] != 128U || (unsigned int )sns_cmd->p.gnn_data[9] != 2U) {
#line 1264
    ql_dbg(268566528U, vha, 8322, "GNN_ID failed, rejected request, gnn_rsp:\n");
#line 1266
    ql_dump_buffer(268566528U, vha, 8314, (uint8_t *)(& sns_cmd->p.gnn_data), 16U);
#line 1268
    rval = 258;
  } else {
#line 1271
    __len = 8UL;
#line 1271
    if (__len > 63UL) {
#line 1271
      __ret = __memcpy((void *)(& (list + (unsigned long )i)->node_name), (void const   *)(& sns_cmd->p.gnn_data) + 16U,
                       __len);
    } else {
#line 1271
      __ret = __builtin_memcpy((void *)(& (list + (unsigned long )i)->node_name),
                               (void const   *)(& sns_cmd->p.gnn_data) + 16U, __len);
    }
#line 1274
    ql_dbg(268435456U, vha, 8302, "GID_PT entry - nn %8phN pn %8phN port_id=%02x%02x%02x.\n",
           (uint8_t *)(& (list + (unsigned long )i)->node_name), (uint8_t *)(& (list + (unsigned long )i)->port_name),
           (int )(list + (unsigned long )i)->d_id.b.domain, (int )(list + (unsigned long )i)->d_id.b.area,
           (int )(list + (unsigned long )i)->d_id.b.al_pa);
  }
#line 1283
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 1284
    goto ldv_60935;
  } else {

  }
#line 1244
  i = (uint16_t )((int )i + 1);
  ldv_60937: ;
#line 1244
  if ((int )ha->max_fibre_devices > (int )i) {
#line 1246
    goto ldv_60936;
  } else {

  }
  ldv_60935: ;
#line 1287
  return (rval);
}
}
#line 1299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_rft_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 1302
  ha = vha->hw;
#line 1307
  sns_cmd = qla2x00_prep_sns_cmd(vha, 535, 22, 16);
#line 1311
  sns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;
#line 1312
  sns_cmd->p.cmd.param[1] = vha->d_id.b.area;
#line 1313
  sns_cmd->p.cmd.param[2] = vha->d_id.b.domain;
#line 1315
  sns_cmd->p.cmd.param[5] = 1U;
#line 1318
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 30, 2064UL);
#line 1320
  if (rval != 0) {
#line 1322
    ql_dbg(268435456U, vha, 8288, "RFT_ID Send SNS failed (%d).\n", rval);
  } else
#line 1324
  if ((unsigned int )sns_cmd->p.rft_data[8] != 128U || (unsigned int )sns_cmd->p.rft_data[9] != 2U) {
#line 1326
    ql_dbg(268566528U, vha, 8323, "RFT_ID failed, rejected request rft_rsp:\n");
#line 1328
    ql_dump_buffer(268566528U, vha, 8320, (uint8_t *)(& sns_cmd->p.rft_data), 16U);
#line 1330
    rval = 258;
  } else {
#line 1332
    ql_dbg(268435456U, vha, 8307, "RFT_ID exiting normally.\n");
  }
#line 1336
  return (rval);
}
}
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_sns_rnn_id(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct sns_cmd_pkt *sns_cmd ;

  {
#line 1352
  ha = vha->hw;
#line 1357
  sns_cmd = qla2x00_prep_sns_cmd(vha, 531, 10, 16);
#line 1361
  sns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;
#line 1362
  sns_cmd->p.cmd.param[1] = vha->d_id.b.area;
#line 1363
  sns_cmd->p.cmd.param[2] = vha->d_id.b.domain;
#line 1365
  sns_cmd->p.cmd.param[4] = vha->node_name[7];
#line 1366
  sns_cmd->p.cmd.param[5] = vha->node_name[6];
#line 1367
  sns_cmd->p.cmd.param[6] = vha->node_name[5];
#line 1368
  sns_cmd->p.cmd.param[7] = vha->node_name[4];
#line 1369
  sns_cmd->p.cmd.param[8] = vha->node_name[3];
#line 1370
  sns_cmd->p.cmd.param[9] = vha->node_name[2];
#line 1371
  sns_cmd->p.cmd.param[10] = vha->node_name[1];
#line 1372
  sns_cmd->p.cmd.param[11] = vha->node_name[0];
#line 1375
  rval = qla2x00_send_sns(vha, ha->sns_cmd_dma, 18, 2064UL);
#line 1377
  if (rval != 0) {
#line 1379
    ql_dbg(268435456U, vha, 8266, "RNN_ID Send SNS failed (%d).\n", rval);
  } else
#line 1381
  if ((unsigned int )sns_cmd->p.rnn_data[8] != 128U || (unsigned int )sns_cmd->p.rnn_data[9] != 2U) {
#line 1383
    ql_dbg(268566528U, vha, 8315, "RNN_ID failed, rejected request, rnn_rsp:\n");
#line 1385
    ql_dump_buffer(268566528U, vha, 8316, (uint8_t *)(& sns_cmd->p.rnn_data), 16U);
#line 1387
    rval = 258;
  } else {
#line 1389
    ql_dbg(268435456U, vha, 8268, "RNN_ID exiting normally.\n");
  }
#line 1393
  return (rval);
}
}
#line 1403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_mgmt_svr_login(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  int rval ;
  uint16_t mb[32U] ;
  struct qla_hw_data *ha ;

  {
#line 1407
  ha = vha->hw;
#line 1408
  ret = 0;
#line 1409
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1410
    return (ret);
  } else {

  }
#line 1412
  rval = (*((ha->isp_ops)->fabric_login))(vha, (int )vha->mgmt_svr_loop_id, 255, 255,
                                          250, (uint16_t *)(& mb), 2);
#line 1414
  if (rval != 0 || (unsigned int )mb[0] != 16384U) {
#line 1415
    if (rval == 259) {
#line 1416
      ql_dbg(268435456U, vha, 8325, "Failed management_server login: loopid=%x rval=%d\n",
             (int )vha->mgmt_svr_loop_id, rval);
    } else {
#line 1420
      ql_dbg(268435456U, vha, 8228, "Failed management_server login: loopid=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",
             (int )vha->mgmt_svr_loop_id, (int )mb[0], (int )mb[1], (int )mb[2], (int )mb[6],
             (int )mb[7]);
    }
#line 1425
    ret = 258;
  } else {
#line 1427
    vha->flags.management_server_logged_in = 1U;
  }
#line 1429
  return (ret);
}
}
#line 1441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void *qla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  ms_iocb_entry_t *ms_pkt ;
  struct qla_hw_data *ha ;

  {
#line 1445
  ha = vha->hw;
#line 1446
  ms_pkt = ha->ms_iocb;
#line 1447
  memset((void *)ms_pkt, 0, 64UL);
#line 1449
  ms_pkt->entry_type = 41U;
#line 1450
  ms_pkt->entry_count = 1U;
#line 1451
  if ((int )ha->device_type < 0) {
#line 1451
    ms_pkt->loop_id.extended = vha->mgmt_svr_loop_id;
  } else {
#line 1451
    ms_pkt->loop_id.id.standard = (unsigned char )vha->mgmt_svr_loop_id;
  }
#line 1452
  ms_pkt->control_flags = 34U;
#line 1453
  ms_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 1454
  ms_pkt->cmd_dsd_count = 1U;
#line 1455
  ms_pkt->total_dsd_count = 2U;
#line 1456
  ms_pkt->rsp_bytecount = rsp_size;
#line 1457
  ms_pkt->req_bytecount = req_size;
#line 1459
  ms_pkt->dseg_req_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1460
  ms_pkt->dseg_req_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1461
  ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
#line 1463
  ms_pkt->dseg_rsp_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1464
  ms_pkt->dseg_rsp_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1465
  ms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;
#line 1467
  return ((void *)ms_pkt);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void *qla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha , uint32_t req_size , uint32_t rsp_size ) 
{ 
  struct ct_entry_24xx *ct_pkt ;
  struct qla_hw_data *ha ;

  {
#line 1483
  ha = vha->hw;
#line 1485
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 1486
  memset((void *)ct_pkt, 0, 64UL);
#line 1488
  ct_pkt->entry_type = 41U;
#line 1489
  ct_pkt->entry_count = 1U;
#line 1490
  ct_pkt->nport_handle = vha->mgmt_svr_loop_id;
#line 1491
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 1492
  ct_pkt->cmd_dsd_count = 1U;
#line 1493
  ct_pkt->rsp_dsd_count = 1U;
#line 1494
  ct_pkt->rsp_byte_count = rsp_size;
#line 1495
  ct_pkt->cmd_byte_count = req_size;
#line 1497
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1498
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1499
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 1501
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 1502
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 1503
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 1504
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 1506
  return ((void *)ct_pkt);
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static ms_iocb_entry_t *qla2x00_update_ms_fdmi_iocb(scsi_qla_host_t *vha ,
                                                             uint32_t req_size ) 
{ 
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_entry_24xx *ct_pkt ;

  {
#line 1512
  ha = vha->hw;
#line 1513
  ms_pkt = ha->ms_iocb;
#line 1514
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 1516
  if ((ha->device_type & 134217728U) != 0U) {
#line 1517
    ct_pkt->cmd_byte_count = req_size;
#line 1518
    ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
  } else {
#line 1520
    ms_pkt->req_bytecount = req_size;
#line 1521
    ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
  }
#line 1524
  return (ms_pkt);
}
}
#line 1536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static struct ct_sns_req *qla2x00_prep_ct_fdmi_req(struct ct_sns_pkt *p ,
                                                            uint16_t cmd , uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 1539
  memset((void *)p, 0, 8208UL);
#line 1541
  p->p.req.header.revision = 1U;
#line 1542
  p->p.req.header.gs_type = 250U;
#line 1543
  p->p.req.header.gs_subtype = 16U;
#line 1544
  tmp = __fswab16((int )cmd);
#line 1544
  p->p.req.command = tmp;
#line 1545
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 1545
  p->p.req.max_rsp_size = tmp___0;
#line 1547
  return (& p->p.req);
}
}
#line 1557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_fdmi_rhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  uint32_t sn ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  uint8_t *entries ;
  struct ct_fdmi_hba_attr *eiter ;
  struct qla_hw_data *ha ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t tmp___0 ;
  __u16 tmp___1 ;
  size_t tmp___2 ;
  __u16 tmp___3 ;
  size_t tmp___4 ;
  __u16 tmp___5 ;
  size_t tmp___6 ;
  __u16 tmp___7 ;
  size_t tmp___8 ;
  __u16 tmp___9 ;
  size_t tmp___10 ;
  __u16 tmp___11 ;
  size_t tmp___12 ;
  __u16 tmp___13 ;
  size_t tmp___14 ;
  __u16 tmp___15 ;
  int tmp___16 ;

  {
#line 1567
  ha = vha->hw;
#line 1572
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 1572
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1575
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 512, 16);
#line 1576
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1579
  __len = 8UL;
#line 1579
  if (__len > 63UL) {
#line 1579
    __ret = __memcpy((void *)(& ct_req->req.rhba.hba_identifier), (void const   *)(& vha->port_name),
                     __len);
  } else {
#line 1579
    __ret = __builtin_memcpy((void *)(& ct_req->req.rhba.hba_identifier), (void const   *)(& vha->port_name),
                             __len);
  }
#line 1580
  ct_req->req.rhba.entry_count = 16777216U;
#line 1581
  __len___0 = 8UL;
#line 1581
  if (__len___0 > 63UL) {
#line 1581
    __ret___0 = __memcpy((void *)(& ct_req->req.rhba.port_name), (void const   *)(& vha->port_name),
                         __len___0);
  } else {
#line 1581
    __ret___0 = __builtin_memcpy((void *)(& ct_req->req.rhba.port_name), (void const   *)(& vha->port_name),
                                 __len___0);
  }
#line 1582
  size = 24U;
#line 1585
  ct_req->req.rhba.attrs.count = 150994944U;
#line 1587
  entries = (uint8_t *)(& ct_req->req.rhba.hba_identifier);
#line 1590
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1591
  eiter->type = 256U;
#line 1592
  eiter->len = 3072U;
#line 1593
  __len___1 = 8UL;
#line 1593
  if (__len___1 > 63UL) {
#line 1593
    __ret___1 = __memcpy((void *)(& eiter->a.node_name), (void const   *)(& vha->node_name),
                         __len___1);
  } else {
#line 1593
    __ret___1 = __builtin_memcpy((void *)(& eiter->a.node_name), (void const   *)(& vha->node_name),
                                 __len___1);
  }
#line 1594
  size = size + 12U;
#line 1596
  ql_dbg(268435456U, vha, 8229, "NodeName = %8phN.\n", (uint8_t *)(& eiter->a.node_name));
#line 1600
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1601
  eiter->type = 512U;
#line 1602
  tmp___0 = strlen("QLogic Corporation");
#line 1602
  alen = (int )tmp___0;
#line 1603
  strncpy((char *)(& eiter->a.manufacturer), "QLogic Corporation", (__kernel_size_t )(alen + 1));
#line 1604
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1605
  tmp___1 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1605
  eiter->len = tmp___1;
#line 1606
  size = ((uint32_t )alen + size) + 4U;
#line 1608
  ql_dbg(268435456U, vha, 8230, "Manufacturer = %s.\n", (uint8_t *)(& eiter->a.manufacturer));
#line 1612
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1613
  eiter->type = 768U;
#line 1614
  sn = (uint32_t )(((((int )ha->serial0 & 31) << 16) | ((int )ha->serial2 << 8)) | (int )ha->serial1);
#line 1615
  sprintf((char *)(& eiter->a.serial_num), "%c%05d", sn / 100000U + 65U, sn % 100000U);
#line 1616
  tmp___2 = strlen((char const   *)(& eiter->a.serial_num));
#line 1616
  alen = (int )tmp___2;
#line 1617
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1618
  tmp___3 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1618
  eiter->len = tmp___3;
#line 1619
  size = ((uint32_t )alen + size) + 4U;
#line 1621
  ql_dbg(268435456U, vha, 8231, "Serial no. = %s.\n", (uint8_t *)(& eiter->a.serial_num));
#line 1625
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1626
  eiter->type = 1024U;
#line 1627
  strcpy((char *)(& eiter->a.model), (char const   *)(& ha->model_number));
#line 1628
  tmp___4 = strlen((char const   *)(& eiter->a.model));
#line 1628
  alen = (int )tmp___4;
#line 1629
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1630
  tmp___5 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1630
  eiter->len = tmp___5;
#line 1631
  size = ((uint32_t )alen + size) + 4U;
#line 1633
  ql_dbg(268435456U, vha, 8232, "Model Name = %s.\n", (uint8_t *)(& eiter->a.model));
#line 1637
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1638
  eiter->type = 1280U;
#line 1639
  strncpy((char *)(& eiter->a.model_desc), (char const   *)(& ha->model_desc), 80UL);
#line 1640
  tmp___6 = strlen((char const   *)(& eiter->a.model_desc));
#line 1640
  alen = (int )tmp___6;
#line 1641
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1642
  tmp___7 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1642
  eiter->len = tmp___7;
#line 1643
  size = ((uint32_t )alen + size) + 4U;
#line 1645
  ql_dbg(268435456U, vha, 8233, "Model Desc = %s.\n", (uint8_t *)(& eiter->a.model_desc));
#line 1649
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1650
  eiter->type = 1536U;
#line 1651
  strcpy((char *)(& eiter->a.hw_version), (char const   *)(& ha->adapter_id));
#line 1652
  tmp___8 = strlen((char const   *)(& eiter->a.hw_version));
#line 1652
  alen = (int )tmp___8;
#line 1653
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1654
  tmp___9 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1654
  eiter->len = tmp___9;
#line 1655
  size = ((uint32_t )alen + size) + 4U;
#line 1657
  ql_dbg(268435456U, vha, 8234, "Hardware ver = %s.\n", (uint8_t *)(& eiter->a.hw_version));
#line 1661
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1662
  eiter->type = 1792U;
#line 1663
  strcpy((char *)(& eiter->a.driver_version), (char const   *)(& qla2x00_version_str));
#line 1664
  tmp___10 = strlen((char const   *)(& eiter->a.driver_version));
#line 1664
  alen = (int )tmp___10;
#line 1665
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1666
  tmp___11 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1666
  eiter->len = tmp___11;
#line 1667
  size = ((uint32_t )alen + size) + 4U;
#line 1669
  ql_dbg(268435456U, vha, 8235, "Driver ver = %s.\n", (uint8_t *)(& eiter->a.driver_version));
#line 1673
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1674
  eiter->type = 2048U;
#line 1675
  strcpy((char *)(& eiter->a.orom_version), "0.00");
#line 1676
  tmp___12 = strlen((char const   *)(& eiter->a.orom_version));
#line 1676
  alen = (int )tmp___12;
#line 1677
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1678
  tmp___13 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1678
  eiter->len = tmp___13;
#line 1679
  size = ((uint32_t )alen + size) + 4U;
#line 1681
  ql_dbg(268435456U, vha, 8236, "Optrom vers = %s.\n", (uint8_t *)(& eiter->a.orom_version));
#line 1685
  eiter = (struct ct_fdmi_hba_attr *)entries + (unsigned long )size;
#line 1686
  eiter->type = 2304U;
#line 1687
  (*((ha->isp_ops)->fw_version_str))(vha, (char *)(& eiter->a.fw_version));
#line 1688
  tmp___14 = strlen((char const   *)(& eiter->a.fw_version));
#line 1688
  alen = (int )tmp___14;
#line 1689
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1690
  tmp___15 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1690
  eiter->len = tmp___15;
#line 1691
  size = ((uint32_t )alen + size) + 4U;
#line 1693
  ql_dbg(268435456U, vha, 8237, "Firmware vers = %s.\n", (uint8_t *)(& eiter->a.fw_version));
#line 1697
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 1699
  ql_dbg(268435456U, vha, 8238, "RHBA identifier = %8phN size=%d.\n", (uint8_t *)(& ct_req->req.rhba.hba_identifier),
         size);
#line 1702
  ql_dump_buffer(268566528U, vha, 8310, entries, size);
#line 1706
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1708
  if (rval != 0) {
#line 1710
    ql_dbg(268435456U, vha, 8240, "RHBA issue IOCB failed (%d).\n", rval);
  } else {
#line 1712
    tmp___16 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RHBA");
#line 1712
    if (tmp___16 != 0) {
#line 1714
      rval = 258;
#line 1715
      if ((unsigned int )ct_rsp->header.reason_code == 9U && (unsigned int )ct_rsp->header.explanation_code == 16U) {
#line 1718
        ql_dbg(268435456U, vha, 8244, "HBA already registered.\n");
#line 1720
        rval = 265;
      } else {

      }
    } else {
#line 1723
      ql_dbg(268435456U, vha, 8245, "RHBA exiting normally.\n");
    }
  }
#line 1727
  return (rval);
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_fdmi_dhba(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 1740
  ha = vha->hw;
#line 1747
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 24U, 16U);
#line 1747
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1751
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 768, 16);
#line 1752
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1755
  __len = 8UL;
#line 1755
  if (__len > 63UL) {
#line 1755
    __ret = __memcpy((void *)(& ct_req->req.dhba.port_name), (void const   *)(& vha->port_name),
                     __len);
  } else {
#line 1755
    __ret = __builtin_memcpy((void *)(& ct_req->req.dhba.port_name), (void const   *)(& vha->port_name),
                             __len);
  }
#line 1757
  ql_dbg(268435456U, vha, 8246, "DHBA portname = %8phN.\n", (uint8_t *)(& ct_req->req.dhba.port_name));
#line 1761
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1763
  if (rval != 0) {
#line 1765
    ql_dbg(268435456U, vha, 8247, "DHBA issue IOCB failed (%d).\n", rval);
  } else {
#line 1767
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "DHBA");
#line 1767
    if (tmp___0 != 0) {
#line 1769
      rval = 258;
    } else {
#line 1771
      ql_dbg(268435456U, vha, 8248, "DHBA exiting normally.\n");
    }
  }
#line 1775
  return (rval);
}
}
#line 1785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
static int qla2x00_fdmi_rpa(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int alen ;
  uint32_t size ;
  uint32_t max_frame_size ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  uint8_t *entries ;
  struct ct_fdmi_port_attr *eiter ;
  struct init_cb_24xx *icb24 ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___0 ;
  size_t tmp___1 ;
  __u16 tmp___2 ;
  size_t tmp___3 ;
  __u16 tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1789
  ha = vha->hw;
#line 1795
  icb24 = (struct init_cb_24xx *)ha->init_cb;
#line 1800
  tmp = (*((ha->isp_ops)->prep_ms_fdmi_iocb))(vha, 0U, 16U);
#line 1800
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 1803
  ct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, 529, 16);
#line 1804
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 1807
  __len = 8UL;
#line 1807
  if (__len > 63UL) {
#line 1807
    __ret = __memcpy((void *)(& ct_req->req.rpa.port_name), (void const   *)(& vha->port_name),
                     __len);
  } else {
#line 1807
    __ret = __builtin_memcpy((void *)(& ct_req->req.rpa.port_name), (void const   *)(& vha->port_name),
                             __len);
  }
#line 1808
  size = 12U;
#line 1811
  ct_req->req.rpa.attrs.count = 83886080U;
#line 1813
  entries = (uint8_t *)(& ct_req->req.rpa.port_name);
#line 1816
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1817
  eiter->type = 256U;
#line 1818
  eiter->len = 9216U;
#line 1819
  eiter->a.fc4_types[2] = 1U;
#line 1820
  size = size + 36U;
#line 1822
  ql_dbg(268435456U, vha, 8249, "FC4_TYPES=%02x %02x.\n", (int )eiter->a.fc4_types[2],
         (int )eiter->a.fc4_types[1]);
#line 1828
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1829
  eiter->type = 512U;
#line 1830
  eiter->len = 2048U;
#line 1831
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1832
    eiter->a.sup_speed = 67108864U;
  } else
#line 1834
  if ((ha->device_type & 2048U) != 0U) {
#line 1835
    eiter->a.sup_speed = 452984832U;
  } else
#line 1838
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 1839
    eiter->a.sup_speed = 184549376U;
  } else
#line 1842
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 1843
    eiter->a.sup_speed = 50331648U;
  } else {
#line 1846
    eiter->a.sup_speed = 16777216U;
  }
#line 1848
  size = size + 8U;
#line 1850
  ql_dbg(268435456U, vha, 8250, "Supported_Speed=%x.\n", eiter->a.sup_speed);
#line 1854
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1855
  eiter->type = 768U;
#line 1856
  eiter->len = 2048U;
#line 1857
  switch ((int )ha->link_data_rate) {
  case 0: 
#line 1859
  eiter->a.cur_speed = 16777216U;
#line 1861
  goto ldv_61034;
  case 1: 
#line 1863
  eiter->a.cur_speed = 33554432U;
#line 1865
  goto ldv_61034;
  case 3: 
#line 1867
  eiter->a.cur_speed = 134217728U;
#line 1869
  goto ldv_61034;
  case 4: 
#line 1871
  eiter->a.cur_speed = 268435456U;
#line 1873
  goto ldv_61034;
  case 19: 
#line 1875
  eiter->a.cur_speed = 67108864U;
#line 1877
  goto ldv_61034;
  case 5: 
#line 1879
  eiter->a.cur_speed = 536870912U;
#line 1881
  goto ldv_61034;
  default: 
#line 1883
  eiter->a.cur_speed = 8388608U;
#line 1885
  goto ldv_61034;
  }
  ldv_61034: 
#line 1887
  size = size + 8U;
#line 1889
  ql_dbg(268435456U, vha, 8251, "Current_Speed=%x.\n", eiter->a.cur_speed);
#line 1893
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1894
  eiter->type = 1024U;
#line 1895
  eiter->len = 2048U;
#line 1896
  max_frame_size = (uint32_t )((ha->device_type & 134217728U) != 0U ? icb24->frame_payload_size : (ha->init_cb)->frame_payload_size);
#line 1899
  tmp___0 = __fswab32(max_frame_size);
#line 1899
  eiter->a.max_frame_size = tmp___0;
#line 1900
  size = size + 8U;
#line 1902
  ql_dbg(268435456U, vha, 8252, "Max_Frame_Size=%x.\n", eiter->a.max_frame_size);
#line 1906
  eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1907
  eiter->type = 1280U;
#line 1908
  tmp___1 = strlen("qla2xxx");
#line 1908
  alen = (int )tmp___1;
#line 1909
  strncpy((char *)(& eiter->a.os_dev_name), "qla2xxx", (__kernel_size_t )(alen + 1));
#line 1910
  alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1911
  tmp___2 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1911
  eiter->len = tmp___2;
#line 1912
  size = ((uint32_t )alen + size) + 4U;
#line 1914
  ql_dbg(268435456U, vha, 8267, "OS_Device_Name=%s.\n", (uint8_t *)(& eiter->a.os_dev_name));
#line 1918
  tmp___5 = strlen((char const   *)(& ((struct fc_host_attrs *)(vha->host)->shost_data)->system_hostname));
#line 1918
  if (tmp___5 != 0UL) {
#line 1919
    ct_req->req.rpa.attrs.count = 100663296U;
#line 1921
    eiter = (struct ct_fdmi_port_attr *)entries + (unsigned long )size;
#line 1922
    eiter->type = 1536U;
#line 1923
    snprintf((char *)(& eiter->a.host_name), 32UL, "%s", (char *)(& ((struct fc_host_attrs *)(vha->host)->shost_data)->system_hostname));
#line 1925
    tmp___3 = strlen((char const   *)(& eiter->a.host_name));
#line 1925
    alen = (int )tmp___3;
#line 1926
    alen = ((alen & 3) != 0 ? 4 - (alen & 3) : 4) + alen;
#line 1927
    tmp___4 = __fswab16((int )((unsigned int )((__u16 )alen) + 4U));
#line 1927
    eiter->len = tmp___4;
#line 1928
    size = ((uint32_t )alen + size) + 4U;
#line 1930
    ql_dbg(268435456U, vha, 8253, "HostName=%s.\n", (uint8_t *)(& eiter->a.host_name));
  } else {

  }
#line 1935
  qla2x00_update_ms_fdmi_iocb(vha, size + 16U);
#line 1937
  ql_dbg(268435456U, vha, 8254, "RPA portname= %8phN size=%d.\n", (uint8_t *)(& ct_req->req.rpa.port_name),
         size);
#line 1939
  ql_dump_buffer(268566528U, vha, 8313, entries, size);
#line 1943
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 1945
  if (rval != 0) {
#line 1947
    ql_dbg(268435456U, vha, 8256, "RPA issue IOCB failed (%d).\n", rval);
  } else {
#line 1949
    tmp___6 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RPA");
#line 1949
    if (tmp___6 != 0) {
#line 1951
      rval = 258;
    } else {
#line 1953
      ql_dbg(268435456U, vha, 8257, "RPA exiting nornally.\n");
    }
  }
#line 1957
  return (rval);
}
}
#line 1967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_fdmi_register(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 1970
  ha = vha->hw;
#line 1972
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 131072U) != 0U) {
#line 1974
    return (258);
  } else {

  }
#line 1976
  rval = qla2x00_mgmt_svr_login(vha);
#line 1977
  if (rval != 0) {
#line 1978
    return (rval);
  } else {

  }
#line 1980
  rval = qla2x00_fdmi_rhba(vha);
#line 1981
  if (rval != 0) {
#line 1982
    if (rval != 265) {
#line 1983
      return (rval);
    } else {

    }
#line 1985
    rval = qla2x00_fdmi_dhba(vha);
#line 1986
    if (rval != 0) {
#line 1987
      return (rval);
    } else {

    }
#line 1989
    rval = qla2x00_fdmi_rhba(vha);
#line 1990
    if (rval != 0) {
#line 1991
      return (rval);
    } else {

    }
  } else {

  }
#line 1993
  rval = qla2x00_fdmi_rpa(vha);
#line 1995
  return (rval);
}
}
#line 2006 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_gfpn_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 2008
  rval = 0;
#line 2010
  ha = vha->hw;
#line 2015
  if ((ha->device_type & 67108864U) == 0U) {
#line 2016
    return (258);
  } else {

  }
#line 2018
  i = 0U;
#line 2018
  goto ldv_61061;
  ldv_61060: 
#line 2021
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 24U);
#line 2021
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2025
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 284, 24);
#line 2027
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2030
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 2031
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 2032
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 2035
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2037
  if (rval != 0) {
#line 2039
    ql_dbg(268435456U, vha, 8227, "GFPN_ID issue IOCB failed (%d).\n", rval);
#line 2041
    goto ldv_61056;
  } else {
#line 2042
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GFPN_ID");
#line 2042
    if (tmp___0 != 0) {
#line 2044
      rval = 258;
#line 2045
      goto ldv_61056;
    } else {
#line 2048
      __len = 8UL;
#line 2048
      if (__len > 63UL) {
#line 2048
        __ret = __memcpy((void *)(& (list + (unsigned long )i)->fabric_port_name),
                         (void const   *)(& ct_rsp->rsp.gfpn_id.port_name), __len);
      } else {
#line 2048
        __ret = __builtin_memcpy((void *)(& (list + (unsigned long )i)->fabric_port_name),
                                 (void const   *)(& ct_rsp->rsp.gfpn_id.port_name),
                                 __len);
      }
    }
  }
#line 2053
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2054
    goto ldv_61056;
  } else {

  }
#line 2018
  i = (uint16_t )((int )i + 1);
  ldv_61061: ;
#line 2018
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2020
    goto ldv_61060;
  } else {

  }
  ldv_61056: ;
#line 2057
  return (rval);
}
}
#line 2061 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static void *qla24xx_prep_ms_fm_iocb(scsi_qla_host_t *vha , uint32_t req_size ,
                                              uint32_t rsp_size ) 
{ 
  struct ct_entry_24xx *ct_pkt ;
  struct qla_hw_data *ha ;

  {
#line 2065
  ha = vha->hw;
#line 2066
  ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;
#line 2067
  memset((void *)ct_pkt, 0, 64UL);
#line 2069
  ct_pkt->entry_type = 41U;
#line 2070
  ct_pkt->entry_count = 1U;
#line 2071
  ct_pkt->nport_handle = vha->mgmt_svr_loop_id;
#line 2072
  ct_pkt->timeout = ((unsigned int )ha->r_a_tov / 10U) * 2U;
#line 2073
  ct_pkt->cmd_dsd_count = 1U;
#line 2074
  ct_pkt->rsp_dsd_count = 1U;
#line 2075
  ct_pkt->rsp_byte_count = rsp_size;
#line 2076
  ct_pkt->cmd_byte_count = req_size;
#line 2078
  ct_pkt->dseg_0_address[0] = (unsigned int )ha->ct_sns_dma;
#line 2079
  ct_pkt->dseg_0_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 2080
  ct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;
#line 2082
  ct_pkt->dseg_1_address[0] = (unsigned int )ha->ct_sns_dma;
#line 2083
  ct_pkt->dseg_1_address[1] = (unsigned int )(ha->ct_sns_dma >> 32ULL);
#line 2084
  ct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;
#line 2085
  ct_pkt->vp_index = (uint8_t )vha->vp_idx;
#line 2087
  return ((void *)ct_pkt);
}
}
#line 2092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
__inline static struct ct_sns_req *qla24xx_prep_ct_fm_req(struct ct_sns_pkt *p , uint16_t cmd ,
                                                          uint16_t rsp_size ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 2095
  memset((void *)p, 0, 8208UL);
#line 2097
  p->p.req.header.revision = 1U;
#line 2098
  p->p.req.header.gs_type = 250U;
#line 2099
  p->p.req.header.gs_subtype = 1U;
#line 2100
  tmp = __fswab16((int )cmd);
#line 2100
  p->p.req.command = tmp;
#line 2101
  tmp___0 = __fswab16((int )((__u16 )(((int )rsp_size + -16) / 4)));
#line 2101
  p->p.req.max_rsp_size = tmp___0;
#line 2103
  return (& p->p.req);
}
}
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int qla2x00_gpsc(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  struct qla_hw_data *ha ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 2118
  ha = vha->hw;
#line 2123
  if ((ha->device_type & 67108864U) == 0U) {
#line 2124
    return (258);
  } else {

  }
#line 2125
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2126
    return (258);
  } else {

  }
#line 2128
  rval = qla2x00_mgmt_svr_login(vha);
#line 2129
  if (rval != 0) {
#line 2130
    return (rval);
  } else {

  }
#line 2132
  i = 0U;
#line 2132
  goto ldv_61096;
  ldv_61095: 
#line 2135
  tmp = qla24xx_prep_ms_fm_iocb(vha, 24U, 20U);
#line 2135
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2139
  ct_req = qla24xx_prep_ct_fm_req(ha->ct_sns, 295, 20);
#line 2141
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2144
  __len = 8UL;
#line 2144
  if (__len > 63UL) {
#line 2144
    __ret = __memcpy((void *)(& ct_req->req.gpsc.port_name), (void const   *)(& (list + (unsigned long )i)->fabric_port_name),
                     __len);
  } else {
#line 2144
    __ret = __builtin_memcpy((void *)(& ct_req->req.gpsc.port_name), (void const   *)(& (list + (unsigned long )i)->fabric_port_name),
                             __len);
  }
#line 2148
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2150
  if (rval != 0) {
#line 2152
    ql_dbg(268435456U, vha, 8281, "GPSC issue IOCB failed (%d).\n", rval);
  } else {
#line 2154
    rval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GPSC");
#line 2154
    if (rval != 0) {
#line 2157
      if (rval == 1 && ((unsigned int )ct_rsp->header.reason_code == 1U || (unsigned int )ct_rsp->header.reason_code == 11U)) {
#line 2162
        ql_dbg(268435456U, vha, 8282, "GPSC command unsupported, disabling query.\n");
#line 2165
        ha->flags.gpsc_supported = 0U;
#line 2166
        rval = 258;
#line 2167
        goto ldv_61087;
      } else {

      }
#line 2169
      rval = 258;
    } else {
#line 2172
      tmp___0 = __fswab16((int )ct_rsp->rsp.gpsc.speed);
#line 2172
      switch ((int )tmp___0) {
      case 32768: 
#line 2174
      (list + (unsigned long )i)->fp_speed = 0U;
#line 2175
      goto ldv_61089;
      case 16384: 
#line 2177
      (list + (unsigned long )i)->fp_speed = 1U;
#line 2178
      goto ldv_61089;
      case 8192: 
#line 2180
      (list + (unsigned long )i)->fp_speed = 3U;
#line 2181
      goto ldv_61089;
      case 4096: 
#line 2183
      (list + (unsigned long )i)->fp_speed = 19U;
#line 2184
      goto ldv_61089;
      case 2048: 
#line 2186
      (list + (unsigned long )i)->fp_speed = 4U;
#line 2187
      goto ldv_61089;
      case 1024: 
#line 2189
      (list + (unsigned long )i)->fp_speed = 5U;
#line 2190
      goto ldv_61089;
      }
      ldv_61089: 
#line 2193
      tmp___1 = __fswab16((int )ct_rsp->rsp.gpsc.speed);
#line 2193
      tmp___2 = __fswab16((int )ct_rsp->rsp.gpsc.speeds);
#line 2193
      ql_dbg(268435456U, vha, 8283, "GPSC ext entry - fpn %8phN speeds=%04x speed=%04x.\n",
             (uint8_t *)(& (list + (unsigned long )i)->fabric_port_name), (int )tmp___2,
             (int )tmp___1);
    }
  }
#line 2202
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2203
    goto ldv_61087;
  } else {

  }
#line 2132
  i = (uint16_t )((int )i + 1);
  ldv_61096: ;
#line 2132
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2134
    goto ldv_61095;
  } else {

  }
  ldv_61087: ;
#line 2206
  return (rval);
}
}
#line 2217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void qla2x00_gff_id(scsi_qla_host_t *vha , sw_info_t *list ) 
{ 
  int rval ;
  uint16_t i ;
  ms_iocb_entry_t *ms_pkt ;
  struct ct_sns_req *ct_req ;
  struct ct_sns_rsp *ct_rsp ;
  struct qla_hw_data *ha ;
  uint8_t fcp_scsi_features ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2225
  ha = vha->hw;
#line 2226
  fcp_scsi_features = 0U;
#line 2228
  i = 0U;
#line 2228
  goto ldv_61111;
  ldv_61110: 
#line 2231
  (list + (unsigned long )i)->fc4_type = 255U;
#line 2234
  if ((ha->device_type & 134217728U) == 0U) {
#line 2235
    goto ldv_61108;
  } else {

  }
#line 2238
  tmp = (*((ha->isp_ops)->prep_ms_iocb))(vha, 20U, 144U);
#line 2238
  ms_pkt = (ms_iocb_entry_t *)tmp;
#line 2242
  ct_req = qla2x00_prep_ct_req(ha->ct_sns, 287, 144);
#line 2244
  ct_rsp = & (ha->ct_sns)->p.rsp;
#line 2247
  ct_req->req.port_id.port_id[0] = (list + (unsigned long )i)->d_id.b.domain;
#line 2248
  ct_req->req.port_id.port_id[1] = (list + (unsigned long )i)->d_id.b.area;
#line 2249
  ct_req->req.port_id.port_id[2] = (list + (unsigned long )i)->d_id.b.al_pa;
#line 2252
  rval = qla2x00_issue_iocb(vha, (void *)ha->ms_iocb, ha->ms_iocb_dma, 64UL);
#line 2255
  if (rval != 0) {
#line 2256
    ql_dbg(268435456U, vha, 8284, "GFF_ID issue IOCB failed (%d).\n", rval);
  } else {
#line 2258
    tmp___0 = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GFF_ID");
#line 2258
    if (tmp___0 != 0) {
#line 2260
      ql_dbg(268435456U, vha, 8285, "GFF_ID IOCB status had a failure status code.\n");
    } else {
#line 2263
      fcp_scsi_features = ct_rsp->rsp.gff_id.fc4_features[7];
#line 2265
      fcp_scsi_features = (unsigned int )fcp_scsi_features & 15U;
#line 2267
      if ((unsigned int )fcp_scsi_features != 0U) {
#line 2268
        (list + (unsigned long )i)->fc4_type = 8U;
      } else {
#line 2270
        (list + (unsigned long )i)->fc4_type = 0U;
      }
    }
  }
#line 2274
  if ((unsigned int )(list + (unsigned long )i)->d_id.b.rsvd_1 != 0U) {
#line 2275
    goto ldv_61109;
  } else {

  }
  ldv_61108: 
#line 2228
  i = (uint16_t )((int )i + 1);
  ldv_61111: ;
#line 2228
  if ((int )ha->max_fibre_devices > (int )i) {
#line 2230
    goto ldv_61110;
  } else {

  }
  ldv_61109: ;
#line 2235
  return;
}
}
#line 2280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int reg_timer_7(struct timer_list *timer ) 
{ 


  {
#line 2281
  ldv_timer_list_7 = timer;
#line 2282
  ldv_timer_state_7 = 1;
#line 2283
  return (0);
}
}
#line 2286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
#line 2287
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_7) {
#line 2288
    ldv_timer_state_7 = 0;
#line 2289
    return;
  } else {

  }
#line 2291
  return;
}
}
#line 2294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2294
  if ((unsigned long )ldv_timer_list_7 == (unsigned long )timer) {
#line 2295
    if (ldv_timer_state_7 == 2 || pending_flag != 0) {
#line 2296
      ldv_timer_list_7 = timer;
#line 2297
      ldv_timer_list_7->data = data;
#line 2298
      ldv_timer_state_7 = 1;
    } else {

    }
#line 2300
    return;
  } else {

  }
#line 2302
  reg_timer_7(timer);
#line 2303
  ldv_timer_list_7->data = data;
#line 2304
  return;
}
}
#line 2307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
void choose_timer_7(struct timer_list *timer ) 
{ 


  {
#line 2308
  LDV_IN_INTERRUPT = 2;
#line 2309
  (*(timer->function))(timer->data);
#line 2310
  LDV_IN_INTERRUPT = 1;
#line 2311
  ldv_timer_state_7 = 2;
#line 2312
  return;
}
}
#line 2314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int ldv_del_timer_35(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 2318
  tmp = del_timer(ldv_func_arg1);
#line 2318
  ldv_func_res = tmp;
#line 2320
  disable_suitable_timer_7(ldv_func_arg1);
#line 2322
  return (ldv_func_res);
}
}
#line 2325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_gs.o.c.prepared"
int ldv_scsi_add_host_with_dma_36(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 2329
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 2329
  ldv_func_res = tmp;
#line 2331
  if (ldv_func_res == 0) {
#line 2332
    ldv_state_variable_72 = 1;
#line 2332
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 2336
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 124 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_39(struct timer_list *ldv_func_arg1 ) ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void disable_suitable_timer_8(struct timer_list *timer ) ;
#line 221
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 229
void choose_timer_8(struct timer_list *timer ) ;
#line 276
int reg_timer_8(struct timer_list *timer ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_40(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 512 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2xxx_dump_post_process(scsi_qla_host_t *vha , int rval ) ;
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static uint32_t ql_dbg_offset  =    2048U;
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void qla2xxx_prep_dump(struct qla_hw_data *ha , struct qla2xxx_fw_dump *fw_dump ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 377
  tmp = __fswab32((__u32 )ha->fw_major_version);
#line 377
  fw_dump->fw_major_version = tmp;
#line 378
  tmp___0 = __fswab32((__u32 )ha->fw_minor_version);
#line 378
  fw_dump->fw_minor_version = tmp___0;
#line 379
  tmp___1 = __fswab32((__u32 )ha->fw_subminor_version);
#line 379
  fw_dump->fw_subminor_version = tmp___1;
#line 380
  tmp___2 = __fswab32((__u32 )ha->fw_attributes);
#line 380
  fw_dump->fw_attributes = tmp___2;
#line 382
  tmp___3 = __fswab32((__u32 )(ha->pdev)->vendor);
#line 382
  fw_dump->vendor = tmp___3;
#line 383
  tmp___4 = __fswab32((__u32 )(ha->pdev)->device);
#line 383
  fw_dump->device = tmp___4;
#line 384
  tmp___5 = __fswab32((__u32 )(ha->pdev)->subsystem_vendor);
#line 384
  fw_dump->subsystem_vendor = tmp___5;
#line 385
  tmp___6 = __fswab32((__u32 )(ha->pdev)->subsystem_device);
#line 385
  fw_dump->subsystem_device = tmp___6;
#line 386
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla2xxx_copy_queues(struct qla_hw_data *ha , void *ptr ) 
{ 
  struct req_que *req ;
  struct rsp_que *rsp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 391
  req = *(ha->req_q_map);
#line 392
  rsp = *(ha->rsp_q_map);
#line 394
  __len = (unsigned long )req->length * 64UL;
#line 394
  __ret = __builtin_memcpy(ptr, (void const   *)req->ring, __len);
#line 398
  ptr = ptr + (unsigned long )req->length * 64UL;
#line 399
  __len___0 = (unsigned long )rsp->length * 64UL;
#line 399
  __ret___0 = __builtin_memcpy(ptr, (void const   *)rsp->ring, __len___0);
#line 402
  return (ptr + (unsigned long )rsp->length * 64UL);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static int qla24xx_dump_ram(struct qla_hw_data *ha , uint32_t addr , uint32_t *ram ,
                            uint32_t ram_dwords , void **nxt ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t stat ;
  uint32_t timer ;
  uint32_t dwords ;
  uint32_t idx ;
  uint16_t mb0 ;
  struct device_reg_24xx *reg ;
  dma_addr_t dump_dma ;
  uint32_t *dump ;
  int tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 412
  reg = & (ha->iobase)->isp24;
#line 413
  dump_dma = ha->gid_list_dma;
#line 414
  dump = (uint32_t *)ha->gid_list;
#line 416
  rval = 0;
#line 417
  mb0 = 0U;
#line 419
  writew(12, (void volatile   *)(& reg->mailbox0));
#line 420
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 422
  tmp = qla2x00_gid_list_size(ha);
#line 422
  dwords = (uint32_t )(tmp / 4);
#line 423
  cnt = 0U;
#line 423
  goto ldv_43494;
  ldv_43493: ;
#line 425
  if (cnt + dwords > ram_dwords) {
#line 426
    dwords = ram_dwords - cnt;
  } else {

  }
#line 428
  writew((int )((unsigned short )addr), (void volatile   *)(& reg->mailbox1));
#line 429
  writew((int )((unsigned short )(addr >> 16)), (void volatile   *)(& reg->mailbox8));
#line 431
  writew((int )((unsigned short )((unsigned int )dump_dma >> 16)), (void volatile   *)(& reg->mailbox2));
#line 432
  writew((int )((unsigned short )dump_dma), (void volatile   *)(& reg->mailbox3));
#line 433
  writew((int )((unsigned short )((unsigned int )(dump_dma >> 32ULL) >> 16)), (void volatile   *)(& reg->mailbox6));
#line 434
  writew((int )((unsigned short )(dump_dma >> 32ULL)), (void volatile   *)(& reg->mailbox7));
#line 436
  writew((int )((unsigned short )(dwords >> 16)), (void volatile   *)(& reg->mailbox4));
#line 437
  writew((int )((unsigned short )dwords), (void volatile   *)(& reg->mailbox5));
#line 438
  writel(1342177280U, (void volatile   *)(& reg->hccr));
#line 440
  timer = 6000000U;
#line 440
  goto ldv_43489;
  ldv_43488: 
#line 442
  stat = readl((void const volatile   *)(& reg->host_status));
#line 443
  if ((stat & 32768U) != 0U) {
#line 444
    stat = stat & 255U;
#line 446
    if (((stat == 1U || stat == 2U) || stat == 16U) || stat == 17U) {
#line 448
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 451
      mb0 = readw((void const volatile   *)(& reg->mailbox0));
#line 453
      writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 455
      readl((void const volatile   *)(& reg->hccr));
#line 456
      goto ldv_43487;
    } else {

    }
#line 460
    writel(2684354560U, (void volatile   *)(& reg->hccr));
#line 461
    readl((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 463
  __const_udelay(21475UL);
#line 440
  timer = timer - 1U;
  ldv_43489: ;
#line 440
  if (timer != 0U) {
#line 442
    goto ldv_43488;
  } else {

  }
  ldv_43487: 
#line 466
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 466
  if (tmp___1 != 0) {
#line 467
    rval = (int )mb0 & 16383;
#line 468
    idx = 0U;
#line 468
    goto ldv_43491;
    ldv_43490: 
#line 469
    tmp___0 = __fswab32(*(dump + (unsigned long )idx));
#line 469
    *(ram + (unsigned long )(cnt + idx)) = tmp___0;
#line 468
    idx = idx + 1U;
    ldv_43491: ;
#line 468
    if (idx < dwords) {
#line 470
      goto ldv_43490;
    } else {

    }

  } else {
#line 471
    rval = 258;
  }
#line 424
  cnt = cnt + dwords;
#line 424
  addr = addr + dwords;
  ldv_43494: ;
#line 423
  if (cnt < ram_dwords && rval == 0) {
#line 425
    goto ldv_43493;
  } else {

  }
#line 475
  *nxt = rval == 0 ? (void *)ram + (unsigned long )cnt : (void *)0;
#line 476
  return (rval);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static int qla24xx_dump_memory(struct qla_hw_data *ha , uint32_t *code_ram , uint32_t cram_size ,
                               void **nxt ) 
{ 
  int rval ;
  int tmp ;

  {
#line 486
  rval = qla24xx_dump_ram(ha, 131072U, code_ram, cram_size / 4U, nxt);
#line 487
  if (rval != 0) {
#line 488
    return (rval);
  } else {

  }
#line 491
  tmp = qla24xx_dump_ram(ha, 1048576U, (uint32_t *)*nxt, ha->fw_memory_size - 1048575U,
                         nxt);
#line 491
  return (tmp);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static uint32_t *qla24xx_read_window(struct device_reg_24xx *reg , uint32_t iobase ,
                                     uint32_t count , uint32_t *buf ) 
{ 
  uint32_t *dmp_reg ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 501
  writel(iobase, (void volatile   *)(& reg->iobase_addr));
#line 502
  dmp_reg = & reg->iobase_window;
#line 503
  goto ldv_43511;
  ldv_43510: 
#line 504
  tmp = buf;
#line 504
  buf = buf + 1;
#line 504
  tmp___0 = dmp_reg;
#line 504
  dmp_reg = dmp_reg + 1;
#line 504
  tmp___1 = readl((void const volatile   *)tmp___0);
#line 504
  tmp___2 = __fswab32(tmp___1);
#line 504
  *tmp = tmp___2;
  ldv_43511: 
#line 503
  tmp___3 = count;
#line 503
  count = count - 1U;
#line 503
  if (tmp___3 != 0U) {
#line 505
    goto ldv_43510;
  } else {

  }

#line 506
  return (buf);
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static int qla24xx_pause_risc(struct device_reg_24xx *reg ) 
{ 
  int rval ;
  uint32_t cnt ;
  unsigned int tmp ;

  {
#line 512
  rval = 0;
#line 515
  writel(805306368U, (void volatile   *)(& reg->hccr));
#line 516
  cnt = 30000U;
#line 516
  goto ldv_43519;
  ldv_43518: ;
#line 519
  if (cnt != 0U) {
#line 520
    __const_udelay(429500UL);
  } else {
#line 522
    rval = 256;
  }
#line 518
  cnt = cnt - 1U;
  ldv_43519: 
#line 516
  tmp = readl((void const volatile   *)(& reg->host_status));
#line 516
  if ((tmp & 256U) == 0U && rval == 0) {
#line 520
    goto ldv_43518;
  } else {

  }

#line 525
  return (rval);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static int qla24xx_soft_reset(struct qla_hw_data *ha ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint16_t mb0 ;
  uint16_t wd ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned int tmp___2 ;
  unsigned short tmp___3 ;

  {
#line 531
  rval = 0;
#line 534
  reg = & (ha->iobase)->isp24;
#line 537
  writel(65584U, (void volatile   *)(& reg->ctrl_status));
#line 538
  cnt = 0U;
#line 538
  goto ldv_43531;
  ldv_43530: 
#line 539
  tmp = readl((void const volatile   *)(& reg->ctrl_status));
#line 539
  if ((tmp & 131072U) == 0U) {
#line 540
    goto ldv_43529;
  } else {

  }
#line 542
  __const_udelay(42950UL);
#line 538
  cnt = cnt + 1U;
  ldv_43531: ;
#line 538
  if (cnt <= 29999U) {
#line 540
    goto ldv_43530;
  } else {

  }
  ldv_43529: 
#line 545
  writel(65585U, (void volatile   *)(& reg->ctrl_status));
#line 547
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 549
  __const_udelay(429500UL);
#line 551
  tmp___0 = readw((void const volatile   *)(& reg->mailbox0));
#line 551
  mb0 = tmp___0;
#line 552
  cnt = 10000U;
#line 552
  goto ldv_43533;
  ldv_43532: 
#line 553
  __const_udelay(21475UL);
#line 554
  tmp___1 = readw((void const volatile   *)(& reg->mailbox0));
#line 554
  mb0 = tmp___1;
#line 555
  __asm__  volatile   ("": : : "memory");
#line 552
  cnt = cnt - 1U;
  ldv_43533: ;
#line 552
  if (cnt != 0U && (unsigned int )mb0 != 0U) {
#line 554
    goto ldv_43532;
  } else {

  }
#line 559
  cnt = 0U;
#line 559
  goto ldv_43537;
  ldv_43536: 
#line 560
  tmp___2 = readl((void const volatile   *)(& reg->ctrl_status));
#line 560
  if ((tmp___2 & 1U) == 0U) {
#line 562
    goto ldv_43535;
  } else {

  }
#line 564
  __const_udelay(42950UL);
#line 559
  cnt = cnt + 1U;
  ldv_43537: ;
#line 559
  if (cnt <= 29999U) {
#line 561
    goto ldv_43536;
  } else {

  }
  ldv_43535: 
#line 566
  writel(536870912U, (void volatile   *)(& reg->hccr));
#line 567
  readl((void const volatile   *)(& reg->hccr));
#line 569
  cnt = 30000U;
#line 569
  goto ldv_43539;
  ldv_43538: ;
#line 571
  if (cnt != 0U) {
#line 572
    __const_udelay(429500UL);
  } else {
#line 574
    rval = 256;
  }
#line 570
  cnt = cnt - 1U;
  ldv_43539: 
#line 569
  tmp___3 = readw((void const volatile   *)(& reg->mailbox0));
#line 569
  if ((unsigned int )tmp___3 != 0U && rval == 0) {
#line 572
    goto ldv_43538;
  } else {

  }

#line 577
  return (rval);
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
static int qla2xxx_dump_ram(struct qla_hw_data *ha , uint32_t addr , uint16_t *ram ,
                            uint32_t ram_words , void **nxt ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t stat ;
  uint32_t timer ;
  uint32_t words ;
  uint32_t idx ;
  uint16_t mb0 ;
  struct device_reg_2xxx *reg ;
  dma_addr_t dump_dma ;
  uint16_t *dump ;
  int tmp ;
  __u16 tmp___0 ;
  int tmp___1 ;

  {
#line 587
  reg = & (ha->iobase)->isp;
#line 588
  dump_dma = ha->gid_list_dma;
#line 589
  dump = (uint16_t *)ha->gid_list;
#line 591
  rval = 0;
#line 592
  mb0 = 0U;
#line 594
  writew(12, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 595
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 597
  tmp = qla2x00_gid_list_size(ha);
#line 597
  words = (uint32_t )(tmp / 2);
#line 598
  cnt = 0U;
#line 598
  goto ldv_43565;
  ldv_43564: ;
#line 600
  if (cnt + words > ram_words) {
#line 601
    words = ram_words - cnt;
  } else {

  }
#line 603
  writew((int )((unsigned short )addr), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 604
  writew((int )((unsigned short )(addr >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u_end.isp2200.mailbox8) : (void volatile   *)(& reg->u.isp2300.mailbox0) + 8U);
#line 606
  writew((int )((unsigned short )((unsigned int )dump_dma >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 607
  writew((int )((unsigned short )dump_dma), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 3U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 3U);
#line 608
  writew((int )((unsigned short )((unsigned int )(dump_dma >> 32ULL) >> 16)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 6U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 6U);
#line 609
  writew((int )((unsigned short )(dump_dma >> 32ULL)), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 7U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 7U);
#line 611
  writew((int )((unsigned short )words), (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 4U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 4U);
#line 612
  writew(20480, (void volatile   *)(& reg->hccr));
#line 614
  timer = 6000000U;
#line 614
  goto ldv_43560;
  ldv_43559: 
#line 616
  stat = readl((void const volatile   *)(& reg->u.isp2300.host_status));
#line 617
  if ((stat & 32768U) != 0U) {
#line 618
    stat = stat & 255U;
#line 620
    if (stat == 1U || stat == 2U) {
#line 621
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 624
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 627
      writew(0, (void volatile   *)(& reg->semaphore));
#line 628
      writew(28672, (void volatile   *)(& reg->hccr));
#line 630
      readw((void const volatile   *)(& reg->hccr));
#line 631
      goto ldv_43558;
    } else
#line 632
    if (stat == 16U || stat == 17U) {
#line 633
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 636
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 638
      writew(28672, (void volatile   *)(& reg->hccr));
#line 640
      readw((void const volatile   *)(& reg->hccr));
#line 641
      goto ldv_43558;
    } else {

    }
#line 645
    writew(28672, (void volatile   *)(& reg->hccr));
#line 646
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 648
  __const_udelay(21475UL);
#line 614
  timer = timer - 1U;
  ldv_43560: ;
#line 614
  if (timer != 0U) {
#line 616
    goto ldv_43559;
  } else {

  }
  ldv_43558: 
#line 651
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 651
  if (tmp___1 != 0) {
#line 652
    rval = (int )mb0 & 16383;
#line 653
    idx = 0U;
#line 653
    goto ldv_43562;
    ldv_43561: 
#line 654
    tmp___0 = __fswab16((int )*(dump + (unsigned long )idx));
#line 654
    *(ram + (unsigned long )(cnt + idx)) = tmp___0;
#line 653
    idx = idx + 1U;
    ldv_43562: ;
#line 653
    if (idx < words) {
#line 655
      goto ldv_43561;
    } else {

    }

  } else {
#line 656
    rval = 258;
  }
#line 599
  cnt = cnt + words;
#line 599
  addr = addr + words;
  ldv_43565: ;
#line 598
  if (cnt < ram_words && rval == 0) {
#line 600
    goto ldv_43564;
  } else {

  }
#line 660
  *nxt = rval == 0 ? (void *)ram + (unsigned long )cnt : (void *)0;
#line 661
  return (rval);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void qla2xxx_read_window(struct device_reg_2xxx *reg , uint32_t count ,
                                         uint16_t *buf ) 
{ 
  uint16_t *dmp_reg ;
  uint16_t *tmp ;
  uint16_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 668
  dmp_reg = & reg->u.isp2300.fb_cmd;
#line 670
  goto ldv_43574;
  ldv_43573: 
#line 671
  tmp = buf;
#line 671
  buf = buf + 1;
#line 671
  tmp___0 = dmp_reg;
#line 671
  dmp_reg = dmp_reg + 1;
#line 671
  tmp___1 = readw((void const volatile   *)tmp___0);
#line 671
  tmp___2 = __fswab16((int )tmp___1);
#line 671
  *tmp = tmp___2;
  ldv_43574: 
#line 670
  tmp___3 = count;
#line 670
  count = count - 1U;
#line 670
  if (tmp___3 != 0U) {
#line 672
    goto ldv_43573;
  } else {

  }

#line 677
  return;
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla24xx_copy_eft(struct qla_hw_data *ha , void *ptr ) 
{ 
  size_t __len ;
  __u32 tmp ;
  void *__ret ;
  __u32 tmp___0 ;

  {
#line 677
  if ((unsigned long )ha->eft == (unsigned long )((void *)0)) {
#line 678
    return (ptr);
  } else {

  }
#line 680
  tmp = __fswab32((ha->fw_dump)->eft_size);
#line 680
  __len = (size_t )tmp;
#line 680
  __ret = __builtin_memcpy(ptr, (void const   *)ha->eft, __len);
#line 681
  tmp___0 = __fswab32((ha->fw_dump)->eft_size);
#line 681
  return (ptr + (unsigned long )tmp___0);
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla25xx_copy_fce(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  uint32_t cnt ;
  uint32_t *iter_reg ;
  struct qla2xxx_fce_chain *fcec ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  __u32 tmp___4 ;
  size_t __len ;
  __u32 tmp___5 ;
  void *__ret ;
  __u32 tmp___6 ;

  {
#line 689
  fcec = (struct qla2xxx_fce_chain *)ptr;
#line 691
  if ((unsigned long )ha->fce == (unsigned long )((void *)0)) {
#line 692
    return (ptr);
  } else {

  }
#line 694
  *last_chain = & fcec->type;
#line 695
  fcec->type = 4042981247U;
#line 696
  tmp = __fswab32(ha->fce_bufs * 1024U + 52U);
#line 696
  fcec->chain_size = tmp;
#line 698
  tmp___0 = __fswab32(ha->fce_bufs * 1024U);
#line 698
  fcec->size = tmp___0;
#line 699
  tmp___1 = __fswab32((unsigned int )ha->fce_dma);
#line 699
  fcec->addr_l = tmp___1;
#line 700
  tmp___2 = __fswab32((unsigned int )(ha->fce_dma >> 32ULL));
#line 700
  fcec->addr_h = tmp___2;
#line 702
  iter_reg = (uint32_t *)(& fcec->eregs);
#line 703
  cnt = 0U;
#line 703
  goto ldv_43592;
  ldv_43591: 
#line 704
  tmp___3 = iter_reg;
#line 704
  iter_reg = iter_reg + 1;
#line 704
  tmp___4 = __fswab32((__u32 )ha->fce_mb[cnt]);
#line 704
  *tmp___3 = tmp___4;
#line 703
  cnt = cnt + 1U;
  ldv_43592: ;
#line 703
  if (cnt <= 7U) {
#line 705
    goto ldv_43591;
  } else {

  }
#line 706
  tmp___5 = __fswab32(fcec->size);
#line 706
  __len = (size_t )tmp___5;
#line 706
  __ret = __builtin_memcpy((void *)iter_reg, (void const   *)ha->fce, __len);
#line 708
  tmp___6 = __fswab32(fcec->size);
#line 708
  return ((void *)iter_reg + (unsigned long )tmp___6);
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla2xxx_copy_atioqueues(struct qla_hw_data *ha , void *ptr ,
                                              uint32_t **last_chain ) 
{ 
  struct qla2xxx_mqueue_chain *q ;
  struct qla2xxx_mqueue_header *qh ;
  uint32_t num_queues ;
  int que ;
  struct __anonstruct_aq_308 aq ;
  struct __anonstruct_aqp_309 *aqp ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 724
  if ((unsigned long )ha->tgt.atio_ring == (unsigned long )((struct atio *)0)) {
#line 725
    return (ptr);
  } else {

  }
#line 727
  num_queues = 1U;
#line 728
  aqp = & aq;
#line 729
  aqp->length = (int )ha->tgt.atio_q_length;
#line 730
  aqp->ring = (void *)ha->tgt.atio_ring;
#line 732
  que = 0;
#line 732
  goto ldv_43615;
  ldv_43614: 
#line 734
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 735
  *last_chain = & q->type;
#line 736
  q->type = 4076535679U;
#line 737
  tmp = __fswab32((__u32 )((unsigned long )aqp->length) * 64U + 20U);
#line 737
  q->chain_size = tmp;
#line 741
  ptr = ptr + 8UL;
#line 744
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 745
  qh->queue = 50331648U;
#line 746
  tmp___0 = __fswab32((__u32 )que);
#line 746
  qh->number = tmp___0;
#line 747
  tmp___1 = __fswab32((__u32 )((unsigned long )aqp->length) * 64U);
#line 747
  qh->size = tmp___1;
#line 748
  ptr = ptr + 12UL;
#line 751
  __len = (unsigned long )aqp->length * 64UL;
#line 751
  __ret = __builtin_memcpy(ptr, (void const   *)aqp->ring, __len);
#line 753
  ptr = ptr + (unsigned long )aqp->length * 64UL;
#line 732
  que = que + 1;
  ldv_43615: ;
#line 732
  if ((uint32_t )que < num_queues) {
#line 734
    goto ldv_43614;
  } else {

  }

#line 756
  return (ptr);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla25xx_copy_mqueues(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  struct qla2xxx_mqueue_chain *q ;
  struct qla2xxx_mqueue_header *qh ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  int que ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 768
  if ((unsigned int )ha->mqenable == 0U) {
#line 769
    return (ptr);
  } else {

  }
#line 772
  que = 1;
#line 772
  goto ldv_43632;
  ldv_43631: 
#line 773
  req = *(ha->req_q_map + (unsigned long )que);
#line 774
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 775
    goto ldv_43627;
  } else {

  }
#line 778
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 779
  *last_chain = & q->type;
#line 780
  q->type = 4076535679U;
#line 781
  tmp = __fswab32((__u32 )req->length * 64U + 20U);
#line 781
  q->chain_size = tmp;
#line 785
  ptr = ptr + 8UL;
#line 788
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 789
  qh->queue = 16777216U;
#line 790
  tmp___0 = __fswab32((__u32 )que);
#line 790
  qh->number = tmp___0;
#line 791
  tmp___1 = __fswab32((__u32 )req->length * 64U);
#line 791
  qh->size = tmp___1;
#line 792
  ptr = ptr + 12UL;
#line 795
  __len = (unsigned long )req->length * 64UL;
#line 795
  __ret = __builtin_memcpy(ptr, (void const   *)req->ring, __len);
#line 796
  ptr = ptr + (unsigned long )req->length * 64UL;
#line 772
  que = que + 1;
  ldv_43632: ;
#line 772
  if ((int )ha->max_req_queues > que) {
#line 774
    goto ldv_43631;
  } else {

  }
  ldv_43627: 
#line 800
  que = 1;
#line 800
  goto ldv_43638;
  ldv_43637: 
#line 801
  rsp = *(ha->rsp_q_map + (unsigned long )que);
#line 802
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 803
    goto ldv_43633;
  } else {

  }
#line 806
  q = (struct qla2xxx_mqueue_chain *)ptr;
#line 807
  *last_chain = & q->type;
#line 808
  q->type = 4076535679U;
#line 809
  tmp___2 = __fswab32((__u32 )rsp->length * 64U + 20U);
#line 809
  q->chain_size = tmp___2;
#line 813
  ptr = ptr + 8UL;
#line 816
  qh = (struct qla2xxx_mqueue_header *)ptr;
#line 817
  qh->queue = 33554432U;
#line 818
  tmp___3 = __fswab32((__u32 )que);
#line 818
  qh->number = tmp___3;
#line 819
  tmp___4 = __fswab32((__u32 )rsp->length * 64U);
#line 819
  qh->size = tmp___4;
#line 820
  ptr = ptr + 12UL;
#line 823
  __len___0 = (unsigned long )rsp->length * 64UL;
#line 823
  __ret___0 = __builtin_memcpy(ptr, (void const   *)rsp->ring, __len___0);
#line 824
  ptr = ptr + (unsigned long )rsp->length * 64UL;
#line 800
  que = que + 1;
  ldv_43638: ;
#line 800
  if ((int )ha->max_rsp_queues > que) {
#line 802
    goto ldv_43637;
  } else {

  }
  ldv_43633: ;
#line 827
  return (ptr);
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static void *qla25xx_copy_mq(struct qla_hw_data *ha , void *ptr , uint32_t **last_chain ) 
{ 
  uint32_t cnt ;
  uint32_t que_idx ;
  uint8_t que_cnt ;
  struct qla2xxx_mq_chain *mq ;
  device_reg_t *reg ;
  __u32 tmp ;
  unsigned int tmp___0 ;
  __u32 tmp___1 ;
  unsigned int tmp___2 ;
  __u32 tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;

  {
#line 835
  mq = (struct qla2xxx_mq_chain *)ptr;
#line 838
  if ((unsigned int )ha->mqenable == 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 839
    return (ptr);
  } else {

  }
#line 841
  mq = (struct qla2xxx_mq_chain *)ptr;
#line 842
  *last_chain = & mq->type;
#line 843
  mq->type = 4059758463U;
#line 844
  mq->chain_size = 201457664U;
#line 846
  que_cnt = (uint8_t )((int )ha->max_req_queues > (int )ha->max_rsp_queues ? ha->max_req_queues : ha->max_rsp_queues);
#line 848
  tmp = __fswab32((__u32 )que_cnt);
#line 848
  mq->count = tmp;
#line 849
  cnt = 0U;
#line 849
  goto ldv_43650;
  ldv_43649: 
#line 850
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase + (unsigned long )(cnt * 4096U) : ha->iobase;
#line 851
  que_idx = cnt * 4U;
#line 852
  tmp___0 = readl((void const volatile   *)(& reg->isp25mq.req_q_in));
#line 852
  tmp___1 = __fswab32(tmp___0);
#line 852
  mq->qregs[que_idx] = tmp___1;
#line 854
  tmp___2 = readl((void const volatile   *)(& reg->isp25mq.req_q_out));
#line 854
  tmp___3 = __fswab32(tmp___2);
#line 854
  mq->qregs[que_idx + 1U] = tmp___3;
#line 856
  tmp___4 = readl((void const volatile   *)(& reg->isp25mq.rsp_q_in));
#line 856
  tmp___5 = __fswab32(tmp___4);
#line 856
  mq->qregs[que_idx + 2U] = tmp___5;
#line 858
  tmp___6 = readl((void const volatile   *)(& reg->isp25mq.rsp_q_out));
#line 858
  tmp___7 = __fswab32(tmp___6);
#line 858
  mq->qregs[que_idx + 3U] = tmp___7;
#line 849
  cnt = cnt + 1U;
  ldv_43650: ;
#line 849
  if ((uint32_t )que_cnt > cnt) {
#line 851
    goto ldv_43649;
  } else {

  }

#line 862
  return (ptr + 524UL);
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla2xxx_dump_post_process(scsi_qla_host_t *vha , int rval ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 868
  ha = vha->hw;
#line 870
  if (rval != 0) {
#line 871
    ql_log(1U, vha, 53248, "Failed to dump firmware (%x).\n", rval);
#line 873
    ha->fw_dumped = 0;
  } else {
#line 875
    ql_log(2U, vha, 53249, "Firmware dump saved to temp buffer (%ld/%p).\n", vha->host_no,
           ha->fw_dump);
#line 878
    ha->fw_dumped = 1;
#line 879
    qla2x00_post_uevent_work(vha, 0U);
  }
#line 881
  return;
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla2300_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint16_t *dmp_reg ;
  unsigned long flags ;
  struct qla2300_fw_dump *fw ;
  void *nxt ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  unsigned short tmp___3 ;
  uint16_t *tmp___4 ;
  unsigned short tmp___5 ;
  __u16 tmp___6 ;
  uint16_t *tmp___7 ;
  unsigned short tmp___8 ;
  __u16 tmp___9 ;
  uint16_t *tmp___10 ;
  unsigned short tmp___11 ;
  __u16 tmp___12 ;
  uint16_t *tmp___13 ;
  unsigned short tmp___14 ;
  __u16 tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;

  {
#line 893
  ha = vha->hw;
#line 894
  reg = & (ha->iobase)->isp;
#line 899
  tmp = pci_get_drvdata(ha->pdev);
#line 899
  base_vha = (struct scsi_qla_host *)tmp;
#line 901
  flags = 0UL;
#line 903
  if (hardware_locked == 0) {
#line 904
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 904
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 906
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 907
    ql_log(1U, vha, 53250, "No buffer available for dump.\n");
#line 909
    goto qla2300_fw_dump_failed;
  } else {

  }
#line 912
  if (ha->fw_dumped != 0) {
#line 913
    ql_log(1U, vha, 53251, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 917
    goto qla2300_fw_dump_failed;
  } else {

  }
#line 919
  fw = & (ha->fw_dump)->isp.isp23;
#line 920
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 922
  rval = 0;
#line 923
  tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 923
  tmp___2 = __fswab16((int )tmp___1);
#line 923
  fw->hccr = tmp___2;
#line 926
  writew(8192, (void volatile   *)(& reg->hccr));
#line 927
  if ((ha->device_type & 4U) != 0U) {
#line 928
    cnt = 30000U;
#line 928
    goto ldv_43675;
    ldv_43674: ;
#line 931
    if (cnt != 0U) {
#line 932
      __const_udelay(429500UL);
    } else {
#line 934
      rval = 256;
    }
#line 930
    cnt = cnt - 1U;
    ldv_43675: 
#line 928
    tmp___3 = readw((void const volatile   *)(& reg->hccr));
#line 928
    if (((int )tmp___3 & 32) == 0 && rval == 0) {
#line 932
      goto ldv_43674;
    } else {

    }

  } else {
#line 937
    readw((void const volatile   *)(& reg->hccr));
#line 938
    __const_udelay(42950UL);
  }
#line 941
  if (rval == 0) {
#line 942
    dmp_reg = & reg->flash_address;
#line 943
    cnt = 0U;
#line 943
    goto ldv_43678;
    ldv_43677: 
#line 944
    tmp___4 = dmp_reg;
#line 944
    dmp_reg = dmp_reg + 1;
#line 944
    tmp___5 = readw((void const volatile   *)tmp___4);
#line 944
    tmp___6 = __fswab16((int )tmp___5);
#line 944
    fw->pbiu_reg[cnt] = tmp___6;
#line 943
    cnt = cnt + 1U;
    ldv_43678: ;
#line 943
    if (cnt <= 7U) {
#line 945
      goto ldv_43677;
    } else {

    }
#line 946
    dmp_reg = & reg->u.isp2300.req_q_in;
#line 947
    cnt = 0U;
#line 947
    goto ldv_43681;
    ldv_43680: 
#line 948
    tmp___7 = dmp_reg;
#line 948
    dmp_reg = dmp_reg + 1;
#line 948
    tmp___8 = readw((void const volatile   *)tmp___7);
#line 948
    tmp___9 = __fswab16((int )tmp___8);
#line 948
    fw->risc_host_reg[cnt] = tmp___9;
#line 947
    cnt = cnt + 1U;
    ldv_43681: ;
#line 947
    if (cnt <= 7U) {
#line 949
      goto ldv_43680;
    } else {

    }
#line 950
    dmp_reg = & reg->u.isp2300.mailbox0;
#line 951
    cnt = 0U;
#line 951
    goto ldv_43684;
    ldv_43683: 
#line 952
    tmp___10 = dmp_reg;
#line 952
    dmp_reg = dmp_reg + 1;
#line 952
    tmp___11 = readw((void const volatile   *)tmp___10);
#line 952
    tmp___12 = __fswab16((int )tmp___11);
#line 952
    fw->mailbox_reg[cnt] = tmp___12;
#line 951
    cnt = cnt + 1U;
    ldv_43684: ;
#line 951
    if (cnt <= 31U) {
#line 953
      goto ldv_43683;
    } else {

    }
#line 954
    writew(64, (void volatile   *)(& reg->ctrl_status));
#line 955
    qla2xxx_read_window(reg, 32U, (uint16_t *)(& fw->resp_dma_reg));
#line 957
    writew(80, (void volatile   *)(& reg->ctrl_status));
#line 958
    qla2xxx_read_window(reg, 48U, (uint16_t *)(& fw->dma_reg));
#line 960
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 961
    dmp_reg = & reg->risc_hw;
#line 962
    cnt = 0U;
#line 962
    goto ldv_43687;
    ldv_43686: 
#line 963
    tmp___13 = dmp_reg;
#line 963
    dmp_reg = dmp_reg + 1;
#line 963
    tmp___14 = readw((void const volatile   *)tmp___13);
#line 963
    tmp___15 = __fswab16((int )tmp___14);
#line 963
    fw->risc_hdw_reg[cnt] = tmp___15;
#line 962
    cnt = cnt + 1U;
    ldv_43687: ;
#line 962
    if (cnt <= 15U) {
#line 964
      goto ldv_43686;
    } else {

    }
#line 965
    writew(8192, (void volatile   *)(& reg->pcr));
#line 966
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp0_reg));
#line 968
    writew(8704, (void volatile   *)(& reg->pcr));
#line 969
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp1_reg));
#line 971
    writew(9216, (void volatile   *)(& reg->pcr));
#line 972
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp2_reg));
#line 974
    writew(9728, (void volatile   *)(& reg->pcr));
#line 975
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp3_reg));
#line 977
    writew(10240, (void volatile   *)(& reg->pcr));
#line 978
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp4_reg));
#line 980
    writew(10752, (void volatile   *)(& reg->pcr));
#line 981
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp5_reg));
#line 983
    writew(11264, (void volatile   *)(& reg->pcr));
#line 984
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp6_reg));
#line 986
    writew(11776, (void volatile   *)(& reg->pcr));
#line 987
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp7_reg));
#line 989
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 990
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->frame_buf_hdw_reg));
#line 992
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 993
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b0_reg));
#line 995
    writew(48, (void volatile   *)(& reg->ctrl_status));
#line 996
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b1_reg));
#line 999
    writew(1, (void volatile   *)(& reg->ctrl_status));
#line 1000
    cnt = 0U;
#line 1000
    goto ldv_43691;
    ldv_43690: 
#line 1001
    tmp___16 = readw((void const volatile   *)(& reg->ctrl_status));
#line 1001
    if (((int )tmp___16 & 1) == 0) {
#line 1003
      goto ldv_43689;
    } else {

    }
#line 1005
    __const_udelay(42950UL);
#line 1000
    cnt = cnt + 1U;
    ldv_43691: ;
#line 1000
    if (cnt <= 29999U) {
#line 1002
      goto ldv_43690;
    } else {

    }
    ldv_43689: ;
  } else {

  }
#line 1009
  if ((ha->device_type & 4U) == 0U) {
#line 1010
    cnt = 30000U;
#line 1010
    goto ldv_43693;
    ldv_43692: ;
#line 1012
    if (cnt != 0U) {
#line 1013
      __const_udelay(429500UL);
    } else {
#line 1015
      rval = 256;
    }
#line 1011
    cnt = cnt - 1U;
    ldv_43693: 
#line 1010
    tmp___17 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1010
    if ((unsigned int )tmp___17 != 0U && rval == 0) {
#line 1013
      goto ldv_43692;
    } else {

    }

  } else {

  }
#line 1020
  if (rval == 0) {
#line 1021
    rval = qla2xxx_dump_ram(ha, 2048U, (uint16_t *)(& fw->risc_ram), 63488U, & nxt);
  } else {

  }
#line 1025
  if (rval == 0) {
#line 1026
    rval = qla2xxx_dump_ram(ha, 65536U, (uint16_t *)(& fw->stack_ram), 4096U, & nxt);
  } else {

  }
#line 1030
  if (rval == 0) {
#line 1031
    rval = qla2xxx_dump_ram(ha, 69632U, (uint16_t *)(& fw->data_ram), ha->fw_memory_size - 69631U,
                            & nxt);
  } else {

  }
#line 1034
  if (rval == 0) {
#line 1035
    qla2xxx_copy_queues(ha, nxt);
  } else {

  }
#line 1037
  qla2xxx_dump_post_process(base_vha, rval);
  qla2300_fw_dump_failed: ;
#line 1040
  if (hardware_locked == 0) {
#line 1041
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1042
  return;
}
}
#line 1050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla2100_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t timer ;
  uint16_t risc_address ;
  uint16_t mb0 ;
  uint16_t mb2 ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  uint16_t *dmp_reg ;
  unsigned long flags ;
  struct qla2100_fw_dump *fw ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned short tmp___1 ;
  __u16 tmp___2 ;
  unsigned short tmp___3 ;
  uint16_t *tmp___4 ;
  unsigned short tmp___5 ;
  __u16 tmp___6 ;
  uint16_t *tmp___7 ;
  unsigned short tmp___8 ;
  __u16 tmp___9 ;
  uint16_t *tmp___10 ;
  unsigned short tmp___11 ;
  __u16 tmp___12 ;
  uint16_t *tmp___13 ;
  unsigned short tmp___14 ;
  __u16 tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;
  unsigned short tmp___18 ;
  unsigned short tmp___19 ;
  unsigned short tmp___20 ;
  __u16 tmp___21 ;
  int tmp___22 ;

  {
#line 1056
  ha = vha->hw;
#line 1057
  reg = & (ha->iobase)->isp;
#line 1061
  tmp = pci_get_drvdata(ha->pdev);
#line 1061
  base_vha = (struct scsi_qla_host *)tmp;
#line 1063
  risc_address = 0U;
#line 1064
  mb2 = 0U;
#line 1064
  mb0 = mb2;
#line 1065
  flags = 0UL;
#line 1067
  if (hardware_locked == 0) {
#line 1068
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1068
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1070
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1071
    ql_log(1U, vha, 53252, "No buffer available for dump.\n");
#line 1073
    goto qla2100_fw_dump_failed;
  } else {

  }
#line 1076
  if (ha->fw_dumped != 0) {
#line 1077
    ql_log(1U, vha, 53253, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1081
    goto qla2100_fw_dump_failed;
  } else {

  }
#line 1083
  fw = & (ha->fw_dump)->isp.isp21;
#line 1084
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1086
  rval = 0;
#line 1087
  tmp___1 = readw((void const volatile   *)(& reg->hccr));
#line 1087
  tmp___2 = __fswab16((int )tmp___1);
#line 1087
  fw->hccr = tmp___2;
#line 1090
  writew(8192, (void volatile   *)(& reg->hccr));
#line 1091
  cnt = 30000U;
#line 1091
  goto ldv_43716;
  ldv_43715: ;
#line 1093
  if (cnt != 0U) {
#line 1094
    __const_udelay(429500UL);
  } else {
#line 1096
    rval = 256;
  }
#line 1092
  cnt = cnt - 1U;
  ldv_43716: 
#line 1091
  tmp___3 = readw((void const volatile   *)(& reg->hccr));
#line 1091
  if (((int )tmp___3 & 32) == 0 && rval == 0) {
#line 1094
    goto ldv_43715;
  } else {

  }

#line 1098
  if (rval == 0) {
#line 1099
    dmp_reg = & reg->flash_address;
#line 1100
    cnt = 0U;
#line 1100
    goto ldv_43719;
    ldv_43718: 
#line 1101
    tmp___4 = dmp_reg;
#line 1101
    dmp_reg = dmp_reg + 1;
#line 1101
    tmp___5 = readw((void const volatile   *)tmp___4);
#line 1101
    tmp___6 = __fswab16((int )tmp___5);
#line 1101
    fw->pbiu_reg[cnt] = tmp___6;
#line 1100
    cnt = cnt + 1U;
    ldv_43719: ;
#line 1100
    if (cnt <= 7U) {
#line 1102
      goto ldv_43718;
    } else {

    }
#line 1103
    dmp_reg = & reg->u.isp2100.mailbox0;
#line 1104
    cnt = 0U;
#line 1104
    goto ldv_43722;
    ldv_43721: ;
#line 1105
    if (cnt == 8U) {
#line 1106
      dmp_reg = & reg->u_end.isp2200.mailbox8;
    } else {

    }
#line 1108
    tmp___7 = dmp_reg;
#line 1108
    dmp_reg = dmp_reg + 1;
#line 1108
    tmp___8 = readw((void const volatile   *)tmp___7);
#line 1108
    tmp___9 = __fswab16((int )tmp___8);
#line 1108
    fw->mailbox_reg[cnt] = tmp___9;
#line 1104
    cnt = cnt + 1U;
    ldv_43722: ;
#line 1104
    if ((uint32_t )ha->mbx_count > cnt) {
#line 1106
      goto ldv_43721;
    } else {

    }
#line 1111
    dmp_reg = (uint16_t *)(& reg->u.isp2100.unused_2);
#line 1112
    cnt = 0U;
#line 1112
    goto ldv_43725;
    ldv_43724: 
#line 1113
    tmp___10 = dmp_reg;
#line 1113
    dmp_reg = dmp_reg + 1;
#line 1113
    tmp___11 = readw((void const volatile   *)tmp___10);
#line 1113
    tmp___12 = __fswab16((int )tmp___11);
#line 1113
    fw->dma_reg[cnt] = tmp___12;
#line 1112
    cnt = cnt + 1U;
    ldv_43725: ;
#line 1112
    if (cnt <= 47U) {
#line 1114
      goto ldv_43724;
    } else {

    }
#line 1115
    writew(0, (void volatile   *)(& reg->ctrl_status));
#line 1116
    dmp_reg = & reg->risc_hw;
#line 1117
    cnt = 0U;
#line 1117
    goto ldv_43728;
    ldv_43727: 
#line 1118
    tmp___13 = dmp_reg;
#line 1118
    dmp_reg = dmp_reg + 1;
#line 1118
    tmp___14 = readw((void const volatile   *)tmp___13);
#line 1118
    tmp___15 = __fswab16((int )tmp___14);
#line 1118
    fw->risc_hdw_reg[cnt] = tmp___15;
#line 1117
    cnt = cnt + 1U;
    ldv_43728: ;
#line 1117
    if (cnt <= 15U) {
#line 1119
      goto ldv_43727;
    } else {

    }
#line 1120
    writew(8192, (void volatile   *)(& reg->pcr));
#line 1121
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp0_reg));
#line 1123
    writew(8448, (void volatile   *)(& reg->pcr));
#line 1124
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp1_reg));
#line 1126
    writew(8704, (void volatile   *)(& reg->pcr));
#line 1127
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp2_reg));
#line 1129
    writew(8960, (void volatile   *)(& reg->pcr));
#line 1130
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp3_reg));
#line 1132
    writew(9216, (void volatile   *)(& reg->pcr));
#line 1133
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp4_reg));
#line 1135
    writew(9472, (void volatile   *)(& reg->pcr));
#line 1136
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp5_reg));
#line 1138
    writew(9728, (void volatile   *)(& reg->pcr));
#line 1139
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp6_reg));
#line 1141
    writew(9984, (void volatile   *)(& reg->pcr));
#line 1142
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->risc_gp7_reg));
#line 1144
    writew(16, (void volatile   *)(& reg->ctrl_status));
#line 1145
    qla2xxx_read_window(reg, 16U, (uint16_t *)(& fw->frame_buf_hdw_reg));
#line 1147
    writew(32, (void volatile   *)(& reg->ctrl_status));
#line 1148
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b0_reg));
#line 1150
    writew(48, (void volatile   *)(& reg->ctrl_status));
#line 1151
    qla2xxx_read_window(reg, 64U, (uint16_t *)(& fw->fpm_b1_reg));
#line 1154
    writew(1, (void volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 1157
  cnt = 30000U;
#line 1157
  goto ldv_43731;
  ldv_43730: ;
#line 1159
  if (cnt != 0U) {
#line 1160
    __const_udelay(429500UL);
  } else {
#line 1162
    rval = 256;
  }
#line 1158
  cnt = cnt - 1U;
  ldv_43731: 
#line 1157
  tmp___16 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1157
  if ((unsigned int )tmp___16 != 0U && rval == 0) {
#line 1160
    goto ldv_43730;
  } else {

  }

#line 1166
  if (rval == 0) {
#line 1166
    if ((ha->device_type & 2U) != 0U) {
#line 1166
      goto _L;
    } else
#line 1166
    if ((int )ha->device_type & 1) {
#line 1166
      tmp___18 = readw((void const volatile   *)(& reg->mctr));
#line 1166
      if (((int )tmp___18 & 3) != 0) {
        _L: /* CIL Label */ 
#line 1169
        writew(8192, (void volatile   *)(& reg->hccr));
#line 1170
        cnt = 30000U;
#line 1170
        goto ldv_43734;
        ldv_43733: ;
#line 1173
        if (cnt != 0U) {
#line 1174
          __const_udelay(429500UL);
        } else {
#line 1176
          rval = 256;
        }
#line 1172
        cnt = cnt - 1U;
        ldv_43734: 
#line 1170
        tmp___17 = readw((void const volatile   *)(& reg->hccr));
#line 1170
        if (((int )tmp___17 & 32) == 0 && rval == 0) {
#line 1174
          goto ldv_43733;
        } else {

        }

#line 1178
        if (rval == 0) {
#line 1180
          if ((int )ha->device_type & 1) {
#line 1181
            writew(241, (void volatile   *)(& reg->mctr));
          } else {
#line 1183
            writew(242, (void volatile   *)(& reg->mctr));
          }
#line 1184
          readw((void const volatile   *)(& reg->mctr));
#line 1187
          writew(12288, (void volatile   *)(& reg->hccr));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1191
  if (rval == 0) {
#line 1193
    risc_address = 4096U;
#line 1194
    writew(5, (void volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1195
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
  } else {

  }
#line 1197
  cnt = 0U;
#line 1197
  goto ldv_43740;
  ldv_43739: 
#line 1199
  writew((int )risc_address, (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void volatile   *)(& reg->u.isp2100.mailbox0) + 1U : (void volatile   *)(& reg->u.isp2300.mailbox0) + 1U);
#line 1200
  writew(20480, (void volatile   *)(& reg->hccr));
#line 1202
  timer = 6000000U;
#line 1202
  goto ldv_43738;
  ldv_43737: 
#line 1204
  tmp___20 = readw((void const volatile   *)(& reg->istatus));
#line 1204
  if (((int )tmp___20 & 8) != 0) {
#line 1205
    tmp___19 = readw((void const volatile   *)(& reg->semaphore));
#line 1205
    if ((int )tmp___19 & 1) {
#line 1206
      set_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 1209
      mb0 = readw((void const volatile   *)((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0));
#line 1210
      mb2 = readw((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? (void const volatile   *)(& reg->u.isp2100.mailbox0) + 2U : (void const volatile   *)(& reg->u.isp2300.mailbox0) + 2U);
#line 1212
      writew(0, (void volatile   *)(& reg->semaphore));
#line 1213
      writew(28672, (void volatile   *)(& reg->hccr));
#line 1215
      readw((void const volatile   *)(& reg->hccr));
#line 1216
      goto ldv_43736;
    } else {

    }
#line 1218
    writew(28672, (void volatile   *)(& reg->hccr));
#line 1219
    readw((void const volatile   *)(& reg->hccr));
  } else {

  }
#line 1221
  __const_udelay(21475UL);
#line 1202
  timer = timer - 1U;
  ldv_43738: ;
#line 1202
  if (timer != 0U) {
#line 1204
    goto ldv_43737;
  } else {

  }
  ldv_43736: 
#line 1224
  tmp___22 = test_and_clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 1224
  if (tmp___22 != 0) {
#line 1225
    rval = (int )mb0 & 16383;
#line 1226
    tmp___21 = __fswab16((int )mb2);
#line 1226
    fw->risc_ram[cnt] = tmp___21;
  } else {
#line 1228
    rval = 258;
  }
#line 1198
  cnt = cnt + 1U;
#line 1198
  risc_address = (uint16_t )((int )risc_address + 1);
  ldv_43740: ;
#line 1197
  if (cnt <= 61439U && rval == 0) {
#line 1199
    goto ldv_43739;
  } else {

  }

#line 1232
  if (rval == 0) {
#line 1233
    qla2xxx_copy_queues(ha, (void *)(& fw->risc_ram) + (unsigned long )cnt);
  } else {

  }
#line 1235
  qla2xxx_dump_post_process(base_vha, rval);
  qla2100_fw_dump_failed: ;
#line 1238
  if (hardware_locked == 0) {
#line 1239
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1240
  return;
}
}
#line 1243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla24xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla24xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;
  unsigned int tmp___8 ;
  __u32 tmp___9 ;
  unsigned int tmp___10 ;
  __u32 tmp___11 ;
  unsigned int tmp___12 ;
  __u32 tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  uint16_t *tmp___20 ;
  unsigned short tmp___21 ;
  __u16 tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  unsigned int tmp___25 ;
  __u32 tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  unsigned int tmp___29 ;
  __u32 tmp___30 ;
  uint32_t *tmp___31 ;
  uint32_t *tmp___32 ;
  unsigned int tmp___33 ;
  __u32 tmp___34 ;

  {
#line 1248
  ha = vha->hw;
#line 1249
  reg = & (ha->iobase)->isp24;
#line 1258
  last_chain = (uint32_t *)0U;
#line 1259
  tmp = pci_get_drvdata(ha->pdev);
#line 1259
  base_vha = (struct scsi_qla_host *)tmp;
#line 1261
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1262
    return;
  } else {

  }
#line 1264
  ext_mem_cnt = 0U;
#line 1264
  risc_address = ext_mem_cnt;
#line 1265
  flags = 0UL;
#line 1267
  if (hardware_locked == 0) {
#line 1268
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1268
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1270
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1271
    ql_log(1U, vha, 53254, "No buffer available for dump.\n");
#line 1273
    goto qla24xx_fw_dump_failed;
  } else {

  }
#line 1276
  if (ha->fw_dumped != 0) {
#line 1277
    ql_log(1U, vha, 53255, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1281
    goto qla24xx_fw_dump_failed;
  } else {

  }
#line 1283
  fw = & (ha->fw_dump)->isp.isp24;
#line 1284
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1286
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1286
  tmp___2 = __fswab32(tmp___1);
#line 1286
  fw->host_status = tmp___2;
#line 1289
  rval = qla24xx_pause_risc(reg);
#line 1290
  if (rval != 0) {
#line 1291
    goto qla24xx_fw_dump_failed_0;
  } else {

  }
#line 1294
  dmp_reg = & reg->flash_addr;
#line 1295
  cnt = 0U;
#line 1295
  goto ldv_43767;
  ldv_43766: 
#line 1296
  tmp___3 = dmp_reg;
#line 1296
  dmp_reg = dmp_reg + 1;
#line 1296
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1296
  tmp___5 = __fswab32(tmp___4);
#line 1296
  fw->host_reg[cnt] = tmp___5;
#line 1295
  cnt = cnt + 1U;
  ldv_43767: ;
#line 1295
  if (cnt <= 31U) {
#line 1297
    goto ldv_43766;
  } else {

  }
#line 1299
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1300
  readl((void const volatile   *)(& reg->ictrl));
#line 1303
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1304
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1305
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1306
  tmp___6 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1306
  tmp___7 = __fswab32(tmp___6);
#line 1306
  fw->shadow_reg[0] = tmp___7;
#line 1308
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1309
  tmp___8 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1309
  tmp___9 = __fswab32(tmp___8);
#line 1309
  fw->shadow_reg[1] = tmp___9;
#line 1311
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1312
  tmp___10 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1312
  tmp___11 = __fswab32(tmp___10);
#line 1312
  fw->shadow_reg[2] = tmp___11;
#line 1314
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1315
  tmp___12 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1315
  tmp___13 = __fswab32(tmp___12);
#line 1315
  fw->shadow_reg[3] = tmp___13;
#line 1317
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1318
  tmp___14 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1318
  tmp___15 = __fswab32(tmp___14);
#line 1318
  fw->shadow_reg[4] = tmp___15;
#line 1320
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1321
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1321
  tmp___17 = __fswab32(tmp___16);
#line 1321
  fw->shadow_reg[5] = tmp___17;
#line 1323
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1324
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1324
  tmp___19 = __fswab32(tmp___18);
#line 1324
  fw->shadow_reg[6] = tmp___19;
#line 1327
  mbx_reg = & reg->mailbox0;
#line 1328
  cnt = 0U;
#line 1328
  goto ldv_43770;
  ldv_43769: 
#line 1329
  tmp___20 = mbx_reg;
#line 1329
  mbx_reg = mbx_reg + 1;
#line 1329
  tmp___21 = readw((void const volatile   *)tmp___20);
#line 1329
  tmp___22 = __fswab16((int )tmp___21);
#line 1329
  fw->mailbox_reg[cnt] = tmp___22;
#line 1328
  cnt = cnt + 1U;
  ldv_43770: ;
#line 1328
  if (cnt <= 31U) {
#line 1330
    goto ldv_43769;
  } else {

  }
#line 1332
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1333
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1334
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1335
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1336
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1337
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1338
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1339
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1340
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1342
  qla24xx_read_window(reg, 49120U, 16U, (uint32_t *)(& fw->xseq_0_reg));
#line 1343
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1346
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1347
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1348
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1349
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1350
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1351
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1352
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1353
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1354
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1356
  qla24xx_read_window(reg, 65488U, 16U, (uint32_t *)(& fw->rseq_0_reg));
#line 1357
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1358
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1361
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1364
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1365
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1366
  dmp_reg = & reg->iobase_q;
#line 1367
  cnt = 0U;
#line 1367
  goto ldv_43773;
  ldv_43772: 
#line 1368
  tmp___23 = iter_reg;
#line 1368
  iter_reg = iter_reg + 1;
#line 1368
  tmp___24 = dmp_reg;
#line 1368
  dmp_reg = dmp_reg + 1;
#line 1368
  tmp___25 = readl((void const volatile   *)tmp___24);
#line 1368
  tmp___26 = __fswab32(tmp___25);
#line 1368
  *tmp___23 = tmp___26;
#line 1367
  cnt = cnt + 1U;
  ldv_43773: ;
#line 1367
  if (cnt <= 6U) {
#line 1369
    goto ldv_43772;
  } else {

  }
#line 1370
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1371
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1372
  dmp_reg = & reg->iobase_q;
#line 1373
  cnt = 0U;
#line 1373
  goto ldv_43776;
  ldv_43775: 
#line 1374
  tmp___27 = iter_reg;
#line 1374
  iter_reg = iter_reg + 1;
#line 1374
  tmp___28 = dmp_reg;
#line 1374
  dmp_reg = dmp_reg + 1;
#line 1374
  tmp___29 = readl((void const volatile   *)tmp___28);
#line 1374
  tmp___30 = __fswab32(tmp___29);
#line 1374
  *tmp___27 = tmp___30;
#line 1373
  cnt = cnt + 1U;
  ldv_43776: ;
#line 1373
  if (cnt <= 6U) {
#line 1375
    goto ldv_43775;
  } else {

  }
#line 1376
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 1377
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 1378
  dmp_reg = & reg->iobase_q;
#line 1379
  cnt = 0U;
#line 1379
  goto ldv_43779;
  ldv_43778: 
#line 1380
  tmp___31 = iter_reg;
#line 1380
  iter_reg = iter_reg + 1;
#line 1380
  tmp___32 = dmp_reg;
#line 1380
  dmp_reg = dmp_reg + 1;
#line 1380
  tmp___33 = readl((void const volatile   *)tmp___32);
#line 1380
  tmp___34 = __fswab32(tmp___33);
#line 1380
  *tmp___31 = tmp___34;
#line 1379
  cnt = cnt + 1U;
  ldv_43779: ;
#line 1379
  if (cnt <= 6U) {
#line 1381
    goto ldv_43778;
  } else {

  }
#line 1383
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 1384
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 1385
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 1387
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 1388
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 1389
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 1391
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 1392
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 1393
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 1395
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 1396
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 1397
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 1399
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 1400
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 1401
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 1403
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 1406
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 1407
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 1408
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 1410
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 1411
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 1412
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 1415
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 1416
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 1417
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 1418
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 1419
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 1420
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 1421
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 1422
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 1423
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 1426
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 1427
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 1428
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 1429
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 1430
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 1431
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 1432
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 1433
  qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 1436
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 1437
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 1438
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 1439
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 1440
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 1441
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 1442
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 1443
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 1444
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 1445
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 1446
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 1447
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 1448
  qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 1451
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 1452
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 1453
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 1454
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 1455
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 1456
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 1457
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 1458
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 1459
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 1460
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 1461
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 1462
  qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 1464
  rval = qla24xx_soft_reset(ha);
#line 1465
  if (rval != 0) {
#line 1466
    goto qla24xx_fw_dump_failed_0;
  } else {

  }
#line 1468
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 1470
  if (rval != 0) {
#line 1471
    goto qla24xx_fw_dump_failed_0;
  } else {

  }
#line 1473
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 1475
  qla24xx_copy_eft(ha, nxt);
#line 1477
  nxt_chain = (void *)ha->fw_dump + (unsigned long )ha->chain_offset;
#line 1478
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 1479
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 1480
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 1481
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 1485
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla24xx_fw_dump_failed_0: 
#line 1488
  qla2xxx_dump_post_process(base_vha, rval);
  qla24xx_fw_dump_failed: ;
#line 1491
  if (hardware_locked == 0) {
#line 1492
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1493
  return;
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla25xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla25xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;

  {
#line 1501
  ha = vha->hw;
#line 1502
  reg = & (ha->iobase)->isp24;
#line 1510
  last_chain = (uint32_t *)0U;
#line 1511
  tmp = pci_get_drvdata(ha->pdev);
#line 1511
  base_vha = (struct scsi_qla_host *)tmp;
#line 1513
  ext_mem_cnt = 0U;
#line 1513
  risc_address = ext_mem_cnt;
#line 1514
  flags = 0UL;
#line 1516
  if (hardware_locked == 0) {
#line 1517
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1517
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1519
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1520
    ql_log(1U, vha, 53256, "No buffer available for dump.\n");
#line 1522
    goto qla25xx_fw_dump_failed;
  } else {

  }
#line 1525
  if (ha->fw_dumped != 0) {
#line 1526
    ql_log(1U, vha, 53257, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1530
    goto qla25xx_fw_dump_failed;
  } else {

  }
#line 1532
  fw = & (ha->fw_dump)->isp.isp25;
#line 1533
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1534
  (ha->fw_dump)->version = 33554432U;
#line 1536
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1536
  tmp___2 = __fswab32(tmp___1);
#line 1536
  fw->host_status = tmp___2;
#line 1539
  rval = qla24xx_pause_risc(reg);
#line 1540
  if (rval != 0) {
#line 1541
    goto qla25xx_fw_dump_failed_0;
  } else {

  }
#line 1544
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 1545
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 1546
  qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 1549
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 1550
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1551
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 1552
  dmp_reg = & reg->iobase_c4;
#line 1553
  tmp___3 = dmp_reg;
#line 1553
  dmp_reg = dmp_reg + 1;
#line 1553
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1553
  tmp___5 = __fswab32(tmp___4);
#line 1553
  fw->pcie_regs[0] = tmp___5;
#line 1554
  tmp___6 = dmp_reg;
#line 1554
  dmp_reg = dmp_reg + 1;
#line 1554
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 1554
  tmp___8 = __fswab32(tmp___7);
#line 1554
  fw->pcie_regs[1] = tmp___8;
#line 1555
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 1555
  tmp___10 = __fswab32(tmp___9);
#line 1555
  fw->pcie_regs[2] = tmp___10;
#line 1556
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 1556
  tmp___12 = __fswab32(tmp___11);
#line 1556
  fw->pcie_regs[3] = tmp___12;
#line 1558
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 1559
  readl((void const volatile   *)(& reg->iobase_window));
#line 1562
  dmp_reg = & reg->flash_addr;
#line 1563
  cnt = 0U;
#line 1563
  goto ldv_43806;
  ldv_43805: 
#line 1564
  tmp___13 = dmp_reg;
#line 1564
  dmp_reg = dmp_reg + 1;
#line 1564
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 1564
  tmp___15 = __fswab32(tmp___14);
#line 1564
  fw->host_reg[cnt] = tmp___15;
#line 1563
  cnt = cnt + 1U;
  ldv_43806: ;
#line 1563
  if (cnt <= 31U) {
#line 1565
    goto ldv_43805;
  } else {

  }
#line 1567
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1568
  readl((void const volatile   *)(& reg->ictrl));
#line 1571
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1572
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1573
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1574
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1574
  tmp___17 = __fswab32(tmp___16);
#line 1574
  fw->shadow_reg[0] = tmp___17;
#line 1576
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1577
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1577
  tmp___19 = __fswab32(tmp___18);
#line 1577
  fw->shadow_reg[1] = tmp___19;
#line 1579
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1580
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1580
  tmp___21 = __fswab32(tmp___20);
#line 1580
  fw->shadow_reg[2] = tmp___21;
#line 1582
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1583
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1583
  tmp___23 = __fswab32(tmp___22);
#line 1583
  fw->shadow_reg[3] = tmp___23;
#line 1585
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1586
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1586
  tmp___25 = __fswab32(tmp___24);
#line 1586
  fw->shadow_reg[4] = tmp___25;
#line 1588
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1589
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1589
  tmp___27 = __fswab32(tmp___26);
#line 1589
  fw->shadow_reg[5] = tmp___27;
#line 1591
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1592
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1592
  tmp___29 = __fswab32(tmp___28);
#line 1592
  fw->shadow_reg[6] = tmp___29;
#line 1594
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 1595
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1595
  tmp___31 = __fswab32(tmp___30);
#line 1595
  fw->shadow_reg[7] = tmp___31;
#line 1597
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 1598
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1598
  tmp___33 = __fswab32(tmp___32);
#line 1598
  fw->shadow_reg[8] = tmp___33;
#line 1600
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 1601
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1601
  tmp___35 = __fswab32(tmp___34);
#line 1601
  fw->shadow_reg[9] = tmp___35;
#line 1603
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 1604
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1604
  tmp___37 = __fswab32(tmp___36);
#line 1604
  fw->shadow_reg[10] = tmp___37;
#line 1607
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 1608
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 1608
  tmp___39 = __fswab32(tmp___38);
#line 1608
  fw->risc_io_reg = tmp___39;
#line 1611
  mbx_reg = & reg->mailbox0;
#line 1612
  cnt = 0U;
#line 1612
  goto ldv_43809;
  ldv_43808: 
#line 1613
  tmp___40 = mbx_reg;
#line 1613
  mbx_reg = mbx_reg + 1;
#line 1613
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 1613
  tmp___42 = __fswab16((int )tmp___41);
#line 1613
  fw->mailbox_reg[cnt] = tmp___42;
#line 1612
  cnt = cnt + 1U;
  ldv_43809: ;
#line 1612
  if (cnt <= 31U) {
#line 1614
    goto ldv_43808;
  } else {

  }
#line 1616
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1617
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1618
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1619
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1620
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1621
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1622
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1623
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1624
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1626
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 1627
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 1628
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 1629
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 1631
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1634
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1635
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1636
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1637
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1638
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1639
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1640
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1641
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1642
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1644
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 1645
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 1646
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 1648
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1649
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1652
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 1653
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 1654
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 1655
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 1656
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 1657
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 1658
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 1659
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 1660
  qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 1662
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 1663
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 1664
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 1666
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 1667
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 1670
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1673
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1674
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1675
  dmp_reg = & reg->iobase_q;
#line 1676
  cnt = 0U;
#line 1676
  goto ldv_43812;
  ldv_43811: 
#line 1677
  tmp___43 = iter_reg;
#line 1677
  iter_reg = iter_reg + 1;
#line 1677
  tmp___44 = dmp_reg;
#line 1677
  dmp_reg = dmp_reg + 1;
#line 1677
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 1677
  tmp___46 = __fswab32(tmp___45);
#line 1677
  *tmp___43 = tmp___46;
#line 1676
  cnt = cnt + 1U;
  ldv_43812: ;
#line 1676
  if (cnt <= 6U) {
#line 1678
    goto ldv_43811;
  } else {

  }
#line 1679
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1680
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1681
  dmp_reg = & reg->iobase_q;
#line 1682
  cnt = 0U;
#line 1682
  goto ldv_43815;
  ldv_43814: 
#line 1683
  tmp___47 = iter_reg;
#line 1683
  iter_reg = iter_reg + 1;
#line 1683
  tmp___48 = dmp_reg;
#line 1683
  dmp_reg = dmp_reg + 1;
#line 1683
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 1683
  tmp___50 = __fswab32(tmp___49);
#line 1683
  *tmp___47 = tmp___50;
#line 1682
  cnt = cnt + 1U;
  ldv_43815: ;
#line 1682
  if (cnt <= 6U) {
#line 1684
    goto ldv_43814;
  } else {

  }
#line 1685
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 1686
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 1687
  dmp_reg = & reg->iobase_q;
#line 1688
  cnt = 0U;
#line 1688
  goto ldv_43818;
  ldv_43817: 
#line 1689
  tmp___51 = iter_reg;
#line 1689
  iter_reg = iter_reg + 1;
#line 1689
  tmp___52 = dmp_reg;
#line 1689
  dmp_reg = dmp_reg + 1;
#line 1689
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 1689
  tmp___54 = __fswab32(tmp___53);
#line 1689
  *tmp___51 = tmp___54;
#line 1688
  cnt = cnt + 1U;
  ldv_43818: ;
#line 1688
  if (cnt <= 6U) {
#line 1690
    goto ldv_43817;
  } else {

  }
#line 1692
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 1693
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 1694
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 1696
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 1697
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 1698
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 1700
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 1701
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 1702
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 1704
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 1705
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 1706
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 1708
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 1709
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 1710
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 1712
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 1715
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 1716
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 1717
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 1719
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 1720
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 1721
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 1724
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 1725
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 1726
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 1727
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 1728
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 1729
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 1730
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 1731
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 1732
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 1735
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 1736
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 1737
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 1738
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 1739
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 1740
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 1741
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 1742
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 1743
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 1746
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 1747
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 1748
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 1749
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 1750
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 1751
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 1752
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 1753
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 1754
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 1755
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 1756
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 1757
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 1758
  qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 1761
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 1762
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 1763
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 1764
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 1765
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 1766
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 1767
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 1768
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 1769
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 1770
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 1771
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 1772
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 1773
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 1776
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 1779
  rval = qla24xx_soft_reset(ha);
#line 1780
  if (rval != 0) {
#line 1781
    goto qla25xx_fw_dump_failed_0;
  } else {

  }
#line 1783
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 1785
  if (rval != 0) {
#line 1786
    goto qla25xx_fw_dump_failed_0;
  } else {

  }
#line 1788
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 1790
  qla24xx_copy_eft(ha, nxt);
#line 1793
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 1794
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 1795
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 1796
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 1797
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 1798
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 1802
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla25xx_fw_dump_failed_0: 
#line 1805
  qla2xxx_dump_post_process(base_vha, rval);
  qla25xx_fw_dump_failed: ;
#line 1808
  if (hardware_locked == 0) {
#line 1809
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 1810
  return;
}
}
#line 1813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla81xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla81xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;

  {
#line 1818
  ha = vha->hw;
#line 1819
  reg = & (ha->iobase)->isp24;
#line 1827
  last_chain = (uint32_t *)0U;
#line 1828
  tmp = pci_get_drvdata(ha->pdev);
#line 1828
  base_vha = (struct scsi_qla_host *)tmp;
#line 1830
  ext_mem_cnt = 0U;
#line 1830
  risc_address = ext_mem_cnt;
#line 1831
  flags = 0UL;
#line 1833
  if (hardware_locked == 0) {
#line 1834
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1834
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1836
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 1837
    ql_log(1U, vha, 53258, "No buffer available for dump.\n");
#line 1839
    goto qla81xx_fw_dump_failed;
  } else {

  }
#line 1842
  if (ha->fw_dumped != 0) {
#line 1843
    ql_log(1U, vha, 53259, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 1847
    goto qla81xx_fw_dump_failed;
  } else {

  }
#line 1849
  fw = & (ha->fw_dump)->isp.isp81;
#line 1850
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 1852
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 1852
  tmp___2 = __fswab32(tmp___1);
#line 1852
  fw->host_status = tmp___2;
#line 1855
  rval = qla24xx_pause_risc(reg);
#line 1856
  if (rval != 0) {
#line 1857
    goto qla81xx_fw_dump_failed_0;
  } else {

  }
#line 1860
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 1861
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 1862
  qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 1865
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 1866
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1867
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 1868
  dmp_reg = & reg->iobase_c4;
#line 1869
  tmp___3 = dmp_reg;
#line 1869
  dmp_reg = dmp_reg + 1;
#line 1869
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 1869
  tmp___5 = __fswab32(tmp___4);
#line 1869
  fw->pcie_regs[0] = tmp___5;
#line 1870
  tmp___6 = dmp_reg;
#line 1870
  dmp_reg = dmp_reg + 1;
#line 1870
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 1870
  tmp___8 = __fswab32(tmp___7);
#line 1870
  fw->pcie_regs[1] = tmp___8;
#line 1871
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 1871
  tmp___10 = __fswab32(tmp___9);
#line 1871
  fw->pcie_regs[2] = tmp___10;
#line 1872
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 1872
  tmp___12 = __fswab32(tmp___11);
#line 1872
  fw->pcie_regs[3] = tmp___12;
#line 1874
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 1875
  readl((void const volatile   *)(& reg->iobase_window));
#line 1878
  dmp_reg = & reg->flash_addr;
#line 1879
  cnt = 0U;
#line 1879
  goto ldv_43845;
  ldv_43844: 
#line 1880
  tmp___13 = dmp_reg;
#line 1880
  dmp_reg = dmp_reg + 1;
#line 1880
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 1880
  tmp___15 = __fswab32(tmp___14);
#line 1880
  fw->host_reg[cnt] = tmp___15;
#line 1879
  cnt = cnt + 1U;
  ldv_43845: ;
#line 1879
  if (cnt <= 31U) {
#line 1881
    goto ldv_43844;
  } else {

  }
#line 1883
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 1884
  readl((void const volatile   *)(& reg->ictrl));
#line 1887
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 1888
  readl((void const volatile   *)(& reg->iobase_addr));
#line 1889
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 1890
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1890
  tmp___17 = __fswab32(tmp___16);
#line 1890
  fw->shadow_reg[0] = tmp___17;
#line 1892
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 1893
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1893
  tmp___19 = __fswab32(tmp___18);
#line 1893
  fw->shadow_reg[1] = tmp___19;
#line 1895
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 1896
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1896
  tmp___21 = __fswab32(tmp___20);
#line 1896
  fw->shadow_reg[2] = tmp___21;
#line 1898
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 1899
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1899
  tmp___23 = __fswab32(tmp___22);
#line 1899
  fw->shadow_reg[3] = tmp___23;
#line 1901
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 1902
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1902
  tmp___25 = __fswab32(tmp___24);
#line 1902
  fw->shadow_reg[4] = tmp___25;
#line 1904
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 1905
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1905
  tmp___27 = __fswab32(tmp___26);
#line 1905
  fw->shadow_reg[5] = tmp___27;
#line 1907
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 1908
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1908
  tmp___29 = __fswab32(tmp___28);
#line 1908
  fw->shadow_reg[6] = tmp___29;
#line 1910
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 1911
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1911
  tmp___31 = __fswab32(tmp___30);
#line 1911
  fw->shadow_reg[7] = tmp___31;
#line 1913
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 1914
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1914
  tmp___33 = __fswab32(tmp___32);
#line 1914
  fw->shadow_reg[8] = tmp___33;
#line 1916
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 1917
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1917
  tmp___35 = __fswab32(tmp___34);
#line 1917
  fw->shadow_reg[9] = tmp___35;
#line 1919
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 1920
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 1920
  tmp___37 = __fswab32(tmp___36);
#line 1920
  fw->shadow_reg[10] = tmp___37;
#line 1923
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 1924
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 1924
  tmp___39 = __fswab32(tmp___38);
#line 1924
  fw->risc_io_reg = tmp___39;
#line 1927
  mbx_reg = & reg->mailbox0;
#line 1928
  cnt = 0U;
#line 1928
  goto ldv_43848;
  ldv_43847: 
#line 1929
  tmp___40 = mbx_reg;
#line 1929
  mbx_reg = mbx_reg + 1;
#line 1929
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 1929
  tmp___42 = __fswab16((int )tmp___41);
#line 1929
  fw->mailbox_reg[cnt] = tmp___42;
#line 1928
  cnt = cnt + 1U;
  ldv_43848: ;
#line 1928
  if (cnt <= 31U) {
#line 1930
    goto ldv_43847;
  } else {

  }
#line 1932
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 1933
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 1934
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 1935
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 1936
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 1937
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 1938
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 1939
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 1940
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 1942
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 1943
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 1944
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 1945
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 1947
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 1950
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 1951
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 1952
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 1953
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 1954
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 1955
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 1956
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 1957
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 1958
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 1960
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 1961
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 1962
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 1964
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 1965
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 1968
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 1969
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 1970
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 1971
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 1972
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 1973
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 1974
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 1975
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 1976
  qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 1978
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 1979
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 1980
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 1982
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 1983
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 1986
  qla24xx_read_window(reg, 28928U, 16U, (uint32_t *)(& fw->cmd_dma_reg));
#line 1989
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 1990
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 1991
  dmp_reg = & reg->iobase_q;
#line 1992
  cnt = 0U;
#line 1992
  goto ldv_43851;
  ldv_43850: 
#line 1993
  tmp___43 = iter_reg;
#line 1993
  iter_reg = iter_reg + 1;
#line 1993
  tmp___44 = dmp_reg;
#line 1993
  dmp_reg = dmp_reg + 1;
#line 1993
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 1993
  tmp___46 = __fswab32(tmp___45);
#line 1993
  *tmp___43 = tmp___46;
#line 1992
  cnt = cnt + 1U;
  ldv_43851: ;
#line 1992
  if (cnt <= 6U) {
#line 1994
    goto ldv_43850;
  } else {

  }
#line 1995
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 1996
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 1997
  dmp_reg = & reg->iobase_q;
#line 1998
  cnt = 0U;
#line 1998
  goto ldv_43854;
  ldv_43853: 
#line 1999
  tmp___47 = iter_reg;
#line 1999
  iter_reg = iter_reg + 1;
#line 1999
  tmp___48 = dmp_reg;
#line 1999
  dmp_reg = dmp_reg + 1;
#line 1999
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 1999
  tmp___50 = __fswab32(tmp___49);
#line 1999
  *tmp___47 = tmp___50;
#line 1998
  cnt = cnt + 1U;
  ldv_43854: ;
#line 1998
  if (cnt <= 6U) {
#line 2000
    goto ldv_43853;
  } else {

  }
#line 2001
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 2002
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 2003
  dmp_reg = & reg->iobase_q;
#line 2004
  cnt = 0U;
#line 2004
  goto ldv_43857;
  ldv_43856: 
#line 2005
  tmp___51 = iter_reg;
#line 2005
  iter_reg = iter_reg + 1;
#line 2005
  tmp___52 = dmp_reg;
#line 2005
  dmp_reg = dmp_reg + 1;
#line 2005
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 2005
  tmp___54 = __fswab32(tmp___53);
#line 2005
  *tmp___51 = tmp___54;
#line 2004
  cnt = cnt + 1U;
  ldv_43857: ;
#line 2004
  if (cnt <= 6U) {
#line 2006
    goto ldv_43856;
  } else {

  }
#line 2008
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 2009
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 2010
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 2012
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 2013
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 2014
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 2016
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 2017
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 2018
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 2020
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 2021
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 2022
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 2024
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 2025
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 2026
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 2028
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 2031
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 2032
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 2033
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 2035
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 2036
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 2037
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 2040
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 2041
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 2042
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 2043
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 2044
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 2045
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 2046
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 2047
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 2048
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 2051
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 2052
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 2053
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 2054
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 2055
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 2056
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 2057
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 2058
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 2059
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 2062
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 2063
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 2064
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 2065
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 2066
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 2067
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 2068
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 2069
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 2070
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 2071
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 2072
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 2073
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 2074
  iter_reg = qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 2075
  iter_reg = qla24xx_read_window(reg, 16576U, 16U, iter_reg);
#line 2076
  qla24xx_read_window(reg, 16592U, 16U, iter_reg);
#line 2079
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 2080
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 2081
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 2082
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 2083
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 2084
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 2085
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 2086
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 2087
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 2088
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 2089
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 2090
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 2091
  iter_reg = qla24xx_read_window(reg, 25024U, 16U, iter_reg);
#line 2092
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 2095
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 2098
  rval = qla24xx_soft_reset(ha);
#line 2099
  if (rval != 0) {
#line 2100
    goto qla81xx_fw_dump_failed_0;
  } else {

  }
#line 2102
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 32768U, & nxt);
#line 2104
  if (rval != 0) {
#line 2105
    goto qla81xx_fw_dump_failed_0;
  } else {

  }
#line 2107
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 2109
  qla24xx_copy_eft(ha, nxt);
#line 2112
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 2113
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 2114
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 2115
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 2116
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 2117
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 2121
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla81xx_fw_dump_failed_0: 
#line 2124
  qla2xxx_dump_post_process(base_vha, rval);
  qla81xx_fw_dump_failed: ;
#line 2127
  if (hardware_locked == 0) {
#line 2128
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2129
  return;
}
}
#line 2132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void qla83xx_fw_dump(scsi_qla_host_t *vha , int hardware_locked ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t reg_data ;
  uint32_t risc_address ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  uint32_t *dmp_reg ;
  uint32_t *iter_reg ;
  uint16_t *mbx_reg ;
  unsigned long flags ;
  struct qla83xx_fw_dump *fw ;
  uint32_t ext_mem_cnt ;
  void *nxt ;
  void *nxt_chain ;
  uint32_t *last_chain ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned int tmp___4 ;
  __u32 tmp___5 ;
  uint32_t *tmp___6 ;
  unsigned int tmp___7 ;
  __u32 tmp___8 ;
  unsigned int tmp___9 ;
  __u32 tmp___10 ;
  unsigned int tmp___11 ;
  __u32 tmp___12 ;
  uint32_t *tmp___13 ;
  unsigned int tmp___14 ;
  __u32 tmp___15 ;
  unsigned int tmp___16 ;
  __u32 tmp___17 ;
  unsigned int tmp___18 ;
  __u32 tmp___19 ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  unsigned int tmp___22 ;
  __u32 tmp___23 ;
  unsigned int tmp___24 ;
  __u32 tmp___25 ;
  unsigned int tmp___26 ;
  __u32 tmp___27 ;
  unsigned int tmp___28 ;
  __u32 tmp___29 ;
  unsigned int tmp___30 ;
  __u32 tmp___31 ;
  unsigned int tmp___32 ;
  __u32 tmp___33 ;
  unsigned int tmp___34 ;
  __u32 tmp___35 ;
  unsigned int tmp___36 ;
  __u32 tmp___37 ;
  unsigned int tmp___38 ;
  __u32 tmp___39 ;
  uint16_t *tmp___40 ;
  unsigned short tmp___41 ;
  __u16 tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  unsigned int tmp___45 ;
  __u32 tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  unsigned int tmp___49 ;
  __u32 tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  unsigned int tmp___53 ;
  __u32 tmp___54 ;
  unsigned short tmp___55 ;

  {
#line 2137
  ha = vha->hw;
#line 2138
  reg = & (ha->iobase)->isp24;
#line 2146
  last_chain = (uint32_t *)0U;
#line 2147
  tmp = pci_get_drvdata(ha->pdev);
#line 2147
  base_vha = (struct scsi_qla_host *)tmp;
#line 2149
  ext_mem_cnt = 0U;
#line 2149
  risc_address = ext_mem_cnt;
#line 2150
  flags = 0UL;
#line 2152
  if (hardware_locked == 0) {
#line 2153
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2153
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 2155
  if ((unsigned long )ha->fw_dump == (unsigned long )((struct qla2xxx_fw_dump *)0)) {
#line 2156
    ql_log(1U, vha, 53260, "No buffer available for dump!!!\n");
#line 2158
    goto qla83xx_fw_dump_failed;
  } else {

  }
#line 2161
  if (ha->fw_dumped != 0) {
#line 2162
    ql_log(1U, vha, 53261, "Firmware has been previously dumped (%p) -- ignoring request...\n",
           ha->fw_dump);
#line 2165
    goto qla83xx_fw_dump_failed;
  } else {

  }
#line 2167
  fw = & (ha->fw_dump)->isp.isp83;
#line 2168
  qla2xxx_prep_dump(ha, ha->fw_dump);
#line 2170
  tmp___1 = readl((void const volatile   *)(& reg->host_status));
#line 2170
  tmp___2 = __fswab32(tmp___1);
#line 2170
  fw->host_status = tmp___2;
#line 2173
  rval = qla24xx_pause_risc(reg);
#line 2174
  if (rval != 0) {
#line 2175
    goto qla83xx_fw_dump_failed_0;
  } else {

  }
#line 2177
  writel(24576U, (void volatile   *)(& reg->iobase_addr));
#line 2178
  dmp_reg = & reg->iobase_window;
#line 2179
  reg_data = readl((void const volatile   *)dmp_reg);
#line 2180
  writel(0U, (void volatile   *)dmp_reg);
#line 2182
  dmp_reg = (uint32_t *)(& reg->unused_4_1);
#line 2183
  reg_data = readl((void const volatile   *)dmp_reg);
#line 2184
  writel(0U, (void volatile   *)dmp_reg);
#line 2186
  writel(24592U, (void volatile   *)(& reg->iobase_addr));
#line 2187
  dmp_reg = (uint32_t *)(& reg->unused_4_1) + 2UL;
#line 2188
  reg_data = readl((void const volatile   *)dmp_reg);
#line 2189
  writel(0U, (void volatile   *)dmp_reg);
#line 2192
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 2193
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2194
  writel(1610612736U, (void volatile   *)(& reg->iobase_select));
#line 2197
  iter_reg = (uint32_t *)(& fw->host_risc_reg);
#line 2198
  iter_reg = qla24xx_read_window(reg, 28672U, 16U, iter_reg);
#line 2199
  iter_reg = qla24xx_read_window(reg, 28688U, 16U, iter_reg);
#line 2200
  qla24xx_read_window(reg, 28736U, 16U, iter_reg);
#line 2203
  writel(31744U, (void volatile   *)(& reg->iobase_addr));
#line 2204
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2205
  writel(1U, (void volatile   *)(& reg->iobase_window));
#line 2206
  dmp_reg = & reg->iobase_c4;
#line 2207
  tmp___3 = dmp_reg;
#line 2207
  dmp_reg = dmp_reg + 1;
#line 2207
  tmp___4 = readl((void const volatile   *)tmp___3);
#line 2207
  tmp___5 = __fswab32(tmp___4);
#line 2207
  fw->pcie_regs[0] = tmp___5;
#line 2208
  tmp___6 = dmp_reg;
#line 2208
  dmp_reg = dmp_reg + 1;
#line 2208
  tmp___7 = readl((void const volatile   *)tmp___6);
#line 2208
  tmp___8 = __fswab32(tmp___7);
#line 2208
  fw->pcie_regs[1] = tmp___8;
#line 2209
  tmp___9 = readl((void const volatile   *)dmp_reg);
#line 2209
  tmp___10 = __fswab32(tmp___9);
#line 2209
  fw->pcie_regs[2] = tmp___10;
#line 2210
  tmp___11 = readl((void const volatile   *)(& reg->iobase_window));
#line 2210
  tmp___12 = __fswab32(tmp___11);
#line 2210
  fw->pcie_regs[3] = tmp___12;
#line 2212
  writel(0U, (void volatile   *)(& reg->iobase_window));
#line 2213
  readl((void const volatile   *)(& reg->iobase_window));
#line 2216
  dmp_reg = & reg->flash_addr;
#line 2217
  cnt = 0U;
#line 2217
  goto ldv_43885;
  ldv_43884: 
#line 2218
  tmp___13 = dmp_reg;
#line 2218
  dmp_reg = dmp_reg + 1;
#line 2218
  tmp___14 = readl((void const volatile   *)tmp___13);
#line 2218
  tmp___15 = __fswab32(tmp___14);
#line 2218
  fw->host_reg[cnt] = tmp___15;
#line 2217
  cnt = cnt + 1U;
  ldv_43885: ;
#line 2217
  if (cnt <= 31U) {
#line 2219
    goto ldv_43884;
  } else {

  }
#line 2221
  writel(0U, (void volatile   *)(& reg->ictrl));
#line 2222
  readl((void const volatile   *)(& reg->ictrl));
#line 2225
  writel(3952U, (void volatile   *)(& reg->iobase_addr));
#line 2226
  readl((void const volatile   *)(& reg->iobase_addr));
#line 2227
  writel(2952790016U, (void volatile   *)(& reg->iobase_select));
#line 2228
  tmp___16 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2228
  tmp___17 = __fswab32(tmp___16);
#line 2228
  fw->shadow_reg[0] = tmp___17;
#line 2230
  writel(2953838592U, (void volatile   *)(& reg->iobase_select));
#line 2231
  tmp___18 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2231
  tmp___19 = __fswab32(tmp___18);
#line 2231
  fw->shadow_reg[1] = tmp___19;
#line 2233
  writel(2954887168U, (void volatile   *)(& reg->iobase_select));
#line 2234
  tmp___20 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2234
  tmp___21 = __fswab32(tmp___20);
#line 2234
  fw->shadow_reg[2] = tmp___21;
#line 2236
  writel(2955935744U, (void volatile   *)(& reg->iobase_select));
#line 2237
  tmp___22 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2237
  tmp___23 = __fswab32(tmp___22);
#line 2237
  fw->shadow_reg[3] = tmp___23;
#line 2239
  writel(2956984320U, (void volatile   *)(& reg->iobase_select));
#line 2240
  tmp___24 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2240
  tmp___25 = __fswab32(tmp___24);
#line 2240
  fw->shadow_reg[4] = tmp___25;
#line 2242
  writel(2958032896U, (void volatile   *)(& reg->iobase_select));
#line 2243
  tmp___26 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2243
  tmp___27 = __fswab32(tmp___26);
#line 2243
  fw->shadow_reg[5] = tmp___27;
#line 2245
  writel(2959081472U, (void volatile   *)(& reg->iobase_select));
#line 2246
  tmp___28 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2246
  tmp___29 = __fswab32(tmp___28);
#line 2246
  fw->shadow_reg[6] = tmp___29;
#line 2248
  writel(2960130048U, (void volatile   *)(& reg->iobase_select));
#line 2249
  tmp___30 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2249
  tmp___31 = __fswab32(tmp___30);
#line 2249
  fw->shadow_reg[7] = tmp___31;
#line 2251
  writel(2961178624U, (void volatile   *)(& reg->iobase_select));
#line 2252
  tmp___32 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2252
  tmp___33 = __fswab32(tmp___32);
#line 2252
  fw->shadow_reg[8] = tmp___33;
#line 2254
  writel(2962227200U, (void volatile   *)(& reg->iobase_select));
#line 2255
  tmp___34 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2255
  tmp___35 = __fswab32(tmp___34);
#line 2255
  fw->shadow_reg[9] = tmp___35;
#line 2257
  writel(2963275776U, (void volatile   *)(& reg->iobase_select));
#line 2258
  tmp___36 = readl((void const volatile   *)(& reg->iobase_sdata));
#line 2258
  tmp___37 = __fswab32(tmp___36);
#line 2258
  fw->shadow_reg[10] = tmp___37;
#line 2261
  writel(16U, (void volatile   *)(& reg->iobase_addr));
#line 2262
  tmp___38 = readl((void const volatile   *)(& reg->iobase_window));
#line 2262
  tmp___39 = __fswab32(tmp___38);
#line 2262
  fw->risc_io_reg = tmp___39;
#line 2265
  mbx_reg = & reg->mailbox0;
#line 2266
  cnt = 0U;
#line 2266
  goto ldv_43888;
  ldv_43887: 
#line 2267
  tmp___40 = mbx_reg;
#line 2267
  mbx_reg = mbx_reg + 1;
#line 2267
  tmp___41 = readw((void const volatile   *)tmp___40);
#line 2267
  tmp___42 = __fswab16((int )tmp___41);
#line 2267
  fw->mailbox_reg[cnt] = tmp___42;
#line 2266
  cnt = cnt + 1U;
  ldv_43888: ;
#line 2266
  if (cnt <= 31U) {
#line 2268
    goto ldv_43887;
  } else {

  }
#line 2270
  iter_reg = (uint32_t *)(& fw->xseq_gp_reg);
#line 2271
  iter_reg = qla24xx_read_window(reg, 48640U, 16U, iter_reg);
#line 2272
  iter_reg = qla24xx_read_window(reg, 48656U, 16U, iter_reg);
#line 2273
  iter_reg = qla24xx_read_window(reg, 48672U, 16U, iter_reg);
#line 2274
  iter_reg = qla24xx_read_window(reg, 48688U, 16U, iter_reg);
#line 2275
  iter_reg = qla24xx_read_window(reg, 48704U, 16U, iter_reg);
#line 2276
  iter_reg = qla24xx_read_window(reg, 48720U, 16U, iter_reg);
#line 2277
  iter_reg = qla24xx_read_window(reg, 48736U, 16U, iter_reg);
#line 2278
  iter_reg = qla24xx_read_window(reg, 48752U, 16U, iter_reg);
#line 2279
  iter_reg = qla24xx_read_window(reg, 48896U, 16U, iter_reg);
#line 2280
  iter_reg = qla24xx_read_window(reg, 48912U, 16U, iter_reg);
#line 2281
  iter_reg = qla24xx_read_window(reg, 48928U, 16U, iter_reg);
#line 2282
  iter_reg = qla24xx_read_window(reg, 48944U, 16U, iter_reg);
#line 2283
  iter_reg = qla24xx_read_window(reg, 48960U, 16U, iter_reg);
#line 2284
  iter_reg = qla24xx_read_window(reg, 48976U, 16U, iter_reg);
#line 2285
  iter_reg = qla24xx_read_window(reg, 48992U, 16U, iter_reg);
#line 2286
  qla24xx_read_window(reg, 49008U, 16U, iter_reg);
#line 2288
  iter_reg = (uint32_t *)(& fw->xseq_0_reg);
#line 2289
  iter_reg = qla24xx_read_window(reg, 49088U, 16U, iter_reg);
#line 2290
  iter_reg = qla24xx_read_window(reg, 49104U, 16U, iter_reg);
#line 2291
  qla24xx_read_window(reg, 49120U, 16U, iter_reg);
#line 2293
  qla24xx_read_window(reg, 49136U, 16U, (uint32_t *)(& fw->xseq_1_reg));
#line 2295
  qla24xx_read_window(reg, 48880U, 16U, (uint32_t *)(& fw->xseq_2_reg));
#line 2298
  iter_reg = (uint32_t *)(& fw->rseq_gp_reg);
#line 2299
  iter_reg = qla24xx_read_window(reg, 65024U, 16U, iter_reg);
#line 2300
  iter_reg = qla24xx_read_window(reg, 65040U, 16U, iter_reg);
#line 2301
  iter_reg = qla24xx_read_window(reg, 65056U, 16U, iter_reg);
#line 2302
  iter_reg = qla24xx_read_window(reg, 65072U, 16U, iter_reg);
#line 2303
  iter_reg = qla24xx_read_window(reg, 65088U, 16U, iter_reg);
#line 2304
  iter_reg = qla24xx_read_window(reg, 65104U, 16U, iter_reg);
#line 2305
  iter_reg = qla24xx_read_window(reg, 65120U, 16U, iter_reg);
#line 2306
  iter_reg = qla24xx_read_window(reg, 65136U, 16U, iter_reg);
#line 2307
  iter_reg = qla24xx_read_window(reg, 65280U, 16U, iter_reg);
#line 2308
  iter_reg = qla24xx_read_window(reg, 65296U, 16U, iter_reg);
#line 2309
  iter_reg = qla24xx_read_window(reg, 65312U, 16U, iter_reg);
#line 2310
  iter_reg = qla24xx_read_window(reg, 65328U, 16U, iter_reg);
#line 2311
  iter_reg = qla24xx_read_window(reg, 65344U, 16U, iter_reg);
#line 2312
  iter_reg = qla24xx_read_window(reg, 65360U, 16U, iter_reg);
#line 2313
  iter_reg = qla24xx_read_window(reg, 65376U, 16U, iter_reg);
#line 2314
  qla24xx_read_window(reg, 65392U, 16U, iter_reg);
#line 2316
  iter_reg = (uint32_t *)(& fw->rseq_0_reg);
#line 2317
  iter_reg = qla24xx_read_window(reg, 65472U, 16U, iter_reg);
#line 2318
  qla24xx_read_window(reg, 65488U, 16U, iter_reg);
#line 2320
  qla24xx_read_window(reg, 65504U, 16U, (uint32_t *)(& fw->rseq_1_reg));
#line 2321
  qla24xx_read_window(reg, 65520U, 16U, (uint32_t *)(& fw->rseq_2_reg));
#line 2322
  qla24xx_read_window(reg, 65264U, 16U, (uint32_t *)(& fw->rseq_3_reg));
#line 2325
  iter_reg = (uint32_t *)(& fw->aseq_gp_reg);
#line 2326
  iter_reg = qla24xx_read_window(reg, 45056U, 16U, iter_reg);
#line 2327
  iter_reg = qla24xx_read_window(reg, 45072U, 16U, iter_reg);
#line 2328
  iter_reg = qla24xx_read_window(reg, 45088U, 16U, iter_reg);
#line 2329
  iter_reg = qla24xx_read_window(reg, 45104U, 16U, iter_reg);
#line 2330
  iter_reg = qla24xx_read_window(reg, 45120U, 16U, iter_reg);
#line 2331
  iter_reg = qla24xx_read_window(reg, 45136U, 16U, iter_reg);
#line 2332
  iter_reg = qla24xx_read_window(reg, 45152U, 16U, iter_reg);
#line 2333
  iter_reg = qla24xx_read_window(reg, 45168U, 16U, iter_reg);
#line 2334
  iter_reg = qla24xx_read_window(reg, 45312U, 16U, iter_reg);
#line 2335
  iter_reg = qla24xx_read_window(reg, 45328U, 16U, iter_reg);
#line 2336
  iter_reg = qla24xx_read_window(reg, 45344U, 16U, iter_reg);
#line 2337
  iter_reg = qla24xx_read_window(reg, 45360U, 16U, iter_reg);
#line 2338
  iter_reg = qla24xx_read_window(reg, 45376U, 16U, iter_reg);
#line 2339
  iter_reg = qla24xx_read_window(reg, 45392U, 16U, iter_reg);
#line 2340
  iter_reg = qla24xx_read_window(reg, 45408U, 16U, iter_reg);
#line 2341
  qla24xx_read_window(reg, 45424U, 16U, iter_reg);
#line 2343
  iter_reg = (uint32_t *)(& fw->aseq_0_reg);
#line 2344
  iter_reg = qla24xx_read_window(reg, 45248U, 16U, iter_reg);
#line 2345
  qla24xx_read_window(reg, 45264U, 16U, iter_reg);
#line 2347
  qla24xx_read_window(reg, 45280U, 16U, (uint32_t *)(& fw->aseq_1_reg));
#line 2348
  qla24xx_read_window(reg, 45296U, 16U, (uint32_t *)(& fw->aseq_2_reg));
#line 2349
  qla24xx_read_window(reg, 45552U, 16U, (uint32_t *)(& fw->aseq_3_reg));
#line 2352
  iter_reg = (uint32_t *)(& fw->cmd_dma_reg);
#line 2353
  iter_reg = qla24xx_read_window(reg, 28928U, 16U, iter_reg);
#line 2354
  iter_reg = qla24xx_read_window(reg, 28960U, 16U, iter_reg);
#line 2355
  iter_reg = qla24xx_read_window(reg, 28976U, 16U, iter_reg);
#line 2356
  qla24xx_read_window(reg, 29168U, 16U, iter_reg);
#line 2359
  iter_reg = (uint32_t *)(& fw->req0_dma_reg);
#line 2360
  iter_reg = qla24xx_read_window(reg, 29184U, 8U, iter_reg);
#line 2361
  dmp_reg = & reg->iobase_q;
#line 2362
  cnt = 0U;
#line 2362
  goto ldv_43891;
  ldv_43890: 
#line 2363
  tmp___43 = iter_reg;
#line 2363
  iter_reg = iter_reg + 1;
#line 2363
  tmp___44 = dmp_reg;
#line 2363
  dmp_reg = dmp_reg + 1;
#line 2363
  tmp___45 = readl((void const volatile   *)tmp___44);
#line 2363
  tmp___46 = __fswab32(tmp___45);
#line 2363
  *tmp___43 = tmp___46;
#line 2362
  cnt = cnt + 1U;
  ldv_43891: ;
#line 2362
  if (cnt <= 6U) {
#line 2364
    goto ldv_43890;
  } else {

  }
#line 2365
  iter_reg = (uint32_t *)(& fw->resp0_dma_reg);
#line 2366
  iter_reg = qla24xx_read_window(reg, 29440U, 8U, iter_reg);
#line 2367
  dmp_reg = & reg->iobase_q;
#line 2368
  cnt = 0U;
#line 2368
  goto ldv_43894;
  ldv_43893: 
#line 2369
  tmp___47 = iter_reg;
#line 2369
  iter_reg = iter_reg + 1;
#line 2369
  tmp___48 = dmp_reg;
#line 2369
  dmp_reg = dmp_reg + 1;
#line 2369
  tmp___49 = readl((void const volatile   *)tmp___48);
#line 2369
  tmp___50 = __fswab32(tmp___49);
#line 2369
  *tmp___47 = tmp___50;
#line 2368
  cnt = cnt + 1U;
  ldv_43894: ;
#line 2368
  if (cnt <= 6U) {
#line 2370
    goto ldv_43893;
  } else {

  }
#line 2371
  iter_reg = (uint32_t *)(& fw->req1_dma_reg);
#line 2372
  iter_reg = qla24xx_read_window(reg, 29696U, 8U, iter_reg);
#line 2373
  dmp_reg = & reg->iobase_q;
#line 2374
  cnt = 0U;
#line 2374
  goto ldv_43897;
  ldv_43896: 
#line 2375
  tmp___51 = iter_reg;
#line 2375
  iter_reg = iter_reg + 1;
#line 2375
  tmp___52 = dmp_reg;
#line 2375
  dmp_reg = dmp_reg + 1;
#line 2375
  tmp___53 = readl((void const volatile   *)tmp___52);
#line 2375
  tmp___54 = __fswab32(tmp___53);
#line 2375
  *tmp___51 = tmp___54;
#line 2374
  cnt = cnt + 1U;
  ldv_43897: ;
#line 2374
  if (cnt <= 6U) {
#line 2376
    goto ldv_43896;
  } else {

  }
#line 2378
  iter_reg = (uint32_t *)(& fw->xmt0_dma_reg);
#line 2379
  iter_reg = qla24xx_read_window(reg, 30208U, 16U, iter_reg);
#line 2380
  qla24xx_read_window(reg, 30224U, 16U, iter_reg);
#line 2382
  iter_reg = (uint32_t *)(& fw->xmt1_dma_reg);
#line 2383
  iter_reg = qla24xx_read_window(reg, 30240U, 16U, iter_reg);
#line 2384
  qla24xx_read_window(reg, 30256U, 16U, iter_reg);
#line 2386
  iter_reg = (uint32_t *)(& fw->xmt2_dma_reg);
#line 2387
  iter_reg = qla24xx_read_window(reg, 30272U, 16U, iter_reg);
#line 2388
  qla24xx_read_window(reg, 30288U, 16U, iter_reg);
#line 2390
  iter_reg = (uint32_t *)(& fw->xmt3_dma_reg);
#line 2391
  iter_reg = qla24xx_read_window(reg, 30304U, 16U, iter_reg);
#line 2392
  qla24xx_read_window(reg, 30320U, 16U, iter_reg);
#line 2394
  iter_reg = (uint32_t *)(& fw->xmt4_dma_reg);
#line 2395
  iter_reg = qla24xx_read_window(reg, 30336U, 16U, iter_reg);
#line 2396
  qla24xx_read_window(reg, 30352U, 16U, iter_reg);
#line 2398
  qla24xx_read_window(reg, 30368U, 16U, (uint32_t *)(& fw->xmt_data_dma_reg));
#line 2401
  iter_reg = (uint32_t *)(& fw->rcvt0_data_dma_reg);
#line 2402
  iter_reg = qla24xx_read_window(reg, 30464U, 16U, iter_reg);
#line 2403
  qla24xx_read_window(reg, 30480U, 16U, iter_reg);
#line 2405
  iter_reg = (uint32_t *)(& fw->rcvt1_data_dma_reg);
#line 2406
  iter_reg = qla24xx_read_window(reg, 30496U, 16U, iter_reg);
#line 2407
  qla24xx_read_window(reg, 30512U, 16U, iter_reg);
#line 2410
  iter_reg = (uint32_t *)(& fw->risc_gp_reg);
#line 2411
  iter_reg = qla24xx_read_window(reg, 3840U, 16U, iter_reg);
#line 2412
  iter_reg = qla24xx_read_window(reg, 3856U, 16U, iter_reg);
#line 2413
  iter_reg = qla24xx_read_window(reg, 3872U, 16U, iter_reg);
#line 2414
  iter_reg = qla24xx_read_window(reg, 3888U, 16U, iter_reg);
#line 2415
  iter_reg = qla24xx_read_window(reg, 3904U, 16U, iter_reg);
#line 2416
  iter_reg = qla24xx_read_window(reg, 3920U, 16U, iter_reg);
#line 2417
  iter_reg = qla24xx_read_window(reg, 3936U, 16U, iter_reg);
#line 2418
  qla24xx_read_window(reg, 3952U, 16U, iter_reg);
#line 2421
  iter_reg = (uint32_t *)(& fw->lmc_reg);
#line 2422
  iter_reg = qla24xx_read_window(reg, 12288U, 16U, iter_reg);
#line 2423
  iter_reg = qla24xx_read_window(reg, 12304U, 16U, iter_reg);
#line 2424
  iter_reg = qla24xx_read_window(reg, 12320U, 16U, iter_reg);
#line 2425
  iter_reg = qla24xx_read_window(reg, 12336U, 16U, iter_reg);
#line 2426
  iter_reg = qla24xx_read_window(reg, 12352U, 16U, iter_reg);
#line 2427
  iter_reg = qla24xx_read_window(reg, 12368U, 16U, iter_reg);
#line 2428
  iter_reg = qla24xx_read_window(reg, 12384U, 16U, iter_reg);
#line 2429
  qla24xx_read_window(reg, 12400U, 16U, iter_reg);
#line 2432
  iter_reg = (uint32_t *)(& fw->fpm_hdw_reg);
#line 2433
  iter_reg = qla24xx_read_window(reg, 16384U, 16U, iter_reg);
#line 2434
  iter_reg = qla24xx_read_window(reg, 16400U, 16U, iter_reg);
#line 2435
  iter_reg = qla24xx_read_window(reg, 16416U, 16U, iter_reg);
#line 2436
  iter_reg = qla24xx_read_window(reg, 16432U, 16U, iter_reg);
#line 2437
  iter_reg = qla24xx_read_window(reg, 16448U, 16U, iter_reg);
#line 2438
  iter_reg = qla24xx_read_window(reg, 16464U, 16U, iter_reg);
#line 2439
  iter_reg = qla24xx_read_window(reg, 16480U, 16U, iter_reg);
#line 2440
  iter_reg = qla24xx_read_window(reg, 16496U, 16U, iter_reg);
#line 2441
  iter_reg = qla24xx_read_window(reg, 16512U, 16U, iter_reg);
#line 2442
  iter_reg = qla24xx_read_window(reg, 16528U, 16U, iter_reg);
#line 2443
  iter_reg = qla24xx_read_window(reg, 16544U, 16U, iter_reg);
#line 2444
  iter_reg = qla24xx_read_window(reg, 16560U, 16U, iter_reg);
#line 2445
  iter_reg = qla24xx_read_window(reg, 16576U, 16U, iter_reg);
#line 2446
  iter_reg = qla24xx_read_window(reg, 16592U, 16U, iter_reg);
#line 2447
  iter_reg = qla24xx_read_window(reg, 16608U, 16U, iter_reg);
#line 2448
  qla24xx_read_window(reg, 16624U, 16U, iter_reg);
#line 2451
  iter_reg = (uint32_t *)(& fw->rq0_array_reg);
#line 2452
  iter_reg = qla24xx_read_window(reg, 23552U, 16U, iter_reg);
#line 2453
  iter_reg = qla24xx_read_window(reg, 23568U, 16U, iter_reg);
#line 2454
  iter_reg = qla24xx_read_window(reg, 23584U, 16U, iter_reg);
#line 2455
  iter_reg = qla24xx_read_window(reg, 23600U, 16U, iter_reg);
#line 2456
  iter_reg = qla24xx_read_window(reg, 23616U, 16U, iter_reg);
#line 2457
  iter_reg = qla24xx_read_window(reg, 23632U, 16U, iter_reg);
#line 2458
  iter_reg = qla24xx_read_window(reg, 23648U, 16U, iter_reg);
#line 2459
  iter_reg = qla24xx_read_window(reg, 23664U, 16U, iter_reg);
#line 2460
  iter_reg = qla24xx_read_window(reg, 23680U, 16U, iter_reg);
#line 2461
  iter_reg = qla24xx_read_window(reg, 23696U, 16U, iter_reg);
#line 2462
  iter_reg = qla24xx_read_window(reg, 23712U, 16U, iter_reg);
#line 2463
  iter_reg = qla24xx_read_window(reg, 23728U, 16U, iter_reg);
#line 2464
  iter_reg = qla24xx_read_window(reg, 23744U, 16U, iter_reg);
#line 2465
  iter_reg = qla24xx_read_window(reg, 23760U, 16U, iter_reg);
#line 2466
  iter_reg = qla24xx_read_window(reg, 23776U, 16U, iter_reg);
#line 2467
  qla24xx_read_window(reg, 23792U, 16U, iter_reg);
#line 2470
  iter_reg = (uint32_t *)(& fw->rq1_array_reg);
#line 2471
  iter_reg = qla24xx_read_window(reg, 23808U, 16U, iter_reg);
#line 2472
  iter_reg = qla24xx_read_window(reg, 23824U, 16U, iter_reg);
#line 2473
  iter_reg = qla24xx_read_window(reg, 23840U, 16U, iter_reg);
#line 2474
  iter_reg = qla24xx_read_window(reg, 23856U, 16U, iter_reg);
#line 2475
  iter_reg = qla24xx_read_window(reg, 23872U, 16U, iter_reg);
#line 2476
  iter_reg = qla24xx_read_window(reg, 23888U, 16U, iter_reg);
#line 2477
  iter_reg = qla24xx_read_window(reg, 23904U, 16U, iter_reg);
#line 2478
  iter_reg = qla24xx_read_window(reg, 23920U, 16U, iter_reg);
#line 2479
  iter_reg = qla24xx_read_window(reg, 23936U, 16U, iter_reg);
#line 2480
  iter_reg = qla24xx_read_window(reg, 23952U, 16U, iter_reg);
#line 2481
  iter_reg = qla24xx_read_window(reg, 23968U, 16U, iter_reg);
#line 2482
  iter_reg = qla24xx_read_window(reg, 23984U, 16U, iter_reg);
#line 2483
  iter_reg = qla24xx_read_window(reg, 24000U, 16U, iter_reg);
#line 2484
  iter_reg = qla24xx_read_window(reg, 24016U, 16U, iter_reg);
#line 2485
  iter_reg = qla24xx_read_window(reg, 24032U, 16U, iter_reg);
#line 2486
  qla24xx_read_window(reg, 24048U, 16U, iter_reg);
#line 2489
  iter_reg = (uint32_t *)(& fw->rp0_array_reg);
#line 2490
  iter_reg = qla24xx_read_window(reg, 24064U, 16U, iter_reg);
#line 2491
  iter_reg = qla24xx_read_window(reg, 24080U, 16U, iter_reg);
#line 2492
  iter_reg = qla24xx_read_window(reg, 24096U, 16U, iter_reg);
#line 2493
  iter_reg = qla24xx_read_window(reg, 24112U, 16U, iter_reg);
#line 2494
  iter_reg = qla24xx_read_window(reg, 24128U, 16U, iter_reg);
#line 2495
  iter_reg = qla24xx_read_window(reg, 24144U, 16U, iter_reg);
#line 2496
  iter_reg = qla24xx_read_window(reg, 24160U, 16U, iter_reg);
#line 2497
  iter_reg = qla24xx_read_window(reg, 24176U, 16U, iter_reg);
#line 2498
  iter_reg = qla24xx_read_window(reg, 24192U, 16U, iter_reg);
#line 2499
  iter_reg = qla24xx_read_window(reg, 24208U, 16U, iter_reg);
#line 2500
  iter_reg = qla24xx_read_window(reg, 24224U, 16U, iter_reg);
#line 2501
  iter_reg = qla24xx_read_window(reg, 24240U, 16U, iter_reg);
#line 2502
  iter_reg = qla24xx_read_window(reg, 24256U, 16U, iter_reg);
#line 2503
  iter_reg = qla24xx_read_window(reg, 24272U, 16U, iter_reg);
#line 2504
  iter_reg = qla24xx_read_window(reg, 24288U, 16U, iter_reg);
#line 2505
  qla24xx_read_window(reg, 24304U, 16U, iter_reg);
#line 2508
  iter_reg = (uint32_t *)(& fw->rp1_array_reg);
#line 2509
  iter_reg = qla24xx_read_window(reg, 24320U, 16U, iter_reg);
#line 2510
  iter_reg = qla24xx_read_window(reg, 24336U, 16U, iter_reg);
#line 2511
  iter_reg = qla24xx_read_window(reg, 24352U, 16U, iter_reg);
#line 2512
  iter_reg = qla24xx_read_window(reg, 24368U, 16U, iter_reg);
#line 2513
  iter_reg = qla24xx_read_window(reg, 24384U, 16U, iter_reg);
#line 2514
  iter_reg = qla24xx_read_window(reg, 24400U, 16U, iter_reg);
#line 2515
  iter_reg = qla24xx_read_window(reg, 24416U, 16U, iter_reg);
#line 2516
  iter_reg = qla24xx_read_window(reg, 24432U, 16U, iter_reg);
#line 2517
  iter_reg = qla24xx_read_window(reg, 24448U, 16U, iter_reg);
#line 2518
  iter_reg = qla24xx_read_window(reg, 24464U, 16U, iter_reg);
#line 2519
  iter_reg = qla24xx_read_window(reg, 24480U, 16U, iter_reg);
#line 2520
  iter_reg = qla24xx_read_window(reg, 24496U, 16U, iter_reg);
#line 2521
  iter_reg = qla24xx_read_window(reg, 24512U, 16U, iter_reg);
#line 2522
  iter_reg = qla24xx_read_window(reg, 24528U, 16U, iter_reg);
#line 2523
  iter_reg = qla24xx_read_window(reg, 24544U, 16U, iter_reg);
#line 2524
  qla24xx_read_window(reg, 24560U, 16U, iter_reg);
#line 2526
  iter_reg = (uint32_t *)(& fw->at0_array_reg);
#line 2527
  iter_reg = qla24xx_read_window(reg, 28800U, 16U, iter_reg);
#line 2528
  iter_reg = qla24xx_read_window(reg, 28816U, 16U, iter_reg);
#line 2529
  iter_reg = qla24xx_read_window(reg, 28832U, 16U, iter_reg);
#line 2530
  iter_reg = qla24xx_read_window(reg, 28848U, 16U, iter_reg);
#line 2531
  iter_reg = qla24xx_read_window(reg, 28864U, 16U, iter_reg);
#line 2532
  iter_reg = qla24xx_read_window(reg, 28880U, 16U, iter_reg);
#line 2533
  iter_reg = qla24xx_read_window(reg, 28896U, 16U, iter_reg);
#line 2534
  qla24xx_read_window(reg, 28912U, 16U, iter_reg);
#line 2537
  qla24xx_read_window(reg, 30720U, 16U, (uint32_t *)(& fw->queue_control_reg));
#line 2540
  iter_reg = (uint32_t *)(& fw->fb_hdw_reg);
#line 2541
  iter_reg = qla24xx_read_window(reg, 24576U, 16U, iter_reg);
#line 2542
  iter_reg = qla24xx_read_window(reg, 24592U, 16U, iter_reg);
#line 2543
  iter_reg = qla24xx_read_window(reg, 24608U, 16U, iter_reg);
#line 2544
  iter_reg = qla24xx_read_window(reg, 24624U, 16U, iter_reg);
#line 2545
  iter_reg = qla24xx_read_window(reg, 24640U, 16U, iter_reg);
#line 2546
  iter_reg = qla24xx_read_window(reg, 24672U, 16U, iter_reg);
#line 2547
  iter_reg = qla24xx_read_window(reg, 24688U, 16U, iter_reg);
#line 2548
  iter_reg = qla24xx_read_window(reg, 24832U, 16U, iter_reg);
#line 2549
  iter_reg = qla24xx_read_window(reg, 24880U, 16U, iter_reg);
#line 2550
  iter_reg = qla24xx_read_window(reg, 24912U, 16U, iter_reg);
#line 2551
  iter_reg = qla24xx_read_window(reg, 24944U, 16U, iter_reg);
#line 2552
  iter_reg = qla24xx_read_window(reg, 24976U, 16U, iter_reg);
#line 2553
  iter_reg = qla24xx_read_window(reg, 25008U, 16U, iter_reg);
#line 2554
  iter_reg = qla24xx_read_window(reg, 25024U, 16U, iter_reg);
#line 2555
  iter_reg = qla24xx_read_window(reg, 25904U, 16U, iter_reg);
#line 2556
  iter_reg = qla24xx_read_window(reg, 25920U, 16U, iter_reg);
#line 2557
  iter_reg = qla24xx_read_window(reg, 25936U, 16U, iter_reg);
#line 2558
  iter_reg = qla24xx_read_window(reg, 25952U, 16U, iter_reg);
#line 2559
  iter_reg = qla24xx_read_window(reg, 25968U, 16U, iter_reg);
#line 2560
  iter_reg = qla24xx_read_window(reg, 25984U, 16U, iter_reg);
#line 2561
  iter_reg = qla24xx_read_window(reg, 26000U, 16U, iter_reg);
#line 2562
  iter_reg = qla24xx_read_window(reg, 26016U, 16U, iter_reg);
#line 2563
  iter_reg = qla24xx_read_window(reg, 26032U, 16U, iter_reg);
#line 2564
  iter_reg = qla24xx_read_window(reg, 26048U, 16U, iter_reg);
#line 2565
  iter_reg = qla24xx_read_window(reg, 26064U, 16U, iter_reg);
#line 2566
  iter_reg = qla24xx_read_window(reg, 26080U, 16U, iter_reg);
#line 2567
  qla24xx_read_window(reg, 28416U, 16U, iter_reg);
#line 2570
  nxt_chain = qla25xx_copy_mq(ha, (void *)ha->fw_dump + (unsigned long )ha->chain_offset,
                              & last_chain);
#line 2573
  rval = qla24xx_soft_reset(ha);
#line 2574
  if (rval != 0) {
#line 2575
    ql_log(1U, vha, 53262, "SOFT RESET FAILED, forcing continuation of dump!!!\n");
#line 2577
    rval = 0;
#line 2579
    ql_log(1U, vha, 53263, "try a bigger hammer!!!\n");
#line 2581
    writel(268435456U, (void volatile   *)(& reg->hccr));
#line 2582
    readl((void const volatile   *)(& reg->hccr));
#line 2584
    writel(1073741824U, (void volatile   *)(& reg->hccr));
#line 2585
    readl((void const volatile   *)(& reg->hccr));
#line 2587
    writel(536870912U, (void volatile   *)(& reg->hccr));
#line 2588
    readl((void const volatile   *)(& reg->hccr));
#line 2590
    cnt = 30000U;
#line 2590
    goto ldv_43900;
    ldv_43899: 
#line 2591
    __const_udelay(21475UL);
#line 2590
    cnt = cnt - 1U;
    ldv_43900: ;
#line 2590
    if (cnt != 0U) {
#line 2590
      tmp___55 = readw((void const volatile   *)(& reg->mailbox0));
#line 2590
      if ((unsigned int )tmp___55 != 0U) {
#line 2592
        goto ldv_43899;
      } else {
#line 2595
        goto ldv_43901;
      }
    } else {

    }
    ldv_43901: ;
#line 2593
    if (cnt == 0U) {
#line 2594
      nxt = (void *)(& fw->code_ram);
#line 2595
      nxt = nxt + 36864UL;
#line 2596
      nxt = nxt + (unsigned long )(ha->fw_memory_size - 1048575U);
#line 2597
      goto copy_queue;
    } else {
#line 2599
      ql_log(1U, vha, 53264, "bigger hammer success?\n");
    }
  } else {

  }
#line 2603
  rval = qla24xx_dump_memory(ha, (uint32_t *)(& fw->code_ram), 36864U, & nxt);
#line 2605
  if (rval != 0) {
#line 2606
    goto qla83xx_fw_dump_failed_0;
  } else {

  }
  copy_queue: 
#line 2609
  nxt = qla2xxx_copy_queues(ha, nxt);
#line 2611
  qla24xx_copy_eft(ha, nxt);
#line 2614
  nxt_chain = qla25xx_copy_fce(ha, nxt_chain, & last_chain);
#line 2615
  nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, & last_chain);
#line 2616
  nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, & last_chain);
#line 2617
  if ((unsigned long )last_chain != (unsigned long )((uint32_t *)0U)) {
#line 2618
    (ha->fw_dump)->version = (ha->fw_dump)->version | 128U;
#line 2619
    *last_chain = *last_chain | 128U;
  } else {

  }
#line 2623
  ha->fw_dump_len = (uint32_t )((long )nxt_chain) - (uint32_t )((long )ha->fw_dump);
  qla83xx_fw_dump_failed_0: 
#line 2626
  qla2xxx_dump_post_process(base_vha, rval);
  qla83xx_fw_dump_failed: ;
#line 2629
  if (hardware_locked == 0) {
#line 2630
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2631
  return;
}
}
#line 2638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
__inline static int ql_mask_match(uint32_t level ) 
{ 


  {
#line 2640
  if (ql2xextended_error_logging == 1) {
#line 2641
    ql2xextended_error_logging = 507510784;
  } else {

  }
#line 2642
  return ((level & (uint32_t )ql2xextended_error_logging) == level);
}
}
#line 2659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_dbg(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  int tmp ;
  struct pci_dev  const  *pdev ;
  char const   *tmp___0 ;

  {
#line 2664
  tmp = ql_mask_match(level);
#line 2664
  if (tmp == 0) {
#line 2665
    return;
  } else {

  }
#line 2667
  ldv__builtin_va_start((__va_list_tag *)(& va));
#line 2669
  vaf.fmt = fmt;
#line 2670
  vaf.va = & va;
#line 2672
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 2673
    pdev = (struct pci_dev  const  *)(vha->hw)->pdev;
#line 2675
    tmp___0 = dev_name(& pdev->dev);
#line 2675
    printk("\f%s [%s]-%04x:%ld: %pV", (char *)"qla2xxx", tmp___0, (uint32_t )id + ql_dbg_offset,
           vha->host_no, & vaf);
  } else {
#line 2679
    printk("\f%s [%s]-%04x: : %pV", (char *)"qla2xxx", (char *)"0000:00:00.0", (uint32_t )id + ql_dbg_offset,
           & vaf);
  }
#line 2683
  ldv__builtin_va_end((__va_list_tag *)(& va));
#line 2684
  return;
}
}
#line 2702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_dbg_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 2708
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 2709
    return;
  } else {

  }
#line 2710
  tmp = ql_mask_match(level);
#line 2710
  if (tmp == 0) {
#line 2711
    return;
  } else {

  }
#line 2713
  ldv__builtin_va_start((__va_list_tag *)(& va));
#line 2715
  vaf.fmt = fmt;
#line 2716
  vaf.va = & va;
#line 2719
  tmp___0 = dev_name((struct device  const  *)(& pdev->dev));
#line 2719
  printk("\f%s [%s]-%04x: : %pV", (char *)"qla2xxx", tmp___0, (uint32_t )id + ql_dbg_offset,
         & vaf);
#line 2722
  ldv__builtin_va_end((__va_list_tag *)(& va));
#line 2723
  return;
}
}
#line 2739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_log(uint32_t level , scsi_qla_host_t *vha , int32_t id , char const   *fmt 
            , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  char pbuf[128U] ;
  struct pci_dev  const  *pdev ;
  char const   *tmp ;

  {
#line 2745
  if ((uint32_t )ql_errlev < level) {
#line 2746
    return;
  } else {

  }
#line 2748
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 2749
    pdev = (struct pci_dev  const  *)(vha->hw)->pdev;
#line 2751
    tmp = dev_name(& pdev->dev);
#line 2751
    snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x:%ld: ", (char *)"qla2xxx", tmp,
             id, vha->host_no);
  } else {
#line 2754
    snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x: : ", (char *)"qla2xxx", (char *)"0000:00:00.0",
             id);
  }
#line 2757
  pbuf[127UL] = 0;
#line 2759
  ldv__builtin_va_start((__va_list_tag *)(& va));
#line 2761
  vaf.fmt = fmt;
#line 2762
  vaf.va = & va;
#line 2764
  switch (level) {
  case 0U: 
#line 2766
  printk("\n%s%pV", (char *)(& pbuf), & vaf);
#line 2767
  goto ldv_43934;
  case 1U: 
#line 2769
  printk("\v%s%pV", (char *)(& pbuf), & vaf);
#line 2770
  goto ldv_43934;
  case 2U: 
#line 2772
  printk("\f%s%pV", (char *)(& pbuf), & vaf);
#line 2773
  goto ldv_43934;
  default: 
#line 2775
  printk("\016%s%pV", (char *)(& pbuf), & vaf);
#line 2776
  goto ldv_43934;
  }
  ldv_43934: 
#line 2779
  ldv__builtin_va_end((__va_list_tag *)(& va));
#line 2780
  return;
}
}
#line 2797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_log_pci(uint32_t level , struct pci_dev *pdev , int32_t id , char const   *fmt 
                , ...) 
{ 
  va_list va ;
  struct va_format vaf ;
  char pbuf[128U] ;
  char const   *tmp ;

  {
#line 2804
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
#line 2805
    return;
  } else {

  }
#line 2806
  if ((uint32_t )ql_errlev < level) {
#line 2807
    return;
  } else {

  }
#line 2810
  tmp = dev_name((struct device  const  *)(& pdev->dev));
#line 2810
  snprintf((char *)(& pbuf), 128UL, "%s [%s]-%04x: : ", (char *)"qla2xxx", tmp, id);
#line 2812
  pbuf[127UL] = 0;
#line 2814
  ldv__builtin_va_start((__va_list_tag *)(& va));
#line 2816
  vaf.fmt = fmt;
#line 2817
  vaf.va = & va;
#line 2819
  switch (level) {
  case 0U: 
#line 2821
  printk("\n%s%pV", (char *)(& pbuf), & vaf);
#line 2822
  goto ldv_43948;
  case 1U: 
#line 2824
  printk("\v%s%pV", (char *)(& pbuf), & vaf);
#line 2825
  goto ldv_43948;
  case 2U: 
#line 2827
  printk("\f%s%pV", (char *)(& pbuf), & vaf);
#line 2828
  goto ldv_43948;
  default: 
#line 2830
  printk("\016%s%pV", (char *)(& pbuf), & vaf);
#line 2831
  goto ldv_43948;
  }
  ldv_43948: 
#line 2834
  ldv__builtin_va_end((__va_list_tag *)(& va));
#line 2835
  return;
}
}
#line 2838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_dump_regs(uint32_t level , scsi_qla_host_t *vha , int32_t id ) 
{ 
  int i ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  struct device_reg_24xx *reg24 ;
  struct device_reg_82xx *reg82 ;
  uint16_t *mbx_reg ;
  int tmp ;
  uint16_t *tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 2841
  ha = vha->hw;
#line 2842
  reg = & (ha->iobase)->isp;
#line 2843
  reg24 = & (ha->iobase)->isp24;
#line 2844
  reg82 = & (ha->iobase)->isp82;
#line 2847
  tmp = ql_mask_match(level);
#line 2847
  if (tmp == 0) {
#line 2848
    return;
  } else {

  }
#line 2850
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2851
    mbx_reg = (uint16_t *)(& reg82->mailbox_in);
  } else
#line 2852
  if ((ha->device_type & 134217728U) != 0U) {
#line 2853
    mbx_reg = & reg24->mailbox0;
  } else {
#line 2855
    mbx_reg = (int )ha->device_type & 1 || (ha->device_type & 2U) != 0U ? & reg->u.isp2100.mailbox0 : & reg->u.isp2300.mailbox0;
  }
#line 2857
  ql_dbg(level, vha, id, "Mailbox registers:\n");
#line 2858
  i = 0;
#line 2858
  goto ldv_43964;
  ldv_43963: 
#line 2859
  tmp___0 = mbx_reg;
#line 2859
  mbx_reg = mbx_reg + 1;
#line 2859
  tmp___1 = readw((void const volatile   *)tmp___0);
#line 2859
  ql_dbg(level, vha, id, "mbox[%d] 0x%04x\n", i, (int )tmp___1);
#line 2858
  i = i + 1;
  ldv_43964: ;
#line 2858
  if (i <= 5) {
#line 2860
    goto ldv_43963;
  } else {

  }

#line 2865
  return;
}
}
#line 2865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void ql_dump_buffer(uint32_t level , scsi_qla_host_t *vha , int32_t id , uint8_t *b ,
                    uint32_t size ) 
{ 
  uint32_t cnt ;
  uint8_t c ;
  int tmp ;
  uint8_t *tmp___0 ;

  {
#line 2871
  tmp = ql_mask_match(level);
#line 2871
  if (tmp == 0) {
#line 2872
    return;
  } else {

  }
#line 2874
  ql_dbg(level, vha, id, " 0   1   2   3   4   5   6   7   8   9  Ah  Bh  Ch  Dh  Eh  Fh\n");
#line 2876
  ql_dbg(level, vha, id, "--------------------------------------------------------------\n");
#line 2879
  ql_dbg(level, vha, id, " ");
#line 2880
  cnt = 0U;
#line 2880
  goto ldv_43976;
  ldv_43975: 
#line 2881
  tmp___0 = b;
#line 2881
  b = b + 1;
#line 2881
  c = *tmp___0;
#line 2882
  printk("%02x", (unsigned int )c);
#line 2883
  cnt = cnt + 1U;
#line 2884
  if ((cnt & 15U) == 0U) {
#line 2885
    printk("\n");
  } else {
#line 2887
    printk("  ");
  }
  ldv_43976: ;
#line 2880
  if (cnt < size) {
#line 2882
    goto ldv_43975;
  } else {

  }

#line 2889
  if ((cnt & 15U) != 0U) {
#line 2890
    ql_dbg(level, vha, id, "\n");
  } else {

  }
#line 2891
  return;
}
}
#line 2894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void disable_suitable_timer_8(struct timer_list *timer ) 
{ 


  {
#line 2895
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_8) {
#line 2896
    ldv_timer_state_8 = 0;
#line 2897
    return;
  } else {

  }
#line 2899
  return;
}
}
#line 2902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2902
  if ((unsigned long )ldv_timer_list_8 == (unsigned long )timer) {
#line 2903
    if (ldv_timer_state_8 == 2 || pending_flag != 0) {
#line 2904
      ldv_timer_list_8 = timer;
#line 2905
      ldv_timer_list_8->data = data;
#line 2906
      ldv_timer_state_8 = 1;
    } else {

    }
#line 2908
    return;
  } else {

  }
#line 2910
  reg_timer_8(timer);
#line 2911
  ldv_timer_list_8->data = data;
#line 2912
  return;
}
}
#line 2915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
void choose_timer_8(struct timer_list *timer ) 
{ 


  {
#line 2916
  LDV_IN_INTERRUPT = 2;
#line 2917
  (*(timer->function))(timer->data);
#line 2918
  LDV_IN_INTERRUPT = 1;
#line 2919
  ldv_timer_state_8 = 2;
#line 2920
  return;
}
}
#line 2923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int reg_timer_8(struct timer_list *timer ) 
{ 


  {
#line 2924
  ldv_timer_list_8 = timer;
#line 2925
  ldv_timer_state_8 = 1;
#line 2926
  return (0);
}
}
#line 2928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int ldv_del_timer_39(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 2932
  tmp = del_timer(ldv_func_arg1);
#line 2932
  ldv_func_res = tmp;
#line 2934
  disable_suitable_timer_7(ldv_func_arg1);
#line 2936
  return (ldv_func_res);
}
}
#line 2939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dbg.o.c.prepared"
int ldv_scsi_add_host_with_dma_40(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 2943
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 2943
  ldv_func_res = tmp;
#line 2945
  if (ldv_func_res == 0) {
#line 2946
    ldv_state_variable_72 = 1;
#line 2946
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 2950
  return (ldv_func_res);
}
}
#line 152 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 41 "include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_43(struct timer_list *ldv_func_arg1 ) ;
#line 309 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value , int port ) 
{ 


  {
#line 309
  __asm__  volatile   ("outw %w0, %w1": : "a" (value), "Nd" (port));
#line 310
  return;
}
}
#line 309 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port ) 
{ 
  unsigned short value ;

  {
#line 309
  __asm__  volatile   ("inw %w1, %w0": "=a" (value): "Nd" (port));
#line 309
  return (value);
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 233
int reg_timer_9(struct timer_list *timer ) ;
#line 241
void choose_timer_9(struct timer_list *timer ) ;
#line 278
void disable_suitable_timer_9(struct timer_list *timer ) ;
#line 2417 "include/linux/sched.h"
extern int _cond_resched(void) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_44(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 820
extern void scsi_unblock_requests(struct Scsi_Host * ) ;
#line 821
extern void scsi_block_requests(struct Scsi_Host * ) ;
#line 850 "include/scsi/scsi_transport_fc.h"
extern struct fc_vport *fc_vport_create(struct Scsi_Host * , int  , struct fc_vport_identifiers * ) ;
#line 552 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha , struct qla_fcp_prio_cfg *pri_cfg ,
                               uint8_t flag ) ;
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_lock_nvram_access(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 325
  reg = & (ha->iobase)->isp;
#line 327
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 328
    data = readw((void const volatile   *)(& reg->nvram));
#line 329
    goto ldv_43459;
    ldv_43458: 
#line 330
    __const_udelay(429500UL);
#line 331
    data = readw((void const volatile   *)(& reg->nvram));
    ldv_43459: ;
#line 329
    if ((int )((short )data) < 0) {
#line 331
      goto ldv_43458;
    } else {

    }
#line 335
    writew(1, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 336
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 337
    __const_udelay(21475UL);
#line 338
    data = readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 339
    goto ldv_43462;
    ldv_43461: 
#line 341
    __const_udelay(429500UL);
#line 342
    writew(1, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 343
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
#line 344
    __const_udelay(21475UL);
#line 345
    data = readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
    ldv_43462: ;
#line 339
    if (((int )data & 1) == 0) {
#line 341
      goto ldv_43461;
    } else {

    }

  } else {

  }
#line 347
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_unlock_nvram_access(struct qla_hw_data *ha ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 357
  reg = & (ha->iobase)->isp;
#line 359
  if (((ha->device_type & 1U) == 0U && (ha->device_type & 2U) == 0U) && (ha->device_type & 4U) == 0U) {
#line 360
    writew(0, (void volatile   *)(& reg->u.isp2300.host_semaphore));
#line 361
    readw((void const volatile   *)(& reg->u.isp2300.host_semaphore));
  } else {

  }
#line 363
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_nv_write(struct qla_hw_data *ha , uint16_t data ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 373
  reg = & (ha->iobase)->isp;
#line 375
  writew((int )((unsigned int )data | 16386U), (void volatile   *)(& reg->nvram));
#line 376
  readw((void const volatile   *)(& reg->nvram));
#line 377
  __const_udelay(42950UL);
#line 378
  writew((int )((unsigned int )data | 16387U), (void volatile   *)(& reg->nvram));
#line 380
  readw((void const volatile   *)(& reg->nvram));
#line 381
  __const_udelay(42950UL);
#line 382
  writew((int )((unsigned int )data | 16386U), (void volatile   *)(& reg->nvram));
#line 383
  readw((void const volatile   *)(& reg->nvram));
#line 384
  __const_udelay(42950UL);
#line 386
  return;
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static uint16_t qla2x00_nvram_request(struct qla_hw_data *ha , uint32_t nv_cmd ) 
{ 
  uint8_t cnt ;
  struct device_reg_2xxx *reg ;
  uint16_t data ;
  uint16_t reg_data ;

  {
#line 406
  reg = & (ha->iobase)->isp;
#line 407
  data = 0U;
#line 411
  nv_cmd = nv_cmd << 5;
#line 412
  cnt = 0U;
#line 412
  goto ldv_43482;
  ldv_43481: ;
#line 413
  if ((int )nv_cmd < 0) {
#line 414
    qla2x00_nv_write(ha, 4);
  } else {
#line 416
    qla2x00_nv_write(ha, 0);
  }
#line 417
  nv_cmd = nv_cmd << 1;
#line 412
  cnt = (uint8_t )((int )cnt + 1);
  ldv_43482: ;
#line 412
  if ((unsigned int )cnt <= 10U) {
#line 414
    goto ldv_43481;
  } else {

  }
#line 421
  cnt = 0U;
#line 421
  goto ldv_43485;
  ldv_43484: 
#line 422
  writew(3, (void volatile   *)(& reg->nvram));
#line 423
  readw((void const volatile   *)(& reg->nvram));
#line 424
  __const_udelay(42950UL);
#line 425
  data = (int )data << 1U;
#line 426
  reg_data = readw((void const volatile   *)(& reg->nvram));
#line 427
  if (((int )reg_data & 8) != 0) {
#line 428
    data = (uint16_t )((unsigned int )data | 1U);
  } else {

  }
#line 429
  writew(2, (void volatile   *)(& reg->nvram));
#line 430
  readw((void const volatile   *)(& reg->nvram));
#line 431
  __const_udelay(42950UL);
#line 421
  cnt = (uint8_t )((int )cnt + 1);
  ldv_43485: ;
#line 421
  if ((unsigned int )cnt <= 15U) {
#line 423
    goto ldv_43484;
  } else {

  }
#line 435
  writew(0, (void volatile   *)(& reg->nvram));
#line 436
  readw((void const volatile   *)(& reg->nvram));
#line 437
  __const_udelay(42950UL);
#line 439
  return (data);
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static uint16_t qla2x00_get_nvram_word(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  uint16_t data ;
  uint32_t nv_cmd ;

  {
#line 457
  nv_cmd = addr << 16;
#line 458
  nv_cmd = nv_cmd | 100663296U;
#line 459
  data = qla2x00_nvram_request(ha, nv_cmd);
#line 461
  return (data);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_nv_deselect(struct qla_hw_data *ha ) 
{ 
  struct device_reg_2xxx *reg ;

  {
#line 471
  reg = & (ha->iobase)->isp;
#line 473
  writew(0, (void volatile   *)(& reg->nvram));
#line 474
  readw((void const volatile   *)(& reg->nvram));
#line 475
  __const_udelay(42950UL);
#line 477
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_write_nvram_word(struct qla_hw_data *ha , uint32_t addr , uint16_t data ) 
{ 
  int count ;
  uint16_t word ;
  uint32_t nv_cmd ;
  uint32_t wait_cnt ;
  struct device_reg_2xxx *reg ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 490
  reg = & (ha->iobase)->isp;
#line 491
  tmp = pci_get_drvdata(ha->pdev);
#line 491
  vha = (scsi_qla_host_t *)tmp;
#line 493
  qla2x00_nv_write(ha, 4);
#line 494
  qla2x00_nv_write(ha, 0);
#line 495
  qla2x00_nv_write(ha, 0);
#line 497
  word = 0U;
#line 497
  goto ldv_43509;
  ldv_43508: 
#line 498
  qla2x00_nv_write(ha, 4);
#line 497
  word = (uint16_t )((int )word + 1);
  ldv_43509: ;
#line 497
  if ((unsigned int )word <= 7U) {
#line 499
    goto ldv_43508;
  } else {

  }
#line 500
  qla2x00_nv_deselect(ha);
#line 503
  nv_cmd = (addr << 16) | 83886080U;
#line 504
  nv_cmd = (uint32_t )data | nv_cmd;
#line 505
  nv_cmd = nv_cmd << 5;
#line 506
  count = 0;
#line 506
  goto ldv_43512;
  ldv_43511: ;
#line 507
  if ((int )nv_cmd < 0) {
#line 508
    qla2x00_nv_write(ha, 4);
  } else {
#line 510
    qla2x00_nv_write(ha, 0);
  }
#line 512
  nv_cmd = nv_cmd << 1;
#line 506
  count = count + 1;
  ldv_43512: ;
#line 506
  if (count <= 26) {
#line 508
    goto ldv_43511;
  } else {

  }
#line 515
  qla2x00_nv_deselect(ha);
#line 518
  writew(2, (void volatile   *)(& reg->nvram));
#line 519
  readw((void const volatile   *)(& reg->nvram));
#line 520
  wait_cnt = 20000U;
  ldv_43515: 
#line 522
  wait_cnt = wait_cnt - 1U;
#line 522
  if (wait_cnt == 0U) {
#line 523
    ql_dbg(8388608U, vha, 28813, "NVRAM didn\'t go ready...\n");
#line 525
    goto ldv_43514;
  } else {

  }
#line 527
  __const_udelay(42950UL);
#line 528
  word = readw((void const volatile   *)(& reg->nvram));
#line 529
  if (((int )word & 8) == 0) {
#line 531
    goto ldv_43515;
  } else {

  }
  ldv_43514: 
#line 531
  qla2x00_nv_deselect(ha);
#line 534
  qla2x00_nv_write(ha, 4);
#line 535
  count = 0;
#line 535
  goto ldv_43517;
  ldv_43516: 
#line 536
  qla2x00_nv_write(ha, 0);
#line 535
  count = count + 1;
  ldv_43517: ;
#line 535
  if (count <= 9) {
#line 537
    goto ldv_43516;
  } else {

  }
#line 538
  qla2x00_nv_deselect(ha);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_write_nvram_word_tmo(struct qla_hw_data *ha , uint32_t addr , uint16_t data ,
                                        uint32_t tmo ) 
{ 
  int ret ;
  int count ;
  uint16_t word ;
  uint32_t nv_cmd ;
  struct device_reg_2xxx *reg ;

  {
#line 548
  reg = & (ha->iobase)->isp;
#line 550
  ret = 0;
#line 552
  qla2x00_nv_write(ha, 4);
#line 553
  qla2x00_nv_write(ha, 0);
#line 554
  qla2x00_nv_write(ha, 0);
#line 556
  word = 0U;
#line 556
  goto ldv_43531;
  ldv_43530: 
#line 557
  qla2x00_nv_write(ha, 4);
#line 556
  word = (uint16_t )((int )word + 1);
  ldv_43531: ;
#line 556
  if ((unsigned int )word <= 7U) {
#line 558
    goto ldv_43530;
  } else {

  }
#line 559
  qla2x00_nv_deselect(ha);
#line 562
  nv_cmd = (addr << 16) | 83886080U;
#line 563
  nv_cmd = (uint32_t )data | nv_cmd;
#line 564
  nv_cmd = nv_cmd << 5;
#line 565
  count = 0;
#line 565
  goto ldv_43534;
  ldv_43533: ;
#line 566
  if ((int )nv_cmd < 0) {
#line 567
    qla2x00_nv_write(ha, 4);
  } else {
#line 569
    qla2x00_nv_write(ha, 0);
  }
#line 571
  nv_cmd = nv_cmd << 1;
#line 565
  count = count + 1;
  ldv_43534: ;
#line 565
  if (count <= 26) {
#line 567
    goto ldv_43533;
  } else {

  }
#line 574
  qla2x00_nv_deselect(ha);
#line 577
  writew(2, (void volatile   *)(& reg->nvram));
#line 578
  readw((void const volatile   *)(& reg->nvram));
  ldv_43537: 
#line 580
  __const_udelay(42950UL);
#line 581
  word = readw((void const volatile   *)(& reg->nvram));
#line 582
  tmo = tmo - 1U;
#line 582
  if (tmo == 0U) {
#line 583
    ret = 258;
#line 584
    goto ldv_43536;
  } else {

  }
#line 586
  if (((int )word & 8) == 0) {
#line 588
    goto ldv_43537;
  } else {

  }
  ldv_43536: 
#line 588
  qla2x00_nv_deselect(ha);
#line 591
  qla2x00_nv_write(ha, 4);
#line 592
  count = 0;
#line 592
  goto ldv_43539;
  ldv_43538: 
#line 593
  qla2x00_nv_write(ha, 0);
#line 592
  count = count + 1;
  ldv_43539: ;
#line 592
  if (count <= 9) {
#line 594
    goto ldv_43538;
  } else {

  }
#line 595
  qla2x00_nv_deselect(ha);
#line 597
  return (ret);
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_clear_nvram_protection(struct qla_hw_data *ha ) 
{ 
  int ret ;
  int stat ;
  struct device_reg_2xxx *reg ;
  uint32_t word ;
  uint32_t wait_cnt ;
  uint16_t wprot ;
  uint16_t wprot_old ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
#line 608
  reg = & (ha->iobase)->isp;
#line 611
  tmp = pci_get_drvdata(ha->pdev);
#line 611
  vha = (scsi_qla_host_t *)tmp;
#line 614
  ret = 258;
#line 616
  wprot_old = qla2x00_get_nvram_word(ha, (uint32_t )ha->nvram_base);
#line 617
  stat = qla2x00_write_nvram_word_tmo(ha, (uint32_t )ha->nvram_base, 4660, 100000U);
#line 619
  wprot = qla2x00_get_nvram_word(ha, (uint32_t )ha->nvram_base);
#line 620
  if (stat != 0 || (unsigned int )wprot != 4660U) {
#line 622
    qla2x00_nv_write(ha, 4);
#line 623
    qla2x00_nv_write(ha, 0);
#line 624
    qla2x00_nv_write(ha, 0);
#line 625
    word = 0U;
#line 625
    goto ldv_43553;
    ldv_43552: 
#line 626
    qla2x00_nv_write(ha, 4);
#line 625
    word = word + 1U;
    ldv_43553: ;
#line 625
    if (word <= 7U) {
#line 627
      goto ldv_43552;
    } else {

    }
#line 628
    qla2x00_nv_deselect(ha);
#line 631
    qla2x00_nv_write(ha, 8196);
#line 632
    qla2x00_nv_write(ha, 8192);
#line 633
    qla2x00_nv_write(ha, 8192);
#line 634
    word = 0U;
#line 634
    goto ldv_43556;
    ldv_43555: 
#line 635
    qla2x00_nv_write(ha, 8196);
#line 634
    word = word + 1U;
    ldv_43556: ;
#line 634
    if (word <= 7U) {
#line 636
      goto ldv_43555;
    } else {

    }
#line 637
    qla2x00_nv_deselect(ha);
#line 640
    qla2x00_nv_write(ha, 8196);
#line 641
    qla2x00_nv_write(ha, 8196);
#line 642
    qla2x00_nv_write(ha, 8196);
#line 643
    word = 0U;
#line 643
    goto ldv_43559;
    ldv_43558: 
#line 644
    qla2x00_nv_write(ha, 8196);
#line 643
    word = word + 1U;
    ldv_43559: ;
#line 643
    if (word <= 7U) {
#line 645
      goto ldv_43558;
    } else {

    }
#line 646
    qla2x00_nv_deselect(ha);
#line 649
    writew(2, (void volatile   *)(& reg->nvram));
#line 650
    readw((void const volatile   *)(& reg->nvram));
#line 651
    wait_cnt = 20000U;
    ldv_43562: 
#line 653
    wait_cnt = wait_cnt - 1U;
#line 653
    if (wait_cnt == 0U) {
#line 654
      ql_dbg(8388608U, vha, 28814, "NVRAM didn\'t go ready...\n");
#line 656
      goto ldv_43561;
    } else {

    }
#line 658
    __const_udelay(42950UL);
#line 659
    tmp___0 = readw((void const volatile   *)(& reg->nvram));
#line 659
    word = (uint32_t )tmp___0;
#line 660
    if ((word & 8U) == 0U) {
#line 662
      goto ldv_43562;
    } else {

    }
    ldv_43561: ;
#line 662
    if (wait_cnt != 0U) {
#line 663
      ret = 0;
    } else {

    }
  } else {
#line 665
    qla2x00_write_nvram_word(ha, (uint32_t )ha->nvram_base, (int )wprot_old);
  }
#line 667
  return (ret);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_set_nvram_protection(struct qla_hw_data *ha , int stat ) 
{ 
  struct device_reg_2xxx *reg ;
  uint32_t word ;
  uint32_t wait_cnt ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
#line 673
  reg = & (ha->iobase)->isp;
#line 675
  tmp = pci_get_drvdata(ha->pdev);
#line 675
  vha = (scsi_qla_host_t *)tmp;
#line 677
  if (stat != 0) {
#line 678
    return;
  } else {

  }
#line 682
  qla2x00_nv_write(ha, 4);
#line 683
  qla2x00_nv_write(ha, 0);
#line 684
  qla2x00_nv_write(ha, 0);
#line 685
  word = 0U;
#line 685
  goto ldv_43572;
  ldv_43571: 
#line 686
  qla2x00_nv_write(ha, 4);
#line 685
  word = word + 1U;
  ldv_43572: ;
#line 685
  if (word <= 7U) {
#line 687
    goto ldv_43571;
  } else {

  }
#line 688
  qla2x00_nv_deselect(ha);
#line 691
  qla2x00_nv_write(ha, 8196);
#line 692
  qla2x00_nv_write(ha, 8192);
#line 693
  qla2x00_nv_write(ha, 8192);
#line 694
  word = 0U;
#line 694
  goto ldv_43575;
  ldv_43574: 
#line 695
  qla2x00_nv_write(ha, 8196);
#line 694
  word = word + 1U;
  ldv_43575: ;
#line 694
  if (word <= 7U) {
#line 696
    goto ldv_43574;
  } else {

  }
#line 697
  qla2x00_nv_deselect(ha);
#line 700
  qla2x00_nv_write(ha, 8196);
#line 701
  qla2x00_nv_write(ha, 8192);
#line 702
  qla2x00_nv_write(ha, 8196);
#line 703
  word = 0U;
#line 703
  goto ldv_43578;
  ldv_43577: 
#line 704
  qla2x00_nv_write(ha, 8192);
#line 703
  word = word + 1U;
  ldv_43578: ;
#line 703
  if (word <= 7U) {
#line 705
    goto ldv_43577;
  } else {

  }
#line 706
  qla2x00_nv_deselect(ha);
#line 709
  writew(2, (void volatile   *)(& reg->nvram));
#line 710
  readw((void const volatile   *)(& reg->nvram));
#line 711
  wait_cnt = 20000U;
  ldv_43581: 
#line 713
  wait_cnt = wait_cnt - 1U;
#line 713
  if (wait_cnt == 0U) {
#line 714
    ql_dbg(8388608U, vha, 28815, "NVRAM didn\'t go ready...\n");
#line 716
    goto ldv_43580;
  } else {

  }
#line 718
  __const_udelay(42950UL);
#line 719
  tmp___0 = readw((void const volatile   *)(& reg->nvram));
#line 719
  word = (uint32_t )tmp___0;
#line 720
  if ((word & 8U) == 0U) {
#line 722
    goto ldv_43581;
  } else {

  }
  ldv_43580: ;
#line 727
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static uint32_t flash_conf_addr(struct qla_hw_data *ha , uint32_t faddr ) 
{ 


  {
#line 731
  return (ha->flash_conf_off | faddr);
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static uint32_t flash_data_addr(struct qla_hw_data *ha , uint32_t faddr ) 
{ 


  {
#line 737
  return (ha->flash_data_off | faddr);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static uint32_t nvram_conf_addr(struct qla_hw_data *ha , uint32_t naddr ) 
{ 


  {
#line 743
  return (ha->nvram_conf_off | naddr);
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static uint32_t nvram_data_addr(struct qla_hw_data *ha , uint32_t naddr ) 
{ 


  {
#line 749
  return (ha->nvram_data_off | naddr);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static uint32_t qla24xx_read_flash_dword(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  int rval ;
  uint32_t cnt ;
  uint32_t data ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;

  {
#line 757
  reg = & (ha->iobase)->isp24;
#line 759
  writel(addr & 2147483647U, (void volatile   *)(& reg->flash_addr));
#line 761
  rval = 0;
#line 762
  cnt = 3000U;
#line 762
  goto ldv_43608;
  ldv_43607: ;
#line 765
  if (cnt != 0U) {
#line 766
    __const_udelay(42950UL);
  } else {
#line 768
    rval = 256;
  }
#line 769
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared",
                769, 0);
#line 769
  _cond_resched();
#line 764
  cnt = cnt - 1U;
  ldv_43608: 
#line 762
  tmp = readl((void const volatile   *)(& reg->flash_addr));
#line 762
  if ((int )tmp >= 0 && rval == 0) {
#line 766
    goto ldv_43607;
  } else {

  }
#line 773
  data = 3735936685U;
#line 774
  if (rval == 0) {
#line 775
    data = readl((void const volatile   *)(& reg->flash_data));
  } else {

  }
#line 777
  return (data);
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint32_t *qla24xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                  uint32_t dwords ) 
{ 
  uint32_t i ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 785
  ha = vha->hw;
#line 788
  i = 0U;
#line 788
  goto ldv_43619;
  ldv_43618: 
#line 789
  tmp = flash_data_addr(ha, faddr);
#line 789
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 788
  i = i + 1U;
#line 788
  faddr = faddr + 1U;
  ldv_43619: ;
#line 788
  if (i < dwords) {
#line 790
    goto ldv_43618;
  } else {

  }

#line 792
  return (dwptr);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla24xx_write_flash_dword(struct qla_hw_data *ha , uint32_t addr , uint32_t data ) 
{ 
  int rval ;
  uint32_t cnt ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;

  {
#line 800
  reg = & (ha->iobase)->isp24;
#line 802
  writel(data, (void volatile   *)(& reg->flash_data));
#line 803
  readl((void const volatile   *)(& reg->flash_data));
#line 804
  writel(addr | 2147483648U, (void volatile   *)(& reg->flash_addr));
#line 806
  rval = 0;
#line 807
  cnt = 500000U;
#line 807
  goto ldv_43631;
  ldv_43630: ;
#line 809
  if (cnt != 0U) {
#line 810
    __const_udelay(42950UL);
  } else {
#line 812
    rval = 256;
  }
#line 813
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared",
                813, 0);
#line 813
  _cond_resched();
#line 808
  cnt = cnt - 1U;
  ldv_43631: 
#line 807
  tmp = readl((void const volatile   *)(& reg->flash_addr));
#line 807
  if ((int )tmp < 0 && rval == 0) {
#line 810
    goto ldv_43630;
  } else {

  }

#line 815
  return (rval);
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla24xx_get_flash_manufacturer(struct qla_hw_data *ha , uint8_t *man_id ,
                                           uint8_t *flash_id ) 
{ 
  uint32_t ids ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 824
  tmp = flash_conf_addr(ha, 939U);
#line 824
  ids = qla24xx_read_flash_dword(ha, tmp);
#line 825
  *man_id = (unsigned char )ids;
#line 826
  *flash_id = (unsigned char )((int )((unsigned short )ids) >> 8);
#line 829
  if (ids != 3735936685U && ((unsigned int )*man_id == 0U || (unsigned int )*flash_id == 0U)) {
#line 836
    tmp___0 = flash_conf_addr(ha, 159U);
#line 836
    ids = qla24xx_read_flash_dword(ha, tmp___0);
#line 837
    *man_id = (unsigned char )ids;
#line 838
    *flash_id = (unsigned char )((int )((unsigned short )ids) >> 8);
  } else {

  }
#line 840
  return;
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2xxx_find_flt_start(scsi_qla_host_t *vha , uint32_t *start ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *buf ;
  uint8_t *bcode ;
  uint8_t last_image ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint16_t *wptr ;
  struct qla_flt_location *fltl ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;

  {
#line 845
  locations[0] = "DEF";
#line 845
  locations[1] = "PCI";
#line 851
  ha = vha->hw;
#line 852
  req = *(ha->req_q_map);
#line 859
  loc = locations[0];
#line 860
  *start = 0U;
#line 861
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 862
    *start = 70656U;
  } else
#line 863
  if ((ha->device_type & 2048U) != 0U) {
#line 864
    *start = 328704U;
  } else
#line 865
  if ((ha->device_type & 8192U) != 0U) {
#line 866
    *start = 885760U;
  } else
#line 867
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 868
    *start = 1033216U;
#line 869
    goto end;
  } else
#line 870
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 871
    *start = 1033216U;
#line 872
    goto end;
  } else {

  }
#line 875
  buf = (uint8_t *)req->ring;
#line 876
  dcode = (uint32_t *)req->ring;
#line 877
  pcihdr = 0U;
#line 878
  last_image = 1U;
  ldv_43658: 
#line 881
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 32U);
#line 882
  bcode = buf + ((unsigned long )pcihdr & 3UL);
#line 883
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 884
    goto end;
  } else {

  }
#line 887
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 888
  qla24xx_read_flash_data(vha, dcode, pcids >> 2, 32U);
#line 889
  bcode = buf + ((unsigned long )pcihdr & 3UL);
#line 892
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 894
    goto end;
  } else {

  }
#line 896
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 899
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 900
  if ((unsigned int )last_image == 0U) {
#line 902
    goto ldv_43658;
  } else {

  }
#line 903
  fltl = (struct qla_flt_location *)req->ring;
#line 904
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 4U);
#line 906
  if ((((unsigned int )fltl->sig[0] != 81U || (unsigned int )fltl->sig[1] != 70U) || (unsigned int )fltl->sig[2] != 76U) || (unsigned int )fltl->sig[3] != 84U) {
#line 908
    goto end;
  } else {

  }
#line 910
  wptr = (uint16_t *)req->ring;
#line 911
  cnt = 8U;
#line 912
  chksum = 0U;
#line 912
  goto ldv_43661;
  ldv_43660: 
#line 913
  tmp = wptr;
#line 913
  wptr = wptr + 1;
#line 913
  chksum = (int )*tmp + (int )chksum;
#line 912
  cnt = (uint16_t )((int )cnt - 1);
  ldv_43661: ;
#line 912
  if ((unsigned int )cnt != 0U) {
#line 914
    goto ldv_43660;
  } else {

  }

#line 914
  if ((unsigned int )chksum != 0U) {
#line 915
    ql_log(0U, vha, 69, "Inconsistent FLTL detected: checksum=0x%x.\n", (int )chksum);
#line 917
    ql_dump_buffer(1073872896U, vha, 270, buf, 16U);
#line 919
    return (258);
  } else {

  }
#line 923
  loc = locations[1];
#line 924
  *start = (uint32_t )((((int )fltl->start_hi << 16) | (int )fltl->start_lo) >> 2);
  end: 
#line 927
  ql_dbg(1073741824U, vha, 70, "FLTL[%s] = 0x%x.\n", loc, *start);
#line 930
  return (0);
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2xxx_get_flt_info(scsi_qla_host_t *vha , uint32_t flt_addr ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint32_t def_fw[3U] ;
  uint32_t def_boot[3U] ;
  uint32_t def_vpd_nvram[3U] ;
  uint32_t def_vpd0[3U] ;
  uint32_t def_vpd1[3U] ;
  uint32_t def_nvram0[3U] ;
  uint32_t def_nvram1[3U] ;
  uint32_t def_fdt[3U] ;
  uint32_t def_npiv_conf0[3U] ;
  uint32_t def_npiv_conf1[3U] ;
  uint32_t fcp_prio_cfg0[3U] ;
  uint32_t fcp_prio_cfg1[3U] ;
  uint32_t def ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint32_t start ;
  struct qla_flt_header *flt ;
  struct qla_flt_region *region ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;

  {
#line 936
  locations[0] = "DEF";
#line 936
  locations[1] = "FLT";
#line 937
  def_fw[0] = 131072U;
#line 937
  def_fw[1] = 131072U;
#line 937
  def_fw[2] = 655360U;
#line 939
  def_boot[0] = 0U;
#line 939
  def_boot[1] = 0U;
#line 939
  def_boot[2] = 524288U;
#line 941
  def_vpd_nvram[0] = 294912U;
#line 941
  def_vpd_nvram[1] = 294912U;
#line 941
  def_vpd_nvram[2] = 851968U;
#line 943
  def_vpd0[0] = 0U;
#line 943
  def_vpd0[1] = 0U;
#line 943
  def_vpd0[2] = 851968U;
#line 945
  def_vpd1[0] = 0U;
#line 945
  def_vpd1[1] = 0U;
#line 945
  def_vpd1[2] = 852992U;
#line 947
  def_nvram0[0] = 0U;
#line 947
  def_nvram0[1] = 0U;
#line 947
  def_nvram0[2] = 852096U;
#line 949
  def_nvram1[0] = 0U;
#line 949
  def_nvram1[1] = 0U;
#line 949
  def_nvram1[2] = 852352U;
#line 951
  def_fdt[0] = 69632U;
#line 951
  def_fdt[1] = 327680U;
#line 951
  def_fdt[2] = 884736U;
#line 954
  def_npiv_conf0[0] = 90112U;
#line 954
  def_npiv_conf0[1] = 376832U;
#line 954
  def_npiv_conf0[2] = 856064U;
#line 957
  def_npiv_conf1[0] = 94208U;
#line 957
  def_npiv_conf1[1] = 380928U;
#line 957
  def_npiv_conf1[2] = 860160U;
#line 960
  fcp_prio_cfg0[0] = 65536U;
#line 960
  fcp_prio_cfg0[1] = 245760U;
#line 960
  fcp_prio_cfg0[2] = 0U;
#line 963
  fcp_prio_cfg1[0] = 73728U;
#line 963
  fcp_prio_cfg1[1] = 253952U;
#line 963
  fcp_prio_cfg1[2] = 0U;
#line 972
  ha = vha->hw;
#line 973
  req = *(ha->req_q_map);
#line 975
  def = 0U;
#line 976
  if ((ha->device_type & 2048U) != 0U) {
#line 977
    def = 1U;
  } else
#line 978
  if ((ha->device_type & 8192U) != 0U) {
#line 979
    def = 2U;
  } else {

  }
#line 984
  ha->flt_region_fcp_prio = *((unsigned long *)ha + 2UL) != 0UL ? fcp_prio_cfg0[def] : fcp_prio_cfg1[def];
#line 987
  ha->flt_region_flt = flt_addr;
#line 988
  wptr = (uint16_t *)req->ring;
#line 989
  flt = (struct qla_flt_header *)req->ring;
#line 990
  region = (struct qla_flt_region *)flt + 1U;
#line 991
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, flt_addr << 2, 4096U);
#line 993
  if ((unsigned int )*wptr == 65535U) {
#line 994
    goto no_flash_data;
  } else {

  }
#line 995
  if ((unsigned int )flt->version != 1U) {
#line 996
    ql_log(1U, vha, 71, "Unsupported FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",
           (int )flt->version, (int )flt->length, (int )flt->checksum);
#line 1000
    goto no_flash_data;
  } else {

  }
#line 1003
  cnt = (uint16_t )(((unsigned long )flt->length + 8UL) >> 1);
#line 1004
  chksum = 0U;
#line 1004
  goto ldv_43692;
  ldv_43691: 
#line 1005
  tmp = wptr;
#line 1005
  wptr = wptr + 1;
#line 1005
  chksum = (int )*tmp + (int )chksum;
#line 1004
  cnt = (uint16_t )((int )cnt - 1);
  ldv_43692: ;
#line 1004
  if ((unsigned int )cnt != 0U) {
#line 1006
    goto ldv_43691;
  } else {

  }

#line 1006
  if ((unsigned int )chksum != 0U) {
#line 1007
    ql_log(0U, vha, 72, "Inconsistent FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",
           (int )flt->version, (int )flt->length, (int )flt->checksum);
#line 1011
    goto no_flash_data;
  } else {

  }
#line 1014
  loc = locations[1];
#line 1015
  cnt = (uint16_t )((unsigned int )flt->length / 16U);
#line 1016
  goto ldv_43718;
  ldv_43717: 
#line 1018
  start = region->start >> 2;
#line 1019
  ql_dbg(1073741824U, vha, 73, "FLT[%02x]: start=0x%x end=0x%x size=0x%x.\n", region->code & 255U,
         start, region->end >> 2, region->size);
#line 1025
  switch (region->code & 255U) {
  case 164U: ;
#line 1027
  if ((ha->device_type & 65536U) == 0U) {
#line 1028
    goto ldv_43695;
  } else {

  }
#line 1029
  ha->flt_region_fw = start;
#line 1030
  goto ldv_43695;
  case 1U: ;
#line 1032
  if ((ha->device_type & 65536U) != 0U) {
#line 1033
    goto ldv_43695;
  } else {

  }
#line 1034
  ha->flt_region_fw = start;
#line 1035
  goto ldv_43695;
  case 7U: 
#line 1037
  ha->flt_region_boot = start;
#line 1038
  goto ldv_43695;
  case 20U: ;
#line 1040
  if ((ha->device_type & 65536U) != 0U) {
#line 1041
    goto ldv_43695;
  } else {

  }
#line 1042
  ha->flt_region_vpd_nvram = start;
#line 1043
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1044
    goto ldv_43695;
  } else {

  }
#line 1045
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1046
    ha->flt_region_vpd = start;
  } else {

  }
#line 1047
  goto ldv_43695;
  case 22U: ;
#line 1049
  if (((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) || (ha->device_type & 65536U) != 0U) {
#line 1050
    goto ldv_43695;
  } else {

  }
#line 1051
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1052
    ha->flt_region_vpd = start;
  } else {

  }
#line 1053
  goto ldv_43695;
  case 21U: ;
#line 1055
  if ((ha->device_type & 65536U) != 0U) {
#line 1056
    goto ldv_43695;
  } else {

  }
#line 1057
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1058
    ha->flt_region_nvram = start;
  } else {

  }
#line 1059
  goto ldv_43695;
  case 23U: ;
#line 1061
  if ((ha->device_type & 65536U) != 0U) {
#line 1062
    goto ldv_43695;
  } else {

  }
#line 1063
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1064
    ha->flt_region_nvram = start;
  } else {

  }
#line 1065
  goto ldv_43695;
  case 26U: 
#line 1067
  ha->flt_region_fdt = start;
#line 1068
  goto ldv_43695;
  case 41U: ;
#line 1070
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1071
    ha->flt_region_npiv_conf = start;
  } else {

  }
#line 1072
  goto ldv_43695;
  case 42U: ;
#line 1074
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1075
    ha->flt_region_npiv_conf = start;
  } else {

  }
#line 1076
  goto ldv_43695;
  case 47U: 
#line 1078
  ha->flt_region_gold_fw = start;
#line 1079
  goto ldv_43695;
  case 135U: ;
#line 1081
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1082
    ha->flt_region_fcp_prio = start;
  } else {

  }
#line 1083
  goto ldv_43695;
  case 136U: ;
#line 1085
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1086
    ha->flt_region_fcp_prio = start;
  } else {

  }
#line 1087
  goto ldv_43695;
  case 120U: 
#line 1089
  ha->flt_region_boot = start;
#line 1090
  goto ldv_43695;
  case 162U: ;
#line 1092
  if ((ha->device_type & 262144U) != 0U) {
#line 1093
    ha->flt_region_boot = start;
  } else {

  }
#line 1094
  goto ldv_43695;
  case 116U: 
#line 1096
  ha->flt_region_fw = start;
#line 1097
  goto ldv_43695;
  case 151U: ;
#line 1099
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1100
    ha->flt_region_fw = start;
  } else {

  }
#line 1101
  goto ldv_43695;
  case 117U: 
#line 1103
  ha->flt_region_gold_fw = start;
#line 1104
  goto ldv_43695;
  case 114U: 
#line 1106
  ha->flt_region_bootload = start;
#line 1107
  goto ldv_43695;
  case 129U: ;
#line 1109
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1110
    ha->flt_region_vpd = start;
  } else {

  }
#line 1111
  goto ldv_43695;
  case 170U: ;
#line 1113
  if ((ha->device_type & 65536U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 1114
    goto ldv_43695;
  } else {

  }
#line 1115
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1116
    ha->flt_region_nvram = start;
  } else {

  }
#line 1117
  goto ldv_43695;
  case 172U: ;
#line 1119
  if ((ha->device_type & 65536U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 1120
    goto ldv_43695;
  } else {

  }
#line 1121
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1122
    ha->flt_region_nvram = start;
  } else {

  }
#line 1123
  goto ldv_43695;
  }
  ldv_43695: 
#line 1016
  cnt = (uint16_t )((int )cnt - 1);
#line 1016
  region = region + 1;
  ldv_43718: ;
#line 1016
  if ((unsigned int )cnt != 0U) {
#line 1018
    goto ldv_43717;
  } else {

  }

#line 1126
  goto done;
  no_flash_data: 
#line 1130
  loc = locations[0];
#line 1131
  ha->flt_region_fw = def_fw[def];
#line 1132
  ha->flt_region_boot = def_boot[def];
#line 1133
  ha->flt_region_vpd_nvram = def_vpd_nvram[def];
#line 1134
  ha->flt_region_vpd = *((unsigned long *)ha + 2UL) != 0UL ? def_vpd0[def] : def_vpd1[def];
#line 1136
  ha->flt_region_nvram = *((unsigned long *)ha + 2UL) != 0UL ? def_nvram0[def] : def_nvram1[def];
#line 1138
  ha->flt_region_fdt = def_fdt[def];
#line 1139
  ha->flt_region_npiv_conf = *((unsigned long *)ha + 2UL) != 0UL ? def_npiv_conf0[def] : def_npiv_conf1[def];
  done: 
#line 1142
  ql_dbg(1073741824U, vha, 74, "FLT[%s]: boot=0x%x fw=0x%x vpd_nvram=0x%x vpd=0x%x nvram=0x%x fdt=0x%x flt=0x%x npiv=0x%x fcp_prif_cfg=0x%x.\n",
         loc, ha->flt_region_boot, ha->flt_region_fw, ha->flt_region_vpd_nvram, ha->flt_region_vpd,
         ha->flt_region_nvram, ha->flt_region_fdt, ha->flt_region_flt, ha->flt_region_npiv_conf,
         ha->flt_region_fcp_prio);
#line 1149
  return;
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2xxx_get_fdt_info(scsi_qla_host_t *vha ) 
{ 
  char const   *loc ;
  char const   *locations[2U] ;
  uint16_t cnt ;
  uint16_t chksum ;
  uint16_t *wptr ;
  struct qla_fdt_layout *fdt ;
  uint8_t man_id ;
  uint8_t flash_id ;
  uint16_t mid ;
  uint16_t fid ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint16_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1157
  locations[0] = "MID";
#line 1157
  locations[1] = "FDT";
#line 1162
  mid = 0U;
#line 1162
  fid = 0U;
#line 1163
  ha = vha->hw;
#line 1164
  req = *(ha->req_q_map);
#line 1166
  wptr = (uint16_t *)req->ring;
#line 1167
  fdt = (struct qla_fdt_layout *)req->ring;
#line 1168
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, ha->flt_region_fdt << 2,
                                  4096U);
#line 1170
  if ((unsigned int )*wptr == 65535U) {
#line 1171
    goto no_flash_data;
  } else {

  }
#line 1172
  if ((((unsigned int )fdt->sig[0] != 81U || (unsigned int )fdt->sig[1] != 76U) || (unsigned int )fdt->sig[2] != 73U) || (unsigned int )fdt->sig[3] != 68U) {
#line 1174
    goto no_flash_data;
  } else {

  }
#line 1176
  cnt = 0U;
#line 1176
  chksum = 0U;
#line 1176
  goto ldv_43738;
  ldv_43737: 
#line 1178
  tmp = wptr;
#line 1178
  wptr = wptr + 1;
#line 1178
  chksum = (int )*tmp + (int )chksum;
#line 1177
  cnt = (uint16_t )((int )cnt + 1);
  ldv_43738: ;
#line 1176
  if ((unsigned int )cnt <= 63U) {
#line 1178
    goto ldv_43737;
  } else {

  }

#line 1179
  if ((unsigned int )chksum != 0U) {
#line 1180
    ql_dbg(1073741824U, vha, 76, "Inconsistent FDT detected: checksum=0x%x id=%c version0x%x.\n",
           (int )chksum, (int )fdt->sig[0], (int )fdt->version);
#line 1184
    ql_dump_buffer(1073872896U, vha, 275, (uint8_t *)fdt, 128U);
#line 1186
    goto no_flash_data;
  } else {

  }
#line 1189
  loc = locations[1];
#line 1190
  mid = fdt->man_id;
#line 1191
  fid = fdt->id;
#line 1192
  ha->fdt_wrt_disable = (uint32_t )fdt->wrt_disable_bits;
#line 1193
  ha->fdt_wrt_enable = (uint32_t )fdt->wrt_enable_bits;
#line 1194
  ha->fdt_wrt_sts_reg_cmd = (uint32_t )fdt->wrt_sts_reg_cmd;
#line 1195
  if ((ha->device_type & 262144U) != 0U) {
#line 1196
    ha->fdt_erase_cmd = (uint32_t )fdt->erase_cmd;
  } else {
#line 1198
    ha->fdt_erase_cmd = flash_conf_addr(ha, (uint32_t )((int )fdt->erase_cmd | 768));
  }
#line 1200
  ha->fdt_block_size = fdt->block_size;
#line 1201
  if ((unsigned int )fdt->unprotect_sec_cmd != 0U) {
#line 1202
    ha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, (uint32_t )((int )fdt->unprotect_sec_cmd | 768));
#line 1204
    if ((unsigned int )fdt->protect_sec_cmd != 0U) {
#line 1204
      tmp___0 = flash_conf_addr(ha, (uint32_t )((int )fdt->protect_sec_cmd | 768));
#line 1204
      ha->fdt_protect_sec_cmd = tmp___0;
    } else {
#line 1204
      tmp___1 = flash_conf_addr(ha, 822U);
#line 1204
      ha->fdt_protect_sec_cmd = tmp___1;
    }
  } else {

  }
#line 1208
  goto done;
  no_flash_data: 
#line 1210
  loc = locations[0];
#line 1211
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1212
    ha->fdt_block_size = 65536U;
#line 1213
    goto done;
  } else {

  }
#line 1215
  qla24xx_get_flash_manufacturer(ha, & man_id, & flash_id);
#line 1216
  mid = (uint16_t )man_id;
#line 1217
  fid = (uint16_t )flash_id;
#line 1218
  ha->fdt_wrt_disable = 156U;
#line 1219
  ha->fdt_erase_cmd = flash_conf_addr(ha, 984U);
#line 1220
  switch ((int )man_id) {
  case 191: ;
#line 1222
  if ((unsigned int )flash_id == 142U) {
#line 1223
    ha->fdt_block_size = 65536U;
  } else {
#line 1225
    ha->fdt_block_size = 32768U;
  }
#line 1227
  if ((unsigned int )flash_id == 128U) {
#line 1228
    ha->fdt_erase_cmd = flash_conf_addr(ha, 850U);
  } else {

  }
#line 1229
  goto ldv_43742;
  case 19: 
#line 1231
  ha->fdt_block_size = 65536U;
#line 1232
  goto ldv_43742;
  case 31: 
#line 1234
  ha->fdt_block_size = 4096U;
#line 1235
  ha->fdt_erase_cmd = flash_conf_addr(ha, 800U);
#line 1236
  ha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 825U);
#line 1237
  ha->fdt_protect_sec_cmd = flash_conf_addr(ha, 822U);
#line 1238
  goto ldv_43742;
  default: 
#line 1241
  ha->fdt_block_size = 65536U;
#line 1242
  goto ldv_43742;
  }
  ldv_43742: ;
  done: 
#line 1245
  ql_dbg(1073741824U, vha, 77, "FDT[%s]: (0x%x/0x%x) erase=0x%x pr=%x wrtd=0x%x blk=0x%x.\n",
         loc, (int )mid, (int )fid, ha->fdt_erase_cmd, ha->fdt_protect_sec_cmd, ha->fdt_wrt_disable,
         ha->fdt_block_size);
#line 1251
  return;
}
}
#line 1255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2xxx_get_idc_param(scsi_qla_host_t *vha ) 
{ 
  uint32_t *wptr ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  uint32_t *tmp ;

  {
#line 1259
  ha = vha->hw;
#line 1260
  req = *(ha->req_q_map);
#line 1262
  if ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) {
#line 1263
    return;
  } else {

  }
#line 1265
  wptr = (uint32_t *)req->ring;
#line 1266
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)req->ring, 4098140U, 8U);
#line 1269
  if (*wptr == 4294967295U) {
#line 1270
    ha->fcoe_dev_init_timeout = 30U;
#line 1271
    ha->fcoe_reset_timeout = 10U;
  } else {
#line 1273
    tmp = wptr;
#line 1273
    wptr = wptr + 1;
#line 1273
    ha->fcoe_dev_init_timeout = *tmp;
#line 1274
    ha->fcoe_reset_timeout = *wptr;
  }
#line 1276
  ql_dbg(1073741824U, vha, 78, "fcoe_dev_init_timeout=%d fcoe_reset_timeout=%d.\n",
         ha->fcoe_dev_init_timeout, ha->fcoe_reset_timeout);
#line 1280
  return;
}
}
#line 1284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2xxx_get_flash_info(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  uint32_t flt_addr ;
  struct qla_hw_data *ha ;

  {
#line 1288
  ha = vha->hw;
#line 1290
  if (((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) {
#line 1292
    return (0);
  } else {

  }
#line 1294
  ret = qla2xxx_find_flt_start(vha, & flt_addr);
#line 1295
  if (ret != 0) {
#line 1296
    return (ret);
  } else {

  }
#line 1298
  qla2xxx_get_flt_info(vha, flt_addr);
#line 1299
  qla2xxx_get_fdt_info(vha);
#line 1300
  qla2xxx_get_idc_param(vha);
#line 1302
  return (0);
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void qla2xxx_flash_npiv_conf(scsi_qla_host_t *vha ) 
{ 
  void *data ;
  uint16_t *wptr ;
  uint16_t cnt ;
  uint16_t chksum ;
  int i ;
  struct qla_npiv_header hdr ;
  struct qla_npiv_entry *entry ;
  struct qla_hw_data *ha ;
  uint16_t *tmp ;
  uint16_t flags ;
  struct fc_vport_identifiers vid ;
  struct fc_vport *vport ;
  size_t __len ;
  void *__ret ;

  {
#line 1315
  ha = vha->hw;
#line 1317
  if (((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((((ha->device_type & 8192U) == 0U && (ha->device_type & 16384U) == 0U) && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U)) && (ha->device_type & 32768U) == 0U) {
#line 1319
    return;
  } else {

  }
#line 1321
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1322
    return;
  } else {

  }
#line 1324
  if ((ha->device_type & 262144U) != 0U) {
#line 1325
    return;
  } else {

  }
#line 1327
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)(& hdr), ha->flt_region_npiv_conf << 2,
                                  16U);
#line 1329
  if ((unsigned int )hdr.version == 65535U) {
#line 1330
    return;
  } else {

  }
#line 1331
  if ((unsigned int )hdr.version != 1U) {
#line 1332
    ql_dbg(8388608U, vha, 28816, "Unsupported NPIV-Config detected: version=0x%x entries=0x%x checksum=0x%x.\n",
           (int )hdr.version, (int )hdr.entries, (int )hdr.checksum);
#line 1337
    return;
  } else {

  }
#line 1340
  data = kmalloc(16384UL, 208U);
#line 1341
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1342
    ql_log(1U, vha, 28817, "Unable to allocate memory for data.\n");
#line 1344
    return;
  } else {

  }
#line 1347
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)data, ha->flt_region_npiv_conf << 2,
                                  16384U);
#line 1350
  cnt = (uint16_t )(((unsigned long )hdr.entries * 24UL + 16UL) >> 1);
#line 1352
  wptr = (uint16_t *)data;
#line 1352
  chksum = 0U;
#line 1352
  goto ldv_43770;
  ldv_43769: 
#line 1353
  tmp = wptr;
#line 1353
  wptr = wptr + 1;
#line 1353
  chksum = (int )*tmp + (int )chksum;
#line 1352
  cnt = (uint16_t )((int )cnt - 1);
  ldv_43770: ;
#line 1352
  if ((unsigned int )cnt != 0U) {
#line 1354
    goto ldv_43769;
  } else {

  }

#line 1354
  if ((unsigned int )chksum != 0U) {
#line 1355
    ql_dbg(8388608U, vha, 28818, "Inconsistent NPIV-Config detected: version=0x%x entries=0x%x checksum=0x%x.\n",
           (int )hdr.version, (int )hdr.entries, (int )hdr.checksum);
#line 1360
    goto done;
  } else {

  }
#line 1363
  entry = (struct qla_npiv_entry *)data + 16U;
#line 1364
  cnt = hdr.entries;
#line 1365
  i = 0;
#line 1365
  goto ldv_43781;
  ldv_43780: 
#line 1370
  __len = 24UL;
#line 1370
  if (__len > 63UL) {
#line 1370
    __ret = __memcpy((void *)ha->npiv_info + (unsigned long )i, (void const   *)entry,
                     __len);
  } else {
#line 1370
    __ret = __builtin_memcpy((void *)ha->npiv_info + (unsigned long )i, (void const   *)entry,
                             __len);
  }
#line 1372
  flags = entry->flags;
#line 1373
  if ((unsigned int )flags == 65535U) {
#line 1374
    goto ldv_43779;
  } else {

  }
#line 1375
  if (((int )flags & 1) == 0) {
#line 1376
    goto ldv_43779;
  } else {

  }
#line 1378
  memset((void *)(& vid), 0, 96UL);
#line 1379
  vid.roles = 2U;
#line 1380
  vid.vport_type = 7;
#line 1381
  vid.disable = 0;
#line 1382
  vid.port_name = wwn_to_u64((u8 *)(& entry->port_name));
#line 1383
  vid.node_name = wwn_to_u64((u8 *)(& entry->node_name));
#line 1385
  ql_dbg(8388608U, vha, 28819, "NPIV[%02x]: wwpn=%llx wwnn=%llx vf_id=0x%x Q_qos=0x%x F_qos=0x%x.\n",
         (int )cnt, vid.port_name, vid.node_name, (int )entry->vf_id, (int )entry->q_qos,
         (int )entry->f_qos);
#line 1393
  if (i <= 31) {
#line 1394
    vport = fc_vport_create(vha->host, 0, & vid);
#line 1395
    if ((unsigned long )vport == (unsigned long )((struct fc_vport *)0)) {
#line 1396
      ql_log(1U, vha, 28820, "NPIV-Config Failed to create vport [%02x]: wwpn=%llx wwnn=%llx.\n",
             (int )cnt, vid.port_name, vid.node_name);
    } else {

    }
  } else {

  }
  ldv_43779: 
#line 1365
  cnt = (uint16_t )((int )cnt - 1);
#line 1365
  entry = entry + 1;
#line 1365
  i = i + 1;
  ldv_43781: ;
#line 1365
  if ((unsigned int )cnt != 0U) {
#line 1367
    goto ldv_43780;
  } else {

  }

  done: 
#line 1404
  kfree((void const   *)data);
#line 1405
  return;
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla24xx_unprotect_flash(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  unsigned int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 1410
  ha = vha->hw;
#line 1411
  reg = & (ha->iobase)->isp24;
#line 1413
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1414
    tmp = qla81xx_fac_do_write_enable(vha, 1);
#line 1414
    return (tmp);
  } else {

  }
#line 1417
  tmp___0 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1417
  writel(tmp___0 | 2U, (void volatile   *)(& reg->ctrl_status));
#line 1419
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1421
  if (ha->fdt_wrt_disable == 0U) {
#line 1422
    goto done;
  } else {

  }
#line 1425
  tmp___1 = flash_conf_addr(ha, 257U);
#line 1425
  qla24xx_write_flash_dword(ha, tmp___1, 0U);
#line 1427
  tmp___2 = flash_conf_addr(ha, 257U);
#line 1427
  qla24xx_write_flash_dword(ha, tmp___2, 0U);
  done: ;
#line 1429
  return (0);
}
}
#line 1433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla24xx_protect_flash(scsi_qla_host_t *vha ) 
{ 
  uint32_t cnt ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1436
  ha = vha->hw;
#line 1437
  reg = & (ha->iobase)->isp24;
#line 1439
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1440
    tmp = qla81xx_fac_do_write_enable(vha, 0);
#line 1440
    return (tmp);
  } else {

  }
#line 1442
  if (ha->fdt_wrt_disable == 0U) {
#line 1443
    goto skip_wrt_protect;
  } else {

  }
#line 1446
  tmp___0 = flash_conf_addr(ha, 257U);
#line 1446
  qla24xx_write_flash_dword(ha, tmp___0, ha->fdt_wrt_disable);
#line 1448
  cnt = 300U;
#line 1448
  goto ldv_43797;
  ldv_43796: 
#line 1451
  __const_udelay(42950UL);
#line 1450
  cnt = cnt - 1U;
  ldv_43797: ;
#line 1448
  if (cnt != 0U) {
#line 1448
    tmp___1 = flash_conf_addr(ha, 5U);
#line 1448
    tmp___2 = qla24xx_read_flash_dword(ha, tmp___1);
#line 1448
    if ((int )tmp___2 & 1) {
#line 1450
      goto ldv_43796;
    } else {
#line 1453
      goto ldv_43798;
    }
  } else {

  }
  ldv_43798: ;
  skip_wrt_protect: 
#line 1456
  tmp___3 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1456
  writel(tmp___3 & 4294967293U, (void volatile   *)(& reg->ctrl_status));
#line 1458
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1460
  return (0);
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla24xx_erase_sector(scsi_qla_host_t *vha , uint32_t fdata ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t start ;
  uint32_t finish ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1466
  ha = vha->hw;
#line 1469
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1470
    start = fdata >> 2;
#line 1471
    finish = ((ha->fdt_block_size >> 2) + start) - 1U;
#line 1472
    tmp = flash_data_addr(ha, finish);
#line 1472
    tmp___0 = flash_data_addr(ha, start);
#line 1472
    tmp___1 = qla81xx_fac_erase_sector(vha, tmp___0, tmp);
#line 1472
    return (tmp___1);
  } else {

  }
#line 1476
  tmp___2 = qla24xx_write_flash_dword(ha, ha->fdt_erase_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
#line 1476
  return (tmp___2);
}
}
#line 1482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla24xx_write_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr , uint32_t faddr ,
                                    uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  uint32_t fdata ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1490
  optrom = (void *)0;
#line 1491
  ha = vha->hw;
#line 1494
  if (((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && (faddr & 4095U) == 0U) && dwords > 1024U) {
#line 1496
    optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 1498
    if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 1499
      ql_log(1U, vha, 28821, "Unable to allocate memory for optrom burst write (%x KB).\n",
             4);
    } else {

    }
  } else {

  }
#line 1506
  rest_addr = (ha->fdt_block_size >> 2) - 1U;
#line 1507
  sec_mask = ~ rest_addr;
#line 1509
  ret = qla24xx_unprotect_flash(vha);
#line 1510
  if (ret != 0) {
#line 1511
    ql_log(1U, vha, 28822, "Unable to unprotect flash for update.\n");
#line 1513
    goto done;
  } else {

  }
#line 1516
  liter = 0U;
#line 1516
  goto ldv_43827;
  ldv_43826: 
#line 1517
  fdata = (faddr & sec_mask) << 2;
#line 1520
  if ((faddr & rest_addr) == 0U) {
#line 1522
    if (ha->fdt_unprotect_sec_cmd != 0U) {
#line 1523
      qla24xx_write_flash_dword(ha, ha->fdt_unprotect_sec_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
    } else {

    }
#line 1527
    ret = qla24xx_erase_sector(vha, fdata);
#line 1528
    if (ret != 0) {
#line 1529
      ql_dbg(8388608U, vha, 28679, "Unable to erase erase sector: address=%x.\n",
             faddr);
#line 1532
      goto ldv_43821;
    } else {

    }
  } else {

  }
#line 1537
  if ((unsigned long )optrom != (unsigned long )((void *)0) && liter + 1024U <= dwords) {
#line 1539
    __len = 4096UL;
#line 1539
    if (__len > 63UL) {
#line 1539
      __ret = __memcpy(optrom, (void const   *)dwptr, __len);
    } else {
#line 1539
      __ret = __builtin_memcpy(optrom, (void const   *)dwptr, __len);
    }
#line 1541
    tmp = flash_data_addr(ha, faddr);
#line 1541
    ret = qla2x00_load_ram(vha, optrom_dma, tmp, 1024U);
#line 1544
    if (ret != 0) {
#line 1545
      tmp___0 = flash_data_addr(ha, faddr);
#line 1545
      ql_log(1U, vha, 28823, "Unable to burst-write optrom segment (%x/%x/%llx).\n",
             ret, tmp___0, optrom_dma);
#line 1550
      ql_log(1U, vha, 28824, "Reverting to slow-write.\n");
#line 1553
      dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 1555
      optrom = (void *)0;
    } else {
#line 1557
      liter = liter + 1023U;
#line 1558
      faddr = faddr + 1023U;
#line 1559
      dwptr = dwptr + 1023UL;
#line 1560
      goto ldv_43825;
    }
  } else {

  }
#line 1564
  tmp___1 = flash_data_addr(ha, faddr);
#line 1564
  ret = qla24xx_write_flash_dword(ha, tmp___1, *dwptr);
#line 1566
  if (ret != 0) {
#line 1567
    ql_dbg(8388608U, vha, 28678, "Unable to program flash address=%x data=%x.\n",
           faddr, *dwptr);
#line 1570
    goto ldv_43821;
  } else {

  }
#line 1574
  if (ha->fdt_unprotect_sec_cmd != 0U && (faddr & rest_addr) == rest_addr) {
#line 1576
    qla24xx_write_flash_dword(ha, ha->fdt_protect_sec_cmd, ((fdata & 65280U) | ((fdata << 16) & 16711680U)) | ((fdata >> 16) & 255U));
  } else {

  }
  ldv_43825: 
#line 1516
  liter = liter + 1U;
#line 1516
  faddr = faddr + 1U;
#line 1516
  dwptr = dwptr + 1;
  ldv_43827: ;
#line 1516
  if (liter < dwords) {
#line 1518
    goto ldv_43826;
  } else {

  }
  ldv_43821: 
#line 1582
  ret = qla24xx_protect_flash(vha);
#line 1583
  if (ret != 0) {
#line 1584
    ql_log(1U, vha, 28825, "Unable to protect flash after update.\n");
  } else {

  }
  done: ;
#line 1587
  if ((unsigned long )optrom != (unsigned long )((void *)0)) {
#line 1588
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
  } else {

  }
#line 1591
  return (ret);
}
}
#line 1595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;

  {
#line 1600
  ha = vha->hw;
#line 1603
  wptr = (uint16_t *)buf;
#line 1604
  qla2x00_lock_nvram_access(ha);
#line 1605
  i = 0U;
#line 1605
  goto ldv_43838;
  ldv_43837: 
#line 1606
  *(wptr + (unsigned long )i) = qla2x00_get_nvram_word(ha, naddr);
#line 1605
  i = i + 1U;
#line 1605
  naddr = naddr + 1U;
  ldv_43838: ;
#line 1605
  if (bytes >> 1 > i) {
#line 1607
    goto ldv_43837;
  } else {

  }
#line 1608
  qla2x00_unlock_nvram_access(ha);
#line 1610
  return (buf);
}
}
#line 1614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 1619
  ha = vha->hw;
#line 1621
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1622
    return (buf);
  } else {

  }
#line 1625
  dwptr = (uint32_t *)buf;
#line 1626
  i = 0U;
#line 1626
  goto ldv_43850;
  ldv_43849: 
#line 1627
  tmp = nvram_data_addr(ha, naddr);
#line 1627
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 1626
  i = i + 1U;
#line 1626
  naddr = naddr + 1U;
  ldv_43850: ;
#line 1626
  if (bytes >> 2 > i) {
#line 1628
    goto ldv_43849;
  } else {

  }

#line 1630
  return (buf);
}
}
#line 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2x00_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  int ret ;
  int stat ;
  uint32_t i ;
  uint16_t *wptr ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;

  {
#line 1641
  ha = vha->hw;
#line 1643
  ret = 0;
#line 1645
  tmp = spinlock_check(& ha->hardware_lock);
#line 1645
  flags = _raw_spin_lock_irqsave(tmp);
#line 1646
  qla2x00_lock_nvram_access(ha);
#line 1649
  stat = qla2x00_clear_nvram_protection(ha);
#line 1651
  wptr = (uint16_t *)buf;
#line 1652
  i = 0U;
#line 1652
  goto ldv_43868;
  ldv_43867: 
#line 1653
  qla2x00_write_nvram_word(ha, naddr, (int )*wptr);
#line 1655
  wptr = wptr + 1;
#line 1652
  i = i + 1U;
#line 1652
  naddr = naddr + 1U;
  ldv_43868: ;
#line 1652
  if (bytes >> 1 > i) {
#line 1654
    goto ldv_43867;
  } else {

  }
#line 1659
  qla2x00_set_nvram_protection(ha, stat);
#line 1661
  qla2x00_unlock_nvram_access(ha);
#line 1662
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1664
  return (ret);
}
}
#line 1668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  int ret ;
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1674
  ha = vha->hw;
#line 1675
  reg = & (ha->iobase)->isp24;
#line 1677
  ret = 0;
#line 1679
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1680
    return (ret);
  } else {

  }
#line 1683
  tmp = readl((void const volatile   *)(& reg->ctrl_status));
#line 1683
  writel(tmp | 2U, (void volatile   *)(& reg->ctrl_status));
#line 1685
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1688
  tmp___0 = nvram_conf_addr(ha, 257U);
#line 1688
  qla24xx_write_flash_dword(ha, tmp___0, 0U);
#line 1689
  tmp___1 = nvram_conf_addr(ha, 257U);
#line 1689
  qla24xx_write_flash_dword(ha, tmp___1, 0U);
#line 1692
  dwptr = (uint32_t *)buf;
#line 1693
  i = 0U;
#line 1693
  goto ldv_43883;
  ldv_43882: 
#line 1694
  tmp___2 = nvram_data_addr(ha, naddr);
#line 1694
  ret = qla24xx_write_flash_dword(ha, tmp___2, *dwptr);
#line 1696
  if (ret != 0) {
#line 1697
    ql_dbg(8388608U, vha, 28826, "Unable to program nvram address=%x data=%x.\n",
           naddr, *dwptr);
#line 1700
    goto ldv_43881;
  } else {

  }
#line 1693
  i = i + 1U;
#line 1693
  naddr = naddr + 1U;
#line 1693
  dwptr = dwptr + 1;
  ldv_43883: ;
#line 1693
  if (bytes >> 2 > i) {
#line 1695
    goto ldv_43882;
  } else {

  }
  ldv_43881: 
#line 1705
  tmp___3 = nvram_conf_addr(ha, 257U);
#line 1705
  qla24xx_write_flash_dword(ha, tmp___3, 140U);
#line 1708
  tmp___4 = readl((void const volatile   *)(& reg->ctrl_status));
#line 1708
  writel(tmp___4 & 4294967293U, (void volatile   *)(& reg->ctrl_status));
#line 1710
  readl((void const volatile   *)(& reg->ctrl_status));
#line 1712
  return (ret);
}
}
#line 1716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                                 uint32_t bytes ) 
{ 
  uint32_t i ;
  uint32_t *dwptr ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 1721
  ha = vha->hw;
#line 1724
  dwptr = (uint32_t *)buf;
#line 1725
  i = 0U;
#line 1725
  goto ldv_43894;
  ldv_43893: 
#line 1726
  tmp = flash_data_addr(ha, ha->flt_region_vpd_nvram | naddr);
#line 1726
  *(dwptr + (unsigned long )i) = qla24xx_read_flash_dword(ha, tmp);
#line 1725
  i = i + 1U;
#line 1725
  naddr = naddr + 1U;
  ldv_43894: ;
#line 1725
  if (bytes >> 2 > i) {
#line 1727
    goto ldv_43893;
  } else {

  }

#line 1729
  return (buf);
}
}
#line 1733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla25xx_write_nvram_data(scsi_qla_host_t *vha , uint8_t *buf , uint32_t naddr ,
                             uint32_t bytes ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t *dbuf ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1736
  ha = vha->hw;
#line 1740
  tmp = vmalloc(65536UL);
#line 1740
  dbuf = (uint8_t *)tmp;
#line 1741
  if ((unsigned long )dbuf == (unsigned long )((uint8_t *)0U)) {
#line 1742
    return (259);
  } else {

  }
#line 1743
  (*((ha->isp_ops)->read_optrom))(vha, dbuf, ha->flt_region_vpd_nvram << 2, 65536U);
#line 1745
  __len = (size_t )bytes;
#line 1745
  __ret = __builtin_memcpy((void *)dbuf + (unsigned long )(naddr << 2), (void const   *)buf,
                           __len);
#line 1746
  (*((ha->isp_ops)->write_optrom))(vha, dbuf, ha->flt_region_vpd_nvram << 2, 65536U);
#line 1748
  vfree((void const   *)dbuf);
#line 1750
  return (0);
}
}
#line 1754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static void qla2x00_flip_colors(struct qla_hw_data *ha , uint16_t *pflags ) 
{ 


  {
#line 1756
  if ((ha->device_type & 16U) != 0U) {
#line 1758
    if ((unsigned int )ha->beacon_color_state == 7U) {
#line 1760
      ha->beacon_color_state = 0U;
#line 1761
      *pflags = 0U;
    } else {
#line 1764
      ha->beacon_color_state = 7U;
#line 1765
      *pflags = 193U;
    }
  } else
#line 1769
  if ((unsigned int )ha->beacon_color_state == 1U) {
#line 1771
    ha->beacon_color_state = 0U;
#line 1772
    *pflags = 0U;
  } else {
#line 1775
    ha->beacon_color_state = 1U;
#line 1776
    *pflags = 64U;
  }
#line 1778
  return;
}
}
#line 1784 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void qla2x00_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint16_t gpio_enable ;
  uint16_t gpio_data ;
  uint16_t led_color ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1788
  led_color = 0U;
#line 1790
  ha = vha->hw;
#line 1791
  reg = & (ha->iobase)->isp;
#line 1793
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1794
    return;
  } else {

  }
#line 1796
  tmp = spinlock_check(& ha->hardware_lock);
#line 1796
  flags = _raw_spin_lock_irqsave(tmp);
#line 1799
  if (ha->pio_address != 0ULL) {
#line 1800
    gpio_enable = inw((int )((unsigned int )ha->pio_address + 206U));
#line 1801
    gpio_data = inw((int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1803
    gpio_enable = readw((void const volatile   *)(& reg->gpioe));
#line 1804
    gpio_data = readw((void const volatile   *)(& reg->gpiod));
  }
#line 1808
  gpio_enable = (uint16_t )((unsigned int )gpio_enable | 192U);
#line 1810
  if (ha->pio_address != 0ULL) {
#line 1811
    outw((int )gpio_enable, (int )((unsigned int )ha->pio_address + 206U));
  } else {
#line 1813
    writew((int )gpio_enable, (void volatile   *)(& reg->gpioe));
#line 1814
    readw((void const volatile   *)(& reg->gpioe));
  }
#line 1817
  qla2x00_flip_colors(ha, & led_color);
#line 1820
  gpio_data = (unsigned int )gpio_data & 65343U;
#line 1823
  gpio_data = (uint16_t )((int )gpio_data | (int )led_color);
#line 1826
  if (ha->pio_address != 0ULL) {
#line 1827
    outw((int )gpio_data, (int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1829
    writew((int )gpio_data, (void volatile   *)(& reg->gpiod));
#line 1830
    readw((void const volatile   *)(& reg->gpiod));
  }
#line 1833
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1834
  return;
}
}
#line 1837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2x00_beacon_on(struct scsi_qla_host *vha ) 
{ 
  uint16_t gpio_enable ;
  uint16_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1842
  ha = vha->hw;
#line 1843
  reg = & (ha->iobase)->isp;
#line 1845
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 1846
  ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 64U);
#line 1848
  tmp = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1848
  if (tmp != 0) {
#line 1849
    ql_log(1U, vha, 28827, "Unable to update fw options (beacon on).\n");
#line 1851
    return (258);
  } else {

  }
#line 1855
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1855
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1856
  if (ha->pio_address != 0ULL) {
#line 1857
    gpio_enable = inw((int )((unsigned int )ha->pio_address + 206U));
#line 1858
    gpio_data = inw((int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1860
    gpio_enable = readw((void const volatile   *)(& reg->gpioe));
#line 1861
    gpio_data = readw((void const volatile   *)(& reg->gpiod));
  }
#line 1863
  gpio_enable = (uint16_t )((unsigned int )gpio_enable | 192U);
#line 1866
  if (ha->pio_address != 0ULL) {
#line 1867
    outw((int )gpio_enable, (int )((unsigned int )ha->pio_address + 206U));
  } else {
#line 1869
    writew((int )gpio_enable, (void volatile   *)(& reg->gpioe));
#line 1870
    readw((void const volatile   *)(& reg->gpioe));
  }
#line 1874
  gpio_data = (unsigned int )gpio_data & 65343U;
#line 1875
  if (ha->pio_address != 0ULL) {
#line 1876
    outw((int )gpio_data, (int )((unsigned int )ha->pio_address + 204U));
  } else {
#line 1878
    writew((int )gpio_data, (void volatile   *)(& reg->gpiod));
#line 1879
    readw((void const volatile   *)(& reg->gpiod));
  }
#line 1881
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1887
  ha->beacon_blink_led = 1U;
#line 1888
  ha->beacon_color_state = 0U;
#line 1890
  return (0);
}
}
#line 1894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2x00_beacon_off(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 1896
  rval = 0;
#line 1897
  ha = vha->hw;
#line 1899
  ha->beacon_blink_led = 0U;
#line 1902
  if ((ha->device_type & 16U) != 0U) {
#line 1903
    ha->beacon_color_state = 7U;
  } else {
#line 1905
    ha->beacon_color_state = 1U;
  }
#line 1907
  (*((ha->isp_ops)->beacon_blink))(vha);
#line 1909
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65279U;
#line 1910
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65471U;
#line 1912
  rval = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 1913
  if (rval != 0) {
#line 1914
    ql_log(1U, vha, 28828, "Unable to update fw options (beacon off).\n");
  } else {

  }
#line 1916
  return (rval);
}
}
#line 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static void qla24xx_flip_colors(struct qla_hw_data *ha , uint16_t *pflags ) 
{ 


  {
#line 1924
  if ((unsigned int )ha->beacon_color_state == 7U) {
#line 1926
    ha->beacon_color_state = 0U;
#line 1927
    *pflags = 0U;
  } else {
#line 1930
    ha->beacon_color_state = 7U;
#line 1931
    *pflags = 20U;
  }
#line 1933
  return;
}
}
#line 1936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void qla24xx_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint16_t led_color ;
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;

  {
#line 1938
  led_color = 0U;
#line 1941
  ha = vha->hw;
#line 1942
  reg = & (ha->iobase)->isp24;
#line 1945
  tmp = spinlock_check(& ha->hardware_lock);
#line 1945
  flags = _raw_spin_lock_irqsave(tmp);
#line 1946
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1949
  gpio_data = gpio_data | 1835008U;
#line 1951
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1952
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1955
  qla24xx_flip_colors(ha, & led_color);
#line 1958
  gpio_data = gpio_data & 4294967267U;
#line 1961
  gpio_data = (uint32_t )led_color | gpio_data;
#line 1964
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 1965
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 1966
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1967
  return;
}
}
#line 1970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static uint32_t qla83xx_select_led_port(struct qla_hw_data *ha ) 
{ 
  uint32_t led_select_value ;

  {
#line 1972
  led_select_value = 0U;
#line 1974
  if ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1975
    goto out;
  } else {

  }
#line 1977
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1978
    led_select_value = 2102048U;
  } else {
#line 1980
    led_select_value = 2102056U;
  }
  out: ;
#line 1983
  return (led_select_value);
}
}
#line 1987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void qla83xx_beacon_blink(struct scsi_qla_host *vha ) 
{ 
  uint32_t led_select_value ;
  struct qla_hw_data *ha ;
  uint16_t led_cfg[6U] ;
  uint16_t orig_led_cfg[6U] ;
  uint32_t led_10_value ;
  uint32_t led_43_value ;
  int rval ;

  {
#line 1990
  ha = vha->hw;
#line 1995
  if (((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 8192U) == 0U) {
#line 1996
    return;
  } else {

  }
#line 1998
  if ((unsigned int )ha->beacon_blink_led == 0U) {
#line 1999
    return;
  } else {

  }
#line 2001
  if ((ha->device_type & 32768U) != 0U) {
#line 2002
    led_select_value = qla83xx_select_led_port(ha);
#line 2004
    qla83xx_wr_reg(vha, led_select_value, 1073750016U);
#line 2005
    qla83xx_wr_reg(vha, led_select_value + 4U, 1073750016U);
#line 2006
    msleep(1000U);
#line 2007
    qla83xx_wr_reg(vha, led_select_value, 1073758208U);
#line 2008
    qla83xx_wr_reg(vha, led_select_value + 4U, 1073758208U);
  } else
#line 2009
  if ((ha->device_type & 65536U) != 0U) {
#line 2010
    led_select_value = qla83xx_select_led_port(ha);
#line 2012
    qla83xx_rd_reg(vha, led_select_value, & led_10_value);
#line 2013
    qla83xx_rd_reg(vha, led_select_value + 16U, & led_43_value);
#line 2014
    qla83xx_wr_reg(vha, led_select_value, 32784384U);
#line 2015
    msleep(500U);
#line 2016
    qla83xx_wr_reg(vha, led_select_value, 1073742324U);
#line 2017
    msleep(1000U);
#line 2018
    qla83xx_wr_reg(vha, led_select_value, led_10_value);
#line 2019
    qla83xx_wr_reg(vha, led_select_value + 16U, led_43_value);
  } else
#line 2020
  if ((ha->device_type & 8192U) != 0U) {
#line 2024
    rval = qla81xx_get_led_config(vha, (uint16_t *)(& orig_led_cfg));
#line 2026
    if (rval == 0) {
#line 2027
      if ((ha->device_type & 8192U) != 0U) {
#line 2028
        led_cfg[0] = 16384U;
#line 2029
        led_cfg[1] = 8192U;
#line 2030
        led_cfg[2] = 0U;
#line 2031
        led_cfg[3] = 0U;
#line 2032
        led_cfg[4] = 0U;
#line 2033
        led_cfg[5] = 0U;
      } else {
#line 2035
        led_cfg[0] = 16384U;
#line 2036
        led_cfg[1] = 16384U;
#line 2037
        led_cfg[2] = 16384U;
#line 2038
        led_cfg[3] = 8192U;
#line 2039
        led_cfg[4] = 0U;
#line 2040
        led_cfg[5] = 8192U;
      }
#line 2042
      rval = qla81xx_set_led_config(vha, (uint16_t *)(& led_cfg));
#line 2043
      msleep(1000U);
#line 2044
      if ((ha->device_type & 8192U) != 0U) {
#line 2045
        led_cfg[0] = 16384U;
#line 2046
        led_cfg[1] = 8192U;
#line 2047
        led_cfg[2] = 0U;
      } else {
#line 2049
        led_cfg[0] = 16384U;
#line 2050
        led_cfg[1] = 8192U;
#line 2051
        led_cfg[2] = 16384U;
#line 2052
        led_cfg[3] = 16384U;
#line 2053
        led_cfg[4] = 0U;
#line 2054
        led_cfg[5] = 8192U;
      }
#line 2056
      rval = qla81xx_set_led_config(vha, (uint16_t *)(& led_cfg));
    } else {

    }
#line 2059
    qla81xx_set_led_config(vha, (uint16_t *)(& orig_led_cfg));
  } else {

  }
#line 2061
  return;
}
}
#line 2064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_beacon_on(struct scsi_qla_host *vha ) 
{ 
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 2068
  ha = vha->hw;
#line 2069
  reg = & (ha->iobase)->isp24;
#line 2071
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2072
    return (0);
  } else {

  }
#line 2074
  if ((ha->device_type & 65536U) != 0U || (ha->device_type & 8192U) != 0U) {
#line 2075
    goto skip_gpio;
  } else {

  }
#line 2077
  if ((unsigned int )ha->beacon_blink_led == 0U) {
#line 2079
    ha->fw_options[1] = (uint16_t )((unsigned int )ha->fw_options[1] | 64U);
#line 2081
    tmp = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2081
    if (tmp != 0) {
#line 2082
      return (258);
    } else {

    }
#line 2084
    tmp___0 = qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2084
    if (tmp___0 != 0) {
#line 2086
      ql_log(1U, vha, 28681, "Unable to update fw options (beacon on).\n");
#line 2088
      return (258);
    } else {

    }
#line 2091
    if ((ha->device_type & 32768U) != 0U) {
#line 2092
      goto skip_gpio;
    } else {

    }
#line 2094
    tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2094
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 2095
    gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 2098
    gpio_data = gpio_data | 1835008U;
#line 2099
    writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 2100
    readl((void const volatile   *)(& reg->gpiod));
#line 2102
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 2106
  ha->beacon_color_state = 0U;
  skip_gpio: 
#line 2110
  ha->beacon_blink_led = 1U;
#line 2112
  return (0);
}
}
#line 2116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_beacon_off(struct scsi_qla_host *vha ) 
{ 
  uint32_t gpio_data ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_24xx *reg ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2120
  ha = vha->hw;
#line 2121
  reg = & (ha->iobase)->isp24;
#line 2123
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 2124
    return (0);
  } else {

  }
#line 2126
  ha->beacon_blink_led = 0U;
#line 2128
  if ((ha->device_type & 32768U) != 0U) {
#line 2129
    goto set_fw_options;
  } else {

  }
#line 2131
  if ((ha->device_type & 65536U) != 0U || (ha->device_type & 8192U) != 0U) {
#line 2132
    return (0);
  } else {

  }
#line 2134
  ha->beacon_color_state = 7U;
#line 2136
  (*((ha->isp_ops)->beacon_blink))(vha);
#line 2139
  tmp = spinlock_check(& ha->hardware_lock);
#line 2139
  flags = _raw_spin_lock_irqsave(tmp);
#line 2140
  gpio_data = readl((void const volatile   *)(& reg->gpiod));
#line 2143
  gpio_data = gpio_data & 4293132287U;
#line 2144
  writel(gpio_data, (void volatile   *)(& reg->gpiod));
#line 2145
  readl((void const volatile   *)(& reg->gpiod));
#line 2146
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
  set_fw_options: 
#line 2149
  ha->fw_options[1] = (unsigned int )ha->fw_options[1] & 65471U;
#line 2151
  tmp___0 = qla2x00_set_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2151
  if (tmp___0 != 0) {
#line 2152
    ql_log(1U, vha, 28749, "Unable to update fw options (beacon on).\n");
#line 2154
    return (258);
  } else {

  }
#line 2157
  tmp___1 = qla2x00_get_fw_options(vha, (uint16_t *)(& ha->fw_options));
#line 2157
  if (tmp___1 != 0) {
#line 2158
    ql_log(1U, vha, 28750, "Unable to update fw options (beacon on).\n");
#line 2160
    return (258);
  } else {

  }
#line 2163
  return (0);
}
}
#line 2176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_flash_enable(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 2179
  reg = & (ha->iobase)->isp;
#line 2181
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 2182
  data = (uint16_t )((unsigned int )data | 2U);
#line 2183
  writew((int )data, (void volatile   *)(& reg->ctrl_status));
#line 2184
  readw((void const volatile   *)(& reg->ctrl_status));
#line 2185
  return;
}
}
#line 2192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_flash_disable(struct qla_hw_data *ha ) 
{ 
  uint16_t data ;
  struct device_reg_2xxx *reg ;

  {
#line 2195
  reg = & (ha->iobase)->isp;
#line 2197
  data = readw((void const volatile   *)(& reg->ctrl_status));
#line 2198
  data = (unsigned int )data & 65533U;
#line 2199
  writew((int )data, (void volatile   *)(& reg->ctrl_status));
#line 2200
  readw((void const volatile   *)(& reg->ctrl_status));
#line 2201
  return;
}
}
#line 2213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static uint8_t qla2x00_read_flash_byte(struct qla_hw_data *ha , uint32_t addr ) 
{ 
  uint16_t data ;
  uint16_t bank_select ;
  struct device_reg_2xxx *reg ;
  uint16_t data2 ;

  {
#line 2217
  reg = & (ha->iobase)->isp;
#line 2219
  bank_select = readw((void const volatile   *)(& reg->ctrl_status));
#line 2221
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2224
    bank_select = (unsigned int )bank_select & 65287U;
#line 2225
    bank_select = ((unsigned int )((uint16_t )(addr >> 12)) & 240U) | (unsigned int )bank_select;
#line 2226
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2227
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2228
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2230
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2231
    data = readw((void const volatile   *)(& reg->flash_data));
#line 2233
    return ((uint8_t )data);
  } else {

  }
#line 2237
  if ((addr & 65536U) != 0U && ((int )bank_select & 8) == 0) {
#line 2238
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2239
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2240
    readw((void const volatile   *)(& reg->ctrl_status));
  } else
#line 2241
  if ((addr & 65536U) == 0U && ((int )bank_select & 8) != 0) {
#line 2243
    bank_select = (unsigned int )bank_select & 65527U;
#line 2244
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2245
    readw((void const volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 2249
  if (ha->pio_address != 0ULL) {
#line 2252
    outw((int )((unsigned short )addr), (int )ha->pio_address);
    ldv_44009: 
#line 2254
    data = inw((int )((unsigned int )ha->pio_address + 2U));
#line 2255
    __asm__  volatile   ("": : : "memory");
#line 2256
    cpu_relax();
#line 2257
    data2 = inw((int )((unsigned int )ha->pio_address + 2U));
#line 2258
    if ((int )data != (int )data2) {
#line 2260
      goto ldv_44009;
    } else {

    }

  } else {
#line 2260
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2261
    data = qla2x00_debounce_register___0((uint16_t volatile   *)(& reg->flash_data));
  }
#line 2264
  return ((uint8_t )data);
}
}
#line 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_write_flash_byte(struct qla_hw_data *ha , uint32_t addr , uint8_t data ) 
{ 
  uint16_t bank_select ;
  struct device_reg_2xxx *reg ;

  {
#line 2277
  reg = & (ha->iobase)->isp;
#line 2279
  bank_select = readw((void const volatile   *)(& reg->ctrl_status));
#line 2280
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2283
    bank_select = (unsigned int )bank_select & 65287U;
#line 2284
    bank_select = ((unsigned int )((uint16_t )(addr >> 12)) & 240U) | (unsigned int )bank_select;
#line 2285
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2286
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2287
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2289
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2290
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2291
    writew((int )data, (void volatile   *)(& reg->flash_data));
#line 2292
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2294
    return;
  } else {

  }
#line 2298
  if ((addr & 65536U) != 0U && ((int )bank_select & 8) == 0) {
#line 2299
    bank_select = (uint16_t )((unsigned int )bank_select | 8U);
#line 2300
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2301
    readw((void const volatile   *)(& reg->ctrl_status));
  } else
#line 2302
  if ((addr & 65536U) == 0U && ((int )bank_select & 8) != 0) {
#line 2304
    bank_select = (unsigned int )bank_select & 65527U;
#line 2305
    writew((int )bank_select, (void volatile   *)(& reg->ctrl_status));
#line 2306
    readw((void const volatile   *)(& reg->ctrl_status));
  } else {

  }
#line 2310
  if (ha->pio_address != 0ULL) {
#line 2311
    outw((int )((unsigned short )addr), (int )ha->pio_address);
#line 2312
    outw((int )data, (int )((unsigned int )ha->pio_address + 2U));
  } else {
#line 2314
    writew((int )((unsigned short )addr), (void volatile   *)(& reg->flash_address));
#line 2315
    readw((void const volatile   *)(& reg->ctrl_status));
#line 2316
    writew((int )data, (void volatile   *)(& reg->flash_data));
#line 2317
    readw((void const volatile   *)(& reg->ctrl_status));
  }
#line 2319
  return;
}
}
#line 2337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_poll_flash(struct qla_hw_data *ha , uint32_t addr , uint8_t poll_data ,
                              uint8_t man_id , uint8_t flash_id ) 
{ 
  int status ;
  uint8_t flash_data ;
  uint32_t cnt ;

  {
#line 2344
  status = 1;
#line 2347
  poll_data = (unsigned int )poll_data & 128U;
#line 2348
  cnt = 3000000U;
#line 2348
  goto ldv_44031;
  ldv_44030: 
#line 2349
  flash_data = qla2x00_read_flash_byte(ha, addr);
#line 2350
  if (((int )flash_data & 128) == (int )poll_data) {
#line 2351
    status = 0;
#line 2352
    goto ldv_44028;
  } else {

  }
#line 2355
  if ((unsigned int )man_id != 64U && (unsigned int )man_id != 218U) {
#line 2356
    if (((int )flash_data & 32) != 0 && cnt > 2U) {
#line 2357
      cnt = 2U;
    } else {

    }
  } else {

  }
#line 2359
  __const_udelay(42950UL);
#line 2360
  __asm__  volatile   ("": : : "memory");
#line 2361
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared",
                2361, 0);
#line 2361
  _cond_resched();
#line 2348
  cnt = cnt - 1U;
  ldv_44031: ;
#line 2348
  if (cnt != 0U) {
#line 2350
    goto ldv_44030;
  } else {

  }
  ldv_44028: ;
#line 2363
  return (status);
}
}
#line 2377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_program_flash_address(struct qla_hw_data *ha , uint32_t addr ,
                                         uint8_t data , uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2381
  if ((ha->device_type & 536870912U) != 0U) {
#line 2382
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2383
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2384
    qla2x00_write_flash_byte(ha, 2730U, 160);
#line 2385
    qla2x00_write_flash_byte(ha, addr, (int )data);
  } else
#line 2387
  if ((unsigned int )man_id == 218U && (unsigned int )flash_id == 193U) {
#line 2388
    qla2x00_write_flash_byte(ha, addr, (int )data);
#line 2389
    if ((addr & 126U) != 0U) {
#line 2390
      return (0);
    } else {

    }
  } else {
#line 2392
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2393
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2394
    qla2x00_write_flash_byte(ha, 21845U, 160);
#line 2395
    qla2x00_write_flash_byte(ha, addr, (int )data);
  }
#line 2399
  __const_udelay(644250UL);
#line 2402
  tmp = qla2x00_poll_flash(ha, addr, (int )data, (int )man_id, (int )flash_id);
#line 2402
  return (tmp);
}
}
#line 2414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_erase_flash(struct qla_hw_data *ha , uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2417
  if ((ha->device_type & 536870912U) != 0U) {
#line 2418
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2419
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2420
    qla2x00_write_flash_byte(ha, 2730U, 128);
#line 2421
    qla2x00_write_flash_byte(ha, 2730U, 170);
#line 2422
    qla2x00_write_flash_byte(ha, 1365U, 85);
#line 2423
    qla2x00_write_flash_byte(ha, 2730U, 16);
  } else {
#line 2425
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2426
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2427
    qla2x00_write_flash_byte(ha, 21845U, 128);
#line 2428
    qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2429
    qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2430
    qla2x00_write_flash_byte(ha, 21845U, 16);
  }
#line 2433
  __const_udelay(644250UL);
#line 2436
  tmp = qla2x00_poll_flash(ha, 0U, 128, (int )man_id, (int )flash_id);
#line 2436
  return (tmp);
}
}
#line 2450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2x00_erase_flash_sector(struct qla_hw_data *ha , uint32_t addr , uint32_t sec_mask ,
                                      uint8_t man_id , uint8_t flash_id ) 
{ 
  int tmp ;

  {
#line 2454
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2455
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2456
  qla2x00_write_flash_byte(ha, 21845U, 128);
#line 2457
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2458
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2459
  if ((unsigned int )man_id == 31U && (unsigned int )flash_id == 19U) {
#line 2460
    qla2x00_write_flash_byte(ha, addr & sec_mask, 16);
  } else {
#line 2462
    qla2x00_write_flash_byte(ha, addr & sec_mask, 48);
  }
#line 2464
  __const_udelay(644250UL);
#line 2467
  tmp = qla2x00_poll_flash(ha, addr, 128, (int )man_id, (int )flash_id);
#line 2467
  return (tmp);
}
}
#line 2476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_get_flash_manufacturer(struct qla_hw_data *ha , uint8_t *man_id ,
                                           uint8_t *flash_id ) 
{ 


  {
#line 2479
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2480
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2481
  qla2x00_write_flash_byte(ha, 21845U, 144);
#line 2482
  *man_id = qla2x00_read_flash_byte(ha, 0U);
#line 2483
  *flash_id = qla2x00_read_flash_byte(ha, 1U);
#line 2484
  qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2485
  qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2486
  qla2x00_write_flash_byte(ha, 21845U, 240);
#line 2487
  return;
}
}
#line 2490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_read_flash_data(struct qla_hw_data *ha , uint8_t *tmp_buf , uint32_t saddr ,
                                    uint32_t length ) 
{ 
  struct device_reg_2xxx *reg ;
  uint32_t midpoint ;
  uint32_t ilength ;
  uint8_t data ;

  {
#line 2493
  reg = & (ha->iobase)->isp;
#line 2497
  midpoint = length / 2U;
#line 2499
  writew(0, (void volatile   *)(& reg->nvram));
#line 2500
  readw((void const volatile   *)(& reg->nvram));
#line 2501
  ilength = 0U;
#line 2501
  goto ldv_44068;
  ldv_44067: ;
#line 2502
  if (ilength == midpoint) {
#line 2503
    writew(2, (void volatile   *)(& reg->nvram));
#line 2504
    readw((void const volatile   *)(& reg->nvram));
  } else {

  }
#line 2506
  data = qla2x00_read_flash_byte(ha, saddr);
#line 2507
  if (saddr % 100U != 0U) {
#line 2508
    __const_udelay(42950UL);
  } else {

  }
#line 2509
  *tmp_buf = data;
#line 2510
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared",
                2510, 0);
#line 2510
  _cond_resched();
#line 2501
  saddr = saddr + 1U;
#line 2501
  ilength = ilength + 1U;
#line 2501
  tmp_buf = tmp_buf + 1;
  ldv_44068: ;
#line 2501
  if (ilength < length) {
#line 2503
    goto ldv_44067;
  } else {

  }

#line 2508
  return;
}
}
#line 2515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static void qla2x00_suspend_hba(struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  raw_spinlock_t *tmp ;
  unsigned short tmp___0 ;

  {
#line 2519
  ha = vha->hw;
#line 2520
  reg = & (ha->iobase)->isp;
#line 2523
  scsi_block_requests(vha->host);
#line 2524
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 2525
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2528
  tmp = spinlock_check(& ha->hardware_lock);
#line 2528
  flags = _raw_spin_lock_irqsave(tmp);
#line 2529
  writew(8192, (void volatile   *)(& reg->hccr));
#line 2530
  readw((void const volatile   *)(& reg->hccr));
#line 2531
  if (((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) || (ha->device_type & 4U) != 0U) {
#line 2532
    cnt = 0;
#line 2532
    goto ldv_44082;
    ldv_44081: 
#line 2533
    tmp___0 = readw((void const volatile   *)(& reg->hccr));
#line 2533
    if (((int )tmp___0 & 32) != 0) {
#line 2534
      goto ldv_44080;
    } else {

    }
#line 2535
    __const_udelay(429500UL);
#line 2532
    cnt = cnt + 1;
    ldv_44082: ;
#line 2532
    if (cnt <= 29999) {
#line 2534
      goto ldv_44081;
    } else {

    }
    ldv_44080: ;
  } else {
#line 2538
    __const_udelay(42950UL);
  }
#line 2540
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2541
  return;
}
}
#line 2544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
__inline static void qla2x00_resume_hba(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2546
  ha = vha->hw;
#line 2549
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2550
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2551
  qla2xxx_wake_dpc(vha);
#line 2552
  qla2x00_wait_for_chip_reset(vha);
#line 2553
  scsi_unblock_requests(vha->host);
#line 2554
  return;
}
}
#line 2557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla2x00_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  uint32_t addr ;
  uint32_t midpoint ;
  uint8_t *data ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;

  {
#line 2562
  ha = vha->hw;
#line 2563
  reg = & (ha->iobase)->isp;
#line 2566
  qla2x00_suspend_hba(vha);
#line 2569
  midpoint = ha->optrom_size / 2U;
#line 2571
  qla2x00_flash_enable(ha);
#line 2572
  writew(0, (void volatile   *)(& reg->nvram));
#line 2573
  readw((void const volatile   *)(& reg->nvram));
#line 2574
  addr = offset;
#line 2574
  data = buf;
#line 2574
  goto ldv_44099;
  ldv_44098: ;
#line 2575
  if (addr == midpoint) {
#line 2576
    writew(2, (void volatile   *)(& reg->nvram));
#line 2577
    readw((void const volatile   *)(& reg->nvram));
  } else {

  }
#line 2580
  *data = qla2x00_read_flash_byte(ha, addr);
#line 2574
  addr = addr + 1U;
#line 2574
  data = data + 1;
  ldv_44099: ;
#line 2574
  if (addr < length) {
#line 2576
    goto ldv_44098;
  } else {

  }
#line 2582
  qla2x00_flash_disable(ha);
#line 2585
  qla2x00_resume_hba(vha);
#line 2587
  return (buf);
}
}
#line 2591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2x00_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  uint8_t man_id ;
  uint8_t flash_id ;
  uint8_t sec_number ;
  uint8_t data ;
  uint16_t wd ;
  uint32_t addr ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  struct qla_hw_data *ha ;
  struct device_reg_2xxx *reg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2599
  ha = vha->hw;
#line 2600
  reg = & (ha->iobase)->isp;
#line 2603
  qla2x00_suspend_hba(vha);
#line 2605
  rval = 0;
#line 2606
  sec_number = 0U;
#line 2609
  writew(1, (void volatile   *)(& reg->ctrl_status));
#line 2610
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & wd);
#line 2613
  qla2x00_flash_enable(ha);
#line 2616
  if ((ha->device_type & 536870912U) != 0U) {
#line 2618
    flash_id = 0U;
#line 2618
    man_id = flash_id;
#line 2619
    rest_addr = 65535U;
#line 2620
    sec_mask = 65536U;
#line 2621
    goto update_flash;
  } else {

  }
#line 2623
  qla2x00_get_flash_manufacturer(ha, & man_id, & flash_id);
#line 2624
  switch ((int )man_id) {
  case 32: ;
#line 2626
  if ((unsigned int )flash_id == 210U || (unsigned int )flash_id == 227U) {
#line 2632
    rest_addr = 65535U;
#line 2633
    sec_mask = 65536U;
#line 2634
    goto ldv_44121;
  } else {

  }
#line 2640
  rest_addr = 16383U;
#line 2641
  sec_mask = 114688U;
#line 2642
  goto ldv_44121;
  case 64: 
#line 2645
  rest_addr = 511U;
#line 2646
  sec_mask = 130560U;
#line 2647
  goto ldv_44121;
  case 191: 
#line 2650
  rest_addr = 4095U;
#line 2651
  sec_mask = 126976U;
#line 2652
  goto ldv_44121;
  case 218: 
#line 2655
  rest_addr = 127U;
#line 2656
  sec_mask = 130944U;
#line 2657
  goto ldv_44121;
  case 194: ;
#line 2660
  if ((unsigned int )flash_id == 56U || (unsigned int )flash_id == 79U) {
#line 2661
    rest_addr = 65535U;
#line 2662
    sec_mask = 65536U;
#line 2663
    goto ldv_44121;
  } else {

  }
  case 31: ;
#line 2669
  if ((unsigned int )flash_id == 19U) {
#line 2670
    rest_addr = 2147483647U;
#line 2671
    sec_mask = 2147483648U;
#line 2672
    goto ldv_44121;
  } else {

  }
  case 1: ;
#line 2677
  if (((unsigned int )flash_id == 56U || (unsigned int )flash_id == 64U) || (unsigned int )flash_id == 79U) {
#line 2681
    rest_addr = 65535U;
#line 2682
    sec_mask = 65536U;
#line 2683
    goto ldv_44121;
  } else
#line 2684
  if ((unsigned int )flash_id == 62U) {
#line 2690
    rest_addr = 65535U;
#line 2691
    sec_mask = 65536U;
#line 2692
    goto ldv_44121;
  } else
#line 2693
  if ((unsigned int )flash_id == 32U || (unsigned int )flash_id == 110U) {
#line 2698
    rest_addr = 16383U;
#line 2699
    sec_mask = 114688U;
#line 2700
    goto ldv_44121;
  } else
#line 2701
  if ((unsigned int )flash_id == 109U) {
#line 2703
    rest_addr = 8191U;
#line 2704
    sec_mask = 122880U;
#line 2705
    goto ldv_44121;
  } else {

  }
  default: 
#line 2709
  rest_addr = 16383U;
#line 2710
  sec_mask = 114688U;
#line 2711
  goto ldv_44121;
  }
  ldv_44121: ;
  update_flash: ;
#line 2715
  if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2716
    tmp = qla2x00_erase_flash(ha, (int )man_id, (int )flash_id);
#line 2716
    if (tmp != 0) {
#line 2717
      rval = 258;
#line 2718
      goto ldv_44129;
    } else {

    }
  } else {

  }
#line 2722
  addr = offset;
#line 2722
  liter = 0U;
#line 2722
  goto ldv_44133;
  ldv_44132: 
#line 2724
  data = *(buf + (unsigned long )liter);
#line 2726
  if ((addr & rest_addr) == 0U) {
#line 2727
    if ((ha->device_type & 16U) != 0U || (ha->device_type & 64U) != 0U) {
#line 2728
      if (addr > 65535U) {
#line 2729
        if (((addr >> 12) & 240U) != 0U && (((unsigned int )man_id == 1U && (unsigned int )flash_id == 62U) || ((unsigned int )man_id == 32U && (unsigned int )flash_id == 210U))) {
#line 2734
          sec_number = (uint8_t )((int )sec_number + 1);
#line 2735
          if ((unsigned int )sec_number == 1U) {
#line 2736
            rest_addr = 32767U;
#line 2738
            sec_mask = 98304U;
          } else
#line 2740
          if ((unsigned int )sec_number == 2U || (unsigned int )sec_number == 3U) {
#line 2743
            rest_addr = 8191U;
#line 2745
            sec_mask = 122880U;
          } else
#line 2747
          if ((unsigned int )sec_number == 4U) {
#line 2749
            rest_addr = 16383U;
#line 2751
            sec_mask = 114688U;
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 2756
    if (ha->optrom_size / 2U == addr) {
#line 2757
      writew(2, (void volatile   *)(& reg->nvram));
#line 2758
      readw((void const volatile   *)(& reg->nvram));
    } else {

    }
#line 2761
    if ((unsigned int )flash_id == 218U && (unsigned int )man_id == 193U) {
#line 2762
      qla2x00_write_flash_byte(ha, 21845U, 170);
#line 2764
      qla2x00_write_flash_byte(ha, 10922U, 85);
#line 2766
      qla2x00_write_flash_byte(ha, 21845U, 160);
    } else
#line 2768
    if ((ha->device_type & 16U) == 0U && (ha->device_type & 64U) == 0U) {
#line 2770
      tmp___0 = qla2x00_erase_flash_sector(ha, addr, sec_mask, (int )man_id, (int )flash_id);
#line 2770
      if (tmp___0 != 0) {
#line 2773
        rval = 258;
#line 2774
        goto ldv_44130;
      } else {

      }
#line 2776
      if ((unsigned int )man_id == 1U && (unsigned int )flash_id == 109U) {
#line 2777
        sec_number = (uint8_t )((int )sec_number + 1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 2781
  if ((unsigned int )man_id == 1U && (unsigned int )flash_id == 109U) {
#line 2782
    if ((unsigned int )sec_number == 1U && rest_addr - 1U == addr) {
#line 2784
      rest_addr = 4095U;
#line 2785
      sec_mask = 126976U;
    } else
#line 2786
    if ((unsigned int )sec_number == 3U && (addr & 32766U) != 0U) {
#line 2787
      rest_addr = 16383U;
#line 2788
      sec_mask = 114688U;
    } else {

    }
  } else {

  }
#line 2792
  tmp___1 = qla2x00_program_flash_address(ha, addr, (int )data, (int )man_id, (int )flash_id);
#line 2792
  if (tmp___1 != 0) {
#line 2794
    rval = 258;
#line 2795
    goto ldv_44130;
  } else {

  }
#line 2797
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared",
                2797, 0);
#line 2797
  _cond_resched();
#line 2722
  liter = liter + 1U;
#line 2722
  addr = addr + 1U;
  ldv_44133: ;
#line 2722
  if (liter < length) {
#line 2724
    goto ldv_44132;
  } else {

  }
  ldv_44130: ;
  ldv_44129: 
#line 2800
  qla2x00_flash_disable(ha);
#line 2803
  qla2x00_resume_hba(vha);
#line 2805
  return (rval);
}
}
#line 2809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla24xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2812
  ha = vha->hw;
#line 2815
  scsi_block_requests(vha->host);
#line 2816
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2819
  qla24xx_read_flash_data(vha, (uint32_t *)buf, offset >> 2, length >> 2);
#line 2822
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2823
  scsi_unblock_requests(vha->host);
#line 2825
  return (buf);
}
}
#line 2829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 2833
  ha = vha->hw;
#line 2836
  scsi_block_requests(vha->host);
#line 2837
  set_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2840
  rval = qla24xx_write_flash_data(vha, (uint32_t *)buf, offset >> 2, length >> 2);
#line 2843
  clear_bit(3L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 2844
  scsi_unblock_requests(vha->host);
#line 2846
  return (rval);
}
}
#line 2850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
uint8_t *qla25xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  int rval ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  uint8_t *pbuf ;
  uint32_t faddr ;
  uint32_t left ;
  uint32_t burst ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  size_t __len ;
  void *__ret ;
  uint8_t *tmp___1 ;

  {
#line 2858
  ha = vha->hw;
#line 2860
  if ((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) {
#line 2861
    goto try_fast;
  } else {

  }
#line 2862
  if ((offset & 4095U) != 0U) {
#line 2863
    goto slow_read;
  } else {

  }
#line 2864
  if (length <= 4095U) {
#line 2865
    goto slow_read;
  } else {

  }
  try_fast: 
#line 2868
  optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 2870
  if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 2871
    ql_log(1U, vha, 204, "Unable to allocate memory for optrom burst read (%x KB).\n",
           4);
#line 2874
    goto slow_read;
  } else {

  }
#line 2877
  pbuf = buf;
#line 2878
  faddr = offset >> 2;
#line 2879
  left = length >> 2;
#line 2880
  burst = 1024U;
#line 2881
  goto ldv_44169;
  ldv_44168: ;
#line 2882
  if (burst > left) {
#line 2883
    burst = left;
  } else {

  }
#line 2885
  tmp = flash_data_addr(ha, faddr);
#line 2885
  rval = qla2x00_dump_ram(vha, optrom_dma, tmp, burst);
#line 2887
  if (rval != 0) {
#line 2888
    tmp___0 = flash_data_addr(ha, faddr);
#line 2888
    ql_log(1U, vha, 245, "Unable to burst-read optrom segment (%x/%x/%llx).\n", rval,
           tmp___0, optrom_dma);
#line 2892
    ql_log(1U, vha, 246, "Reverting to slow-read.\n");
#line 2895
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 2897
    goto slow_read;
  } else {

  }
#line 2900
  __len = (size_t )(burst * 4U);
#line 2900
  __ret = __builtin_memcpy((void *)pbuf, (void const   *)optrom, __len);
#line 2902
  left = left - burst;
#line 2903
  faddr = faddr + burst;
#line 2904
  pbuf = pbuf + (unsigned long )(burst * 4U);
  ldv_44169: ;
#line 2881
  if (left != 0U) {
#line 2883
    goto ldv_44168;
  } else {

  }
#line 2907
  dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 2910
  return (buf);
  slow_read: 
#line 2913
  tmp___1 = qla24xx_read_optrom_data(vha, buf, offset, length);
#line 2913
  return (tmp___1);
}
}
#line 2935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static void qla2x00_get_fcode_version(struct qla_hw_data *ha , uint32_t pcids ) 
{ 
  int ret ;
  uint32_t istart ;
  uint32_t iend ;
  uint32_t iter ;
  uint32_t vend ;
  uint8_t do_next ;
  uint8_t rbyte ;
  uint8_t *vbyte ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t *tmp___5 ;

  {
#line 2937
  ret = 258;
#line 2941
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 2944
  tmp = qla2x00_read_flash_byte(ha, pcids + 11U);
#line 2944
  tmp___0 = qla2x00_read_flash_byte(ha, pcids + 10U);
#line 2944
  istart = (uint32_t )(((int )tmp << 8) | (int )tmp___0) + pcids;
#line 2947
  iend = istart + 256U;
#line 2950
  do_next = 0U;
#line 2951
  iter = istart;
#line 2952
  goto ldv_44184;
  ldv_44183: 
#line 2953
  iter = iter + 1U;
#line 2954
  tmp___3 = qla2x00_read_flash_byte(ha, iter);
#line 2954
  if ((unsigned int )tmp___3 == 47U) {
#line 2955
    tmp___2 = qla2x00_read_flash_byte(ha, iter + 2U);
#line 2955
    if ((unsigned int )tmp___2 == 47U) {
#line 2957
      do_next = (uint8_t )((int )do_next + 1);
    } else {
#line 2958
      tmp___1 = qla2x00_read_flash_byte(ha, iter + 3U);
#line 2958
      if ((unsigned int )tmp___1 == 47U) {
#line 2960
        do_next = (uint8_t )((int )do_next + 1);
      } else {

      }
    }
  } else {

  }
  ldv_44184: ;
#line 2952
  if (iter < iend && (unsigned int )do_next == 0U) {
#line 2954
    goto ldv_44183;
  } else {

  }

#line 2963
  if ((unsigned int )do_next == 0U) {
#line 2964
    goto ldv_44186;
  } else {

  }
#line 2967
  do_next = 0U;
#line 2968
  goto ldv_44188;
  ldv_44187: 
#line 2969
  iter = iter - 1U;
#line 2970
  tmp___4 = qla2x00_read_flash_byte(ha, iter);
#line 2970
  if ((unsigned int )tmp___4 == 32U) {
#line 2971
    do_next = (uint8_t )((int )do_next + 1);
  } else {

  }
  ldv_44188: ;
#line 2968
  if (iter > istart && (unsigned int )do_next == 0U) {
#line 2970
    goto ldv_44187;
  } else {

  }

#line 2973
  if ((unsigned int )do_next == 0U) {
#line 2974
    goto ldv_44186;
  } else {

  }
#line 2980
  vend = iter - 1U;
#line 2981
  do_next = 0U;
#line 2982
  goto ldv_44191;
  ldv_44190: 
#line 2983
  iter = iter - 1U;
#line 2984
  rbyte = qla2x00_read_flash_byte(ha, iter);
#line 2985
  if (((unsigned int )rbyte == 32U || (unsigned int )rbyte == 13U) || (unsigned int )rbyte == 16U) {
#line 2986
    do_next = (uint8_t )((int )do_next + 1);
  } else {

  }
  ldv_44191: ;
#line 2982
  if (iter > istart && (unsigned int )do_next == 0U) {
#line 2984
    goto ldv_44190;
  } else {

  }

#line 2988
  if ((unsigned int )do_next == 0U) {
#line 2989
    goto ldv_44186;
  } else {

  }
#line 2992
  iter = iter + 1U;
#line 2993
  if (vend != iter && vend - iter <= 15U) {
#line 2995
    vbyte = (uint8_t *)(& ha->fcode_revision);
#line 2996
    goto ldv_44194;
    ldv_44193: 
#line 2997
    tmp___5 = vbyte;
#line 2997
    vbyte = vbyte + 1;
#line 2997
    *tmp___5 = qla2x00_read_flash_byte(ha, iter);
#line 2998
    iter = iter + 1U;
    ldv_44194: ;
#line 2996
    if (iter <= vend) {
#line 2998
      goto ldv_44193;
    } else {

    }
#line 3000
    ret = 0;
  } else {

  }
  ldv_44186: ;
#line 3004
  if (ret != 0) {
#line 3005
    memset((void *)(& ha->fcode_revision), 0, 16UL);
  } else {

  }
#line 3006
  return;
}
}
#line 3009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2x00_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint8_t code_type ;
  uint8_t last_image ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint8_t *dbyte ;
  uint16_t *dcode ;
  struct qla_hw_data *ha ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  uint8_t tmp___6 ;
  uint8_t tmp___7 ;
  uint8_t tmp___8 ;
  uint8_t tmp___9 ;

  {
#line 3011
  ret = 0;
#line 3016
  ha = vha->hw;
#line 3018
  if (ha->pio_address == 0ULL || (unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 3019
    return (258);
  } else {

  }
#line 3021
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 3022
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 3023
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 3024
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3026
  qla2x00_flash_enable(ha);
#line 3029
  pcihdr = 0U;
#line 3030
  last_image = 1U;
  ldv_44214: 
#line 3033
  tmp = qla2x00_read_flash_byte(ha, pcihdr);
#line 3033
  if ((unsigned int )tmp != 85U) {
#line 3036
    ql_log(0U, vha, 80, "No matching ROM signature.\n");
#line 3038
    ret = 258;
#line 3039
    goto ldv_44208;
  } else {
#line 3033
    tmp___0 = qla2x00_read_flash_byte(ha, pcihdr + 1U);
#line 3033
    if ((unsigned int )tmp___0 != 170U) {
#line 3036
      ql_log(0U, vha, 80, "No matching ROM signature.\n");
#line 3038
      ret = 258;
#line 3039
      goto ldv_44208;
    } else {

    }
  }
#line 3043
  tmp___1 = qla2x00_read_flash_byte(ha, pcihdr + 25U);
#line 3043
  tmp___2 = qla2x00_read_flash_byte(ha, pcihdr + 24U);
#line 3043
  pcids = (uint32_t )(((int )tmp___1 << 8) | (int )tmp___2) + pcihdr;
#line 3048
  tmp___3 = qla2x00_read_flash_byte(ha, pcids);
#line 3048
  if ((unsigned int )tmp___3 != 80U) {
#line 3053
    ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3055
    ret = 258;
#line 3056
    goto ldv_44208;
  } else {
#line 3048
    tmp___4 = qla2x00_read_flash_byte(ha, pcids + 1U);
#line 3048
    if ((unsigned int )tmp___4 != 67U) {
#line 3053
      ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3055
      ret = 258;
#line 3056
      goto ldv_44208;
    } else {
#line 3048
      tmp___5 = qla2x00_read_flash_byte(ha, pcids + 2U);
#line 3048
      if ((unsigned int )tmp___5 != 73U) {
#line 3053
        ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3055
        ret = 258;
#line 3056
        goto ldv_44208;
      } else {
#line 3048
        tmp___6 = qla2x00_read_flash_byte(ha, pcids + 3U);
#line 3048
        if ((unsigned int )tmp___6 != 82U) {
#line 3053
          ql_log(0U, vha, 81, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3055
          ret = 258;
#line 3056
          goto ldv_44208;
        } else {

        }
      }
    }
  }
#line 3060
  code_type = qla2x00_read_flash_byte(ha, pcids + 20U);
#line 3061
  switch ((int )code_type) {
  case 0: 
#line 3064
  ha->bios_revision[0] = qla2x00_read_flash_byte(ha, pcids + 18U);
#line 3066
  ha->bios_revision[1] = qla2x00_read_flash_byte(ha, pcids + 19U);
#line 3068
  ql_dbg(1073741824U, vha, 82, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 3071
  goto ldv_44210;
  case 1: 
#line 3075
  qla2x00_get_fcode_version(ha, pcids);
#line 3076
  goto ldv_44210;
  case 3: 
#line 3079
  ha->efi_revision[0] = qla2x00_read_flash_byte(ha, pcids + 18U);
#line 3081
  ha->efi_revision[1] = qla2x00_read_flash_byte(ha, pcids + 19U);
#line 3083
  ql_dbg(1073741824U, vha, 83, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 3086
  goto ldv_44210;
  default: 
#line 3088
  ql_log(1U, vha, 84, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 3091
  goto ldv_44210;
  }
  ldv_44210: 
#line 3094
  tmp___7 = qla2x00_read_flash_byte(ha, pcids + 21U);
#line 3094
  last_image = (unsigned int )tmp___7 & 128U;
#line 3097
  tmp___8 = qla2x00_read_flash_byte(ha, pcids + 17U);
#line 3097
  tmp___9 = qla2x00_read_flash_byte(ha, pcids + 16U);
#line 3097
  pcihdr = (uint32_t )((((int )tmp___8 << 8) | (int )tmp___9) * 512) + pcihdr;
#line 3099
  if ((unsigned int )last_image == 0U) {
#line 3101
    goto ldv_44214;
  } else {

  }
  ldv_44208: ;
#line 3101
  if ((ha->device_type & 16U) != 0U) {
#line 3103
    memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3104
    dbyte = (uint8_t *)mbuf;
#line 3105
    memset((void *)dbyte, 0, 8UL);
#line 3106
    dcode = (uint16_t *)dbyte;
#line 3108
    qla2x00_read_flash_data(ha, dbyte, ha->flt_region_fw * 4U + 10U, 8U);
#line 3110
    ql_dbg(1073872896U, vha, 266, "Dumping fw ver from flash:.\n");
#line 3113
    ql_dump_buffer(1073872896U, vha, 267, dbyte, 8U);
#line 3116
    if (((((unsigned int )*dcode == 65535U && (unsigned int )*(dcode + 1UL) == 65535U) && (unsigned int )*(dcode + 2UL) == 65535U) && (unsigned int )*(dcode + 3UL) == 65535U) || ((((unsigned int )*dcode == 0U && (unsigned int )*(dcode + 1UL) == 0U) && (unsigned int )*(dcode + 2UL) == 0U) && (unsigned int )*(dcode + 3UL) == 0U)) {
#line 3120
      ql_log(1U, vha, 87, "Unrecognized fw revision at %x.\n", ha->flt_region_fw * 4U);
    } else {
#line 3125
      ha->fw_revision[0] = (uint32_t )(((int )*dbyte << 16) | (int )*(dbyte + 1UL));
#line 3126
      ha->fw_revision[1] = (uint32_t )(((int )*(dbyte + 2UL) << 16) | (int )*(dbyte + 3UL));
#line 3127
      ha->fw_revision[2] = (uint32_t )(((int )*(dbyte + 4UL) << 16) | (int )*(dbyte + 5UL));
#line 3128
      ql_dbg(1073741824U, vha, 88, "FW Version: %d.%d.%d.\n", ha->fw_revision[0],
             ha->fw_revision[1], ha->fw_revision[2]);
    }
  } else {

  }
#line 3135
  qla2x00_flash_disable(ha);
#line 3137
  return (ret);
}
}
#line 3141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla82xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *bcode ;
  uint8_t code_type ;
  uint8_t last_image ;
  struct qla_hw_data *ha ;

  {
#line 3143
  ret = 0;
#line 3148
  ha = vha->hw;
#line 3150
  if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 3151
    return (258);
  } else {

  }
#line 3153
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 3154
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 3155
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 3156
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3158
  dcode = (uint32_t *)mbuf;
#line 3161
  pcihdr = ha->flt_region_boot << 2;
#line 3162
  last_image = 1U;
  ldv_44233: 
#line 3165
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, pcihdr, 128U);
#line 3167
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3168
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 3170
    ql_log(0U, vha, 340, "No matching ROM signature.\n");
#line 3172
    ret = 258;
#line 3173
    goto ldv_44227;
  } else {

  }
#line 3177
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 3179
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, pcids, 128U);
#line 3181
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3184
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 3187
    ql_log(0U, vha, 341, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3189
    ret = 258;
#line 3190
    goto ldv_44227;
  } else {

  }
#line 3194
  code_type = *(bcode + 20UL);
#line 3195
  switch ((int )code_type) {
  case 0: 
#line 3198
  ha->bios_revision[0] = *(bcode + 18UL);
#line 3199
  ha->bios_revision[1] = *(bcode + 19UL);
#line 3200
  ql_dbg(1073741824U, vha, 342, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1],
         (int )ha->bios_revision[0]);
#line 3203
  goto ldv_44229;
  case 1: 
#line 3206
  ha->fcode_revision[0] = *(bcode + 18UL);
#line 3207
  ha->fcode_revision[1] = *(bcode + 19UL);
#line 3208
  ql_dbg(1073741824U, vha, 343, "Read FCODE %d.%d.\n", (int )ha->fcode_revision[1],
         (int )ha->fcode_revision[0]);
#line 3211
  goto ldv_44229;
  case 3: 
#line 3214
  ha->efi_revision[0] = *(bcode + 18UL);
#line 3215
  ha->efi_revision[1] = *(bcode + 19UL);
#line 3216
  ql_dbg(1073741824U, vha, 344, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 3219
  goto ldv_44229;
  default: 
#line 3221
  ql_log(1U, vha, 345, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 3224
  goto ldv_44229;
  }
  ldv_44229: 
#line 3227
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 3230
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 3231
  if ((unsigned int )last_image == 0U) {
#line 3233
    goto ldv_44233;
  } else {

  }
  ldv_44227: 
#line 3234
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3235
  dcode = (uint32_t *)mbuf;
#line 3236
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, ha->flt_region_fw << 2, 32U);
#line 3238
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3241
  if ((((unsigned int )*bcode == 3U && (unsigned int )*(bcode + 1UL) == 0U) && (unsigned int )*(bcode + 2UL) == 64U) && (unsigned int )*(bcode + 3UL) == 64U) {
#line 3243
    ha->fw_revision[0] = (uint32_t )*(bcode + 4UL);
#line 3244
    ha->fw_revision[1] = (uint32_t )*(bcode + 5UL);
#line 3245
    ha->fw_revision[2] = (uint32_t )*(bcode + 6UL);
#line 3246
    ql_dbg(1073741824U, vha, 339, "Firmware revision %d.%d.%d\n", ha->fw_revision[0],
           ha->fw_revision[1], ha->fw_revision[2]);
  } else {

  }
#line 3252
  return (ret);
}
}
#line 3256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_get_flash_version(scsi_qla_host_t *vha , void *mbuf ) 
{ 
  int ret ;
  uint32_t pcihdr ;
  uint32_t pcids ;
  uint32_t *dcode ;
  uint8_t *bcode ;
  uint8_t code_type ;
  uint8_t last_image ;
  int i ;
  struct qla_hw_data *ha ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 3258
  ret = 0;
#line 3264
  ha = vha->hw;
#line 3266
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 3267
    return (ret);
  } else {

  }
#line 3269
  if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
#line 3270
    return (258);
  } else {

  }
#line 3272
  memset((void *)(& ha->bios_revision), 0, 2UL);
#line 3273
  memset((void *)(& ha->efi_revision), 0, 2UL);
#line 3274
  memset((void *)(& ha->fcode_revision), 0, 16UL);
#line 3275
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3277
  dcode = (uint32_t *)mbuf;
#line 3280
  pcihdr = ha->flt_region_boot << 2;
#line 3281
  last_image = 1U;
  ldv_44253: 
#line 3284
  qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 32U);
#line 3285
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3286
  if ((unsigned int )*bcode != 85U || (unsigned int )*(bcode + 1UL) != 170U) {
#line 3288
    ql_log(0U, vha, 89, "No matching ROM signature.\n");
#line 3290
    ret = 258;
#line 3291
    goto ldv_44247;
  } else {

  }
#line 3295
  pcids = (uint32_t )(((int )*(bcode + 25UL) << 8) | (int )*(bcode + 24UL)) + pcihdr;
#line 3297
  qla24xx_read_flash_data(vha, dcode, pcids >> 2, 32U);
#line 3298
  bcode = (uint8_t *)(mbuf + ((unsigned long )pcihdr & 3UL));
#line 3301
  if ((((unsigned int )*bcode != 80U || (unsigned int )*(bcode + 1UL) != 67U) || (unsigned int )*(bcode + 2UL) != 73U) || (unsigned int )*(bcode + 3UL) != 82U) {
#line 3304
    ql_log(0U, vha, 90, "PCI data struct not found pcir_adr=%x.\n", pcids);
#line 3306
    ret = 258;
#line 3307
    goto ldv_44247;
  } else {

  }
#line 3311
  code_type = *(bcode + 20UL);
#line 3312
  switch ((int )code_type) {
  case 0: 
#line 3315
  ha->bios_revision[0] = *(bcode + 18UL);
#line 3316
  ha->bios_revision[1] = *(bcode + 19UL);
#line 3317
  ql_dbg(1073741824U, vha, 91, "Read BIOS %d.%d.\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 3320
  goto ldv_44249;
  case 1: 
#line 3323
  ha->fcode_revision[0] = *(bcode + 18UL);
#line 3324
  ha->fcode_revision[1] = *(bcode + 19UL);
#line 3325
  ql_dbg(1073741824U, vha, 92, "Read FCODE %d.%d.\n", (int )ha->fcode_revision[1],
         (int )ha->fcode_revision[0]);
#line 3328
  goto ldv_44249;
  case 3: 
#line 3331
  ha->efi_revision[0] = *(bcode + 18UL);
#line 3332
  ha->efi_revision[1] = *(bcode + 19UL);
#line 3333
  ql_dbg(1073741824U, vha, 93, "Read EFI %d.%d.\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 3336
  goto ldv_44249;
  default: 
#line 3338
  ql_log(1U, vha, 94, "Unrecognized code type %x at pcids %x.\n", (int )code_type,
         pcids);
#line 3341
  goto ldv_44249;
  }
  ldv_44249: 
#line 3344
  last_image = (unsigned int )*(bcode + 21UL) & 128U;
#line 3347
  pcihdr = (uint32_t )((((int )*(bcode + 17UL) << 8) | (int )*(bcode + 16UL)) * 512) + pcihdr;
#line 3348
  if ((unsigned int )last_image == 0U) {
#line 3350
    goto ldv_44253;
  } else {

  }
  ldv_44247: 
#line 3351
  memset((void *)(& ha->fw_revision), 0, 16UL);
#line 3352
  dcode = (uint32_t *)mbuf;
#line 3354
  qla24xx_read_flash_data(vha, dcode, ha->flt_region_fw + 4U, 4U);
#line 3355
  i = 0;
#line 3355
  goto ldv_44255;
  ldv_44254: 
#line 3356
  tmp = __fswab32(*(dcode + (unsigned long )i));
#line 3356
  *(dcode + (unsigned long )i) = tmp;
#line 3355
  i = i + 1;
  ldv_44255: ;
#line 3355
  if (i <= 3) {
#line 3357
    goto ldv_44254;
  } else {

  }

#line 3358
  if ((((*dcode == 4294967295U && *(dcode + 1UL) == 4294967295U) && *(dcode + 2UL) == 4294967295U) && *(dcode + 3UL) == 4294967295U) || (((*dcode == 0U && *(dcode + 1UL) == 0U) && *(dcode + 2UL) == 0U) && *(dcode + 3UL) == 0U)) {
#line 3362
    ql_log(1U, vha, 95, "Unrecognized fw revision at %x.\n", ha->flt_region_fw * 4U);
  } else {
#line 3366
    ha->fw_revision[0] = *dcode;
#line 3367
    ha->fw_revision[1] = *(dcode + 1UL);
#line 3368
    ha->fw_revision[2] = *(dcode + 2UL);
#line 3369
    ha->fw_revision[3] = *(dcode + 3UL);
#line 3370
    ql_dbg(1073741824U, vha, 96, "Firmware revision %d.%d.%d.%d.\n", ha->fw_revision[0],
           ha->fw_revision[1], ha->fw_revision[2], ha->fw_revision[3]);
  }
#line 3377
  if ((ha->device_type & 8192U) == 0U) {
#line 3379
    return (ret);
  } else {

  }
#line 3382
  memset((void *)(& ha->gold_fw_version), 0, 16UL);
#line 3383
  dcode = (uint32_t *)mbuf;
#line 3384
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)dcode, ha->flt_region_gold_fw << 2,
                                  32U);
#line 3387
  if (((*(dcode + 4UL) == 4294967295U && *(dcode + 5UL) == 4294967295U) && *(dcode + 6UL) == 4294967295U) && *(dcode + 7UL) == 4294967295U) {
#line 3389
    ql_log(1U, vha, 86, "Unrecognized golden fw at 0x%x.\n", ha->flt_region_gold_fw * 4U);
#line 3392
    return (ret);
  } else {

  }
#line 3395
  i = 4;
#line 3395
  goto ldv_44258;
  ldv_44257: 
#line 3396
  tmp___0 = __fswab32(*(dcode + (unsigned long )i));
#line 3396
  ha->gold_fw_version[i + -4] = tmp___0;
#line 3395
  i = i + 1;
  ldv_44258: ;
#line 3395
  if (i <= 7) {
#line 3397
    goto ldv_44257;
  } else {

  }

#line 3398
  return (ret);
}
}
#line 3402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
static int qla2xxx_is_vpd_valid(uint8_t *pos , uint8_t *end ) 
{ 


  {
#line 3404
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 130U) {
#line 3405
    return (0);
  } else {

  }
#line 3407
  pos = pos + (unsigned long )((int )*(pos + 1UL) + 3);
#line 3408
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 144U) {
#line 3409
    return (0);
  } else {

  }
#line 3411
  pos = pos + (unsigned long )((int )*(pos + 1UL) + 3);
#line 3412
  if ((unsigned long )pos >= (unsigned long )end || (unsigned int )*pos != 120U) {
#line 3413
    return (0);
  } else {

  }
#line 3415
  return (1);
}
}
#line 3419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla2xxx_get_vpd_field(scsi_qla_host_t *vha , char *key , char *str , size_t size ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t *pos ;
  uint8_t *end ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3421
  ha = vha->hw;
#line 3422
  pos = (uint8_t *)ha->vpd;
#line 3423
  end = pos + (unsigned long )ha->vpd_size;
#line 3424
  len = 0;
#line 3426
  if ((ha->device_type & 134217728U) == 0U) {
#line 3427
    return (0);
  } else {
#line 3426
    tmp = qla2xxx_is_vpd_valid(pos, end);
#line 3426
    if (tmp == 0) {
#line 3427
      return (0);
    } else {

    }
  }
#line 3429
  goto ldv_44276;
  ldv_44275: 
#line 3430
  len = (unsigned int )*pos == 130U ? (int )*(pos + 1UL) : (int )*(pos + 2UL);
#line 3432
  tmp___0 = strlen((char const   *)key);
#line 3432
  tmp___1 = strncmp((char const   *)pos, (char const   *)key, tmp___0);
#line 3432
  if (tmp___1 == 0) {
#line 3433
    goto ldv_44274;
  } else {

  }
#line 3435
  if ((unsigned int )*pos != 144U && (unsigned int )*pos != 145U) {
#line 3436
    pos = pos + (unsigned long )len;
  } else {

  }
#line 3438
  pos = pos + 3UL;
  ldv_44276: ;
#line 3429
  if ((unsigned long )pos < (unsigned long )end && (unsigned int )*pos != 120U) {
#line 3431
    goto ldv_44275;
  } else {

  }
  ldv_44274: ;
#line 3441
  if ((unsigned long )(end + - ((unsigned long )len)) > (unsigned long )pos && (unsigned int )*pos != 120U) {
#line 3442
    tmp___2 = snprintf(str, size, "%.*s", len, pos + 3UL);
#line 3442
    return (tmp___2);
  } else {

  }
#line 3444
  return (0);
}
}
#line 3448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int qla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha ) 
{ 
  int len ;
  int max_len ;
  uint32_t fcp_prio_addr ;
  struct qla_hw_data *ha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3452
  ha = vha->hw;
#line 3454
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 3455
    tmp = vmalloc(32768UL);
#line 3455
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)tmp;
#line 3456
    if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 3457
      ql_log(1U, vha, 213, "Unable to allocate memory for fcp priorty data (%x).\n",
             32768);
#line 3460
      return (258);
    } else {

    }
  } else {

  }
#line 3463
  memset((void *)ha->fcp_prio_cfg, 0, 32768UL);
#line 3465
  fcp_prio_addr = ha->flt_region_fcp_prio;
#line 3468
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->fcp_prio_cfg, fcp_prio_addr << 2,
                                  16U);
#line 3471
  tmp___0 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 0);
#line 3471
  if (tmp___0 == 0) {
#line 3472
    goto fail;
  } else {

  }
#line 3475
  fcp_prio_addr = fcp_prio_addr + 4U;
#line 3476
  len = (int )(ha->fcp_prio_cfg)->num_entries * 32;
#line 3477
  max_len = 32752;
#line 3479
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)(& (ha->fcp_prio_cfg)->entry), fcp_prio_addr << 2,
                                  (uint32_t )(len < max_len ? len : max_len));
#line 3483
  tmp___1 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1);
#line 3483
  if (tmp___1 == 0) {
#line 3484
    goto fail;
  } else {

  }
#line 3486
  ha->flags.fcp_prio_enabled = 1U;
#line 3487
  return (0);
  fail: 
#line 3489
  vfree((void const   *)ha->fcp_prio_cfg);
#line 3490
  ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)0;
#line 3491
  return (258);
}
}
#line 3495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3495
  if ((unsigned long )ldv_timer_list_9 == (unsigned long )timer) {
#line 3496
    if (ldv_timer_state_9 == 2 || pending_flag != 0) {
#line 3497
      ldv_timer_list_9 = timer;
#line 3498
      ldv_timer_list_9->data = data;
#line 3499
      ldv_timer_state_9 = 1;
    } else {

    }
#line 3501
    return;
  } else {

  }
#line 3503
  reg_timer_9(timer);
#line 3504
  ldv_timer_list_9->data = data;
#line 3505
  return;
}
}
#line 3508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int reg_timer_9(struct timer_list *timer ) 
{ 


  {
#line 3509
  ldv_timer_list_9 = timer;
#line 3510
  ldv_timer_state_9 = 1;
#line 3511
  return (0);
}
}
#line 3514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void choose_timer_9(struct timer_list *timer ) 
{ 


  {
#line 3515
  LDV_IN_INTERRUPT = 2;
#line 3516
  (*(timer->function))(timer->data);
#line 3517
  LDV_IN_INTERRUPT = 1;
#line 3518
  ldv_timer_state_9 = 2;
#line 3519
  return;
}
}
#line 3522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
void disable_suitable_timer_9(struct timer_list *timer ) 
{ 


  {
#line 3523
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_9) {
#line 3524
    ldv_timer_state_9 = 0;
#line 3525
    return;
  } else {

  }
#line 3527
  return;
}
}
#line 3529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int ldv_del_timer_43(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 3533
  tmp = del_timer(ldv_func_arg1);
#line 3533
  ldv_func_res = tmp;
#line 3535
  disable_suitable_timer_7(ldv_func_arg1);
#line 3537
  return (ldv_func_res);
}
}
#line 3540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_sup.o.c.prepared"
int ldv_scsi_add_host_with_dma_44(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 3544
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 3544
  ldv_func_res = tmp;
#line 3546
  if (ldv_func_res == 0) {
#line 3547
    ldv_state_variable_72 = 1;
#line 3547
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 3551
  return (ldv_func_res);
}
}
#line 343 "include/linux/kernel.h"
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 370
extern int sscanf(char const   * , char const   *  , ...) ;
#line 131 "include/linux/string.h"
extern ssize_t memory_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_47(struct timer_list *ldv_func_arg1 ) ;
#line 201 "include/linux/sysfs.h"
extern int sysfs_create_bin_file(struct kobject * , struct bin_attribute  const  * ) ;
#line 203
extern void sysfs_remove_bin_file(struct kobject * , struct bin_attribute  const  * ) ;
#line 19 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern size_t __VERIFIER_nondet_size_t(void) ;
#line 21
extern u32 __VERIFIER_nondet_u32(void) ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int reg_timer_10(struct timer_list *timer ) ;
#line 258
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 273
void disable_suitable_timer_10(struct timer_list *timer ) ;
#line 296
void choose_timer_10(struct timer_list *timer ) ;
#line 211 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 757 "include/scsi/scsi_host.h"
extern int scsi_is_host_device(struct device  const  * ) ;
#line 759 "include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 761
  goto ldv_26897;
  ldv_26896: ;
#line 762
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 763
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 764
  dev = dev->parent;
  ldv_26897: 
#line 761
  tmp = scsi_is_host_device((struct device  const  *)dev);
#line 761
  if (tmp == 0) {
#line 763
    goto ldv_26896;
  } else {

  }
#line 766
  __mptr = (struct device  const  *)dev;
#line 766
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffd38UL);
}
}
#line 786
int ldv_scsi_add_host_with_dma_48(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 790
int ldv_scsi_add_host_with_dma_49(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 797
void ldv_scsi_remove_host_50(struct Scsi_Host *shost ) ;
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___2[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 170 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla24xx_deallocate_vp_id(scsi_qla_host_t *vha ) ;
#line 171
int qla24xx_disable_vp(scsi_qla_host_t *vha ) ;
#line 172
int qla24xx_enable_vp(scsi_qla_host_t *vha ) ;
#line 176
void qla2x00_vp_stop_timer(scsi_qla_host_t *vha ) ;
#line 181
int qla24xx_vport_create_req_sanity_check(struct fc_vport *fc_vport ) ;
#line 182
scsi_qla_host_t *qla24xx_create_vhost(struct fc_vport *fc_vport ) ;
#line 194
int qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha ) ;
#line 570
int qla25xx_delete_req_que(struct scsi_qla_host *vha , struct req_que *req ) ;
#line 605
uint32_t qlafx00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) ;
#line 607
void qlafx00_get_host_speed(struct Scsi_Host *shost ) ;
#line 693
int qla24xx_bsg_request(struct fc_bsg_job *bsg_job ) ;
#line 694
int qla24xx_bsg_timeout(struct fc_bsg_job *bsg_job ) ;
#line 710
void qla82xx_md_prep(scsi_qla_host_t *vha ) ;
#line 711
void qla82xx_set_reset_owner(scsi_qla_host_t *vha ) ;
#line 717
uint32_t qla8044_rd_reg(struct qla_hw_data *ha , ulong addr ) ;
#line 718
void qla8044_wr_reg(struct qla_hw_data *ha , ulong addr , uint32_t val ) ;
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___1(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 154
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 155
  atomic_set(& fcport->state, state);
#line 158
  if (old_state != 0 && old_state != state) {
#line 159
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___2[old_state], port_state_str___2[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 165
  return;
}
}
#line 197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static int qla2x00_reset_active(scsi_qla_host_t *vha ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 199
  tmp = pci_get_drvdata((vha->hw)->pdev);
#line 199
  base_vha = (scsi_qla_host_t *)tmp;
#line 202
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 202
  if (tmp___0 != 0) {
#line 202
    tmp___5 = 1;
  } else {
#line 202
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 202
    if (tmp___1 != 0) {
#line 202
      tmp___5 = 1;
    } else {
#line 202
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 202
      if (tmp___2 != 0) {
#line 202
        tmp___5 = 1;
      } else {
#line 202
        tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 202
        if (tmp___3 != 0) {
#line 202
          tmp___5 = 1;
        } else {
#line 202
          tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 202
          if (tmp___4 != 0) {
#line 202
            tmp___5 = 1;
          } else {
#line 202
            tmp___5 = 0;
          }
        }
      }
    }
  }
#line 202
  return (tmp___5);
}
}
#line 985 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_vport_create(struct scsi_qla_host *vha , struct qla_hw_data *ha ) ;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static int qla24xx_vport_disable(struct fc_vport *fc_vport , bool disable ) ;
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_fw_dump(struct file *filp , struct kobject *kobj ,
                                          struct bin_attribute *bin_attr , char *buf ,
                                          loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 323
  __mptr = (struct kobject  const  *)kobj;
#line 323
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 323
  tmp___0 = shost_priv(tmp);
#line 323
  vha = (struct scsi_qla_host *)tmp___0;
#line 325
  ha = vha->hw;
#line 326
  rval = 0;
#line 328
  if (ha->fw_dump_reading == 0 && ha->mctp_dump_reading == 0) {
#line 329
    return (0L);
  } else {

  }
#line 331
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 332
    if ((loff_t )ha->md_template_size > off) {
#line 333
      tmp___1 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->md_tmplt_hdr,
                                        (size_t )ha->md_template_size);
#line 333
      rval = (int )tmp___1;
#line 335
      return ((ssize_t )rval);
    } else {

    }
#line 337
    off = off - (loff_t )ha->md_template_size;
#line 338
    tmp___2 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->md_dump,
                                      (size_t )ha->md_dump_size);
#line 338
    rval = (int )tmp___2;
#line 340
    return ((ssize_t )rval);
  } else
#line 341
  if (ha->mctp_dumped != 0 && ha->mctp_dump_reading != 0) {
#line 342
    tmp___3 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->mctp_dump,
                                      548964UL);
#line 342
    return (tmp___3);
  } else
#line 344
  if (ha->fw_dump_reading != 0) {
#line 345
    tmp___4 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->fw_dump,
                                      (size_t )ha->fw_dump_len);
#line 345
    return (tmp___4);
  } else {
#line 348
    return (0L);
  }
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_fw_dump(struct file *filp , struct kobject *kobj ,
                                           struct bin_attribute *bin_attr , char *buf ,
                                           loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int reading ;
  long tmp___1 ;

  {
#line 356
  __mptr = (struct kobject  const  *)kobj;
#line 356
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 356
  tmp___0 = shost_priv(tmp);
#line 356
  vha = (struct scsi_qla_host *)tmp___0;
#line 358
  ha = vha->hw;
#line 361
  if (off != 0LL) {
#line 362
    return (0L);
  } else {

  }
#line 364
  tmp___1 = simple_strtol((char const   *)buf, (char **)0, 10U);
#line 364
  reading = (int )tmp___1;
#line 365
  switch (reading) {
  case 0: ;
#line 367
  if (ha->fw_dump_reading == 0) {
#line 368
    goto ldv_60823;
  } else {

  }
#line 370
  ql_log(2U, vha, 28765, "Firmware dump cleared on (%ld).\n", vha->host_no);
#line 373
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 374
    qla82xx_md_free(vha);
#line 375
    qla82xx_md_prep(vha);
  } else {

  }
#line 377
  ha->fw_dump_reading = 0;
#line 378
  ha->fw_dumped = 0;
#line 379
  goto ldv_60823;
  case 1: ;
#line 381
  if (ha->fw_dumped != 0 && ha->fw_dump_reading == 0) {
#line 382
    ha->fw_dump_reading = 1;
#line 384
    ql_log(2U, vha, 28766, "Raw firmware dump ready for read on (%ld).\n", vha->host_no);
  } else {

  }
#line 388
  goto ldv_60823;
  case 2: 
#line 390
  qla2x00_alloc_fw_dump(vha);
#line 391
  goto ldv_60823;
  case 3: ;
#line 393
  if ((ha->device_type & 16384U) != 0U) {
#line 394
    qla82xx_idc_lock(ha);
#line 395
    qla82xx_set_reset_owner(vha);
#line 396
    qla82xx_idc_unlock(ha);
  } else
#line 397
  if ((ha->device_type & 262144U) != 0U) {
#line 398
    qla8044_idc_lock(ha);
#line 399
    qla82xx_set_reset_owner(vha);
#line 400
    qla8044_idc_unlock(ha);
  } else {
#line 402
    qla2x00_system_error(vha);
  }
#line 403
  goto ldv_60823;
  case 4: ;
#line 405
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 406
    if ((unsigned long )ha->md_tmplt_hdr != (unsigned long )((void *)0)) {
#line 407
      ql_dbg(8388608U, vha, 28763, "MiniDump supported with this firmware.\n");
    } else {
#line 410
      ql_dbg(8388608U, vha, 28829, "MiniDump not supported with this firmware.\n");
    }
  } else {

  }
#line 413
  goto ldv_60823;
  case 5: ;
#line 415
  if ((ha->device_type & 16384U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 416
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 417
  goto ldv_60823;
  case 6: ;
#line 419
  if (ha->mctp_dump_reading == 0) {
#line 420
    goto ldv_60823;
  } else {

  }
#line 421
  ql_log(2U, vha, 28865, "MCTP dump cleared on (%ld).\n", vha->host_no);
#line 423
  ha->mctp_dump_reading = 0;
#line 424
  ha->mctp_dumped = 0;
#line 425
  goto ldv_60823;
  case 7: ;
#line 427
  if (ha->mctp_dumped != 0 && ha->mctp_dump_reading == 0) {
#line 428
    ha->mctp_dump_reading = 1;
#line 429
    ql_log(2U, vha, 28866, "Raw mctp dump ready for read on (%ld).\n", vha->host_no);
  } else {

  }
#line 433
  goto ldv_60823;
  }
  ldv_60823: ;
#line 435
  return ((ssize_t )count);
}
}
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_fw_dump_attr  =    {{"fw_dump", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_fw_dump,
    & qla2x00_sysfs_write_fw_dump, 0};
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_nvram(struct file *filp , struct kobject *kobj ,
                                        struct bin_attribute *bin_attr , char *buf ,
                                        loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  bool tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 453
  __mptr = (struct kobject  const  *)kobj;
#line 453
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 453
  tmp___0 = shost_priv(tmp);
#line 453
  vha = (struct scsi_qla_host *)tmp___0;
#line 455
  ha = vha->hw;
#line 457
  tmp___1 = capable(21);
#line 457
  if (tmp___1) {
#line 457
    tmp___2 = 0;
  } else {
#line 457
    tmp___2 = 1;
  }
#line 457
  if (tmp___2) {
#line 458
    return (0L);
  } else {

  }
#line 460
  if ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 461
    (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->nvram, ha->flt_region_nvram << 2,
                                    (uint32_t )ha->nvram_size);
  } else {

  }
#line 463
  tmp___3 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->nvram,
                                    (size_t )ha->nvram_size);
#line 463
  return (tmp___3);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_nvram(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint16_t cnt ;
  bool tmp___1 ;
  int tmp___2 ;
  uint32_t *iter ;
  uint32_t chksum ;
  uint32_t *tmp___3 ;
  uint8_t *iter___0 ;
  uint8_t chksum___0 ;
  uint8_t *tmp___4 ;
  int tmp___5 ;

  {
#line 472
  __mptr = (struct kobject  const  *)kobj;
#line 472
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 472
  tmp___0 = shost_priv(tmp);
#line 472
  vha = (struct scsi_qla_host *)tmp___0;
#line 474
  ha = vha->hw;
#line 477
  tmp___1 = capable(21);
#line 477
  if (tmp___1) {
#line 477
    tmp___2 = 0;
  } else {
#line 477
    tmp___2 = 1;
  }
#line 477
  if (((tmp___2 || off != 0LL) || (size_t )ha->nvram_size != count) || (unsigned long )(ha->isp_ops)->write_nvram == (unsigned long )((int (*)(struct scsi_qla_host * ,
                                                                                                                                               uint8_t * ,
                                                                                                                                               uint32_t  ,
                                                                                                                                               uint32_t  ))0)) {
#line 479
    return (-22L);
  } else {

  }
#line 482
  if ((ha->device_type & 134217728U) != 0U) {
#line 486
    iter = (uint32_t *)buf;
#line 487
    chksum = 0U;
#line 488
    cnt = 0U;
#line 488
    goto ldv_60860;
    ldv_60859: 
#line 489
    tmp___3 = iter;
#line 489
    iter = iter + 1;
#line 489
    chksum = *tmp___3 + chksum;
#line 488
    cnt = (uint16_t )((int )cnt + 1);
    ldv_60860: ;
#line 488
    if ((size_t )cnt < (count >> 2) - 1UL) {
#line 490
      goto ldv_60859;
    } else {

    }
#line 490
    chksum = - chksum;
#line 491
    *iter = chksum;
  } else {
#line 496
    iter___0 = (uint8_t *)buf;
#line 497
    chksum___0 = 0U;
#line 498
    cnt = 0U;
#line 498
    goto ldv_60865;
    ldv_60864: 
#line 499
    tmp___4 = iter___0;
#line 499
    iter___0 = iter___0 + 1;
#line 499
    chksum___0 = (int )*tmp___4 + (int )chksum___0;
#line 498
    cnt = (uint16_t )((int )cnt + 1);
    ldv_60865: ;
#line 498
    if ((size_t )cnt < count - 1UL) {
#line 500
      goto ldv_60864;
    } else {

    }
#line 500
    chksum___0 = - ((int )chksum___0);
#line 501
    *iter___0 = chksum___0;
  }
#line 504
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 504
  if (tmp___5 != 0) {
#line 505
    ql_log(1U, vha, 28767, "HBA not online, failing NVRAM update.\n");
#line 507
    return (-11L);
  } else {

  }
#line 511
  (*((ha->isp_ops)->write_nvram))(vha, (uint8_t *)buf, (uint32_t )ha->nvram_base,
                                  (uint32_t )count);
#line 512
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->nvram, (uint32_t )ha->nvram_base,
                                 (uint32_t )count);
#line 515
  ql_dbg(8388608U, vha, 28768, "Setting ISP_ABORT_NEEDED\n");
#line 518
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 519
  qla2xxx_wake_dpc(vha);
#line 520
  qla2x00_wait_for_chip_reset(vha);
#line 522
  return ((ssize_t )count);
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_nvram_attr  =    {{"nvram", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, 512UL, 0, & qla2x00_sysfs_read_nvram,
    & qla2x00_sysfs_write_nvram, 0};
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_optrom(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  ssize_t tmp___1 ;

  {
#line 540
  __mptr = (struct kobject  const  *)kobj;
#line 540
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 540
  tmp___0 = shost_priv(tmp);
#line 540
  vha = (struct scsi_qla_host *)tmp___0;
#line 542
  ha = vha->hw;
#line 544
  if (ha->optrom_state != 1) {
#line 545
    return (0L);
  } else {

  }
#line 547
  tmp___1 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->optrom_buffer,
                                    (size_t )ha->optrom_region_size);
#line 547
  return (tmp___1);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_optrom(struct file *filp , struct kobject *kobj ,
                                          struct bin_attribute *bin_attr , char *buf ,
                                          loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 556
  __mptr = (struct kobject  const  *)kobj;
#line 556
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 556
  tmp___0 = shost_priv(tmp);
#line 556
  vha = (struct scsi_qla_host *)tmp___0;
#line 558
  ha = vha->hw;
#line 560
  if (ha->optrom_state != 2) {
#line 561
    return (-22L);
  } else {

  }
#line 562
  if ((loff_t )ha->optrom_region_size < off) {
#line 563
    return (-34L);
  } else {

  }
#line 564
  if ((unsigned long long )off + (unsigned long long )count > (unsigned long long )ha->optrom_region_size) {
#line 565
    count = (size_t )((loff_t )ha->optrom_region_size - off);
  } else {

  }
#line 567
  __len = count;
#line 567
  __ret = __builtin_memcpy((void *)ha->optrom_buffer + (unsigned long )off, (void const   *)buf,
                           __len);
#line 569
  return ((ssize_t )count);
}
}
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_optrom_attr  =    {{"optrom", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_optrom,
    & qla2x00_sysfs_write_optrom, 0};
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_optrom_ctl(struct file *filp , struct kobject *kobj ,
                                              struct bin_attribute *bin_attr , char *buf ,
                                              loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint32_t start ;
  uint32_t size ;
  int val ;
  int valid ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
#line 587
  __mptr = (struct kobject  const  *)kobj;
#line 587
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 587
  tmp___0 = shost_priv(tmp);
#line 587
  vha = (struct scsi_qla_host *)tmp___0;
#line 589
  ha = vha->hw;
#line 591
  start = 0U;
#line 592
  size = ha->optrom_size;
#line 595
  if (off != 0LL) {
#line 596
    return (-22L);
  } else {

  }
#line 598
  tmp___1 = pci_channel_offline(ha->pdev);
#line 598
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 598
  if (tmp___2 != 0L) {
#line 599
    return (-11L);
  } else {

  }
#line 601
  tmp___3 = sscanf((char const   *)buf, "%d:%x:%x", & val, & start, & size);
#line 601
  if (tmp___3 <= 0) {
#line 602
    return (-22L);
  } else {

  }
#line 603
  if (ha->optrom_size < start) {
#line 604
    return (-22L);
  } else {

  }
#line 606
  switch (val) {
  case 0: ;
#line 608
  if (ha->optrom_state != 1 && ha->optrom_state != 2) {
#line 610
    return (-22L);
  } else {

  }
#line 612
  ha->optrom_state = 0;
#line 614
  ql_dbg(8388608U, vha, 28769, "Freeing flash region allocation -- 0x%x bytes.\n",
         ha->optrom_region_size);
#line 618
  vfree((void const   *)ha->optrom_buffer);
#line 619
  ha->optrom_buffer = (char *)0;
#line 620
  goto ldv_60913;
  case 1: ;
#line 622
  if (ha->optrom_state != 0) {
#line 623
    return (-22L);
  } else {

  }
#line 625
  ha->optrom_region_start = start;
#line 626
  ha->optrom_region_size = start + size > ha->optrom_size ? ha->optrom_size - start : size;
#line 629
  ha->optrom_state = 1;
#line 630
  tmp___4 = vmalloc((unsigned long )ha->optrom_region_size);
#line 630
  ha->optrom_buffer = (char *)tmp___4;
#line 631
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 632
    ql_log(1U, vha, 28770, "Unable to allocate memory for optrom retrieval (%x).\n",
           ha->optrom_region_size);
#line 636
    ha->optrom_state = 0;
#line 637
    return (-12L);
  } else {

  }
#line 640
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 640
  if (tmp___5 != 0) {
#line 641
    ql_log(1U, vha, 28771, "HBA not online, failing NVRAM update.\n");
#line 643
    return (-11L);
  } else {

  }
#line 646
  ql_dbg(8388608U, vha, 28772, "Reading flash region -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 650
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 651
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                  ha->optrom_region_size);
#line 653
  goto ldv_60913;
  case 2: ;
#line 655
  if (ha->optrom_state != 0) {
#line 656
    return (-22L);
  } else {

  }
#line 678
  valid = 0;
#line 679
  if (ha->optrom_size == 131072U && start == 0U) {
#line 680
    valid = 1;
  } else
#line 681
  if (ha->flt_region_boot * 4U == start || ha->flt_region_fw * 4U == start) {
#line 683
    valid = 1;
  } else
#line 684
  if (((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) {
#line 686
    valid = 1;
  } else {

  }
#line 687
  if (valid == 0) {
#line 688
    ql_log(1U, vha, 28773, "Invalid start region 0x%x/0x%x.\n", start, size);
#line 690
    return (-22L);
  } else {

  }
#line 693
  ha->optrom_region_start = start;
#line 694
  ha->optrom_region_size = start + size > ha->optrom_size ? ha->optrom_size - start : size;
#line 697
  ha->optrom_state = 2;
#line 698
  tmp___6 = vmalloc((unsigned long )ha->optrom_region_size);
#line 698
  ha->optrom_buffer = (char *)tmp___6;
#line 699
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 700
    ql_log(1U, vha, 28774, "Unable to allocate memory for optrom update (%x)\n", ha->optrom_region_size);
#line 704
    ha->optrom_state = 0;
#line 705
    return (-12L);
  } else {

  }
#line 708
  ql_dbg(8388608U, vha, 28775, "Staging flash region write -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 712
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 713
  goto ldv_60913;
  case 3: ;
#line 715
  if (ha->optrom_state != 2) {
#line 716
    return (-22L);
  } else {

  }
#line 718
  tmp___7 = qla2x00_wait_for_hba_online(vha);
#line 718
  if (tmp___7 != 0) {
#line 719
    ql_log(1U, vha, 28776, "HBA not online, failing flash update.\n");
#line 721
    return (-11L);
  } else {

  }
#line 724
  ql_dbg(8388608U, vha, 28777, "Writing flash region -- 0x%x/0x%x.\n", ha->optrom_region_start,
         ha->optrom_region_size);
#line 728
  (*((ha->isp_ops)->write_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                   ha->optrom_region_size);
#line 730
  goto ldv_60913;
  default: ;
#line 732
  return (-22L);
  }
  ldv_60913: ;
#line 734
  return ((ssize_t )count);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_optrom_ctl_attr  =    {{"optrom_ctl", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, 0, & qla2x00_sysfs_write_optrom_ctl, 0};
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_vpd(struct file *filp , struct kobject *kobj , struct bin_attribute *bin_attr ,
                                      char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 751
  __mptr = (struct kobject  const  *)kobj;
#line 751
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 751
  tmp___0 = shost_priv(tmp);
#line 751
  vha = (struct scsi_qla_host *)tmp___0;
#line 753
  ha = vha->hw;
#line 755
  tmp___1 = pci_channel_offline(ha->pdev);
#line 755
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 755
  if (tmp___2 != 0L) {
#line 756
    return (-11L);
  } else {

  }
#line 758
  tmp___3 = capable(21);
#line 758
  if (tmp___3) {
#line 758
    tmp___4 = 0;
  } else {
#line 758
    tmp___4 = 1;
  }
#line 758
  if (tmp___4) {
#line 759
    return (-22L);
  } else {

  }
#line 761
  if ((ha->device_type & 8192U) != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 762
    (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->vpd, ha->flt_region_vpd << 2,
                                    (uint32_t )ha->vpd_size);
  } else {

  }
#line 764
  tmp___5 = memory_read_from_buffer((void *)buf, count, & off, (void const   *)ha->vpd,
                                    (size_t )ha->vpd_size);
#line 764
  return (tmp___5);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_vpd(struct file *filp , struct kobject *kobj ,
                                       struct bin_attribute *bin_attr , char *buf ,
                                       loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint8_t *tmp_data ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 772
  __mptr = (struct kobject  const  *)kobj;
#line 772
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 772
  tmp___0 = shost_priv(tmp);
#line 772
  vha = (struct scsi_qla_host *)tmp___0;
#line 774
  ha = vha->hw;
#line 777
  tmp___1 = pci_channel_offline(ha->pdev);
#line 777
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 777
  if (tmp___2 != 0L) {
#line 778
    return (0L);
  } else {

  }
#line 780
  tmp___3 = capable(21);
#line 780
  if (tmp___3) {
#line 780
    tmp___4 = 0;
  } else {
#line 780
    tmp___4 = 1;
  }
#line 780
  if (((tmp___4 || off != 0LL) || (size_t )ha->vpd_size != count) || (unsigned long )(ha->isp_ops)->write_nvram == (unsigned long )((int (*)(struct scsi_qla_host * ,
                                                                                                                                             uint8_t * ,
                                                                                                                                             uint32_t  ,
                                                                                                                                             uint32_t  ))0)) {
#line 782
    return (0L);
  } else {

  }
#line 784
  tmp___5 = qla2x00_wait_for_hba_online(vha);
#line 784
  if (tmp___5 != 0) {
#line 785
    ql_log(1U, vha, 28778, "HBA not online, failing VPD update.\n");
#line 787
    return (-11L);
  } else {

  }
#line 791
  (*((ha->isp_ops)->write_nvram))(vha, (uint8_t *)buf, (uint32_t )ha->vpd_base, (uint32_t )count);
#line 792
  (*((ha->isp_ops)->read_nvram))(vha, (uint8_t *)ha->vpd, (uint32_t )ha->vpd_base,
                                 (uint32_t )count);
#line 795
  if ((ha->device_type & 134217728U) == 0U) {
#line 796
    return (-22L);
  } else {

  }
#line 798
  tmp___6 = vmalloc(256UL);
#line 798
  tmp_data = (uint8_t *)tmp___6;
#line 799
  if ((unsigned long )tmp_data == (unsigned long )((uint8_t *)0U)) {
#line 800
    ql_log(1U, vha, 28779, "Unable to allocate memory for VPD information update.\n");
#line 802
    return (-12L);
  } else {

  }
#line 804
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)tmp_data);
#line 805
  vfree((void const   *)tmp_data);
#line 807
  return ((ssize_t )count);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_vpd_attr  =    {{"vpd", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qla2x00_sysfs_read_vpd,
    & qla2x00_sysfs_write_vpd, 0};
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_sfp(struct file *filp , struct kobject *kobj , struct bin_attribute *bin_attr ,
                                      char *buf , loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  uint16_t iter ;
  uint16_t addr ;
  uint16_t offset ;
  int rval ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 825
  __mptr = (struct kobject  const  *)kobj;
#line 825
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 825
  tmp___0 = shost_priv(tmp);
#line 825
  vha = (struct scsi_qla_host *)tmp___0;
#line 827
  ha = vha->hw;
#line 831
  tmp___1 = capable(21);
#line 831
  if (tmp___1) {
#line 831
    tmp___2 = 0;
  } else {
#line 831
    tmp___2 = 1;
  }
#line 831
  if ((tmp___2 || off != 0LL) || count != 512UL) {
#line 832
    return (0L);
  } else {

  }
#line 834
  if ((unsigned long )ha->sfp_data != (unsigned long )((void *)0)) {
#line 835
    goto do_read;
  } else {

  }
#line 837
  ha->sfp_data = dma_pool_alloc(ha->s_dma_pool, 208U, & ha->sfp_data_dma);
#line 839
  if ((unsigned long )ha->sfp_data == (unsigned long )((void *)0)) {
#line 840
    ql_log(1U, vha, 28780, "Unable to allocate memory for SFP read-data.\n");
#line 842
    return (0L);
  } else {

  }
  do_read: 
#line 846
  memset(ha->sfp_data, 0, 64UL);
#line 847
  addr = 160U;
#line 848
  iter = 0U;
#line 848
  offset = 0U;
#line 848
  goto ldv_60966;
  ldv_60965: ;
#line 850
  if ((unsigned int )iter == 4U) {
#line 852
    addr = 162U;
#line 853
    offset = 0U;
  } else {

  }
#line 856
  rval = qla2x00_read_sfp(vha, ha->sfp_data_dma, (uint8_t *)ha->sfp_data, (int )addr,
                          (int )offset, 64, 0);
#line 858
  if (rval != 0) {
#line 859
    ql_log(1U, vha, 28781, "Unable to read SFP data (%x/%x/%x).\n", rval, (int )addr,
           (int )offset);
#line 863
    return (-5L);
  } else {

  }
#line 865
  __len = 64UL;
#line 865
  if (__len > 63UL) {
#line 865
    __ret = __memcpy((void *)buf, (void const   *)ha->sfp_data, __len);
  } else {
#line 865
    __ret = __builtin_memcpy((void *)buf, (void const   *)ha->sfp_data, __len);
  }
#line 866
  buf = buf + 64UL;
#line 849
  iter = (uint16_t )((int )iter + 1);
#line 849
  offset = (unsigned int )offset + 64U;
  ldv_60966: ;
#line 848
  if ((unsigned int )iter <= 7U) {
#line 850
    goto ldv_60965;
  } else {

  }

#line 869
  return ((ssize_t )count);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_sfp_attr  =    {{"sfp", 384U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 512UL, 0, & qla2x00_sysfs_read_sfp,
    0, 0};
#line 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_write_reset(struct file *filp , struct kobject *kobj ,
                                         struct bin_attribute *bin_attr , char *buf ,
                                         loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___1 ;
  int type ;
  uint32_t idc_control ;
  uint8_t *tmp_data ;
  long tmp___2 ;
  uint32_t idc_control___0 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 886
  __mptr = (struct kobject  const  *)kobj;
#line 886
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 886
  tmp___0 = shost_priv(tmp);
#line 886
  vha = (struct scsi_qla_host *)tmp___0;
#line 888
  ha = vha->hw;
#line 889
  tmp___1 = pci_get_drvdata(ha->pdev);
#line 889
  base_vha = (struct scsi_qla_host *)tmp___1;
#line 892
  tmp_data = (uint8_t *)0U;
#line 893
  if (off != 0LL) {
#line 894
    return (-22L);
  } else {

  }
#line 896
  tmp___2 = simple_strtol((char const   *)buf, (char **)0, 10U);
#line 896
  type = (int )tmp___2;
#line 897
  switch (type) {
  case 131676: 
#line 899
  ql_log(2U, vha, 28782, "Issuing ISP reset.\n");
#line 902
  scsi_block_requests(vha->host);
#line 903
  if ((ha->device_type & 16384U) != 0U) {
#line 904
    ha->flags.isp82xx_no_md_cap = 1U;
#line 905
    qla82xx_idc_lock(ha);
#line 906
    qla82xx_set_reset_owner(vha);
#line 907
    qla82xx_idc_unlock(ha);
  } else
#line 908
  if ((ha->device_type & 262144U) != 0U) {
#line 909
    qla8044_idc_lock(ha);
#line 910
    idc_control = qla8044_rd_reg(ha, 14224UL);
#line 912
    qla8044_wr_reg(ha, 14224UL, idc_control | 2U);
#line 914
    qla82xx_set_reset_owner(vha);
#line 915
    qla8044_idc_unlock(ha);
  } else {
#line 917
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 918
    qla2xxx_wake_dpc(vha);
  }
#line 920
  qla2x00_wait_for_chip_reset(vha);
#line 921
  scsi_unblock_requests(vha->host);
#line 922
  goto ldv_60986;
  case 131677: ;
#line 924
  if ((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 925
    return (-1L);
  } else {

  }
#line 927
  ql_log(2U, vha, 28783, "Issuing MPI reset.\n");
#line 930
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 933
    qla83xx_idc_lock(vha, 0);
#line 934
    __qla83xx_get_idc_control(vha, & idc_control___0);
#line 935
    idc_control___0 = idc_control___0 | 2U;
#line 936
    __qla83xx_set_idc_control(vha, idc_control___0);
#line 937
    qla83xx_wr_reg(vha, 571483012U, 4U);
#line 939
    qla83xx_idc_audit(vha, 0);
#line 940
    qla83xx_idc_unlock(vha, 0);
#line 941
    goto ldv_60986;
  } else {
#line 944
    qla2x00_wait_for_hba_online(vha);
#line 947
    scsi_block_requests(vha->host);
#line 948
    tmp___3 = qla81xx_restart_mpi_firmware(vha);
#line 948
    if (tmp___3 != 0) {
#line 949
      ql_log(1U, vha, 28784, "MPI reset failed.\n");
    } else {

    }
#line 951
    scsi_unblock_requests(vha->host);
#line 952
    goto ldv_60986;
  }
  case 131678: ;
#line 955
  if (((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U) || (unsigned long )vha != (unsigned long )base_vha) {
#line 956
    ql_log(2U, vha, 28785, "FCoE ctx reset no supported.\n");
#line 958
    return (-1L);
  } else {

  }
#line 961
  ql_log(2U, vha, 28786, "Issuing FCoE ctx reset.\n");
#line 963
  set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 964
  qla2xxx_wake_dpc(vha);
#line 965
  qla2x00_wait_for_fcoe_ctx_reset(vha);
#line 966
  goto ldv_60986;
  case 131679: ;
#line 968
  if ((ha->device_type & 65536U) == 0U) {
#line 969
    return (-1L);
  } else {

  }
#line 970
  ql_log(2U, vha, 28860, "Disabling Reset by IDC control\n");
#line 972
  qla83xx_idc_lock(vha, 0);
#line 973
  __qla83xx_get_idc_control(vha, & idc_control);
#line 974
  idc_control = idc_control | 1U;
#line 975
  __qla83xx_set_idc_control(vha, idc_control);
#line 976
  qla83xx_idc_unlock(vha, 0);
#line 977
  goto ldv_60986;
  case 131680: ;
#line 979
  if ((ha->device_type & 65536U) == 0U) {
#line 980
    return (-1L);
  } else {

  }
#line 981
  ql_log(2U, vha, 28861, "Enabling Reset by IDC control\n");
#line 983
  qla83xx_idc_lock(vha, 0);
#line 984
  __qla83xx_get_idc_control(vha, & idc_control);
#line 985
  idc_control = idc_control & 4294967294U;
#line 986
  __qla83xx_set_idc_control(vha, idc_control);
#line 987
  qla83xx_idc_unlock(vha, 0);
#line 988
  goto ldv_60986;
  case 131681: 
#line 990
  ql_dbg(8388608U, vha, 28896, "Updating cache versions without reset ");
#line 993
  tmp___4 = vmalloc(256UL);
#line 993
  tmp_data = (uint8_t *)tmp___4;
#line 994
  if ((unsigned long )tmp_data == (unsigned long )((uint8_t *)0U)) {
#line 995
    ql_log(1U, vha, 28897, "Unable to allocate memory for VPD information update.\n");
#line 997
    return (-12L);
  } else {

  }
#line 999
  (*((ha->isp_ops)->get_flash_version))(vha, (void *)tmp_data);
#line 1000
  vfree((void const   *)tmp_data);
#line 1001
  goto ldv_60986;
  }
  ldv_60986: ;
#line 1003
  return ((ssize_t )count);
}
}
#line 1006 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_reset_attr  =    {{"reset", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, 0,
    & qla2x00_sysfs_write_reset, 0};
#line 1016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_xgmac_stats(struct file *filp , struct kobject *kobj ,
                                              struct bin_attribute *bin_attr , char *buf ,
                                              loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  uint16_t actual_size ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 1020
  __mptr = (struct kobject  const  *)kobj;
#line 1020
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 1020
  tmp___0 = shost_priv(tmp);
#line 1020
  vha = (struct scsi_qla_host *)tmp___0;
#line 1022
  ha = vha->hw;
#line 1026
  tmp___1 = capable(21);
#line 1026
  if (tmp___1) {
#line 1026
    tmp___2 = 0;
  } else {
#line 1026
    tmp___2 = 1;
  }
#line 1026
  if ((tmp___2 || off != 0LL) || count > 4096UL) {
#line 1027
    return (0L);
  } else {

  }
#line 1029
  if ((unsigned long )ha->xgmac_data != (unsigned long )((void *)0)) {
#line 1030
    goto do_read;
  } else {

  }
#line 1032
  ha->xgmac_data = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & ha->xgmac_data_dma,
                                   208U, (struct dma_attrs *)0);
#line 1034
  if ((unsigned long )ha->xgmac_data == (unsigned long )((void *)0)) {
#line 1035
    ql_log(1U, vha, 28790, "Unable to allocate memory for XGMAC read-data.\n");
#line 1037
    return (0L);
  } else {

  }
  do_read: 
#line 1041
  actual_size = 0U;
#line 1042
  memset(ha->xgmac_data, 0, 4096UL);
#line 1044
  rval = qla2x00_get_xgmac_stats(vha, ha->xgmac_data_dma, 4096, & actual_size);
#line 1046
  if (rval != 0) {
#line 1047
    ql_log(1U, vha, 28791, "Unable to read XGMAC data (%x).\n", rval);
#line 1049
    count = 0UL;
  } else {

  }
#line 1052
  count = count < (size_t )actual_size ? count : (size_t )actual_size;
#line 1053
  __len = count;
#line 1053
  __ret = __builtin_memcpy((void *)buf, (void const   *)ha->xgmac_data, __len);
#line 1055
  return ((ssize_t )count);
}
}
#line 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_xgmac_stats_attr  =    {{"xgmac_stats", 256U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qla2x00_sysfs_read_xgmac_stats, 0, 0};
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_sysfs_read_dcbx_tlv(struct file *filp , struct kobject *kobj ,
                                           struct bin_attribute *bin_attr , char *buf ,
                                           loff_t off , size_t count ) 
{ 
  struct scsi_qla_host *vha ;
  struct kobject  const  *__mptr ;
  struct Scsi_Host *tmp ;
  void *tmp___0 ;
  struct qla_hw_data *ha ;
  int rval ;
  uint16_t actual_size ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 1072
  __mptr = (struct kobject  const  *)kobj;
#line 1072
  tmp = dev_to_shost((struct device *)__mptr + 0xfffffffffffffff0UL);
#line 1072
  tmp___0 = shost_priv(tmp);
#line 1072
  vha = (struct scsi_qla_host *)tmp___0;
#line 1074
  ha = vha->hw;
#line 1078
  tmp___1 = capable(21);
#line 1078
  if (tmp___1) {
#line 1078
    tmp___2 = 0;
  } else {
#line 1078
    tmp___2 = 1;
  }
#line 1078
  if ((tmp___2 || off != 0LL) || count > 4096UL) {
#line 1079
    return (0L);
  } else {

  }
#line 1081
  if ((unsigned long )ha->dcbx_tlv != (unsigned long )((void *)0)) {
#line 1082
    goto do_read;
  } else {

  }
#line 1084
  ha->dcbx_tlv = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & ha->dcbx_tlv_dma, 208U,
                                 (struct dma_attrs *)0);
#line 1086
  if ((unsigned long )ha->dcbx_tlv == (unsigned long )((void *)0)) {
#line 1087
    ql_log(1U, vha, 28792, "Unable to allocate memory for DCBX TLV read-data.\n");
#line 1089
    return (-12L);
  } else {

  }
  do_read: 
#line 1093
  actual_size = 0U;
#line 1094
  memset(ha->dcbx_tlv, 0, 4096UL);
#line 1096
  rval = qla2x00_get_dcbx_params(vha, ha->dcbx_tlv_dma, 4096);
#line 1098
  if (rval != 0) {
#line 1099
    ql_log(1U, vha, 28793, "Unable to read DCBX TLV (%x).\n", rval);
#line 1101
    return (-5L);
  } else {

  }
#line 1104
  __len = count;
#line 1104
  __ret = __builtin_memcpy((void *)buf, (void const   *)ha->dcbx_tlv, __len);
#line 1106
  return ((ssize_t )count);
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct bin_attribute sysfs_dcbx_tlv_attr  =    {{"dcbx_tlv", 256U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qla2x00_sysfs_read_dcbx_tlv, 0, 0};
#line 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct sysfs_entry bin_file_entries[10U]  = 
#line 1122
  {      {(char *)"fw_dump", & sysfs_fw_dump_attr, 0}, 
        {(char *)"nvram", & sysfs_nvram_attr, 0}, 
        {(char *)"optrom", & sysfs_optrom_attr, 0}, 
        {(char *)"optrom_ctl", & sysfs_optrom_ctl_attr, 0}, 
        {(char *)"vpd", & sysfs_vpd_attr, 1}, 
        {(char *)"sfp", & sysfs_sfp_attr, 1}, 
        {(char *)"reset", & sysfs_reset_attr, 0}, 
        {(char *)"xgmac_stats", & sysfs_xgmac_stats_attr, 3}, 
        {(char *)"dcbx_tlv", & sysfs_dcbx_tlv_attr, 3}, 
        {(char *)0, 0, 0}};
#line 1136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void qla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha ) 
{ 
  struct Scsi_Host *host ;
  struct sysfs_entry *iter ;
  int ret ;

  {
#line 1138
  host = vha->host;
#line 1142
  iter = (struct sysfs_entry *)(& bin_file_entries);
#line 1142
  goto ldv_61045;
  ldv_61044: ;
#line 1143
  if (iter->is4GBp_only != 0 && ((vha->hw)->device_type & 134217728U) == 0U) {
#line 1144
    goto ldv_61043;
  } else {

  }
#line 1145
  if (iter->is4GBp_only == 2 && ((vha->hw)->device_type & 2048U) == 0U) {
#line 1146
    goto ldv_61043;
  } else {

  }
#line 1147
  if (iter->is4GBp_only == 3 && (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U)) {
#line 1148
    goto ldv_61043;
  } else {

  }
#line 1150
  ret = sysfs_create_bin_file(& host->shost_gendev.kobj, (struct bin_attribute  const  *)iter->attr);
#line 1152
  if (ret != 0) {
#line 1153
    ql_log(1U, vha, 243, "Unable to create sysfs %s binary attribute (%d).\n", iter->name,
           ret);
  } else {
#line 1157
    ql_dbg(1073741824U, vha, 244, "Successfully created sysfs %s binary attribure.\n",
           iter->name);
  }
  ldv_61043: 
#line 1142
  iter = iter + 1;
  ldv_61045: ;
#line 1142
  if ((unsigned long )iter->name != (unsigned long )((char *)0)) {
#line 1144
    goto ldv_61044;
  } else {

  }

#line 1149
  return;
}
}
#line 1164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void qla2x00_free_sysfs_attr(scsi_qla_host_t *vha ) 
{ 
  struct Scsi_Host *host ;
  struct sysfs_entry *iter ;
  struct qla_hw_data *ha ;

  {
#line 1166
  host = vha->host;
#line 1168
  ha = vha->hw;
#line 1170
  iter = (struct sysfs_entry *)(& bin_file_entries);
#line 1170
  goto ldv_61055;
  ldv_61054: ;
#line 1171
  if (iter->is4GBp_only != 0 && (ha->device_type & 134217728U) == 0U) {
#line 1172
    goto ldv_61053;
  } else {

  }
#line 1173
  if (iter->is4GBp_only == 2 && (ha->device_type & 2048U) == 0U) {
#line 1174
    goto ldv_61053;
  } else {

  }
#line 1175
  if (iter->is4GBp_only == 3 && (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U)) {
#line 1176
    goto ldv_61053;
  } else {

  }
#line 1178
  sysfs_remove_bin_file(& host->shost_gendev.kobj, (struct bin_attribute  const  *)iter->attr);
  ldv_61053: 
#line 1170
  iter = iter + 1;
  ldv_61055: ;
#line 1170
  if ((unsigned long )iter->name != (unsigned long )((char *)0)) {
#line 1172
    goto ldv_61054;
  } else {

  }

#line 1182
  if ((unsigned int )ha->beacon_blink_led == 1U) {
#line 1183
    (*((ha->isp_ops)->beacon_off))(vha);
  } else {

  }
#line 1184
  return;
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_drvr_version_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  int tmp ;

  {
#line 1192
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& qla2x00_version_str));
#line 1192
  return ((ssize_t )tmp);
}
}
#line 1196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  char fw_str[128U] ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1199
  __mptr = (struct device  const  *)dev;
#line 1199
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1199
  vha = (scsi_qla_host_t *)tmp;
#line 1200
  ha = vha->hw;
#line 1203
  tmp___0 = (*((ha->isp_ops)->fw_version_str))(vha, (char *)(& fw_str));
#line 1203
  tmp___1 = snprintf(buf, 4096UL, "%s\n", tmp___0);
#line 1203
  return ((ssize_t )tmp___1);
}
}
#line 1208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_serial_num_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint32_t sn ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1211
  __mptr = (struct device  const  *)dev;
#line 1211
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1211
  vha = (scsi_qla_host_t *)tmp;
#line 1212
  ha = vha->hw;
#line 1215
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1216
    tmp___0 = snprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->mr.serial_num));
#line 1216
    return ((ssize_t )tmp___0);
  } else
#line 1218
  if ((ha->device_type & 134217728U) != 0U) {
#line 1219
    qla2xxx_get_vpd_field(vha, (char *)"SN", buf, 4096UL);
#line 1220
    tmp___1 = snprintf(buf, 4096UL, "%s\n", buf);
#line 1220
    return ((ssize_t )tmp___1);
  } else {

  }
#line 1223
  sn = (uint32_t )(((((int )ha->serial0 & 31) << 16) | ((int )ha->serial2 << 8)) | (int )ha->serial1);
#line 1224
  tmp___2 = snprintf(buf, 4096UL, "%c%05d\n", sn / 100000U + 65U, sn % 100000U);
#line 1224
  return ((ssize_t )tmp___2);
}
}
#line 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_isp_name_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1232
  __mptr = (struct device  const  *)dev;
#line 1232
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1232
  vha = (scsi_qla_host_t *)tmp;
#line 1233
  tmp___0 = snprintf(buf, 4096UL, "ISP%04X\n", (int )((vha->hw)->pdev)->device);
#line 1233
  return ((ssize_t )tmp___0);
}
}
#line 1237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_isp_id_show(struct device *dev , struct device_attribute *attr ,
                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1240
  __mptr = (struct device  const  *)dev;
#line 1240
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1240
  vha = (scsi_qla_host_t *)tmp;
#line 1241
  ha = vha->hw;
#line 1243
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1244
    tmp___0 = snprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->mr.hw_version));
#line 1244
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1247
  tmp___1 = snprintf(buf, 4096UL, "%04x %04x %04x %04x\n", (int )ha->product_id[0],
                     (int )ha->product_id[1], (int )ha->product_id[2], (int )ha->product_id[3]);
#line 1247
  return ((ssize_t )tmp___1);
}
}
#line 1253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_model_name_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1256
  __mptr = (struct device  const  *)dev;
#line 1256
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1256
  vha = (scsi_qla_host_t *)tmp;
#line 1258
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1259
    tmp___0 = snprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->mr.product_name));
#line 1259
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1262
  tmp___1 = snprintf(buf, 4096UL, "%s\n", (uint8_t *)(& (vha->hw)->model_number));
#line 1262
  return ((ssize_t )tmp___1);
}
}
#line 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_model_desc_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1269
  __mptr = (struct device  const  *)dev;
#line 1269
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1269
  vha = (scsi_qla_host_t *)tmp;
#line 1270
  tmp___0 = snprintf(buf, 4096UL, "%s\n", (unsigned long )(& (vha->hw)->model_desc) != (unsigned long )((char (*)[80])0) ? (char *)(& (vha->hw)->model_desc) : (char *)"");
#line 1270
  return ((ssize_t )tmp___0);
}
}
#line 1275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_pci_info_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  char pci_info[30U] ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1278
  __mptr = (struct device  const  *)dev;
#line 1278
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1278
  vha = (scsi_qla_host_t *)tmp;
#line 1281
  tmp___0 = (*(((vha->hw)->isp_ops)->pci_info_str))(vha, (char *)(& pci_info));
#line 1281
  tmp___1 = snprintf(buf, 4096UL, "%s\n", tmp___0);
#line 1281
  return ((ssize_t )tmp___1);
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_link_state_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1289
  __mptr = (struct device  const  *)dev;
#line 1289
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1289
  vha = (scsi_qla_host_t *)tmp;
#line 1290
  ha = vha->hw;
#line 1291
  len = 0;
#line 1293
  tmp___7 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1293
  if (tmp___7 == 2) {
#line 1296
    len = snprintf(buf, 4096UL, "Link Down\n");
  } else {
#line 1293
    tmp___8 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1293
    if (tmp___8 == 6) {
#line 1296
      len = snprintf(buf, 4096UL, "Link Down\n");
    } else
#line 1293
    if ((vha->device_flags & 2U) != 0U) {
#line 1296
      len = snprintf(buf, 4096UL, "Link Down\n");
    } else {
#line 1297
      tmp___5 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1297
      if (tmp___5 != 5) {
#line 1299
        len = snprintf(buf, 4096UL, "Unknown Link State\n");
      } else {
#line 1297
        tmp___6 = qla2x00_reset_active(vha);
#line 1297
        if (tmp___6 != 0) {
#line 1299
          len = snprintf(buf, 4096UL, "Unknown Link State\n");
        } else {
#line 1301
          len = snprintf(buf, 4096UL, "Link Up - ");
#line 1303
          switch ((int )ha->current_topology) {
          case 1: 
#line 1305
          tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                             "Loop\n");
#line 1305
          len = tmp___0 + len;
#line 1306
          goto ldv_61135;
          case 4: 
#line 1308
          tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                             "FL_Port\n");
#line 1308
          len = tmp___1 + len;
#line 1309
          goto ldv_61135;
          case 2: 
#line 1311
          tmp___2 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                             "N_Port to N_Port\n");
#line 1311
          len = tmp___2 + len;
#line 1313
          goto ldv_61135;
          case 8: 
#line 1315
          tmp___3 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                             "F_Port\n");
#line 1315
          len = tmp___3 + len;
#line 1316
          goto ldv_61135;
          default: 
#line 1318
          tmp___4 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len,
                             "Loop\n");
#line 1318
          len = tmp___4 + len;
#line 1319
          goto ldv_61135;
          }
          ldv_61135: ;
        }
      }
    }
  }
#line 1322
  return ((ssize_t )len);
}
}
#line 1326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_zio_show(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1329
  __mptr = (struct device  const  *)dev;
#line 1329
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1329
  vha = (scsi_qla_host_t *)tmp;
#line 1330
  len = 0;
#line 1332
  switch ((int )(vha->hw)->zio_mode) {
  case 6: 
#line 1334
  tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Mode 6\n");
#line 1334
  len = tmp___0 + len;
#line 1335
  goto ldv_61150;
  case 0: 
#line 1337
  tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Disabled\n");
#line 1337
  len = tmp___1 + len;
#line 1338
  goto ldv_61150;
  }
  ldv_61150: ;
#line 1340
  return ((ssize_t )len);
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_zio_store(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int val ;
  uint16_t zio_mode ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1347
  __mptr = (struct device  const  *)dev;
#line 1347
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1347
  vha = (scsi_qla_host_t *)tmp;
#line 1348
  ha = vha->hw;
#line 1349
  val = 0;
#line 1352
  if ((ha->device_type & 268435456U) == 0U) {
#line 1353
    return (-524L);
  } else {

  }
#line 1355
  tmp___0 = sscanf(buf, "%d", & val);
#line 1355
  if (tmp___0 != 1) {
#line 1356
    return (-22L);
  } else {

  }
#line 1358
  if (val != 0) {
#line 1359
    zio_mode = 6U;
  } else {
#line 1361
    zio_mode = 0U;
  }
#line 1364
  if ((unsigned int )zio_mode != 0U || (unsigned int )ha->zio_mode != 0U) {
#line 1365
    ha->zio_mode = zio_mode;
#line 1366
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {

  }
#line 1368
  tmp___1 = strlen(buf);
#line 1368
  return ((ssize_t )tmp___1);
}
}
#line 1372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_zio_timer_show(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1375
  __mptr = (struct device  const  *)dev;
#line 1375
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1375
  vha = (scsi_qla_host_t *)tmp;
#line 1377
  tmp___0 = snprintf(buf, 4096UL, "%d us\n", (int )(vha->hw)->zio_timer * 100);
#line 1377
  return ((ssize_t )tmp___0);
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_zio_timer_store(struct device *dev , struct device_attribute *attr ,
                                       char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int val ;
  uint16_t zio_timer ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1384
  __mptr = (struct device  const  *)dev;
#line 1384
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1384
  vha = (scsi_qla_host_t *)tmp;
#line 1385
  val = 0;
#line 1388
  tmp___0 = sscanf(buf, "%d", & val);
#line 1388
  if (tmp___0 != 1) {
#line 1389
    return (-22L);
  } else {

  }
#line 1390
  if (val > 25500 || val <= 99) {
#line 1391
    return (-34L);
  } else {

  }
#line 1393
  zio_timer = (unsigned short )(val / 100);
#line 1394
  (vha->hw)->zio_timer = zio_timer;
#line 1396
  tmp___1 = strlen(buf);
#line 1396
  return ((ssize_t )tmp___1);
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_beacon_show(struct device *dev , struct device_attribute *attr ,
                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1403
  __mptr = (struct device  const  *)dev;
#line 1403
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1403
  vha = (scsi_qla_host_t *)tmp;
#line 1404
  len = 0;
#line 1406
  if ((unsigned int )(vha->hw)->beacon_blink_led != 0U) {
#line 1407
    tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Enabled\n");
#line 1407
    len = tmp___0 + len;
  } else {
#line 1409
    tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "Disabled\n");
#line 1409
    len = tmp___1 + len;
  }
#line 1410
  return ((ssize_t )len);
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_beacon_store(struct device *dev , struct device_attribute *attr ,
                                    char const   *buf , size_t count ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int val ;
  int rval ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1417
  __mptr = (struct device  const  *)dev;
#line 1417
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1417
  vha = (scsi_qla_host_t *)tmp;
#line 1418
  ha = vha->hw;
#line 1419
  val = 0;
#line 1422
  if ((int )ha->device_type & 1 || (ha->device_type & 2U) != 0U) {
#line 1423
    return (-1L);
  } else {

  }
#line 1425
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1425
  if (tmp___0 != 0) {
#line 1426
    ql_log(1U, vha, 28794, "Abort ISP active -- ignoring beacon request.\n");
#line 1428
    return (-16L);
  } else {

  }
#line 1431
  tmp___1 = sscanf(buf, "%d", & val);
#line 1431
  if (tmp___1 != 1) {
#line 1432
    return (-22L);
  } else {

  }
#line 1434
  if (val != 0) {
#line 1435
    rval = (*((ha->isp_ops)->beacon_on))(vha);
  } else {
#line 1437
    rval = (*((ha->isp_ops)->beacon_off))(vha);
  }
#line 1439
  if (rval != 0) {
#line 1440
    count = 0UL;
  } else {

  }
#line 1442
  return ((ssize_t )count);
}
}
#line 1446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_optrom_bios_version_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1449
  __mptr = (struct device  const  *)dev;
#line 1449
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1449
  vha = (scsi_qla_host_t *)tmp;
#line 1450
  ha = vha->hw;
#line 1451
  tmp___0 = snprintf(buf, 4096UL, "%d.%02d\n", (int )ha->bios_revision[1], (int )ha->bios_revision[0]);
#line 1451
  return ((ssize_t )tmp___0);
}
}
#line 1456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_optrom_efi_version_show(struct device *dev , struct device_attribute *attr ,
                                               char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1459
  __mptr = (struct device  const  *)dev;
#line 1459
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1459
  vha = (scsi_qla_host_t *)tmp;
#line 1460
  ha = vha->hw;
#line 1461
  tmp___0 = snprintf(buf, 4096UL, "%d.%02d\n", (int )ha->efi_revision[1], (int )ha->efi_revision[0]);
#line 1461
  return ((ssize_t )tmp___0);
}
}
#line 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_optrom_fcode_version_show(struct device *dev , struct device_attribute *attr ,
                                                 char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1469
  __mptr = (struct device  const  *)dev;
#line 1469
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1469
  vha = (scsi_qla_host_t *)tmp;
#line 1470
  ha = vha->hw;
#line 1471
  tmp___0 = snprintf(buf, 4096UL, "%d.%02d\n", (int )ha->fcode_revision[1], (int )ha->fcode_revision[0]);
#line 1471
  return ((ssize_t )tmp___0);
}
}
#line 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_optrom_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1479
  __mptr = (struct device  const  *)dev;
#line 1479
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1479
  vha = (scsi_qla_host_t *)tmp;
#line 1480
  ha = vha->hw;
#line 1481
  tmp___0 = snprintf(buf, 4096UL, "%d.%02d.%02d %d\n", ha->fw_revision[0], ha->fw_revision[1],
                     ha->fw_revision[2], ha->fw_revision[3]);
#line 1481
  return ((ssize_t )tmp___0);
}
}
#line 1487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_optrom_gold_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                                   char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1490
  __mptr = (struct device  const  *)dev;
#line 1490
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1490
  vha = (scsi_qla_host_t *)tmp;
#line 1491
  ha = vha->hw;
#line 1493
  if ((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 1494
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1494
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1496
  tmp___1 = snprintf(buf, 4096UL, "%d.%02d.%02d (%d)\n", ha->gold_fw_version[0], ha->gold_fw_version[1],
                     ha->gold_fw_version[2], ha->gold_fw_version[3]);
#line 1496
  return ((ssize_t )tmp___1);
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_total_isp_aborts_show(struct device *dev , struct device_attribute *attr ,
                                             char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1505
  __mptr = (struct device  const  *)dev;
#line 1505
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1505
  vha = (scsi_qla_host_t *)tmp;
#line 1506
  tmp___0 = snprintf(buf, 4096UL, "%d\n", vha->qla_stats.total_isp_aborts);
#line 1506
  return ((ssize_t )tmp___0);
}
}
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla24xx_84xx_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                            char *buf ) 
{ 
  int rval ;
  uint16_t status[2U] ;
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1514
  rval = 0;
#line 1515
  status[0] = 0U;
#line 1515
  status[1] = 0U;
#line 1516
  __mptr = (struct device  const  *)dev;
#line 1516
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1516
  vha = (scsi_qla_host_t *)tmp;
#line 1517
  ha = vha->hw;
#line 1519
  if ((ha->device_type & 4096U) == 0U) {
#line 1520
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1520
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1522
  if ((ha->cs84xx)->op_fw_version == 0U) {
#line 1523
    rval = qla84xx_verify_chip(vha, (uint16_t *)(& status));
  } else {

  }
#line 1525
  if (rval == 0 && (unsigned int )status[0] == 0U) {
#line 1526
    tmp___1 = snprintf(buf, 4096UL, "%u\n", (ha->cs84xx)->op_fw_version);
#line 1526
    return ((ssize_t )tmp___1);
  } else {

  }
#line 1529
  tmp___2 = snprintf(buf, 4096UL, "\n");
#line 1529
  return ((ssize_t )tmp___2);
}
}
#line 1533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_mpi_version_show(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1536
  __mptr = (struct device  const  *)dev;
#line 1536
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1536
  vha = (scsi_qla_host_t *)tmp;
#line 1537
  ha = vha->hw;
#line 1539
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 1540
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1540
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1542
  tmp___1 = snprintf(buf, 4096UL, "%d.%02d.%02d (%x)\n", (int )ha->mpi_version[0],
                     (int )ha->mpi_version[1], (int )ha->mpi_version[2], ha->mpi_capabilities);
#line 1542
  return ((ssize_t )tmp___1);
}
}
#line 1548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_phy_version_show(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1551
  __mptr = (struct device  const  *)dev;
#line 1551
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1551
  vha = (scsi_qla_host_t *)tmp;
#line 1552
  ha = vha->hw;
#line 1554
  if ((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) {
#line 1555
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1555
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1557
  tmp___1 = snprintf(buf, 4096UL, "%d.%02d.%02d\n", (int )ha->phy_version[0], (int )ha->phy_version[1],
                     (int )ha->phy_version[2]);
#line 1557
  return ((ssize_t )tmp___1);
}
}
#line 1562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_flash_block_size_show(struct device *dev , struct device_attribute *attr ,
                                             char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int tmp___0 ;

  {
#line 1565
  __mptr = (struct device  const  *)dev;
#line 1565
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1565
  vha = (scsi_qla_host_t *)tmp;
#line 1566
  ha = vha->hw;
#line 1568
  tmp___0 = snprintf(buf, 4096UL, "0x%x\n", ha->fdt_block_size);
#line 1568
  return ((ssize_t )tmp___0);
}
}
#line 1572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_vlan_id_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1575
  __mptr = (struct device  const  *)dev;
#line 1575
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1575
  vha = (scsi_qla_host_t *)tmp;
#line 1577
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1578
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1578
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1580
  tmp___1 = snprintf(buf, 4096UL, "%d\n", (int )vha->fcoe_vlan_id);
#line 1580
  return ((ssize_t )tmp___1);
}
}
#line 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_vn_port_mac_address_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1587
  __mptr = (struct device  const  *)dev;
#line 1587
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1587
  vha = (scsi_qla_host_t *)tmp;
#line 1589
  if (((((vha->hw)->device_type & 8192U) == 0U && ((vha->hw)->device_type & 16384U) == 0U) && ((vha->hw)->device_type & 65536U) == 0U) && ((vha->hw)->device_type & 262144U) == 0U) {
#line 1590
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1590
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1592
  tmp___1 = snprintf(buf, 4096UL, "%pMR\n", (uint8_t *)(& vha->fcoe_vn_port_mac));
#line 1592
  return ((ssize_t )tmp___1);
}
}
#line 1596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_fabric_param_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1599
  __mptr = (struct device  const  *)dev;
#line 1599
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1599
  vha = (scsi_qla_host_t *)tmp;
#line 1601
  tmp___0 = snprintf(buf, 4096UL, "%d\n", (int )(vha->hw)->switch_cap);
#line 1601
  return ((ssize_t )tmp___0);
}
}
#line 1605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_thermal_temp_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  uint16_t temp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1608
  __mptr = (struct device  const  *)dev;
#line 1608
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1608
  vha = (scsi_qla_host_t *)tmp;
#line 1609
  temp = 0U;
#line 1611
  tmp___0 = qla2x00_reset_active(vha);
#line 1611
  if (tmp___0 != 0) {
#line 1612
    ql_log(1U, vha, 28892, "ISP reset active.\n");
#line 1613
    goto done;
  } else {

  }
#line 1616
  if (*((unsigned long *)vha->hw + 2UL) != 0UL) {
#line 1617
    ql_log(1U, vha, 28893, "PCI EEH busy.\n");
#line 1618
    goto done;
  } else {

  }
#line 1621
  tmp___2 = qla2x00_get_thermal_temp(vha, & temp);
#line 1621
  if (tmp___2 == 0) {
#line 1622
    tmp___1 = snprintf(buf, 4096UL, "%d\n", (int )temp);
#line 1622
    return ((ssize_t )tmp___1);
  } else {

  }
  done: 
#line 1625
  tmp___3 = snprintf(buf, 4096UL, "\n");
#line 1625
  return ((ssize_t )tmp___3);
}
}
#line 1629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int rval ;
  uint16_t state[5U] ;
  uint32_t pstate ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1632
  __mptr = (struct device  const  *)dev;
#line 1632
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1632
  vha = (scsi_qla_host_t *)tmp;
#line 1633
  rval = 258;
#line 1637
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1638
    pstate = qlafx00_fw_state_show(dev, attr, buf);
#line 1639
    tmp___0 = snprintf(buf, 4096UL, "0x%x\n", pstate);
#line 1639
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1642
  tmp___1 = qla2x00_reset_active(vha);
#line 1642
  if (tmp___1 != 0) {
#line 1643
    ql_log(1U, vha, 28796, "ISP reset active.\n");
  } else
#line 1645
  if (*((unsigned long *)vha->hw + 2UL) == 0UL) {
#line 1646
    rval = qla2x00_get_firmware_state(vha, (uint16_t *)(& state));
  } else {

  }
#line 1647
  if (rval != 0) {
#line 1648
    memset((void *)(& state), -1, 10UL);
  } else {

  }
#line 1650
  tmp___2 = snprintf(buf, 4096UL, "0x%x 0x%x 0x%x 0x%x 0x%x\n", (int )state[0], (int )state[1],
                     (int )state[2], (int )state[3], (int )state[4]);
#line 1650
  return ((ssize_t )tmp___2);
}
}
#line 1655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_diag_requests_show(struct device *dev , struct device_attribute *attr ,
                                          char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1658
  __mptr = (struct device  const  *)dev;
#line 1658
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1658
  vha = (scsi_qla_host_t *)tmp;
#line 1660
  if (((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 32768U) == 0U) {
#line 1661
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1661
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1663
  tmp___1 = snprintf(buf, 4096UL, "%llu\n", vha->bidi_stats.io_count);
#line 1663
  return ((ssize_t )tmp___1);
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_diag_megabytes_show(struct device *dev , struct device_attribute *attr ,
                                           char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1670
  __mptr = (struct device  const  *)dev;
#line 1670
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1670
  vha = (scsi_qla_host_t *)tmp;
#line 1672
  if (((vha->hw)->device_type & 2048U) == 0U && ((vha->hw)->device_type & 32768U) == 0U) {
#line 1673
    tmp___0 = snprintf(buf, 4096UL, "\n");
#line 1673
    return ((ssize_t )tmp___0);
  } else {

  }
#line 1675
  tmp___1 = snprintf(buf, 4096UL, "%llu\n", vha->bidi_stats.transfer_bytes >> 20);
#line 1675
  return ((ssize_t )tmp___1);
}
}
#line 1680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static ssize_t qla2x00_fw_dump_size_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint32_t size ;
  int tmp___0 ;

  {
#line 1683
  __mptr = (struct device  const  *)dev;
#line 1683
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 1683
  vha = (scsi_qla_host_t *)tmp;
#line 1684
  ha = vha->hw;
#line 1687
  if (ha->fw_dumped == 0) {
#line 1688
    size = 0U;
  } else
#line 1689
  if ((ha->device_type & 16384U) != 0U) {
#line 1690
    size = ha->md_template_size + ha->md_dump_size;
  } else {
#line 1692
    size = ha->fw_dump_len;
  }
#line 1694
  tmp___0 = snprintf(buf, 4096UL, "%d\n", size);
#line 1694
  return ((ssize_t )tmp___0);
}
}
#line 1697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_driver_version  =    {{"driver_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_drvr_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_fw_version  =    {{"fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_serial_num  =    {{"serial_num", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_serial_num_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_isp_name  =    {{"isp_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_isp_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_isp_id  =    {{"isp_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_isp_id_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_model_name  =    {{"model_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_model_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_model_desc  =    {{"model_desc", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_model_desc_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_pci_info  =    {{"pci_info", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_pci_info_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_link_state  =    {{"link_state", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_link_state_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
#line 1706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_zio  =    {{"zio", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_zio_show,
    & qla2x00_zio_store};
#line 1708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_zio_timer  =    {{"zio_timer", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_zio_timer_show, & qla2x00_zio_timer_store};
#line 1710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_beacon  =    {{"beacon", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_beacon_show,
    & qla2x00_beacon_store};
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_optrom_bios_version  =    {{"optrom_bios_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}}}}, & qla2x00_optrom_bios_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_optrom_efi_version  =    {{"optrom_efi_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_optrom_efi_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                    char const   * , size_t  ))0};
#line 1716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_optrom_fcode_version  =    {{"optrom_fcode_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}}}}, & qla2x00_optrom_fcode_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_optrom_fw_version  =    {{"optrom_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_optrom_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                   char const   * , size_t  ))0};
#line 1720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_optrom_gold_fw_version  =    {{"optrom_gold_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}}}}, & qla2x00_optrom_gold_fw_version_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_84xx_fw_version  =    {{"84xx_fw_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                             {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla24xx_84xx_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                 char const   * , size_t  ))0};
#line 1724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_total_isp_aborts  =    {{"total_isp_aborts", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_total_isp_aborts_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0};
#line 1725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_mpi_version  =    {{"mpi_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_mpi_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0};
#line 1726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_phy_version  =    {{"phy_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_phy_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0};
#line 1728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_flash_block_size  =    {{"flash_block_size", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_flash_block_size_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0};
#line 1729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_vlan_id  =    {{"vlan_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, & qla2x00_vlan_id_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_vn_port_mac_address  =    {{"vn_port_mac_address", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}}}}, & qla2x00_vn_port_mac_address_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_fabric_param  =    {{"fabric_param", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fabric_param_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_fw_state  =    {{"fw_state", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_state_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 1734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_thermal_temp  =    {{"thermal_temp", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_thermal_temp_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_diag_requests  =    {{"diag_requests", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                           {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_diag_requests_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                               char const   * , size_t  ))0};
#line 1736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_diag_megabytes  =    {{"diag_megabytes", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_diag_megabytes_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                char const   * , size_t  ))0};
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct device_attribute dev_attr_fw_dump_size  =    {{"fw_dump_size", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qla2x00_fw_dump_size_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
#line 1739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
struct device_attribute *qla2x00_host_attrs[31U]  = 
#line 1739
  {      & dev_attr_driver_version,      & dev_attr_fw_version,      & dev_attr_serial_num,      & dev_attr_isp_name, 
        & dev_attr_isp_id,      & dev_attr_model_name,      & dev_attr_model_desc,      & dev_attr_pci_info, 
        & dev_attr_link_state,      & dev_attr_zio,      & dev_attr_zio_timer,      & dev_attr_beacon, 
        & dev_attr_optrom_bios_version,      & dev_attr_optrom_efi_version,      & dev_attr_optrom_fcode_version,      & dev_attr_optrom_fw_version, 
        & dev_attr_84xx_fw_version,      & dev_attr_total_isp_aborts,      & dev_attr_mpi_version,      & dev_attr_phy_version, 
        & dev_attr_flash_block_size,      & dev_attr_vlan_id,      & dev_attr_vn_port_mac_address,      & dev_attr_fabric_param, 
        & dev_attr_fw_state,      & dev_attr_optrom_gold_fw_version,      & dev_attr_thermal_temp,      & dev_attr_diag_requests, 
        & dev_attr_diag_megabytes,      & dev_attr_fw_dump_size,      (struct device_attribute *)0};
#line 1776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_port_id(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1778
  tmp = shost_priv(shost);
#line 1778
  vha = (scsi_qla_host_t *)tmp;
#line 1780
  ((struct fc_host_attrs *)shost->shost_data)->port_id = (u32 )((((int )vha->d_id.b.domain << 16) | ((int )vha->d_id.b.area << 8)) | (int )vha->d_id.b.al_pa);
#line 1782
  return;
}
}
#line 1785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct qla_hw_data *ha ;
  void *tmp ;
  u32 speed ;

  {
#line 1787
  tmp = shost_priv(shost);
#line 1787
  ha = ((struct scsi_qla_host *)tmp)->hw;
#line 1789
  speed = 0U;
#line 1791
  if ((ha->device_type & 131072U) != 0U) {
#line 1792
    qlafx00_get_host_speed(shost);
#line 1793
    return;
  } else {

  }
#line 1796
  switch ((int )ha->link_data_rate) {
  case 0: 
#line 1798
  speed = 1U;
#line 1799
  goto ldv_61407;
  case 1: 
#line 1801
  speed = 2U;
#line 1802
  goto ldv_61407;
  case 3: 
#line 1804
  speed = 8U;
#line 1805
  goto ldv_61407;
  case 4: 
#line 1807
  speed = 16U;
#line 1808
  goto ldv_61407;
  case 19: 
#line 1810
  speed = 4U;
#line 1811
  goto ldv_61407;
  case 5: 
#line 1813
  speed = 32U;
#line 1814
  goto ldv_61407;
  }
  ldv_61407: 
#line 1816
  ((struct fc_host_attrs *)shost->shost_data)->speed = speed;
#line 1817
  return;
}
}
#line 1820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_port_type(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint32_t port_type ;

  {
#line 1822
  tmp = shost_priv(shost);
#line 1822
  vha = (scsi_qla_host_t *)tmp;
#line 1823
  port_type = 0U;
#line 1825
  if ((unsigned int )vha->vp_idx != 0U) {
#line 1826
    ((struct fc_host_attrs *)shost->shost_data)->port_type = 7;
#line 1827
    return;
  } else {

  }
#line 1829
  switch ((int )(vha->hw)->current_topology) {
  case 1: 
#line 1831
  port_type = 5U;
#line 1832
  goto ldv_61419;
  case 4: 
#line 1834
  port_type = 4U;
#line 1835
  goto ldv_61419;
  case 2: 
#line 1837
  port_type = 6U;
#line 1838
  goto ldv_61419;
  case 8: 
#line 1840
  port_type = 3U;
#line 1841
  goto ldv_61419;
  }
  ldv_61419: 
#line 1843
  ((struct fc_host_attrs *)shost->shost_data)->port_type = (enum fc_port_type )port_type;
#line 1844
  return;
}
}
#line 1847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_starget_node_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  u64 node_name ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1849
  tmp = dev_to_shost(starget->dev.parent);
#line 1849
  host = tmp;
#line 1850
  tmp___0 = shost_priv(host);
#line 1850
  vha = (scsi_qla_host_t *)tmp___0;
#line 1852
  node_name = 0ULL;
#line 1854
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1854
  fcport = (fc_port_t *)__mptr;
#line 1854
  goto ldv_61436;
  ldv_61435: ;
#line 1855
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1857
    node_name = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1858
    goto ldv_61434;
  } else {

  }
#line 1854
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1854
  fcport = (fc_port_t *)__mptr___0;
  ldv_61436: ;
#line 1854
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1856
    goto ldv_61435;
  } else {

  }
  ldv_61434: 
#line 1862
  ((struct fc_starget_attrs *)(& starget->starget_data))->node_name = node_name;
#line 1863
  return;
}
}
#line 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_starget_port_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  u64 port_name ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1868
  tmp = dev_to_shost(starget->dev.parent);
#line 1868
  host = tmp;
#line 1869
  tmp___0 = shost_priv(host);
#line 1869
  vha = (scsi_qla_host_t *)tmp___0;
#line 1871
  port_name = 0ULL;
#line 1873
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1873
  fcport = (fc_port_t *)__mptr;
#line 1873
  goto ldv_61450;
  ldv_61449: ;
#line 1874
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1876
    port_name = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1877
    goto ldv_61448;
  } else {

  }
#line 1873
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1873
  fcport = (fc_port_t *)__mptr___0;
  ldv_61450: ;
#line 1873
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1875
    goto ldv_61449;
  } else {

  }
  ldv_61448: 
#line 1881
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_name = port_name;
#line 1882
  return;
}
}
#line 1885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_starget_port_id(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  scsi_qla_host_t *vha ;
  void *tmp___0 ;
  fc_port_t *fcport ;
  uint32_t port_id ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1887
  tmp = dev_to_shost(starget->dev.parent);
#line 1887
  host = tmp;
#line 1888
  tmp___0 = shost_priv(host);
#line 1888
  vha = (scsi_qla_host_t *)tmp___0;
#line 1890
  port_id = 4294967295U;
#line 1892
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1892
  fcport = (fc_port_t *)__mptr;
#line 1892
  goto ldv_61464;
  ldv_61463: ;
#line 1893
  if ((unsigned long )fcport->rport != (unsigned long )((struct fc_rport *)0) && starget->id == (fcport->rport)->scsi_target_id) {
#line 1895
    port_id = (uint32_t )((((int )fcport->d_id.b.domain << 16) | ((int )fcport->d_id.b.area << 8)) | (int )fcport->d_id.b.al_pa);
#line 1897
    goto ldv_61462;
  } else {

  }
#line 1892
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1892
  fcport = (fc_port_t *)__mptr___0;
  ldv_61464: ;
#line 1892
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1894
    goto ldv_61463;
  } else {

  }
  ldv_61462: 
#line 1901
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_id = port_id;
#line 1902
  return;
}
}
#line 1905 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_set_rport_loss_tmo(struct fc_rport *rport , uint32_t timeout ) 
{ 


  {
#line 1907
  if (timeout != 0U) {
#line 1908
    rport->dev_loss_tmo = timeout;
  } else {
#line 1910
    rport->dev_loss_tmo = 1U;
  }
#line 1911
  return;
}
}
#line 1914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_dev_loss_tmo_callbk(struct fc_rport *rport ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  fc_port_t *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct fc_rport *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 1916
  tmp = dev_to_shost(rport->dev.parent);
#line 1916
  host = tmp;
#line 1917
  fcport = *((fc_port_t **)rport->dd_data);
#line 1920
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1921
    return;
  } else {

  }
#line 1925
  qla2x00_set_fcport_state___1(fcport, 2);
#line 1931
  tmp___0 = spinlock_check(host->host_lock);
#line 1931
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1932
  tmp___1 = (struct fc_rport *)0;
#line 1932
  fcport->drport = tmp___1;
#line 1932
  fcport->rport = tmp___1;
#line 1933
  *((fc_port_t **)rport->dd_data) = (fc_port_t *)0;
#line 1934
  spin_unlock_irqrestore(host->host_lock, flags);
#line 1936
  tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& (fcport->vha)->dpc_flags));
#line 1936
  if (tmp___2 != 0) {
#line 1937
    return;
  } else {

  }
#line 1939
  tmp___3 = pci_channel_offline(((fcport->vha)->hw)->pdev);
#line 1939
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 1939
  if (tmp___4 != 0L) {
#line 1940
    qla2x00_abort_all_cmds(fcport->vha, 65536);
#line 1941
    return;
  } else {

  }
#line 1943
  return;
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_terminate_rport_io(struct fc_rport *rport ) 
{ 
  fc_port_t *fcport ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1948
  fcport = *((fc_port_t **)rport->dd_data);
#line 1950
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 1951
    return;
  } else {

  }
#line 1953
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& (fcport->vha)->dpc_flags));
#line 1953
  if (tmp != 0) {
#line 1954
    return;
  } else {

  }
#line 1956
  tmp___0 = pci_channel_offline(((fcport->vha)->hw)->pdev);
#line 1956
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 1956
  if (tmp___1 != 0L) {
#line 1957
    qla2x00_abort_all_cmds(fcport->vha, 65536);
#line 1958
    return;
  } else {

  }
#line 1964
  if ((unsigned int )fcport->loop_id != 4096U) {
#line 1965
    if ((((fcport->vha)->hw)->device_type & 134217728U) != 0U) {
#line 1966
      (*((((fcport->vha)->hw)->isp_ops)->fabric_logout))(fcport->vha, (int )fcport->loop_id,
                                                         (int )fcport->d_id.b.domain,
                                                         (int )fcport->d_id.b.area,
                                                         (int )fcport->d_id.b.al_pa);
    } else {
#line 1970
      qla2x00_port_logout(fcport->vha, fcport);
    }
  } else {

  }
#line 1971
  return;
}
}
#line 1975 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static int qla2x00_issue_lip(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1977
  tmp = shost_priv(shost);
#line 1977
  vha = (scsi_qla_host_t *)tmp;
#line 1979
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 1980
    return (0);
  } else {

  }
#line 1982
  qla2x00_loop_reset(vha);
#line 1983
  return (0);
}
}
#line 1987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static struct fc_host_statistics *qla2x00_get_fc_host_stats(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *base_vha ;
  void *tmp___0 ;
  int rval ;
  struct link_statistics *stats ;
  dma_addr_t stats_dma ;
  struct fc_host_statistics *pfc_host_stat ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u64 tmp___7 ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 1989
  tmp = shost_priv(shost);
#line 1989
  vha = (scsi_qla_host_t *)tmp;
#line 1990
  ha = vha->hw;
#line 1991
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 1991
  base_vha = (struct scsi_qla_host *)tmp___0;
#line 1997
  pfc_host_stat = & vha->fc_host_stat;
#line 1998
  memset((void *)pfc_host_stat, -1, 232UL);
#line 2000
  if (((vha->hw)->device_type & 131072U) != 0U) {
#line 2001
    goto done;
  } else {

  }
#line 2003
  tmp___1 = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2003
  if (tmp___1 != 0) {
#line 2004
    goto done;
  } else {

  }
#line 2006
  tmp___2 = pci_channel_offline(ha->pdev);
#line 2006
  tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
#line 2006
  if (tmp___3 != 0L) {
#line 2007
    goto done;
  } else {

  }
#line 2009
  tmp___4 = qla2x00_reset_active(vha);
#line 2009
  if (tmp___4 != 0) {
#line 2010
    goto done;
  } else {

  }
#line 2012
  tmp___5 = dma_pool_alloc(ha->s_dma_pool, 208U, & stats_dma);
#line 2012
  stats = (struct link_statistics *)tmp___5;
#line 2013
  if ((unsigned long )stats == (unsigned long )((struct link_statistics *)0)) {
#line 2014
    ql_log(1U, vha, 28797, "Failed to allocate memory for stats.\n");
#line 2016
    goto done;
  } else {

  }
#line 2018
  memset((void *)stats, 0, 256UL);
#line 2020
  rval = 258;
#line 2021
  if ((ha->device_type & 134217728U) != 0U) {
#line 2022
    rval = qla24xx_get_isp_stats(base_vha, stats, stats_dma);
  } else {
#line 2023
    tmp___6 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2023
    if (tmp___6 == 5 && (unsigned int )ha->dpc_active == 0U) {
#line 2026
      rval = qla2x00_get_link_status(base_vha, (int )base_vha->loop_id, stats, stats_dma);
    } else {

    }
  }
#line 2030
  if (rval != 0) {
#line 2031
    goto done_free;
  } else {

  }
#line 2033
  pfc_host_stat->link_failure_count = (u64 )stats->link_fail_cnt;
#line 2034
  pfc_host_stat->loss_of_sync_count = (u64 )stats->loss_sync_cnt;
#line 2035
  pfc_host_stat->loss_of_signal_count = (u64 )stats->loss_sig_cnt;
#line 2036
  pfc_host_stat->prim_seq_protocol_err_count = (u64 )stats->prim_seq_err_cnt;
#line 2037
  pfc_host_stat->invalid_tx_word_count = (u64 )stats->inval_xmit_word_cnt;
#line 2038
  pfc_host_stat->invalid_crc_count = (u64 )stats->inval_crc_cnt;
#line 2039
  if ((ha->device_type & 134217728U) != 0U) {
#line 2040
    pfc_host_stat->lip_count = (u64 )stats->lip_cnt;
#line 2041
    pfc_host_stat->tx_frames = (u64 )stats->tx_frames;
#line 2042
    pfc_host_stat->rx_frames = (u64 )stats->rx_frames;
#line 2043
    pfc_host_stat->dumped_frames = (u64 )stats->discarded_frames;
#line 2044
    pfc_host_stat->nos_count = (u64 )stats->nos_rcvd;
#line 2045
    pfc_host_stat->error_frames = (u64 )(stats->dropped_frames + stats->discarded_frames);
#line 2047
    pfc_host_stat->rx_words = vha->qla_stats.input_bytes;
#line 2048
    pfc_host_stat->tx_words = vha->qla_stats.output_bytes;
  } else {

  }
#line 2050
  pfc_host_stat->fcp_control_requests = (u64 )vha->qla_stats.control_requests;
#line 2051
  pfc_host_stat->fcp_input_requests = vha->qla_stats.input_requests;
#line 2052
  pfc_host_stat->fcp_output_requests = vha->qla_stats.output_requests;
#line 2053
  pfc_host_stat->fcp_input_megabytes = vha->qla_stats.input_bytes >> 20;
#line 2054
  pfc_host_stat->fcp_output_megabytes = vha->qla_stats.output_bytes >> 20;
#line 2055
  tmp___7 = get_jiffies_64();
#line 2055
  pfc_host_stat->seconds_since_last_reset = tmp___7 - vha->qla_stats.jiffies_at_last_reset;
#line 2057
  __base = 250U;
#line 2057
  __rem = (uint32_t )(pfc_host_stat->seconds_since_last_reset % (u64 )__base);
#line 2057
  pfc_host_stat->seconds_since_last_reset = pfc_host_stat->seconds_since_last_reset / (u64 )__base;
  done_free: 
#line 2060
  dma_pool_free(ha->s_dma_pool, (void *)stats, stats_dma);
  done: ;
#line 2062
  return (pfc_host_stat);
}
}
#line 2066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_reset_host_stats(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2068
  tmp = shost_priv(shost);
#line 2068
  vha = (scsi_qla_host_t *)tmp;
#line 2070
  memset((void *)(& vha->fc_host_stat), 0, 232UL);
#line 2072
  vha->qla_stats.jiffies_at_last_reset = get_jiffies_64();
#line 2073
  return;
}
}
#line 2076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_symbolic_name(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2078
  tmp = shost_priv(shost);
#line 2078
  vha = (scsi_qla_host_t *)tmp;
#line 2080
  qla2x00_get_sym_node_name(vha, (uint8_t *)(& ((struct fc_host_attrs *)shost->shost_data)->symbolic_name));
#line 2081
  return;
}
}
#line 2084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_set_host_system_hostname(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2086
  tmp = shost_priv(shost);
#line 2086
  vha = (scsi_qla_host_t *)tmp;
#line 2088
  set_bit(12L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2089
  return;
}
}
#line 2092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_fabric_name(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint8_t node_name[8U] ;
  u64 fabric_name ;
  u64 tmp___0 ;

  {
#line 2094
  tmp = shost_priv(shost);
#line 2094
  vha = (scsi_qla_host_t *)tmp;
#line 2095
  node_name[0] = 255U;
#line 2095
  node_name[1] = 255U;
#line 2095
  node_name[2] = 255U;
#line 2095
  node_name[3] = 255U;
#line 2095
  node_name[4] = 255U;
#line 2095
  node_name[5] = 255U;
#line 2095
  node_name[6] = 255U;
#line 2095
  node_name[7] = 255U;
#line 2097
  tmp___0 = wwn_to_u64((u8 *)(& node_name));
#line 2097
  fabric_name = tmp___0;
#line 2099
  if ((int )vha->device_flags & 1) {
#line 2100
    fabric_name = wwn_to_u64((u8 *)(& vha->fabric_node_name));
  } else {

  }
#line 2102
  ((struct fc_host_attrs *)shost->shost_data)->fabric_name = fabric_name;
#line 2103
  return;
}
}
#line 2106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static void qla2x00_get_host_port_state(struct Scsi_Host *shost ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct scsi_qla_host *base_vha ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2108
  tmp = shost_priv(shost);
#line 2108
  vha = (scsi_qla_host_t *)tmp;
#line 2109
  tmp___0 = pci_get_drvdata((vha->hw)->pdev);
#line 2109
  base_vha = (struct scsi_qla_host *)tmp___0;
#line 2111
  if (*((unsigned long *)base_vha + 19UL) == 0UL) {
#line 2112
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 3;
#line 2113
    return;
  } else {

  }
#line 2116
  tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2116
  switch (tmp___1) {
  case 4: 
#line 2118
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 6;
#line 2119
  goto ldv_61525;
  case 2: 
#line 2121
  tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 2121
  if (tmp___2 != 0) {
#line 2122
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 6;
  } else {
#line 2124
    ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
  }
#line 2125
  goto ldv_61525;
  case 6: 
#line 2127
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
#line 2128
  goto ldv_61525;
  case 5: 
#line 2130
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 2;
#line 2131
  goto ldv_61525;
  default: 
#line 2133
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 0;
#line 2134
  goto ldv_61525;
  }
  ldv_61525: ;
#line 2137
  return;
}
}
#line 2139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static int qla24xx_vport_create(struct fc_vport *fc_vport , bool disable ) 
{ 
  int ret ;
  uint8_t qos ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  uint16_t options ;
  int cnt ;
  struct req_que *req ;
  int tmp___0 ;
  int tmp___1 ;
  int prot ;
  int guard ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2141
  ret = 0;
#line 2142
  qos = 0U;
#line 2143
  tmp = shost_priv(fc_vport->shost);
#line 2143
  base_vha = (scsi_qla_host_t *)tmp;
#line 2144
  vha = (scsi_qla_host_t *)0;
#line 2145
  ha = base_vha->hw;
#line 2146
  options = 0U;
#line 2148
  req = *(ha->req_q_map);
#line 2150
  ret = qla24xx_vport_create_req_sanity_check(fc_vport);
#line 2151
  if (ret != 0) {
#line 2152
    ql_log(1U, vha, 28798, "Vport sanity check failed, status %x\n", ret);
#line 2154
    return (ret);
  } else {

  }
#line 2157
  vha = qla24xx_create_vhost(fc_vport);
#line 2158
  if ((unsigned long )vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 2159
    ql_log(1U, vha, 28799, "Vport create host failed.\n");
#line 2160
    return (9);
  } else {

  }
#line 2162
  if ((int )disable) {
#line 2163
    atomic_set(& vha->vp_state, 0);
#line 2164
    fc_vport_set_state(fc_vport, 2);
  } else {
#line 2166
    atomic_set(& vha->vp_state, 2);
  }
#line 2169
  ql_log(2U, vha, 28800, "VP entry id %d assigned.\n", (int )vha->vp_idx);
#line 2173
  atomic_set(& vha->loop_state, 2);
#line 2174
  vha->vp_err_state = 1U;
#line 2175
  vha->vp_prev_err_state = 0U;
#line 2177
  tmp___0 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2177
  if (tmp___0 == 2) {
#line 2177
    goto _L;
  } else {
#line 2177
    tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 2177
    if (tmp___1 == 6) {
      _L: /* CIL Label */ 
#line 2180
      ql_dbg(8388608U, vha, 28801, "Vport loop state is not UP.\n");
#line 2182
      atomic_set(& vha->loop_state, 6);
#line 2183
      if (! disable) {
#line 2184
        fc_vport_set_state(fc_vport, 3);
      } else {

      }
    } else {

    }
  }
#line 2187
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 2188
    if (((int )ha->fw_attributes & 16) != 0) {
#line 2189
      prot = 0;
#line 2190
      vha->flags.difdix_supported = 1U;
#line 2191
      ql_dbg(8388608U, vha, 28802, "Registered for DIF/DIX type 1 and 3 protection.\n");
#line 2193
      if (ql2xenabledif == 1) {
#line 2194
        prot = 8;
      } else {

      }
#line 2195
      scsi_host_set_prot(vha->host, (unsigned int )(prot | 119));
#line 2203
      guard = 1;
#line 2205
      if (((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) && ql2xenabledif > 1) {
#line 2207
        guard = guard | 2;
      } else {

      }
#line 2209
      scsi_host_set_guard(vha->host, (int )((unsigned char )guard));
    } else {
#line 2211
      vha->flags.difdix_supported = 0U;
    }
  } else {

  }
#line 2214
  tmp___2 = ldv_scsi_add_host_with_dma_49(vha->host, & fc_vport->dev, & (ha->pdev)->dev);
#line 2214
  if (tmp___2 != 0) {
#line 2216
    ql_dbg(8388608U, vha, 28803, "scsi_add_host failure for VP[%d].\n", (int )vha->vp_idx);
#line 2218
    goto vport_create_failed_2;
  } else {

  }
#line 2222
  ((struct fc_host_attrs *)(vha->host)->shost_data)->dev_loss_tmo = (u32 )ha->port_down_retry_count;
#line 2223
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = wwn_to_u64((u8 *)(& vha->node_name));
#line 2224
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 2225
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = ((struct fc_host_attrs *)(base_vha->host)->shost_data)->supported_classes;
#line 2227
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_speeds = ((struct fc_host_attrs *)(base_vha->host)->shost_data)->supported_speeds;
#line 2230
  qlt_vport_create(vha, ha);
#line 2231
  qla24xx_vport_disable(fc_vport, (int )disable);
#line 2233
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2234
    req = *(ha->req_q_map + 1UL);
#line 2235
    ql_dbg(1048576U, vha, 49152, "Request queue %p attached with VP[%d], cpu affinity =%d\n",
           req, (int )vha->vp_idx, (int )ha->flags.cpu_affinity_enabled);
#line 2239
    goto vport_queue;
  } else
#line 2240
  if (ql2xmaxqueues == 1 || (unsigned long )ha->npiv_info == (unsigned long )((struct qla_npiv_entry *)0)) {
#line 2241
    goto vport_queue;
  } else {

  }
#line 2243
  cnt = 0;
#line 2243
  goto ldv_61548;
  ldv_61547: 
#line 2244
  tmp___3 = memcmp((void const   *)(& (ha->npiv_info + (unsigned long )cnt)->port_name),
                   (void const   *)(& vha->port_name), 8UL);
#line 2244
  if (tmp___3 == 0) {
#line 2244
    tmp___4 = memcmp((void const   *)(& (ha->npiv_info + (unsigned long )cnt)->node_name),
                     (void const   *)(& vha->node_name), 8UL);
#line 2244
    if (tmp___4 == 0) {
#line 2247
      qos = (ha->npiv_info + (unsigned long )cnt)->q_qos;
#line 2248
      goto ldv_61546;
    } else {

    }
  } else {

  }
#line 2243
  cnt = cnt + 1;
  ldv_61548: ;
#line 2243
  if ((int )ha->nvram_npiv_size > cnt) {
#line 2245
    goto ldv_61547;
  } else {

  }
  ldv_61546: ;
#line 2252
  if ((unsigned int )qos != 0U) {
#line 2253
    ret = qla25xx_create_req_que(ha, (int )options, (int )((uint8_t )vha->vp_idx),
                                 0, 0, (int )qos);
#line 2255
    if (ret == 0) {
#line 2256
      ql_log(1U, vha, 28804, "Can\'t create request queue for VP[%d]\n", (int )vha->vp_idx);
    } else {
#line 2260
      ql_dbg(1048576U, vha, 49153, "Request Que:%d Q0s: %d) created for VP[%d]\n",
             ret, (int )qos, (int )vha->vp_idx);
#line 2263
      ql_dbg(8388608U, vha, 28805, "Request Que:%d Q0s: %d) created for VP[%d]\n",
             ret, (int )qos, (int )vha->vp_idx);
#line 2266
      req = *(ha->req_q_map + (unsigned long )ret);
    }
  } else {

  }
  vport_queue: 
#line 2271
  vha->req = req;
#line 2272
  return (0);
  vport_create_failed_2: 
#line 2275
  qla24xx_disable_vp(vha);
#line 2276
  qla24xx_deallocate_vp_id(vha);
#line 2277
  scsi_host_put(vha->host);
#line 2278
  return (9);
}
}
#line 2282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static int qla24xx_vport_delete(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  uint16_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 2284
  vha = (scsi_qla_host_t *)fc_vport->dd_data;
#line 2285
  ha = vha->hw;
#line 2286
  id = vha->vp_idx;
#line 2288
  goto ldv_61556;
  ldv_61555: 
#line 2290
  msleep(1000U);
  ldv_61556: 
#line 2288
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2288
  if (tmp != 0) {
#line 2290
    goto ldv_61555;
  } else {
#line 2288
    tmp___0 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2288
    if (tmp___0 != 0) {
#line 2290
      goto ldv_61555;
    } else {
#line 2293
      goto ldv_61557;
    }
  }
  ldv_61557: 
#line 2292
  qla24xx_disable_vp(vha);
#line 2294
  vha->flags.delete_progress = 1U;
#line 2296
  fc_remove_host(vha->host);
#line 2298
  ldv_scsi_remove_host_50(vha->host);
#line 2301
  qla24xx_deallocate_vp_id(vha);
#line 2303
  if (vha->timer_active != 0U) {
#line 2304
    qla2x00_vp_stop_timer(vha);
#line 2305
    ql_dbg(8388608U, vha, 28806, "Timer for the VP[%d] has stopped\n", (int )vha->vp_idx);
  } else {

  }
#line 2309
  tmp___1 = atomic_read((atomic_t const   *)(& vha->vref_count));
#line 2309
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 2309
  if (tmp___2 != 0L) {
#line 2309
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"),
                         "i" (2309), "i" (12UL));
    ldv_61558: ;
#line 2309
    goto ldv_61558;
  } else {

  }
#line 2311
  qla2x00_free_fcports(vha);
#line 2313
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 2314
  ha->cur_vport_count = ha->cur_vport_count - 1;
#line 2315
  clear_bit((long )vha->vp_idx, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 2316
  mutex_unlock(& ha->vport_lock);
#line 2318
  if ((unsigned int )(vha->req)->id != 0U && *((unsigned long *)ha + 2UL) == 0UL) {
#line 2319
    tmp___3 = qla25xx_delete_req_que(vha, vha->req);
#line 2319
    if (tmp___3 != 0) {
#line 2320
      ql_log(1U, vha, 28807, "Queue delete failed.\n");
    } else {

    }
  } else {

  }
#line 2324
  ql_log(2U, vha, 28808, "VP[%d] deleted.\n", (int )id);
#line 2325
  scsi_host_put(vha->host);
#line 2326
  return (0);
}
}
#line 2330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
static int qla24xx_vport_disable(struct fc_vport *fc_vport , bool disable ) 
{ 
  scsi_qla_host_t *vha ;

  {
#line 2332
  vha = (scsi_qla_host_t *)fc_vport->dd_data;
#line 2334
  if ((int )disable) {
#line 2335
    qla24xx_disable_vp(vha);
  } else {
#line 2337
    qla24xx_enable_vp(vha);
  }
#line 2339
  return (0);
}
}
#line 2342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
struct fc_function_template qla2xxx_transport_functions  = 
#line 2342
     {0, & qla2x00_set_rport_loss_tmo, & qla2x00_get_starget_node_name, & qla2x00_get_starget_port_name,
    & qla2x00_get_starget_port_id, & qla2x00_get_host_port_id, & qla2x00_get_host_port_type,
    & qla2x00_get_host_port_state, 0, & qla2x00_get_host_speed, & qla2x00_get_host_fabric_name,
    & qla2x00_get_host_symbolic_name, & qla2x00_set_host_system_hostname, & qla2x00_get_fc_host_stats,
    & qla2x00_reset_host_stats, & qla2x00_issue_lip, & qla2x00_dev_loss_tmo_callbk,
    & qla2x00_terminate_rport_io, 0, & qla24xx_vport_create, & qla24xx_vport_disable,
    & qla24xx_vport_delete, 0, 0, & qla24xx_bsg_request, & qla24xx_bsg_timeout, 8U,
    0U, 0U, (unsigned char)0, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, 1U,
    1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 2390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
struct fc_function_template qla2xxx_transport_vport_functions  = 
#line 2390
     {0, & qla2x00_set_rport_loss_tmo, & qla2x00_get_starget_node_name, & qla2x00_get_starget_port_name,
    & qla2x00_get_starget_port_id, & qla2x00_get_host_port_id, & qla2x00_get_host_port_type,
    & qla2x00_get_host_port_state, 0, & qla2x00_get_host_speed, & qla2x00_get_host_fabric_name,
    & qla2x00_get_host_symbolic_name, & qla2x00_set_host_system_hostname, & qla2x00_get_fc_host_stats,
    & qla2x00_reset_host_stats, & qla2x00_issue_lip, & qla2x00_dev_loss_tmo_callbk,
    & qla2x00_terminate_rport_io, 0, 0, 0, 0, 0, 0, & qla24xx_bsg_request, & qla24xx_bsg_timeout,
    8U, 0U, 0U, (unsigned char)0, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, 1U, 1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 2435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void qla2x00_init_host_attr(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  u32 speed ;

  {
#line 2437
  ha = vha->hw;
#line 2438
  speed = 0U;
#line 2440
  ((struct fc_host_attrs *)(vha->host)->shost_data)->dev_loss_tmo = (u32 )ha->port_down_retry_count;
#line 2441
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = wwn_to_u64((u8 *)(& vha->node_name));
#line 2442
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = wwn_to_u64((u8 *)(& vha->port_name));
#line 2443
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = (unsigned int )*((unsigned char *)ha + 3808UL) != 0U ? 12U : 8U;
#line 2445
  ((struct fc_host_attrs *)(vha->host)->shost_data)->max_npiv_vports = ha->max_npiv_vports;
#line 2446
  ((struct fc_host_attrs *)(vha->host)->shost_data)->npiv_vports_inuse = (u16 )ha->cur_vport_count;
#line 2448
  if ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 2449
    speed = 4U;
  } else
#line 2450
  if ((ha->device_type & 32768U) != 0U) {
#line 2451
    speed = 56U;
  } else
#line 2453
  if ((ha->device_type & 2048U) != 0U) {
#line 2454
    speed = 27U;
  } else
#line 2456
  if ((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) {
#line 2457
    speed = 11U;
  } else
#line 2459
  if (((((ha->device_type & 4U) != 0U || (ha->device_type & 8U) != 0U) || (ha->device_type & 16U) != 0U) || (ha->device_type & 32U) != 0U) || (ha->device_type & 64U) != 0U) {
#line 2460
    speed = 3U;
  } else
#line 2461
  if ((ha->device_type & 131072U) != 0U) {
#line 2462
    speed = 27U;
  } else {
#line 2465
    speed = 1U;
  }
#line 2466
  ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_speeds = speed;
#line 2467
  return;
}
}
#line 2469
extern int ldv_release_52(void) ;
#line 2470
extern int ldv_release_58(void) ;
#line 2471
extern int ldv_probe_56(void) ;
#line 2472
extern int ldv_release_55(void) ;
#line 2473
extern int ldv_probe_59(void) ;
#line 2474
extern int ldv_probe_54(void) ;
#line 2475
extern int ldv_release_54(void) ;
#line 2476
extern int ldv_release_57(void) ;
#line 2477
extern int ldv_probe_53(void) ;
#line 2478
extern int ldv_release_53(void) ;
#line 2479
extern int ldv_probe_51(void) ;
#line 2480
extern int ldv_release_56(void) ;
#line 2481
extern int ldv_probe_52(void) ;
#line 2482
extern int ldv_release_59(void) ;
#line 2483
extern int ldv_probe_55(void) ;
#line 2484
extern int ldv_probe_58(void) ;
#line 2485
extern int ldv_probe_57(void) ;
#line 2486
extern int ldv_release_51(void) ;
#line 2489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_55(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2490
  tmp = ldv_zalloc(360UL);
#line 2490
  sysfs_vpd_attr_group0 = (struct file *)tmp;
#line 2491
  tmp___0 = ldv_zalloc(296UL);
#line 2491
  sysfs_vpd_attr_group2 = (struct kobject *)tmp___0;
#line 2492
  tmp___1 = ldv_zalloc(72UL);
#line 2492
  sysfs_vpd_attr_group1 = (struct bin_attribute *)tmp___1;
#line 2493
  return;
}
}
#line 2495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int reg_timer_10(struct timer_list *timer ) 
{ 


  {
#line 2496
  ldv_timer_list_10 = timer;
#line 2497
  ldv_timer_state_10 = 1;
#line 2498
  return (0);
}
}
#line 2501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_58(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2502
  tmp = ldv_zalloc(360UL);
#line 2502
  sysfs_nvram_attr_group0 = (struct file *)tmp;
#line 2503
  tmp___0 = ldv_zalloc(296UL);
#line 2503
  sysfs_nvram_attr_group2 = (struct kobject *)tmp___0;
#line 2504
  tmp___1 = ldv_zalloc(72UL);
#line 2504
  sysfs_nvram_attr_group1 = (struct bin_attribute *)tmp___1;
#line 2505
  return;
}
}
#line 2507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_59(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2508
  tmp = ldv_zalloc(360UL);
#line 2508
  sysfs_fw_dump_attr_group0 = (struct file *)tmp;
#line 2509
  tmp___0 = ldv_zalloc(296UL);
#line 2509
  sysfs_fw_dump_attr_group2 = (struct kobject *)tmp___0;
#line 2510
  tmp___1 = ldv_zalloc(72UL);
#line 2510
  sysfs_fw_dump_attr_group1 = (struct bin_attribute *)tmp___1;
#line 2511
  return;
}
}
#line 2513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_fc_function_template_19(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2514
  tmp = ldv_zalloc(3496UL);
#line 2514
  qla2xxx_transport_vport_functions_group0 = (struct Scsi_Host *)tmp;
#line 2515
  tmp___0 = ldv_zalloc(2168UL);
#line 2515
  qla2xxx_transport_vport_functions_group2 = (struct fc_rport *)tmp___0;
#line 2516
  tmp___1 = ldv_zalloc(184UL);
#line 2516
  qla2xxx_transport_vport_functions_group1 = (struct fc_bsg_job *)tmp___1;
#line 2517
  tmp___2 = ldv_zalloc(1552UL);
#line 2517
  qla2xxx_transport_vport_functions_group3 = (struct scsi_target *)tmp___2;
#line 2518
  return;
}
}
#line 2520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2520
  if ((unsigned long )ldv_timer_list_10 == (unsigned long )timer) {
#line 2521
    if (ldv_timer_state_10 == 2 || pending_flag != 0) {
#line 2522
      ldv_timer_list_10 = timer;
#line 2523
      ldv_timer_list_10->data = data;
#line 2524
      ldv_timer_state_10 = 1;
    } else {

    }
#line 2526
    return;
  } else {

  }
#line 2528
  reg_timer_10(timer);
#line 2529
  ldv_timer_list_10->data = data;
#line 2530
  return;
}
}
#line 2533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_41(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2534
  tmp = ldv_zalloc(1376UL);
#line 2534
  dev_attr_zio_group0 = (struct device *)tmp;
#line 2535
  tmp___0 = ldv_zalloc(48UL);
#line 2535
  dev_attr_zio_group1 = (struct device_attribute *)tmp___0;
#line 2536
  return;
}
}
#line 2538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_fc_function_template_20(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 2539
  tmp = ldv_zalloc(3496UL);
#line 2539
  qla2xxx_transport_functions_group0 = (struct Scsi_Host *)tmp;
#line 2540
  tmp___0 = ldv_zalloc(2168UL);
#line 2540
  qla2xxx_transport_functions_group2 = (struct fc_rport *)tmp___0;
#line 2541
  tmp___1 = ldv_zalloc(184UL);
#line 2541
  qla2xxx_transport_functions_group1 = (struct fc_bsg_job *)tmp___1;
#line 2542
  tmp___2 = ldv_zalloc(1552UL);
#line 2542
  qla2xxx_transport_functions_group3 = (struct scsi_target *)tmp___2;
#line 2543
  tmp___3 = ldv_zalloc(1608UL);
#line 2543
  qla2xxx_transport_functions_group4 = (struct fc_vport *)tmp___3;
#line 2544
  return;
}
}
#line 2546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void disable_suitable_timer_10(struct timer_list *timer ) 
{ 


  {
#line 2547
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_10) {
#line 2548
    ldv_timer_state_10 = 0;
#line 2549
    return;
  } else {

  }
#line 2551
  return;
}
}
#line 2554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_40(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2555
  tmp = ldv_zalloc(1376UL);
#line 2555
  dev_attr_zio_timer_group0 = (struct device *)tmp;
#line 2556
  tmp___0 = ldv_zalloc(48UL);
#line 2556
  dev_attr_zio_timer_group1 = (struct device_attribute *)tmp___0;
#line 2557
  return;
}
}
#line 2559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_device_attribute_39(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2560
  tmp = ldv_zalloc(1376UL);
#line 2560
  dev_attr_beacon_group0 = (struct device *)tmp;
#line 2561
  tmp___0 = ldv_zalloc(48UL);
#line 2561
  dev_attr_beacon_group1 = (struct device_attribute *)tmp___0;
#line 2562
  return;
}
}
#line 2564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void choose_timer_10(struct timer_list *timer ) 
{ 


  {
#line 2565
  LDV_IN_INTERRUPT = 2;
#line 2566
  (*(timer->function))(timer->data);
#line 2567
  LDV_IN_INTERRUPT = 1;
#line 2568
  ldv_timer_state_10 = 2;
#line 2569
  return;
}
}
#line 2572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_initialize_bin_attribute_57(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2573
  tmp = ldv_zalloc(360UL);
#line 2573
  sysfs_optrom_attr_group0 = (struct file *)tmp;
#line 2574
  tmp___0 = ldv_zalloc(296UL);
#line 2574
  sysfs_optrom_attr_group2 = (struct kobject *)tmp___0;
#line 2575
  tmp___1 = ldv_zalloc(72UL);
#line 2575
  sysfs_optrom_attr_group1 = (struct bin_attribute *)tmp___1;
#line 2576
  return;
}
}
#line 2578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  struct device_attribute *ldvarg2 ;
  void *tmp ;
  struct device *ldvarg0 ;
  void *tmp___0 ;
  char *ldvarg1 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2579
  tmp = ldv_zalloc(48UL);
#line 2579
  ldvarg2 = (struct device_attribute *)tmp;
#line 2580
  tmp___0 = ldv_zalloc(1376UL);
#line 2580
  ldvarg0 = (struct device *)tmp___0;
#line 2581
  tmp___1 = ldv_zalloc(1UL);
#line 2581
  ldvarg1 = (char *)tmp___1;
#line 2583
  tmp___2 = __VERIFIER_nondet_int();
#line 2583
  switch (tmp___2) {
  case 0: ;
#line 2586
  if (ldv_state_variable_33 == 1) {
#line 2588
    qla24xx_84xx_fw_version_show(ldvarg0, ldvarg2, ldvarg1);
#line 2590
    ldv_state_variable_33 = 1;
  } else {

  }
#line 2593
  goto ldv_61655;
  default: 
#line 2594
  ldv_stop();
  }
  ldv_61655: ;
#line 2598
  return;
}
}
#line 2600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  struct device_attribute *ldvarg5 ;
  void *tmp ;
  struct device *ldvarg3 ;
  void *tmp___0 ;
  char *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2601
  tmp = ldv_zalloc(48UL);
#line 2601
  ldvarg5 = (struct device_attribute *)tmp;
#line 2602
  tmp___0 = ldv_zalloc(1376UL);
#line 2602
  ldvarg3 = (struct device *)tmp___0;
#line 2603
  tmp___1 = ldv_zalloc(1UL);
#line 2603
  ldvarg4 = (char *)tmp___1;
#line 2605
  tmp___2 = __VERIFIER_nondet_int();
#line 2605
  switch (tmp___2) {
  case 0: ;
#line 2608
  if (ldv_state_variable_32 == 1) {
#line 2610
    qla2x00_total_isp_aborts_show(ldvarg3, ldvarg5, ldvarg4);
#line 2612
    ldv_state_variable_32 = 1;
  } else {

  }
#line 2615
  goto ldv_61664;
  default: 
#line 2616
  ldv_stop();
  }
  ldv_61664: ;
#line 2620
  return;
}
}
#line 2622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  struct device *ldvarg33 ;
  void *tmp ;
  char *ldvarg34 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg35 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2623
  tmp = ldv_zalloc(1376UL);
#line 2623
  ldvarg33 = (struct device *)tmp;
#line 2624
  tmp___0 = ldv_zalloc(1UL);
#line 2624
  ldvarg34 = (char *)tmp___0;
#line 2625
  tmp___1 = ldv_zalloc(48UL);
#line 2625
  ldvarg35 = (struct device_attribute *)tmp___1;
#line 2627
  tmp___2 = __VERIFIER_nondet_int();
#line 2627
  switch (tmp___2) {
  case 0: ;
#line 2630
  if (ldv_state_variable_21 == 1) {
#line 2632
    qla2x00_fw_dump_size_show(ldvarg33, ldvarg35, ldvarg34);
#line 2634
    ldv_state_variable_21 = 1;
  } else {

  }
#line 2637
  goto ldv_61673;
  default: 
#line 2638
  ldv_stop();
  }
  ldv_61673: ;
#line 2642
  return;
}
}
#line 2644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_26(void) 
{ 
  char *ldvarg80 ;
  void *tmp ;
  struct device *ldvarg79 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg81 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2645
  tmp = ldv_zalloc(1UL);
#line 2645
  ldvarg80 = (char *)tmp;
#line 2646
  tmp___0 = ldv_zalloc(1376UL);
#line 2646
  ldvarg79 = (struct device *)tmp___0;
#line 2647
  tmp___1 = ldv_zalloc(48UL);
#line 2647
  ldvarg81 = (struct device_attribute *)tmp___1;
#line 2649
  tmp___2 = __VERIFIER_nondet_int();
#line 2649
  switch (tmp___2) {
  case 0: ;
#line 2652
  if (ldv_state_variable_26 == 1) {
#line 2654
    qla2x00_fabric_param_show(ldvarg79, ldvarg81, ldvarg80);
#line 2656
    ldv_state_variable_26 = 1;
  } else {

  }
#line 2659
  goto ldv_61682;
  default: 
#line 2660
  ldv_stop();
  }
  ldv_61682: ;
#line 2664
  return;
}
}
#line 2666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_30(void) 
{ 
  char *ldvarg386 ;
  void *tmp ;
  struct device_attribute *ldvarg387 ;
  void *tmp___0 ;
  struct device *ldvarg385 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2667
  tmp = ldv_zalloc(1UL);
#line 2667
  ldvarg386 = (char *)tmp;
#line 2668
  tmp___0 = ldv_zalloc(48UL);
#line 2668
  ldvarg387 = (struct device_attribute *)tmp___0;
#line 2669
  tmp___1 = ldv_zalloc(1376UL);
#line 2669
  ldvarg385 = (struct device *)tmp___1;
#line 2671
  tmp___2 = __VERIFIER_nondet_int();
#line 2671
  switch (tmp___2) {
  case 0: ;
#line 2674
  if (ldv_state_variable_30 == 1) {
#line 2676
    qla2x00_phy_version_show(ldvarg385, ldvarg387, ldvarg386);
#line 2678
    ldv_state_variable_30 = 1;
  } else {

  }
#line 2681
  goto ldv_61691;
  default: 
#line 2682
  ldv_stop();
  }
  ldv_61691: ;
#line 2686
  return;
}
}
#line 2688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_44(void) 
{ 
  char *ldvarg92 ;
  void *tmp ;
  struct device *ldvarg91 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg93 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2689
  tmp = ldv_zalloc(1UL);
#line 2689
  ldvarg92 = (char *)tmp;
#line 2690
  tmp___0 = ldv_zalloc(1376UL);
#line 2690
  ldvarg91 = (struct device *)tmp___0;
#line 2691
  tmp___1 = ldv_zalloc(48UL);
#line 2691
  ldvarg93 = (struct device_attribute *)tmp___1;
#line 2693
  tmp___2 = __VERIFIER_nondet_int();
#line 2693
  switch (tmp___2) {
  case 0: ;
#line 2696
  if (ldv_state_variable_44 == 1) {
#line 2698
    qla2x00_model_desc_show(ldvarg91, ldvarg93, ldvarg92);
#line 2700
    ldv_state_variable_44 = 1;
  } else {

  }
#line 2703
  goto ldv_61700;
  default: 
#line 2704
  ldv_stop();
  }
  ldv_61700: ;
#line 2708
  return;
}
}
#line 2710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_55(void) 
{ 
  loff_t ldvarg99 ;
  loff_t tmp ;
  loff_t ldvarg96 ;
  loff_t tmp___0 ;
  size_t ldvarg94 ;
  size_t tmp___1 ;
  size_t ldvarg97 ;
  size_t tmp___2 ;
  char *ldvarg95 ;
  void *tmp___3 ;
  char *ldvarg98 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 2711
  tmp = __VERIFIER_nondet_loff_t();
#line 2711
  ldvarg99 = tmp;
#line 2712
  tmp___0 = __VERIFIER_nondet_loff_t();
#line 2712
  ldvarg96 = tmp___0;
#line 2713
  tmp___1 = __VERIFIER_nondet_size_t();
#line 2713
  ldvarg94 = tmp___1;
#line 2714
  tmp___2 = __VERIFIER_nondet_size_t();
#line 2714
  ldvarg97 = tmp___2;
#line 2715
  tmp___3 = ldv_zalloc(1UL);
#line 2715
  ldvarg95 = (char *)tmp___3;
#line 2716
  tmp___4 = ldv_zalloc(1UL);
#line 2716
  ldvarg98 = (char *)tmp___4;
#line 2718
  tmp___5 = __VERIFIER_nondet_int();
#line 2718
  switch (tmp___5) {
  case 0: ;
#line 2721
  if (ldv_state_variable_55 == 2) {
#line 2723
    qla2x00_sysfs_write_vpd(sysfs_vpd_attr_group0, sysfs_vpd_attr_group2, sysfs_vpd_attr_group1,
                            ldvarg98, ldvarg99, ldvarg97);
#line 2725
    ldv_state_variable_55 = 2;
  } else {

  }
#line 2728
  goto ldv_61712;
  case 1: ;
#line 2731
  if (ldv_state_variable_55 == 2) {
#line 2733
    qla2x00_sysfs_read_vpd(sysfs_vpd_attr_group0, sysfs_vpd_attr_group2, sysfs_vpd_attr_group1,
                           ldvarg95, ldvarg96, ldvarg94);
#line 2735
    ldv_state_variable_55 = 2;
  } else {

  }
#line 2738
  goto ldv_61712;
  case 2: ;
#line 2741
  if (ldv_state_variable_55 == 2) {
#line 2743
    ldv_release_55();
#line 2745
    ldv_state_variable_55 = 1;
#line 2746
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2749
  goto ldv_61712;
  case 3: ;
#line 2752
  if (ldv_state_variable_55 == 1) {
#line 2754
    ldv_probe_55();
#line 2756
    ldv_state_variable_55 = 2;
#line 2757
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2760
  goto ldv_61712;
  default: 
#line 2761
  ldv_stop();
  }
  ldv_61712: ;
#line 2765
  return;
}
}
#line 2767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_25(void) 
{ 
  char *ldvarg389 ;
  void *tmp ;
  struct device *ldvarg388 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg390 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2768
  tmp = ldv_zalloc(1UL);
#line 2768
  ldvarg389 = (char *)tmp;
#line 2769
  tmp___0 = ldv_zalloc(1376UL);
#line 2769
  ldvarg388 = (struct device *)tmp___0;
#line 2770
  tmp___1 = ldv_zalloc(48UL);
#line 2770
  ldvarg390 = (struct device_attribute *)tmp___1;
#line 2772
  tmp___2 = __VERIFIER_nondet_int();
#line 2772
  switch (tmp___2) {
  case 0: ;
#line 2775
  if (ldv_state_variable_25 == 1) {
#line 2777
    qla2x00_fw_state_show(ldvarg388, ldvarg390, ldvarg389);
#line 2779
    ldv_state_variable_25 = 1;
  } else {

  }
#line 2782
  goto ldv_61724;
  default: 
#line 2783
  ldv_stop();
  }
  ldv_61724: ;
#line 2787
  return;
}
}
#line 2789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_27(void) 
{ 
  struct device *ldvarg100 ;
  void *tmp ;
  char *ldvarg101 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg102 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2790
  tmp = ldv_zalloc(1376UL);
#line 2790
  ldvarg100 = (struct device *)tmp;
#line 2791
  tmp___0 = ldv_zalloc(1UL);
#line 2791
  ldvarg101 = (char *)tmp___0;
#line 2792
  tmp___1 = ldv_zalloc(48UL);
#line 2792
  ldvarg102 = (struct device_attribute *)tmp___1;
#line 2794
  tmp___2 = __VERIFIER_nondet_int();
#line 2794
  switch (tmp___2) {
  case 0: ;
#line 2797
  if (ldv_state_variable_27 == 1) {
#line 2799
    qla2x00_vn_port_mac_address_show(ldvarg100, ldvarg102, ldvarg101);
#line 2801
    ldv_state_variable_27 = 1;
  } else {

  }
#line 2804
  goto ldv_61733;
  default: 
#line 2805
  ldv_stop();
  }
  ldv_61733: ;
#line 2809
  return;
}
}
#line 2811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_28(void) 
{ 
  struct device *ldvarg391 ;
  void *tmp ;
  char *ldvarg392 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg393 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 2812
  tmp = ldv_zalloc(1376UL);
#line 2812
  ldvarg391 = (struct device *)tmp;
#line 2813
  tmp___0 = ldv_zalloc(1UL);
#line 2813
  ldvarg392 = (char *)tmp___0;
#line 2814
  tmp___1 = ldv_zalloc(48UL);
#line 2814
  ldvarg393 = (struct device_attribute *)tmp___1;
#line 2816
  tmp___2 = __VERIFIER_nondet_int();
#line 2816
  switch (tmp___2) {
  case 0: ;
#line 2819
  if (ldv_state_variable_28 == 1) {
#line 2821
    qla2x00_vlan_id_show(ldvarg391, ldvarg393, ldvarg392);
#line 2823
    ldv_state_variable_28 = 1;
  } else {

  }
#line 2826
  goto ldv_61742;
  default: 
#line 2827
  ldv_stop();
  }
  ldv_61742: ;
#line 2831
  return;
}
}
#line 2833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_57(void) 
{ 
  size_t ldvarg103 ;
  size_t tmp ;
  char *ldvarg107 ;
  void *tmp___0 ;
  loff_t ldvarg105 ;
  loff_t tmp___1 ;
  size_t ldvarg106 ;
  size_t tmp___2 ;
  loff_t ldvarg108 ;
  loff_t tmp___3 ;
  char *ldvarg104 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 2834
  tmp = __VERIFIER_nondet_size_t();
#line 2834
  ldvarg103 = tmp;
#line 2835
  tmp___0 = ldv_zalloc(1UL);
#line 2835
  ldvarg107 = (char *)tmp___0;
#line 2836
  tmp___1 = __VERIFIER_nondet_loff_t();
#line 2836
  ldvarg105 = tmp___1;
#line 2837
  tmp___2 = __VERIFIER_nondet_size_t();
#line 2837
  ldvarg106 = tmp___2;
#line 2838
  tmp___3 = __VERIFIER_nondet_loff_t();
#line 2838
  ldvarg108 = tmp___3;
#line 2839
  tmp___4 = ldv_zalloc(1UL);
#line 2839
  ldvarg104 = (char *)tmp___4;
#line 2841
  tmp___5 = __VERIFIER_nondet_int();
#line 2841
  switch (tmp___5) {
  case 0: ;
#line 2844
  if (ldv_state_variable_57 == 2) {
#line 2846
    qla2x00_sysfs_write_optrom(sysfs_optrom_attr_group0, sysfs_optrom_attr_group2,
                               sysfs_optrom_attr_group1, ldvarg107, ldvarg108, ldvarg106);
#line 2848
    ldv_state_variable_57 = 2;
  } else {

  }
#line 2851
  goto ldv_61754;
  case 1: ;
#line 2854
  if (ldv_state_variable_57 == 2) {
#line 2856
    qla2x00_sysfs_read_optrom(sysfs_optrom_attr_group0, sysfs_optrom_attr_group2,
                              sysfs_optrom_attr_group1, ldvarg104, ldvarg105, ldvarg103);
#line 2858
    ldv_state_variable_57 = 2;
  } else {

  }
#line 2861
  goto ldv_61754;
  case 2: ;
#line 2864
  if (ldv_state_variable_57 == 2) {
#line 2866
    ldv_release_57();
#line 2868
    ldv_state_variable_57 = 1;
#line 2869
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2872
  goto ldv_61754;
  case 3: ;
#line 2875
  if (ldv_state_variable_57 == 1) {
#line 2877
    ldv_probe_57();
#line 2879
    ldv_state_variable_57 = 2;
#line 2880
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2883
  goto ldv_61754;
  default: 
#line 2884
  ldv_stop();
  }
  ldv_61754: ;
#line 2888
  return;
}
}
#line 2890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_40(void) 
{ 
  char *ldvarg394 ;
  void *tmp ;
  char *ldvarg396 ;
  void *tmp___0 ;
  size_t ldvarg395 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2891
  tmp = ldv_zalloc(1UL);
#line 2891
  ldvarg394 = (char *)tmp;
#line 2892
  tmp___0 = ldv_zalloc(1UL);
#line 2892
  ldvarg396 = (char *)tmp___0;
#line 2893
  tmp___1 = __VERIFIER_nondet_size_t();
#line 2893
  ldvarg395 = tmp___1;
#line 2895
  tmp___2 = __VERIFIER_nondet_int();
#line 2895
  switch (tmp___2) {
  case 0: ;
#line 2898
  if (ldv_state_variable_40 == 1) {
#line 2900
    qla2x00_zio_timer_store(dev_attr_zio_timer_group0, dev_attr_zio_timer_group1,
                            (char const   *)ldvarg396, ldvarg395);
#line 2902
    ldv_state_variable_40 = 1;
  } else {

  }
#line 2905
  goto ldv_61766;
  case 1: ;
#line 2908
  if (ldv_state_variable_40 == 1) {
#line 2910
    qla2x00_zio_timer_show(dev_attr_zio_timer_group0, dev_attr_zio_timer_group1, ldvarg394);
#line 2912
    ldv_state_variable_40 = 1;
  } else {

  }
#line 2915
  goto ldv_61766;
  default: 
#line 2916
  ldv_stop();
  }
  ldv_61766: ;
#line 2920
  return;
}
}
#line 2922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  u32 ldvarg112 ;
  u32 tmp ;
  bool ldvarg110 ;
  bool ldvarg111 ;
  int tmp___0 ;

  {
#line 2923
  tmp = __VERIFIER_nondet_u32();
#line 2923
  ldvarg112 = tmp;
#line 2924
  memset((void *)(& ldvarg110), 0, 1UL);
#line 2925
  memset((void *)(& ldvarg111), 0, 1UL);
#line 2927
  tmp___0 = __VERIFIER_nondet_int();
#line 2927
  switch (tmp___0) {
  case 0: ;
#line 2930
  if (ldv_state_variable_20 == 1) {
#line 2932
    qla2x00_issue_lip(qla2xxx_transport_functions_group0);
#line 2934
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2937
  goto ldv_61776;
  case 1: ;
#line 2940
  if (ldv_state_variable_20 == 1) {
#line 2942
    qla2x00_set_rport_loss_tmo(qla2xxx_transport_functions_group2, ldvarg112);
#line 2944
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2947
  goto ldv_61776;
  case 2: ;
#line 2950
  if (ldv_state_variable_20 == 1) {
#line 2952
    qla2x00_get_fc_host_stats(qla2xxx_transport_functions_group0);
#line 2954
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2957
  goto ldv_61776;
  case 3: ;
#line 2960
  if (ldv_state_variable_20 == 1) {
#line 2962
    qla2x00_get_host_port_type(qla2xxx_transport_functions_group0);
#line 2964
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2967
  goto ldv_61776;
  case 4: ;
#line 2970
  if (ldv_state_variable_20 == 1) {
#line 2972
    qla24xx_bsg_timeout(qla2xxx_transport_functions_group1);
#line 2974
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2977
  goto ldv_61776;
  case 5: ;
#line 2980
  if (ldv_state_variable_20 == 1) {
#line 2982
    qla24xx_vport_delete(qla2xxx_transport_functions_group4);
#line 2984
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2987
  goto ldv_61776;
  case 6: ;
#line 2990
  if (ldv_state_variable_20 == 1) {
#line 2992
    qla24xx_bsg_request(qla2xxx_transport_functions_group1);
#line 2994
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2997
  goto ldv_61776;
  case 7: ;
#line 3000
  if (ldv_state_variable_20 == 1) {
#line 3002
    qla24xx_vport_disable(qla2xxx_transport_functions_group4, (int )ldvarg111);
#line 3004
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3007
  goto ldv_61776;
  case 8: ;
#line 3010
  if (ldv_state_variable_20 == 1) {
#line 3012
    qla2x00_terminate_rport_io(qla2xxx_transport_functions_group2);
#line 3014
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3017
  goto ldv_61776;
  case 9: ;
#line 3020
  if (ldv_state_variable_20 == 1) {
#line 3022
    qla2x00_get_host_port_state(qla2xxx_transport_functions_group0);
#line 3024
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3027
  goto ldv_61776;
  case 10: ;
#line 3030
  if (ldv_state_variable_20 == 1) {
#line 3032
    qla2x00_get_starget_node_name(qla2xxx_transport_functions_group3);
#line 3034
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3037
  goto ldv_61776;
  case 11: ;
#line 3040
  if (ldv_state_variable_20 == 1) {
#line 3042
    qla2x00_get_host_speed(qla2xxx_transport_functions_group0);
#line 3044
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3047
  goto ldv_61776;
  case 12: ;
#line 3050
  if (ldv_state_variable_20 == 1) {
#line 3052
    qla2x00_get_starget_port_id(qla2xxx_transport_functions_group3);
#line 3054
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3057
  goto ldv_61776;
  case 13: ;
#line 3060
  if (ldv_state_variable_20 == 1) {
#line 3062
    qla2x00_get_starget_port_name(qla2xxx_transport_functions_group3);
#line 3064
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3067
  goto ldv_61776;
  case 14: ;
#line 3070
  if (ldv_state_variable_20 == 1) {
#line 3072
    qla2x00_dev_loss_tmo_callbk(qla2xxx_transport_functions_group2);
#line 3074
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3077
  goto ldv_61776;
  case 15: ;
#line 3080
  if (ldv_state_variable_20 == 1) {
#line 3082
    qla2x00_reset_host_stats(qla2xxx_transport_functions_group0);
#line 3084
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3087
  goto ldv_61776;
  case 16: ;
#line 3090
  if (ldv_state_variable_20 == 1) {
#line 3092
    qla2x00_get_host_symbolic_name(qla2xxx_transport_functions_group0);
#line 3094
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3097
  goto ldv_61776;
  case 17: ;
#line 3100
  if (ldv_state_variable_20 == 1) {
#line 3102
    qla24xx_vport_create(qla2xxx_transport_functions_group4, (int )ldvarg110);
#line 3104
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3107
  goto ldv_61776;
  case 18: ;
#line 3110
  if (ldv_state_variable_20 == 1) {
#line 3112
    qla2x00_set_host_system_hostname(qla2xxx_transport_functions_group0);
#line 3114
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3117
  goto ldv_61776;
  case 19: ;
#line 3120
  if (ldv_state_variable_20 == 1) {
#line 3122
    qla2x00_get_host_fabric_name(qla2xxx_transport_functions_group0);
#line 3124
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3127
  goto ldv_61776;
  case 20: ;
#line 3130
  if (ldv_state_variable_20 == 1) {
#line 3132
    qla2x00_get_host_port_id(qla2xxx_transport_functions_group0);
#line 3134
    ldv_state_variable_20 = 1;
  } else {

  }
#line 3137
  goto ldv_61776;
  default: 
#line 3138
  ldv_stop();
  }
  ldv_61776: ;
#line 3142
  return;
}
}
#line 3144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_59(void) 
{ 
  char *ldvarg437 ;
  void *tmp ;
  size_t ldvarg436 ;
  size_t tmp___0 ;
  char *ldvarg440 ;
  void *tmp___1 ;
  loff_t ldvarg438 ;
  loff_t tmp___2 ;
  size_t ldvarg439 ;
  size_t tmp___3 ;
  loff_t ldvarg441 ;
  loff_t tmp___4 ;
  int tmp___5 ;

  {
#line 3145
  tmp = ldv_zalloc(1UL);
#line 3145
  ldvarg437 = (char *)tmp;
#line 3146
  tmp___0 = __VERIFIER_nondet_size_t();
#line 3146
  ldvarg436 = tmp___0;
#line 3147
  tmp___1 = ldv_zalloc(1UL);
#line 3147
  ldvarg440 = (char *)tmp___1;
#line 3148
  tmp___2 = __VERIFIER_nondet_loff_t();
#line 3148
  ldvarg438 = tmp___2;
#line 3149
  tmp___3 = __VERIFIER_nondet_size_t();
#line 3149
  ldvarg439 = tmp___3;
#line 3150
  tmp___4 = __VERIFIER_nondet_loff_t();
#line 3150
  ldvarg441 = tmp___4;
#line 3152
  tmp___5 = __VERIFIER_nondet_int();
#line 3152
  switch (tmp___5) {
  case 0: ;
#line 3155
  if (ldv_state_variable_59 == 2) {
#line 3157
    qla2x00_sysfs_write_fw_dump(sysfs_fw_dump_attr_group0, sysfs_fw_dump_attr_group2,
                                sysfs_fw_dump_attr_group1, ldvarg440, ldvarg441, ldvarg439);
#line 3159
    ldv_state_variable_59 = 2;
  } else {

  }
#line 3162
  goto ldv_61808;
  case 1: ;
#line 3165
  if (ldv_state_variable_59 == 2) {
#line 3167
    qla2x00_sysfs_read_fw_dump(sysfs_fw_dump_attr_group0, sysfs_fw_dump_attr_group2,
                               sysfs_fw_dump_attr_group1, ldvarg437, ldvarg438, ldvarg436);
#line 3169
    ldv_state_variable_59 = 2;
  } else {

  }
#line 3172
  goto ldv_61808;
  case 2: ;
#line 3175
  if (ldv_state_variable_59 == 2) {
#line 3177
    ldv_release_59();
#line 3179
    ldv_state_variable_59 = 1;
#line 3180
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3183
  goto ldv_61808;
  case 3: ;
#line 3186
  if (ldv_state_variable_59 == 1) {
#line 3188
    ldv_probe_59();
#line 3190
    ldv_state_variable_59 = 2;
#line 3191
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3194
  goto ldv_61808;
  default: 
#line 3195
  ldv_stop();
  }
  ldv_61808: ;
#line 3199
  return;
}
}
#line 3201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_49(void) 
{ 
  struct device *ldvarg442 ;
  void *tmp ;
  char *ldvarg443 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg444 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3202
  tmp = ldv_zalloc(1376UL);
#line 3202
  ldvarg442 = (struct device *)tmp;
#line 3203
  tmp___0 = ldv_zalloc(1UL);
#line 3203
  ldvarg443 = (char *)tmp___0;
#line 3204
  tmp___1 = ldv_zalloc(48UL);
#line 3204
  ldvarg444 = (struct device_attribute *)tmp___1;
#line 3206
  tmp___2 = __VERIFIER_nondet_int();
#line 3206
  switch (tmp___2) {
  case 0: ;
#line 3209
  if (ldv_state_variable_49 == 1) {
#line 3211
    qla2x00_fw_version_show(ldvarg442, ldvarg444, ldvarg443);
#line 3213
    ldv_state_variable_49 = 1;
  } else {

  }
#line 3216
  goto ldv_61820;
  default: 
#line 3217
  ldv_stop();
  }
  ldv_61820: ;
#line 3221
  return;
}
}
#line 3223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  char *ldvarg446 ;
  void *tmp ;
  struct device *ldvarg445 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg447 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3224
  tmp = ldv_zalloc(1UL);
#line 3224
  ldvarg446 = (char *)tmp;
#line 3225
  tmp___0 = ldv_zalloc(1376UL);
#line 3225
  ldvarg445 = (struct device *)tmp___0;
#line 3226
  tmp___1 = ldv_zalloc(48UL);
#line 3226
  ldvarg447 = (struct device_attribute *)tmp___1;
#line 3228
  tmp___2 = __VERIFIER_nondet_int();
#line 3228
  switch (tmp___2) {
  case 0: ;
#line 3231
  if (ldv_state_variable_24 == 1) {
#line 3233
    qla2x00_thermal_temp_show(ldvarg445, ldvarg447, ldvarg446);
#line 3235
    ldv_state_variable_24 = 1;
  } else {

  }
#line 3238
  goto ldv_61829;
  default: 
#line 3239
  ldv_stop();
  }
  ldv_61829: ;
#line 3243
  return;
}
}
#line 3246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  struct device_attribute *ldvarg115 ;
  void *tmp ;
  char *ldvarg114 ;
  void *tmp___0 ;
  struct device *ldvarg113 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3247
  tmp = ldv_zalloc(48UL);
#line 3247
  ldvarg115 = (struct device_attribute *)tmp;
#line 3248
  tmp___0 = ldv_zalloc(1UL);
#line 3248
  ldvarg114 = (char *)tmp___0;
#line 3249
  tmp___1 = ldv_zalloc(1376UL);
#line 3249
  ldvarg113 = (struct device *)tmp___1;
#line 3251
  tmp___2 = __VERIFIER_nondet_int();
#line 3251
  switch (tmp___2) {
  case 0: ;
#line 3254
  if (ldv_state_variable_31 == 1) {
#line 3256
    qla2x00_mpi_version_show(ldvarg113, ldvarg115, ldvarg114);
#line 3258
    ldv_state_variable_31 = 1;
  } else {

  }
#line 3261
  goto ldv_61838;
  default: 
#line 3262
  ldv_stop();
  }
  ldv_61838: ;
#line 3266
  return;
}
}
#line 3268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  struct device_attribute *ldvarg118 ;
  void *tmp ;
  char *ldvarg117 ;
  void *tmp___0 ;
  struct device *ldvarg116 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3269
  tmp = ldv_zalloc(48UL);
#line 3269
  ldvarg118 = (struct device_attribute *)tmp;
#line 3270
  tmp___0 = ldv_zalloc(1UL);
#line 3270
  ldvarg117 = (char *)tmp___0;
#line 3271
  tmp___1 = ldv_zalloc(1376UL);
#line 3271
  ldvarg116 = (struct device *)tmp___1;
#line 3273
  tmp___2 = __VERIFIER_nondet_int();
#line 3273
  switch (tmp___2) {
  case 0: ;
#line 3276
  if (ldv_state_variable_35 == 1) {
#line 3278
    qla2x00_optrom_fw_version_show(ldvarg116, ldvarg118, ldvarg117);
#line 3280
    ldv_state_variable_35 = 1;
  } else {

  }
#line 3283
  goto ldv_61847;
  default: 
#line 3284
  ldv_stop();
  }
  ldv_61847: ;
#line 3288
  return;
}
}
#line 3290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_53(void) 
{ 
  struct bin_attribute *ldvarg451 ;
  void *tmp ;
  struct file *ldvarg450 ;
  void *tmp___0 ;
  char *ldvarg449 ;
  void *tmp___1 ;
  struct kobject *ldvarg452 ;
  void *tmp___2 ;
  loff_t ldvarg453 ;
  loff_t tmp___3 ;
  size_t ldvarg448 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 3291
  tmp = ldv_zalloc(72UL);
#line 3291
  ldvarg451 = (struct bin_attribute *)tmp;
#line 3292
  tmp___0 = ldv_zalloc(360UL);
#line 3292
  ldvarg450 = (struct file *)tmp___0;
#line 3293
  tmp___1 = ldv_zalloc(1UL);
#line 3293
  ldvarg449 = (char *)tmp___1;
#line 3294
  tmp___2 = ldv_zalloc(296UL);
#line 3294
  ldvarg452 = (struct kobject *)tmp___2;
#line 3295
  tmp___3 = __VERIFIER_nondet_loff_t();
#line 3295
  ldvarg453 = tmp___3;
#line 3296
  tmp___4 = __VERIFIER_nondet_size_t();
#line 3296
  ldvarg448 = tmp___4;
#line 3298
  tmp___5 = __VERIFIER_nondet_int();
#line 3298
  switch (tmp___5) {
  case 0: ;
#line 3301
  if (ldv_state_variable_53 == 2) {
#line 3303
    qla2x00_sysfs_write_reset(ldvarg450, ldvarg452, ldvarg451, ldvarg449, ldvarg453,
                              ldvarg448);
#line 3305
    ldv_state_variable_53 = 2;
  } else {

  }
#line 3308
  goto ldv_61859;
  case 1: ;
#line 3311
  if (ldv_state_variable_53 == 2) {
#line 3313
    ldv_release_53();
#line 3315
    ldv_state_variable_53 = 1;
#line 3316
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3319
  goto ldv_61859;
  case 2: ;
#line 3322
  if (ldv_state_variable_53 == 1) {
#line 3324
    ldv_probe_53();
#line 3326
    ldv_state_variable_53 = 2;
#line 3327
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3330
  goto ldv_61859;
  default: 
#line 3331
  ldv_stop();
  }
  ldv_61859: ;
#line 3335
  return;
}
}
#line 3337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_48(void) 
{ 
  struct device *ldvarg119 ;
  void *tmp ;
  char *ldvarg120 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg121 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3338
  tmp = ldv_zalloc(1376UL);
#line 3338
  ldvarg119 = (struct device *)tmp;
#line 3339
  tmp___0 = ldv_zalloc(1UL);
#line 3339
  ldvarg120 = (char *)tmp___0;
#line 3340
  tmp___1 = ldv_zalloc(48UL);
#line 3340
  ldvarg121 = (struct device_attribute *)tmp___1;
#line 3342
  tmp___2 = __VERIFIER_nondet_int();
#line 3342
  switch (tmp___2) {
  case 0: ;
#line 3345
  if (ldv_state_variable_48 == 1) {
#line 3347
    qla2x00_serial_num_show(ldvarg119, ldvarg121, ldvarg120);
#line 3349
    ldv_state_variable_48 = 1;
  } else {

  }
#line 3352
  goto ldv_61870;
  default: 
#line 3353
  ldv_stop();
  }
  ldv_61870: ;
#line 3357
  return;
}
}
#line 3359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct device *ldvarg454 ;
  void *tmp ;
  char *ldvarg455 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg456 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3360
  tmp = ldv_zalloc(1376UL);
#line 3360
  ldvarg454 = (struct device *)tmp;
#line 3361
  tmp___0 = ldv_zalloc(1UL);
#line 3361
  ldvarg455 = (char *)tmp___0;
#line 3362
  tmp___1 = ldv_zalloc(48UL);
#line 3362
  ldvarg456 = (struct device_attribute *)tmp___1;
#line 3364
  tmp___2 = __VERIFIER_nondet_int();
#line 3364
  switch (tmp___2) {
  case 0: ;
#line 3367
  if (ldv_state_variable_22 == 1) {
#line 3369
    qla2x00_diag_megabytes_show(ldvarg454, ldvarg456, ldvarg455);
#line 3371
    ldv_state_variable_22 = 1;
  } else {

  }
#line 3374
  goto ldv_61879;
  default: 
#line 3375
  ldv_stop();
  }
  ldv_61879: ;
#line 3379
  return;
}
}
#line 3381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_42(void) 
{ 
  struct device *ldvarg457 ;
  void *tmp ;
  struct device_attribute *ldvarg459 ;
  void *tmp___0 ;
  char *ldvarg458 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3382
  tmp = ldv_zalloc(1376UL);
#line 3382
  ldvarg457 = (struct device *)tmp;
#line 3383
  tmp___0 = ldv_zalloc(48UL);
#line 3383
  ldvarg459 = (struct device_attribute *)tmp___0;
#line 3384
  tmp___1 = ldv_zalloc(1UL);
#line 3384
  ldvarg458 = (char *)tmp___1;
#line 3386
  tmp___2 = __VERIFIER_nondet_int();
#line 3386
  switch (tmp___2) {
  case 0: ;
#line 3389
  if (ldv_state_variable_42 == 1) {
#line 3391
    qla2x00_link_state_show(ldvarg457, ldvarg459, ldvarg458);
#line 3393
    ldv_state_variable_42 = 1;
  } else {

  }
#line 3396
  goto ldv_61888;
  default: 
#line 3397
  ldv_stop();
  }
  ldv_61888: ;
#line 3401
  return;
}
}
#line 3403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_46(void) 
{ 
  struct device_attribute *ldvarg462 ;
  void *tmp ;
  char *ldvarg461 ;
  void *tmp___0 ;
  struct device *ldvarg460 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3404
  tmp = ldv_zalloc(48UL);
#line 3404
  ldvarg462 = (struct device_attribute *)tmp;
#line 3405
  tmp___0 = ldv_zalloc(1UL);
#line 3405
  ldvarg461 = (char *)tmp___0;
#line 3406
  tmp___1 = ldv_zalloc(1376UL);
#line 3406
  ldvarg460 = (struct device *)tmp___1;
#line 3408
  tmp___2 = __VERIFIER_nondet_int();
#line 3408
  switch (tmp___2) {
  case 0: ;
#line 3411
  if (ldv_state_variable_46 == 1) {
#line 3413
    qla2x00_isp_id_show(ldvarg460, ldvarg462, ldvarg461);
#line 3415
    ldv_state_variable_46 = 1;
  } else {

  }
#line 3418
  goto ldv_61897;
  default: 
#line 3419
  ldv_stop();
  }
  ldv_61897: ;
#line 3423
  return;
}
}
#line 3425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  char *ldvarg464 ;
  void *tmp ;
  struct device *ldvarg463 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg465 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3426
  tmp = ldv_zalloc(1UL);
#line 3426
  ldvarg464 = (char *)tmp;
#line 3427
  tmp___0 = ldv_zalloc(1376UL);
#line 3427
  ldvarg463 = (struct device *)tmp___0;
#line 3428
  tmp___1 = ldv_zalloc(48UL);
#line 3428
  ldvarg465 = (struct device_attribute *)tmp___1;
#line 3430
  tmp___2 = __VERIFIER_nondet_int();
#line 3430
  switch (tmp___2) {
  case 0: ;
#line 3433
  if (ldv_state_variable_23 == 1) {
#line 3435
    qla2x00_diag_requests_show(ldvarg463, ldvarg465, ldvarg464);
#line 3437
    ldv_state_variable_23 = 1;
  } else {

  }
#line 3440
  goto ldv_61906;
  default: 
#line 3441
  ldv_stop();
  }
  ldv_61906: ;
#line 3445
  return;
}
}
#line 3447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_29(void) 
{ 
  struct device *ldvarg155 ;
  void *tmp ;
  struct device_attribute *ldvarg157 ;
  void *tmp___0 ;
  char *ldvarg156 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3448
  tmp = ldv_zalloc(1376UL);
#line 3448
  ldvarg155 = (struct device *)tmp;
#line 3449
  tmp___0 = ldv_zalloc(48UL);
#line 3449
  ldvarg157 = (struct device_attribute *)tmp___0;
#line 3450
  tmp___1 = ldv_zalloc(1UL);
#line 3450
  ldvarg156 = (char *)tmp___1;
#line 3452
  tmp___2 = __VERIFIER_nondet_int();
#line 3452
  switch (tmp___2) {
  case 0: ;
#line 3455
  if (ldv_state_variable_29 == 1) {
#line 3457
    qla2x00_flash_block_size_show(ldvarg155, ldvarg157, ldvarg156);
#line 3459
    ldv_state_variable_29 = 1;
  } else {

  }
#line 3462
  goto ldv_61915;
  default: 
#line 3463
  ldv_stop();
  }
  ldv_61915: ;
#line 3467
  return;
}
}
#line 3469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_50(void) 
{ 
  struct device *ldvarg158 ;
  void *tmp ;
  struct device_attribute *ldvarg160 ;
  void *tmp___0 ;
  char *ldvarg159 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3470
  tmp = ldv_zalloc(1376UL);
#line 3470
  ldvarg158 = (struct device *)tmp;
#line 3471
  tmp___0 = ldv_zalloc(48UL);
#line 3471
  ldvarg160 = (struct device_attribute *)tmp___0;
#line 3472
  tmp___1 = ldv_zalloc(1UL);
#line 3472
  ldvarg159 = (char *)tmp___1;
#line 3474
  tmp___2 = __VERIFIER_nondet_int();
#line 3474
  switch (tmp___2) {
  case 0: ;
#line 3477
  if (ldv_state_variable_50 == 1) {
#line 3479
    qla2x00_drvr_version_show(ldvarg158, ldvarg160, ldvarg159);
#line 3481
    ldv_state_variable_50 = 1;
  } else {

  }
#line 3484
  goto ldv_61924;
  default: 
#line 3485
  ldv_stop();
  }
  ldv_61924: ;
#line 3489
  return;
}
}
#line 3491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_39(void) 
{ 
  char *ldvarg161 ;
  void *tmp ;
  size_t ldvarg162 ;
  size_t tmp___0 ;
  char *ldvarg163 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3492
  tmp = ldv_zalloc(1UL);
#line 3492
  ldvarg161 = (char *)tmp;
#line 3493
  tmp___0 = __VERIFIER_nondet_size_t();
#line 3493
  ldvarg162 = tmp___0;
#line 3494
  tmp___1 = ldv_zalloc(1UL);
#line 3494
  ldvarg163 = (char *)tmp___1;
#line 3496
  tmp___2 = __VERIFIER_nondet_int();
#line 3496
  switch (tmp___2) {
  case 0: ;
#line 3499
  if (ldv_state_variable_39 == 1) {
#line 3501
    qla2x00_beacon_store(dev_attr_beacon_group0, dev_attr_beacon_group1, (char const   *)ldvarg163,
                         ldvarg162);
#line 3503
    ldv_state_variable_39 = 1;
  } else {

  }
#line 3506
  goto ldv_61933;
  case 1: ;
#line 3509
  if (ldv_state_variable_39 == 1) {
#line 3511
    qla2x00_beacon_show(dev_attr_beacon_group0, dev_attr_beacon_group1, ldvarg161);
#line 3513
    ldv_state_variable_39 = 1;
  } else {

  }
#line 3516
  goto ldv_61933;
  default: 
#line 3517
  ldv_stop();
  }
  ldv_61933: ;
#line 3521
  return;
}
}
#line 3523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_36(void) 
{ 
  struct device *ldvarg466 ;
  void *tmp ;
  struct device_attribute *ldvarg468 ;
  void *tmp___0 ;
  char *ldvarg467 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3524
  tmp = ldv_zalloc(1376UL);
#line 3524
  ldvarg466 = (struct device *)tmp;
#line 3525
  tmp___0 = ldv_zalloc(48UL);
#line 3525
  ldvarg468 = (struct device_attribute *)tmp___0;
#line 3526
  tmp___1 = ldv_zalloc(1UL);
#line 3526
  ldvarg467 = (char *)tmp___1;
#line 3528
  tmp___2 = __VERIFIER_nondet_int();
#line 3528
  switch (tmp___2) {
  case 0: ;
#line 3531
  if (ldv_state_variable_36 == 1) {
#line 3533
    qla2x00_optrom_fcode_version_show(ldvarg466, ldvarg468, ldvarg467);
#line 3535
    ldv_state_variable_36 = 1;
  } else {

  }
#line 3538
  goto ldv_61943;
  default: 
#line 3539
  ldv_stop();
  }
  ldv_61943: ;
#line 3543
  return;
}
}
#line 3545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_51(void) 
{ 
  struct kobject *ldvarg473 ;
  void *tmp ;
  char *ldvarg470 ;
  void *tmp___0 ;
  struct bin_attribute *ldvarg472 ;
  void *tmp___1 ;
  struct file *ldvarg471 ;
  void *tmp___2 ;
  loff_t ldvarg474 ;
  loff_t tmp___3 ;
  size_t ldvarg469 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 3546
  tmp = ldv_zalloc(296UL);
#line 3546
  ldvarg473 = (struct kobject *)tmp;
#line 3547
  tmp___0 = ldv_zalloc(1UL);
#line 3547
  ldvarg470 = (char *)tmp___0;
#line 3548
  tmp___1 = ldv_zalloc(72UL);
#line 3548
  ldvarg472 = (struct bin_attribute *)tmp___1;
#line 3549
  tmp___2 = ldv_zalloc(360UL);
#line 3549
  ldvarg471 = (struct file *)tmp___2;
#line 3550
  tmp___3 = __VERIFIER_nondet_loff_t();
#line 3550
  ldvarg474 = tmp___3;
#line 3551
  tmp___4 = __VERIFIER_nondet_size_t();
#line 3551
  ldvarg469 = tmp___4;
#line 3553
  tmp___5 = __VERIFIER_nondet_int();
#line 3553
  switch (tmp___5) {
  case 0: ;
#line 3556
  if (ldv_state_variable_51 == 2) {
#line 3558
    qla2x00_sysfs_read_dcbx_tlv(ldvarg471, ldvarg473, ldvarg472, ldvarg470, ldvarg474,
                                ldvarg469);
#line 3560
    ldv_state_variable_51 = 2;
  } else {

  }
#line 3563
  goto ldv_61955;
  case 1: ;
#line 3566
  if (ldv_state_variable_51 == 2) {
#line 3568
    ldv_release_51();
#line 3570
    ldv_state_variable_51 = 1;
#line 3571
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3574
  goto ldv_61955;
  case 2: ;
#line 3577
  if (ldv_state_variable_51 == 1) {
#line 3579
    ldv_probe_51();
#line 3581
    ldv_state_variable_51 = 2;
#line 3582
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3585
  goto ldv_61955;
  default: 
#line 3586
  ldv_stop();
  }
  ldv_61955: ;
#line 3590
  return;
}
}
#line 3592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_58(void) 
{ 
  loff_t ldvarg202 ;
  loff_t tmp ;
  char *ldvarg201 ;
  void *tmp___0 ;
  loff_t ldvarg199 ;
  loff_t tmp___1 ;
  char *ldvarg198 ;
  void *tmp___2 ;
  size_t ldvarg197 ;
  size_t tmp___3 ;
  size_t ldvarg200 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 3593
  tmp = __VERIFIER_nondet_loff_t();
#line 3593
  ldvarg202 = tmp;
#line 3594
  tmp___0 = ldv_zalloc(1UL);
#line 3594
  ldvarg201 = (char *)tmp___0;
#line 3595
  tmp___1 = __VERIFIER_nondet_loff_t();
#line 3595
  ldvarg199 = tmp___1;
#line 3596
  tmp___2 = ldv_zalloc(1UL);
#line 3596
  ldvarg198 = (char *)tmp___2;
#line 3597
  tmp___3 = __VERIFIER_nondet_size_t();
#line 3597
  ldvarg197 = tmp___3;
#line 3598
  tmp___4 = __VERIFIER_nondet_size_t();
#line 3598
  ldvarg200 = tmp___4;
#line 3600
  tmp___5 = __VERIFIER_nondet_int();
#line 3600
  switch (tmp___5) {
  case 0: ;
#line 3603
  if (ldv_state_variable_58 == 2) {
#line 3605
    qla2x00_sysfs_write_nvram(sysfs_nvram_attr_group0, sysfs_nvram_attr_group2, sysfs_nvram_attr_group1,
                              ldvarg201, ldvarg202, ldvarg200);
#line 3607
    ldv_state_variable_58 = 2;
  } else {

  }
#line 3610
  goto ldv_61969;
  case 1: ;
#line 3613
  if (ldv_state_variable_58 == 2) {
#line 3615
    qla2x00_sysfs_read_nvram(sysfs_nvram_attr_group0, sysfs_nvram_attr_group2, sysfs_nvram_attr_group1,
                             ldvarg198, ldvarg199, ldvarg197);
#line 3617
    ldv_state_variable_58 = 2;
  } else {

  }
#line 3620
  goto ldv_61969;
  case 2: ;
#line 3623
  if (ldv_state_variable_58 == 2) {
#line 3625
    ldv_release_58();
#line 3627
    ldv_state_variable_58 = 1;
#line 3628
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3631
  goto ldv_61969;
  case 3: ;
#line 3634
  if (ldv_state_variable_58 == 1) {
#line 3636
    ldv_probe_58();
#line 3638
    ldv_state_variable_58 = 2;
#line 3639
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3642
  goto ldv_61969;
  default: 
#line 3643
  ldv_stop();
  }
  ldv_61969: ;
#line 3647
  return;
}
}
#line 3649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_41(void) 
{ 
  char *ldvarg205 ;
  void *tmp ;
  char *ldvarg203 ;
  void *tmp___0 ;
  size_t ldvarg204 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 3650
  tmp = ldv_zalloc(1UL);
#line 3650
  ldvarg205 = (char *)tmp;
#line 3651
  tmp___0 = ldv_zalloc(1UL);
#line 3651
  ldvarg203 = (char *)tmp___0;
#line 3652
  tmp___1 = __VERIFIER_nondet_size_t();
#line 3652
  ldvarg204 = tmp___1;
#line 3654
  tmp___2 = __VERIFIER_nondet_int();
#line 3654
  switch (tmp___2) {
  case 0: ;
#line 3657
  if (ldv_state_variable_41 == 1) {
#line 3659
    qla2x00_zio_store(dev_attr_zio_group0, dev_attr_zio_group1, (char const   *)ldvarg205,
                      ldvarg204);
#line 3661
    ldv_state_variable_41 = 1;
  } else {

  }
#line 3664
  goto ldv_61981;
  case 1: ;
#line 3667
  if (ldv_state_variable_41 == 1) {
#line 3669
    qla2x00_zio_show(dev_attr_zio_group0, dev_attr_zio_group1, ldvarg203);
#line 3671
    ldv_state_variable_41 = 1;
  } else {

  }
#line 3674
  goto ldv_61981;
  default: 
#line 3675
  ldv_stop();
  }
  ldv_61981: ;
#line 3679
  return;
}
}
#line 3681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_47(void) 
{ 
  char *ldvarg476 ;
  void *tmp ;
  struct device *ldvarg475 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg477 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3682
  tmp = ldv_zalloc(1UL);
#line 3682
  ldvarg476 = (char *)tmp;
#line 3683
  tmp___0 = ldv_zalloc(1376UL);
#line 3683
  ldvarg475 = (struct device *)tmp___0;
#line 3684
  tmp___1 = ldv_zalloc(48UL);
#line 3684
  ldvarg477 = (struct device_attribute *)tmp___1;
#line 3686
  tmp___2 = __VERIFIER_nondet_int();
#line 3686
  switch (tmp___2) {
  case 0: ;
#line 3689
  if (ldv_state_variable_47 == 1) {
#line 3691
    qla2x00_isp_name_show(ldvarg475, ldvarg477, ldvarg476);
#line 3693
    ldv_state_variable_47 = 1;
  } else {

  }
#line 3696
  goto ldv_61991;
  default: 
#line 3697
  ldv_stop();
  }
  ldv_61991: ;
#line 3701
  return;
}
}
#line 3703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_38(void) 
{ 
  char *ldvarg479 ;
  void *tmp ;
  struct device_attribute *ldvarg480 ;
  void *tmp___0 ;
  struct device *ldvarg478 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3704
  tmp = ldv_zalloc(1UL);
#line 3704
  ldvarg479 = (char *)tmp;
#line 3705
  tmp___0 = ldv_zalloc(48UL);
#line 3705
  ldvarg480 = (struct device_attribute *)tmp___0;
#line 3706
  tmp___1 = ldv_zalloc(1376UL);
#line 3706
  ldvarg478 = (struct device *)tmp___1;
#line 3708
  tmp___2 = __VERIFIER_nondet_int();
#line 3708
  switch (tmp___2) {
  case 0: ;
#line 3711
  if (ldv_state_variable_38 == 1) {
#line 3713
    qla2x00_optrom_bios_version_show(ldvarg478, ldvarg480, ldvarg479);
#line 3715
    ldv_state_variable_38 = 1;
  } else {

  }
#line 3718
  goto ldv_62000;
  default: 
#line 3719
  ldv_stop();
  }
  ldv_62000: ;
#line 3723
  return;
}
}
#line 3725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_52(void) 
{ 
  struct kobject *ldvarg210 ;
  void *tmp ;
  size_t ldvarg206 ;
  size_t tmp___0 ;
  char *ldvarg207 ;
  void *tmp___1 ;
  struct file *ldvarg208 ;
  void *tmp___2 ;
  loff_t ldvarg211 ;
  loff_t tmp___3 ;
  struct bin_attribute *ldvarg209 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 3726
  tmp = ldv_zalloc(296UL);
#line 3726
  ldvarg210 = (struct kobject *)tmp;
#line 3727
  tmp___0 = __VERIFIER_nondet_size_t();
#line 3727
  ldvarg206 = tmp___0;
#line 3728
  tmp___1 = ldv_zalloc(1UL);
#line 3728
  ldvarg207 = (char *)tmp___1;
#line 3729
  tmp___2 = ldv_zalloc(360UL);
#line 3729
  ldvarg208 = (struct file *)tmp___2;
#line 3730
  tmp___3 = __VERIFIER_nondet_loff_t();
#line 3730
  ldvarg211 = tmp___3;
#line 3731
  tmp___4 = ldv_zalloc(72UL);
#line 3731
  ldvarg209 = (struct bin_attribute *)tmp___4;
#line 3733
  tmp___5 = __VERIFIER_nondet_int();
#line 3733
  switch (tmp___5) {
  case 0: ;
#line 3736
  if (ldv_state_variable_52 == 2) {
#line 3738
    qla2x00_sysfs_read_xgmac_stats(ldvarg208, ldvarg210, ldvarg209, ldvarg207, ldvarg211,
                                   ldvarg206);
#line 3740
    ldv_state_variable_52 = 2;
  } else {

  }
#line 3743
  goto ldv_62012;
  case 1: ;
#line 3746
  if (ldv_state_variable_52 == 2) {
#line 3748
    ldv_release_52();
#line 3750
    ldv_state_variable_52 = 1;
#line 3751
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3754
  goto ldv_62012;
  case 2: ;
#line 3757
  if (ldv_state_variable_52 == 1) {
#line 3759
    ldv_probe_52();
#line 3761
    ldv_state_variable_52 = 2;
#line 3762
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3765
  goto ldv_62012;
  default: 
#line 3766
  ldv_stop();
  }
  ldv_62012: ;
#line 3770
  return;
}
}
#line 3772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  struct device_attribute *ldvarg483 ;
  void *tmp ;
  char *ldvarg482 ;
  void *tmp___0 ;
  struct device *ldvarg481 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3773
  tmp = ldv_zalloc(48UL);
#line 3773
  ldvarg483 = (struct device_attribute *)tmp;
#line 3774
  tmp___0 = ldv_zalloc(1UL);
#line 3774
  ldvarg482 = (char *)tmp___0;
#line 3775
  tmp___1 = ldv_zalloc(1376UL);
#line 3775
  ldvarg481 = (struct device *)tmp___1;
#line 3777
  tmp___2 = __VERIFIER_nondet_int();
#line 3777
  switch (tmp___2) {
  case 0: ;
#line 3780
  if (ldv_state_variable_34 == 1) {
#line 3782
    qla2x00_optrom_gold_fw_version_show(ldvarg481, ldvarg483, ldvarg482);
#line 3784
    ldv_state_variable_34 = 1;
  } else {

  }
#line 3787
  goto ldv_62023;
  default: 
#line 3788
  ldv_stop();
  }
  ldv_62023: ;
#line 3792
  return;
}
}
#line 3794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_56(void) 
{ 
  struct file *ldvarg216 ;
  void *tmp ;
  loff_t ldvarg219 ;
  loff_t tmp___0 ;
  size_t ldvarg214 ;
  size_t tmp___1 ;
  struct bin_attribute *ldvarg217 ;
  void *tmp___2 ;
  struct kobject *ldvarg218 ;
  void *tmp___3 ;
  char *ldvarg215 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 3795
  tmp = ldv_zalloc(360UL);
#line 3795
  ldvarg216 = (struct file *)tmp;
#line 3796
  tmp___0 = __VERIFIER_nondet_loff_t();
#line 3796
  ldvarg219 = tmp___0;
#line 3797
  tmp___1 = __VERIFIER_nondet_size_t();
#line 3797
  ldvarg214 = tmp___1;
#line 3798
  tmp___2 = ldv_zalloc(72UL);
#line 3798
  ldvarg217 = (struct bin_attribute *)tmp___2;
#line 3799
  tmp___3 = ldv_zalloc(296UL);
#line 3799
  ldvarg218 = (struct kobject *)tmp___3;
#line 3800
  tmp___4 = ldv_zalloc(1UL);
#line 3800
  ldvarg215 = (char *)tmp___4;
#line 3802
  tmp___5 = __VERIFIER_nondet_int();
#line 3802
  switch (tmp___5) {
  case 0: ;
#line 3805
  if (ldv_state_variable_56 == 2) {
#line 3807
    qla2x00_sysfs_write_optrom_ctl(ldvarg216, ldvarg218, ldvarg217, ldvarg215, ldvarg219,
                                   ldvarg214);
#line 3809
    ldv_state_variable_56 = 2;
  } else {

  }
#line 3812
  goto ldv_62035;
  case 1: ;
#line 3815
  if (ldv_state_variable_56 == 2) {
#line 3817
    ldv_release_56();
#line 3819
    ldv_state_variable_56 = 1;
#line 3820
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3823
  goto ldv_62035;
  case 2: ;
#line 3826
  if (ldv_state_variable_56 == 1) {
#line 3828
    ldv_probe_56();
#line 3830
    ldv_state_variable_56 = 2;
#line 3831
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 3834
  goto ldv_62035;
  default: 
#line 3835
  ldv_stop();
  }
  ldv_62035: ;
#line 3839
  return;
}
}
#line 3841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_37(void) 
{ 
  struct device *ldvarg484 ;
  void *tmp ;
  struct device_attribute *ldvarg486 ;
  void *tmp___0 ;
  char *ldvarg485 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3842
  tmp = ldv_zalloc(1376UL);
#line 3842
  ldvarg484 = (struct device *)tmp;
#line 3843
  tmp___0 = ldv_zalloc(48UL);
#line 3843
  ldvarg486 = (struct device_attribute *)tmp___0;
#line 3844
  tmp___1 = ldv_zalloc(1UL);
#line 3844
  ldvarg485 = (char *)tmp___1;
#line 3846
  tmp___2 = __VERIFIER_nondet_int();
#line 3846
  switch (tmp___2) {
  case 0: ;
#line 3849
  if (ldv_state_variable_37 == 1) {
#line 3851
    qla2x00_optrom_efi_version_show(ldvarg484, ldvarg486, ldvarg485);
#line 3853
    ldv_state_variable_37 = 1;
  } else {

  }
#line 3856
  goto ldv_62046;
  default: 
#line 3857
  ldv_stop();
  }
  ldv_62046: ;
#line 3861
  return;
}
}
#line 3863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_45(void) 
{ 
  char *ldvarg260 ;
  void *tmp ;
  struct device_attribute *ldvarg261 ;
  void *tmp___0 ;
  struct device *ldvarg259 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 3864
  tmp = ldv_zalloc(1UL);
#line 3864
  ldvarg260 = (char *)tmp;
#line 3865
  tmp___0 = ldv_zalloc(48UL);
#line 3865
  ldvarg261 = (struct device_attribute *)tmp___0;
#line 3866
  tmp___1 = ldv_zalloc(1376UL);
#line 3866
  ldvarg259 = (struct device *)tmp___1;
#line 3868
  tmp___2 = __VERIFIER_nondet_int();
#line 3868
  switch (tmp___2) {
  case 0: ;
#line 3871
  if (ldv_state_variable_45 == 1) {
#line 3873
    qla2x00_model_name_show(ldvarg259, ldvarg261, ldvarg260);
#line 3875
    ldv_state_variable_45 = 1;
  } else {

  }
#line 3878
  goto ldv_62055;
  default: 
#line 3879
  ldv_stop();
  }
  ldv_62055: ;
#line 3883
  return;
}
}
#line 3885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  u32 ldvarg262 ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 3886
  tmp = __VERIFIER_nondet_u32();
#line 3886
  ldvarg262 = tmp;
#line 3888
  tmp___0 = __VERIFIER_nondet_int();
#line 3888
  switch (tmp___0) {
  case 0: ;
#line 3891
  if (ldv_state_variable_19 == 1) {
#line 3893
    qla2x00_issue_lip(qla2xxx_transport_vport_functions_group0);
#line 3895
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3898
  goto ldv_62062;
  case 1: ;
#line 3901
  if (ldv_state_variable_19 == 1) {
#line 3903
    qla2x00_set_rport_loss_tmo(qla2xxx_transport_vport_functions_group2, ldvarg262);
#line 3905
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3908
  goto ldv_62062;
  case 2: ;
#line 3911
  if (ldv_state_variable_19 == 1) {
#line 3913
    qla2x00_get_fc_host_stats(qla2xxx_transport_vport_functions_group0);
#line 3915
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3918
  goto ldv_62062;
  case 3: ;
#line 3921
  if (ldv_state_variable_19 == 1) {
#line 3923
    qla2x00_get_host_port_type(qla2xxx_transport_vport_functions_group0);
#line 3925
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3928
  goto ldv_62062;
  case 4: ;
#line 3931
  if (ldv_state_variable_19 == 1) {
#line 3933
    qla24xx_bsg_timeout(qla2xxx_transport_vport_functions_group1);
#line 3935
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3938
  goto ldv_62062;
  case 5: ;
#line 3941
  if (ldv_state_variable_19 == 1) {
#line 3943
    qla24xx_bsg_request(qla2xxx_transport_vport_functions_group1);
#line 3945
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3948
  goto ldv_62062;
  case 6: ;
#line 3951
  if (ldv_state_variable_19 == 1) {
#line 3953
    qla2x00_terminate_rport_io(qla2xxx_transport_vport_functions_group2);
#line 3955
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3958
  goto ldv_62062;
  case 7: ;
#line 3961
  if (ldv_state_variable_19 == 1) {
#line 3963
    qla2x00_get_host_port_state(qla2xxx_transport_vport_functions_group0);
#line 3965
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3968
  goto ldv_62062;
  case 8: ;
#line 3971
  if (ldv_state_variable_19 == 1) {
#line 3973
    qla2x00_get_starget_node_name(qla2xxx_transport_vport_functions_group3);
#line 3975
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3978
  goto ldv_62062;
  case 9: ;
#line 3981
  if (ldv_state_variable_19 == 1) {
#line 3983
    qla2x00_get_host_speed(qla2xxx_transport_vport_functions_group0);
#line 3985
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3988
  goto ldv_62062;
  case 10: ;
#line 3991
  if (ldv_state_variable_19 == 1) {
#line 3993
    qla2x00_get_starget_port_id(qla2xxx_transport_vport_functions_group3);
#line 3995
    ldv_state_variable_19 = 1;
  } else {

  }
#line 3998
  goto ldv_62062;
  case 11: ;
#line 4001
  if (ldv_state_variable_19 == 1) {
#line 4003
    qla2x00_get_starget_port_name(qla2xxx_transport_vport_functions_group3);
#line 4005
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4008
  goto ldv_62062;
  case 12: ;
#line 4011
  if (ldv_state_variable_19 == 1) {
#line 4013
    qla2x00_dev_loss_tmo_callbk(qla2xxx_transport_vport_functions_group2);
#line 4015
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4018
  goto ldv_62062;
  case 13: ;
#line 4021
  if (ldv_state_variable_19 == 1) {
#line 4023
    qla2x00_reset_host_stats(qla2xxx_transport_vport_functions_group0);
#line 4025
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4028
  goto ldv_62062;
  case 14: ;
#line 4031
  if (ldv_state_variable_19 == 1) {
#line 4033
    qla2x00_get_host_symbolic_name(qla2xxx_transport_vport_functions_group0);
#line 4035
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4038
  goto ldv_62062;
  case 15: ;
#line 4041
  if (ldv_state_variable_19 == 1) {
#line 4043
    qla2x00_set_host_system_hostname(qla2xxx_transport_vport_functions_group0);
#line 4045
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4048
  goto ldv_62062;
  case 16: ;
#line 4051
  if (ldv_state_variable_19 == 1) {
#line 4053
    qla2x00_get_host_fabric_name(qla2xxx_transport_vport_functions_group0);
#line 4055
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4058
  goto ldv_62062;
  case 17: ;
#line 4061
  if (ldv_state_variable_19 == 1) {
#line 4063
    qla2x00_get_host_port_id(qla2xxx_transport_vport_functions_group0);
#line 4065
    ldv_state_variable_19 = 1;
  } else {

  }
#line 4068
  goto ldv_62062;
  default: 
#line 4069
  ldv_stop();
  }
  ldv_62062: ;
#line 4073
  return;
}
}
#line 4075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_43(void) 
{ 
  struct device *ldvarg487 ;
  void *tmp ;
  struct device_attribute *ldvarg489 ;
  void *tmp___0 ;
  char *ldvarg488 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 4076
  tmp = ldv_zalloc(1376UL);
#line 4076
  ldvarg487 = (struct device *)tmp;
#line 4077
  tmp___0 = ldv_zalloc(48UL);
#line 4077
  ldvarg489 = (struct device_attribute *)tmp___0;
#line 4078
  tmp___1 = ldv_zalloc(1UL);
#line 4078
  ldvarg488 = (char *)tmp___1;
#line 4080
  tmp___2 = __VERIFIER_nondet_int();
#line 4080
  switch (tmp___2) {
  case 0: ;
#line 4083
  if (ldv_state_variable_43 == 1) {
#line 4085
    qla2x00_pci_info_show(ldvarg487, ldvarg489, ldvarg488);
#line 4087
    ldv_state_variable_43 = 1;
  } else {

  }
#line 4090
  goto ldv_62088;
  default: 
#line 4091
  ldv_stop();
  }
  ldv_62088: ;
#line 4095
  return;
}
}
#line 4097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_main_exported_54(void) 
{ 
  char *ldvarg265 ;
  void *tmp ;
  struct kobject *ldvarg268 ;
  void *tmp___0 ;
  struct bin_attribute *ldvarg267 ;
  void *tmp___1 ;
  loff_t ldvarg269 ;
  loff_t tmp___2 ;
  size_t ldvarg264 ;
  size_t tmp___3 ;
  struct file *ldvarg266 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 4098
  tmp = ldv_zalloc(1UL);
#line 4098
  ldvarg265 = (char *)tmp;
#line 4099
  tmp___0 = ldv_zalloc(296UL);
#line 4099
  ldvarg268 = (struct kobject *)tmp___0;
#line 4100
  tmp___1 = ldv_zalloc(72UL);
#line 4100
  ldvarg267 = (struct bin_attribute *)tmp___1;
#line 4101
  tmp___2 = __VERIFIER_nondet_loff_t();
#line 4101
  ldvarg269 = tmp___2;
#line 4102
  tmp___3 = __VERIFIER_nondet_size_t();
#line 4102
  ldvarg264 = tmp___3;
#line 4103
  tmp___4 = ldv_zalloc(360UL);
#line 4103
  ldvarg266 = (struct file *)tmp___4;
#line 4105
  tmp___5 = __VERIFIER_nondet_int();
#line 4105
  switch (tmp___5) {
  case 0: ;
#line 4108
  if (ldv_state_variable_54 == 2) {
#line 4110
    qla2x00_sysfs_read_sfp(ldvarg266, ldvarg268, ldvarg267, ldvarg265, ldvarg269,
                           ldvarg264);
#line 4112
    ldv_state_variable_54 = 2;
  } else {

  }
#line 4115
  goto ldv_62100;
  case 1: ;
#line 4118
  if (ldv_state_variable_54 == 2) {
#line 4120
    ldv_release_54();
#line 4122
    ldv_state_variable_54 = 1;
#line 4123
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 4126
  goto ldv_62100;
  case 2: ;
#line 4129
  if (ldv_state_variable_54 == 1) {
#line 4131
    ldv_probe_54();
#line 4133
    ldv_state_variable_54 = 2;
#line 4134
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 4137
  goto ldv_62100;
  default: 
#line 4138
  ldv_stop();
  }
  ldv_62100: ;
#line 4142
  return;
}
}
#line 4143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int ldv_del_timer_47(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 4147
  tmp = del_timer(ldv_func_arg1);
#line 4147
  ldv_func_res = tmp;
#line 4149
  disable_suitable_timer_7(ldv_func_arg1);
#line 4151
  return (ldv_func_res);
}
}
#line 4154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int ldv_scsi_add_host_with_dma_48(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 4158
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 4158
  ldv_func_res = tmp;
#line 4160
  if (ldv_func_res == 0) {
#line 4161
    ldv_state_variable_72 = 1;
#line 4161
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 4165
  return (ldv_func_res);
}
}
#line 4168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
int ldv_scsi_add_host_with_dma_49(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 4172
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 4172
  ldv_func_res = tmp;
#line 4174
  if (ldv_func_res == 0) {
#line 4175
    ldv_state_variable_72 = 1;
#line 4175
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 4179
  return (ldv_func_res);
}
}
#line 4182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_attr.o.c.prepared"
void ldv_scsi_remove_host_50(struct Scsi_Host *shost ) 
{ 


  {
#line 4185
  scsi_remove_host(shost);
#line 4187
  ldv_state_variable_72 = 0;
#line 4188
  return;
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_55(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_57(struct timer_list *ldv_func_arg1 ) ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void disable_suitable_timer_11(struct timer_list *timer ) ;
#line 237
void choose_timer_11(struct timer_list *timer ) ;
#line 244
int reg_timer_11(struct timer_list *timer ) ;
#line 289
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_56(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 800 "include/scsi/scsi_transport_fc.h"
__inline static void u64_to_wwn(u64 inm , u8 *wwn ) 
{ 


  {
#line 802
  *wwn = (u8 )(inm >> 56);
#line 803
  *(wwn + 1UL) = (u8 )(inm >> 48);
#line 804
  *(wwn + 2UL) = (u8 )(inm >> 40);
#line 805
  *(wwn + 3UL) = (u8 )(inm >> 32);
#line 806
  *(wwn + 4UL) = (u8 )(inm >> 24);
#line 807
  *(wwn + 5UL) = (u8 )(inm >> 16);
#line 808
  *(wwn + 6UL) = (u8 )(inm >> 8);
#line 809
  *(wwn + 7UL) = (u8 )inm;
#line 810
  return;
}
}
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___3[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___2(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 154
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 155
  atomic_set(& fcport->state, state);
#line 158
  if (old_state != 0 && old_state != state) {
#line 159
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___3[old_state], port_state_str___3[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 165
  return;
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void qla2x00_vp_stop_timer(scsi_qla_host_t *vha ) 
{ 


  {
#line 322
  if ((unsigned int )vha->vp_idx != 0U && vha->timer_active != 0U) {
#line 323
    ldv_del_timer_sync_57(& vha->timer);
#line 324
    vha->timer_active = 0U;
  } else {

  }
#line 326
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static uint32_t qla24xx_allocate_vp_id(scsi_qla_host_t *vha ) 
{ 
  uint32_t vp_id ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  unsigned long tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 332
  ha = vha->hw;
#line 336
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 337
  tmp = find_first_zero_bit((unsigned long const   *)(& ha->vp_idx_map), (unsigned long )((int )ha->max_npiv_vports + 1));
#line 337
  vp_id = (uint32_t )tmp;
#line 338
  if ((uint32_t )ha->max_npiv_vports < vp_id) {
#line 339
    ql_dbg(262144U, vha, 40960, "vp_id %d is bigger than max-supported %d.\n", vp_id,
           (int )ha->max_npiv_vports);
#line 342
    mutex_unlock(& ha->vport_lock);
#line 343
    return (vp_id);
  } else {

  }
#line 346
  set_bit((long )vp_id, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 347
  ha->num_vhosts = (uint16_t )((int )ha->num_vhosts + 1);
#line 348
  vha->vp_idx = (uint16_t )vp_id;
#line 350
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 350
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 351
  list_add_tail(& vha->list, & ha->vp_list);
#line 353
  qlt_update_vp_map(vha, 1);
#line 355
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 357
  mutex_unlock(& ha->vport_lock);
#line 358
  return (vp_id);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void qla24xx_deallocate_vp_id(scsi_qla_host_t *vha ) 
{ 
  uint16_t vp_id ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 365
  ha = vha->hw;
#line 366
  flags = 0UL;
#line 368
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 376
  tmp = spinlock_check(& ha->vport_slock);
#line 376
  flags = _raw_spin_lock_irqsave(tmp);
#line 377
  goto ldv_60798;
  ldv_60797: 
#line 378
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 380
  msleep(500U);
#line 382
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 382
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_60798: 
#line 377
  tmp___1 = atomic_read((atomic_t const   *)(& vha->vref_count));
#line 377
  if (tmp___1 != 0) {
#line 379
    goto ldv_60797;
  } else {

  }
#line 384
  list_del(& vha->list);
#line 385
  qlt_update_vp_map(vha, 3);
#line 386
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 388
  vp_id = vha->vp_idx;
#line 389
  ha->num_vhosts = (uint16_t )((int )ha->num_vhosts - 1);
#line 390
  clear_bit((long )vp_id, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 392
  mutex_unlock(& ha->vport_lock);
#line 393
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static scsi_qla_host_t *qla24xx_find_vhost_by_name(struct qla_hw_data *ha , uint8_t *port_name ) 
{ 
  scsi_qla_host_t *vha ;
  struct scsi_qla_host *tvha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 402
  tmp = spinlock_check(& ha->vport_slock);
#line 402
  flags = _raw_spin_lock_irqsave(tmp);
#line 404
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 404
  vha = (scsi_qla_host_t *)__mptr;
#line 404
  __mptr___0 = (struct list_head  const  *)vha->list.next;
#line 404
  tvha = (scsi_qla_host_t *)__mptr___0;
#line 404
  goto ldv_60817;
  ldv_60816: 
#line 405
  tmp___0 = memcmp((void const   *)port_name, (void const   *)(& vha->port_name),
                   8UL);
#line 405
  if (tmp___0 == 0) {
#line 406
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 407
    return (vha);
  } else {

  }
#line 404
  vha = tvha;
#line 404
  __mptr___1 = (struct list_head  const  *)tvha->list.next;
#line 404
  tvha = (struct scsi_qla_host *)__mptr___1;
  ldv_60817: ;
#line 404
  if ((unsigned long )(& vha->list) != (unsigned long )(& ha->vp_list)) {
#line 406
    goto ldv_60816;
  } else {

  }
#line 410
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 411
  return ((scsi_qla_host_t *)0);
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static void qla2x00_mark_vp_devices_dead(scsi_qla_host_t *vha ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 438
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 438
  fcport = (fc_port_t *)__mptr;
#line 438
  goto ldv_60828;
  ldv_60827: 
#line 439
  ql_dbg(262144U, vha, 40961, "Marking port dead, loop_id=0x%04x : %x.\n", (int )fcport->loop_id,
         (int )(fcport->vha)->vp_idx);
#line 443
  qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 444
  qla2x00_set_fcport_state___2(fcport, 1);
#line 438
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 438
  fcport = (fc_port_t *)__mptr___0;
  ldv_60828: ;
#line 438
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 440
    goto ldv_60827;
  } else {

  }

#line 445
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla24xx_disable_vp(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;

  {
#line 454
  ret = qla24xx_control_vp(vha, 11);
#line 455
  atomic_set(& vha->loop_state, 2);
#line 456
  atomic_set(& vha->loop_down_timer, 255);
#line 459
  tmp = spinlock_check(& (vha->hw)->vport_slock);
#line 459
  flags = _raw_spin_lock_irqsave(tmp);
#line 460
  qlt_update_vp_map(vha, 4);
#line 461
  spin_unlock_irqrestore(& (vha->hw)->vport_slock, flags);
#line 463
  qla2x00_mark_vp_devices_dead(vha);
#line 464
  atomic_set(& vha->vp_state, 2);
#line 465
  vha->flags.management_server_logged_in = 0U;
#line 466
  if (ret == 0) {
#line 467
    fc_vport_set_state(vha->fc_vport, 2);
  } else {
#line 469
    fc_vport_set_state(vha->fc_vport, 9);
#line 470
    return (-1);
  }
#line 472
  return (0);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla24xx_enable_vp(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 479
  ha = vha->hw;
#line 480
  tmp = pci_get_drvdata(ha->pdev);
#line 480
  base_vha = (scsi_qla_host_t *)tmp;
#line 483
  tmp___0 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 483
  if (tmp___0 == 2) {
#line 486
    vha->vp_err_state = 1U;
#line 487
    fc_vport_set_state(vha->fc_vport, 3);
#line 488
    goto enable_failed;
  } else {
#line 483
    tmp___1 = atomic_read((atomic_t const   *)(& base_vha->loop_state));
#line 483
    if (tmp___1 == 6) {
#line 486
      vha->vp_err_state = 1U;
#line 487
      fc_vport_set_state(vha->fc_vport, 3);
#line 488
      goto enable_failed;
    } else
#line 483
    if (((int )ha->current_topology & 8) == 0) {
#line 486
      vha->vp_err_state = 1U;
#line 487
      fc_vport_set_state(vha->fc_vport, 3);
#line 488
      goto enable_failed;
    } else {

    }
  }
#line 492
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 493
  ret = qla24xx_modify_vp_config(vha);
#line 494
  mutex_unlock(& ha->vport_lock);
#line 496
  if (ret != 0) {
#line 497
    fc_vport_set_state(vha->fc_vport, 9);
#line 498
    goto enable_failed;
  } else {

  }
#line 501
  ql_dbg(4194304U, vha, 32794, "Virtual port with id: %d - Enabled.\n", (int )vha->vp_idx);
#line 503
  return (0);
  enable_failed: 
#line 506
  ql_dbg(4194304U, vha, 32795, "Virtual port with id: %d - Disabled.\n", (int )vha->vp_idx);
#line 508
  return (1);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static void qla24xx_configure_vp(scsi_qla_host_t *vha ) 
{ 
  struct fc_vport *fc_vport ;
  int ret ;
  int tmp ;

  {
#line 517
  fc_vport = vha->fc_vport;
#line 519
  ql_dbg(262144U, vha, 40962, "%s: change request #3.\n", "qla24xx_configure_vp");
#line 521
  ret = qla2x00_send_change_request(vha, 3, (int )vha->vp_idx);
#line 522
  if (ret != 0) {
#line 523
    ql_dbg(262144U, vha, 40963, "Failed to enable receiving of RSCN requests: 0x%x.\n",
           ret);
#line 525
    return;
  } else {
#line 528
    clear_bit(4L, (unsigned long volatile   *)(& vha->vp_flags));
  }
#line 531
  vha->flags.online = 1U;
#line 532
  tmp = qla24xx_configure_vhba(vha);
#line 532
  if (tmp != 0) {
#line 533
    return;
  } else {

  }
#line 535
  atomic_set(& vha->vp_state, 1);
#line 536
  fc_vport_set_state(fc_vport, 1);
#line 537
  return;
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void qla2x00_alert_all_vps(struct rsp_que *rsp , uint16_t *mb ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int i ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 543
  ha = rsp->hw;
#line 544
  i = 0;
#line 547
  tmp = spinlock_check(& ha->vport_slock);
#line 547
  flags = _raw_spin_lock_irqsave(tmp);
#line 548
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 548
  vha = (scsi_qla_host_t *)__mptr;
#line 548
  goto ldv_60879;
  ldv_60878: ;
#line 549
  if ((unsigned int )vha->vp_idx != 0U) {
#line 550
    atomic_inc(& vha->vref_count);
#line 551
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 553
    switch ((int )*mb) {
    case 32784: ;
    case 32785: ;
    case 32786: ;
    case 32787: ;
    case 32816: ;
    case 32822: ;
    case 32788: ;
    case 32789: 
#line 562
    ql_dbg(33554432U, vha, 20516, "Async_event for VP[%d], mb=0x%x vha=%p.\n", i,
           (int )*mb, vha);
#line 565
    qla2x00_async_event(vha, rsp, mb);
#line 566
    goto ldv_60874;
    }
    ldv_60874: 
#line 569
    tmp___0 = spinlock_check(& ha->vport_slock);
#line 569
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 570
    atomic_dec(& vha->vref_count);
  } else {

  }
#line 572
  i = i + 1;
#line 548
  __mptr___0 = (struct list_head  const  *)vha->list.next;
#line 548
  vha = (scsi_qla_host_t *)__mptr___0;
  ldv_60879: ;
#line 548
  if ((unsigned long )(& vha->list) != (unsigned long )(& ha->vp_list)) {
#line 550
    goto ldv_60878;
  } else {

  }
#line 574
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 575
  return;
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla2x00_vp_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 584
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 584
  if (tmp___0 != 2) {
#line 585
    atomic_set(& vha->loop_state, 2);
#line 586
    qla2x00_mark_all_devices_lost(vha, 0);
  } else {
#line 588
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 588
    if (tmp == 0) {
#line 589
      atomic_set(& vha->loop_down_timer, 255);
    } else {

    }
  }
#line 597
  tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 597
  if (tmp___1 == 0) {
#line 598
    qla24xx_control_vp(vha, 11);
  } else {

  }
#line 600
  ql_dbg(4194304U, vha, 32797, "Scheduling enable of Vport %d.\n", (int )vha->vp_idx);
#line 602
  tmp___2 = qla24xx_enable_vp(vha);
#line 602
  return (tmp___2);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static int qla2x00_do_dpc_vp(scsi_qla_host_t *vha ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 608
  ql_dbg(67141632U, vha, 16402, "Entering %s vp_flags: 0x%lx.\n", "qla2x00_do_dpc_vp",
         vha->vp_flags);
#line 611
  qla2x00_do_work(vha);
#line 613
  tmp = test_and_clear_bit(0L, (unsigned long volatile   *)(& vha->vp_flags));
#line 613
  if (tmp != 0) {
#line 615
    ql_dbg(67108864U, vha, 16404, "Configure VP scheduled.\n");
#line 617
    qla24xx_configure_vp(vha);
#line 618
    ql_dbg(67108864U, vha, 16405, "Configure VP end.\n");
#line 620
    return (0);
  } else {

  }
#line 623
  tmp___0 = constant_test_bit(13L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 623
  if (tmp___0 != 0) {
#line 624
    ql_dbg(67108864U, vha, 16406, "FCPort update scheduled.\n");
#line 626
    qla2x00_update_fcports(vha);
#line 627
    clear_bit(13L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 628
    ql_dbg(67108864U, vha, 16407, "FCPort update end.\n");
  } else {

  }
#line 632
  tmp___1 = test_and_clear_bit(8L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 632
  if (tmp___1 != 0) {
#line 632
    tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 632
    if (tmp___2 == 0) {
#line 632
      tmp___3 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 632
      if (tmp___3 != 2) {
#line 636
        ql_dbg(67108864U, vha, 16408, "Relogin needed scheduled.\n");
#line 638
        qla2x00_relogin(vha);
#line 639
        ql_dbg(67108864U, vha, 16409, "Relogin needed end.\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 643
  tmp___4 = test_and_clear_bit(0L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 643
  if (tmp___4 != 0) {
#line 643
    tmp___5 = test_and_set_bit(1L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 643
    if (tmp___5 == 0) {
#line 645
      clear_bit(1L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
  } else {

  }
#line 648
  tmp___7 = test_and_clear_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 648
  if (tmp___7 != 0) {
#line 649
    tmp___6 = test_and_set_bit(5L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 649
    if (tmp___6 == 0) {
#line 650
      ql_dbg(67108864U, vha, 16410, "Loop resync scheduled.\n");
#line 652
      qla2x00_loop_resync(vha);
#line 653
      clear_bit(5L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 654
      ql_dbg(67108864U, vha, 16411, "Loop resync end.\n");
    } else {

    }
  } else {

  }
#line 659
  ql_dbg(67141632U, vha, 16412, "Exiting %s.\n", "qla2x00_do_dpc_vp");
#line 661
  return (0);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void qla2x00_do_dpc_all_vps(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vp ;
  unsigned long flags ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 668
  ha = vha->hw;
#line 670
  flags = 0UL;
#line 672
  if ((unsigned int )vha->vp_idx != 0U) {
#line 673
    return;
  } else {

  }
#line 674
  tmp = list_empty((struct list_head  const  *)(& ha->vp_list));
#line 674
  if (tmp != 0) {
#line 675
    return;
  } else {

  }
#line 677
  clear_bit(14L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 679
  if (((int )ha->current_topology & 8) == 0) {
#line 680
    return;
  } else {

  }
#line 682
  tmp___0 = spinlock_check(& ha->vport_slock);
#line 682
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 683
  __mptr = (struct list_head  const  *)ha->vp_list.next;
#line 683
  vp = (scsi_qla_host_t *)__mptr;
#line 683
  goto ldv_60906;
  ldv_60905: ;
#line 684
  if ((unsigned int )vp->vp_idx != 0U) {
#line 685
    atomic_inc(& vp->vref_count);
#line 686
    spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 688
    ret = qla2x00_do_dpc_vp(vp);
#line 690
    tmp___1 = spinlock_check(& ha->vport_slock);
#line 690
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 691
    atomic_dec(& vp->vref_count);
  } else {

  }
#line 683
  __mptr___0 = (struct list_head  const  *)vp->list.next;
#line 683
  vp = (scsi_qla_host_t *)__mptr___0;
  ldv_60906: ;
#line 683
  if ((unsigned long )(& vp->list) != (unsigned long )(& ha->vp_list)) {
#line 685
    goto ldv_60905;
  } else {

  }
#line 694
  spin_unlock_irqrestore(& ha->vport_slock, flags);
#line 695
  return;
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla24xx_vport_create_req_sanity_check(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  uint8_t port_name[8U] ;
  int tmp___0 ;

  {
#line 700
  tmp = shost_priv(fc_vport->shost);
#line 700
  base_vha = (scsi_qla_host_t *)tmp;
#line 701
  ha = base_vha->hw;
#line 705
  if (fc_vport->roles != 2U) {
#line 706
    return (-38);
  } else {

  }
#line 709
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 710
    return (-38);
  } else {

  }
#line 713
  if (((int )ha->switch_cap & 1024) == 0) {
#line 714
    return (-95);
  } else {

  }
#line 717
  u64_to_wwn(fc_vport->port_name, (u8 *)(& port_name));
#line 718
  tmp___0 = memcmp((void const   *)(& port_name), (void const   *)(& base_vha->port_name),
                   8UL);
#line 718
  if (tmp___0 == 0) {
#line 719
    return (-76);
  } else {

  }
#line 720
  vha = qla24xx_find_vhost_by_name(ha, (uint8_t *)(& port_name));
#line 721
  if ((unsigned long )vha != (unsigned long )((scsi_qla_host_t *)0)) {
#line 722
    return (-76);
  } else {

  }
#line 725
  if ((int )ha->num_vhosts > (int )ha->max_npiv_vports) {
#line 726
    ql_dbg(262144U, vha, 40964, "num_vhosts %ud is bigger than max_npiv_vports %ud.\n",
           (int )ha->num_vhosts, (int )ha->max_npiv_vports);
#line 730
    return (-38);
  } else {

  }
#line 732
  return (0);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
scsi_qla_host_t *qla24xx_create_vhost(struct fc_vport *fc_vport ) 
{ 
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *vha ;
  struct scsi_host_template *sht ;
  struct Scsi_Host *host ;
  struct scsi_qla_host *tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 738
  tmp = shost_priv(fc_vport->shost);
#line 738
  base_vha = (scsi_qla_host_t *)tmp;
#line 739
  ha = base_vha->hw;
#line 741
  sht = & qla2xxx_driver_template;
#line 744
  tmp___0 = qla2x00_create_host(sht, ha);
#line 744
  vha = tmp___0;
#line 745
  if ((unsigned long )vha == (unsigned long )((scsi_qla_host_t *)0)) {
#line 746
    ql_log(1U, vha, 40965, "scsi_host_alloc() failed for vport.\n");
#line 748
    return ((scsi_qla_host_t *)0);
  } else {

  }
#line 751
  host = vha->host;
#line 752
  fc_vport->dd_data = (void *)vha;
#line 754
  u64_to_wwn(fc_vport->node_name, (u8 *)(& vha->node_name));
#line 755
  u64_to_wwn(fc_vport->port_name, (u8 *)(& vha->port_name));
#line 757
  vha->fc_vport = fc_vport;
#line 758
  vha->device_flags = 0U;
#line 759
  tmp___1 = qla24xx_allocate_vp_id(vha);
#line 759
  vha->vp_idx = (uint16_t )tmp___1;
#line 760
  if ((int )vha->vp_idx > (int )ha->max_npiv_vports) {
#line 761
    ql_dbg(262144U, vha, 40966, "Couldn\'t allocate vp_id.\n");
#line 763
    goto create_vhost_failed;
  } else {

  }
#line 765
  vha->mgmt_svr_loop_id = (unsigned int )vha->vp_idx + 10U;
#line 767
  vha->dpc_flags = 0UL;
#line 773
  set_bit(4L, (unsigned long volatile   *)(& vha->vp_flags));
#line 774
  atomic_set(& vha->loop_state, 2);
#line 775
  atomic_set(& vha->loop_down_timer, 255);
#line 777
  qla2x00_start_timer(vha, (void *)(& qla2x00_timer), 1UL);
#line 779
  vha->req = base_vha->req;
#line 780
  host->can_queue = (int )(base_vha->req)->length + 128;
#line 781
  host->cmd_per_lun = 3;
#line 782
  if ((ha->device_type & 33554432U) != 0U && ql2xenabledif != 0) {
#line 783
    host->max_cmd_len = 32U;
  } else {
#line 785
    host->max_cmd_len = 16U;
  }
#line 786
  host->max_channel = 0U;
#line 787
  host->max_lun = ql2xmaxlun;
#line 788
  host->unique_id = host->host_no;
#line 789
  host->max_id = (unsigned int )ha->max_fibre_devices;
#line 790
  host->transportt = qla2xxx_transport_vport_template;
#line 792
  ql_dbg(262144U, vha, 40967, "Detect vport hba %ld at address = %p.\n", vha->host_no,
         vha);
#line 796
  vha->flags.init_done = 1U;
#line 798
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 799
  set_bit((long )vha->vp_idx, (unsigned long volatile   *)(& ha->vp_idx_map));
#line 800
  ha->cur_vport_count = ha->cur_vport_count + 1;
#line 801
  mutex_unlock(& ha->vport_lock);
#line 803
  return (vha);
  create_vhost_failed: ;
#line 806
  return ((scsi_qla_host_t *)0);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static void qla25xx_free_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t que_id ;

  {
#line 812
  ha = vha->hw;
#line 813
  que_id = req->id;
#line 815
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                 (void *)req->ring, req->dma, (struct dma_attrs *)0);
#line 817
  req->ring = (request_t *)0;
#line 818
  req->dma = 0ULL;
#line 819
  if ((unsigned int )que_id != 0U) {
#line 820
    *(ha->req_q_map + (unsigned long )que_id) = (struct req_que *)0;
#line 821
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 822
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 823
    mutex_unlock(& ha->vport_lock);
  } else {

  }
#line 825
  kfree((void const   *)req->outstanding_cmds);
#line 826
  kfree((void const   *)req);
#line 827
  req = (struct req_que *)0;
#line 828
  return;
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static void qla25xx_free_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t que_id ;

  {
#line 833
  ha = vha->hw;
#line 834
  que_id = rsp->id;
#line 836
  if ((unsigned long )rsp->msix != (unsigned long )((struct qla_msix_entry *)0) && (rsp->msix)->have_irq != 0) {
#line 837
    free_irq((rsp->msix)->vector, (void *)rsp);
#line 838
    (rsp->msix)->have_irq = 0;
#line 839
    (rsp->msix)->rsp = (struct rsp_que *)0;
  } else {

  }
#line 841
  dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                 (void *)rsp->ring, rsp->dma, (struct dma_attrs *)0);
#line 843
  rsp->ring = (response_t *)0;
#line 844
  rsp->dma = 0ULL;
#line 845
  if ((unsigned int )que_id != 0U) {
#line 846
    *(ha->rsp_q_map + (unsigned long )que_id) = (struct rsp_que *)0;
#line 847
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 848
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 849
    mutex_unlock(& ha->vport_lock);
  } else {

  }
#line 851
  kfree((void const   *)rsp);
#line 852
  rsp = (struct rsp_que *)0;
#line 853
  return;
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla25xx_delete_req_que(struct scsi_qla_host *vha , struct req_que *req ) 
{ 
  int ret ;

  {
#line 858
  ret = -1;
#line 860
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 861
    req->options = (uint16_t )((unsigned int )req->options | 1U);
#line 862
    ret = qla25xx_init_req_que(vha, req);
  } else {

  }
#line 864
  if (ret == 0) {
#line 865
    qla25xx_free_req_que(vha, req);
  } else {

  }
#line 867
  return (ret);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static int qla25xx_delete_rsp_que(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  int ret ;

  {
#line 873
  ret = -1;
#line 875
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 876
    rsp->options = (uint16_t )((unsigned int )rsp->options | 1U);
#line 877
    ret = qla25xx_init_rsp_que(vha, rsp);
  } else {

  }
#line 879
  if (ret == 0) {
#line 880
    qla25xx_free_rsp_que(vha, rsp);
  } else {

  }
#line 882
  return (ret);
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla25xx_delete_queues(struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  int ret ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct qla_hw_data *ha ;

  {
#line 889
  ret = 0;
#line 890
  req = (struct req_que *)0;
#line 891
  rsp = (struct rsp_que *)0;
#line 892
  ha = vha->hw;
#line 895
  cnt = 1;
#line 895
  goto ldv_60955;
  ldv_60954: 
#line 896
  req = *(ha->req_q_map + (unsigned long )cnt);
#line 897
  if ((unsigned long )req != (unsigned long )((struct req_que *)0)) {
#line 898
    ret = qla25xx_delete_req_que(vha, req);
#line 899
    if (ret != 0) {
#line 900
      ql_log(1U, vha, 234, "Couldn\'t delete req que %d.\n", (int )req->id);
#line 903
      return (ret);
    } else {

    }
  } else {

  }
#line 895
  cnt = cnt + 1;
  ldv_60955: ;
#line 895
  if ((int )ha->max_req_queues > cnt) {
#line 897
    goto ldv_60954;
  } else {

  }
#line 909
  cnt = 1;
#line 909
  goto ldv_60958;
  ldv_60957: 
#line 910
  rsp = *(ha->rsp_q_map + (unsigned long )cnt);
#line 911
  if ((unsigned long )rsp != (unsigned long )((struct rsp_que *)0)) {
#line 912
    ret = qla25xx_delete_rsp_que(vha, rsp);
#line 913
    if (ret != 0) {
#line 914
      ql_log(1U, vha, 235, "Couldn\'t delete rsp que %d.\n", (int )rsp->id);
#line 917
      return (ret);
    } else {

    }
  } else {

  }
#line 909
  cnt = cnt + 1;
  ldv_60958: ;
#line 909
  if ((int )ha->max_rsp_queues > cnt) {
#line 911
    goto ldv_60957;
  } else {

  }

#line 921
  return (ret);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla25xx_create_req_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int rsp_que , uint8_t qos ) 
{ 
  int ret ;
  struct req_que *req ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  uint16_t que_id ;
  device_reg_t *reg ;
  uint32_t cnt ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 928
  ret = 0;
#line 929
  req = (struct req_que *)0;
#line 930
  tmp = pci_get_drvdata(ha->pdev);
#line 930
  base_vha = (struct scsi_qla_host *)tmp;
#line 931
  que_id = 0U;
#line 935
  tmp___0 = kzalloc(184UL, 208U);
#line 935
  req = (struct req_que *)tmp___0;
#line 936
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 937
    ql_log(0U, base_vha, 217, "Failed to allocate memory for request queue.\n");
#line 939
    goto failed;
  } else {

  }
#line 942
  req->length = 2048U;
#line 943
  tmp___1 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )req->length + 1) * 64UL,
                            & req->dma, 208U, (struct dma_attrs *)0);
#line 943
  req->ring = (request_t *)tmp___1;
#line 946
  if ((unsigned long )req->ring == (unsigned long )((request_t *)0)) {
#line 947
    ql_log(0U, base_vha, 218, "Failed to allocate memory for request_ring.\n");
#line 949
    goto que_failed;
  } else {

  }
#line 952
  ret = qla2x00_alloc_outstanding_cmds(ha, req);
#line 953
  if (ret != 0) {
#line 954
    goto que_failed;
  } else {

  }
#line 956
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 957
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& ha->req_qid_map), (unsigned long )ha->max_req_queues);
#line 957
  que_id = (uint16_t )tmp___2;
#line 958
  if ((int )((unsigned short )ha->max_req_queues) <= (int )que_id) {
#line 959
    mutex_unlock(& ha->vport_lock);
#line 960
    ql_log(1U, base_vha, 219, "No resources to create additional request queue.\n");
#line 962
    goto que_failed;
  } else {

  }
#line 964
  set_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 965
  *(ha->req_q_map + (unsigned long )que_id) = req;
#line 966
  req->rid = rid;
#line 967
  req->vp_idx = (uint16_t )vp_idx;
#line 968
  req->qos = (uint16_t )qos;
#line 970
  ql_dbg(1048576U, base_vha, 49154, "queue_id=%d rid=%d vp_idx=%d qos=%d.\n", (int )que_id,
         (int )req->rid, (int )req->vp_idx, (int )req->qos);
#line 973
  ql_dbg(1073741824U, base_vha, 220, "queue_id=%d rid=%d vp_idx=%d qos=%d.\n", (int )que_id,
         (int )req->rid, (int )req->vp_idx, (int )req->qos);
#line 976
  if (rsp_que < 0) {
#line 977
    req->rsp = (struct rsp_que *)0;
  } else {
#line 979
    req->rsp = *(ha->rsp_q_map + (unsigned long )rsp_que);
  }
#line 981
  if ((unsigned int )((unsigned char )((int )req->rid >> 8)) != 0U) {
#line 982
    options = (uint16_t )((unsigned int )options | 16U);
  } else {

  }
#line 984
  if ((unsigned int )((unsigned char )req->rid) != 0U) {
#line 985
    options = (uint16_t )((unsigned int )options | 32U);
  } else {

  }
#line 986
  req->options = options;
#line 988
  ql_dbg(1048576U, base_vha, 49155, "options=0x%x.\n", (int )req->options);
#line 990
  ql_dbg(1073741824U, base_vha, 221, "options=0x%x.\n", (int )req->options);
#line 992
  cnt = 1U;
#line 992
  goto ldv_60977;
  ldv_60976: 
#line 993
  *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 992
  cnt = cnt + 1U;
  ldv_60977: ;
#line 992
  if ((uint32_t )req->num_outstanding_cmds > cnt) {
#line 994
    goto ldv_60976;
  } else {

  }
#line 994
  req->current_outstanding_cmd = 1U;
#line 996
  req->ring_ptr = req->ring;
#line 997
  req->ring_index = 0U;
#line 998
  req->cnt = req->length;
#line 999
  req->id = que_id;
#line 1000
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase + (unsigned long )((int )que_id * 4096) : ha->iobase;
#line 1001
  req->req_q_in = & reg->isp25mq.req_q_in;
#line 1002
  req->req_q_out = & reg->isp25mq.req_q_out;
#line 1003
  req->max_q_depth = (*(ha->req_q_map))->max_q_depth;
#line 1004
  mutex_unlock(& ha->vport_lock);
#line 1005
  ql_dbg(1048576U, base_vha, 49156, "ring_ptr=%p ring_index=%d, cnt=%d id=%d max_q_depth=%d.\n",
         req->ring_ptr, (int )req->ring_index, (int )req->cnt, (int )req->id, req->max_q_depth);
#line 1010
  ql_dbg(1073741824U, base_vha, 222, "ring_ptr=%p ring_index=%d, cnt=%d id=%d max_q_depth=%d.\n",
         req->ring_ptr, (int )req->ring_index, (int )req->cnt, (int )req->id, req->max_q_depth);
#line 1016
  ret = qla25xx_init_req_que(base_vha, req);
#line 1017
  if (ret != 0) {
#line 1018
    ql_log(0U, base_vha, 223, "%s failed.\n", "qla25xx_create_req_que");
#line 1020
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 1021
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->req_qid_map));
#line 1022
    mutex_unlock(& ha->vport_lock);
#line 1023
    goto que_failed;
  } else {

  }
#line 1026
  return ((int )req->id);
  que_failed: 
#line 1029
  qla25xx_free_req_que(base_vha, req);
  failed: ;
#line 1031
  return (0);
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
static void qla_do_work(struct work_struct *work ) 
{ 
  unsigned long flags ;
  struct rsp_que *rsp ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 1037
  __mptr = (struct work_struct  const  *)work;
#line 1037
  rsp = (struct rsp_que *)__mptr + 0xffffffffffffffa8UL;
#line 1039
  ha = rsp->hw;
#line 1041
  tmp = spinlock_check(& (rsp->hw)->hardware_lock);
#line 1041
  flags = _raw_spin_lock_irqsave(tmp);
#line 1042
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 1042
  vha = (struct scsi_qla_host *)tmp___0;
#line 1043
  qla24xx_process_response_queue(vha, rsp);
#line 1044
  spin_unlock_irqrestore(& (rsp->hw)->hardware_lock, flags);
#line 1045
  return;
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int qla25xx_create_rsp_que(struct qla_hw_data *ha , uint16_t options , uint8_t vp_idx ,
                           uint16_t rid , int req ) 
{ 
  int ret ;
  struct rsp_que *rsp ;
  struct scsi_qla_host *base_vha ;
  void *tmp ;
  uint16_t que_id ;
  device_reg_t *reg ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 1052
  ret = 0;
#line 1053
  rsp = (struct rsp_que *)0;
#line 1054
  tmp = pci_get_drvdata(ha->pdev);
#line 1054
  base_vha = (struct scsi_qla_host *)tmp;
#line 1055
  que_id = 0U;
#line 1058
  tmp___0 = kzalloc(256UL, 208U);
#line 1058
  rsp = (struct rsp_que *)tmp___0;
#line 1059
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 1060
    ql_log(1U, base_vha, 102, "Failed to allocate memory for response queue.\n");
#line 1062
    goto failed;
  } else {

  }
#line 1065
  rsp->length = 128U;
#line 1066
  tmp___1 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )rsp->length + 1) * 64UL,
                            & rsp->dma, 208U, (struct dma_attrs *)0);
#line 1066
  rsp->ring = (response_t *)tmp___1;
#line 1069
  if ((unsigned long )rsp->ring == (unsigned long )((response_t *)0)) {
#line 1070
    ql_log(1U, base_vha, 225, "Failed to allocate memory for response ring.\n");
#line 1072
    goto que_failed;
  } else {

  }
#line 1075
  mutex_lock_nested(& ha->vport_lock, 0U);
#line 1076
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& ha->rsp_qid_map), (unsigned long )ha->max_rsp_queues);
#line 1076
  que_id = (uint16_t )tmp___2;
#line 1077
  if ((int )((unsigned short )ha->max_rsp_queues) <= (int )que_id) {
#line 1078
    mutex_unlock(& ha->vport_lock);
#line 1079
    ql_log(1U, base_vha, 226, "No resources to create additional request queue.\n");
#line 1081
    goto que_failed;
  } else {

  }
#line 1083
  set_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 1085
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1086
    rsp->msix = ha->msix_entries + ((unsigned long )que_id + 1UL);
  } else {
#line 1088
    ql_log(1U, base_vha, 227, "MSIX not enalbled.\n");
  }
#line 1091
  *(ha->rsp_q_map + (unsigned long )que_id) = rsp;
#line 1092
  rsp->rid = rid;
#line 1093
  rsp->vp_idx = (uint16_t )vp_idx;
#line 1094
  rsp->hw = ha;
#line 1095
  ql_dbg(1073741824U, base_vha, 228, "queue_id=%d rid=%d vp_idx=%d hw=%p.\n", (int )que_id,
         (int )rsp->rid, (int )rsp->vp_idx, rsp->hw);
#line 1099
  if ((unsigned int )((unsigned char )((int )rsp->rid >> 8)) != 0U) {
#line 1100
    options = (uint16_t )((unsigned int )options | 16U);
  } else {

  }
#line 1102
  if ((unsigned int )((unsigned char )rsp->rid) != 0U) {
#line 1103
    options = (uint16_t )((unsigned int )options | 32U);
  } else {

  }
#line 1105
  if ((ha->device_type & 8192U) == 0U && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 1106
    options = (uint16_t )((unsigned int )options | 64U);
  } else {

  }
#line 1108
  rsp->options = options;
#line 1109
  rsp->id = que_id;
#line 1110
  reg = (unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) ? ha->mqiobase + (unsigned long )((int )que_id * 4096) : ha->iobase;
#line 1111
  rsp->rsp_q_in = & reg->isp25mq.rsp_q_in;
#line 1112
  rsp->rsp_q_out = & reg->isp25mq.rsp_q_out;
#line 1113
  mutex_unlock(& ha->vport_lock);
#line 1114
  ql_dbg(1048576U, base_vha, 49163, "options=%x id=%d rsp_q_in=%p rsp_q_out=%p", (int )rsp->options,
         (int )rsp->id, rsp->rsp_q_in, rsp->rsp_q_out);
#line 1118
  ql_dbg(1073741824U, base_vha, 229, "options=%x id=%d rsp_q_in=%p rsp_q_out=%p",
         (int )rsp->options, (int )rsp->id, rsp->rsp_q_in, rsp->rsp_q_out);
#line 1123
  ret = qla25xx_request_irq(rsp);
#line 1124
  if (ret != 0) {
#line 1125
    goto que_failed;
  } else {

  }
#line 1127
  ret = qla25xx_init_rsp_que(base_vha, rsp);
#line 1128
  if (ret != 0) {
#line 1129
    ql_log(0U, base_vha, 231, "%s failed.\n", "qla25xx_create_rsp_que");
#line 1131
    mutex_lock_nested(& ha->vport_lock, 0U);
#line 1132
    clear_bit((long )que_id, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 1133
    mutex_unlock(& ha->vport_lock);
#line 1134
    goto que_failed;
  } else {

  }
#line 1136
  if (req >= 0) {
#line 1137
    rsp->req = *(ha->req_q_map + (unsigned long )req);
  } else {
#line 1139
    rsp->req = (struct req_que *)0;
  }
#line 1141
  qla2x00_init_response_q_entries(rsp);
#line 1142
  if ((unsigned long )(rsp->hw)->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 1143
    __init_work(& rsp->q_work, 0);
#line 1143
    __constr_expr_0.counter = 137438953408L;
#line 1143
    rsp->q_work.data = __constr_expr_0;
#line 1143
    lockdep_init_map(& rsp->q_work.lockdep_map, "(&rsp->q_work)", & __key, 0);
#line 1143
    INIT_LIST_HEAD(& rsp->q_work.entry);
#line 1143
    rsp->q_work.func = & qla_do_work;
  } else {

  }
#line 1144
  return ((int )rsp->id);
  que_failed: 
#line 1147
  qla25xx_free_rsp_que(base_vha, rsp);
  failed: ;
#line 1149
  return (0);
}
}
#line 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void disable_suitable_timer_11(struct timer_list *timer ) 
{ 


  {
#line 1154
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_11) {
#line 1155
    ldv_timer_state_11 = 0;
#line 1156
    return;
  } else {

  }
#line 1158
  return;
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void choose_timer_11(struct timer_list *timer ) 
{ 


  {
#line 1162
  LDV_IN_INTERRUPT = 2;
#line 1163
  (*(timer->function))(timer->data);
#line 1164
  LDV_IN_INTERRUPT = 1;
#line 1165
  ldv_timer_state_11 = 2;
#line 1166
  return;
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int reg_timer_11(struct timer_list *timer ) 
{ 


  {
#line 1170
  ldv_timer_list_11 = timer;
#line 1171
  ldv_timer_state_11 = 1;
#line 1172
  return (0);
}
}
#line 1175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1175
  if ((unsigned long )ldv_timer_list_11 == (unsigned long )timer) {
#line 1176
    if (ldv_timer_state_11 == 2 || pending_flag != 0) {
#line 1177
      ldv_timer_list_11 = timer;
#line 1178
      ldv_timer_list_11->data = data;
#line 1179
      ldv_timer_state_11 = 1;
    } else {

    }
#line 1181
    return;
  } else {

  }
#line 1183
  reg_timer_11(timer);
#line 1184
  ldv_timer_list_11->data = data;
#line 1185
  return;
}
}
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int ldv_del_timer_55(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 1191
  tmp = del_timer(ldv_func_arg1);
#line 1191
  ldv_func_res = tmp;
#line 1193
  disable_suitable_timer_7(ldv_func_arg1);
#line 1195
  return (ldv_func_res);
}
}
#line 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int ldv_scsi_add_host_with_dma_56(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 1202
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 1202
  ldv_func_res = tmp;
#line 1204
  if (ldv_func_res == 0) {
#line 1205
    ldv_state_variable_72 = 1;
#line 1205
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 1209
  return (ldv_func_res);
}
}
#line 1212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mid.o.c.prepared"
int ldv_del_timer_sync_57(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;

  {
#line 1216
  tmp = del_timer_sync(ldv_func_arg1);
#line 1216
  ldv_func_res = tmp;
#line 1218
  disable_suitable_timer_7(ldv_func_arg1);
#line 1220
  return (ldv_func_res);
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_61(struct timer_list *ldv_func_arg1 ) ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int reg_timer_12(struct timer_list *timer ) ;
#line 240
void choose_timer_12(struct timer_list *timer ) ;
#line 250
void disable_suitable_timer_12(struct timer_list *timer ) ;
#line 263
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 84 "include/linux/seq_file.h"
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 85
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 92
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 125
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 127
extern int single_release(struct inode * , struct file * ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_62(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 49 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 53
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 58
extern void debugfs_remove(struct dentry * ) ;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static struct dentry *qla2x00_dfs_root  ;
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static atomic_t qla2x00_dfs_root_count  ;
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static int qla2x00_dfs_fce_show(struct seq_file *s , void *unused ) 
{ 
  scsi_qla_host_t *vha ;
  uint32_t cnt ;
  uint32_t *fce ;
  uint64_t fce_start ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;

  {
#line 317
  vha = (scsi_qla_host_t *)s->private;
#line 321
  ha = vha->hw;
#line 323
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 325
  seq_printf(s, "FCE Trace Buffer\n");
#line 326
  seq_printf(s, "In Pointer = %llx\n\n", ha->fce_wr);
#line 327
  seq_printf(s, "Base = %llx\n\n", ha->fce_dma);
#line 328
  seq_printf(s, "FCE Enable Registers\n");
#line 329
  seq_printf(s, "%08x %08x %08x %08x %08x %08x\n", (int )ha->fce_mb[0], (int )ha->fce_mb[2],
             (int )ha->fce_mb[3], (int )ha->fce_mb[4], (int )ha->fce_mb[5], (int )ha->fce_mb[6]);
#line 333
  fce = (uint32_t *)ha->fce;
#line 334
  fce_start = ha->fce_dma;
#line 335
  cnt = 0U;
#line 335
  goto ldv_43551;
  ldv_43550: ;
#line 336
  if ((cnt & 7U) == 0U) {
#line 337
    seq_printf(s, "\n%llx: ", (uint64_t )(cnt * 4U) + fce_start);
  } else {
#line 340
    seq_printf(s, " ");
  }
#line 341
  tmp = fce;
#line 341
  fce = fce + 1;
#line 341
  seq_printf(s, "%08x", *tmp);
#line 335
  cnt = cnt + 1U;
  ldv_43551: ;
#line 335
  if ((ha->fce_bufs * 1024U) / 4U > cnt) {
#line 337
    goto ldv_43550;
  } else {

  }
#line 344
  seq_printf(s, "\nEnd\n");
#line 346
  mutex_unlock(& ha->fce_mutex);
#line 348
  return (0);
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static int qla2x00_dfs_fce_open(struct inode *inode , struct file *file ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int rval ;
  int tmp ;

  {
#line 354
  vha = (scsi_qla_host_t *)inode->i_private;
#line 355
  ha = vha->hw;
#line 358
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 359
    goto out;
  } else {

  }
#line 361
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 364
  rval = qla2x00_disable_fce_trace(vha, & ha->fce_wr, & ha->fce_rd);
#line 365
  if (rval != 0) {
#line 366
    ql_dbg(8388608U, vha, 28764, "DebugFS: Unable to disable FCE (%d).\n", rval);
  } else {

  }
#line 369
  ha->flags.fce_enabled = 0U;
#line 371
  mutex_unlock(& ha->fce_mutex);
  out: 
#line 373
  tmp = single_open(file, & qla2x00_dfs_fce_show, (void *)vha);
#line 373
  return (tmp);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static int qla2x00_dfs_fce_release(struct inode *inode , struct file *file ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  int rval ;
  int tmp ;

  {
#line 379
  vha = (scsi_qla_host_t *)inode->i_private;
#line 380
  ha = vha->hw;
#line 383
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 384
    goto out;
  } else {

  }
#line 386
  mutex_lock_nested(& ha->fce_mutex, 0U);
#line 389
  ha->flags.fce_enabled = 1U;
#line 390
  memset(ha->fce, 0, (size_t )(ha->fce_bufs * 1024U));
#line 391
  rval = qla2x00_enable_fce_trace(vha, ha->fce_dma, (int )((uint16_t )ha->fce_bufs),
                                  (uint16_t *)(& ha->fce_mb), & ha->fce_bufs);
#line 393
  if (rval != 0) {
#line 394
    ql_dbg(8388608U, vha, 28685, "DebugFS: Unable to reinitialize FCE (%d).\n", rval);
#line 396
    ha->flags.fce_enabled = 0U;
  } else {

  }
#line 399
  mutex_unlock(& ha->fce_mutex);
  out: 
#line 401
  tmp = single_release(inode, file);
#line 401
  return (tmp);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
static struct file_operations  const  dfs_fce_ops  = 
#line 404
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, & qla2x00_dfs_fce_open, 0,
    & qla2x00_dfs_fce_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int qla2x00_dfs_setup(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct lock_class_key __key ;

  {
#line 414
  ha = vha->hw;
#line 416
  if (((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) {
#line 417
    goto out;
  } else {

  }
#line 418
  if ((unsigned long )ha->fce == (unsigned long )((void *)0)) {
#line 419
    goto out;
  } else {

  }
#line 421
  if ((unsigned long )qla2x00_dfs_root != (unsigned long )((struct dentry *)0)) {
#line 422
    goto create_dir;
  } else {

  }
#line 424
  atomic_set(& qla2x00_dfs_root_count, 0);
#line 425
  qla2x00_dfs_root = debugfs_create_dir("qla2xxx", (struct dentry *)0);
#line 426
  if ((unsigned long )qla2x00_dfs_root == (unsigned long )((struct dentry *)0)) {
#line 427
    ql_log(1U, vha, 247, "Unable to create debugfs root directory.\n");
#line 429
    goto out;
  } else {

  }
  create_dir: ;
#line 433
  if ((unsigned long )ha->dfs_dir != (unsigned long )((struct dentry *)0)) {
#line 434
    goto create_nodes;
  } else {

  }
#line 436
  __mutex_init(& ha->fce_mutex, "&ha->fce_mutex", & __key);
#line 437
  ha->dfs_dir = debugfs_create_dir((char const   *)(& vha->host_str), qla2x00_dfs_root);
#line 438
  if ((unsigned long )ha->dfs_dir == (unsigned long )((struct dentry *)0)) {
#line 439
    ql_log(1U, vha, 248, "Unable to create debugfs ha directory.\n");
#line 441
    goto out;
  } else {

  }
#line 444
  atomic_inc(& qla2x00_dfs_root_count);
  create_nodes: 
#line 447
  ha->dfs_fce = debugfs_create_file("fce", 256, ha->dfs_dir, (void *)vha, & dfs_fce_ops);
#line 449
  if ((unsigned long )ha->dfs_fce == (unsigned long )((struct dentry *)0)) {
#line 450
    ql_log(1U, vha, 249, "Unable to create debugfs fce node.\n");
#line 452
    goto out;
  } else {

  }
  out: ;
#line 455
  return (0);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int qla2x00_dfs_remove(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 461
  ha = vha->hw;
#line 462
  if ((unsigned long )ha->dfs_fce != (unsigned long )((struct dentry *)0)) {
#line 463
    debugfs_remove(ha->dfs_fce);
#line 464
    ha->dfs_fce = (struct dentry *)0;
  } else {

  }
#line 467
  if ((unsigned long )ha->dfs_dir != (unsigned long )((struct dentry *)0)) {
#line 468
    debugfs_remove(ha->dfs_dir);
#line 469
    ha->dfs_dir = (struct dentry *)0;
#line 470
    atomic_dec(& qla2x00_dfs_root_count);
  } else {

  }
#line 473
  tmp = atomic_read((atomic_t const   *)(& qla2x00_dfs_root_count));
#line 473
  if (tmp == 0 && (unsigned long )qla2x00_dfs_root != (unsigned long )((struct dentry *)0)) {
#line 475
    debugfs_remove(qla2x00_dfs_root);
#line 476
    qla2x00_dfs_root = (struct dentry *)0;
  } else {

  }
#line 479
  return (0);
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int ldv_retval_0  ;
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int reg_timer_12(struct timer_list *timer ) 
{ 


  {
#line 486
  ldv_timer_list_12 = timer;
#line 487
  ldv_timer_state_12 = 1;
#line 488
  return (0);
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void choose_timer_12(struct timer_list *timer ) 
{ 


  {
#line 492
  LDV_IN_INTERRUPT = 2;
#line 493
  (*(timer->function))(timer->data);
#line 494
  LDV_IN_INTERRUPT = 1;
#line 495
  ldv_timer_state_12 = 2;
#line 496
  return;
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void disable_suitable_timer_12(struct timer_list *timer ) 
{ 


  {
#line 500
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_12) {
#line 501
    ldv_timer_state_12 = 0;
#line 502
    return;
  } else {

  }
#line 504
  return;
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 507
  if ((unsigned long )ldv_timer_list_12 == (unsigned long )timer) {
#line 508
    if (ldv_timer_state_12 == 2 || pending_flag != 0) {
#line 509
      ldv_timer_list_12 = timer;
#line 510
      ldv_timer_list_12->data = data;
#line 511
      ldv_timer_state_12 = 1;
    } else {

    }
#line 513
    return;
  } else {

  }
#line 515
  reg_timer_12(timer);
#line 516
  ldv_timer_list_12->data = data;
#line 517
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void ldv_file_operations_18(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 521
  tmp = ldv_zalloc(1032UL);
#line 521
  dfs_fce_ops_group1 = (struct inode *)tmp;
#line 522
  tmp___0 = ldv_zalloc(360UL);
#line 522
  dfs_fce_ops_group2 = (struct file *)tmp___0;
#line 523
  return;
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  loff_t ldvarg83 ;
  loff_t tmp ;
  char *ldvarg86 ;
  void *tmp___0 ;
  int ldvarg82 ;
  int tmp___1 ;
  loff_t *ldvarg84 ;
  void *tmp___2 ;
  size_t ldvarg85 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 527
  tmp = __VERIFIER_nondet_loff_t();
#line 527
  ldvarg83 = tmp;
#line 528
  tmp___0 = ldv_zalloc(1UL);
#line 528
  ldvarg86 = (char *)tmp___0;
#line 529
  tmp___1 = __VERIFIER_nondet_int();
#line 529
  ldvarg82 = tmp___1;
#line 530
  tmp___2 = ldv_zalloc(8UL);
#line 530
  ldvarg84 = (loff_t *)tmp___2;
#line 531
  tmp___3 = __VERIFIER_nondet_size_t();
#line 531
  ldvarg85 = tmp___3;
#line 533
  tmp___4 = __VERIFIER_nondet_int();
#line 533
  switch (tmp___4) {
  case 0: ;
#line 536
  if (ldv_state_variable_18 == 2) {
#line 538
    qla2x00_dfs_fce_release(dfs_fce_ops_group1, dfs_fce_ops_group2);
#line 539
    ldv_state_variable_18 = 1;
#line 540
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 543
  goto ldv_43609;
  case 1: ;
#line 546
  if (ldv_state_variable_18 == 1) {
#line 548
    ldv_retval_0 = qla2x00_dfs_fce_open(dfs_fce_ops_group1, dfs_fce_ops_group2);
#line 549
    if (ldv_retval_0 == 0) {
#line 550
      ldv_state_variable_18 = 2;
#line 551
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 555
  goto ldv_43609;
  case 2: ;
#line 558
  if (ldv_state_variable_18 == 2) {
#line 560
    seq_read(dfs_fce_ops_group2, ldvarg86, ldvarg85, ldvarg84);
#line 562
    ldv_state_variable_18 = 2;
  } else {

  }
#line 565
  goto ldv_43609;
  case 3: ;
#line 568
  if (ldv_state_variable_18 == 2) {
#line 570
    seq_lseek(dfs_fce_ops_group2, ldvarg83, ldvarg82);
#line 572
    ldv_state_variable_18 = 2;
  } else {

  }
#line 575
  goto ldv_43609;
  default: 
#line 576
  ldv_stop();
  }
  ldv_43609: ;
#line 580
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int ldv_del_timer_61(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 585
  tmp = del_timer(ldv_func_arg1);
#line 585
  ldv_func_res = tmp;
#line 587
  disable_suitable_timer_7(ldv_func_arg1);
#line 589
  return (ldv_func_res);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_dfs.o.c.prepared"
int ldv_scsi_add_host_with_dma_62(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 596
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 596
  ldv_func_res = tmp;
#line 598
  if (ldv_func_res == 0) {
#line 599
    ldv_state_variable_72 = 1;
#line 599
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 603
  return (ldv_func_res);
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_65(struct timer_list *ldv_func_arg1 ) ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void choose_timer_13(struct timer_list *timer ) ;
#line 226
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 253
void disable_suitable_timer_13(struct timer_list *timer ) ;
#line 286
int reg_timer_13(struct timer_list *timer ) ;
#line 242 "include/linux/scatterlist.h"
extern size_t sg_copy_from_buffer(struct scatterlist * , unsigned int  , void * ,
                                  size_t  ) ;
#line 244
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
#line 59 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs___0(struct device *dev , struct scatterlist *sg ,
                                            int nents , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 65
  if (tmp___1 != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
    ldv_21302: ;
#line 65
    goto ldv_21302;
  } else {

  }
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 69
  return;
}
}
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_66(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 646 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
void qla2x00_bsg_job_done(void *data , void *ptr , int res ) ;
#line 647
void qla2x00_bsg_sp_free(void *data , void *ptr ) ;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void qla2x00_bsg_job_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct scsi_qla_host *vha ;
  struct fc_bsg_job *bsg_job ;

  {
#line 316
  sp = (srb_t *)ptr;
#line 317
  vha = (struct scsi_qla_host *)data;
#line 318
  bsg_job = sp->u.bsg_job;
#line 320
  (bsg_job->reply)->result = (uint32_t )res;
#line 321
  (*(bsg_job->job_done))(bsg_job);
#line 322
  (*(sp->free))((void *)vha, (void *)sp);
#line 323
  return;
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void qla2x00_bsg_sp_free(void *data , void *ptr ) 
{ 
  srb_t *sp ;
  struct scsi_qla_host *vha ;
  struct fc_bsg_job *bsg_job ;
  struct qla_hw_data *ha ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;

  {
#line 328
  sp = (srb_t *)ptr;
#line 329
  vha = (sp->fcport)->vha;
#line 330
  bsg_job = sp->u.bsg_job;
#line 331
  ha = vha->hw;
#line 334
  if ((unsigned int )sp->type == 11U) {
#line 335
    piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 338
    if ((int )piocb_rqst->flags & 1) {
#line 339
      dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
    } else {

    }
#line 343
    if (((int )piocb_rqst->flags & 2) != 0) {
#line 344
      dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
    } else {

    }
  } else {
#line 348
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
#line 351
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  }
#line 355
  if (((unsigned int )sp->type == 5U || (unsigned int )sp->type == 11U) || (unsigned int )sp->type == 4U) {
#line 358
    kfree((void const   *)sp->fcport);
  } else {

  }
#line 359
  qla2x00_rel_sp(vha, sp);
#line 360
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int qla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha , struct qla_fcp_prio_cfg *pri_cfg ,
                               uint8_t flag ) 
{ 
  int i ;
  int ret ;
  int num_valid ;
  uint8_t *bcode ;
  struct qla_fcp_prio_entry *pri_entry ;
  uint32_t *bcode_val_ptr ;
  uint32_t bcode_val ;

  {
#line 371
  ret = 1;
#line 372
  num_valid = 0;
#line 373
  bcode = (uint8_t *)pri_cfg;
#line 374
  bcode_val_ptr = (uint32_t *)pri_cfg;
#line 375
  bcode_val = *bcode_val_ptr;
#line 377
  if (bcode_val == 4294967295U) {
#line 379
    ql_dbg(8388608U, vha, 28753, "No FCP Priority config data.\n");
#line 381
    return (0);
  } else {

  }
#line 384
  if ((((unsigned int )*bcode != 72U || (unsigned int )*(bcode + 1UL) != 81U) || (unsigned int )*(bcode + 2UL) != 79U) || (unsigned int )*(bcode + 3UL) != 83U) {
#line 387
    ql_dbg(8388608U, vha, 28754, "Invalid FCP Priority data header. bcode=0x%x.\n",
           bcode_val);
#line 390
    return (0);
  } else {

  }
#line 392
  if ((unsigned int )flag != 1U) {
#line 393
    return (ret);
  } else {

  }
#line 395
  pri_entry = (struct qla_fcp_prio_entry *)(& pri_cfg->entry);
#line 396
  i = 0;
#line 396
  goto ldv_43546;
  ldv_43545: ;
#line 397
  if (((int )pri_entry->flags & 2) != 0) {
#line 398
    num_valid = num_valid + 1;
  } else {

  }
#line 399
  pri_entry = pri_entry + 1;
#line 396
  i = i + 1;
  ldv_43546: ;
#line 396
  if ((int )pri_cfg->num_entries > i) {
#line 398
    goto ldv_43545;
  } else {

  }

#line 402
  if (num_valid == 0) {
#line 404
    ql_dbg(8388608U, vha, 28755, "No valid FCP Priority data entries.\n");
#line 406
    ret = 0;
  } else {
#line 409
    ql_dbg(8388608U, vha, 28756, "Valid FCP priority data. num entries = %d.\n", num_valid);
  }
#line 414
  return (ret);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla24xx_proc_fcp_prio_cfg_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int ret ;
  uint32_t len ;
  uint32_t oper ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 420
  host = bsg_job->shost;
#line 421
  tmp = shost_priv(host);
#line 421
  vha = (scsi_qla_host_t *)tmp;
#line 422
  ha = vha->hw;
#line 423
  ret = 0;
#line 427
  if ((((((ha->device_type & 128U) == 0U && (ha->device_type & 256U) == 0U) && ((ha->device_type & 512U) == 0U && (ha->device_type & 1024U) == 0U)) && (ha->device_type & 4096U) == 0U) && (ha->device_type & 2048U) == 0U) && ((ha->device_type & 16384U) == 0U && (ha->device_type & 262144U) == 0U)) {
#line 428
    ret = -22;
#line 429
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 433
  oper = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 436
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0) && oper != 3U) {
#line 437
    ret = -22;
#line 438
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 440
  switch (oper) {
  case 0U: ;
#line 442
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 443
    ha->flags.fcp_prio_enabled = 0U;
#line 444
    (ha->fcp_prio_cfg)->attributes = (unsigned int )(ha->fcp_prio_cfg)->attributes & 254U;
#line 446
    qla24xx_update_all_fcp_prio(vha);
#line 447
    (bsg_job->reply)->result = 0U;
  } else {
#line 449
    ret = -22;
#line 450
    (bsg_job->reply)->result = 458752U;
#line 451
    goto exit_fcp_prio_cfg;
  }
#line 453
  goto ldv_43559;
  case 1U: ;
#line 456
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 457
    if ((unsigned long )ha->fcp_prio_cfg != (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 458
      ha->flags.fcp_prio_enabled = 1U;
#line 459
      (ha->fcp_prio_cfg)->attributes = (uint8_t )((unsigned int )(ha->fcp_prio_cfg)->attributes | 1U);
#line 461
      qla24xx_update_all_fcp_prio(vha);
#line 462
      (bsg_job->reply)->result = 0U;
    } else {
#line 464
      ret = -22;
#line 465
      (bsg_job->reply)->result = 458752U;
#line 466
      goto exit_fcp_prio_cfg;
    }
  } else {

  }
#line 469
  goto ldv_43559;
  case 2U: 
#line 472
  len = bsg_job->reply_payload.payload_len;
#line 473
  if (len == 0U || len > 32768U) {
#line 474
    ret = -22;
#line 475
    (bsg_job->reply)->result = 458752U;
#line 476
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 479
  (bsg_job->reply)->result = 0U;
#line 480
  tmp___0 = sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                                (void *)ha->fcp_prio_cfg, (size_t )len);
#line 480
  (bsg_job->reply)->reply_payload_rcv_len = (uint32_t )tmp___0;
#line 486
  goto ldv_43559;
  case 3U: 
#line 489
  len = bsg_job->request_payload.payload_len;
#line 490
  if (len == 0U || len > 32768U) {
#line 491
    (bsg_job->reply)->result = 458752U;
#line 492
    ret = -22;
#line 493
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 496
  if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 497
    tmp___1 = vmalloc(32768UL);
#line 497
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)tmp___1;
#line 498
    if ((unsigned long )ha->fcp_prio_cfg == (unsigned long )((struct qla_fcp_prio_cfg *)0)) {
#line 499
      ql_log(1U, vha, 28752, "Unable to allocate memory for fcp prio config data (%x).\n",
             32768);
#line 502
      (bsg_job->reply)->result = 458752U;
#line 503
      ret = -12;
#line 504
      goto exit_fcp_prio_cfg;
    } else {

    }
  } else {

  }
#line 508
  memset((void *)ha->fcp_prio_cfg, 0, 32768UL);
#line 509
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)ha->fcp_prio_cfg, 32768UL);
#line 515
  tmp___2 = qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1);
#line 515
  if (tmp___2 == 0) {
#line 517
    (bsg_job->reply)->result = 458752U;
#line 518
    ret = -22;
#line 522
    vfree((void const   *)ha->fcp_prio_cfg);
#line 523
    ha->fcp_prio_cfg = (struct qla_fcp_prio_cfg *)0;
#line 524
    goto exit_fcp_prio_cfg;
  } else {

  }
#line 527
  ha->flags.fcp_prio_enabled = 0U;
#line 528
  if ((int )(ha->fcp_prio_cfg)->attributes & 1) {
#line 529
    ha->flags.fcp_prio_enabled = 1U;
  } else {

  }
#line 530
  qla24xx_update_all_fcp_prio(vha);
#line 531
  (bsg_job->reply)->result = 0U;
#line 532
  goto ldv_43559;
  default: 
#line 534
  ret = -22;
#line 535
  goto ldv_43559;
  }
  ldv_43559: ;
  exit_fcp_prio_cfg: ;
#line 538
  if (ret == 0) {
#line 539
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 540
  return (ret);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_process_els(struct fc_bsg_job *bsg_job ) 
{ 
  struct fc_rport *rport ;
  fc_port_t *fcport ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  srb_t *sp ;
  char const   *type ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  int rval ;
  uint16_t nextlid ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 547
  fcport = (fc_port_t *)0;
#line 554
  rval = 262144;
#line 555
  nextlid = 0U;
#line 557
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 558
    rport = bsg_job->rport;
#line 559
    fcport = *((fc_port_t **)rport->dd_data);
#line 560
    host = dev_to_shost(rport->dev.parent);
#line 561
    tmp = shost_priv(host);
#line 561
    vha = (scsi_qla_host_t *)tmp;
#line 562
    ha = vha->hw;
#line 563
    type = "FC_BSG_RPT_ELS";
  } else {
#line 565
    host = bsg_job->shost;
#line 566
    tmp___0 = shost_priv(host);
#line 566
    vha = (scsi_qla_host_t *)tmp___0;
#line 567
    ha = vha->hw;
#line 568
    type = "FC_BSG_HST_ELS_NOLOGIN";
  }
#line 571
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 572
    ql_log(1U, vha, 28677, "Host not online.\n");
#line 573
    rval = -5;
#line 574
    goto done;
  } else {

  }
#line 578
  if ((ha->device_type & 134217728U) == 0U) {
#line 579
    ql_dbg(8388608U, vha, 28673, "ELS passthru not supported for ISP23xx based adapters.\n");
#line 581
    rval = -1;
#line 582
    goto done;
  } else {

  }
#line 586
  if (bsg_job->request_payload.sg_cnt > 1 || bsg_job->reply_payload.sg_cnt > 1) {
#line 588
    ql_dbg(8388608U, vha, 28674, "Multiple SG\'s are not suppored for ELS requests, request_sg_cnt=%x reply_sg_cnt=%x.\n",
           bsg_job->request_payload.sg_cnt, bsg_job->reply_payload.sg_cnt);
#line 593
    rval = -1;
#line 594
    goto done;
  } else {

  }
#line 598
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 602
    tmp___1 = qla2x00_fabric_login(vha, fcport, & nextlid);
#line 602
    if (tmp___1 != 0) {
#line 603
      ql_dbg(8388608U, vha, 28675, "Failed to login port %06X for ELS passthru.\n",
             (int )fcport->d_id.b24);
#line 606
      rval = -5;
#line 607
      goto done;
    } else {

    }
  } else {
#line 615
    fcport = qla2x00_alloc_fcport(vha, 208U);
#line 616
    if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 617
      rval = -12;
#line 618
      goto done;
    } else {

    }
#line 622
    fcport->vha = vha;
#line 623
    fcport->d_id.b.al_pa = (bsg_job->request)->rqst_data.h_els.port_id[0];
#line 625
    fcport->d_id.b.area = (bsg_job->request)->rqst_data.h_els.port_id[1];
#line 627
    fcport->d_id.b.domain = (bsg_job->request)->rqst_data.h_els.port_id[2];
#line 629
    fcport->loop_id = (unsigned int )fcport->d_id.b.al_pa == 253U ? 2045U : 2046U;
  }
#line 634
  req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 637
  if (req_sg_cnt == 0) {
#line 638
    rval = -12;
#line 639
    goto done_free_fcport;
  } else {

  }
#line 642
  rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 644
  if (rsp_sg_cnt == 0) {
#line 645
    rval = -12;
#line 646
    goto done_free_fcport;
  } else {

  }
#line 649
  if (bsg_job->request_payload.sg_cnt != req_sg_cnt || bsg_job->reply_payload.sg_cnt != rsp_sg_cnt) {
#line 651
    ql_log(1U, vha, 28680, "dma mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt:%x reply_sg_cnt:%x dma_reply_sg_cnt:%x.\n",
           bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           rsp_sg_cnt);
#line 656
    rval = -11;
#line 657
    goto done_unmap_sg;
  } else {

  }
#line 661
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 662
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 663
    rval = -12;
#line 664
    goto done_unmap_sg;
  } else {

  }
#line 667
  sp->type = (bsg_job->request)->msgcode == 1073741825U ? 3U : 4U;
#line 670
  sp->name = (bsg_job->request)->msgcode == 1073741825U ? (char *)"bsg_els_rpt" : (char *)"bsg_els_hst";
#line 673
  sp->u.bsg_job = bsg_job;
#line 674
  sp->free = & qla2x00_bsg_sp_free;
#line 675
  sp->done = & qla2x00_bsg_job_done;
#line 677
  ql_dbg(8388608U, vha, 28682, "bsg rqst type: %s els type: %x - loop-id=%x portid=%-2x%02x%02x.\n",
         type, (int )(bsg_job->request)->rqst_data.h_els.command_code, (int )fcport->loop_id,
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 683
  rval = qla2x00_start_sp(sp);
#line 684
  if (rval != 0) {
#line 685
    ql_log(1U, vha, 28686, "qla2x00_start_sp failed = %d\n", rval);
#line 687
    qla2x00_rel_sp(vha, sp);
#line 688
    rval = -5;
#line 689
    goto done_unmap_sg;
  } else {

  }
#line 691
  return (rval);
  done_unmap_sg: 
#line 694
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 696
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
#line 698
  goto done_free_fcport;
  done_free_fcport: ;
#line 701
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 702
    kfree((void const   *)fcport);
  } else {

  }
  done: ;
#line 704
  return (rval);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
__inline uint16_t qla24xx_calc_ct_iocbs(uint16_t dsds ) 
{ 
  uint16_t iocbs ;

  {
#line 712
  iocbs = 1U;
#line 713
  if ((unsigned int )dsds > 2U) {
#line 714
    iocbs = (int )((uint16_t )(((int )dsds + -2) / 5)) + (int )iocbs;
#line 715
    if (((int )dsds + -2) % 5 != 0) {
#line 716
      iocbs = (uint16_t )((int )iocbs + 1);
    } else {

    }
  } else {

  }
#line 718
  return (iocbs);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_process_ct(struct fc_bsg_job *bsg_job ) 
{ 
  srb_t *sp ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  uint16_t loop_id ;
  struct fc_port *fcport ;
  char *type ;
  fc_port_t *tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 725
  host = bsg_job->shost;
#line 726
  tmp = shost_priv(host);
#line 726
  vha = (scsi_qla_host_t *)tmp;
#line 727
  ha = vha->hw;
#line 728
  rval = 262144;
#line 732
  type = (char *)"FC_BSG_HST_CT";
#line 734
  req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 737
  if (req_sg_cnt == 0) {
#line 738
    ql_log(1U, vha, 28687, "dma_map_sg return %d for request\n", req_sg_cnt);
#line 740
    rval = -12;
#line 741
    goto done;
  } else {

  }
#line 744
  rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 746
  if (rsp_sg_cnt == 0) {
#line 747
    ql_log(1U, vha, 28688, "dma_map_sg return %d for reply\n", rsp_sg_cnt);
#line 749
    rval = -12;
#line 750
    goto done;
  } else {

  }
#line 753
  if (bsg_job->request_payload.sg_cnt != req_sg_cnt || bsg_job->reply_payload.sg_cnt != rsp_sg_cnt) {
#line 755
    ql_log(1U, vha, 28689, "request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x dma_reply_sg_cnt: %x\n",
           bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           rsp_sg_cnt);
#line 759
    rval = -11;
#line 760
    goto done_unmap_sg;
  } else {

  }
#line 763
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 764
    ql_log(1U, vha, 28690, "Host is not online.\n");
#line 766
    rval = -5;
#line 767
    goto done_unmap_sg;
  } else {

  }
#line 770
  loop_id = (uint16_t )((bsg_job->request)->rqst_data.h_ct.preamble_word1 >> 24);
#line 773
  switch ((int )loop_id) {
  case 252: 
#line 775
  loop_id = 2044U;
#line 776
  goto ldv_43601;
  case 250: 
#line 778
  loop_id = vha->mgmt_svr_loop_id;
#line 779
  goto ldv_43601;
  default: 
#line 781
  ql_dbg(8388608U, vha, 28691, "Unknown loop id: %x.\n", (int )loop_id);
#line 783
  rval = -22;
#line 784
  goto done_unmap_sg;
  }
  ldv_43601: 
#line 792
  tmp___0 = qla2x00_alloc_fcport(vha, 208U);
#line 792
  fcport = tmp___0;
#line 793
  if ((unsigned long )fcport == (unsigned long )((struct fc_port *)0)) {
#line 794
    ql_log(1U, vha, 28692, "Failed to allocate fcport.\n");
#line 796
    rval = -12;
#line 797
    goto done_unmap_sg;
  } else {

  }
#line 801
  fcport->vha = vha;
#line 802
  fcport->d_id.b.al_pa = (bsg_job->request)->rqst_data.h_ct.port_id[0];
#line 803
  fcport->d_id.b.area = (bsg_job->request)->rqst_data.h_ct.port_id[1];
#line 804
  fcport->d_id.b.domain = (bsg_job->request)->rqst_data.h_ct.port_id[2];
#line 805
  fcport->loop_id = loop_id;
#line 808
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 809
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 810
    ql_log(1U, vha, 28693, "qla2x00_get_sp failed.\n");
#line 812
    rval = -12;
#line 813
    goto done_free_fcport;
  } else {

  }
#line 816
  sp->type = 5U;
#line 817
  sp->name = (char *)"bsg_ct";
#line 818
  tmp___1 = qla24xx_calc_ct_iocbs((int )((uint16_t )req_sg_cnt) + (int )((uint16_t )rsp_sg_cnt));
#line 818
  sp->iocbs = (int )tmp___1;
#line 819
  sp->u.bsg_job = bsg_job;
#line 820
  sp->free = & qla2x00_bsg_sp_free;
#line 821
  sp->done = & qla2x00_bsg_job_done;
#line 823
  ql_dbg(8388608U, vha, 28694, "bsg rqst type: %s else type: %x - loop-id=%x portid=%02x%02x%02x.\n",
         type, (bsg_job->request)->rqst_data.h_ct.preamble_word2 >> 16, (int )fcport->loop_id,
         (int )fcport->d_id.b.domain, (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
#line 830
  rval = qla2x00_start_sp(sp);
#line 831
  if (rval != 0) {
#line 832
    ql_log(1U, vha, 28695, "qla2x00_start_sp failed=%d.\n", rval);
#line 834
    qla2x00_rel_sp(vha, sp);
#line 835
    rval = -5;
#line 836
    goto done_free_fcport;
  } else {

  }
#line 838
  return (rval);
  done_free_fcport: 
#line 841
  kfree((void const   *)fcport);
  done_unmap_sg: 
#line 843
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 845
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done: ;
#line 848
  return (rval);
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
__inline static int qla81xx_reset_loopback_mode(scsi_qla_host_t *vha , uint16_t *config ,
                                                int wait , int wait2 ) 
{ 
  int ret ;
  int rval ;
  uint16_t new_config[4U] ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 856
  ret = 0;
#line 857
  rval = 0;
#line 859
  ha = vha->hw;
#line 861
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 862
    goto done_reset_internal;
  } else {

  }
#line 864
  memset((void *)(& new_config), 0, 8UL);
#line 865
  if (((int )*config & 14) >> 1 == 2 || ((int )*config & 14) >> 1 == 4) {
#line 869
    new_config[0] = (unsigned int )*config & 65521U;
#line 870
    ql_dbg(8388608U, vha, 28863, "new_config[0]=%02x\n", (int )new_config[0] & 14);
#line 872
    __len = 6UL;
#line 872
    if (__len > 63UL) {
#line 872
      __ret = __memcpy((void *)(& new_config) + 1U, (void const   *)config + 1U, __len);
    } else {
#line 872
      __ret = __builtin_memcpy((void *)(& new_config) + 1U, (void const   *)config + 1U,
                               __len);
    }
#line 874
    ha->notify_dcbx_comp = wait;
#line 875
    ha->notify_lb_portup_comp = wait2;
#line 877
    ret = qla81xx_set_port_config(vha, (uint16_t *)(& new_config));
#line 878
    if (ret != 0) {
#line 879
      ql_log(1U, vha, 28709, "Set port config failed.\n");
#line 881
      ha->notify_dcbx_comp = 0;
#line 882
      ha->notify_lb_portup_comp = 0;
#line 883
      rval = -22;
#line 884
      goto done_reset_internal;
    } else {

    }
#line 888
    if (wait != 0) {
#line 888
      tmp = wait_for_completion_timeout(& ha->dcbx_comp, 5000UL);
#line 888
      if (tmp == 0UL) {
#line 890
        ql_dbg(8388608U, vha, 28710, "DCBX completion not received.\n");
#line 892
        ha->notify_dcbx_comp = 0;
#line 893
        ha->notify_lb_portup_comp = 0;
#line 894
        rval = -22;
#line 895
        goto done_reset_internal;
      } else {
#line 897
        ql_dbg(8388608U, vha, 28711, "DCBX completion received.\n");
      }
    } else {
#line 897
      ql_dbg(8388608U, vha, 28711, "DCBX completion received.\n");
    }
#line 900
    if (wait2 != 0) {
#line 900
      tmp___0 = wait_for_completion_timeout(& ha->lb_portup_comp, 2500UL);
#line 900
      if (tmp___0 == 0UL) {
#line 903
        ql_dbg(8388608U, vha, 28869, "Port up completion not received.\n");
#line 905
        ha->notify_lb_portup_comp = 0;
#line 906
        rval = -22;
#line 907
        goto done_reset_internal;
      } else {
#line 909
        ql_dbg(8388608U, vha, 28870, "Port up completion received.\n");
      }
    } else {
#line 909
      ql_dbg(8388608U, vha, 28870, "Port up completion received.\n");
    }
#line 912
    ha->notify_dcbx_comp = 0;
#line 913
    ha->notify_lb_portup_comp = 0;
  } else {

  }
  done_reset_internal: ;
#line 916
  return (rval);
}
}
#line 924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
__inline static int qla81xx_set_loopback_mode(scsi_qla_host_t *vha , uint16_t *config ,
                                              uint16_t *new_config , uint16_t mode ) 
{ 
  int ret ;
  int rval ;
  unsigned long rem_tmo ;
  unsigned long current_tmo ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 927
  ret = 0;
#line 928
  rval = 0;
#line 929
  rem_tmo = 0UL;
#line 929
  current_tmo = 0UL;
#line 930
  ha = vha->hw;
#line 932
  if (((ha->device_type & 8192U) == 0U && (ha->device_type & 65536U) == 0U) && (ha->device_type & 262144U) == 0U) {
#line 933
    goto done_set_internal;
  } else {

  }
#line 935
  if ((unsigned int )mode == 241U) {
#line 936
    *new_config = (uint16_t )((unsigned int )*config | 4U);
  } else
#line 937
  if ((unsigned int )mode == 242U) {
#line 938
    *new_config = (uint16_t )((unsigned int )*config | 8U);
  } else {

  }
#line 939
  ql_dbg(8388608U, vha, 28862, "new_config[0]=%02x\n", (int )*new_config & 14);
#line 942
  __len = 6UL;
#line 942
  if (__len > 63UL) {
#line 942
    __ret = __memcpy((void *)new_config + 1U, (void const   *)config + 1U, __len);
  } else {
#line 942
    __ret = __builtin_memcpy((void *)new_config + 1U, (void const   *)config + 1U,
                             __len);
  }
#line 944
  ha->notify_dcbx_comp = 1;
#line 945
  ret = qla81xx_set_port_config(vha, new_config);
#line 946
  if (ret != 0) {
#line 947
    ql_log(1U, vha, 28705, "set port config failed.\n");
#line 949
    ha->notify_dcbx_comp = 0;
#line 950
    rval = -22;
#line 951
    goto done_set_internal;
  } else {

  }
#line 955
  current_tmo = 5000UL;
  ldv_43635: 
#line 957
  rem_tmo = wait_for_completion_timeout(& ha->dcbx_comp, current_tmo);
#line 959
  if (ha->idc_extend_tmo == 0U || rem_tmo != 0UL) {
#line 960
    ha->idc_extend_tmo = 0U;
#line 961
    goto ldv_43634;
  } else {

  }
#line 963
  current_tmo = (unsigned long )(ha->idc_extend_tmo * 250U);
#line 964
  ha->idc_extend_tmo = 0U;
#line 965
  goto ldv_43635;
  ldv_43634: ;
#line 967
  if (rem_tmo == 0UL) {
#line 968
    ql_dbg(8388608U, vha, 28706, "DCBX completion not received.\n");
#line 970
    ret = qla81xx_reset_loopback_mode(vha, new_config, 0, 0);
#line 975
    if (ret != 0) {
#line 976
      (*((ha->isp_ops)->fw_dump))(vha, 0);
#line 977
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else {

    }
#line 979
    rval = -22;
  } else
#line 981
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 982
    ql_dbg(8388608U, vha, 28867, "Bad status in IDC Completion AEN\n");
#line 984
    rval = -22;
#line 985
    ha->flags.idc_compl_status = 0U;
  } else {
#line 987
    ql_dbg(8388608U, vha, 28707, "DCBX completion received.\n");
  }
#line 991
  ha->notify_dcbx_comp = 0;
#line 992
  ha->idc_extend_tmo = 0U;
  done_set_internal: ;
#line 995
  return (rval);
}
}
#line 999 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_process_loopback(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t command_sent ;
  char *type ;
  struct msg_echo_lb elreq ;
  uint16_t response[32U] ;
  uint16_t config[4U] ;
  uint16_t new_config[4U] ;
  uint8_t *fw_sts_ptr ;
  uint8_t *req_data ;
  dma_addr_t req_data_dma ;
  uint32_t req_data_len ;
  uint8_t *rsp_data ;
  dma_addr_t rsp_data_dma ;
  uint32_t rsp_data_len ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int ret ;
  int tmp___6 ;
  size_t __len ;
  void *__ret ;

  {
#line 1001
  host = bsg_job->shost;
#line 1002
  tmp = shost_priv(host);
#line 1002
  vha = (scsi_qla_host_t *)tmp;
#line 1003
  ha = vha->hw;
#line 1011
  req_data = (uint8_t *)0U;
#line 1014
  rsp_data = (uint8_t *)0U;
#line 1018
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1019
    ql_log(1U, vha, 28697, "Host is not online.\n");
#line 1020
    return (-5);
  } else {

  }
#line 1023
  tmp___0 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1023
  elreq.req_sg_cnt = (uint16_t )tmp___0;
#line 1027
  if ((unsigned int )elreq.req_sg_cnt == 0U) {
#line 1028
    ql_log(1U, vha, 28698, "dma_map_sg returned %d for request.\n", (int )elreq.req_sg_cnt);
#line 1030
    return (-12);
  } else {

  }
#line 1033
  tmp___1 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 1033
  elreq.rsp_sg_cnt = (uint16_t )tmp___1;
#line 1037
  if ((unsigned int )elreq.rsp_sg_cnt == 0U) {
#line 1038
    ql_log(1U, vha, 28699, "dma_map_sg returned %d for reply.\n", (int )elreq.rsp_sg_cnt);
#line 1040
    rval = -12;
#line 1041
    goto done_unmap_req_sg;
  } else {

  }
#line 1044
  if ((int )elreq.req_sg_cnt != bsg_job->request_payload.sg_cnt || (int )elreq.rsp_sg_cnt != bsg_job->reply_payload.sg_cnt) {
#line 1046
    ql_log(1U, vha, 28700, "dma mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, (int )elreq.req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           (int )elreq.rsp_sg_cnt);
#line 1052
    rval = -11;
#line 1053
    goto done_unmap_sg;
  } else {

  }
#line 1055
  rsp_data_len = bsg_job->request_payload.payload_len;
#line 1055
  req_data_len = rsp_data_len;
#line 1056
  tmp___2 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )req_data_len, & req_data_dma,
                            208U, (struct dma_attrs *)0);
#line 1056
  req_data = (uint8_t *)tmp___2;
#line 1058
  if ((unsigned long )req_data == (unsigned long )((uint8_t *)0U)) {
#line 1059
    ql_log(1U, vha, 28701, "dma alloc failed for req_data.\n");
#line 1061
    rval = -12;
#line 1062
    goto done_unmap_sg;
  } else {

  }
#line 1065
  tmp___3 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )rsp_data_len, & rsp_data_dma,
                            208U, (struct dma_attrs *)0);
#line 1065
  rsp_data = (uint8_t *)tmp___3;
#line 1067
  if ((unsigned long )rsp_data == (unsigned long )((uint8_t *)0U)) {
#line 1068
    ql_log(1U, vha, 28676, "dma alloc failed for rsp_data.\n");
#line 1070
    rval = -12;
#line 1071
    goto done_free_dma_req;
  } else {

  }
#line 1075
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)req_data, (size_t )req_data_len);
#line 1078
  elreq.send_dma = req_data_dma;
#line 1079
  elreq.rcv_dma = rsp_data_dma;
#line 1080
  elreq.transfer_size = req_data_len;
#line 1082
  elreq.options = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1083
  elreq.iteration_count = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[2];
#line 1086
  tmp___6 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1086
  if ((tmp___6 == 5 && ((unsigned int )ha->current_topology == 8U || (((((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) && *((uint32_t *)req_data) == 16U) && req_data_len == 252U))) && (unsigned int )elreq.options == 242U) {
#line 1092
    type = (char *)"FC_BSG_HST_VENDOR_ECHO_DIAG";
#line 1093
    ql_dbg(8388608U, vha, 28702, "BSG request type: %s.\n", type);
#line 1095
    command_sent = 1U;
#line 1096
    rval = qla2x00_echo_test(vha, & elreq, (uint16_t *)(& response));
  } else
#line 1098
  if (((ha->device_type & 8192U) != 0U || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U) {
#line 1099
    memset((void *)(& config), 0, 8UL);
#line 1100
    memset((void *)(& new_config), 0, 8UL);
#line 1102
    tmp___4 = qla81xx_get_port_config(vha, (uint16_t *)(& config));
#line 1102
    if (tmp___4 != 0) {
#line 1103
      ql_log(1U, vha, 28703, "Get port config failed.\n");
#line 1105
      rval = -1;
#line 1106
      goto done_free_dma_rsp;
    } else {

    }
#line 1109
    if (((int )config[0] & 14) != 0) {
#line 1110
      ql_dbg(8388608U, vha, 28868, "Loopback operation already in progress.\n");
#line 1113
      rval = -11;
#line 1114
      goto done_free_dma_rsp;
    } else {

    }
#line 1117
    ql_dbg(8388608U, vha, 28864, "elreq.options=%04x\n", (int )elreq.options);
#line 1120
    if ((unsigned int )elreq.options == 242U) {
#line 1121
      if ((ha->device_type & 65536U) != 0U || (ha->device_type & 262144U) != 0U) {
#line 1122
        rval = qla81xx_set_loopback_mode(vha, (uint16_t *)(& config), (uint16_t *)(& new_config),
                                         (int )elreq.options);
      } else {
#line 1125
        rval = qla81xx_reset_loopback_mode(vha, (uint16_t *)(& config), 1, 0);
      }
    } else {
#line 1128
      rval = qla81xx_set_loopback_mode(vha, (uint16_t *)(& config), (uint16_t *)(& new_config),
                                       (int )elreq.options);
    }
#line 1131
    if (rval != 0) {
#line 1132
      rval = -1;
#line 1133
      goto done_free_dma_rsp;
    } else {

    }
#line 1136
    type = (char *)"FC_BSG_HST_VENDOR_LOOPBACK";
#line 1137
    ql_dbg(8388608U, vha, 28712, "BSG request type: %s.\n", type);
#line 1140
    command_sent = 0U;
#line 1141
    rval = qla2x00_loopback_test(vha, & elreq, (uint16_t *)(& response));
#line 1143
    if ((unsigned int )response[0] == 16389U && (unsigned int )response[1] == 23U) {
#line 1145
      ql_log(1U, vha, 28713, "MBX command error, Aborting ISP.\n");
#line 1147
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1148
      qla2xxx_wake_dpc(vha);
#line 1149
      qla2x00_wait_for_chip_reset(vha);
#line 1151
      if ((ha->device_type & 8192U) != 0U) {
#line 1152
        tmp___5 = qla81xx_restart_mpi_firmware(vha);
#line 1152
        if (tmp___5 != 0) {
#line 1154
          ql_log(1U, vha, 28714, "MPI reset failed.\n");
        } else {

        }
      } else {

      }
#line 1159
      rval = -5;
#line 1160
      goto done_free_dma_rsp;
    } else {

    }
#line 1163
    if ((unsigned int )new_config[0] != 0U) {
#line 1169
      ret = qla81xx_reset_loopback_mode(vha, (uint16_t *)(& new_config), 0, 1);
#line 1171
      if (ret != 0) {
#line 1177
        (*((ha->isp_ops)->fw_dump))(vha, 0);
#line 1178
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {

      }
    } else {

    }
  } else {
#line 1185
    type = (char *)"FC_BSG_HST_VENDOR_LOOPBACK";
#line 1186
    ql_dbg(8388608U, vha, 28715, "BSG request type: %s.\n", type);
#line 1188
    command_sent = 0U;
#line 1189
    rval = qla2x00_loopback_test(vha, & elreq, (uint16_t *)(& response));
  }
#line 1193
  if (rval != 0) {
#line 1194
    ql_log(1U, vha, 28716, "Vendor request %s failed.\n", type);
#line 1197
    rval = 0;
#line 1198
    (bsg_job->reply)->result = 458752U;
#line 1199
    (bsg_job->reply)->reply_payload_rcv_len = 0U;
  } else {
#line 1201
    ql_dbg(8388608U, vha, 28717, "Vendor request %s completed.\n", type);
#line 1203
    (bsg_job->reply)->result = 0U;
#line 1204
    sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                        (void *)rsp_data, (size_t )rsp_data_len);
  }
#line 1209
  bsg_job->reply_len = 81U;
#line 1211
  fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 1213
  __len = 64UL;
#line 1213
  if (__len > 63UL) {
#line 1213
    __ret = __memcpy((void *)fw_sts_ptr, (void const   *)(& response), __len);
  } else {
#line 1213
    __ret = __builtin_memcpy((void *)fw_sts_ptr, (void const   *)(& response), __len);
  }
#line 1214
  fw_sts_ptr = fw_sts_ptr + 64UL;
#line 1215
  *fw_sts_ptr = command_sent;
  done_free_dma_rsp: 
#line 1218
  dma_free_attrs(& (ha->pdev)->dev, (size_t )rsp_data_len, (void *)rsp_data, rsp_data_dma,
                 (struct dma_attrs *)0);
  done_free_dma_req: 
#line 1221
  dma_free_attrs(& (ha->pdev)->dev, (size_t )req_data_len, (void *)req_data, req_data_dma,
                 (struct dma_attrs *)0);
  done_unmap_sg: 
#line 1224
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done_unmap_req_sg: 
#line 1228
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 1231
  if (rval == 0) {
#line 1232
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 1233
  return (rval);
}
}
#line 1237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla84xx_reset(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint32_t flag ;

  {
#line 1239
  host = bsg_job->shost;
#line 1240
  tmp = shost_priv(host);
#line 1240
  vha = (scsi_qla_host_t *)tmp;
#line 1241
  ha = vha->hw;
#line 1242
  rval = 0;
#line 1245
  if ((ha->device_type & 4096U) == 0U) {
#line 1246
    ql_dbg(8388608U, vha, 28719, "Not 84xx, exiting.\n");
#line 1247
    return (-22);
  } else {

  }
#line 1250
  flag = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1252
  rval = qla84xx_reset_chip(vha, flag == 4U);
#line 1254
  if (rval != 0) {
#line 1255
    ql_log(1U, vha, 28720, "Vendor request 84xx reset failed.\n");
#line 1257
    rval = 458752;
  } else {
#line 1260
    ql_dbg(8388608U, vha, 28721, "Vendor request 84xx reset completed.\n");
#line 1262
    (bsg_job->reply)->result = 0U;
#line 1263
    (*(bsg_job->job_done))(bsg_job);
  }
#line 1266
  return (rval);
}
}
#line 1270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla84xx_updatefw(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct verify_chip_entry_84xx *mn ;
  dma_addr_t mn_dma ;
  dma_addr_t fw_dma ;
  void *fw_buf ;
  int rval ;
  uint32_t sg_cnt ;
  uint32_t data_len ;
  uint16_t options ;
  uint32_t flag ;
  uint32_t fw_ver ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1272
  host = bsg_job->shost;
#line 1273
  tmp = shost_priv(host);
#line 1273
  vha = (scsi_qla_host_t *)tmp;
#line 1274
  ha = vha->hw;
#line 1275
  mn = (struct verify_chip_entry_84xx *)0;
#line 1277
  fw_buf = (void *)0;
#line 1278
  rval = 0;
#line 1285
  if ((ha->device_type & 4096U) == 0U) {
#line 1286
    ql_dbg(8388608U, vha, 28722, "Not 84xx, exiting.\n");
#line 1288
    return (-22);
  } else {

  }
#line 1291
  tmp___0 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1291
  sg_cnt = (uint32_t )tmp___0;
#line 1293
  if (sg_cnt == 0U) {
#line 1294
    ql_log(1U, vha, 28723, "dma_map_sg returned %d for request.\n", sg_cnt);
#line 1296
    return (-12);
  } else {

  }
#line 1299
  if ((uint32_t )bsg_job->request_payload.sg_cnt != sg_cnt) {
#line 1300
    ql_log(1U, vha, 28724, "DMA mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, sg_cnt);
#line 1304
    rval = -11;
#line 1305
    goto done_unmap_sg;
  } else {

  }
#line 1308
  data_len = bsg_job->request_payload.payload_len;
#line 1309
  fw_buf = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & fw_dma, 208U, (struct dma_attrs *)0);
#line 1311
  if ((unsigned long )fw_buf == (unsigned long )((void *)0)) {
#line 1312
    ql_log(1U, vha, 28725, "DMA alloc failed for fw_buf.\n");
#line 1314
    rval = -12;
#line 1315
    goto done_unmap_sg;
  } else {

  }
#line 1318
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    fw_buf, (size_t )data_len);
#line 1321
  tmp___1 = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 1321
  mn = (struct verify_chip_entry_84xx *)tmp___1;
#line 1322
  if ((unsigned long )mn == (unsigned long )((struct verify_chip_entry_84xx *)0)) {
#line 1323
    ql_log(1U, vha, 28726, "DMA alloc failed for fw buffer.\n");
#line 1325
    rval = -12;
#line 1326
    goto done_free_fw_buf;
  } else {

  }
#line 1329
  flag = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1330
  fw_ver = *((uint32_t *)fw_buf + 2UL);
#line 1332
  memset((void *)mn, 0, 64UL);
#line 1333
  mn->entry_type = 27U;
#line 1334
  mn->entry_count = 1U;
#line 1336
  options = 16386U;
#line 1337
  if (flag == 6U) {
#line 1338
    options = (uint16_t )((unsigned int )options | 8U);
  } else {

  }
#line 1340
  mn->options = options;
#line 1341
  mn->fw_ver = fw_ver;
#line 1342
  mn->fw_size = data_len;
#line 1343
  mn->fw_seq_size = data_len;
#line 1344
  mn->dseg_address[0] = (unsigned int )fw_dma;
#line 1345
  mn->dseg_address[1] = (unsigned int )(fw_dma >> 32ULL);
#line 1346
  mn->dseg_length = data_len;
#line 1347
  mn->data_seg_cnt = 1U;
#line 1349
  rval = qla2x00_issue_iocb_timeout(vha, (void *)mn, mn_dma, 0UL, 120U);
#line 1351
  if (rval != 0) {
#line 1352
    ql_log(1U, vha, 28727, "Vendor request 84xx updatefw failed.\n");
#line 1355
    rval = 458752;
  } else {
#line 1357
    ql_dbg(8388608U, vha, 28728, "Vendor request 84xx updatefw completed.\n");
#line 1360
    bsg_job->reply_len = 16U;
#line 1361
    (bsg_job->reply)->result = 0U;
  }
#line 1364
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
  done_free_fw_buf: 
#line 1367
  dma_free_attrs(& (ha->pdev)->dev, (size_t )data_len, fw_buf, fw_dma, (struct dma_attrs *)0);
  done_unmap_sg: 
#line 1370
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
#line 1373
  if (rval == 0) {
#line 1374
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 1375
  return (rval);
}
}
#line 1379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla84xx_mgmt_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  struct access_chip_84xx *mn ;
  dma_addr_t mn_dma ;
  dma_addr_t mgmt_dma ;
  void *mgmt_b ;
  int rval ;
  struct qla_bsg_a84_mgmt *ql84_mgmt ;
  uint32_t sg_cnt ;
  uint32_t data_len ;
  uint32_t dma_direction ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1381
  host = bsg_job->shost;
#line 1382
  tmp = shost_priv(host);
#line 1382
  vha = (scsi_qla_host_t *)tmp;
#line 1383
  ha = vha->hw;
#line 1384
  mn = (struct access_chip_84xx *)0;
#line 1386
  mgmt_b = (void *)0;
#line 1387
  rval = 0;
#line 1390
  data_len = 0U;
#line 1391
  dma_direction = 3U;
#line 1393
  if ((ha->device_type & 4096U) == 0U) {
#line 1394
    ql_log(1U, vha, 28730, "Not 84xx, exiting.\n");
#line 1396
    return (-22);
  } else {

  }
#line 1399
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & mn_dma);
#line 1399
  mn = (struct access_chip_84xx *)tmp___0;
#line 1400
  if ((unsigned long )mn == (unsigned long )((struct access_chip_84xx *)0)) {
#line 1401
    ql_log(1U, vha, 28732, "DMA alloc failed for fw buffer.\n");
#line 1403
    return (-12);
  } else {

  }
#line 1406
  memset((void *)mn, 0, 64UL);
#line 1407
  mn->entry_type = 43U;
#line 1408
  mn->entry_count = 1U;
#line 1409
  ql84_mgmt = (struct qla_bsg_a84_mgmt *)bsg_job->request + 20U;
#line 1410
  switch ((int )ql84_mgmt->mgmt.cmd) {
  case 0: ;
  case 3: 
#line 1413
  tmp___1 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 1413
  sg_cnt = (uint32_t )tmp___1;
#line 1416
  if (sg_cnt == 0U) {
#line 1417
    ql_log(1U, vha, 28733, "dma_map_sg returned %d for reply.\n", sg_cnt);
#line 1419
    rval = -12;
#line 1420
    goto exit_mgmt;
  } else {

  }
#line 1423
  dma_direction = 2U;
#line 1425
  if ((uint32_t )bsg_job->reply_payload.sg_cnt != sg_cnt) {
#line 1426
    ql_log(1U, vha, 28734, "DMA mapping resulted in different sg counts, reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",
           bsg_job->reply_payload.sg_cnt, sg_cnt);
#line 1430
    rval = -11;
#line 1431
    goto done_unmap_sg;
  } else {

  }
#line 1434
  data_len = bsg_job->reply_payload.payload_len;
#line 1436
  mgmt_b = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & mgmt_dma, 208U,
                           (struct dma_attrs *)0);
#line 1438
  if ((unsigned long )mgmt_b == (unsigned long )((void *)0)) {
#line 1439
    ql_log(1U, vha, 28735, "DMA alloc failed for mgmt_b.\n");
#line 1441
    rval = -12;
#line 1442
    goto done_unmap_sg;
  } else {

  }
#line 1445
  if ((unsigned int )ql84_mgmt->mgmt.cmd == 0U) {
#line 1446
    mn->options = 0U;
#line 1447
    mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.mem.start_addr;
  } else
#line 1451
  if ((unsigned int )ql84_mgmt->mgmt.cmd == 3U) {
#line 1452
    mn->options = 3U;
#line 1453
    mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.info.type;
#line 1456
    mn->parameter2 = ql84_mgmt->mgmt.mgmtp.u.info.context;
  } else {

  }
#line 1460
  goto ldv_43709;
  case 1: 
#line 1463
  tmp___2 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 1463
  sg_cnt = (uint32_t )tmp___2;
#line 1467
  if (sg_cnt == 0U) {
#line 1468
    ql_log(1U, vha, 28736, "dma_map_sg returned %d.\n", sg_cnt);
#line 1470
    rval = -12;
#line 1471
    goto exit_mgmt;
  } else {

  }
#line 1474
  dma_direction = 1U;
#line 1476
  if ((uint32_t )bsg_job->request_payload.sg_cnt != sg_cnt) {
#line 1477
    ql_log(1U, vha, 28737, "DMA mapping resulted in different sg counts, request_sg_cnt: %x dma_request_sg_cnt: %x.\n",
           bsg_job->request_payload.sg_cnt, sg_cnt);
#line 1481
    rval = -11;
#line 1482
    goto done_unmap_sg;
  } else {

  }
#line 1485
  data_len = bsg_job->request_payload.payload_len;
#line 1486
  mgmt_b = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )data_len, & mgmt_dma, 208U,
                           (struct dma_attrs *)0);
#line 1488
  if ((unsigned long )mgmt_b == (unsigned long )((void *)0)) {
#line 1489
    ql_log(1U, vha, 28738, "DMA alloc failed for mgmt_b.\n");
#line 1491
    rval = -12;
#line 1492
    goto done_unmap_sg;
  } else {

  }
#line 1495
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    mgmt_b, (size_t )data_len);
#line 1498
  mn->options = 1U;
#line 1499
  mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.mem.start_addr;
#line 1501
  goto ldv_43709;
  case 2: 
#line 1504
  mn->options = 2U;
#line 1505
  mn->parameter1 = ql84_mgmt->mgmt.mgmtp.u.config.id;
#line 1508
  mn->parameter2 = ql84_mgmt->mgmt.mgmtp.u.config.param0;
#line 1511
  mn->parameter3 = ql84_mgmt->mgmt.mgmtp.u.config.param1;
#line 1513
  goto ldv_43709;
  default: 
#line 1516
  rval = -5;
#line 1517
  goto exit_mgmt;
  }
  ldv_43709: ;
#line 1520
  if ((unsigned int )ql84_mgmt->mgmt.cmd != 2U) {
#line 1521
    mn->total_byte_cnt = ql84_mgmt->mgmt.len;
#line 1522
    mn->dseg_count = 1U;
#line 1523
    mn->dseg_address[0] = (unsigned int )mgmt_dma;
#line 1524
    mn->dseg_address[1] = (unsigned int )(mgmt_dma >> 32ULL);
#line 1525
    mn->dseg_length = ql84_mgmt->mgmt.len;
  } else {

  }
#line 1528
  rval = qla2x00_issue_iocb(vha, (void *)mn, mn_dma, 0UL);
#line 1530
  if (rval != 0) {
#line 1531
    ql_log(1U, vha, 28739, "Vendor request 84xx mgmt failed.\n");
#line 1534
    rval = 458752;
  } else {
#line 1537
    ql_dbg(8388608U, vha, 28740, "Vendor request 84xx mgmt completed.\n");
#line 1540
    bsg_job->reply_len = 16U;
#line 1541
    (bsg_job->reply)->result = 0U;
#line 1543
    if ((unsigned int )ql84_mgmt->mgmt.cmd == 0U || (unsigned int )ql84_mgmt->mgmt.cmd == 3U) {
#line 1545
      (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
#line 1548
      sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                          mgmt_b, (size_t )data_len);
    } else {

    }
  }
  done_unmap_sg: ;
#line 1555
  if ((unsigned long )mgmt_b != (unsigned long )((void *)0)) {
#line 1556
    dma_free_attrs(& (ha->pdev)->dev, (size_t )data_len, mgmt_b, mgmt_dma, (struct dma_attrs *)0);
  } else {

  }
#line 1558
  if (dma_direction == 1U) {
#line 1559
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
  } else
#line 1561
  if (dma_direction == 2U) {
#line 1562
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  } else {

  }
  exit_mgmt: 
#line 1566
  dma_pool_free(ha->s_dma_pool, (void *)mn, mn_dma);
#line 1568
  if (rval == 0) {
#line 1569
    (*(bsg_job->job_done))(bsg_job);
  } else {

  }
#line 1570
  return (rval);
}
}
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla24xx_iidma(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int rval ;
  struct qla_port_param *port_param ;
  fc_port_t *fcport ;
  int found ;
  uint16_t mb[32U] ;
  uint8_t *rsp_ptr ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 1576
  host = bsg_job->shost;
#line 1577
  tmp = shost_priv(host);
#line 1577
  vha = (scsi_qla_host_t *)tmp;
#line 1578
  rval = 0;
#line 1579
  port_param = (struct qla_port_param *)0;
#line 1580
  fcport = (fc_port_t *)0;
#line 1581
  found = 0;
#line 1583
  rsp_ptr = (uint8_t *)0U;
#line 1585
  if (((vha->hw)->device_type & 67108864U) == 0U) {
#line 1586
    ql_log(2U, vha, 28742, "iiDMA not supported.\n");
#line 1587
    return (-22);
  } else {

  }
#line 1590
  port_param = (struct qla_port_param *)bsg_job->request + 20U;
#line 1591
  if ((unsigned int )port_param->fc_scsi_addr.dest_type != 2U) {
#line 1592
    ql_log(1U, vha, 28744, "Invalid destination type.\n");
#line 1594
    return (-22);
  } else {

  }
#line 1597
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1597
  fcport = (fc_port_t *)__mptr;
#line 1597
  goto ldv_43731;
  ldv_43730: ;
#line 1598
  if ((unsigned int )fcport->port_type != 5U) {
#line 1599
    goto ldv_43728;
  } else {

  }
#line 1601
  tmp___0 = memcmp((void const   *)(& port_param->fc_scsi_addr.dest_addr.wwpn), (void const   *)(& fcport->port_name),
                   8UL);
#line 1601
  if (tmp___0 != 0) {
#line 1603
    goto ldv_43728;
  } else {

  }
#line 1605
  found = 1;
#line 1606
  goto ldv_43729;
  ldv_43728: 
#line 1597
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1597
  fcport = (fc_port_t *)__mptr___0;
  ldv_43731: ;
#line 1597
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1599
    goto ldv_43730;
  } else {

  }
  ldv_43729: ;
#line 1609
  if (found == 0) {
#line 1610
    ql_log(1U, vha, 28745, "Failed to find port.\n");
#line 1612
    return (-22);
  } else {

  }
#line 1615
  tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1615
  if (tmp___1 != 4) {
#line 1616
    ql_log(1U, vha, 28746, "Port is not online.\n");
#line 1618
    return (-22);
  } else {

  }
#line 1621
  if ((fcport->flags & 2U) != 0U) {
#line 1622
    ql_log(1U, vha, 28747, "Remote port not logged in flags = 0x%x.\n", fcport->flags);
#line 1624
    return (-22);
  } else {

  }
#line 1627
  if ((unsigned int )port_param->mode != 0U) {
#line 1628
    rval = qla2x00_set_idma_speed(vha, (int )fcport->loop_id, (int )port_param->speed,
                                  (uint16_t *)(& mb));
  } else {
#line 1631
    rval = qla2x00_get_idma_speed(vha, (int )fcport->loop_id, & port_param->speed,
                                  (uint16_t *)(& mb));
  }
#line 1634
  if (rval != 0) {
#line 1635
    ql_log(1U, vha, 28748, "iIDMA cmd failed for %8phN -- %04x %x %04x %04x.\n", (uint8_t *)(& fcport->port_name),
           rval, (int )fcport->fp_speed, (int )mb[0], (int )mb[1]);
#line 1639
    rval = 458752;
  } else {
#line 1641
    if ((unsigned int )port_param->mode == 0U) {
#line 1642
      bsg_job->reply_len = 36U;
#line 1645
      rsp_ptr = (uint8_t *)bsg_job->reply + 16UL;
#line 1648
      __len = 20UL;
#line 1648
      if (__len > 63UL) {
#line 1648
        __ret = __memcpy((void *)rsp_ptr, (void const   *)port_param, __len);
      } else {
#line 1648
        __ret = __builtin_memcpy((void *)rsp_ptr, (void const   *)port_param, __len);
      }
    } else {

    }
#line 1652
    (bsg_job->reply)->result = 0U;
#line 1653
    (*(bsg_job->job_done))(bsg_job);
  }
#line 1656
  return (rval);
}
}
#line 1660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_optrom_setup(struct fc_bsg_job *bsg_job , scsi_qla_host_t *vha ,
                                uint8_t is_update ) 
{ 
  uint32_t start ;
  int valid ;
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
#line 1663
  start = 0U;
#line 1664
  valid = 0;
#line 1665
  ha = vha->hw;
#line 1667
  tmp = pci_channel_offline(ha->pdev);
#line 1667
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 1667
  if (tmp___0 != 0L) {
#line 1668
    return (-22);
  } else {

  }
#line 1670
  start = (bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 1671
  if (ha->optrom_size < start) {
#line 1672
    ql_log(1U, vha, 28757, "start %d > optrom_size %d.\n", start, ha->optrom_size);
#line 1674
    return (-22);
  } else {

  }
#line 1677
  if (ha->optrom_state != 0) {
#line 1678
    ql_log(2U, vha, 28758, "optrom_state %d.\n", ha->optrom_state);
#line 1680
    return (-16);
  } else {

  }
#line 1683
  ha->optrom_region_start = start;
#line 1684
  ql_dbg(8388608U, vha, 28759, "is_update=%d.\n", (int )is_update);
#line 1685
  if ((unsigned int )is_update != 0U) {
#line 1686
    if (ha->optrom_size == 131072U && start == 0U) {
#line 1687
      valid = 1;
    } else
#line 1688
    if (ha->flt_region_boot * 4U == start || ha->flt_region_fw * 4U == start) {
#line 1690
      valid = 1;
    } else
#line 1691
    if (((((((ha->device_type & 128U) != 0U || (ha->device_type & 256U) != 0U) || ((ha->device_type & 512U) != 0U || (ha->device_type & 1024U) != 0U)) || (ha->device_type & 4096U) != 0U) || (ha->device_type & 2048U) != 0U) || ((((ha->device_type & 8192U) != 0U || (ha->device_type & 16384U) != 0U) || (ha->device_type & 65536U) != 0U) || (ha->device_type & 262144U) != 0U)) || (ha->device_type & 32768U) != 0U) {
#line 1693
      valid = 1;
    } else {

    }
#line 1694
    if (valid == 0) {
#line 1695
      ql_log(1U, vha, 28760, "Invalid start region 0x%x/0x%x.\n", start, bsg_job->request_payload.payload_len);
#line 1698
      return (-22);
    } else {

    }
#line 1701
    ha->optrom_region_size = bsg_job->request_payload.payload_len + start > ha->optrom_size ? ha->optrom_size - start : bsg_job->request_payload.payload_len;
#line 1705
    ha->optrom_state = 2;
  } else {
#line 1707
    ha->optrom_region_size = bsg_job->reply_payload.payload_len + start > ha->optrom_size ? ha->optrom_size - start : bsg_job->reply_payload.payload_len;
#line 1711
    ha->optrom_state = 1;
  }
#line 1714
  tmp___1 = vmalloc((unsigned long )ha->optrom_region_size);
#line 1714
  ha->optrom_buffer = (char *)tmp___1;
#line 1715
  if ((unsigned long )ha->optrom_buffer == (unsigned long )((char *)0)) {
#line 1716
    ql_log(1U, vha, 28761, "Read: Unable to allocate memory for optrom retrieval (%x)\n",
           ha->optrom_region_size);
#line 1720
    ha->optrom_state = 0;
#line 1721
    return (-12);
  } else {

  }
#line 1724
  memset((void *)ha->optrom_buffer, 0, (size_t )ha->optrom_region_size);
#line 1725
  return (0);
}
}
#line 1729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_read_optrom(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 1731
  host = bsg_job->shost;
#line 1732
  tmp = shost_priv(host);
#line 1732
  vha = (scsi_qla_host_t *)tmp;
#line 1733
  ha = vha->hw;
#line 1734
  rval = 0;
#line 1736
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1737
    return (-16);
  } else {

  }
#line 1739
  rval = qla2x00_optrom_setup(bsg_job, vha, 0);
#line 1740
  if (rval != 0) {
#line 1741
    return (rval);
  } else {

  }
#line 1743
  (*((ha->isp_ops)->read_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                  ha->optrom_region_size);
#line 1746
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void *)ha->optrom_buffer, (size_t )ha->optrom_region_size);
#line 1750
  (bsg_job->reply)->reply_payload_rcv_len = ha->optrom_region_size;
#line 1751
  (bsg_job->reply)->result = 0U;
#line 1752
  vfree((void const   *)ha->optrom_buffer);
#line 1753
  ha->optrom_buffer = (char *)0;
#line 1754
  ha->optrom_state = 0;
#line 1755
  (*(bsg_job->job_done))(bsg_job);
#line 1756
  return (rval);
}
}
#line 1760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_update_optrom(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 1762
  host = bsg_job->shost;
#line 1763
  tmp = shost_priv(host);
#line 1763
  vha = (scsi_qla_host_t *)tmp;
#line 1764
  ha = vha->hw;
#line 1765
  rval = 0;
#line 1767
  rval = qla2x00_optrom_setup(bsg_job, vha, 1);
#line 1768
  if (rval != 0) {
#line 1769
    return (rval);
  } else {

  }
#line 1772
  ha->flags.isp82xx_no_md_cap = 1U;
#line 1774
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)ha->optrom_buffer, (size_t )ha->optrom_region_size);
#line 1778
  (*((ha->isp_ops)->write_optrom))(vha, (uint8_t *)ha->optrom_buffer, ha->optrom_region_start,
                                   ha->optrom_region_size);
#line 1781
  (bsg_job->reply)->result = 0U;
#line 1782
  vfree((void const   *)ha->optrom_buffer);
#line 1783
  ha->optrom_buffer = (char *)0;
#line 1784
  ha->optrom_state = 0;
#line 1785
  (*(bsg_job->job_done))(bsg_job);
#line 1786
  return (rval);
}
}
#line 1790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_update_fru_versions(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_image_version_list *list ;
  struct qla_image_version *image ;
  uint32_t count ;
  dma_addr_t sfp_dma ;
  void *sfp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  uint32_t tmp___1 ;

  {
#line 1792
  host = bsg_job->shost;
#line 1793
  tmp = shost_priv(host);
#line 1793
  vha = (scsi_qla_host_t *)tmp;
#line 1794
  ha = vha->hw;
#line 1795
  rval = 0;
#line 1797
  list = (struct qla_image_version_list *)(& bsg);
#line 1801
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1801
  sfp = tmp___0;
#line 1802
  if ((unsigned long )sfp == (unsigned long )((void *)0)) {
#line 1803
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1805
    goto done;
  } else {

  }
#line 1808
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)list, 256UL);
#line 1811
  image = (struct qla_image_version *)(& list->version);
#line 1812
  count = list->count;
#line 1813
  goto ldv_43776;
  ldv_43775: 
#line 1814
  __len = 36UL;
#line 1814
  if (__len > 63UL) {
#line 1814
    __ret = __memcpy(sfp, (void const   *)(& image->field_info), __len);
  } else {
#line 1814
    __ret = __builtin_memcpy(sfp, (void const   *)(& image->field_info), __len);
  }
#line 1815
  rval = qla2x00_write_sfp(vha, sfp_dma, (uint8_t *)sfp, (int )image->field_address.device,
                           (int )image->field_address.offset, 36, (int )image->field_address.option);
#line 1818
  if (rval != 0) {
#line 1819
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1821
    goto dealloc;
  } else {

  }
#line 1823
  image = image + 1;
  ldv_43776: 
#line 1813
  tmp___1 = count;
#line 1813
  count = count - 1U;
#line 1813
  if (tmp___1 != 0U) {
#line 1815
    goto ldv_43775;
  } else {

  }
#line 1826
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1829
  dma_pool_free(ha->s_dma_pool, sfp, sfp_dma);
  done: 
#line 1832
  bsg_job->reply_len = 16U;
#line 1833
  (bsg_job->reply)->result = 0U;
#line 1834
  (*(bsg_job->job_done))(bsg_job);
#line 1836
  return (0);
}
}
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_read_fru_status(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_status_reg *sr ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1842
  host = bsg_job->shost;
#line 1843
  tmp = shost_priv(host);
#line 1843
  vha = (scsi_qla_host_t *)tmp;
#line 1844
  ha = vha->hw;
#line 1845
  rval = 0;
#line 1847
  sr = (struct qla_status_reg *)(& bsg);
#line 1849
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1849
  sfp = (uint8_t *)tmp___0;
#line 1850
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1851
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1853
    goto done;
  } else {

  }
#line 1856
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)sr, 14UL);
#line 1859
  rval = qla2x00_read_sfp(vha, sfp_dma, sfp, (int )sr->field_address.device, (int )sr->field_address.offset,
                          1, (int )sr->field_address.option);
#line 1862
  sr->status_reg = *sfp;
#line 1864
  if (rval != 0) {
#line 1865
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1867
    goto dealloc;
  } else {

  }
#line 1870
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void *)sr, 14UL);
#line 1873
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1876
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1879
  bsg_job->reply_len = 16U;
#line 1880
  (bsg_job->reply)->reply_payload_rcv_len = 14U;
#line 1881
  (bsg_job->reply)->result = 0U;
#line 1882
  (*(bsg_job->job_done))(bsg_job);
#line 1884
  return (0);
}
}
#line 1888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_write_fru_status(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_status_reg *sr ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;

  {
#line 1890
  host = bsg_job->shost;
#line 1891
  tmp = shost_priv(host);
#line 1891
  vha = (scsi_qla_host_t *)tmp;
#line 1892
  ha = vha->hw;
#line 1893
  rval = 0;
#line 1895
  sr = (struct qla_status_reg *)(& bsg);
#line 1897
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1897
  sfp = (uint8_t *)tmp___0;
#line 1898
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1899
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1901
    goto done;
  } else {

  }
#line 1904
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)sr, 14UL);
#line 1907
  *sfp = sr->status_reg;
#line 1908
  rval = qla2x00_write_sfp(vha, sfp_dma, sfp, (int )sr->field_address.device, (int )sr->field_address.offset,
                           1, (int )sr->field_address.option);
#line 1912
  if (rval != 0) {
#line 1913
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1915
    goto dealloc;
  } else {

  }
#line 1918
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1921
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1924
  bsg_job->reply_len = 16U;
#line 1925
  (bsg_job->reply)->result = 0U;
#line 1926
  (*(bsg_job->job_done))(bsg_job);
#line 1928
  return (0);
}
}
#line 1932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_write_i2c(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_i2c_access *i2c ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 1934
  host = bsg_job->shost;
#line 1935
  tmp = shost_priv(host);
#line 1935
  vha = (scsi_qla_host_t *)tmp;
#line 1936
  ha = vha->hw;
#line 1937
  rval = 0;
#line 1939
  i2c = (struct qla_i2c_access *)(& bsg);
#line 1941
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1941
  sfp = (uint8_t *)tmp___0;
#line 1942
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1943
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1945
    goto done;
  } else {

  }
#line 1948
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)i2c, 72UL);
#line 1951
  __len = (size_t )i2c->length;
#line 1951
  __ret = __builtin_memcpy((void *)sfp, (void const   *)(& i2c->buffer), __len);
#line 1952
  rval = qla2x00_write_sfp(vha, sfp_dma, sfp, (int )i2c->device, (int )i2c->offset,
                           (int )i2c->length, (int )i2c->option);
#line 1955
  if (rval != 0) {
#line 1956
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 1958
    goto dealloc;
  } else {

  }
#line 1961
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 1964
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 1967
  bsg_job->reply_len = 16U;
#line 1968
  (bsg_job->reply)->result = 0U;
#line 1969
  (*(bsg_job->job_done))(bsg_job);
#line 1971
  return (0);
}
}
#line 1975 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_read_i2c(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  uint8_t bsg[256U] ;
  struct qla_i2c_access *i2c ;
  dma_addr_t sfp_dma ;
  uint8_t *sfp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 1977
  host = bsg_job->shost;
#line 1978
  tmp = shost_priv(host);
#line 1978
  vha = (scsi_qla_host_t *)tmp;
#line 1979
  ha = vha->hw;
#line 1980
  rval = 0;
#line 1982
  i2c = (struct qla_i2c_access *)(& bsg);
#line 1984
  tmp___0 = dma_pool_alloc(ha->s_dma_pool, 208U, & sfp_dma);
#line 1984
  sfp = (uint8_t *)tmp___0;
#line 1985
  if ((unsigned long )sfp == (unsigned long )((uint8_t *)0U)) {
#line 1986
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 17U;
#line 1988
    goto done;
  } else {

  }
#line 1991
  sg_copy_to_buffer(bsg_job->request_payload.sg_list, (unsigned int )bsg_job->request_payload.sg_cnt,
                    (void *)i2c, 72UL);
#line 1994
  rval = qla2x00_read_sfp(vha, sfp_dma, sfp, (int )i2c->device, (int )i2c->offset,
                          (int )i2c->length, (int )i2c->option);
#line 1997
  if (rval != 0) {
#line 1998
    (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 11U;
#line 2000
    goto dealloc;
  } else {

  }
#line 2003
  __len = (size_t )i2c->length;
#line 2003
  __ret = __builtin_memcpy((void *)(& i2c->buffer), (void const   *)sfp, __len);
#line 2004
  sg_copy_from_buffer(bsg_job->reply_payload.sg_list, (unsigned int )bsg_job->reply_payload.sg_cnt,
                      (void *)i2c, 72UL);
#line 2007
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = 0U;
  dealloc: 
#line 2010
  dma_pool_free(ha->s_dma_pool, (void *)sfp, sfp_dma);
  done: 
#line 2013
  bsg_job->reply_len = 16U;
#line 2014
  (bsg_job->reply)->reply_payload_rcv_len = 72U;
#line 2015
  (bsg_job->reply)->result = 0U;
#line 2016
  (*(bsg_job->job_done))(bsg_job);
#line 2018
  return (0);
}
}
#line 2022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla24xx_process_bidir_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  uint16_t thread_id ;
  uint32_t rval ;
  uint16_t req_sg_cnt ;
  uint16_t rsp_sg_cnt ;
  uint16_t nextlid ;
  uint32_t tot_dsds ;
  srb_t *sp ;
  uint32_t req_data_len ;
  uint32_t rsp_data_len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2024
  host = bsg_job->shost;
#line 2025
  tmp = shost_priv(host);
#line 2025
  vha = (scsi_qla_host_t *)tmp;
#line 2026
  ha = vha->hw;
#line 2028
  rval = 0U;
#line 2029
  req_sg_cnt = 0U;
#line 2030
  rsp_sg_cnt = 0U;
#line 2031
  nextlid = 0U;
#line 2033
  sp = (srb_t *)0;
#line 2034
  req_data_len = 0U;
#line 2035
  rsp_data_len = 0U;
#line 2038
  if ((ha->device_type & 2048U) == 0U && (ha->device_type & 32768U) == 0U) {
#line 2039
    ql_log(1U, vha, 28832, "This adapter is not supported\n");
#line 2041
    rval = 27U;
#line 2042
    goto done;
  } else {

  }
#line 2045
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2045
  if (tmp___0 != 0) {
#line 2048
    rval = 2U;
#line 2049
    goto done;
  } else {
#line 2045
    tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2045
    if (tmp___1 != 0) {
#line 2048
      rval = 2U;
#line 2049
      goto done;
    } else {
#line 2045
      tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2045
      if (tmp___2 != 0) {
#line 2048
        rval = 2U;
#line 2049
        goto done;
      } else {

      }
    }
  }
#line 2053
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2054
    ql_log(1U, vha, 28833, "Host is not online\n");
#line 2056
    rval = 22U;
#line 2057
    goto done;
  } else {

  }
#line 2061
  if ((vha->device_flags & 2U) != 0U) {
#line 2062
    ql_log(1U, vha, 28834, "Cable is unplugged...\n");
#line 2064
    rval = 28U;
#line 2065
    goto done;
  } else {

  }
#line 2069
  if ((unsigned int )ha->current_topology != 8U) {
#line 2070
    ql_log(1U, vha, 28835, "Host is not connected to the switch\n");
#line 2072
    rval = 28U;
#line 2073
    goto done;
  } else {

  }
#line 2077
  if ((unsigned int )ha->operating_mode != 1U) {
#line 2078
    ql_log(1U, vha, 28836, "Host is operating mode is not P2p\n");
#line 2080
    rval = 28U;
#line 2081
    goto done;
  } else {

  }
#line 2084
  thread_id = (uint16_t )(bsg_job->request)->rqst_data.h_vendor.vendor_cmd[1];
#line 2086
  mutex_lock_nested(& ha->selflogin_lock, 0U);
#line 2087
  if ((unsigned int )vha->self_login_loop_id == 0U) {
#line 2089
    vha->bidir_fcport.vha = vha;
#line 2090
    vha->bidir_fcport.d_id.b.al_pa = vha->d_id.b.al_pa;
#line 2091
    vha->bidir_fcport.d_id.b.area = vha->d_id.b.area;
#line 2092
    vha->bidir_fcport.d_id.b.domain = vha->d_id.b.domain;
#line 2093
    vha->bidir_fcport.loop_id = vha->loop_id;
#line 2095
    tmp___3 = qla2x00_fabric_login(vha, & vha->bidir_fcport, & nextlid);
#line 2095
    if (tmp___3 != 0) {
#line 2096
      ql_log(1U, vha, 28839, "Failed to login port %06X for bidirectional IOCB\n",
             (int )vha->bidir_fcport.d_id.b24);
#line 2099
      mutex_unlock(& ha->selflogin_lock);
#line 2100
      rval = 11U;
#line 2101
      goto done;
    } else {

    }
#line 2103
    vha->self_login_loop_id = (unsigned int )nextlid + 65535U;
  } else {

  }
#line 2107
  mutex_unlock(& ha->selflogin_lock);
#line 2109
  vha->bidir_fcport.loop_id = vha->self_login_loop_id;
#line 2111
  tmp___4 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                             bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 2111
  req_sg_cnt = (uint16_t )tmp___4;
#line 2116
  if ((unsigned int )req_sg_cnt == 0U) {
#line 2117
    rval = 17U;
#line 2118
    goto done;
  } else {

  }
#line 2121
  tmp___5 = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                             2, (struct dma_attrs *)0);
#line 2121
  rsp_sg_cnt = (uint16_t )tmp___5;
#line 2125
  if ((unsigned int )rsp_sg_cnt == 0U) {
#line 2126
    rval = 17U;
#line 2127
    goto done_unmap_req_sg;
  } else {

  }
#line 2130
  if ((int )req_sg_cnt != bsg_job->request_payload.sg_cnt || (int )rsp_sg_cnt != bsg_job->reply_payload.sg_cnt) {
#line 2132
    ql_dbg(8388608U, vha, 28841, "Dma mapping resulted in different sg counts [request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt: %x dma_reply_sg_cnt: %x]\n",
           bsg_job->request_payload.sg_cnt, (int )req_sg_cnt, bsg_job->reply_payload.sg_cnt,
           (int )rsp_sg_cnt);
#line 2138
    rval = 17U;
#line 2139
    goto done_unmap_sg;
  } else {

  }
#line 2142
  if (req_data_len != rsp_data_len) {
#line 2143
    rval = 2U;
#line 2144
    ql_log(1U, vha, 28842, "req_data_len != rsp_data_len\n");
#line 2146
    goto done_unmap_sg;
  } else {

  }
#line 2149
  req_data_len = bsg_job->request_payload.payload_len;
#line 2150
  rsp_data_len = bsg_job->reply_payload.payload_len;
#line 2154
  sp = qla2x00_get_sp(vha, & vha->bidir_fcport, 208U);
#line 2155
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2156
    ql_dbg(8388608U, vha, 28844, "Alloc SRB structure failed\n");
#line 2158
    rval = 17U;
#line 2159
    goto done_unmap_sg;
  } else {

  }
#line 2163
  sp->u.bsg_job = bsg_job;
#line 2164
  sp->free = & qla2x00_bsg_sp_free;
#line 2165
  sp->type = 9U;
#line 2166
  sp->done = & qla2x00_bsg_job_done;
#line 2169
  tot_dsds = (uint32_t )((int )rsp_sg_cnt + (int )req_sg_cnt);
#line 2171
  tmp___6 = qla2x00_start_bidir(sp, vha, tot_dsds);
#line 2171
  rval = (uint32_t )tmp___6;
#line 2172
  if (rval != 0U) {
#line 2173
    goto done_free_srb;
  } else {

  }
#line 2175
  return ((int )rval);
  done_free_srb: 
#line 2178
  mempool_free((void *)sp, ha->srb_mempool);
  done_unmap_sg: 
#line 2180
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                         2, (struct dma_attrs *)0);
  done_unmap_req_sg: 
#line 2184
  dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                         1, (struct dma_attrs *)0);
  done: 
#line 2192
  (bsg_job->reply)->reply_data.vendor_reply.vendor_rsp[0] = rval;
#line 2193
  bsg_job->reply_len = 16U;
#line 2194
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 2195
  (bsg_job->reply)->result = 0U;
#line 2196
  (*(bsg_job->job_done))(bsg_job);
#line 2198
  return (0);
}
}
#line 2202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qlafx00_mgmt_cmd(struct fc_bsg_job *bsg_job ) 
{ 
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  int rval ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;
  srb_t *sp ;
  int req_sg_cnt ;
  int rsp_sg_cnt ;
  struct fc_port *fcport ;
  char *type ;
  fc_port_t *tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 2204
  host = bsg_job->shost;
#line 2205
  tmp = shost_priv(host);
#line 2205
  vha = (scsi_qla_host_t *)tmp;
#line 2206
  ha = vha->hw;
#line 2207
  rval = 262144;
#line 2210
  req_sg_cnt = 0;
#line 2210
  rsp_sg_cnt = 0;
#line 2212
  type = (char *)"FC_BSG_HST_FX_MGMT";
#line 2215
  piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 2219
  ql_dump_buffer(8421376U, vha, 28879, (uint8_t *)piocb_rqst, 32U);
#line 2222
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2223
    ql_log(1U, vha, 28880, "Host is not online.\n");
#line 2225
    rval = -5;
#line 2226
    goto done;
  } else {

  }
#line 2229
  if ((int )piocb_rqst->flags & 1) {
#line 2230
    req_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->request_payload.sg_list,
                                  bsg_job->request_payload.sg_cnt, 1, (struct dma_attrs *)0);
#line 2233
    if (req_sg_cnt == 0) {
#line 2234
      ql_log(1U, vha, 28871, "dma_map_sg return %d for request\n", req_sg_cnt);
#line 2236
      rval = -12;
#line 2237
      goto done;
    } else {

    }
  } else {

  }
#line 2241
  if (((int )piocb_rqst->flags & 2) != 0) {
#line 2242
    rsp_sg_cnt = dma_map_sg_attrs(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list,
                                  bsg_job->reply_payload.sg_cnt, 2, (struct dma_attrs *)0);
#line 2245
    if (rsp_sg_cnt == 0) {
#line 2246
      ql_log(1U, vha, 28872, "dma_map_sg return %d for reply\n", rsp_sg_cnt);
#line 2248
      rval = -12;
#line 2249
      goto done_unmap_req_sg;
    } else {

    }
  } else {

  }
#line 2253
  ql_dbg(8388608U, vha, 28873, "request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x dma_reply_sg_cnt: %x\n",
         bsg_job->request_payload.sg_cnt, req_sg_cnt, bsg_job->reply_payload.sg_cnt,
         rsp_sg_cnt);
#line 2263
  tmp___0 = qla2x00_alloc_fcport(vha, 208U);
#line 2263
  fcport = tmp___0;
#line 2264
  if ((unsigned long )fcport == (unsigned long )((struct fc_port *)0)) {
#line 2265
    ql_log(1U, vha, 28874, "Failed to allocate fcport.\n");
#line 2267
    rval = -12;
#line 2268
    goto done_unmap_rsp_sg;
  } else {

  }
#line 2272
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 2273
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2274
    ql_log(1U, vha, 28875, "qla2x00_get_sp failed.\n");
#line 2276
    rval = -12;
#line 2277
    goto done_free_fcport;
  } else {

  }
#line 2281
  fcport->vha = vha;
#line 2282
  fcport->loop_id = (uint16_t )piocb_rqst->dataword;
#line 2284
  sp->type = 11U;
#line 2285
  sp->name = (char *)"bsg_fx_mgmt";
#line 2286
  tmp___1 = qla24xx_calc_ct_iocbs((int )((uint16_t )req_sg_cnt) + (int )((uint16_t )rsp_sg_cnt));
#line 2286
  sp->iocbs = (int )tmp___1;
#line 2287
  sp->u.bsg_job = bsg_job;
#line 2288
  sp->free = & qla2x00_bsg_sp_free;
#line 2289
  sp->done = & qla2x00_bsg_job_done;
#line 2291
  ql_dbg(8388608U, vha, 28876, "bsg rqst type: %s fx_mgmt_type: %x id=%x\n", type,
         (int )piocb_rqst->func_type, (int )fcport->loop_id);
#line 2295
  rval = qla2x00_start_sp(sp);
#line 2296
  if (rval != 0) {
#line 2297
    ql_log(1U, vha, 28877, "qla2x00_start_sp failed=%d.\n", rval);
#line 2299
    mempool_free((void *)sp, ha->srb_mempool);
#line 2300
    rval = -5;
#line 2301
    goto done_free_fcport;
  } else {

  }
#line 2303
  return (rval);
  done_free_fcport: 
#line 2306
  kfree((void const   *)fcport);
  done_unmap_rsp_sg: ;
#line 2309
  if (((int )piocb_rqst->flags & 2) != 0) {
#line 2310
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,
                           2, (struct dma_attrs *)0);
  } else {

  }
  done_unmap_req_sg: ;
#line 2314
  if ((int )piocb_rqst->flags & 1) {
#line 2315
    dma_unmap_sg_attrs___0(& (ha->pdev)->dev, bsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,
                           1, (struct dma_attrs *)0);
  } else {

  }
  done: ;
#line 2320
  return (rval);
}
}
#line 2324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
static int qla2x00_process_vendor_specific(struct fc_bsg_job *bsg_job ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2326
  switch ((bsg_job->request)->rqst_data.h_vendor.vendor_cmd[0]) {
  case 1U: 
#line 2328
  tmp = qla2x00_process_loopback(bsg_job);
#line 2328
  return (tmp);
  case 2U: 
#line 2331
  tmp___0 = qla84xx_reset(bsg_job);
#line 2331
  return (tmp___0);
  case 3U: 
#line 2334
  tmp___1 = qla84xx_updatefw(bsg_job);
#line 2334
  return (tmp___1);
  case 4U: 
#line 2337
  tmp___2 = qla84xx_mgmt_cmd(bsg_job);
#line 2337
  return (tmp___2);
  case 5U: 
#line 2340
  tmp___3 = qla24xx_iidma(bsg_job);
#line 2340
  return (tmp___3);
  case 6U: 
#line 2343
  tmp___4 = qla24xx_proc_fcp_prio_cfg_cmd(bsg_job);
#line 2343
  return (tmp___4);
  case 7U: 
#line 2346
  tmp___5 = qla2x00_read_optrom(bsg_job);
#line 2346
  return (tmp___5);
  case 8U: 
#line 2349
  tmp___6 = qla2x00_update_optrom(bsg_job);
#line 2349
  return (tmp___6);
  case 11U: 
#line 2352
  tmp___7 = qla2x00_update_fru_versions(bsg_job);
#line 2352
  return (tmp___7);
  case 12U: 
#line 2355
  tmp___8 = qla2x00_read_fru_status(bsg_job);
#line 2355
  return (tmp___8);
  case 13U: 
#line 2358
  tmp___9 = qla2x00_write_fru_status(bsg_job);
#line 2358
  return (tmp___9);
  case 16U: 
#line 2361
  tmp___10 = qla2x00_write_i2c(bsg_job);
#line 2361
  return (tmp___10);
  case 17U: 
#line 2364
  tmp___11 = qla2x00_read_i2c(bsg_job);
#line 2364
  return (tmp___11);
  case 10U: 
#line 2367
  tmp___12 = qla24xx_process_bidir_cmd(bsg_job);
#line 2367
  return (tmp___12);
  case 18U: 
#line 2370
  tmp___13 = qlafx00_mgmt_cmd(bsg_job);
#line 2370
  return (tmp___13);
  default: ;
#line 2372
  return (-38);
  }
}
}
#line 2377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int qla24xx_bsg_request(struct fc_bsg_job *bsg_job ) 
{ 
  int ret ;
  struct fc_rport *rport ;
  fc_port_t *fcport ;
  struct Scsi_Host *host ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2379
  ret = -22;
#line 2381
  fcport = (fc_port_t *)0;
#line 2386
  (bsg_job->reply)->reply_payload_rcv_len = 0U;
#line 2388
  if ((bsg_job->request)->msgcode == 1073741825U) {
#line 2389
    rport = bsg_job->rport;
#line 2390
    fcport = *((fc_port_t **)rport->dd_data);
#line 2391
    host = dev_to_shost(rport->dev.parent);
#line 2392
    tmp = shost_priv(host);
#line 2392
    vha = (scsi_qla_host_t *)tmp;
  } else {
#line 2394
    host = bsg_job->shost;
#line 2395
    tmp___0 = shost_priv(host);
#line 2395
    vha = (scsi_qla_host_t *)tmp___0;
  }
#line 2398
  tmp___1 = qla2x00_reset_active(vha);
#line 2398
  if (tmp___1 != 0) {
#line 2399
    ql_dbg(8388608U, vha, 28831, "BSG: ISP abort active/needed -- cmd=%d.\n", (bsg_job->request)->msgcode);
#line 2402
    return (-16);
  } else {

  }
#line 2405
  ql_dbg(8388608U, vha, 28672, "Entered %s msgcode=0x%x.\n", "qla24xx_bsg_request",
         (bsg_job->request)->msgcode);
#line 2408
  switch ((bsg_job->request)->msgcode) {
  case 1073741825U: ;
  case 2147483651U: 
#line 2411
  ret = qla2x00_process_els(bsg_job);
#line 2412
  goto ldv_43902;
  case 2147483652U: 
#line 2414
  ret = qla2x00_process_ct(bsg_job);
#line 2415
  goto ldv_43902;
  case 2147483903U: 
#line 2417
  ret = qla2x00_process_vendor_specific(bsg_job);
#line 2418
  goto ldv_43902;
  case 2147483649U: ;
  case 2147483650U: ;
  case 1073741826U: ;
  default: 
#line 2423
  ql_log(1U, vha, 28762, "Unsupported BSG request.\n");
#line 2424
  goto ldv_43902;
  }
  ldv_43902: ;
#line 2426
  return (ret);
}
}
#line 2430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int qla24xx_bsg_timeout(struct fc_bsg_job *bsg_job ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  struct qla_hw_data *ha ;
  srb_t *sp ;
  int cnt ;
  int que ;
  unsigned long flags ;
  struct req_que *req ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 2432
  tmp = shost_priv(bsg_job->shost);
#line 2432
  vha = (scsi_qla_host_t *)tmp;
#line 2433
  ha = vha->hw;
#line 2440
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2440
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2441
  que = 0;
#line 2441
  goto ldv_43931;
  ldv_43930: 
#line 2442
  req = *(ha->req_q_map + (unsigned long )que);
#line 2443
  if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 2444
    goto ldv_43922;
  } else {

  }
#line 2446
  cnt = 1;
#line 2446
  goto ldv_43928;
  ldv_43927: 
#line 2447
  sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 2448
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 2449
    if ((((unsigned int )sp->type == 5U || (unsigned int )sp->type == 4U) || (unsigned int )sp->type == 11U) && (unsigned long )sp->u.bsg_job == (unsigned long )bsg_job) {
#line 2453
      *(req->outstanding_cmds + (unsigned long )cnt) = (srb_t *)0;
#line 2454
      spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2455
      tmp___1 = (*((ha->isp_ops)->abort_command))(sp);
#line 2455
      if (tmp___1 != 0) {
#line 2456
        ql_log(1U, vha, 28809, "mbx abort_command failed.\n");
#line 2459
        (bsg_job->reply)->result = 4294967291U;
#line 2459
        (bsg_job->req)->errors = -5;
      } else {
#line 2462
        ql_dbg(8388608U, vha, 28810, "mbx abort_command success.\n");
#line 2465
        (bsg_job->reply)->result = 0U;
#line 2465
        (bsg_job->req)->errors = 0;
      }
#line 2468
      tmp___2 = spinlock_check(& ha->hardware_lock);
#line 2468
      flags = _raw_spin_lock_irqsave(tmp___2);
#line 2469
      goto done;
    } else {

    }
  } else {

  }
#line 2446
  cnt = cnt + 1;
  ldv_43928: ;
#line 2446
  if ((int )req->num_outstanding_cmds > cnt) {
#line 2448
    goto ldv_43927;
  } else {

  }

  ldv_43922: 
#line 2441
  que = que + 1;
  ldv_43931: ;
#line 2441
  if ((int )ha->max_req_queues > que) {
#line 2443
    goto ldv_43930;
  } else {

  }
#line 2474
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2475
  ql_log(2U, vha, 28811, "SRB not found to abort.\n");
#line 2476
  (bsg_job->reply)->result = 4294967290U;
#line 2476
  (bsg_job->req)->errors = -6;
#line 2477
  return (0);
  done: 
#line 2480
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2481
  (*(sp->free))((void *)vha, (void *)sp);
#line 2482
  return (0);
}
}
#line 2486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void choose_timer_13(struct timer_list *timer ) 
{ 


  {
#line 2487
  LDV_IN_INTERRUPT = 2;
#line 2488
  (*(timer->function))(timer->data);
#line 2489
  LDV_IN_INTERRUPT = 1;
#line 2490
  ldv_timer_state_13 = 2;
#line 2491
  return;
}
}
#line 2494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2494
  if ((unsigned long )ldv_timer_list_13 == (unsigned long )timer) {
#line 2495
    if (ldv_timer_state_13 == 2 || pending_flag != 0) {
#line 2496
      ldv_timer_list_13 = timer;
#line 2497
      ldv_timer_list_13->data = data;
#line 2498
      ldv_timer_state_13 = 1;
    } else {

    }
#line 2500
    return;
  } else {

  }
#line 2502
  reg_timer_13(timer);
#line 2503
  ldv_timer_list_13->data = data;
#line 2504
  return;
}
}
#line 2507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
void disable_suitable_timer_13(struct timer_list *timer ) 
{ 


  {
#line 2508
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_13) {
#line 2509
    ldv_timer_state_13 = 0;
#line 2510
    return;
  } else {

  }
#line 2512
  return;
}
}
#line 2515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int reg_timer_13(struct timer_list *timer ) 
{ 


  {
#line 2516
  ldv_timer_list_13 = timer;
#line 2517
  ldv_timer_state_13 = 1;
#line 2518
  return (0);
}
}
#line 2520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int ldv_del_timer_65(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 2524
  tmp = del_timer(ldv_func_arg1);
#line 2524
  ldv_func_res = tmp;
#line 2526
  disable_suitable_timer_7(ldv_func_arg1);
#line 2528
  return (ldv_func_res);
}
}
#line 2531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_bsg.o.c.prepared"
int ldv_scsi_add_host_with_dma_66(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 2535
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 2535
  ldv_func_res = tmp;
#line 2537
  if (ldv_func_res == 0) {
#line 2538
    ldv_state_variable_72 = 1;
#line 2538
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 2542
  return (ldv_func_res);
}
}
#line 136 "include/linux/printk.h"
extern int __printk_ratelimit(char const   * ) ;
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t * , char const   * , struct lock_class_key * ) ;
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void ldv_write_lock_irqsave(rwlock_t *lock ) ;
#line 9
void ldv_write_unlock_irqrestore(rwlock_t *lock ) ;
#line 11
void ldv_read_lock(rwlock_t *lock ) ;
#line 12
void ldv_read_unlock(rwlock_t *lock ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_69(struct timer_list *ldv_func_arg1 ) ;
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 53
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 53
  return (ret);
}
}
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
#line 84
  __asm__  volatile   ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
#line 84
  return (ret);
}
}
#line 85 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
#line 85
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 86
  return;
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void activate_pending_timer_14(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 271
int reg_timer_14(struct timer_list *timer ) ;
#line 277
void disable_suitable_timer_14(struct timer_list *timer ) ;
#line 288
void choose_timer_14(struct timer_list *timer ) ;
#line 41 "include/linux/ratelimit.h"
extern int ___ratelimit(struct ratelimit_state * , char const   * ) ;
#line 1014 "include/linux/device.h"
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 817 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 835 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 838
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 838
  return (tmp);
}
}
#line 854
extern int pcie_capability_read_word(struct pci_dev * , int  , u16 * ) ;
#line 921
extern int pci_set_mwi(struct pci_dev * ) ;
#line 1034
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 298 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_70(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 1182 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
static int const   MD_MIU_TEST_AGT_RDDATA[4U]  = {      1090519208,      1090519212,      1090519224,      1090519228};
#line 621 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
int qla82xx_pci_mem_read_2M(struct qla_hw_data *ha , u64 off , void *data , int size ) ;
#line 622
int qla82xx_pci_region_offset(struct pci_dev *pdev , int region ) ;
#line 669
uint32_t qla82xx_wait_for_state_change(scsi_qla_host_t *vha , uint32_t curr_state ) ;
#line 687
char *qdev_state(uint32_t dev_state ) ;
#line 707
int qla82xx_md_alloc(scsi_qla_host_t *vha ) ;
#line 709
int qla82xx_md_collect(scsi_qla_host_t *vha ) ;
#line 712
int qla82xx_validate_template_chksum(scsi_qla_host_t *vha ) ;
#line 735
void qla82xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) ;
#line 737
int qla8044_check_fw_alive(struct scsi_qla_host *vha ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static unsigned long crb_addr_xform[60U]  ;
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_crb_table_initialized  ;
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_crb_addr_transform_setup(void) 
{ 


  {
#line 346
  crb_addr_xform[49] = 1078984704UL;
#line 347
  crb_addr_xform[40] = 1097859072UL;
#line 348
  crb_addr_xform[5] = 218103808UL;
#line 349
  crb_addr_xform[11] = 238026752UL;
#line 350
  crb_addr_xform[10] = 236978176UL;
#line 351
  crb_addr_xform[9] = 235929600UL;
#line 352
  crb_addr_xform[8] = 234881024UL;
#line 353
  crb_addr_xform[16] = 1883242496UL;
#line 354
  crb_addr_xform[15] = 1882193920UL;
#line 355
  crb_addr_xform[14] = 1881145344UL;
#line 356
  crb_addr_xform[13] = 1880096768UL;
#line 357
  crb_addr_xform[48] = 1894776832UL;
#line 358
  crb_addr_xform[47] = 148897792UL;
#line 359
  crb_addr_xform[46] = 147849216UL;
#line 360
  crb_addr_xform[45] = 1891631104UL;
#line 361
  crb_addr_xform[44] = 1890582528UL;
#line 362
  crb_addr_xform[43] = 1889533952UL;
#line 363
  crb_addr_xform[42] = 143654912UL;
#line 364
  crb_addr_xform[53] = 142606336UL;
#line 365
  crb_addr_xform[51] = 1108344832UL;
#line 366
  crb_addr_xform[29] = 1090519040UL;
#line 367
  crb_addr_xform[7] = 241172480UL;
#line 368
  crb_addr_xform[12] = 1879048192UL;
#line 369
  crb_addr_xform[22] = 876609536UL;
#line 370
  crb_addr_xform[21] = 877658112UL;
#line 371
  crb_addr_xform[20] = 875560960UL;
#line 372
  crb_addr_xform[19] = 874512384UL;
#line 373
  crb_addr_xform[18] = 873463808UL;
#line 374
  crb_addr_xform[17] = 872415232UL;
#line 375
  crb_addr_xform[28] = 1010827264UL;
#line 376
  crb_addr_xform[27] = 1011875840UL;
#line 377
  crb_addr_xform[26] = 1009778688UL;
#line 378
  crb_addr_xform[25] = 1008730112UL;
#line 379
  crb_addr_xform[24] = 1007681536UL;
#line 380
  crb_addr_xform[23] = 1006632960UL;
#line 381
  crb_addr_xform[1] = 1999634432UL;
#line 382
  crb_addr_xform[0] = 698351616UL;
#line 383
  crb_addr_xform[6] = 454033408UL;
#line 384
  crb_addr_xform[50] = 1107296256UL;
#line 385
  crb_addr_xform[31] = 219152384UL;
#line 386
  crb_addr_xform[2] = 693108736UL;
#line 387
  crb_addr_xform[3] = 709885952UL;
#line 388
  crb_addr_xform[37] = 209715200UL;
#line 389
  crb_addr_xform[36] = 208666624UL;
#line 390
  crb_addr_xform[35] = 207618048UL;
#line 391
  crb_addr_xform[34] = 1096810496UL;
#line 392
  crb_addr_xform[39] = 1972371456UL;
#line 393
  crb_addr_xform[38] = 1971322880UL;
#line 394
  crb_addr_xform[58] = 1904214016UL;
#line 395
  crb_addr_xform[56] = 1080033280UL;
#line 399
  crb_addr_xform[59] = 428867584UL;
#line 401
  qla82xx_crb_table_initialized = 1;
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static struct crb_128M_2M_block_map crb_128M_2M_map[64U]  = 
#line 404
  {      {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 1048576U, 1056768U, 1179648U}, {1U, 1114112U, 1179648U, 1245184U}, {1U,
                                                                                1179648U,
                                                                                1187840U,
                                                                                1196032U},
       {1U, 1245184U, 1253376U, 1204224U}, {1U, 1310720U, 1318912U, 1212416U}, {1U,
                                                                                1376256U,
                                                                                1384448U,
                                                                                1220608U},
       {1U, 1441792U, 1507328U, 1114112U}, {1U, 1507328U, 1515520U, 1236992U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {1U, 1966080U, 1968128U, 1187840U}, {0U, 0U, 0U, 0U}}}, 
        {{{1U, 2097152U, 2162688U, 1572864U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 4194304U, 4198400U, 1478656U}}}, 
        {{{1U, 5242880U, 5308416U, 1310720U}}}, 
        {{{1U, 6291456U, 6356992U, 1835008U}}}, 
        {{{1U, 7340032U, 7356416U, 1802240U}}}, 
        {{{1U, 8388608U, 8396800U, 1507328U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 9371648U, 9379840U, 1515520U}}}, 
        {{{1U, 9437184U, 9445376U, 1523712U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 10420224U, 10428416U, 1531904U}}}, 
        {{{0U, 10485760U, 10493952U, 1540096U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 11468800U, 11476992U, 1548288U}}}, 
        {{{0U, 11534336U, 11542528U, 1556480U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 12517376U, 12525568U, 1564672U}}}, 
        {{{1U, 12582912U, 12599296U, 1916928U}}}, 
        {{{1U, 13631488U, 13647872U, 1720320U}}}, 
        {{{1U, 14680064U, 14696448U, 1703936U}}}, 
        {{{1U, 15728640U, 15732736U, 1458176U}}}, 
        {{{0U, 16777216U, 16793600U, 1736704U}}}, 
        {{{1U, 17825792U, 17829888U, 1441792U}}}, 
        {{{1U, 18874368U, 18878464U, 1445888U}}}, 
        {{{1U, 19922944U, 19927040U, 1449984U}}}, 
        {{{1U, 20971520U, 20975616U, 1454080U}}}, 
        {{{1U, 22020096U, 22024192U, 1462272U}}}, 
        {{{1U, 23068672U, 23072768U, 1466368U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 30408704U, 30474240U, 1638400U}}}, 
        {{{1U, 31457280U, 31461376U, 1482752U}}}, 
        {{{1U, 32505856U, 32571392U, 1376256U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 34603008U, 34611200U, 1179648U}, {1U, 34668544U, 34734080U, 1245184U},
       {1U, 34734080U, 34742272U, 1196032U}, {1U, 34799616U, 34807808U, 1204224U},
       {1U, 34865152U, 34873344U, 1212416U}, {1U, 34930688U, 34938880U, 1220608U},
       {1U, 34996224U, 35061760U, 1114112U}, {1U, 35061760U, 35069952U, 1236992U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}}}, 
        {{{1U, 35651584U, 35667968U, 1769472U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 41943040U, 41959424U, 1720320U}}}, 
        {{{1U, 42991616U, 42995712U, 1486848U}}}, 
        {{{1U, 44040192U, 44041216U, 1754112U}}}, 
        {{{1U, 45088768U, 45089792U, 1755136U}}}, 
        {{{1U, 46137344U, 46138368U, 1756160U}}}, 
        {{{1U, 47185920U, 47186944U, 1757184U}}}, 
        {{{1U, 48234496U, 48235520U, 1758208U}}}, 
        {{{1U, 49283072U, 49284096U, 1759232U}}}, 
        {{{1U, 50331648U, 50332672U, 1760256U}}}, 
        {{{0U, 51380224U, 51396608U, 1736704U}}}, 
        {{{1U, 52428800U, 52445184U, 1916928U}}}, 
        {{{1U, 53477376U, 53493760U, 1703936U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 55574528U, 55575552U, 1753088U}}}, 
        {{{1U, 56623104U, 56624128U, 1761280U}}}, 
        {{{1U, 57671680U, 57672704U, 1762304U}}}, 
        {{{1U, 58720256U, 58736640U, 1900544U}}}, 
        {{{1U, 59768832U, 59785216U, 1785856U}}}, 
        {{{1U, 60817408U, 60833792U, 1933312U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{0U, 0U, 0U, 0U}}}, 
        {{{1U, 63963136U, 63979520U, 1949696U}}}, 
        {{{1U, 65011712U, 65015808U, 1470464U}}}, 
        {{{1U, 66060288U, 66064384U, 1474560U}}}};
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static unsigned int qla82xx_crb_hub_agt[64U]  = 
#line 564
  {      0U,      1907U,      661U,      677U, 
        0U,      208U,      433U,      230U, 
        224U,      225U,      226U,      227U, 
        1056U,      1047U,      1057U,      843U, 
        1029U,      832U,      833U,      834U, 
        835U,      837U,      836U,      960U, 
        961U,      962U,      963U,      0U, 
        964U,      1040U,      0U,      209U, 
        0U,      1907U,      1046U,      0U, 
        0U,      0U,      0U,      0U, 
        1047U,      0U,      137U,      1802U, 
        1803U,      1804U,      141U,      142U, 
        1807U,      1029U,      1056U,      1057U, 
        0U,      136U,      145U,      1810U, 
        1030U,      0U,      1816U,      409U, 
        425U,      0U,      838U,      0U};
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static char *q_dev_state[8U]  = 
#line 632
  {      (char *)"Unknown",      (char *)"Cold",      (char *)"Initializing",      (char *)"Ready", 
        (char *)"Need Reset",      (char *)"Need Quiescent",      (char *)"Failed",      (char *)"Quiescent"};
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
char *qdev_state(uint32_t dev_state ) 
{ 


  {
#line 645
  return (q_dev_state[dev_state]);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_pci_set_crbwindow_2M(struct qla_hw_data *ha , ulong *off ) 
{ 
  u32 win_read ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 657
  tmp = pci_get_drvdata(ha->pdev);
#line 657
  vha = (scsi_qla_host_t *)tmp;
#line 659
  ha->crb_win = (qla82xx_crb_hub_agt[(*off >> 20) & 63UL] << 20) | ((uint32_t )*off & 983040U);
#line 660
  writel(ha->crb_win, (void volatile   *)(ha->nx_pcibase + 1245280UL));
#line 666
  win_read = readl((void const volatile   *)(ha->nx_pcibase + 1245280UL));
#line 668
  if (ha->crb_win != win_read) {
#line 669
    ql_dbg(524288U, vha, 45056, "%s: Written crbwin (0x%x) != Read crbwin (0x%x), off=0x%lx.\n",
           "qla82xx_pci_set_crbwindow_2M", ha->crb_win, win_read, *off);
  } else {

  }
#line 674
  *off = (ulong )((((unsigned long long )*off & 65535ULL) + (unsigned long long )ha->nx_pcibase) + 1966080ULL);
#line 675
  return;
}
}
#line 719 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_get_crb_addr_2M(struct qla_hw_data *ha , ulong *off ) 
{ 
  struct crb_128M_2M_sub_block_map *m ;

  {
#line 723
  if (*off > 167772159UL) {
#line 724
    return (-1);
  } else {

  }
#line 726
  if (*off > 75497471UL && *off <= 75499519UL) {
#line 727
    *off = (*off + ha->nx_pcibase) - 74450944UL;
#line 729
    return (0);
  } else {

  }
#line 732
  if (*off <= 100663295UL) {
#line 733
    return (-1);
  } else {

  }
#line 735
  *off = *off - 100663296UL;
#line 738
  m = (struct crb_128M_2M_sub_block_map *)(& crb_128M_2M_map[(*off >> 20) & 63UL].sub_block) + ((*off >> 16) & 15UL);
#line 740
  if ((m->valid != 0U && (ulong )m->start_128M <= *off) && (ulong )m->end_128M > *off) {
#line 741
    *off = ((*off + (ulong )m->start_2M) - (ulong )m->start_128M) + ha->nx_pcibase;
#line 742
    return (0);
  } else {

  }
#line 745
  return (1);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_crb_win_lock(struct qla_hw_data *ha ) 
{ 
  int done ;
  int timeout ;

  {
#line 751
  done = 0;
#line 751
  timeout = 0;
#line 753
  goto ldv_43529;
  ldv_43528: 
#line 755
  done = qla82xx_rd_32(ha, 101826616UL);
#line 756
  if (done == 1) {
#line 757
    goto ldv_43527;
  } else {

  }
#line 758
  if (timeout > 99999999) {
#line 759
    return (-1);
  } else {

  }
#line 760
  timeout = timeout + 1;
  ldv_43529: ;
#line 753
  if (done == 0) {
#line 755
    goto ldv_43528;
  } else {

  }
  ldv_43527: 
#line 762
  qla82xx_wr_32(ha, 136323364UL, (u32 )ha->portnum);
#line 763
  return (0);
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_wr_32(struct qla_hw_data *ha , ulong off , u32 data ) 
{ 
  unsigned long flags ;
  int rv ;
  long tmp ;

  {
#line 769
  flags = 0UL;
#line 772
  rv = qla82xx_pci_get_crb_addr_2M(ha, & off);
#line 774
  tmp = ldv__builtin_expect(rv == -1, 0L);
#line 774
  if (tmp != 0L) {
#line 774
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"),
                         "i" (774), "i" (12UL));
    ldv_43537: ;
#line 774
    goto ldv_43537;
  } else {

  }
#line 776
  if (rv == 1) {
#line 777
    ldv_write_lock_irqsave(& ha->hw_lock);
#line 778
    qla82xx_crb_win_lock(ha);
#line 779
    qla82xx_pci_set_crbwindow_2M(ha, & off);
  } else {

  }
#line 782
  writel(data, (void volatile   *)off);
#line 784
  if (rv == 1) {
#line 785
    qla82xx_rd_32(ha, 101826620UL);
#line 786
    ldv_write_unlock_irqrestore(& ha->hw_lock);
  } else {

  }
#line 788
  return (0);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_rd_32(struct qla_hw_data *ha , ulong off ) 
{ 
  unsigned long flags ;
  int rv ;
  u32 data ;
  long tmp ;

  {
#line 794
  flags = 0UL;
#line 798
  rv = qla82xx_pci_get_crb_addr_2M(ha, & off);
#line 800
  tmp = ldv__builtin_expect(rv == -1, 0L);
#line 800
  if (tmp != 0L) {
#line 800
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"),
                         "i" (800), "i" (12UL));
    ldv_43545: ;
#line 800
    goto ldv_43545;
  } else {

  }
#line 802
  if (rv == 1) {
#line 803
    ldv_write_lock_irqsave(& ha->hw_lock);
#line 804
    qla82xx_crb_win_lock(ha);
#line 805
    qla82xx_pci_set_crbwindow_2M(ha, & off);
  } else {

  }
#line 807
  data = readl((void const volatile   *)off);
#line 809
  if (rv == 1) {
#line 810
    qla82xx_rd_32(ha, 101826620UL);
#line 811
    ldv_write_unlock_irqrestore(& ha->hw_lock);
  } else {

  }
#line 813
  return ((int )data);
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_idc_lock(struct qla_hw_data *ha ) 
{ 
  int i ;
  int done ;
  int timeout ;
  struct thread_info *tmp ;

  {
#line 820
  done = 0;
#line 820
  timeout = 0;
#line 822
  goto ldv_43557;
  ldv_43556: 
#line 824
  done = qla82xx_rd_32(ha, 101826600UL);
#line 825
  if (done == 1) {
#line 826
    goto ldv_43552;
  } else {

  }
#line 827
  if (timeout > 99999999) {
#line 828
    return (-1);
  } else {

  }
#line 830
  timeout = timeout + 1;
#line 833
  tmp = current_thread_info();
#line 833
  if (((unsigned long )tmp->preempt_count & 134217472UL) == 0UL) {
#line 834
    schedule();
  } else {
#line 836
    i = 0;
#line 836
    goto ldv_43554;
    ldv_43553: 
#line 837
    cpu_relax();
#line 836
    i = i + 1;
    ldv_43554: ;
#line 836
    if (i <= 19) {
#line 838
      goto ldv_43553;
    } else {

    }

  }
  ldv_43557: ;
#line 822
  if (done == 0) {
#line 824
    goto ldv_43556;
  } else {

  }
  ldv_43552: ;
#line 841
  return (0);
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_idc_unlock(struct qla_hw_data *ha ) 
{ 


  {
#line 846
  qla82xx_rd_32(ha, 101826604UL);
#line 847
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static unsigned long qla82xx_pci_mem_bound_check(struct qla_hw_data *ha , unsigned long long addr ,
                                                 int size ) 
{ 


  {
#line 860
  if ((addr > 268435455ULL || ((unsigned long long )size + addr) - 1ULL > 268435455ULL) || (((size != 1 && size != 2) && size != 4) && size != 8)) {
#line 865
    return (0UL);
  } else {
#line 867
    return (1UL);
  }
}
}
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_set_window_warning_count  ;
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static unsigned long qla82xx_pci_set_window(struct qla_hw_data *ha , unsigned long long addr ) 
{ 
  int window ;
  u32 win_read ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned int temp1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 877
  tmp = pci_get_drvdata(ha->pdev);
#line 877
  vha = (scsi_qla_host_t *)tmp;
#line 879
  if (addr <= 268435455ULL) {
#line 882
    window = (int )((unsigned int )((addr & 33292288ULL) >> 1) | ((unsigned int )(addr >> 25) & 1023U));
#line 883
    ha->ddr_mn_window = (uint32_t )window;
#line 884
    qla82xx_wr_32(ha, ha->mn_win_crb | 100663296UL, (u32 )window);
#line 886
    tmp___0 = qla82xx_rd_32(ha, ha->mn_win_crb | 100663296UL);
#line 886
    win_read = (u32 )tmp___0;
#line 888
    if (win_read << 17 != (u32 )window) {
#line 889
      ql_dbg(524288U, vha, 45059, "%s: Written MNwin (0x%x) != Read MNwin (0x%x).\n",
             "qla82xx_pci_set_window", window, win_read);
    } else {

    }
#line 893
    addr = addr & 262143ULL;
  } else
#line 894
  if (addr <= 8590983167ULL && addr > 8589934591ULL) {
#line 897
    if ((addr & 1046528ULL) == 1046528ULL) {
#line 898
      ql_log(1U, vha, 45060, "%s: QM access not handled.\n", "qla82xx_pci_set_window");
#line 900
      addr = 0xffffffffffffffffULL;
    } else {

    }
#line 902
    window = (int )((unsigned int )((addr & 33488896ULL) >> 1) | ((unsigned int )(addr >> 25) & 1023U));
#line 903
    ha->ddr_mn_window = (uint32_t )window;
#line 904
    qla82xx_wr_32(ha, ha->mn_win_crb | 100663296UL, (u32 )window);
#line 906
    tmp___1 = qla82xx_rd_32(ha, ha->mn_win_crb | 100663296UL);
#line 906
    win_read = (u32 )tmp___1;
#line 908
    temp1 = ((unsigned int )(window << 7) & 65535U) | ((unsigned int )window >> 17);
#line 910
    if (win_read != temp1) {
#line 911
      ql_log(1U, vha, 45061, "%s: Written OCMwin (0x%x) != Read OCMwin (0x%x).\n",
             "qla82xx_pci_set_window", temp1, win_read);
    } else {

    }
#line 915
    addr = (addr & 262143ULL) + 786432ULL;
  } else
#line 917
  if (addr <= 12952010751ULL && addr > 12884901887ULL) {
#line 920
    window = (int )addr & 268173312;
#line 921
    ha->qdr_sn_window = window;
#line 922
    qla82xx_wr_32(ha, ha->ms_win_crb | 100663296UL, (u32 )window);
#line 924
    tmp___2 = qla82xx_rd_32(ha, ha->ms_win_crb | 100663296UL);
#line 924
    win_read = (u32 )tmp___2;
#line 926
    if ((u32 )window != win_read) {
#line 927
      ql_log(1U, vha, 45062, "%s: Written MSwin (0x%x) != Read MSwin (0x%x).\n", "qla82xx_pci_set_window",
             window, win_read);
    } else {

    }
#line 931
    addr = (addr & 262143ULL) + 67108864ULL;
  } else {
#line 937
    tmp___3 = qla82xx_pci_set_window_warning_count;
#line 937
    qla82xx_pci_set_window_warning_count = qla82xx_pci_set_window_warning_count + 1;
#line 937
    if (tmp___3 <= 7 || ((unsigned int )qla82xx_pci_set_window_warning_count & 63U) == 0U) {
#line 939
      ql_log(1U, vha, 45063, "%s: Warning:%s Unknown address range!.\n", "qla82xx_pci_set_window",
             (char *)"qla2xxx");
    } else {

    }
#line 943
    addr = 0xffffffffffffffffULL;
  }
#line 945
  return ((unsigned long )addr);
}
}
#line 949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_is_same_window(struct qla_hw_data *ha , unsigned long long addr ) 
{ 
  int window ;
  unsigned long long qdr_max ;

  {
#line 955
  qdr_max = 12952010751ULL;
#line 958
  if (addr <= 268435455ULL) {
#line 960
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"),
                         "i" (960), "i" (12UL));
    ldv_43582: ;
#line 960
    goto ldv_43582;
  } else
#line 961
  if (addr <= 8590983167ULL && addr > 8589934591ULL) {
#line 963
    return (1);
  } else
#line 964
  if (addr <= 8595177471ULL && addr > 8594128895ULL) {
#line 966
    return (1);
  } else
#line 967
  if (addr <= qdr_max && addr > 12884901887ULL) {
#line 969
    window = (int )((addr - 12884901888ULL) >> 22) & 63;
#line 970
    if (ha->qdr_sn_window == window) {
#line 971
      return (1);
    } else {

    }
  } else {

  }
#line 973
  return (0);
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_mem_read_direct(struct qla_hw_data *ha , u64 off , void *data ,
                                       int size ) 
{ 
  void *addr ;
  int ret ;
  u64 start ;
  uint8_t *mem_ptr ;
  unsigned long mem_base ;
  unsigned long mem_page ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 980
  addr = (void *)0;
#line 981
  ret = 0;
#line 983
  mem_ptr = (uint8_t *)0U;
#line 986
  tmp = pci_get_drvdata(ha->pdev);
#line 986
  vha = (scsi_qla_host_t *)tmp;
#line 988
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 994
  tmp___0 = qla82xx_pci_set_window(ha, off);
#line 994
  start = (u64 )tmp___0;
#line 995
  if (start == 0xffffffffffffffffULL) {
#line 997
    ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 998
    ql_log(0U, vha, 45064, "%s out of bound pci memory access, offset is 0x%llx.\n",
           (char *)"qla2xxx", off);
#line 1002
    return (-1);
  } else {
#line 995
    tmp___1 = qla82xx_pci_is_same_window(ha, ((u64 )size + off) - 1ULL);
#line 995
    if (tmp___1 == 0) {
#line 997
      ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 998
      ql_log(0U, vha, 45064, "%s out of bound pci memory access, offset is 0x%llx.\n",
             (char *)"qla2xxx", off);
#line 1002
      return (-1);
    } else {

    }
  }
#line 1005
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1006
  mem_base = (unsigned long )(ha->pdev)->resource[0].start;
#line 1007
  mem_page = (unsigned long )start & 0xfffffffffffff000UL;
#line 1011
  if (((((u64 )size + start) - 1ULL) & 0xfffffffffffff000ULL) != (unsigned long long )mem_page) {
#line 1012
    tmp___2 = ioremap((resource_size_t )(mem_base + mem_page), 8192UL);
#line 1012
    mem_ptr = (uint8_t *)tmp___2;
  } else {
#line 1014
    tmp___3 = ioremap((resource_size_t )(mem_base + mem_page), 4096UL);
#line 1014
    mem_ptr = (uint8_t *)tmp___3;
  }
#line 1015
  if ((unsigned long )mem_ptr == (unsigned long )((uint8_t *)0U)) {
#line 1016
    *((u8 *)data) = 0U;
#line 1017
    return (-1);
  } else {

  }
#line 1019
  addr = (void *)mem_ptr;
#line 1020
  addr = addr + (start & 4095ULL);
#line 1021
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 1023
  switch (size) {
  case 1: 
#line 1025
  *((u8 *)data) = readb((void const volatile   *)addr);
#line 1026
  goto ldv_43598;
  case 2: 
#line 1028
  *((u16 *)data) = readw((void const volatile   *)addr);
#line 1029
  goto ldv_43598;
  case 4: 
#line 1031
  *((u32 *)data) = readl((void const volatile   *)addr);
#line 1032
  goto ldv_43598;
  case 8: 
#line 1034
  tmp___4 = readq((void const volatile   *)addr);
#line 1034
  *((u64 *)data) = (u64 )tmp___4;
#line 1035
  goto ldv_43598;
  default: 
#line 1037
  ret = -1;
#line 1038
  goto ldv_43598;
  }
  ldv_43598: 
#line 1040
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1042
  if ((unsigned long )mem_ptr != (unsigned long )((uint8_t *)0U)) {
#line 1043
    iounmap((void volatile   *)mem_ptr);
  } else {

  }
#line 1044
  return (ret);
}
}
#line 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_mem_write_direct(struct qla_hw_data *ha , u64 off , void *data ,
                                        int size ) 
{ 
  void *addr ;
  int ret ;
  u64 start ;
  uint8_t *mem_ptr ;
  unsigned long mem_base ;
  unsigned long mem_page ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1052
  addr = (void *)0;
#line 1053
  ret = 0;
#line 1055
  mem_ptr = (uint8_t *)0U;
#line 1058
  tmp = pci_get_drvdata(ha->pdev);
#line 1058
  vha = (scsi_qla_host_t *)tmp;
#line 1060
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 1066
  tmp___0 = qla82xx_pci_set_window(ha, off);
#line 1066
  start = (u64 )tmp___0;
#line 1067
  if (start == 0xffffffffffffffffULL) {
#line 1069
    ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1070
    ql_log(0U, vha, 45065, "%s out of bount memory access, offset is 0x%llx.\n", (char *)"qla2xxx",
           off);
#line 1074
    return (-1);
  } else {
#line 1067
    tmp___1 = qla82xx_pci_is_same_window(ha, ((u64 )size + off) - 1ULL);
#line 1067
    if (tmp___1 == 0) {
#line 1069
      ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1070
      ql_log(0U, vha, 45065, "%s out of bount memory access, offset is 0x%llx.\n",
             (char *)"qla2xxx", off);
#line 1074
      return (-1);
    } else {

    }
  }
#line 1077
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1078
  mem_base = (unsigned long )(ha->pdev)->resource[0].start;
#line 1079
  mem_page = (unsigned long )start & 0xfffffffffffff000UL;
#line 1083
  if (((((u64 )size + start) - 1ULL) & 0xfffffffffffff000ULL) != (unsigned long long )mem_page) {
#line 1084
    tmp___2 = ioremap((resource_size_t )(mem_base + mem_page), 8192UL);
#line 1084
    mem_ptr = (uint8_t *)tmp___2;
  } else {
#line 1086
    tmp___3 = ioremap((resource_size_t )(mem_base + mem_page), 4096UL);
#line 1086
    mem_ptr = (uint8_t *)tmp___3;
  }
#line 1087
  if ((unsigned long )mem_ptr == (unsigned long )((uint8_t *)0U)) {
#line 1088
    return (-1);
  } else {

  }
#line 1090
  addr = (void *)mem_ptr;
#line 1091
  addr = addr + (start & 4095ULL);
#line 1092
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 1094
  switch (size) {
  case 1: 
#line 1096
  writeb((int )*((u8 *)data), (void volatile   *)addr);
#line 1097
  goto ldv_43618;
  case 2: 
#line 1099
  writew((int )*((u16 *)data), (void volatile   *)addr);
#line 1100
  goto ldv_43618;
  case 4: 
#line 1102
  writel(*((u32 *)data), (void volatile   *)addr);
#line 1103
  goto ldv_43618;
  case 8: 
#line 1105
  writeq((unsigned long )*((u64 *)data), (void volatile   *)addr);
#line 1106
  goto ldv_43618;
  default: 
#line 1108
  ret = -1;
#line 1109
  goto ldv_43618;
  }
  ldv_43618: 
#line 1111
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 1112
  if ((unsigned long )mem_ptr != (unsigned long )((uint8_t *)0U)) {
#line 1113
    iounmap((void volatile   *)mem_ptr);
  } else {

  }
#line 1114
  return (ret);
}
}
#line 1119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static unsigned long qla82xx_decode_crb_addr(unsigned long addr ) 
{ 
  int i ;
  unsigned long base_addr ;
  unsigned long offset ;
  unsigned long pci_base ;

  {
#line 1124
  if (qla82xx_crb_table_initialized == 0) {
#line 1125
    qla82xx_crb_addr_transform_setup();
  } else {

  }
#line 1127
  pci_base = 4294967295UL;
#line 1128
  base_addr = addr & 4293918720UL;
#line 1129
  offset = addr & 1048575UL;
#line 1131
  i = 0;
#line 1131
  goto ldv_43632;
  ldv_43631: ;
#line 1132
  if (crb_addr_xform[i] == base_addr) {
#line 1133
    pci_base = (unsigned long )(i << 20);
#line 1134
    goto ldv_43630;
  } else {

  }
#line 1131
  i = i + 1;
  ldv_43632: ;
#line 1131
  if (i <= 59) {
#line 1133
    goto ldv_43631;
  } else {

  }
  ldv_43630: ;
#line 1137
  if (pci_base == 4294967295UL) {
#line 1138
    return (pci_base);
  } else {

  }
#line 1139
  return (pci_base + offset);
}
}
#line 1142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static long rom_max_timeout  =    100L;
#line 1143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static long qla82xx_rom_lock_timeout  =    100L;
#line 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_rom_lock(struct qla_hw_data *ha ) 
{ 
  int done ;
  int timeout ;
  uint32_t lock_owner ;
  int tmp ;

  {
#line 1148
  done = 0;
#line 1148
  timeout = 0;
#line 1149
  lock_owner = 0U;
#line 1151
  goto ldv_43643;
  ldv_43642: 
#line 1153
  done = qla82xx_rd_32(ha, 101826576UL);
#line 1154
  if (done == 1) {
#line 1155
    goto ldv_43641;
  } else {

  }
#line 1156
  if ((long )timeout >= qla82xx_rom_lock_timeout) {
#line 1157
    tmp = qla82xx_rd_32(ha, 136323328UL);
#line 1157
    lock_owner = (uint32_t )tmp;
#line 1158
    return (-1);
  } else {

  }
#line 1160
  timeout = timeout + 1;
  ldv_43643: ;
#line 1151
  if (done == 0) {
#line 1153
    goto ldv_43642;
  } else {

  }
  ldv_43641: 
#line 1162
  qla82xx_wr_32(ha, 136323328UL, 222393152U);
#line 1163
  return (0);
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_rom_unlock(struct qla_hw_data *ha ) 
{ 


  {
#line 1169
  qla82xx_rd_32(ha, 101826580UL);
#line 1170
  return;
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_wait_rom_busy(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  long done ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1175
  timeout = 0L;
#line 1176
  done = 0L;
#line 1177
  tmp = pci_get_drvdata(ha->pdev);
#line 1177
  vha = (scsi_qla_host_t *)tmp;
#line 1179
  goto ldv_43654;
  ldv_43653: 
#line 1180
  tmp___0 = qla82xx_rd_32(ha, 154140676UL);
#line 1180
  done = (long )tmp___0;
#line 1181
  done = done & 4L;
#line 1182
  timeout = timeout + 1L;
#line 1183
  if (timeout >= rom_max_timeout) {
#line 1184
    ql_dbg(524288U, vha, 45066, "%s: Timeout reached waiting for rom busy.\n", (char *)"qla2xxx");
#line 1187
    return (-1);
  } else {

  }
  ldv_43654: ;
#line 1179
  if (done == 0L) {
#line 1181
    goto ldv_43653;
  } else {

  }

#line 1190
  return (0);
}
}
#line 1194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_wait_rom_done(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  long done ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1196
  timeout = 0L;
#line 1197
  done = 0L;
#line 1198
  tmp = pci_get_drvdata(ha->pdev);
#line 1198
  vha = (scsi_qla_host_t *)tmp;
#line 1200
  goto ldv_43663;
  ldv_43662: 
#line 1201
  tmp___0 = qla82xx_rd_32(ha, 154140676UL);
#line 1201
  done = (long )tmp___0;
#line 1202
  done = done & 2L;
#line 1203
  timeout = timeout + 1L;
#line 1204
  if (timeout >= rom_max_timeout) {
#line 1205
    ql_dbg(524288U, vha, 45067, "%s: Timeout reached waiting for rom done.\n", (char *)"qla2xxx");
#line 1208
    return (-1);
  } else {

  }
  ldv_43663: ;
#line 1200
  if (done == 0L) {
#line 1202
    goto ldv_43662;
  } else {

  }

#line 1211
  return (0);
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_md_rw_32(struct qla_hw_data *ha , uint32_t off , u32 data , uint8_t flag ) 
{ 
  uint32_t off_value ;
  uint32_t rval ;

  {
#line 1217
  rval = 0U;
#line 1219
  writel(off & 4294901760U, (void volatile   *)(ha->nx_pcibase + 1245280UL));
#line 1223
  readl((void const volatile   *)(ha->nx_pcibase + 1245280UL));
#line 1224
  off_value = off & 65535U;
#line 1226
  if ((unsigned int )flag != 0U) {
#line 1227
    writel(data, (void volatile   *)(((unsigned long )off_value + ha->nx_pcibase) + 1966080UL));
  } else {
#line 1231
    rval = readl((void const volatile   *)(((unsigned long )off_value + ha->nx_pcibase) + 1966080UL));
  }
#line 1234
  return ((int )rval);
}
}
#line 1238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_do_rom_fast_read(struct qla_hw_data *ha , int addr , int *valp ) 
{ 


  {
#line 1241
  qla82xx_md_rw_32(ha, 1108410416U, (unsigned int )addr & 4294901760U, 1);
#line 1242
  *valp = qla82xx_md_rw_32(ha, (uint32_t )((addr & 65535) + 1108672512), 0U, 0);
#line 1245
  return (0);
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_rom_fast_read(struct qla_hw_data *ha , int addr , int *valp ) 
{ 
  int ret ;
  int loops ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1251
  loops = 0;
#line 1252
  tmp = pci_get_drvdata(ha->pdev);
#line 1252
  vha = (scsi_qla_host_t *)tmp;
#line 1254
  goto ldv_43687;
  ldv_43686: 
#line 1255
  __const_udelay(429500UL);
#line 1256
  schedule();
#line 1257
  loops = loops + 1;
  ldv_43687: 
#line 1254
  tmp___0 = qla82xx_rom_lock(ha);
#line 1254
  if (tmp___0 != 0 && loops <= 49999) {
#line 1256
    goto ldv_43686;
  } else {

  }

#line 1259
  if (loops > 49999) {
#line 1260
    ql_log(0U, vha, 185, "Failed to acquire SEM2 lock.\n");
#line 1262
    return (-1);
  } else {

  }
#line 1264
  ret = qla82xx_do_rom_fast_read(ha, addr, valp);
#line 1265
  qla82xx_rom_unlock(ha);
#line 1266
  return (ret);
}
}
#line 1270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_read_status_reg(struct qla_hw_data *ha , uint32_t *val ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1272
  tmp = pci_get_drvdata(ha->pdev);
#line 1272
  vha = (scsi_qla_host_t *)tmp;
#line 1273
  qla82xx_wr_32(ha, 154206212UL, 5U);
#line 1274
  qla82xx_wait_rom_busy(ha);
#line 1275
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 1275
  if (tmp___0 != 0) {
#line 1276
    ql_log(1U, vha, 45068, "Error waiting for rom done.\n");
#line 1278
    return (-1);
  } else {

  }
#line 1280
  tmp___1 = qla82xx_rd_32(ha, 154206232UL);
#line 1280
  *val = (uint32_t )tmp___1;
#line 1281
  return (0);
}
}
#line 1285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_flash_wait_write_finish(struct qla_hw_data *ha ) 
{ 
  long timeout ;
  uint32_t done ;
  uint32_t val ;
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 1287
  timeout = 0L;
#line 1288
  done = 1U;
#line 1290
  ret = 0;
#line 1291
  tmp = pci_get_drvdata(ha->pdev);
#line 1291
  vha = (scsi_qla_host_t *)tmp;
#line 1293
  qla82xx_wr_32(ha, 154206224UL, 0U);
#line 1294
  goto ldv_43704;
  ldv_43703: 
#line 1295
  ret = qla82xx_read_status_reg(ha, & val);
#line 1296
  done = val & 1U;
#line 1297
  timeout = timeout + 1L;
#line 1298
  __const_udelay(42950UL);
#line 1299
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared",
                1299, 0);
#line 1299
  _cond_resched();
#line 1300
  if (timeout > 49999L) {
#line 1301
    ql_log(1U, vha, 45069, "Timeout reached waiting for write finish.\n");
#line 1303
    return (-1);
  } else {

  }
  ldv_43704: ;
#line 1294
  if (done != 0U && ret == 0) {
#line 1296
    goto ldv_43703;
  } else {

  }

#line 1306
  return (ret);
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_flash_set_write_enable(struct qla_hw_data *ha ) 
{ 
  uint32_t val ;
  int tmp ;
  int tmp___0 ;

  {
#line 1313
  qla82xx_wait_rom_busy(ha);
#line 1314
  qla82xx_wr_32(ha, 154206224UL, 0U);
#line 1315
  qla82xx_wr_32(ha, 154206212UL, 6U);
#line 1316
  qla82xx_wait_rom_busy(ha);
#line 1317
  tmp = qla82xx_wait_rom_done(ha);
#line 1317
  if (tmp != 0) {
#line 1318
    return (-1);
  } else {

  }
#line 1319
  tmp___0 = qla82xx_read_status_reg(ha, & val);
#line 1319
  if (tmp___0 != 0) {
#line 1320
    return (-1);
  } else {

  }
#line 1321
  if ((val & 2U) == 0U) {
#line 1322
    return (-1);
  } else {

  }
#line 1323
  return (0);
}
}
#line 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_write_status_reg(struct qla_hw_data *ha , uint32_t val ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1329
  tmp = pci_get_drvdata(ha->pdev);
#line 1329
  vha = (scsi_qla_host_t *)tmp;
#line 1330
  tmp___0 = qla82xx_flash_set_write_enable(ha);
#line 1330
  if (tmp___0 != 0) {
#line 1331
    return (-1);
  } else {

  }
#line 1332
  qla82xx_wr_32(ha, 154206220UL, val);
#line 1333
  qla82xx_wr_32(ha, 154206212UL, 1U);
#line 1334
  tmp___1 = qla82xx_wait_rom_done(ha);
#line 1334
  if (tmp___1 != 0) {
#line 1335
    ql_log(1U, vha, 45070, "Error waiting for rom done.\n");
#line 1337
    return (-1);
  } else {

  }
#line 1339
  tmp___2 = qla82xx_flash_wait_write_finish(ha);
#line 1339
  return (tmp___2);
}
}
#line 1343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_write_disable_flash(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1345
  tmp = pci_get_drvdata(ha->pdev);
#line 1345
  vha = (scsi_qla_host_t *)tmp;
#line 1346
  qla82xx_wr_32(ha, 154206212UL, 4U);
#line 1347
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 1347
  if (tmp___0 != 0) {
#line 1348
    ql_log(1U, vha, 45071, "Error waiting for rom done.\n");
#line 1350
    return (-1);
  } else {

  }
#line 1352
  return (0);
}
}
#line 1356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int ql82xx_rom_lock_d(struct qla_hw_data *ha ) 
{ 
  int loops ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1358
  loops = 0;
#line 1359
  tmp = pci_get_drvdata(ha->pdev);
#line 1359
  vha = (scsi_qla_host_t *)tmp;
#line 1361
  goto ldv_43726;
  ldv_43725: 
#line 1362
  __const_udelay(429500UL);
#line 1363
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared",
                1363, 0);
#line 1363
  _cond_resched();
#line 1364
  loops = loops + 1;
  ldv_43726: 
#line 1361
  tmp___0 = qla82xx_rom_lock(ha);
#line 1361
  if (tmp___0 != 0 && loops <= 49999) {
#line 1363
    goto ldv_43725;
  } else {

  }

#line 1366
  if (loops > 49999) {
#line 1367
    ql_log(1U, vha, 45072, "ROM lock failed.\n");
#line 1369
    return (-1);
  } else {

  }
#line 1371
  return (0);
}
}
#line 1375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_write_flash_dword(struct qla_hw_data *ha , uint32_t flashaddr ,
                                     uint32_t data ) 
{ 
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1378
  ret = 0;
#line 1379
  tmp = pci_get_drvdata(ha->pdev);
#line 1379
  vha = (scsi_qla_host_t *)tmp;
#line 1381
  ret = ql82xx_rom_lock_d(ha);
#line 1382
  if (ret < 0) {
#line 1383
    ql_log(1U, vha, 45073, "ROM lock failed.\n");
#line 1385
    return (ret);
  } else {

  }
#line 1388
  tmp___0 = qla82xx_flash_set_write_enable(ha);
#line 1388
  if (tmp___0 != 0) {
#line 1389
    goto done_write;
  } else {

  }
#line 1391
  qla82xx_wr_32(ha, 154206220UL, data);
#line 1392
  qla82xx_wr_32(ha, 154206216UL, flashaddr);
#line 1393
  qla82xx_wr_32(ha, 154206224UL, 3U);
#line 1394
  qla82xx_wr_32(ha, 154206212UL, 2U);
#line 1395
  qla82xx_wait_rom_busy(ha);
#line 1396
  tmp___1 = qla82xx_wait_rom_done(ha);
#line 1396
  if (tmp___1 != 0) {
#line 1397
    ql_log(1U, vha, 45074, "Error waiting for rom done.\n");
#line 1399
    ret = -1;
#line 1400
    goto done_write;
  } else {

  }
#line 1403
  ret = qla82xx_flash_wait_write_finish(ha);
  done_write: 
#line 1406
  qla82xx_rom_unlock(ha);
#line 1407
  return (ret);
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pinit_from_rom(scsi_qla_host_t *vha ) 
{ 
  int addr ;
  int val ;
  int i ;
  struct crb_addr_pair *buf ;
  unsigned long off ;
  unsigned int offset ;
  unsigned int n ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1421
  ha = vha->hw;
#line 1429
  qla82xx_rom_lock(ha);
#line 1432
  qla82xx_wr_32(ha, 153092112UL, 0U);
#line 1433
  qla82xx_wr_32(ha, 153092116UL, 0U);
#line 1434
  qla82xx_wr_32(ha, 153092120UL, 0U);
#line 1435
  qla82xx_wr_32(ha, 153092124UL, 0U);
#line 1436
  qla82xx_wr_32(ha, 153092128UL, 0U);
#line 1437
  qla82xx_wr_32(ha, 153092132UL, 0U);
#line 1440
  qla82xx_wr_32(ha, 106954816UL, 255U);
#line 1442
  qla82xx_wr_32(ha, 107413504UL, 0U);
#line 1444
  qla82xx_wr_32(ha, 107479040UL, 0U);
#line 1446
  qla82xx_wr_32(ha, 107544576UL, 0U);
#line 1448
  qla82xx_wr_32(ha, 107610112UL, 0U);
#line 1450
  qla82xx_wr_32(ha, 107675648UL, 0U);
#line 1453
  val = qla82xx_rd_32(ha, 105910272UL);
#line 1454
  qla82xx_wr_32(ha, 105910272UL, (u32 )val & 4294967294U);
#line 1457
  qla82xx_wr_32(ha, 133174016UL, 1U);
#line 1460
  qla82xx_wr_32(ha, 142606336UL, 0U);
#line 1461
  qla82xx_wr_32(ha, 142606344UL, 0U);
#line 1462
  qla82xx_wr_32(ha, 142606352UL, 0U);
#line 1463
  qla82xx_wr_32(ha, 142606360UL, 0U);
#line 1464
  qla82xx_wr_32(ha, 142606592UL, 0U);
#line 1465
  qla82xx_wr_32(ha, 142606848UL, 0U);
#line 1468
  qla82xx_wr_32(ha, 118489148UL, 1U);
#line 1469
  qla82xx_wr_32(ha, 119537724UL, 1U);
#line 1470
  qla82xx_wr_32(ha, 120586300UL, 1U);
#line 1471
  qla82xx_wr_32(ha, 121634876UL, 1U);
#line 1472
  qla82xx_wr_32(ha, 116391996UL, 1U);
#line 1473
  msleep(20U);
#line 1476
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1476
  if (tmp != 0) {
#line 1478
    qla82xx_wr_32(ha, 154140680UL, 4278190079U);
  } else {
#line 1480
    qla82xx_wr_32(ha, 154140680UL, 4294967295U);
  }
#line 1481
  qla82xx_rom_unlock(ha);
#line 1488
  tmp___0 = qla82xx_rom_fast_read(ha, 0, (int *)(& n));
#line 1488
  if (tmp___0 != 0 || n != 3405695742U) {
#line 1490
    ql_log(0U, vha, 110, "Error Reading crb_init area: n: %08x.\n", n);
#line 1492
    return (-1);
  } else {
#line 1488
    tmp___1 = qla82xx_rom_fast_read(ha, 4, (int *)(& n));
#line 1488
    if (tmp___1 != 0) {
#line 1490
      ql_log(0U, vha, 110, "Error Reading crb_init area: n: %08x.\n", n);
#line 1492
      return (-1);
    } else {

    }
  }
#line 1498
  offset = n & 65535U;
#line 1499
  n = n >> 16;
#line 1502
  if (n > 1023U) {
#line 1503
    ql_log(0U, vha, 113, "Card flash not initialized:n=0x%x.\n", n);
#line 1505
    return (-1);
  } else {

  }
#line 1508
  ql_log(2U, vha, 114, "%d CRB init values found in ROM.\n", n);
#line 1511
  tmp___2 = kmalloc((unsigned long )n * 16UL, 208U);
#line 1511
  buf = (struct crb_addr_pair___0 *)tmp___2;
#line 1512
  if ((unsigned long )buf == (unsigned long )((struct crb_addr_pair___0 *)0)) {
#line 1513
    ql_log(0U, vha, 268, "Unable to allocate memory.\n");
#line 1515
    return (-1);
  } else {

  }
#line 1518
  i = 0;
#line 1518
  goto ldv_43751;
  ldv_43750: 
#line 1519
  tmp___3 = qla82xx_rom_fast_read(ha, (int )(((unsigned int )(i * 2) + offset) * 4U),
                                  & val);
#line 1519
  if (tmp___3 != 0) {
#line 1521
    kfree((void const   *)buf);
#line 1522
    return (-1);
  } else {
#line 1519
    tmp___4 = qla82xx_rom_fast_read(ha, (int )((((unsigned int )(i * 2) + offset) + 1U) * 4U),
                                    & addr);
#line 1519
    if (tmp___4 != 0) {
#line 1521
      kfree((void const   *)buf);
#line 1522
      return (-1);
    } else {

    }
  }
#line 1525
  (buf + (unsigned long )i)->addr = (long )addr;
#line 1526
  (buf + (unsigned long )i)->data = (long )val;
#line 1518
  i = i + 1;
  ldv_43751: ;
#line 1518
  if ((unsigned int )i < n) {
#line 1520
    goto ldv_43750;
  } else {

  }
#line 1529
  i = 0;
#line 1529
  goto ldv_43755;
  ldv_43754: 
#line 1533
  tmp___5 = qla82xx_decode_crb_addr((unsigned long )(buf + (unsigned long )i)->addr);
#line 1533
  off = tmp___5 + 100663296UL;
#line 1540
  if (off == 136323580UL) {
#line 1541
    goto ldv_43753;
  } else {

  }
#line 1544
  if (off == 154140860UL) {
#line 1545
    goto ldv_43753;
  } else {

  }
#line 1548
  if (off == 154140872UL) {
#line 1549
    goto ldv_43753;
  } else {

  }
#line 1552
  if (off == 101785664UL) {
#line 1553
    goto ldv_43753;
  } else {

  }
#line 1555
  if (off == 101785672UL) {
#line 1556
    goto ldv_43753;
  } else {

  }
#line 1558
  if ((off & 267386880UL) == 161480704UL) {
#line 1559
    goto ldv_43753;
  } else {

  }
#line 1561
  if ((off & 267386880UL) == 102760448UL) {
#line 1562
    goto ldv_43753;
  } else {

  }
#line 1564
  if (off == 4294967295UL) {
#line 1565
    ql_log(0U, vha, 278, "Unknow addr: 0x%08lx.\n", (buf + (unsigned long )i)->addr);
#line 1567
    goto ldv_43753;
  } else {

  }
#line 1570
  qla82xx_wr_32(ha, off, (u32 )(buf + (unsigned long )i)->data);
#line 1575
  if (off == 154140680UL) {
#line 1576
    msleep(1000U);
  } else {

  }
#line 1581
  msleep(1U);
  ldv_43753: 
#line 1529
  i = i + 1;
  ldv_43755: ;
#line 1529
  if ((unsigned int )i < n) {
#line 1531
    goto ldv_43754;
  } else {

  }
#line 1584
  kfree((void const   *)buf);
#line 1587
  qla82xx_wr_32(ha, 122683628UL, 30U);
#line 1588
  qla82xx_wr_32(ha, 122683468UL, 8U);
#line 1589
  qla82xx_wr_32(ha, 123732044UL, 8U);
#line 1592
  qla82xx_wr_32(ha, 118489096UL, 0U);
#line 1593
  qla82xx_wr_32(ha, 118489100UL, 0U);
#line 1594
  qla82xx_wr_32(ha, 119537672UL, 0U);
#line 1595
  qla82xx_wr_32(ha, 119537676UL, 0U);
#line 1596
  qla82xx_wr_32(ha, 120586248UL, 0U);
#line 1597
  qla82xx_wr_32(ha, 120586252UL, 0U);
#line 1598
  qla82xx_wr_32(ha, 121634824UL, 0U);
#line 1599
  qla82xx_wr_32(ha, 121634828UL, 0U);
#line 1600
  return (0);
}
}
#line 1604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_pci_mem_write_2M(struct qla_hw_data *ha , u64 off , void *data ,
                                    int size ) 
{ 
  int i ;
  int j ;
  int ret ;
  int loop ;
  int sz[2U] ;
  int off0 ;
  int scale ;
  int shift_amount ;
  int startword ;
  uint32_t temp ;
  uint64_t off8 ;
  uint64_t mem_crb ;
  uint64_t tmpw ;
  uint64_t word[2U] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1607
  ret = 0;
#line 1610
  word[0] = 0ULL;
#line 1610
  word[1] = 0ULL;
#line 1615
  if (off > 12884901887ULL && off <= 12952010751ULL) {
#line 1616
    mem_crb = 131072000ULL;
  } else {
#line 1618
    mem_crb = 102760448ULL;
#line 1619
    tmp___0 = qla82xx_pci_mem_bound_check(ha, off, size);
#line 1619
    if (tmp___0 == 0UL) {
#line 1620
      tmp = qla82xx_pci_mem_write_direct(ha, off, data, size);
#line 1620
      return (tmp);
    } else {

    }
  }
#line 1624
  off0 = (int )off & 7;
#line 1625
  sz[0] = size < 8 - off0 ? size : 8 - off0;
#line 1626
  sz[1] = size - sz[0];
#line 1628
  off8 = off & 4294967280ULL;
#line 1629
  loop = (int )((unsigned int )((((off & 15ULL) + (u64 )size) - 1ULL) >> 4) + 1U);
#line 1630
  shift_amount = 4;
#line 1631
  scale = 2;
#line 1632
  startword = (int )((off & 15ULL) / 8ULL);
#line 1634
  i = 0;
#line 1634
  goto ldv_43778;
  ldv_43777: 
#line 1635
  tmp___1 = qla82xx_pci_mem_read_2M(ha, (uint64_t )(i << shift_amount) + off8, (void *)(& word) + (unsigned long )(i * scale),
                                    8);
#line 1635
  if (tmp___1 != 0) {
#line 1637
    return (-1);
  } else {

  }
#line 1634
  i = i + 1;
  ldv_43778: ;
#line 1634
  if (i < loop) {
#line 1636
    goto ldv_43777;
  } else {

  }

#line 1640
  switch (size) {
  case 1: 
#line 1642
  tmpw = (uint64_t )*((uint8_t *)data);
#line 1643
  goto ldv_43781;
  case 2: 
#line 1645
  tmpw = (uint64_t )*((uint16_t *)data);
#line 1646
  goto ldv_43781;
  case 4: 
#line 1648
  tmpw = (uint64_t )*((uint32_t *)data);
#line 1649
  goto ldv_43781;
  case 8: ;
  default: 
#line 1652
  tmpw = *((uint64_t *)data);
#line 1653
  goto ldv_43781;
  }
  ldv_43781: ;
#line 1656
  if (sz[0] == 8) {
#line 1657
    word[startword] = tmpw;
  } else {
#line 1659
    word[startword] = word[startword] & ~ (~ (0xffffffffffffffffULL << sz[0] * 8) << off0 * 8);
#line 1661
    word[startword] = word[startword] | (tmpw << off0 * 8);
  }
#line 1663
  if (sz[1] != 0) {
#line 1664
    word[startword + 1] = word[startword + 1] & ~ (0xffffffffffffffffULL << sz[1] * 8);
#line 1665
    word[startword + 1] = word[startword + 1] | (tmpw >> sz[0] * 8);
  } else {

  }
#line 1668
  i = 0;
#line 1668
  goto ldv_43792;
  ldv_43791: 
#line 1669
  temp = (uint32_t )(i << shift_amount) + (uint32_t )off8;
#line 1670
  qla82xx_wr_32(ha, (ulong )(mem_crb + 148ULL), temp);
#line 1671
  temp = 0U;
#line 1672
  qla82xx_wr_32(ha, (ulong )(mem_crb + 152ULL), temp);
#line 1673
  temp = (uint32_t )word[i * scale];
#line 1674
  qla82xx_wr_32(ha, (ulong )(mem_crb + 160ULL), temp);
#line 1675
  temp = (uint32_t )(word[i * scale] >> 32);
#line 1676
  qla82xx_wr_32(ha, (ulong )(mem_crb + 164ULL), temp);
#line 1677
  temp = (uint32_t )word[i * scale + 1];
#line 1678
  qla82xx_wr_32(ha, (ulong )(mem_crb + 176ULL), temp);
#line 1680
  temp = (uint32_t )(word[i * scale + 1] >> 32);
#line 1681
  qla82xx_wr_32(ha, (ulong )(mem_crb + 180ULL), temp);
#line 1684
  temp = 6U;
#line 1685
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1686
  temp = 7U;
#line 1687
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1689
  j = 0;
#line 1689
  goto ldv_43788;
  ldv_43787: 
#line 1690
  tmp___2 = qla82xx_rd_32(ha, (ulong )(mem_crb + 144ULL));
#line 1690
  temp = (uint32_t )tmp___2;
#line 1691
  if ((temp & 8U) == 0U) {
#line 1692
    goto ldv_43786;
  } else {

  }
#line 1689
  j = j + 1;
  ldv_43788: ;
#line 1689
  if (j <= 999) {
#line 1691
    goto ldv_43787;
  } else {

  }
  ldv_43786: ;
#line 1695
  if (j > 999) {
#line 1696
    tmp___3 = __printk_ratelimit("qla82xx_pci_mem_write_2M");
#line 1696
    if (tmp___3 != 0) {
#line 1697
      dev_err((struct device  const  *)(& (ha->pdev)->dev), "failed to write through agent.\n");
    } else {

    }
#line 1699
    ret = -1;
#line 1700
    goto ldv_43790;
  } else {

  }
#line 1668
  i = i + 1;
  ldv_43792: ;
#line 1668
  if (i < loop) {
#line 1670
    goto ldv_43791;
  } else {

  }
  ldv_43790: ;
#line 1704
  return (ret);
}
}
#line 1708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_fw_load_from_flash(struct qla_hw_data *ha ) 
{ 
  int i ;
  long size ;
  long flashaddr ;
  long memaddr ;
  u64 data ;
  u32 high ;
  u32 low ;
  int tmp ;
  int tmp___0 ;

  {
#line 1711
  size = 0L;
#line 1712
  flashaddr = (long )(ha->flt_region_bootload << 2);
#line 1713
  memaddr = 65536L;
#line 1716
  size = 122880L;
#line 1718
  i = 0;
#line 1718
  goto ldv_43804;
  ldv_43803: 
#line 1719
  tmp = qla82xx_rom_fast_read(ha, (int )flashaddr, (int *)(& low));
#line 1719
  if (tmp != 0) {
#line 1721
    return (-1);
  } else {
#line 1719
    tmp___0 = qla82xx_rom_fast_read(ha, (int )((unsigned int )flashaddr + 4U), (int *)(& high));
#line 1719
    if (tmp___0 != 0) {
#line 1721
      return (-1);
    } else {

    }
  }
#line 1723
  data = ((unsigned long long )high << 32) | (unsigned long long )low;
#line 1724
  qla82xx_pci_mem_write_2M(ha, (u64 )memaddr, (void *)(& data), 8);
#line 1725
  flashaddr = flashaddr + 8L;
#line 1726
  memaddr = memaddr + 8L;
#line 1728
  if (((unsigned int )i & 4095U) == 0U) {
#line 1729
    msleep(1U);
  } else {

  }
#line 1718
  i = i + 1;
  ldv_43804: ;
#line 1718
  if ((long )i < size) {
#line 1720
    goto ldv_43803;
  } else {

  }
#line 1731
  __const_udelay(429500UL);
#line 1732
  ldv_read_lock(& ha->hw_lock);
#line 1733
  qla82xx_wr_32(ha, 118489112UL, 4128U);
#line 1734
  qla82xx_wr_32(ha, 154140680UL, 8388638U);
#line 1735
  ldv_read_unlock(& ha->hw_lock);
#line 1736
  return (0);
}
}
#line 1740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_pci_mem_read_2M(struct qla_hw_data *ha , u64 off , void *data , int size ) 
{ 
  int i ;
  int j ;
  int k ;
  int start ;
  int end ;
  int loop ;
  int sz[2U] ;
  int off0[2U] ;
  int shift_amount ;
  uint32_t temp ;
  uint64_t off8 ;
  uint64_t val ;
  uint64_t mem_crb ;
  uint64_t word[2U] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1743
  j = 0;
#line 1746
  word[0] = 0ULL;
#line 1746
  word[1] = 0ULL;
#line 1752
  if (off > 12884901887ULL && off <= 12952010751ULL) {
#line 1753
    mem_crb = 131072000ULL;
  } else {
#line 1755
    mem_crb = 102760448ULL;
#line 1756
    tmp___0 = qla82xx_pci_mem_bound_check(ha, off, size);
#line 1756
    if (tmp___0 == 0UL) {
#line 1757
      tmp = qla82xx_pci_mem_read_direct(ha, off, data, size);
#line 1757
      return (tmp);
    } else {

    }
  }
#line 1761
  off8 = off & 4294967280ULL;
#line 1762
  off0[0] = (int )off & 15;
#line 1763
  sz[0] = size < 16 - off0[0] ? size : 16 - off0[0];
#line 1764
  shift_amount = 4;
#line 1765
  loop = (((off0[0] + size) + -1) >> shift_amount) + 1;
#line 1766
  off0[1] = 0;
#line 1767
  sz[1] = size - sz[0];
#line 1769
  i = 0;
#line 1769
  goto ldv_43835;
  ldv_43834: 
#line 1770
  temp = (uint32_t )(i << shift_amount) + (uint32_t )off8;
#line 1771
  qla82xx_wr_32(ha, (ulong )(mem_crb + 148ULL), temp);
#line 1772
  temp = 0U;
#line 1773
  qla82xx_wr_32(ha, (ulong )(mem_crb + 152ULL), temp);
#line 1774
  temp = 2U;
#line 1775
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1776
  temp = 3U;
#line 1777
  qla82xx_wr_32(ha, (ulong )(mem_crb + 144ULL), temp);
#line 1779
  j = 0;
#line 1779
  goto ldv_43828;
  ldv_43827: 
#line 1780
  tmp___1 = qla82xx_rd_32(ha, (ulong )(mem_crb + 144ULL));
#line 1780
  temp = (uint32_t )tmp___1;
#line 1781
  if ((temp & 8U) == 0U) {
#line 1782
    goto ldv_43826;
  } else {

  }
#line 1779
  j = j + 1;
  ldv_43828: ;
#line 1779
  if (j <= 999) {
#line 1781
    goto ldv_43827;
  } else {

  }
  ldv_43826: ;
#line 1785
  if (j > 999) {
#line 1786
    tmp___2 = __printk_ratelimit("qla82xx_pci_mem_read_2M");
#line 1786
    if (tmp___2 != 0) {
#line 1787
      dev_err((struct device  const  *)(& (ha->pdev)->dev), "failed to read through agent.\n");
    } else {

    }
#line 1789
    goto ldv_43830;
  } else {

  }
#line 1792
  start = off0[i] >> 2;
#line 1793
  end = ((off0[i] + sz[i]) + -1) >> 2;
#line 1794
  k = start;
#line 1794
  goto ldv_43832;
  ldv_43831: 
#line 1795
  tmp___3 = qla82xx_rd_32(ha, (ulong )((uint64_t )((k + 42) * 4) + mem_crb));
#line 1795
  temp = (uint32_t )tmp___3;
#line 1797
  word[i] = word[i] | ((unsigned long long )temp << (k & 1) * 32);
#line 1794
  k = k + 1;
  ldv_43832: ;
#line 1794
  if (k <= end) {
#line 1796
    goto ldv_43831;
  } else {

  }
#line 1769
  i = i + 1;
  ldv_43835: ;
#line 1769
  if (i < loop) {
#line 1771
    goto ldv_43834;
  } else {

  }
  ldv_43830: ;
#line 1801
  if (j > 999) {
#line 1802
    return (-1);
  } else {

  }
#line 1804
  if ((off0[0] & 7) == 0) {
#line 1805
    val = word[0];
  } else {
#line 1807
    val = ((word[0] >> off0[0] * 8) & ~ (0xffffffffffffffffULL << sz[0] * 8)) | ((word[1] & ~ (0xffffffffffffffffULL << sz[1] * 8)) << sz[0] * 8);
  }
#line 1811
  switch (size) {
  case 1: 
#line 1813
  *((uint8_t *)data) = (uint8_t )val;
#line 1814
  goto ldv_43837;
  case 2: 
#line 1816
  *((uint16_t *)data) = (uint16_t )val;
#line 1817
  goto ldv_43837;
  case 4: 
#line 1819
  *((uint32_t *)data) = (uint32_t )val;
#line 1820
  goto ldv_43837;
  case 8: 
#line 1822
  *((uint64_t *)data) = val;
#line 1823
  goto ldv_43837;
  }
  ldv_43837: ;
#line 1825
  return (0);
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static struct qla82xx_uri_table_desc *qla82xx_get_table_desc(u8 const   *unirom ,
                                                             int section ) 
{ 
  uint32_t i ;
  struct qla82xx_uri_table_desc *directory ;
  __le32 offset ;
  __le32 tab_type ;
  __le32 entries ;

  {
#line 1833
  directory = (struct qla82xx_uri_table_desc *)unirom;
#line 1837
  entries = directory->num_entries;
#line 1839
  i = 0U;
#line 1839
  goto ldv_43851;
  ldv_43850: 
#line 1840
  offset = directory->findex + directory->entry_size * i;
#line 1842
  tab_type = *((u32 *)unirom + ((unsigned long )offset + 8UL));
#line 1844
  if ((__le32 )section == tab_type) {
#line 1845
    return ((struct qla82xx_uri_table_desc *)unirom + (unsigned long )offset);
  } else {

  }
#line 1839
  i = i + 1U;
  ldv_43851: ;
#line 1839
  if (i < entries) {
#line 1841
    goto ldv_43850;
  } else {

  }

#line 1848
  return ((struct qla82xx_uri_table_desc *)0);
}
}
#line 1852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static struct qla82xx_uri_data_desc *qla82xx_get_data_desc(struct qla_hw_data *ha ,
                                                           u32 section , u32 idx_offset ) 
{ 
  u8 const   *unirom ;
  int idx ;
  struct qla82xx_uri_table_desc *tab_desc ;
  __le32 offset ;

  {
#line 1855
  unirom = ((ha->hablob)->fw)->data;
#line 1856
  idx = *((int *)unirom + ((unsigned long )ha->file_prd_off + (unsigned long )idx_offset));
#line 1857
  tab_desc = (struct qla82xx_uri_table_desc *)0;
#line 1860
  tab_desc = qla82xx_get_table_desc(unirom, (int )section);
#line 1861
  if ((unsigned long )tab_desc == (unsigned long )((struct qla82xx_uri_table_desc *)0)) {
#line 1862
    return ((struct qla82xx_uri_data_desc *)0);
  } else {

  }
#line 1864
  offset = tab_desc->findex + tab_desc->entry_size * (uint32_t )idx;
#line 1867
  return ((struct qla82xx_uri_data_desc *)unirom + (unsigned long )offset);
}
}
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static u8 *qla82xx_get_bootld_offset(struct qla_hw_data *ha ) 
{ 
  u32 offset ;
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1873
  offset = 65536U;
#line 1874
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1876
  if ((unsigned int )ha->fw_type == 3U) {
#line 1877
    uri_desc = qla82xx_get_data_desc(ha, 6U, 27U);
#line 1879
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1880
      offset = uri_desc->findex;
    } else {

    }
  } else {

  }
#line 1883
  return ((u8 *)((ha->hablob)->fw)->data + (unsigned long )offset);
}
}
#line 1887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static __le32 qla82xx_get_fw_size(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1889
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1891
  if ((unsigned int )ha->fw_type == 3U) {
#line 1892
    uri_desc = qla82xx_get_data_desc(ha, 7U, 29U);
#line 1894
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1895
      return (uri_desc->size);
    } else {

    }
  } else {

  }
#line 1898
  return (*((u32 *)((ha->hablob)->fw)->data + 4097036U));
}
}
#line 1902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static u8 *qla82xx_get_fw_offs(struct qla_hw_data *ha ) 
{ 
  u32 offset ;
  struct qla82xx_uri_data_desc *uri_desc ;

  {
#line 1904
  offset = 1048576U;
#line 1905
  uri_desc = (struct qla82xx_uri_data_desc *)0;
#line 1907
  if ((unsigned int )ha->fw_type == 3U) {
#line 1908
    uri_desc = qla82xx_get_data_desc(ha, 7U, 29U);
#line 1910
    if ((unsigned long )uri_desc != (unsigned long )((struct qla82xx_uri_data_desc *)0)) {
#line 1911
      offset = uri_desc->findex;
    } else {

    }
  } else {

  }
#line 1914
  return ((u8 *)((ha->hablob)->fw)->data + (unsigned long )offset);
}
}
#line 1918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_pci_region_offset(struct pci_dev *pdev , int region ) 
{ 
  unsigned long val ;
  u32 control ;

  {
#line 1920
  val = 0UL;
#line 1923
  switch (region) {
  case 0: 
#line 1925
  val = 0UL;
#line 1926
  goto ldv_43883;
  case 1: 
#line 1928
  pci_read_config_dword((struct pci_dev  const  *)pdev, 68, & control);
#line 1929
  val = (unsigned long )(control + 8192U);
#line 1930
  goto ldv_43883;
  }
  ldv_43883: ;
#line 1932
  return ((int )val);
}
}
#line 1937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_iospace_config(struct qla_hw_data *ha ) 
{ 
  uint32_t len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint8_t tmp___2 ;

  {
#line 1939
  len = 0U;
#line 1941
  tmp = pci_request_regions(ha->pdev, "qla2xxx");
#line 1941
  if (tmp != 0) {
#line 1942
    ql_log_pci(0U, ha->pdev, 12, "Failed to reserver selected regions.\n");
#line 1944
    goto iospace_error_exit;
  } else {

  }
#line 1948
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 1949
    ql_log_pci(0U, ha->pdev, 13, "Region #0 not an MMIO resource, aborting.\n");
#line 1951
    goto iospace_error_exit;
  } else {

  }
#line 1954
  len = (ha->pdev)->resource[0].start != 0ULL || (ha->pdev)->resource[0].end != (ha->pdev)->resource[0].start ? ((uint32_t )(ha->pdev)->resource[0].end - (uint32_t )(ha->pdev)->resource[0].start) + 1U : 0U;
#line 1955
  tmp___0 = ioremap((ha->pdev)->resource[0].start, (unsigned long )len);
#line 1955
  ha->nx_pcibase = (unsigned long )tmp___0;
#line 1957
  if (ha->nx_pcibase == 0UL) {
#line 1958
    ql_log_pci(0U, ha->pdev, 14, "Cannot remap pcibase MMIO, aborting.\n");
#line 1960
    goto iospace_error_exit;
  } else {

  }
#line 1964
  if ((ha->device_type & 262144U) != 0U) {
#line 1965
    ha->iobase = (device_reg_t *)ha->nx_pcibase;
  } else
#line 1967
  if ((ha->device_type & 16384U) != 0U) {
#line 1968
    ha->iobase = (device_reg_t *)(((unsigned long )((ha->pdev)->devfn << 11) + ha->nx_pcibase) + 770048UL);
  } else {

  }
#line 1973
  if (ql2xdbwr == 0) {
#line 1974
    tmp___1 = ioremap((ha->pdev)->resource[4].start + (resource_size_t )((ha->pdev)->devfn << 12),
                      4UL);
#line 1974
    ha->nxdb_wr_ptr = (unsigned long )tmp___1;
#line 1977
    if (ha->nxdb_wr_ptr == 0UL) {
#line 1978
      ql_log_pci(0U, ha->pdev, 15, "Cannot remap MMIO, aborting.\n");
#line 1980
      goto iospace_error_exit;
    } else {

    }
#line 1986
    ha->nxdb_rd_ptr = (uint8_t *)(((unsigned long )((ha->pdev)->devfn * 8U) + ha->nx_pcibase) + 524288UL);
  } else {
#line 1989
    ha->nxdb_wr_ptr = (ha->pdev)->devfn == 6U ? 136323512UL : 136323516UL;
  }
#line 1994
  tmp___2 = 1U;
#line 1994
  ha->max_rsp_queues = tmp___2;
#line 1994
  ha->max_req_queues = tmp___2;
#line 1995
  ha->msix_count = (unsigned int )((uint16_t )ha->max_rsp_queues) + 1U;
#line 1996
  ql_dbg_pci(1048576U, ha->pdev, 49158, "nx_pci_base=%p iobase=%p max_req_queues=%d msix_count=%d.\n",
             (void *)ha->nx_pcibase, ha->iobase, (int )ha->max_req_queues, (int )ha->msix_count);
#line 2001
  ql_dbg_pci(1073741824U, ha->pdev, 16, "nx_pci_base=%p iobase=%p max_req_queues=%d msix_count=%d.\n",
             (void *)ha->nx_pcibase, ha->iobase, (int )ha->max_req_queues, (int )ha->msix_count);
#line 2006
  return (0);
  iospace_error_exit: ;
#line 2009
  return (-12);
}
}
#line 2023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_pci_config(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int ret ;

  {
#line 2025
  ha = vha->hw;
#line 2028
  pci_set_master(ha->pdev);
#line 2029
  ret = pci_set_mwi(ha->pdev);
#line 2030
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 2031
  ql_dbg(1073741824U, vha, 67, "Chip revision:%d.\n", (int )ha->chip_revision);
#line 2034
  return (0);
}
}
#line 2044 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_reset_chip(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 2046
  ha = vha->hw;
#line 2047
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 2048
  return;
}
}
#line 2050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_82xx *reg ;
  struct init_cb_81xx *icb ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 2052
  ha = vha->hw;
#line 2053
  reg = & (ha->iobase)->isp82;
#line 2055
  req = *(ha->req_q_map);
#line 2056
  rsp = *(ha->rsp_q_map);
#line 2059
  icb = (struct init_cb_81xx *)ha->init_cb;
#line 2060
  icb->request_q_outpointer = 0U;
#line 2061
  icb->response_q_inpointer = 0U;
#line 2062
  icb->request_q_length = req->length;
#line 2063
  icb->response_q_length = rsp->length;
#line 2064
  icb->request_q_address[0] = (unsigned int )req->dma;
#line 2065
  icb->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 2066
  icb->response_q_address[0] = (unsigned int )rsp->dma;
#line 2067
  icb->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 2069
  writel(0U, (void volatile   *)(& reg->req_q_out));
#line 2070
  writel(0U, (void volatile   *)(& reg->rsp_q_in));
#line 2071
  writel(0U, (void volatile   *)(& reg->rsp_q_out));
#line 2072
  return;
}
}
#line 2075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_fw_load_from_blob(struct qla_hw_data *ha ) 
{ 
  u64 *ptr64 ;
  u32 i ;
  u32 flashaddr ;
  u32 size ;
  __le64 data ;
  u8 *tmp ;
  int tmp___0 ;
  __le32 tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;

  {
#line 2081
  size = 122880U;
#line 2083
  tmp = qla82xx_get_bootld_offset(ha);
#line 2083
  ptr64 = (u64 *)tmp;
#line 2084
  flashaddr = 65536U;
#line 2086
  i = 0U;
#line 2086
  goto ldv_43916;
  ldv_43915: 
#line 2087
  data = *(ptr64 + (unsigned long )i);
#line 2088
  tmp___0 = qla82xx_pci_mem_write_2M(ha, (u64 )flashaddr, (void *)(& data), 8);
#line 2088
  if (tmp___0 != 0) {
#line 2089
    return (-5);
  } else {

  }
#line 2090
  flashaddr = flashaddr + 8U;
#line 2086
  i = i + 1U;
  ldv_43916: ;
#line 2086
  if (i < size) {
#line 2088
    goto ldv_43915;
  } else {

  }
#line 2093
  flashaddr = 274432U;
#line 2094
  tmp___1 = qla82xx_get_fw_size(ha);
#line 2094
  size = tmp___1 / 8U;
#line 2095
  tmp___2 = qla82xx_get_fw_offs(ha);
#line 2095
  ptr64 = (u64 *)tmp___2;
#line 2097
  i = 0U;
#line 2097
  goto ldv_43919;
  ldv_43918: 
#line 2098
  data = *(ptr64 + (unsigned long )i);
#line 2100
  tmp___3 = qla82xx_pci_mem_write_2M(ha, (u64 )flashaddr, (void *)(& data), 8);
#line 2100
  if (tmp___3 != 0) {
#line 2101
    return (-5);
  } else {

  }
#line 2102
  flashaddr = flashaddr + 8U;
#line 2097
  i = i + 1U;
  ldv_43919: ;
#line 2097
  if (i < size) {
#line 2099
    goto ldv_43918;
  } else {

  }
#line 2104
  __const_udelay(429500UL);
#line 2111
  qla82xx_wr_32(ha, 136323580UL, 305419896U);
#line 2113
  ldv_read_lock(& ha->hw_lock);
#line 2114
  qla82xx_wr_32(ha, 118489112UL, 4128U);
#line 2115
  qla82xx_wr_32(ha, 154140680UL, 8388638U);
#line 2116
  ldv_read_unlock(& ha->hw_lock);
#line 2117
  return (0);
}
}
#line 2121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_set_product_offset(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_uri_table_desc *ptab_desc ;
  uint8_t const   *unirom ;
  uint32_t i ;
  __le32 entries ;
  __le32 flags ;
  __le32 file_chiprev ;
  __le32 offset ;
  uint8_t chiprev ;
  int mn_present ;
  uint32_t flagbit ;

  {
#line 2123
  ptab_desc = (struct qla82xx_uri_table_desc *)0;
#line 2124
  unirom = (uint8_t const   *)((ha->hablob)->fw)->data;
#line 2128
  chiprev = (uint8_t )ha->chip_revision;
#line 2130
  mn_present = 0;
#line 2133
  ptab_desc = qla82xx_get_table_desc(unirom, 0);
#line 2135
  if ((unsigned long )ptab_desc == (unsigned long )((struct qla82xx_uri_table_desc *)0)) {
#line 2136
    return (-1);
  } else {

  }
#line 2138
  entries = ptab_desc->num_entries;
#line 2140
  i = 0U;
#line 2140
  goto ldv_43935;
  ldv_43934: 
#line 2141
  offset = ptab_desc->findex + ptab_desc->entry_size * i;
#line 2143
  flags = (unsigned int )*((int *)unirom + ((unsigned long )offset + 11UL));
#line 2145
  file_chiprev = (unsigned int )*((int *)unirom + ((unsigned long )offset + 10UL));
#line 2148
  flagbit = mn_present != 0 ? 1U : 2U;
#line 2150
  if ((__le32 )chiprev == file_chiprev && (int )((unsigned long long )flags >> (int )flagbit) & 1) {
#line 2151
    ha->file_prd_off = offset;
#line 2152
    return (0);
  } else {

  }
#line 2140
  i = i + 1U;
  ldv_43935: ;
#line 2140
  if (i < entries) {
#line 2142
    goto ldv_43934;
  } else {

  }

#line 2155
  return (-1);
}
}
#line 2159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_validate_firmware_blob(scsi_qla_host_t *vha , uint8_t fw_type ) 
{ 
  __le32 val ;
  uint32_t min_size ;
  struct qla_hw_data *ha ;
  struct firmware  const  *fw ;
  int tmp ;

  {
#line 2163
  ha = vha->hw;
#line 2164
  fw = (ha->hablob)->fw;
#line 2166
  ha->fw_type = fw_type;
#line 2168
  if ((unsigned int )fw_type == 3U) {
#line 2169
    tmp = qla82xx_set_product_offset(ha);
#line 2169
    if (tmp != 0) {
#line 2170
      return (-22);
    } else {

    }
#line 2172
    min_size = 819200U;
  } else {
#line 2174
    val = *((u32 *)fw->data + 16680U);
#line 2175
    if (val != 305419896U) {
#line 2176
      return (-22);
    } else {

    }
#line 2178
    min_size = 4194303U;
  }
#line 2181
  if ((unsigned long )fw->size < (unsigned long )min_size) {
#line 2182
    return (-22);
  } else {

  }
#line 2183
  return (0);
}
}
#line 2187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_check_cmdpeg_state(struct qla_hw_data *ha ) 
{ 
  u32 val ;
  int retries ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2189
  val = 0U;
#line 2190
  retries = 60;
#line 2191
  tmp = pci_get_drvdata(ha->pdev);
#line 2191
  vha = (scsi_qla_host_t *)tmp;
  ldv_43956: 
#line 2194
  ldv_read_lock(& ha->hw_lock);
#line 2195
  tmp___0 = qla82xx_rd_32(ha, 136323664UL);
#line 2195
  val = (u32 )tmp___0;
#line 2196
  ldv_read_unlock(& ha->hw_lock);
#line 2198
  switch (val) {
  case 65281U: ;
  case 61455U: ;
#line 2201
  return (0);
  case 65535U: ;
#line 2203
  goto ldv_43954;
  default: ;
#line 2205
  goto ldv_43954;
  }
  ldv_43954: 
#line 2207
  ql_log(2U, vha, 168, "CRB_CMDPEG_STATE: 0x%x and retries:0x%x.\n", val, retries);
#line 2211
  msleep(500U);
#line 2213
  retries = retries - 1;
#line 2213
  if (retries != 0) {
#line 2215
    goto ldv_43956;
  } else {

  }
#line 2215
  ql_log(0U, vha, 169, "Cmd Peg initialization failed: 0x%x.\n", val);
#line 2218
  tmp___1 = qla82xx_rd_32(ha, 154140764UL);
#line 2218
  val = (u32 )tmp___1;
#line 2219
  ldv_read_lock(& ha->hw_lock);
#line 2220
  qla82xx_wr_32(ha, 136323664UL, 65535U);
#line 2221
  ldv_read_unlock(& ha->hw_lock);
#line 2222
  return (258);
}
}
#line 2226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_check_rcvpeg_state(struct qla_hw_data *ha ) 
{ 
  u32 val ;
  int retries ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2228
  val = 0U;
#line 2229
  retries = 60;
#line 2230
  tmp = pci_get_drvdata(ha->pdev);
#line 2230
  vha = (scsi_qla_host_t *)tmp;
  ldv_43969: 
#line 2233
  ldv_read_lock(& ha->hw_lock);
#line 2234
  tmp___0 = qla82xx_rd_32(ha, 136323900UL);
#line 2234
  val = (u32 )tmp___0;
#line 2235
  ldv_read_unlock(& ha->hw_lock);
#line 2237
  switch (val) {
  case 65281U: ;
  case 61455U: ;
#line 2240
  return (0);
  case 65535U: ;
#line 2242
  goto ldv_43967;
  default: ;
#line 2244
  goto ldv_43967;
  }
  ldv_43967: 
#line 2246
  ql_log(2U, vha, 171, "CRB_RCVPEG_STATE: 0x%x and retries: 0x%x.\n", val, retries);
#line 2250
  msleep(500U);
#line 2252
  retries = retries - 1;
#line 2252
  if (retries != 0) {
#line 2254
    goto ldv_43969;
  } else {

  }
#line 2254
  ql_log(0U, vha, 172, "Rcv Peg initializatin failed: 0x%x.\n", val);
#line 2256
  ldv_read_lock(& ha->hw_lock);
#line 2257
  qla82xx_wr_32(ha, 136323900UL, 65535U);
#line 2258
  ldv_read_unlock(& ha->hw_lock);
#line 2259
  return (258);
}
}
#line 2263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static struct qla82xx_legacy_intr_set legacy_intr[8U]  = 
#line 2263
  {      {128U, 101777688U, 101777704U, 101789696U}, 
        {256U, 101777760U, 101777776U, 101789700U}, 
        {512U, 101777764U, 101777780U, 101789704U}, 
        {1024U, 101777768U, 101777784U, 101789708U}, 
        {2048U, 101778272U, 101778288U, 101789712U}, 
        {4096U, 101778276U, 101778292U, 101789716U}, 
        {8192U, 101778280U, 101778296U, 101789720U}, 
        {16384U, 101778284U, 101778300U, 101789724U}};
#line 2272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_mbx_completion(scsi_qla_host_t *vha , uint16_t mb0 ) 
{ 
  uint16_t cnt ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_82xx *reg ;

  {
#line 2276
  ha = vha->hw;
#line 2277
  reg = & (ha->iobase)->isp82;
#line 2278
  wptr = (uint16_t *)(& reg->mailbox_out) + 1UL;
#line 2281
  ha->flags.mbox_int = 1U;
#line 2282
  ha->mailbox_out[0] = mb0;
#line 2284
  cnt = 1U;
#line 2284
  goto ldv_43981;
  ldv_43980: 
#line 2285
  ha->mailbox_out[(int )cnt] = readw((void const volatile   *)wptr);
#line 2286
  wptr = wptr + 1;
#line 2284
  cnt = (uint16_t )((int )cnt + 1);
  ldv_43981: ;
#line 2284
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 2286
    goto ldv_43980;
  } else {

  }

#line 2289
  if ((unsigned long )ha->mcp == (unsigned long )((mbx_cmd_t *)0)) {
#line 2290
    ql_dbg(33554432U, vha, 20563, "MBX pointer OLD_ERROR.\n");
  } else {

  }
#line 2292
  return;
}
}
#line 2305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
irqreturn_t qla82xx_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  int status1 ;
  unsigned long flags ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 2311
  status = 0;
#line 2311
  status1 = 0;
#line 2314
  stat = 0U;
#line 2317
  rsp = (struct rsp_que *)dev_id;
#line 2318
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2319
    ql_log(2U, (scsi_qla_host_t *)0, 45139, "%s: NULL response queue pointer.\n",
           "qla82xx_intr_handler");
#line 2321
    return (0);
  } else {

  }
#line 2323
  ha = rsp->hw;
#line 2325
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2326
    status = qla82xx_rd_32(ha, 101777664UL);
#line 2327
    if ((ha->nx_legacy_intr.int_vec_bit & (uint32_t )status) == 0U) {
#line 2328
      return (0);
    } else {

    }
#line 2330
    status1 = qla82xx_rd_32(ha, 101785708UL);
#line 2331
    if ((status1 & 768) != 512) {
#line 2332
      return (0);
    } else {

    }
  } else {

  }
#line 2336
  qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_status_reg, 4294967295U);
#line 2339
  qla82xx_rd_32(ha, 101777664UL);
#line 2340
  qla82xx_rd_32(ha, 101777664UL);
#line 2342
  reg = & (ha->iobase)->isp82;
#line 2344
  tmp = spinlock_check(& ha->hardware_lock);
#line 2344
  flags = _raw_spin_lock_irqsave(tmp);
#line 2345
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2345
  vha = (scsi_qla_host_t *)tmp___0;
#line 2346
  iter = 1UL;
#line 2346
  goto ldv_44010;
  ldv_44009: 
#line 2348
  tmp___1 = readl((void const volatile   *)(& reg->host_int));
#line 2348
  if (tmp___1 != 0U) {
#line 2349
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2351
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2356
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2357
    status = status | 1;
#line 2358
    goto ldv_44005;
    case 18U: 
#line 2360
    mb[0] = (unsigned short )(stat >> 16);
#line 2361
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2362
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2363
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2364
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2365
    goto ldv_44005;
    case 19U: 
#line 2367
    qla24xx_process_response_queue(vha, rsp);
#line 2368
    goto ldv_44005;
    default: 
#line 2370
    ql_dbg(33554432U, vha, 20564, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 2373
    goto ldv_44005;
    }
    ldv_44005: ;
  } else {

  }
#line 2376
  writel(0U, (void volatile   *)(& reg->host_int));
  ldv_44010: 
#line 2346
  tmp___2 = iter;
#line 2346
  iter = iter - 1UL;
#line 2346
  if (tmp___2 != 0UL) {
#line 2348
    goto ldv_44009;
  } else {

  }
#line 2379
  qla2x00_handle_mbx_completion(ha, status);
#line 2380
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2382
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 2383
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 64511U);
  } else {

  }
#line 2385
  return (1);
}
}
#line 2389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
irqreturn_t qla82xx_msix_default(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  unsigned long flags ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2395
  status = 0;
#line 2397
  stat = 0U;
#line 2400
  rsp = (struct rsp_que *)dev_id;
#line 2401
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2402
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_msix_default");
#line 2404
    return (0);
  } else {

  }
#line 2406
  ha = rsp->hw;
#line 2408
  reg = & (ha->iobase)->isp82;
#line 2410
  tmp = spinlock_check(& ha->hardware_lock);
#line 2410
  flags = _raw_spin_lock_irqsave(tmp);
#line 2411
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2411
  vha = (scsi_qla_host_t *)tmp___0;
#line 2413
  tmp___1 = readl((void const volatile   *)(& reg->host_int));
#line 2413
  if (tmp___1 != 0U) {
#line 2414
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2416
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2421
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2422
    status = status | 1;
#line 2423
    goto ldv_44032;
    case 18U: 
#line 2425
    mb[0] = (unsigned short )(stat >> 16);
#line 2426
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2427
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2428
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2429
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2430
    goto ldv_44032;
    case 19U: 
#line 2432
    qla24xx_process_response_queue(vha, rsp);
#line 2433
    goto ldv_44032;
    default: 
#line 2435
    ql_dbg(33554432U, vha, 20545, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 2438
    goto ldv_44032;
    }
    ldv_44032: ;
  } else {

  }
#line 2441
  writel(0U, (void volatile   *)(& reg->host_int));
#line 2444
  qla2x00_handle_mbx_completion(ha, status);
#line 2445
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2447
  return (1);
}
}
#line 2451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
irqreturn_t qla82xx_msix_rsp_q(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 2459
  rsp = (struct rsp_que *)dev_id;
#line 2460
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2461
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_msix_rsp_q");
#line 2463
    return (0);
  } else {

  }
#line 2466
  ha = rsp->hw;
#line 2467
  reg = & (ha->iobase)->isp82;
#line 2468
  tmp = spinlock_check(& ha->hardware_lock);
#line 2468
  flags = _raw_spin_lock_irqsave(tmp);
#line 2469
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2469
  vha = (scsi_qla_host_t *)tmp___0;
#line 2470
  qla24xx_process_response_queue(vha, rsp);
#line 2471
  writel(0U, (void volatile   *)(& reg->host_int));
#line 2472
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2473
  return (1);
}
}
#line 2477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_poll(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2483
  status = 0;
#line 2488
  rsp = (struct rsp_que *)dev_id;
#line 2489
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 2490
    printk("\016%s(): NULL response queue pointer.\n", "qla82xx_poll");
#line 2492
    return;
  } else {

  }
#line 2494
  ha = rsp->hw;
#line 2496
  reg = & (ha->iobase)->isp82;
#line 2497
  tmp = spinlock_check(& ha->hardware_lock);
#line 2497
  flags = _raw_spin_lock_irqsave(tmp);
#line 2498
  tmp___0 = pci_get_drvdata(ha->pdev);
#line 2498
  vha = (scsi_qla_host_t *)tmp___0;
#line 2500
  tmp___1 = readl((void const volatile   *)(& reg->host_int));
#line 2500
  if (tmp___1 != 0U) {
#line 2501
    stat = readl((void const volatile   *)(& reg->host_status));
#line 2502
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 2507
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 2508
    status = status | 1;
#line 2509
    goto ldv_44069;
    case 18U: 
#line 2511
    mb[0] = (unsigned short )(stat >> 16);
#line 2512
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 2513
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 2514
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 2515
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 2516
    goto ldv_44069;
    case 19U: 
#line 2518
    qla24xx_process_response_queue(vha, rsp);
#line 2519
    goto ldv_44069;
    default: 
#line 2521
    ql_dbg(524288U, vha, 45075, "Unrecognized interrupt type (%d).\n", stat * 255U);
#line 2524
    goto ldv_44069;
    }
    ldv_44069: ;
  } else {

  }
#line 2527
  writel(0U, (void volatile   *)(& reg->host_int));
#line 2528
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2529
  return;
}
}
#line 2532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_enable_intrs(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2534
  tmp = pci_get_drvdata(ha->pdev);
#line 2534
  vha = (scsi_qla_host_t *)tmp;
#line 2535
  qla82xx_mbx_intr_enable(vha);
#line 2536
  spin_lock_irq(& ha->hardware_lock);
#line 2537
  if ((ha->device_type & 262144U) != 0U) {
#line 2538
    qla8044_wr_reg(ha, 14536UL, 0U);
  } else {
#line 2540
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 64511U);
  }
#line 2541
  spin_unlock_irq(& ha->hardware_lock);
#line 2542
  ha->interrupts_on = 1U;
#line 2543
  return;
}
}
#line 2546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_disable_intrs(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;

  {
#line 2548
  tmp = pci_get_drvdata(ha->pdev);
#line 2548
  vha = (scsi_qla_host_t *)tmp;
#line 2549
  qla82xx_mbx_intr_disable(vha);
#line 2550
  spin_lock_irq(& ha->hardware_lock);
#line 2551
  if ((ha->device_type & 262144U) != 0U) {
#line 2552
    qla8044_wr_reg(ha, 14536UL, 1U);
  } else {
#line 2554
    qla82xx_wr_32(ha, (ulong )ha->nx_legacy_intr.tgt_mask_reg, 1024U);
  }
#line 2555
  spin_unlock_irq(& ha->hardware_lock);
#line 2556
  ha->interrupts_on = 0U;
#line 2557
  return;
}
}
#line 2559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_init_flags(struct qla_hw_data *ha ) 
{ 
  struct qla82xx_legacy_intr_set *nx_legacy_intr ;
  struct lock_class_key __key ;

  {
#line 2564
  __rwlock_init(& ha->hw_lock, "&ha->hw_lock", & __key);
#line 2565
  ha->qdr_sn_window = -1;
#line 2566
  ha->ddr_mn_window = 4294967295U;
#line 2567
  ha->curr_window = 255U;
#line 2568
  ha->portnum = (unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U;
#line 2569
  nx_legacy_intr = (struct qla82xx_legacy_intr_set *)(& legacy_intr) + (unsigned long )ha->portnum;
#line 2570
  ha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;
#line 2571
  ha->nx_legacy_intr.tgt_status_reg = nx_legacy_intr->tgt_status_reg;
#line 2572
  ha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;
#line 2573
  ha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;
#line 2574
  return;
}
}
#line 2577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
__inline void qla82xx_set_idc_version(scsi_qla_host_t *vha ) 
{ 
  int idc_ver ;
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2581
  ha = vha->hw;
#line 2583
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2583
  drv_active = (uint32_t )tmp;
#line 2584
  if ((uint32_t )(1 << (int )ha->portnum * 4) == drv_active) {
#line 2585
    qla82xx_wr_32(ha, 136323444UL, 1U);
#line 2587
    ql_log(2U, vha, 45186, "IDC version updated to %d\n", 1);
  } else {
#line 2590
    idc_ver = qla82xx_rd_32(ha, 136323444UL);
#line 2591
    if (idc_ver != 1) {
#line 2592
      ql_log(2U, vha, 45187, "qla2xxx driver IDC version %d is not compatible with IDC version %d of the other drivers\n",
             1, idc_ver);
    } else {

    }
  }
#line 2595
  return;
}
}
#line 2600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_set_drv_active(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 2603
  ha = vha->hw;
#line 2605
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2605
  drv_active = (uint32_t )tmp;
#line 2608
  if (drv_active == 4294967295U) {
#line 2609
    qla82xx_wr_32(ha, 136323384UL, 0U);
#line 2611
    tmp___0 = qla82xx_rd_32(ha, 136323384UL);
#line 2611
    drv_active = (uint32_t )tmp___0;
  } else {

  }
#line 2613
  drv_active = (uint32_t )(1 << (int )ha->portnum * 4) | drv_active;
#line 2614
  qla82xx_wr_32(ha, 136323384UL, drv_active);
#line 2615
  return;
}
}
#line 2618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_clear_drv_active(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_active ;
  int tmp ;

  {
#line 2622
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 2622
  drv_active = (uint32_t )tmp;
#line 2623
  drv_active = (uint32_t )(~ (1 << (int )ha->portnum * 4)) & drv_active;
#line 2624
  qla82xx_wr_32(ha, 136323384UL, drv_active);
#line 2625
  return;
}
}
#line 2628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
__inline static int qla82xx_need_reset(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  int rval ;
  int tmp ;

  {
#line 2633
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 2634
    return (1);
  } else {
#line 2636
    tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2636
    drv_state = (uint32_t )tmp;
#line 2637
    rval = (int )((uint32_t )(1 << (int )ha->portnum * 4) & drv_state);
#line 2638
    return (rval);
  }
}
}
#line 2643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
__inline static void qla82xx_set_rst_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2646
  tmp = pci_get_drvdata(ha->pdev);
#line 2646
  vha = (scsi_qla_host_t *)tmp;
#line 2648
  tmp___0 = qla82xx_rd_32(ha, 136323396UL);
#line 2648
  drv_state = (uint32_t )tmp___0;
#line 2651
  if (drv_state == 4294967295U) {
#line 2652
    qla82xx_wr_32(ha, 136323396UL, 0U);
#line 2653
    tmp___1 = qla82xx_rd_32(ha, 136323396UL);
#line 2653
    drv_state = (uint32_t )tmp___1;
  } else {

  }
#line 2655
  drv_state = (uint32_t )(1 << (int )ha->portnum * 4) | drv_state;
#line 2656
  ql_dbg(1073741824U, vha, 187, "drv_state = 0x%08x.\n", drv_state);
#line 2658
  qla82xx_wr_32(ha, 136323396UL, drv_state);
#line 2659
  return;
}
}
#line 2662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
__inline static void qla82xx_clear_rst_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t drv_state ;
  int tmp ;

  {
#line 2666
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2666
  drv_state = (uint32_t )tmp;
#line 2667
  drv_state = (uint32_t )(~ (1 << (int )ha->portnum * 4)) & drv_state;
#line 2668
  qla82xx_wr_32(ha, 136323396UL, drv_state);
#line 2669
  return;
}
}
#line 2672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
__inline static void qla82xx_set_qsnt_ready(struct qla_hw_data *ha ) 
{ 
  uint32_t qsnt_state ;
  int tmp ;

  {
#line 2676
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2676
  qsnt_state = (uint32_t )tmp;
#line 2677
  qsnt_state = (uint32_t )(2 << (int )ha->portnum * 4) | qsnt_state;
#line 2678
  qla82xx_wr_32(ha, 136323396UL, qsnt_state);
#line 2679
  return;
}
}
#line 2682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_clear_qsnt_ready(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t qsnt_state ;
  int tmp ;

  {
#line 2684
  ha = vha->hw;
#line 2687
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 2687
  qsnt_state = (uint32_t )tmp;
#line 2688
  qsnt_state = (uint32_t )(~ (2 << (int )ha->portnum * 4)) & qsnt_state;
#line 2689
  qla82xx_wr_32(ha, 136323396UL, qsnt_state);
#line 2690
  return;
}
}
#line 2693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_load_fw(scsi_qla_host_t *vha ) 
{ 
  int rst ;
  struct fw_blob *blob ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  struct fw_blob *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2697
  ha = vha->hw;
#line 2699
  tmp = qla82xx_pinit_from_rom(vha);
#line 2699
  if (tmp != 0) {
#line 2700
    ql_log(0U, vha, 159, "Error during CRB initialization.\n");
#line 2702
    return (258);
  } else {

  }
#line 2704
  __const_udelay(2147500UL);
#line 2707
  rst = qla82xx_rd_32(ha, 154140680UL);
#line 2708
  rst = rst & -285212673;
#line 2709
  qla82xx_wr_32(ha, 154140680UL, (u32 )rst);
#line 2716
  if (ql2xfwloadbin == 2) {
#line 2717
    goto try_blob_fw;
  } else {

  }
#line 2719
  ql_log(2U, vha, 160, "Attempting to load firmware from flash.\n");
#line 2722
  tmp___0 = qla82xx_fw_load_from_flash(ha);
#line 2722
  if (tmp___0 == 0) {
#line 2723
    ql_log(2U, vha, 161, "Firmware loaded successfully from flash.\n");
#line 2725
    return (0);
  } else {
#line 2727
    ql_log(1U, vha, 264, "Firmware load from flash failed.\n");
  }
  try_blob_fw: 
#line 2732
  ql_log(2U, vha, 162, "Attempting to load firmware from blob.\n");
#line 2736
  tmp___1 = qla2x00_request_firmware(vha);
#line 2736
  ha->hablob = tmp___1;
#line 2736
  blob = tmp___1;
#line 2737
  if ((unsigned long )blob == (unsigned long )((struct fw_blob *)0)) {
#line 2738
    ql_log(0U, vha, 163, "Firmware image not present.\n");
#line 2740
    goto fw_load_failed;
  } else {

  }
#line 2744
  tmp___3 = qla82xx_validate_firmware_blob(vha, 4);
#line 2744
  if (tmp___3 != 0) {
#line 2747
    tmp___2 = qla82xx_validate_firmware_blob(vha, 3);
#line 2747
    if (tmp___2 != 0) {
#line 2749
      ql_log(0U, vha, 164, "No valid firmware image found.\n");
#line 2751
      return (258);
    } else {

    }
  } else {

  }
#line 2755
  tmp___4 = qla82xx_fw_load_from_blob(ha);
#line 2755
  if (tmp___4 == 0) {
#line 2756
    ql_log(2U, vha, 165, "Firmware loaded successfully from binary blob.\n");
#line 2758
    return (0);
  } else {
#line 2760
    ql_log(0U, vha, 166, "Firmware load failed for binary blob.\n");
#line 2762
    blob->fw = (struct firmware  const  *)0;
#line 2763
    blob = (struct fw_blob *)0;
#line 2764
    goto fw_load_failed;
  }
#line 2766
  return (0);
  fw_load_failed: ;
#line 2769
  return (258);
}
}
#line 2773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_start_firmware(scsi_qla_host_t *vha ) 
{ 
  uint16_t lnk ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2776
  ha = vha->hw;
#line 2779
  qla82xx_wr_32(ha, 136323788UL, 1431655765U);
#line 2784
  qla82xx_wr_32(ha, 136323664UL, 0U);
#line 2785
  qla82xx_wr_32(ha, 136323900UL, 0U);
#line 2788
  qla82xx_wr_32(ha, 136323240UL, 0U);
#line 2789
  qla82xx_wr_32(ha, 136323244UL, 0U);
#line 2791
  tmp = qla82xx_load_fw(vha);
#line 2791
  if (tmp != 0) {
#line 2792
    ql_log(0U, vha, 167, "Error trying to start fw.\n");
#line 2794
    return (258);
  } else {

  }
#line 2798
  tmp___0 = qla82xx_check_cmdpeg_state(ha);
#line 2798
  if (tmp___0 != 0) {
#line 2799
    ql_log(0U, vha, 170, "Error during card handshake.\n");
#line 2801
    return (258);
  } else {

  }
#line 2805
  pcie_capability_read_word(ha->pdev, 18, & lnk);
#line 2806
  ha->link_width = ((int )lnk >> 4) & 63;
#line 2809
  tmp___1 = qla82xx_check_rcvpeg_state(ha);
#line 2809
  return (tmp___1);
}
}
#line 2813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static uint32_t *qla82xx_read_flash_data(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                         uint32_t faddr , uint32_t length ) 
{ 
  uint32_t i ;
  uint32_t val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2818
  ha = vha->hw;
#line 2821
  i = 0U;
#line 2821
  goto ldv_44148;
  ldv_44147: 
#line 2822
  tmp = qla82xx_rom_fast_read(ha, (int )faddr, (int *)(& val));
#line 2822
  if (tmp != 0) {
#line 2823
    ql_log(1U, vha, 262, "Do ROM fast read failed.\n");
#line 2825
    goto done_read;
  } else {

  }
#line 2827
  *(dwptr + (unsigned long )i) = val;
#line 2821
  i = i + 1U;
#line 2821
  faddr = faddr + 4U;
  ldv_44148: ;
#line 2821
  if (length / 4U > i) {
#line 2823
    goto ldv_44147;
  } else {

  }

  done_read: ;
#line 2830
  return (dwptr);
}
}
#line 2834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_unprotect_flash(struct qla_hw_data *ha ) 
{ 
  int ret ;
  uint32_t val ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2838
  tmp = pci_get_drvdata(ha->pdev);
#line 2838
  vha = (scsi_qla_host_t *)tmp;
#line 2840
  ret = ql82xx_rom_lock_d(ha);
#line 2841
  if (ret < 0) {
#line 2842
    ql_log(1U, vha, 45076, "ROM Lock failed.\n");
#line 2844
    return (ret);
  } else {

  }
#line 2847
  ret = qla82xx_read_status_reg(ha, & val);
#line 2848
  if (ret < 0) {
#line 2849
    goto done_unprotect;
  } else {

  }
#line 2851
  val = val & 4294967235U;
#line 2852
  ret = qla82xx_write_status_reg(ha, val);
#line 2853
  if (ret < 0) {
#line 2854
    val = val | 60U;
#line 2855
    qla82xx_write_status_reg(ha, val);
  } else {

  }
#line 2858
  tmp___0 = qla82xx_write_disable_flash(ha);
#line 2858
  if (tmp___0 != 0) {
#line 2859
    ql_log(1U, vha, 45077, "Write disable failed.\n");
  } else {

  }
  done_unprotect: 
#line 2863
  qla82xx_rom_unlock(ha);
#line 2864
  return (ret);
}
}
#line 2868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_protect_flash(struct qla_hw_data *ha ) 
{ 
  int ret ;
  uint32_t val ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2872
  tmp = pci_get_drvdata(ha->pdev);
#line 2872
  vha = (scsi_qla_host_t *)tmp;
#line 2874
  ret = ql82xx_rom_lock_d(ha);
#line 2875
  if (ret < 0) {
#line 2876
    ql_log(1U, vha, 45078, "ROM Lock failed.\n");
#line 2878
    return (ret);
  } else {

  }
#line 2881
  ret = qla82xx_read_status_reg(ha, & val);
#line 2882
  if (ret < 0) {
#line 2883
    goto done_protect;
  } else {

  }
#line 2885
  val = val | 60U;
#line 2887
  ret = qla82xx_write_status_reg(ha, val);
#line 2888
  if (ret < 0) {
#line 2889
    ql_log(1U, vha, 45079, "Write status register failed.\n");
  } else {

  }
#line 2892
  tmp___0 = qla82xx_write_disable_flash(ha);
#line 2892
  if (tmp___0 != 0) {
#line 2893
    ql_log(1U, vha, 45080, "Write disable failed.\n");
  } else {

  }
  done_protect: 
#line 2896
  qla82xx_rom_unlock(ha);
#line 2897
  return (ret);
}
}
#line 2901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_erase_sector(struct qla_hw_data *ha , int addr ) 
{ 
  int ret ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2903
  ret = 0;
#line 2904
  tmp = pci_get_drvdata(ha->pdev);
#line 2904
  vha = (scsi_qla_host_t *)tmp;
#line 2906
  ret = ql82xx_rom_lock_d(ha);
#line 2907
  if (ret < 0) {
#line 2908
    ql_log(1U, vha, 45081, "ROM Lock failed.\n");
#line 2910
    return (ret);
  } else {

  }
#line 2913
  qla82xx_flash_set_write_enable(ha);
#line 2914
  qla82xx_wr_32(ha, 154206216UL, (u32 )addr);
#line 2915
  qla82xx_wr_32(ha, 154206224UL, 3U);
#line 2916
  qla82xx_wr_32(ha, 154206212UL, 216U);
#line 2918
  tmp___0 = qla82xx_wait_rom_done(ha);
#line 2918
  if (tmp___0 != 0) {
#line 2919
    ql_log(1U, vha, 45082, "Error waiting for rom done.\n");
#line 2921
    ret = -1;
#line 2922
    goto done;
  } else {

  }
#line 2924
  ret = qla82xx_flash_wait_write_finish(ha);
  done: 
#line 2926
  qla82xx_rom_unlock(ha);
#line 2927
  return (ret);
}
}
#line 2934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
uint8_t *qla82xx_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 


  {
#line 2937
  scsi_block_requests(vha->host);
#line 2938
  qla82xx_read_flash_data(vha, (uint32_t *)buf, offset, length);
#line 2939
  scsi_unblock_requests(vha->host);
#line 2940
  return (buf);
}
}
#line 2944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_write_flash_data(struct scsi_qla_host *vha , uint32_t *dwptr ,
                                    uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;
  uint32_t sec_mask ;
  uint32_t rest_addr ;
  dma_addr_t optrom_dma ;
  void *optrom ;
  int page_mode ;
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 2951
  optrom = (void *)0;
#line 2952
  page_mode = 0;
#line 2953
  ha = vha->hw;
#line 2955
  ret = -1;
#line 2958
  if ((page_mode != 0 && (faddr & 4095U) == 0U) && dwords > 1024U) {
#line 2960
    optrom = dma_alloc_attrs(& (ha->pdev)->dev, 4096UL, & optrom_dma, 208U, (struct dma_attrs *)0);
#line 2962
    if ((unsigned long )optrom == (unsigned long )((void *)0)) {
#line 2963
      ql_log(1U, vha, 45083, "Unable to allocate memory for optrom burst write (%x KB).\n",
             4);
    } else {

    }
  } else {

  }
#line 2970
  rest_addr = ha->fdt_block_size - 1U;
#line 2971
  sec_mask = ~ rest_addr;
#line 2973
  ret = qla82xx_unprotect_flash(ha);
#line 2974
  if (ret != 0) {
#line 2975
    ql_log(1U, vha, 45084, "Unable to unprotect flash for update.\n");
#line 2977
    goto write_done;
  } else {

  }
#line 2980
  liter = 0U;
#line 2980
  goto ldv_44198;
  ldv_44197: ;
#line 2982
  if ((faddr & rest_addr) == 0U) {
#line 2984
    ret = qla82xx_erase_sector(ha, (int )faddr);
#line 2985
    if (ret != 0) {
#line 2986
      ql_log(1U, vha, 45085, "Unable to erase sector: address=%x.\n", faddr);
#line 2989
      goto ldv_44192;
    } else {

    }
  } else {

  }
#line 2994
  if ((unsigned long )optrom != (unsigned long )((void *)0) && liter + 1024U <= dwords) {
#line 2996
    __len = 4096UL;
#line 2996
    if (__len > 63UL) {
#line 2996
      __ret = __memcpy(optrom, (void const   *)dwptr, __len);
    } else {
#line 2996
      __ret = __builtin_memcpy(optrom, (void const   *)dwptr, __len);
    }
#line 2998
    ret = qla2x00_load_ram(vha, optrom_dma, ha->flash_data_off | faddr, 1024U);
#line 3001
    if (ret != 0) {
#line 3002
      ql_log(1U, vha, 45086, "Unable to burst-write optrom segment (%x/%x/%llx).\n",
             ret, ha->flash_data_off | faddr, optrom_dma);
#line 3007
      ql_log(1U, vha, 45087, "Reverting to slow-write.\n");
#line 3010
      dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
#line 3012
      optrom = (void *)0;
    } else {
#line 3014
      liter = liter + 1023U;
#line 3015
      faddr = faddr + 1023U;
#line 3016
      dwptr = dwptr + 1023UL;
#line 3017
      goto ldv_44196;
    }
  } else {

  }
#line 3021
  ret = qla82xx_write_flash_dword(ha, faddr, *dwptr);
#line 3023
  if (ret != 0) {
#line 3024
    ql_dbg(524288U, vha, 45088, "Unable to program flash address=%x data=%x.\n", faddr,
           *dwptr);
#line 3027
    goto ldv_44192;
  } else {

  }
  ldv_44196: 
#line 2980
  liter = liter + 1U;
#line 2980
  faddr = faddr + 4U;
#line 2980
  dwptr = dwptr + 1;
  ldv_44198: ;
#line 2980
  if (liter < dwords) {
#line 2982
    goto ldv_44197;
  } else {

  }
  ldv_44192: 
#line 3031
  ret = qla82xx_protect_flash(ha);
#line 3032
  if (ret != 0) {
#line 3033
    ql_log(1U, vha, 45089, "Unable to protect flash after update.\n");
  } else {

  }
  write_done: ;
#line 3036
  if ((unsigned long )optrom != (unsigned long )((void *)0)) {
#line 3037
    dma_free_attrs(& (ha->pdev)->dev, 4096UL, optrom, optrom_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3039
  return (ret);
}
}
#line 3043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;

  {
#line 3049
  scsi_block_requests(vha->host);
#line 3050
  rval = qla82xx_write_flash_data(vha, (uint32_t *)buf, offset, length >> 2);
#line 3052
  scsi_unblock_requests(vha->host);
#line 3055
  if (rval != 0) {
#line 3056
    rval = 258;
  } else {
#line 3058
    rval = 0;
  }
#line 3059
  return (rval);
}
}
#line 3063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_start_iocbs(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct device_reg_82xx *reg ;
  uint32_t dbval ;
  unsigned int tmp ;

  {
#line 3065
  ha = vha->hw;
#line 3066
  req = *(ha->req_q_map);
#line 3071
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 3072
  if ((int )req->ring_index == (int )req->length) {
#line 3073
    req->ring_index = 0U;
#line 3074
    req->ring_ptr = req->ring;
  } else {
#line 3076
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 3078
  reg = & (ha->iobase)->isp82;
#line 3079
  dbval = (uint32_t )(((int )ha->portnum << 5) | 4);
#line 3081
  dbval = ((uint32_t )((int )req->id << 8) | dbval) | (uint32_t )((int )req->ring_index << 16);
#line 3082
  if (ql2xdbwr != 0) {
#line 3083
    qla82xx_wr_32(ha, ha->nxdb_wr_ptr, dbval);
  } else {
#line 3085
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 3086
    __asm__  volatile   ("sfence": : : "memory");
#line 3087
    goto ldv_44214;
    ldv_44213: 
#line 3088
    writel(dbval, (void volatile   *)ha->nxdb_wr_ptr);
#line 3090
    __asm__  volatile   ("sfence": : : "memory");
    ldv_44214: 
#line 3087
    tmp = readl((void const volatile   *)ha->nxdb_rd_ptr);
#line 3087
    if (tmp != dbval) {
#line 3089
      goto ldv_44213;
    } else {

    }

  }
#line 3095
  return;
}
}
#line 3096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_rom_lock_recovery(struct qla_hw_data *ha ) 
{ 
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 3098
  tmp = pci_get_drvdata(ha->pdev);
#line 3098
  vha = (scsi_qla_host_t *)tmp;
#line 3100
  tmp___0 = qla82xx_rom_lock(ha);
#line 3100
  if (tmp___0 != 0) {
#line 3102
    ql_log(2U, vha, 45090, "Resetting rom_lock.\n");
  } else {

  }
#line 3110
  qla82xx_rom_unlock(ha);
#line 3111
  return;
}
}
#line 3125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_device_bootstrap(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  int i ;
  int timeout ;
  uint32_t old_count ;
  uint32_t count ;
  struct qla_hw_data *ha ;
  int need_reset ;
  int peg_stuck ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 3127
  rval = 0;
#line 3130
  ha = vha->hw;
#line 3131
  need_reset = 0;
#line 3131
  peg_stuck = 1;
#line 3133
  need_reset = qla82xx_need_reset(ha);
#line 3135
  tmp = qla82xx_rd_32(ha, 136323248UL);
#line 3135
  old_count = (uint32_t )tmp;
#line 3137
  i = 0;
#line 3137
  goto ldv_44232;
  ldv_44231: 
#line 3138
  tmp___0 = msleep_interruptible(200U);
#line 3138
  timeout = (int )tmp___0;
#line 3139
  if (timeout != 0) {
#line 3140
    qla82xx_wr_32(ha, 136323392UL, 6U);
#line 3142
    return (258);
  } else {

  }
#line 3145
  tmp___1 = qla82xx_rd_32(ha, 136323248UL);
#line 3145
  count = (uint32_t )tmp___1;
#line 3146
  if (count != old_count) {
#line 3147
    peg_stuck = 0;
  } else {

  }
#line 3137
  i = i + 1;
  ldv_44232: ;
#line 3137
  if (i <= 9) {
#line 3139
    goto ldv_44231;
  } else {

  }

#line 3150
  if (need_reset != 0) {
#line 3152
    if (peg_stuck != 0) {
#line 3153
      qla82xx_rom_lock_recovery(ha);
    } else {

    }
#line 3154
    goto dev_initialize;
  } else
#line 3157
  if (peg_stuck != 0) {
#line 3159
    qla82xx_rom_lock_recovery(ha);
#line 3160
    goto dev_initialize;
  } else {
#line 3163
    goto dev_ready;
  }
#line 3166
  return (rval);
  dev_initialize: 
#line 3170
  ql_log(2U, vha, 158, "HW State: INITIALIZING.\n");
#line 3172
  qla82xx_wr_32(ha, 136323392UL, 2U);
#line 3174
  qla82xx_idc_unlock(ha);
#line 3175
  rval = qla82xx_start_firmware(vha);
#line 3176
  qla82xx_idc_lock(ha);
#line 3178
  if (rval != 0) {
#line 3179
    ql_log(0U, vha, 173, "HW State: FAILED.\n");
#line 3181
    qla82xx_clear_drv_active(ha);
#line 3182
    qla82xx_wr_32(ha, 136323392UL, 6U);
#line 3183
    return (rval);
  } else {

  }
  dev_ready: 
#line 3187
  ql_log(2U, vha, 174, "HW State: READY.\n");
#line 3189
  qla82xx_wr_32(ha, 136323392UL, 3U);
#line 3191
  return (0);
}
}
#line 3205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_need_qsnt_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  unsigned long reset_timeout ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3207
  ha = vha->hw;
#line 3211
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3213
    qla2x00_quiesce_io(vha);
  } else {

  }
#line 3217
  qla82xx_set_qsnt_ready(ha);
#line 3220
  reset_timeout = (unsigned long )jiffies + 7500UL;
#line 3222
  tmp = qla82xx_rd_32(ha, 136323396UL);
#line 3222
  drv_state = (uint32_t )tmp;
#line 3223
  tmp___0 = qla82xx_rd_32(ha, 136323384UL);
#line 3223
  drv_active = (uint32_t )tmp___0;
#line 3225
  drv_active = drv_active << 1;
#line 3227
  goto ldv_44251;
  ldv_44250: ;
#line 3229
  if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 3233
    ql_log(2U, vha, 45091, "%s : QUIESCENT TIMEOUT DRV_ACTIVE:%d DRV_STATE:%d.\n",
           (char *)"qla2xxx", drv_active, drv_state);
#line 3237
    qla82xx_wr_32(ha, 136323392UL, 3U);
#line 3239
    ql_log(2U, vha, 45093, "HW State: DEV_READY.\n");
#line 3241
    qla82xx_idc_unlock(ha);
#line 3242
    qla2x00_perform_loop_resync(vha);
#line 3243
    qla82xx_idc_lock(ha);
#line 3245
    qla82xx_clear_qsnt_ready(vha);
#line 3246
    return;
  } else {

  }
#line 3249
  qla82xx_idc_unlock(ha);
#line 3250
  msleep(1000U);
#line 3251
  qla82xx_idc_lock(ha);
#line 3253
  tmp___1 = qla82xx_rd_32(ha, 136323396UL);
#line 3253
  drv_state = (uint32_t )tmp___1;
#line 3254
  tmp___2 = qla82xx_rd_32(ha, 136323384UL);
#line 3254
  drv_active = (uint32_t )tmp___2;
#line 3255
  drv_active = drv_active << 1;
  ldv_44251: ;
#line 3227
  if (drv_state != drv_active) {
#line 3229
    goto ldv_44250;
  } else {

  }
#line 3257
  tmp___3 = qla82xx_rd_32(ha, 136323392UL);
#line 3257
  dev_state = (uint32_t )tmp___3;
#line 3259
  if (dev_state == 5U) {
#line 3260
    ql_log(2U, vha, 45094, "HW State: DEV_QUIESCENT.\n");
#line 3262
    qla82xx_wr_32(ha, 136323392UL, 7U);
  } else {

  }
#line 3264
  return;
}
}
#line 3277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
uint32_t qla82xx_wait_for_state_change(scsi_qla_host_t *vha , uint32_t curr_state ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  int tmp ;

  {
#line 3279
  ha = vha->hw;
  ldv_44259: 
#line 3283
  msleep(1000U);
#line 3284
  qla82xx_idc_lock(ha);
#line 3285
  tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3285
  dev_state = (uint32_t )tmp;
#line 3286
  qla82xx_idc_unlock(ha);
#line 3287
  if (dev_state == curr_state) {
#line 3289
    goto ldv_44259;
  } else {

  }

#line 3289
  return (dev_state);
}
}
#line 3293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla8xxx_dev_failed_handler(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 3295
  ha = vha->hw;
#line 3298
  ql_log(0U, vha, 184, "Disabling the board.\n");
#line 3301
  if ((ha->device_type & 16384U) != 0U) {
#line 3302
    qla82xx_clear_drv_active(ha);
#line 3303
    qla82xx_idc_unlock(ha);
  } else
#line 3304
  if ((ha->device_type & 262144U) != 0U) {
#line 3305
    qla8044_clear_drv_active(vha);
#line 3306
    qla8044_idc_unlock(ha);
  } else {

  }
#line 3310
  vha->device_flags = vha->device_flags | 32U;
#line 3311
  qla2x00_abort_all_cmds(vha, 65536);
#line 3312
  qla2x00_mark_all_devices_lost(vha, 0);
#line 3313
  vha->flags.online = 0U;
#line 3314
  vha->flags.init_done = 0U;
#line 3315
  return;
}
}
#line 3329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_need_reset_handler(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  uint32_t active_mask ;
  unsigned long reset_timeout ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 3332
  active_mask = 0U;
#line 3334
  ha = vha->hw;
#line 3335
  req = *(ha->req_q_map);
#line 3337
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3338
    qla82xx_idc_unlock(ha);
#line 3339
    qla2x00_abort_isp_cleanup(vha);
#line 3340
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)req->ring);
#line 3341
    (*((ha->isp_ops)->nvram_config))(vha);
#line 3342
    qla82xx_idc_lock(ha);
  } else {

  }
#line 3345
  tmp = qla82xx_rd_32(ha, 136323384UL);
#line 3345
  drv_active = (uint32_t )tmp;
#line 3346
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3347
    ql_dbg(524288U, vha, 45096, "reset_acknowledged by 0x%x\n", (int )ha->portnum);
#line 3349
    qla82xx_set_rst_ready(ha);
  } else {
#line 3351
    active_mask = (uint32_t )(~ (1 << (int )ha->portnum * 4));
#line 3352
    drv_active = drv_active & active_mask;
#line 3353
    ql_dbg(524288U, vha, 45097, "active_mask: 0x%08x\n", active_mask);
  }
#line 3358
  reset_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 3360
  tmp___0 = qla82xx_rd_32(ha, 136323396UL);
#line 3360
  drv_state = (uint32_t )tmp___0;
#line 3361
  tmp___1 = qla82xx_rd_32(ha, 136323384UL);
#line 3361
  drv_active = (uint32_t )tmp___1;
#line 3362
  tmp___2 = qla82xx_rd_32(ha, 136323392UL);
#line 3362
  dev_state = (uint32_t )tmp___2;
#line 3364
  ql_dbg(524288U, vha, 45098, "drv_state: 0x%08x, drv_active: 0x%08x, dev_state: 0x%08x, active_mask: 0x%08x\n",
         drv_state, drv_active, dev_state, active_mask);
#line 3369
  goto ldv_44283;
  ldv_44282: ;
#line 3371
  if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 3372
    ql_log(1U, vha, 181, "Reset timeout.\n");
#line 3374
    goto ldv_44281;
  } else {

  }
#line 3376
  qla82xx_idc_unlock(ha);
#line 3377
  msleep(1000U);
#line 3378
  qla82xx_idc_lock(ha);
#line 3379
  tmp___3 = qla82xx_rd_32(ha, 136323396UL);
#line 3379
  drv_state = (uint32_t )tmp___3;
#line 3380
  tmp___4 = qla82xx_rd_32(ha, 136323384UL);
#line 3380
  drv_active = (uint32_t )tmp___4;
#line 3381
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3382
    drv_active = drv_active & active_mask;
  } else {

  }
#line 3383
  tmp___5 = qla82xx_rd_32(ha, 136323392UL);
#line 3383
  dev_state = (uint32_t )tmp___5;
  ldv_44283: ;
#line 3369
  if (drv_state != drv_active && dev_state != 2U) {
#line 3372
    goto ldv_44282;
  } else {

  }
  ldv_44281: 
#line 3386
  ql_dbg(524288U, vha, 45099, "drv_state: 0x%08x, drv_active: 0x%08x, dev_state: 0x%08x, active_mask: 0x%08x\n",
         drv_state, drv_active, dev_state, active_mask);
#line 3391
  if (dev_state <= 7U) {
#line 3391
    tmp___6 = qdev_state(dev_state);
#line 3391
    tmp___7 = tmp___6;
  } else {
#line 3391
    tmp___7 = (char *)"Unknown";
  }
#line 3391
  ql_log(2U, vha, 182, "Device state is 0x%x = %s.\n", dev_state, tmp___7);
#line 3397
  if (dev_state != 2U && dev_state != 1U) {
#line 3399
    ql_log(2U, vha, 183, "HW State: COLD/RE-INIT.\n");
#line 3401
    qla82xx_wr_32(ha, 136323392UL, 1U);
#line 3402
    qla82xx_set_rst_ready(ha);
#line 3403
    if (ql2xmdenable != 0) {
#line 3404
      tmp___8 = qla82xx_md_collect(vha);
#line 3404
      if (tmp___8 != 0) {
#line 3405
        ql_log(1U, vha, 45100, "Minidump not collected.\n");
      } else {

      }
    } else {
#line 3408
      ql_log(1U, vha, 45135, "Minidump disabled.\n");
    }
  } else {

  }
#line 3411
  return;
}
}
#line 3414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_check_md_needed(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t fw_major_version ;
  uint16_t fw_minor_version ;
  uint16_t fw_subminor_version ;
  int rval ;

  {
#line 3416
  ha = vha->hw;
#line 3418
  rval = 0;
#line 3420
  fw_major_version = ha->fw_major_version;
#line 3421
  fw_minor_version = ha->fw_minor_version;
#line 3422
  fw_subminor_version = ha->fw_subminor_version;
#line 3424
  rval = qla2x00_get_fw_version(vha);
#line 3425
  if (rval != 0) {
#line 3426
    return (rval);
  } else {

  }
#line 3428
  if (ql2xmdenable != 0) {
#line 3429
    if (ha->fw_dumped == 0) {
#line 3430
      if (((int )ha->fw_major_version != (int )fw_major_version || (int )ha->fw_minor_version != (int )fw_minor_version) || (int )ha->fw_subminor_version != (int )fw_subminor_version) {
#line 3433
        ql_dbg(524288U, vha, 45101, "Firmware version differs Previous version: %d:%d:%d - New version: %d:%d:%d\n",
               (int )fw_major_version, (int )fw_minor_version, (int )fw_subminor_version,
               (int )ha->fw_major_version, (int )ha->fw_minor_version, (int )ha->fw_subminor_version);
#line 3443
        qla82xx_md_free(vha);
#line 3445
        qla82xx_md_prep(vha);
      } else {

      }
    } else {
#line 3448
      ql_log(2U, vha, 45102, "Firmware dump available to retrieve\n");
    }
  } else {

  }
#line 3451
  return (rval);
}
}
#line 3456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_check_fw_alive(scsi_qla_host_t *vha ) 
{ 
  uint32_t fw_heartbeat_counter ;
  int status ;
  int tmp ;

  {
#line 3459
  status = 0;
#line 3461
  tmp = qla82xx_rd_32(vha->hw, 136323248UL);
#line 3461
  fw_heartbeat_counter = (uint32_t )tmp;
#line 3464
  if (fw_heartbeat_counter == 4294967295U) {
#line 3465
    ql_dbg(16777216U, vha, 24579, "FW heartbeat counter is 0xffffffff, returning status=%d.\n",
           status);
#line 3468
    return (status);
  } else {

  }
#line 3470
  if ((uint32_t )vha->fw_heartbeat_counter == fw_heartbeat_counter) {
#line 3471
    vha->seconds_since_last_heartbeat = vha->seconds_since_last_heartbeat + 1;
#line 3473
    if (vha->seconds_since_last_heartbeat == 2) {
#line 3474
      vha->seconds_since_last_heartbeat = 0;
#line 3475
      status = 1;
    } else {

    }
  } else {
#line 3478
    vha->seconds_since_last_heartbeat = 0;
  }
#line 3479
  vha->fw_heartbeat_counter = (int )fw_heartbeat_counter;
#line 3480
  if (status != 0) {
#line 3481
    ql_dbg(16777216U, vha, 24580, "Returning status=%d.\n", status);
  } else {

  }
#line 3483
  return (status);
}
}
#line 3498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_device_state_handler(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t old_dev_state ;
  int rval ;
  unsigned long dev_init_timeout ;
  struct qla_hw_data *ha ;
  int loopcount ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 3502
  rval = 0;
#line 3504
  ha = vha->hw;
#line 3505
  loopcount = 0;
#line 3507
  qla82xx_idc_lock(ha);
#line 3508
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 3509
    qla82xx_set_drv_active(vha);
#line 3510
    qla82xx_set_idc_version(vha);
  } else {

  }
#line 3513
  tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3513
  dev_state = (uint32_t )tmp;
#line 3514
  old_dev_state = dev_state;
#line 3515
  if (dev_state <= 7U) {
#line 3515
    tmp___0 = qdev_state(dev_state);
#line 3515
    tmp___1 = tmp___0;
  } else {
#line 3515
    tmp___1 = (char *)"Unknown";
  }
#line 3515
  ql_log(2U, vha, 155, "Device state is 0x%x = %s.\n", dev_state, tmp___1);
#line 3521
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
  ldv_44324: ;
#line 3525
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 3526
    ql_log(0U, vha, 156, "Device init failed.\n");
#line 3528
    rval = 258;
#line 3529
    goto ldv_44312;
  } else {

  }
#line 3531
  tmp___2 = qla82xx_rd_32(ha, 136323392UL);
#line 3531
  dev_state = (uint32_t )tmp___2;
#line 3532
  if (old_dev_state != dev_state) {
#line 3533
    loopcount = 0;
#line 3534
    old_dev_state = dev_state;
  } else {

  }
#line 3536
  if (loopcount <= 4) {
#line 3537
    if (dev_state <= 7U) {
#line 3537
      tmp___3 = qdev_state(dev_state);
#line 3537
      tmp___4 = tmp___3;
    } else {
#line 3537
      tmp___4 = (char *)"Unknown";
    }
#line 3537
    ql_log(2U, vha, 157, "Device state is 0x%x = %s.\n", dev_state, tmp___4);
  } else {

  }
#line 3544
  switch (dev_state) {
  case 3U: 
#line 3546
  ha->flags.nic_core_reset_owner = 0U;
#line 3547
  goto rel_lock;
  case 1U: 
#line 3549
  rval = qla82xx_device_bootstrap(vha);
#line 3550
  goto ldv_44316;
  case 2U: 
#line 3552
  qla82xx_idc_unlock(ha);
#line 3553
  msleep(1000U);
#line 3554
  qla82xx_idc_lock(ha);
#line 3555
  goto ldv_44316;
  case 4U: ;
#line 3557
  if (ql2xdontresethba == 0) {
#line 3558
    qla82xx_need_reset_handler(vha);
  } else {
#line 3560
    qla82xx_idc_unlock(ha);
#line 3561
    msleep(1000U);
#line 3562
    qla82xx_idc_lock(ha);
  }
#line 3564
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3566
  goto ldv_44316;
  case 5U: 
#line 3568
  qla82xx_need_qsnt_handler(vha);
#line 3570
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3572
  goto ldv_44316;
  case 7U: ;
#line 3577
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3578
    goto rel_lock;
  } else {

  }
#line 3580
  qla82xx_idc_unlock(ha);
#line 3581
  msleep(1000U);
#line 3582
  qla82xx_idc_lock(ha);
#line 3585
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 3587
  goto ldv_44316;
  case 6U: 
#line 3589
  qla8xxx_dev_failed_handler(vha);
#line 3590
  rval = 258;
#line 3591
  goto exit;
  default: 
#line 3593
  qla82xx_idc_unlock(ha);
#line 3594
  msleep(1000U);
#line 3595
  qla82xx_idc_lock(ha);
  }
  ldv_44316: 
#line 3597
  loopcount = loopcount + 1;
#line 3598
  goto ldv_44324;
  ldv_44312: ;
  rel_lock: 
#line 3600
  qla82xx_idc_unlock(ha);
  exit: ;
#line 3602
  return (rval);
}
}
#line 3605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_check_temp(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  uint32_t temp_state ;
  uint32_t temp_val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3608
  ha = vha->hw;
#line 3610
  tmp = qla82xx_rd_32(ha, 136324020UL);
#line 3610
  temp = (uint32_t )tmp;
#line 3611
  temp_state = temp & 65535U;
#line 3612
  temp_val = temp >> 16;
#line 3614
  if (temp_state == 3U) {
#line 3615
    ql_log(1U, vha, 24590, "Device temperature %d degrees C exceeds  maximum allowed. Hardware has been shut down.\n",
           temp_val);
#line 3619
    return (1);
  } else
#line 3620
  if (temp_state == 2U) {
#line 3621
    ql_log(1U, vha, 24591, "Device temperature %d degrees C exceeds operating range. Immediate action needed.\n",
           temp_val);
  } else {

  }
#line 3626
  return (0);
}
}
#line 3629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_read_temperature(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  int tmp ;

  {
#line 3633
  tmp = qla82xx_rd_32(vha->hw, 136324020UL);
#line 3633
  temp = (uint32_t )tmp;
#line 3634
  return ((int )(temp >> 16));
}
}
#line 3637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_clear_pending_mbx(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3639
  ha = vha->hw;
#line 3641
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 3642
    ha->flags.mbox_int = 1U;
#line 3643
    ha->flags.mbox_busy = 0U;
#line 3644
    ql_log(1U, vha, 24592, "Doing premature completion of mbx command.\n");
#line 3646
    tmp = test_and_clear_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 3646
    if (tmp != 0) {
#line 3647
      complete(& ha->mbx_intr_comp);
    } else {

    }
  } else {

  }
#line 3649
  return;
}
}
#line 3651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_watchdog(scsi_qla_host_t *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t halt_status ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3654
  ha = vha->hw;
#line 3657
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3658
    tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3658
    dev_state = (uint32_t )tmp;
#line 3659
    tmp___11 = qla82xx_check_temp(vha);
#line 3659
    if (tmp___11 != 0) {
#line 3660
      set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3661
      ha->flags.isp82xx_fw_hung = 1U;
#line 3662
      qla82xx_clear_pending_mbx(vha);
    } else
#line 3663
    if (dev_state == 4U) {
#line 3663
      tmp___10 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3663
      if (tmp___10 == 0) {
#line 3665
        ql_log(1U, vha, 24577, "Adapter reset needed.\n");
#line 3667
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 3663
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3668
    if (dev_state == 5U) {
#line 3668
      tmp___9 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3668
      if (tmp___9 == 0) {
#line 3670
        ql_log(1U, vha, 24578, "Quiescent needed.\n");
#line 3672
        set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
      } else {
#line 3668
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3673
    if (dev_state == 6U) {
#line 3673
      tmp___8 = constant_test_bit(17L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3673
      if (tmp___8 == 0) {
#line 3673
        if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3676
          ql_log(1U, vha, 45141, "Adapter state is failed. Offlining.\n");
#line 3678
          set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3679
          ha->flags.isp82xx_fw_hung = 1U;
#line 3680
          qla82xx_clear_pending_mbx(vha);
        } else {
#line 3673
          goto _L___0;
        }
      } else {
#line 3673
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 3682
      tmp___7 = qla82xx_check_fw_alive(vha);
#line 3682
      if (tmp___7 != 0) {
#line 3683
        ql_dbg(16777216U, vha, 24593, "disabling pause transmit on port 0 & 1.\n");
#line 3685
        qla82xx_wr_32(ha, 106954904UL, 9U);
#line 3687
        tmp___0 = qla82xx_rd_32(ha, 136323240UL);
#line 3687
        halt_status = (uint32_t )tmp___0;
#line 3689
        tmp___1 = qla82xx_rd_32(ha, 116391996UL);
#line 3689
        tmp___2 = qla82xx_rd_32(ha, 121634876UL);
#line 3689
        tmp___3 = qla82xx_rd_32(ha, 120586300UL);
#line 3689
        tmp___4 = qla82xx_rd_32(ha, 119537724UL);
#line 3689
        tmp___5 = qla82xx_rd_32(ha, 118489148UL);
#line 3689
        tmp___6 = qla82xx_rd_32(ha, 136323244UL);
#line 3689
        ql_log(2U, vha, 24581, "dumping hw/fw registers:.\n  PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,.\n  PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,.\n  PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,.\n  PEG_NET_4_PC: 0x%x.\n",
               halt_status, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
#line 3706
        if ((halt_status & 536870656U) >> 8 == 103U) {
#line 3707
          ql_log(1U, vha, 45138, "Firmware aborted with error code 0x00006700. Device is being reset.\n");
        } else {

        }
#line 3711
        if ((int )halt_status < 0) {
#line 3712
          set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
        } else {
#line 3715
          ql_log(2U, vha, 24582, "Detect abort  needed.\n");
#line 3717
          set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
        }
#line 3720
        ha->flags.isp82xx_fw_hung = 1U;
#line 3721
        ql_log(1U, vha, 24583, "Firmware hung.\n");
#line 3722
        qla82xx_clear_pending_mbx(vha);
      } else {

      }
    }
  } else {

  }
#line 3725
  return;
}
}
#line 3728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_load_risc(scsi_qla_host_t *vha , uint32_t *srisc_addr ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 3730
  rval = -1;
#line 3731
  ha = vha->hw;
#line 3733
  if ((ha->device_type & 16384U) != 0U) {
#line 3734
    rval = qla82xx_device_state_handler(vha);
  } else
#line 3735
  if ((ha->device_type & 262144U) != 0U) {
#line 3736
    qla8044_idc_lock(ha);
#line 3738
    qla83xx_reset_ownership(vha);
#line 3739
    qla8044_idc_unlock(ha);
#line 3740
    rval = qla8044_device_state_handler(vha);
  } else {

  }
#line 3742
  return (rval);
}
}
#line 3746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_set_reset_owner(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t dev_state ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3748
  ha = vha->hw;
#line 3749
  dev_state = 0U;
#line 3751
  if ((ha->device_type & 16384U) != 0U) {
#line 3752
    tmp = qla82xx_rd_32(ha, 136323392UL);
#line 3752
    dev_state = (uint32_t )tmp;
  } else
#line 3753
  if ((ha->device_type & 262144U) != 0U) {
#line 3754
    tmp___0 = qla8044_rd_direct(vha, 4U);
#line 3754
    dev_state = (uint32_t )tmp___0;
  } else {

  }
#line 3756
  if (dev_state == 3U) {
#line 3757
    ql_log(2U, vha, 45103, "HW State: NEED RESET\n");
#line 3759
    if ((ha->device_type & 16384U) != 0U) {
#line 3760
      qla82xx_wr_32(ha, 136323392UL, 4U);
#line 3762
      ha->flags.nic_core_reset_owner = 1U;
#line 3763
      ql_dbg(524288U, vha, 45104, "reset_owner is 0x%x\n", (int )ha->portnum);
    } else
#line 3765
    if ((ha->device_type & 262144U) != 0U) {
#line 3766
      qla8044_wr_direct(vha, 4U, 4U);
    } else {

    }
  } else {
#line 3769
    if (dev_state <= 7U) {
#line 3769
      tmp___1 = qdev_state(dev_state);
#line 3769
      tmp___2 = tmp___1;
    } else {
#line 3769
      tmp___2 = (char *)"Unknown";
    }
#line 3769
    ql_log(2U, vha, 45105, "Device state is 0x%x = %s.\n", dev_state, tmp___2);
  }
#line 3773
  return;
}
}
#line 3786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3788
  rval = -1;
#line 3789
  ha = vha->hw;
#line 3791
  if ((vha->device_flags & 32U) != 0U) {
#line 3792
    ql_log(1U, vha, 32804, "Device in failed state, exiting.\n");
#line 3794
    return (0);
  } else {

  }
#line 3796
  ha->flags.nic_core_reset_hdlr_active = 1U;
#line 3798
  qla82xx_idc_lock(ha);
#line 3799
  qla82xx_set_reset_owner(vha);
#line 3800
  qla82xx_idc_unlock(ha);
#line 3802
  if ((ha->device_type & 16384U) != 0U) {
#line 3803
    rval = qla82xx_device_state_handler(vha);
  } else
#line 3804
  if ((ha->device_type & 262144U) != 0U) {
#line 3805
    qla8044_idc_lock(ha);
#line 3807
    qla83xx_reset_ownership(vha);
#line 3808
    qla8044_idc_unlock(ha);
#line 3809
    rval = qla8044_device_state_handler(vha);
  } else {

  }
#line 3812
  qla82xx_idc_lock(ha);
#line 3813
  qla82xx_clear_rst_ready(ha);
#line 3814
  qla82xx_idc_unlock(ha);
#line 3816
  if (rval == 0) {
#line 3817
    ha->flags.isp82xx_fw_hung = 0U;
#line 3818
    ha->flags.nic_core_reset_hdlr_active = 0U;
#line 3819
    qla82xx_restart_isp(vha);
  } else {

  }
#line 3822
  if (rval != 0) {
#line 3823
    vha->flags.online = 1U;
#line 3824
    tmp = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3824
    if (tmp != 0) {
#line 3825
      if (ha->isp_abort_cnt == 0U) {
#line 3826
        ql_log(1U, vha, 32807, "ISP error recover failed - board disabled.\n");
#line 3833
        (*((ha->isp_ops)->reset_adapter))(vha);
#line 3834
        vha->flags.online = 0U;
#line 3835
        clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3837
        rval = 0;
      } else {
#line 3839
        ha->isp_abort_cnt = ha->isp_abort_cnt - 1U;
#line 3840
        ql_log(1U, vha, 32822, "ISP abort - retry remaining %d.\n", ha->isp_abort_cnt);
#line 3843
        rval = 258;
      }
    } else {
#line 3846
      ha->isp_abort_cnt = 5U;
#line 3847
      ql_dbg(4194304U, vha, 32809, "ISP error recovery - retrying (%d) more times.\n",
             ha->isp_abort_cnt);
#line 3850
      set_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3851
      rval = 258;
    }
  } else {

  }
#line 3854
  return (rval);
}
}
#line 3870 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha ) 
{ 
  int rval ;

  {
#line 3872
  rval = 258;
#line 3874
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 3876
    qla2x00_abort_isp_cleanup(vha);
  } else {

  }
#line 3882
  qla2x00_try_to_stop_firmware(vha);
#line 3885
  rval = qla82xx_restart_isp(vha);
#line 3887
  return (rval);
}
}
#line 3902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha ) 
{ 
  int status ;
  unsigned long wait_reset ;
  long volatile   __ret ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 3904
  status = 258;
#line 3907
  wait_reset = (unsigned long )jiffies + 75000UL;
#line 3908
  goto ldv_44387;
  ldv_44386: 
#line 3912
  __ret = 2L;
#line 3912
  switch (8UL) {
  case 1UL: 
#line 3912
  tmp = get_current();
#line 3912
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp->state): : "memory",
                       "cc");
#line 3912
  goto ldv_44379;
  case 2UL: 
#line 3912
  tmp___0 = get_current();
#line 3912
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 3912
  goto ldv_44379;
  case 4UL: 
#line 3912
  tmp___1 = get_current();
#line 3912
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 3912
  goto ldv_44379;
  case 8UL: 
#line 3912
  tmp___2 = get_current();
#line 3912
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 3912
  goto ldv_44379;
  default: 
#line 3912
  __xchg_wrong_size();
  }
  ldv_44379: 
#line 3913
  schedule_timeout(250L);
#line 3915
  tmp___3 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3915
  if (tmp___3 == 0) {
#line 3915
    tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3915
    if (tmp___4 == 0) {
#line 3917
      status = 0;
#line 3918
      goto ldv_44385;
    } else {

    }
  } else {

  }
  ldv_44387: 
#line 3908
  tmp___5 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3910
  if (tmp___5 != 0) {
#line 3910
    goto _L;
  } else {
#line 3908
    tmp___6 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 3910
    if (tmp___6 != 0) {
      _L: /* CIL Label */ 
#line 3910
      if ((long )((unsigned long )jiffies - wait_reset) < 0L) {
#line 3912
        goto ldv_44386;
      } else {
#line 3915
        goto ldv_44385;
      }
    } else {
#line 3915
      goto ldv_44385;
    }
  }
  ldv_44385: 
#line 3921
  ql_dbg(524288U, vha, 45095, "%s: status=%d.\n", "qla2x00_wait_for_fcoe_ctx_reset",
         status);
#line 3924
  return (status);
}
}
#line 3928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha ) 
{ 
  int i ;
  int fw_state ;
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int cnt ;
  int que ;
  srb_t *sp ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
#line 3930
  fw_state = 0;
#line 3932
  ha = vha->hw;
#line 3938
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3939
    i = 0;
#line 3939
    goto ldv_44398;
    ldv_44397: 
#line 3940
    msleep(1000U);
#line 3941
    if ((ha->device_type & 16384U) != 0U) {
#line 3942
      fw_state = qla82xx_check_fw_alive(vha);
    } else
#line 3943
    if ((ha->device_type & 262144U) != 0U) {
#line 3944
      fw_state = qla8044_check_fw_alive(vha);
    } else {

    }
#line 3945
    if (fw_state != 0) {
#line 3946
      ha->flags.isp82xx_fw_hung = 1U;
#line 3947
      qla82xx_clear_pending_mbx(vha);
#line 3948
      goto ldv_44396;
    } else {

    }
#line 3939
    i = i + 1;
    ldv_44398: ;
#line 3939
    if (i <= 1) {
#line 3941
      goto ldv_44397;
    } else {

    }
    ldv_44396: ;
  } else {

  }
#line 3952
  ql_dbg(1073741824U, vha, 176, "Entered %s fw_hung=%d.\n", "qla82xx_chip_reset_cleanup",
         (int )ha->flags.isp82xx_fw_hung);
#line 3957
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 3962
    tmp = spinlock_check(& ha->hardware_lock);
#line 3962
    flags = _raw_spin_lock_irqsave(tmp);
#line 3963
    que = 0;
#line 3963
    goto ldv_44415;
    ldv_44414: 
#line 3964
    req = *(ha->req_q_map + (unsigned long )que);
#line 3965
    if ((unsigned long )req == (unsigned long )((struct req_que *)0)) {
#line 3966
      goto ldv_44407;
    } else {

    }
#line 3967
    cnt = 1;
#line 3967
    goto ldv_44412;
    ldv_44411: 
#line 3968
    sp = *(req->outstanding_cmds + (unsigned long )cnt);
#line 3969
    if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 3970
      if ((unsigned long )sp->u.scmd.ctx == (unsigned long )((void *)0) || ((int )sp->flags & 4096) != 0) {
#line 3972
        spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3974
        tmp___0 = (*((ha->isp_ops)->abort_command))(sp);
#line 3974
        if (tmp___0 != 0) {
#line 3975
          ql_log(2U, vha, 177, "mbx abort failed.\n");
        } else {
#line 3979
          ql_log(2U, vha, 178, "mbx abort success.\n");
        }
#line 3983
        tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3983
        flags = _raw_spin_lock_irqsave(tmp___1);
      } else {

      }
    } else {

    }
#line 3967
    cnt = cnt + 1;
    ldv_44412: ;
#line 3967
    if ((int )req->num_outstanding_cmds > cnt) {
#line 3969
      goto ldv_44411;
    } else {

    }

    ldv_44407: 
#line 3963
    que = que + 1;
    ldv_44415: ;
#line 3963
    if ((int )ha->max_req_queues > que) {
#line 3965
      goto ldv_44414;
    } else {

    }
#line 3988
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3991
    tmp___2 = qla2x00_eh_wait_for_pending_commands(vha, 0U, 0U, 0);
#line 3991
    if (tmp___2 != 0) {
#line 3993
      ql_dbg(1073741824U, vha, 179, "Done wait for pending commands.\n");
    } else {

    }
  } else {

  }
#line 3996
  return;
}
}
#line 4002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_minidump_process_control(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                            uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  struct qla82xx_md_entry_crb *crb_entry ;
  uint32_t read_value ;
  uint32_t opcode ;
  uint32_t poll_time ;
  uint32_t addr ;
  uint32_t index ;
  uint32_t crb_addr ;
  unsigned long wtime ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;
  uint32_t rval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4005
  ha = vha->hw;
#line 4011
  rval = 0U;
#line 4014
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 4015
  crb_entry = (struct qla82xx_md_entry_crb *)entry_hdr;
#line 4016
  crb_addr = crb_entry->addr;
#line 4018
  i = 0;
#line 4018
  goto ldv_44443;
  ldv_44442: 
#line 4019
  opcode = (uint32_t )crb_entry->crb_ctrl.opcode;
#line 4020
  if ((int )opcode & 1) {
#line 4021
    qla82xx_md_rw_32(ha, crb_addr, crb_entry->value_1, 1);
#line 4023
    opcode = opcode & 4294967294U;
  } else {

  }
#line 4026
  if ((opcode & 2U) != 0U) {
#line 4027
    tmp = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 4027
    read_value = (uint32_t )tmp;
#line 4028
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
#line 4029
    opcode = opcode & 4294967293U;
  } else {

  }
#line 4032
  if ((opcode & 4U) != 0U) {
#line 4033
    tmp___0 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 4033
    read_value = (uint32_t )tmp___0;
#line 4034
    read_value = crb_entry->value_2 & read_value;
#line 4035
    opcode = opcode & 4294967291U;
#line 4036
    if ((opcode & 8U) != 0U) {
#line 4037
      read_value = crb_entry->value_3 | read_value;
#line 4038
      opcode = opcode & 4294967287U;
    } else {

    }
#line 4040
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
  } else {

  }
#line 4043
  if ((opcode & 8U) != 0U) {
#line 4044
    tmp___1 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 4044
    read_value = (uint32_t )tmp___1;
#line 4045
    read_value = crb_entry->value_3 | read_value;
#line 4046
    qla82xx_md_rw_32(ha, crb_addr, read_value, 1);
#line 4047
    opcode = opcode & 4294967287U;
  } else {

  }
#line 4050
  if ((opcode & 16U) != 0U) {
#line 4051
    poll_time = (uint32_t )crb_entry->crb_strd.poll_timeout;
#line 4052
    wtime = (unsigned long )poll_time + (unsigned long )jiffies;
#line 4053
    tmp___2 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 4053
    read_value = (uint32_t )tmp___2;
    ldv_44441: ;
#line 4056
    if ((crb_entry->value_2 & read_value) == crb_entry->value_1) {
#line 4058
      goto ldv_44434;
    } else
#line 4059
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 4061
      rval = 258U;
#line 4062
      goto ldv_44434;
    } else {
#line 4064
      tmp___3 = qla82xx_md_rw_32(ha, crb_addr, 0U, 0);
#line 4064
      read_value = (uint32_t )tmp___3;
    }
#line 4066
    goto ldv_44441;
    ldv_44434: 
#line 4067
    opcode = opcode & 4294967279U;
  } else {

  }
#line 4070
  if ((opcode & 32U) != 0U) {
#line 4071
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 4072
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 4073
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 4075
      addr = crb_addr;
    }
#line 4077
    tmp___4 = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 4077
    read_value = (uint32_t )tmp___4;
#line 4078
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 4079
    tmplt_hdr->saved_state_array[index] = read_value;
#line 4080
    opcode = opcode & 4294967263U;
  } else {

  }
#line 4083
  if ((opcode & 64U) != 0U) {
#line 4084
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 4085
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 4086
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 4088
      addr = crb_addr;
    }
#line 4090
    if ((unsigned int )crb_entry->crb_ctrl.state_index_v != 0U) {
#line 4091
      index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 4092
      read_value = tmplt_hdr->saved_state_array[index];
    } else {
#line 4095
      read_value = crb_entry->value_1;
    }
#line 4097
    qla82xx_md_rw_32(ha, addr, read_value, 1);
#line 4098
    opcode = opcode & 4294967231U;
  } else {

  }
#line 4101
  if ((opcode & 128U) != 0U) {
#line 4102
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 4103
    read_value = tmplt_hdr->saved_state_array[index];
#line 4104
    read_value = read_value << (int )crb_entry->crb_ctrl.shl;
#line 4105
    read_value = read_value >> (int )crb_entry->crb_ctrl.shr;
#line 4106
    if (crb_entry->value_2 != 0U) {
#line 4107
      read_value = crb_entry->value_2 & read_value;
    } else {

    }
#line 4108
    read_value = crb_entry->value_3 | read_value;
#line 4109
    read_value = crb_entry->value_1 + read_value;
#line 4110
    tmplt_hdr->saved_state_array[index] = read_value;
#line 4111
    opcode = opcode & 4294967167U;
  } else {

  }
#line 4113
  crb_addr = (uint32_t )crb_entry->crb_strd.addr_stride + crb_addr;
#line 4018
  i = i + 1;
  ldv_44443: ;
#line 4018
  if ((uint32_t )i < crb_entry->op_count) {
#line 4020
    goto ldv_44442;
  } else {

  }

#line 4115
  return ((int )rval);
}
}
#line 4119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_rdocm(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_rdocm *ocm_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 4122
  ha = vha->hw;
#line 4125
  data_ptr = *d_ptr;
#line 4127
  ocm_hdr = (struct qla82xx_md_entry_rdocm *)entry_hdr;
#line 4128
  r_addr = ocm_hdr->read_addr;
#line 4129
  r_stride = ocm_hdr->read_addr_stride;
#line 4130
  loop_cnt = ocm_hdr->op_count;
#line 4132
  i = 0U;
#line 4132
  goto ldv_44459;
  ldv_44458: 
#line 4133
  r_value = readl((void const volatile   *)((unsigned long )r_addr + ha->nx_pcibase));
#line 4135
  tmp = data_ptr;
#line 4135
  data_ptr = data_ptr + 1;
#line 4135
  *tmp = r_value;
#line 4136
  r_addr = r_addr + r_stride;
#line 4132
  i = i + 1U;
  ldv_44459: ;
#line 4132
  if (i < loop_cnt) {
#line 4134
    goto ldv_44458;
  } else {

  }
#line 4138
  *d_ptr = data_ptr;
#line 4139
  return;
}
}
#line 4142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_rdmux(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t s_stride ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_mux *mux_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 4145
  ha = vha->hw;
#line 4148
  data_ptr = *d_ptr;
#line 4150
  mux_hdr = (struct qla82xx_md_entry_mux *)entry_hdr;
#line 4151
  r_addr = mux_hdr->read_addr;
#line 4152
  s_addr = mux_hdr->select_addr;
#line 4153
  s_stride = mux_hdr->select_value_stride;
#line 4154
  s_value = mux_hdr->select_value;
#line 4155
  loop_cnt = mux_hdr->op_count;
#line 4157
  i = 0U;
#line 4157
  goto ldv_44477;
  ldv_44476: 
#line 4158
  qla82xx_md_rw_32(ha, s_addr, s_value, 1);
#line 4159
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 4159
  r_value = (uint32_t )tmp;
#line 4160
  tmp___0 = data_ptr;
#line 4160
  data_ptr = data_ptr + 1;
#line 4160
  *tmp___0 = s_value;
#line 4161
  tmp___1 = data_ptr;
#line 4161
  data_ptr = data_ptr + 1;
#line 4161
  *tmp___1 = r_value;
#line 4162
  s_value = s_value + s_stride;
#line 4157
  i = i + 1U;
  ldv_44477: ;
#line 4157
  if (i < loop_cnt) {
#line 4159
    goto ldv_44476;
  } else {

  }
#line 4164
  *d_ptr = data_ptr;
#line 4165
  return;
}
}
#line 4168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla82xx_md_entry_crb *crb_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 4171
  ha = vha->hw;
#line 4174
  data_ptr = *d_ptr;
#line 4176
  crb_hdr = (struct qla82xx_md_entry_crb *)entry_hdr;
#line 4177
  r_addr = crb_hdr->addr;
#line 4178
  r_stride = (uint32_t )crb_hdr->crb_strd.addr_stride;
#line 4179
  loop_cnt = crb_hdr->op_count;
#line 4181
  i = 0U;
#line 4181
  goto ldv_44493;
  ldv_44492: 
#line 4182
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 4182
  r_value = (uint32_t )tmp;
#line 4183
  tmp___0 = data_ptr;
#line 4183
  data_ptr = data_ptr + 1;
#line 4183
  *tmp___0 = r_addr;
#line 4184
  tmp___1 = data_ptr;
#line 4184
  data_ptr = data_ptr + 1;
#line 4184
  *tmp___1 = r_value;
#line 4185
  r_addr = r_addr + r_stride;
#line 4181
  i = i + 1U;
  ldv_44493: ;
#line 4181
  if (i < loop_cnt) {
#line 4183
    goto ldv_44492;
  } else {

  }
#line 4187
  *d_ptr = data_ptr;
#line 4188
  return;
}
}
#line 4191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_minidump_process_l2tag(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  unsigned long p_wait ;
  unsigned long w_time ;
  unsigned long p_mask ;
  uint32_t c_value_w ;
  uint32_t c_value_r ;
  struct qla82xx_md_entry_cache *cache_hdr ;
  int rval ;
  uint32_t *data_ptr ;
  int tmp ;
  int tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 4194
  ha = vha->hw;
#line 4200
  rval = 258;
#line 4201
  data_ptr = *d_ptr;
#line 4203
  cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
#line 4204
  loop_count = cache_hdr->op_count;
#line 4205
  r_addr = cache_hdr->read_addr;
#line 4206
  c_addr = cache_hdr->control_addr;
#line 4207
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 4209
  t_r_addr = cache_hdr->tag_reg_addr;
#line 4210
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 4211
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 4212
  p_wait = (unsigned long )cache_hdr->cache_ctrl.poll_wait;
#line 4213
  p_mask = (unsigned long )cache_hdr->cache_ctrl.poll_mask;
#line 4215
  i = 0U;
#line 4215
  goto ldv_44531;
  ldv_44530: 
#line 4216
  qla82xx_md_rw_32(ha, t_r_addr, t_value, 1);
#line 4217
  if (c_value_w != 0U) {
#line 4218
    qla82xx_md_rw_32(ha, c_addr, c_value_w, 1);
  } else {

  }
#line 4220
  if (p_mask != 0UL) {
#line 4221
    w_time = (unsigned long )jiffies + p_wait;
    ldv_44526: 
#line 4223
    tmp = qla82xx_md_rw_32(ha, c_addr, 0U, 0);
#line 4223
    c_value_r = (uint32_t )tmp;
#line 4224
    if (((unsigned long )c_value_r & p_mask) == 0UL) {
#line 4225
      goto ldv_44519;
    } else
#line 4226
    if ((long )((unsigned long )jiffies - w_time) >= 0L) {
#line 4228
      ql_dbg(524288U, vha, 45106, "c_value_r: 0x%x, poll_mask: 0x%lx, w_time: 0x%lx\n",
             c_value_r, p_mask, w_time);
#line 4232
      return (rval);
    } else {

    }
#line 4234
    goto ldv_44526;
    ldv_44519: ;
  } else {

  }
#line 4237
  addr = r_addr;
#line 4238
  k = 0U;
#line 4238
  goto ldv_44528;
  ldv_44527: 
#line 4239
  tmp___0 = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 4239
  r_value = (uint32_t )tmp___0;
#line 4240
  tmp___1 = data_ptr;
#line 4240
  data_ptr = data_ptr + 1;
#line 4240
  *tmp___1 = r_value;
#line 4241
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 4238
  k = k + 1U;
  ldv_44528: ;
#line 4238
  if (k < r_cnt) {
#line 4240
    goto ldv_44527;
  } else {

  }
#line 4243
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 4215
  i = i + 1U;
  ldv_44531: ;
#line 4215
  if (i < loop_count) {
#line 4217
    goto ldv_44530;
  } else {

  }
#line 4245
  *d_ptr = data_ptr;
#line 4246
  return (0);
}
}
#line 4250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_l1cache(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                             uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  uint32_t c_value_w ;
  struct qla82xx_md_entry_cache *cache_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 4253
  ha = vha->hw;
#line 4258
  data_ptr = *d_ptr;
#line 4260
  cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
#line 4261
  loop_count = cache_hdr->op_count;
#line 4262
  r_addr = cache_hdr->read_addr;
#line 4263
  c_addr = cache_hdr->control_addr;
#line 4264
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 4266
  t_r_addr = cache_hdr->tag_reg_addr;
#line 4267
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 4268
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 4270
  i = 0U;
#line 4270
  goto ldv_44556;
  ldv_44555: 
#line 4271
  qla82xx_md_rw_32(ha, t_r_addr, t_value, 1);
#line 4272
  qla82xx_md_rw_32(ha, c_addr, c_value_w, 1);
#line 4273
  addr = r_addr;
#line 4274
  k = 0U;
#line 4274
  goto ldv_44553;
  ldv_44552: 
#line 4275
  tmp = qla82xx_md_rw_32(ha, addr, 0U, 0);
#line 4275
  r_value = (uint32_t )tmp;
#line 4276
  tmp___0 = data_ptr;
#line 4276
  data_ptr = data_ptr + 1;
#line 4276
  *tmp___0 = r_value;
#line 4277
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 4274
  k = k + 1U;
  ldv_44553: ;
#line 4274
  if (k < r_cnt) {
#line 4276
    goto ldv_44552;
  } else {

  }
#line 4279
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 4270
  i = i + 1U;
  ldv_44556: ;
#line 4270
  if (i < loop_count) {
#line 4272
    goto ldv_44555;
  } else {

  }
#line 4281
  *d_ptr = data_ptr;
#line 4282
  return;
}
}
#line 4285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_queue(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t s_addr ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t r_value ;
  uint32_t r_cnt ;
  uint32_t qid ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_queue *q_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 4288
  ha = vha->hw;
#line 4290
  qid = 0U;
#line 4293
  data_ptr = *d_ptr;
#line 4295
  q_hdr = (struct qla82xx_md_entry_queue *)entry_hdr;
#line 4296
  s_addr = q_hdr->select_addr;
#line 4297
  r_cnt = (uint32_t )q_hdr->rd_strd.read_addr_cnt;
#line 4298
  r_stride = (uint32_t )q_hdr->rd_strd.read_addr_stride;
#line 4299
  loop_cnt = q_hdr->op_count;
#line 4301
  i = 0U;
#line 4301
  goto ldv_44579;
  ldv_44578: 
#line 4302
  qla82xx_md_rw_32(ha, s_addr, qid, 1);
#line 4303
  r_addr = q_hdr->read_addr;
#line 4304
  k = 0U;
#line 4304
  goto ldv_44576;
  ldv_44575: 
#line 4305
  tmp = qla82xx_md_rw_32(ha, r_addr, 0U, 0);
#line 4305
  r_value = (uint32_t )tmp;
#line 4306
  tmp___0 = data_ptr;
#line 4306
  data_ptr = data_ptr + 1;
#line 4306
  *tmp___0 = r_value;
#line 4307
  r_addr = r_addr + r_stride;
#line 4304
  k = k + 1U;
  ldv_44576: ;
#line 4304
  if (k < r_cnt) {
#line 4306
    goto ldv_44575;
  } else {

  }
#line 4309
  qid = (uint32_t )q_hdr->q_strd.queue_id_stride + qid;
#line 4301
  i = i + 1U;
  ldv_44579: ;
#line 4301
  if (i < loop_cnt) {
#line 4303
    goto ldv_44578;
  } else {

  }
#line 4311
  *d_ptr = data_ptr;
#line 4312
  return;
}
}
#line 4315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_minidump_process_rdrom(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t i ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_rdrom *rom_hdr ;
  uint32_t *data_ptr ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 4318
  ha = vha->hw;
#line 4322
  data_ptr = *d_ptr;
#line 4324
  rom_hdr = (struct qla82xx_md_entry_rdrom *)entry_hdr;
#line 4325
  r_addr = rom_hdr->read_addr;
#line 4326
  loop_cnt = rom_hdr->read_data_size / 4U;
#line 4328
  i = 0U;
#line 4328
  goto ldv_44594;
  ldv_44593: 
#line 4329
  qla82xx_md_rw_32(ha, 1108410416U, r_addr & 4294901760U, 1);
#line 4331
  tmp = qla82xx_md_rw_32(ha, (r_addr & 65535U) + 1108672512U, 0U, 0);
#line 4331
  r_value = (uint32_t )tmp;
#line 4334
  tmp___0 = data_ptr;
#line 4334
  data_ptr = data_ptr + 1;
#line 4334
  *tmp___0 = r_value;
#line 4335
  r_addr = r_addr + 4U;
#line 4328
  i = i + 1U;
  ldv_44594: ;
#line 4328
  if (i < loop_cnt) {
#line 4330
    goto ldv_44593;
  } else {

  }
#line 4337
  *d_ptr = data_ptr;
#line 4338
  return;
}
}
#line 4341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static int qla82xx_minidump_process_rdmem(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t r_data ;
  uint32_t i ;
  uint32_t j ;
  uint32_t loop_cnt ;
  struct qla82xx_md_entry_rdmem *m_hdr ;
  int rval ;
  uint32_t *data_ptr ;
  int tmp ;
  struct ratelimit_state _rs ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 4344
  ha = vha->hw;
#line 4349
  rval = 258;
#line 4350
  data_ptr = *d_ptr;
#line 4352
  m_hdr = (struct qla82xx_md_entry_rdmem *)entry_hdr;
#line 4353
  r_addr = m_hdr->read_addr;
#line 4354
  loop_cnt = m_hdr->read_data_size / 16U;
#line 4356
  if ((r_addr & 15U) != 0U) {
#line 4357
    ql_log(1U, vha, 45107, "Read addr 0x%x not 16 bytes aligned\n", r_addr);
#line 4359
    return (rval);
  } else {

  }
#line 4362
  if ((m_hdr->read_data_size & 15U) != 0U) {
#line 4363
    ql_log(1U, vha, 45108, "Read data[0x%x] not multiple of 16 bytes\n", m_hdr->read_data_size);
#line 4366
    return (rval);
  } else {

  }
#line 4369
  ql_dbg(524288U, vha, 45109, "[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",
         "qla82xx_minidump_process_rdmem", r_addr, m_hdr->read_data_size, loop_cnt);
#line 4373
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 4374
  i = 0U;
#line 4374
  goto ldv_44622;
  ldv_44621: 
#line 4375
  qla82xx_md_rw_32(ha, 1090519188U, r_addr, 1);
#line 4376
  r_value = 0U;
#line 4377
  qla82xx_md_rw_32(ha, 1090519192U, r_value, 1);
#line 4378
  r_value = 2U;
#line 4379
  qla82xx_md_rw_32(ha, 1090519184U, r_value, 1);
#line 4380
  r_value = 3U;
#line 4381
  qla82xx_md_rw_32(ha, 1090519184U, r_value, 1);
#line 4383
  j = 0U;
#line 4383
  goto ldv_44615;
  ldv_44614: 
#line 4384
  tmp = qla82xx_md_rw_32(ha, 1090519184U, 0U, 0);
#line 4384
  r_value = (uint32_t )tmp;
#line 4386
  if ((r_value & 8U) == 0U) {
#line 4387
    goto ldv_44613;
  } else {

  }
#line 4383
  j = j + 1U;
  ldv_44615: ;
#line 4383
  if (j <= 999U) {
#line 4385
    goto ldv_44614;
  } else {

  }
  ldv_44613: ;
#line 4390
  if (j > 999U) {
#line 4391
    _rs.lock.raw_lock.ldv_1464.head_tail = 0U;
#line 4391
    _rs.lock.magic = 3735899821U;
#line 4391
    _rs.lock.owner_cpu = 4294967295U;
#line 4391
    _rs.lock.owner = (void *)-1;
#line 4391
    _rs.lock.dep_map.key = 0;
#line 4391
    _rs.lock.dep_map.class_cache[0] = 0;
#line 4391
    _rs.lock.dep_map.class_cache[1] = 0;
#line 4391
    _rs.lock.dep_map.name = "_rs.lock";
#line 4391
    _rs.lock.dep_map.cpu = 0;
#line 4391
    _rs.lock.dep_map.ip = 0UL;
#line 4391
    _rs.interval = 1250;
#line 4391
    _rs.burst = 10;
#line 4391
    _rs.printed = 0;
#line 4391
    _rs.missed = 0;
#line 4391
    _rs.begin = 0UL;
#line 4391
    tmp___0 = ___ratelimit(& _rs, "qla82xx_minidump_process_rdmem");
#line 4391
    if (tmp___0 != 0) {
#line 4391
      printk("\vfailed to read through agent\n");
    } else {

    }
#line 4393
    ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 4394
    return (rval);
  } else {

  }
#line 4397
  j = 0U;
#line 4397
  goto ldv_44619;
  ldv_44618: 
#line 4398
  tmp___1 = qla82xx_md_rw_32(ha, (uint32_t )MD_MIU_TEST_AGT_RDDATA[j], 0U, 0);
#line 4398
  r_data = (uint32_t )tmp___1;
#line 4400
  tmp___2 = data_ptr;
#line 4400
  data_ptr = data_ptr + 1;
#line 4400
  *tmp___2 = r_data;
#line 4397
  j = j + 1U;
  ldv_44619: ;
#line 4397
  if (j <= 3U) {
#line 4399
    goto ldv_44618;
  } else {

  }
#line 4402
  r_addr = r_addr + 16U;
#line 4374
  i = i + 1U;
  ldv_44622: ;
#line 4374
  if (i < loop_cnt) {
#line 4376
    goto ldv_44621;
  } else {

  }
#line 4404
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 4405
  *d_ptr = data_ptr;
#line 4406
  return (0);
}
}
#line 4410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_validate_template_chksum(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint64_t chksum ;
  uint32_t *d_ptr ;
  int count ;
  uint32_t *tmp ;
  int tmp___0 ;

  {
#line 4412
  ha = vha->hw;
#line 4413
  chksum = 0ULL;
#line 4414
  d_ptr = (uint32_t *)ha->md_tmplt_hdr;
#line 4415
  count = (int )(ha->md_template_size / 4U);
#line 4417
  goto ldv_44632;
  ldv_44631: 
#line 4418
  tmp = d_ptr;
#line 4418
  d_ptr = d_ptr + 1;
#line 4418
  chksum = (uint64_t )*tmp + chksum;
  ldv_44632: 
#line 4417
  tmp___0 = count;
#line 4417
  count = count - 1;
#line 4417
  if (tmp___0 > 0) {
#line 4419
    goto ldv_44631;
  } else {

  }

#line 4419
  goto ldv_44635;
  ldv_44634: 
#line 4420
  chksum = (chksum & 4294967295ULL) + (chksum >> 32);
  ldv_44635: ;
#line 4419
  if (chksum >> 32 != 0ULL) {
#line 4421
    goto ldv_44634;
  } else {

  }

#line 4421
  return (~ ((int )chksum));
}
}
#line 4425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
static void qla82xx_mark_entry_skipped(scsi_qla_host_t *vha , qla82xx_md_entry_hdr_t *entry_hdr ,
                                       int index ) 
{ 


  {
#line 4428
  entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 4429
  ql_dbg(524288U, vha, 45110, "Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n", index,
         entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4434
  return;
}
}
#line 4437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_md_collect(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int no_entry_hdr ;
  qla82xx_md_entry_hdr_t *entry_hdr ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;
  uint32_t *data_ptr ;
  uint32_t total_data_size ;
  uint32_t f_capture_mask ;
  uint32_t data_collected ;
  int i ;
  int rval ;
  int tmp ;

  {
#line 4439
  ha = vha->hw;
#line 4440
  no_entry_hdr = 0;
#line 4444
  total_data_size = 0U;
#line 4444
  data_collected = 0U;
#line 4445
  i = 0;
#line 4445
  rval = 258;
#line 4447
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 4448
  data_ptr = (uint32_t *)ha->md_dump;
#line 4450
  if (ha->fw_dumped != 0) {
#line 4451
    ql_log(1U, vha, 45111, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 4454
    goto md_failed;
  } else {

  }
#line 4457
  ha->fw_dumped = 0;
#line 4459
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0) || (unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 4460
    ql_log(1U, vha, 45112, "Memory not allocated for minidump capture\n");
#line 4462
    goto md_failed;
  } else {

  }
#line 4465
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 4466
    ql_log(1U, vha, 45140, "Forced reset from application, ignore minidump capture\n");
#line 4469
    ha->flags.isp82xx_no_md_cap = 0U;
#line 4470
    goto md_failed;
  } else {

  }
#line 4473
  tmp = qla82xx_validate_template_chksum(vha);
#line 4473
  if (tmp != 0) {
#line 4474
    ql_log(2U, vha, 45113, "Template checksum validation error\n");
#line 4476
    goto md_failed;
  } else {

  }
#line 4479
  no_entry_hdr = (int )tmplt_hdr->num_of_entries;
#line 4480
  ql_dbg(524288U, vha, 45114, "No of entry headers in Template: 0x%x\n", no_entry_hdr);
#line 4483
  ql_dbg(524288U, vha, 45115, "Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);
#line 4486
  f_capture_mask = tmplt_hdr->capture_debug_level & 255U;
#line 4489
  if ((f_capture_mask & 3U) != 3U) {
#line 4490
    ql_log(1U, vha, 45116, "Minimum required capture mask[0x%x] level not set\n",
           f_capture_mask);
#line 4493
    goto md_failed;
  } else {

  }
#line 4495
  tmplt_hdr->driver_capture_mask = (uint32_t )ql2xmdcapmask;
#line 4497
  tmplt_hdr->driver_info[0] = (uint32_t )vha->host_no;
#line 4498
  tmplt_hdr->driver_info[1] = 134610944U;
#line 4502
  total_data_size = ha->md_dump_size;
#line 4504
  ql_dbg(524288U, vha, 45117, "Total minidump data_size 0x%x to be captured\n", total_data_size);
#line 4508
  if (tmplt_hdr->entry_type != 99U) {
#line 4509
    ql_log(1U, vha, 45134, "Bad template header entry type: 0x%x obtained\n", tmplt_hdr->entry_type);
#line 4512
    goto md_failed;
  } else {

  }
#line 4515
  entry_hdr = (qla82xx_md_entry_hdr_t *)ha->md_tmplt_hdr + (unsigned long )tmplt_hdr->first_entry_offset;
#line 4519
  i = 0;
#line 4519
  goto ldv_44677;
  ldv_44676: ;
#line 4521
  if (data_collected > total_data_size) {
#line 4522
    ql_log(1U, vha, 45118, "More MiniDump data collected: [0x%x]\n", data_collected);
#line 4525
    goto md_failed;
  } else {

  }
#line 4528
  if (((int )entry_hdr->d_ctrl.entry_capture_mask & ql2xmdcapmask) == 0) {
#line 4530
    entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 4532
    ql_dbg(524288U, vha, 45119, "Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",
           i, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4537
    goto skip_nxt_entry;
  } else {

  }
#line 4540
  ql_dbg(524288U, vha, 45120, "[%s]: data ptr[%d]: %p, entry_hdr: %p\nentry_type: 0x%x, captrue_mask: 0x%x\n",
         "qla82xx_md_collect", i, data_ptr, entry_hdr, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 4547
  ql_dbg(524288U, vha, 45121, "Data collected: [0x%x], Dump size left:[0x%x]\n", data_collected,
         ha->md_dump_size - data_collected);
#line 4553
  switch (entry_hdr->entry_type) {
  case 255U: 
#line 4555
  qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4556
  goto ldv_44659;
  case 98U: 
#line 4558
  rval = qla82xx_minidump_process_control(vha, entry_hdr, & data_ptr);
#line 4560
  if (rval != 0) {
#line 4561
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4562
    goto md_failed;
  } else {

  }
#line 4564
  goto ldv_44659;
  case 1U: 
#line 4566
  qla82xx_minidump_process_rdcrb(vha, entry_hdr, & data_ptr);
#line 4568
  goto ldv_44659;
  case 72U: 
#line 4570
  rval = qla82xx_minidump_process_rdmem(vha, entry_hdr, & data_ptr);
#line 4572
  if (rval != 0) {
#line 4573
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4574
    goto md_failed;
  } else {

  }
#line 4576
  goto ldv_44659;
  case 4U: ;
  case 71U: 
#line 4579
  qla82xx_minidump_process_rdrom(vha, entry_hdr, & data_ptr);
#line 4581
  goto ldv_44659;
  case 21U: ;
  case 22U: ;
  case 23U: ;
  case 24U: 
#line 4586
  rval = qla82xx_minidump_process_l2tag(vha, entry_hdr, & data_ptr);
#line 4588
  if (rval != 0) {
#line 4589
    qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4590
    goto md_failed;
  } else {

  }
#line 4592
  goto ldv_44659;
  case 11U: ;
  case 12U: 
#line 4595
  qla82xx_minidump_process_l1cache(vha, entry_hdr, & data_ptr);
#line 4597
  goto ldv_44659;
  case 6U: 
#line 4599
  qla82xx_minidump_process_rdocm(vha, entry_hdr, & data_ptr);
#line 4601
  goto ldv_44659;
  case 2U: 
#line 4603
  qla82xx_minidump_process_rdmux(vha, entry_hdr, & data_ptr);
#line 4605
  goto ldv_44659;
  case 3U: 
#line 4607
  qla82xx_minidump_process_queue(vha, entry_hdr, & data_ptr);
#line 4609
  goto ldv_44659;
  case 0U: ;
  default: 
#line 4612
  qla82xx_mark_entry_skipped(vha, entry_hdr, i);
#line 4613
  goto ldv_44659;
  }
  ldv_44659: 
#line 4616
  ql_dbg(524288U, vha, 45122, "[%s]: data ptr[%d]: %p\n", "qla82xx_md_collect", i,
         data_ptr);
#line 4619
  data_collected = (uint32_t )((long )data_ptr) - (uint32_t )((long )ha->md_dump);
  skip_nxt_entry: 
#line 4622
  entry_hdr = entry_hdr + (unsigned long )entry_hdr->entry_size;
#line 4519
  i = i + 1;
  ldv_44677: ;
#line 4519
  if (i < no_entry_hdr) {
#line 4521
    goto ldv_44676;
  } else {

  }

#line 4626
  if (data_collected != total_data_size) {
#line 4627
    ql_dbg(524288U, vha, 45123, "MiniDump data mismatch: Data collected: [0x%x],total_data_size:[0x%x]\n",
           data_collected, total_data_size);
#line 4631
    goto md_failed;
  } else {

  }
#line 4634
  ql_log(2U, vha, 45124, "Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",
         vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);
#line 4637
  ha->fw_dumped = 1;
#line 4638
  qla2x00_post_uevent_work(vha, 0U);
  md_failed: ;
#line 4641
  return (rval);
}
}
#line 4645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_md_alloc(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int i ;
  int k ;
  struct qla82xx_md_template_hdr *tmplt_hdr ;

  {
#line 4647
  ha = vha->hw;
#line 4651
  tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
#line 4653
  if (ql2xmdcapmask <= 2 || ql2xmdcapmask > 127) {
#line 4654
    ql2xmdcapmask = (int )tmplt_hdr->capture_debug_level & 255;
#line 4655
    ql_log(2U, vha, 45125, "Forcing driver capture mask to firmware default capture mask: 0x%x.\n",
           ql2xmdcapmask);
  } else {

  }
#line 4660
  i = 2;
#line 4660
  k = 1;
#line 4660
  goto ldv_44687;
  ldv_44686: ;
#line 4661
  if ((i & ql2xmdcapmask) != 0) {
#line 4662
    ha->md_dump_size = ha->md_dump_size + tmplt_hdr->capture_size_array[k];
  } else {

  }
#line 4660
  i = i << 1;
#line 4660
  k = k + 1;
  ldv_44687: ;
#line 4660
  if ((i & 255) != 0) {
#line 4662
    goto ldv_44686;
  } else {

  }

#line 4665
  if ((unsigned long )ha->md_dump != (unsigned long )((void *)0)) {
#line 4666
    ql_log(1U, vha, 45126, "Firmware dump previously allocated.\n");
#line 4668
    return (1);
  } else {

  }
#line 4671
  ha->md_dump = vmalloc((unsigned long )ha->md_dump_size);
#line 4672
  if ((unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 4673
    ql_log(1U, vha, 45127, "Unable to allocate memory for Minidump size (0x%x).\n",
           ha->md_dump_size);
#line 4676
    return (1);
  } else {

  }
#line 4678
  return (0);
}
}
#line 4682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_md_free(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4684
  ha = vha->hw;
#line 4687
  if ((unsigned long )ha->md_tmplt_hdr != (unsigned long )((void *)0)) {
#line 4688
    ql_log(2U, vha, 45128, "Free MiniDump template: %p, size (%d KB)\n", ha->md_tmplt_hdr,
           ha->md_template_size / 1024U);
#line 4691
    dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size, ha->md_tmplt_hdr,
                   ha->md_tmplt_hdr_dma, (struct dma_attrs *)0);
#line 4693
    ha->md_tmplt_hdr = (void *)0;
  } else {

  }
#line 4697
  if ((unsigned long )ha->md_dump != (unsigned long )((void *)0)) {
#line 4698
    ql_log(2U, vha, 45129, "Free MiniDump memory: %p, size (%d KB)\n", ha->md_dump,
           ha->md_dump_size / 1024U);
#line 4701
    vfree((void const   *)ha->md_dump);
#line 4702
    ha->md_dump_size = 0U;
#line 4703
    ha->md_dump = (void *)0;
  } else {

  }
#line 4705
  return;
}
}
#line 4708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void qla82xx_md_prep(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;

  {
#line 4710
  ha = vha->hw;
#line 4714
  rval = qla82xx_md_get_template_size(vha);
#line 4715
  if (rval == 0) {
#line 4716
    ql_log(2U, vha, 45130, "MiniDump Template size obtained (%d KB)\n", ha->md_template_size / 1024U);
#line 4721
    if ((ha->device_type & 262144U) != 0U) {
#line 4722
      rval = qla8044_md_get_template(vha);
    } else {
#line 4724
      rval = qla82xx_md_get_template(vha);
    }
#line 4726
    if (rval == 0) {
#line 4727
      ql_dbg(524288U, vha, 45131, "MiniDump Template obtained\n");
#line 4731
      rval = qla82xx_md_alloc(vha);
#line 4732
      if (rval == 0) {
#line 4733
        ql_log(2U, vha, 45132, "MiniDump memory allocated (%d KB)\n", ha->md_dump_size / 1024U);
      } else {
#line 4737
        ql_log(2U, vha, 45133, "Free MiniDump template: %p, size: (%d KB)\n", ha->md_tmplt_hdr,
               ha->md_template_size / 1024U);
#line 4741
        dma_free_attrs(& (ha->pdev)->dev, (size_t )ha->md_template_size, ha->md_tmplt_hdr,
                       ha->md_tmplt_hdr_dma, (struct dma_attrs *)0);
#line 4744
        ha->md_tmplt_hdr = (void *)0;
      }
    } else {

    }
  } else {

  }
#line 4748
  return;
}
}
#line 4752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_beacon_on(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 4756
  ha = vha->hw;
#line 4757
  qla82xx_idc_lock(ha);
#line 4758
  rval = qla82xx_mbx_beacon_ctl(vha, 1);
#line 4760
  if (rval != 0) {
#line 4761
    ql_log(1U, vha, 45136, "mbx set led config failed in %s\n", "qla82xx_beacon_on");
#line 4763
    goto exit;
  } else {

  }
#line 4765
  ha->beacon_blink_led = 1U;
  exit: 
#line 4767
  qla82xx_idc_unlock(ha);
#line 4768
  return (rval);
}
}
#line 4772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int qla82xx_beacon_off(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;

  {
#line 4776
  ha = vha->hw;
#line 4777
  qla82xx_idc_lock(ha);
#line 4778
  rval = qla82xx_mbx_beacon_ctl(vha, 0);
#line 4780
  if (rval != 0) {
#line 4781
    ql_log(1U, vha, 45137, "mbx set led config failed in %s\n", "qla82xx_beacon_off");
#line 4783
    goto exit;
  } else {

  }
#line 4785
  ha->beacon_blink_led = 0U;
  exit: 
#line 4787
  qla82xx_idc_unlock(ha);
#line 4788
  return (rval);
}
}
#line 4792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void activate_pending_timer_14(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 4792
  if ((unsigned long )ldv_timer_list_14 == (unsigned long )timer) {
#line 4793
    if (ldv_timer_state_14 == 2 || pending_flag != 0) {
#line 4794
      ldv_timer_list_14 = timer;
#line 4795
      ldv_timer_list_14->data = data;
#line 4796
      ldv_timer_state_14 = 1;
    } else {

    }
#line 4798
    return;
  } else {

  }
#line 4800
  reg_timer_14(timer);
#line 4801
  ldv_timer_list_14->data = data;
#line 4802
  return;
}
}
#line 4805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int reg_timer_14(struct timer_list *timer ) 
{ 


  {
#line 4806
  ldv_timer_list_14 = timer;
#line 4807
  ldv_timer_state_14 = 1;
#line 4808
  return (0);
}
}
#line 4811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void disable_suitable_timer_14(struct timer_list *timer ) 
{ 


  {
#line 4812
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_14) {
#line 4813
    ldv_timer_state_14 = 0;
#line 4814
    return;
  } else {

  }
#line 4816
  return;
}
}
#line 4819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
void choose_timer_14(struct timer_list *timer ) 
{ 


  {
#line 4820
  LDV_IN_INTERRUPT = 2;
#line 4821
  (*(timer->function))(timer->data);
#line 4822
  LDV_IN_INTERRUPT = 1;
#line 4823
  ldv_timer_state_14 = 2;
#line 4824
  return;
}
}
#line 4826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int ldv_del_timer_69(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 4830
  tmp = del_timer(ldv_func_arg1);
#line 4830
  ldv_func_res = tmp;
#line 4832
  disable_suitable_timer_7(ldv_func_arg1);
#line 4834
  return (ldv_func_res);
}
}
#line 4837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx.o.c.prepared"
int ldv_scsi_add_host_with_dma_70(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 4841
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 4841
  ldv_func_res = tmp;
#line 4843
  if (ldv_func_res == 0) {
#line 4844
    ldv_state_variable_72 = 1;
#line 4844
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 4848
  return (ldv_func_res);
}
}
#line 11 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 35
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 63 "include/linux/string.h"
extern char *strim(char * ) ;
#line 79 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 156 "include/linux/time.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 178 "include/linux/timer.h"
int ldv_del_timer_73(struct timer_list *ldv_func_arg1 ) ;
#line 209 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 211
  __len = count;
#line 211
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 213
  return;
}
}
#line 215 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 217
  __len = count;
#line 217
  __ret = __builtin_memcpy((void *)dst, src, __len);
#line 219
  return;
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int reg_timer_15(struct timer_list *timer ) ;
#line 239
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 259
void choose_timer_15(struct timer_list *timer ) ;
#line 281
void disable_suitable_timer_15(struct timer_list *timer ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_74(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 2034 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_def.h"
static char const   * const  port_state_str___4[5U]  = {      "Unknown",      "UNCONFIGURED",      "DEAD",      "LOST", 
        "ONLINE"};
#line 83 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void host_to_adap(uint8_t *src , uint8_t *dst , uint32_t bsize ) 
{ 
  uint32_t *isrc ;
  __le32 *odest ;
  uint32_t iter ;
  __le32 *tmp ;
  uint32_t *tmp___0 ;

  {
#line 85
  isrc = (uint32_t *)src;
#line 86
  odest = (__le32 *)dst;
#line 87
  iter = bsize >> 2;
#line 89
  goto ldv_43333;
  ldv_43332: 
#line 90
  tmp = odest;
#line 90
  odest = odest + 1;
#line 90
  tmp___0 = isrc;
#line 90
  isrc = isrc + 1;
#line 90
  *tmp = *tmp___0;
#line 89
  iter = iter - 1U;
  ldv_43333: ;
#line 89
  if (iter != 0U) {
#line 91
    goto ldv_43332;
  } else {

  }

#line 96
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_inline.h"
__inline static void qla2x00_set_fcport_state___3(fc_port_t *fcport , int state ) 
{ 
  int old_state ;

  {
#line 154
  old_state = atomic_read((atomic_t const   *)(& fcport->state));
#line 155
  atomic_set(& fcport->state, state);
#line 158
  if (old_state != 0 && old_state != state) {
#line 159
    ql_dbg(268435456U, fcport->vha, 8317, "FCPort state transitioned from %s to %s - portid=%02x%02x%02x.\n",
           port_state_str___4[old_state], port_state_str___4[state], (int )fcport->d_id.b.domain,
           (int )fcport->d_id.b.area, (int )fcport->d_id.b.al_pa);
  } else {

  }
#line 165
  return;
}
}
#line 48 "include/linux/delay.h"
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 71 "include/linux/utsname.h"
__inline static struct new_utsname *utsname(void) 
{ 
  struct task_struct *tmp ;

  {
#line 73
  tmp = get_current();
#line 73
  return (& ((tmp->nsproxy)->uts_ns)->name);
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_mailbox_command(scsi_qla_host_t *vha , struct mbx_cmd_32 *mcp ) 
{ 
  int rval ;
  unsigned long flags ;
  device_reg_t *reg ;
  uint8_t abort_active ;
  uint8_t io_lock_on ;
  uint16_t command ;
  uint32_t *iptr ;
  uint32_t *optr ;
  uint32_t cnt ;
  uint32_t mboxes ;
  unsigned long wait_time ;
  struct qla_hw_data *ha ;
  scsi_qla_host_t *base_vha ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  uint32_t *iptr2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 341
  flags = 0UL;
#line 345
  command = 0U;
#line 351
  ha = vha->hw;
#line 352
  tmp = pci_get_drvdata(ha->pdev);
#line 352
  base_vha = (scsi_qla_host_t *)tmp;
#line 354
  if ((ha->pdev)->error_state > 2U) {
#line 355
    ql_log(1U, vha, 4444, "error_state is greater than pci_channel_io_frozen, exiting.\n");
#line 358
    return (256);
  } else {

  }
#line 361
  if ((vha->device_flags & 32U) != 0U) {
#line 362
    ql_log(1U, vha, 4447, "Device in failed state, exiting.\n");
#line 364
    return (256);
  } else {

  }
#line 367
  reg = ha->iobase;
#line 368
  io_lock_on = (uint8_t )base_vha->flags.init_done;
#line 370
  rval = 0;
#line 371
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& base_vha->dpc_flags));
#line 371
  abort_active = (uint8_t )tmp___0;
#line 373
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 374
    ql_log(1U, vha, 4469, "Perm failure on EEH timeout MBX, exiting.\n");
#line 376
    return (256);
  } else {

  }
#line 379
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 381
    mcp->mb[0] = 16395U;
#line 382
    ql_log(1U, vha, 4470, "FW hung = %d.\n", (int )ha->flags.isp82xx_fw_hung);
#line 384
    rval = 258;
#line 385
    goto premature_exit;
  } else {

  }
#line 393
  tmp___1 = wait_for_completion_timeout(& ha->mbx_cmd_comp, (unsigned long )(mcp->tov * 250U));
#line 393
  if (tmp___1 == 0UL) {
#line 395
    ql_log(1U, vha, 4471, "Cmd access timeout, cmd=0x%x, Exiting.\n", mcp->mb[0]);
#line 398
    return (256);
  } else {

  }
#line 401
  ha->flags.mbox_busy = 1U;
#line 403
  ha->mcp32 = mcp;
#line 405
  ql_dbg(536870912U, vha, 4472, "Prepare to issue mbox cmd=0x%x.\n", mcp->mb[0]);
#line 408
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 408
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 411
  optr = & reg->ispfx00.mailbox0;
#line 413
  iptr = (uint32_t *)(& mcp->mb);
#line 414
  command = (uint16_t )mcp->mb[0];
#line 415
  mboxes = mcp->out_mb;
#line 417
  cnt = 0U;
#line 417
  goto ldv_43566;
  ldv_43565: ;
#line 418
  if ((int )mboxes & 1) {
#line 419
    writel(*iptr, (void volatile   *)optr);
  } else {

  }
#line 421
  mboxes = mboxes >> 1;
#line 422
  optr = optr + 1;
#line 423
  iptr = iptr + 1;
#line 417
  cnt = cnt + 1U;
  ldv_43566: ;
#line 417
  if ((uint32_t )ha->mbx_count > cnt) {
#line 419
    goto ldv_43565;
  } else {

  }
#line 427
  ha->flags.mbox_int = 0U;
#line 428
  clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 430
  ql_dump_buffer(537001984U, vha, 4466, (uint8_t *)(& mcp->mb), 16U);
#line 432
  ql_dump_buffer(537001984U, vha, 4467, (uint8_t *)(& mcp->mb) + 16UL, 16U);
#line 434
  ql_dump_buffer(537001984U, vha, 4468, (uint8_t *)(& mcp->mb) + 32UL, 8U);
#line 438
  ql_dbg(536870912U, vha, 4473, "Going to unlock irq & waiting for interrupts. jiffies=%lx.\n",
         jiffies);
#line 443
  if (((unsigned int )abort_active == 0U && (unsigned int )io_lock_on != 0U) || ((((ha->device_type & 2048U) != 0U || (ha->device_type & 8192U) != 0U) || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) && *((unsigned long *)ha + 2UL) != 0UL)) {
#line 444
    set_bit(2L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 446
    writel(ha->mbx_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 447
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 449
    wait_for_completion_timeout(& ha->mbx_intr_comp, (unsigned long )(mcp->tov * 250U));
  } else {
#line 451
    ql_dbg(536870912U, vha, 4396, "Cmd=%x Polling Mode.\n", (int )command);
#line 454
    writel(ha->mbx_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 455
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 457
    wait_time = (unsigned long )(mcp->tov * 250U) + (unsigned long )jiffies;
#line 458
    goto ldv_43576;
    ldv_43575: ;
#line 459
    if ((long )(wait_time - (unsigned long )jiffies) < 0L) {
#line 460
      goto ldv_43574;
    } else {

    }
#line 463
    qla2x00_poll(*(ha->rsp_q_map));
#line 465
    if (*((unsigned long *)ha + 2UL) == 0UL && ((ha->device_type & 2U) == 0U || (unsigned int )command != 11U)) {
#line 468
      usleep_range(10000UL, 11000UL);
    } else {

    }
    ldv_43576: ;
#line 458
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 460
      goto ldv_43575;
    } else {

    }
    ldv_43574: 
#line 470
    ql_dbg(536870912U, vha, 4397, "Waited %d sec.\n", (unsigned int )((((unsigned long )(mcp->tov * 250U) - wait_time) + (unsigned long )jiffies) / 250UL));
  }
#line 476
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 479
    ql_dbg(536870912U, vha, 4398, "Cmd=%x completed.\n", (int )command);
#line 483
    ha->flags.mbox_int = 0U;
#line 484
    clear_bit(1L, (unsigned long volatile   *)(& ha->mbx_cmd_flags));
#line 486
    if (ha->mailbox_out32[0] != 16384U) {
#line 487
      rval = 258;
    } else {

    }
#line 490
    iptr2 = (uint32_t *)(& mcp->mb);
#line 491
    iptr = (uint32_t *)(& ha->mailbox_out32);
#line 492
    mboxes = mcp->in_mb;
#line 493
    cnt = 0U;
#line 493
    goto ldv_43579;
    ldv_43578: ;
#line 494
    if ((int )mboxes & 1) {
#line 495
      *iptr2 = *iptr;
    } else {

    }
#line 497
    mboxes = mboxes >> 1;
#line 498
    iptr2 = iptr2 + 1;
#line 499
    iptr = iptr + 1;
#line 493
    cnt = cnt + 1U;
    ldv_43579: ;
#line 493
    if ((uint32_t )ha->mbx_count > cnt) {
#line 495
      goto ldv_43578;
    } else {

    }

  } else {
#line 503
    rval = 256;
  }
#line 506
  ha->flags.mbox_busy = 0U;
#line 509
  ha->mcp32 = (struct mbx_cmd_32 *)0;
#line 511
  if (((unsigned int )abort_active != 0U || (unsigned int )io_lock_on == 0U) && ((((ha->device_type & 2048U) == 0U && (ha->device_type & 8192U) == 0U) && ((ha->device_type & 32768U) == 0U && (ha->device_type & 65536U) == 0U)) || *((unsigned long *)ha + 2UL) == 0UL)) {
#line 512
    ql_dbg(536870912U, vha, 4410, "checking for additional resp interrupt.\n");
#line 516
    qla2x00_poll(*(ha->rsp_q_map));
  } else {

  }
#line 519
  if (rval == 256 && mcp->mb[0] != 42U) {
#line 521
    if (((unsigned int )io_lock_on == 0U || ((int )mcp->flags & 4) != 0) || *((unsigned long *)ha + 2UL) != 0UL) {
#line 524
      ql_dbg(536870912U, vha, 4445, "Timeout, schedule isp_abort_needed.\n");
#line 527
      tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 527
      if (tmp___3 == 0) {
#line 527
        tmp___4 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 527
        if (tmp___4 == 0) {
#line 527
          tmp___5 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 527
          if (tmp___5 == 0) {
#line 531
            ql_log(2U, base_vha, 4446, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP abort.\n",
                   (int )command, mcp->mb[0], (int )ha->flags.eeh_busy);
#line 536
            set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 537
            qla2xxx_wake_dpc(vha);
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 539
    if ((unsigned int )abort_active == 0U) {
#line 541
      ql_dbg(536870912U, vha, 4448, "Timeout, calling abort_isp.\n");
#line 544
      tmp___7 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 544
      if (tmp___7 == 0) {
#line 544
        tmp___8 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 544
        if (tmp___8 == 0) {
#line 544
          tmp___9 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 544
          if (tmp___9 == 0) {
#line 548
            ql_log(2U, base_vha, 4449, "Mailbox cmd timeout occurred, cmd=0x%x, mb[0]=0x%x. Scheduling ISP abort ",
                   (int )command, mcp->mb[0]);
#line 553
            set_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 554
            clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 555
            tmp___6 = (*((ha->isp_ops)->abort_isp))(vha);
#line 555
            if (tmp___6 != 0) {
#line 557
              set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
            } else {

            }
#line 560
            clear_bit(3L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 561
            ql_dbg(536870912U, vha, 4450, "Finished abort_isp.\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  premature_exit: 
#line 569
  complete(& ha->mbx_cmd_comp);
#line 571
  if (rval != 0) {
#line 572
    ql_log(1U, base_vha, 4451, "**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\n",
           mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3], (int )command);
  } else {
#line 577
    ql_dbg(536870912U, base_vha, 4452, "Done %s.\n", "qlafx00_mailbox_command");
  }
#line 580
  return (rval);
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_driver_shutdown(scsi_qla_host_t *vha , int tmo ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 601
  mcp = & mc;
#line 603
  ql_dbg(536903680U, vha, 4454, "Entered %s.\n", "qlafx00_driver_shutdown");
#line 606
  mcp->mb[0] = 106U;
#line 607
  mcp->out_mb = 1U;
#line 608
  mcp->in_mb = 1U;
#line 609
  if (tmo != 0) {
#line 610
    mcp->tov = (uint32_t )tmo;
  } else {
#line 612
    mcp->tov = 30U;
  }
#line 613
  mcp->flags = 0U;
#line 614
  rval = qlafx00_mailbox_command(vha, mcp);
#line 616
  if (rval != 0) {
#line 617
    ql_dbg(536870912U, vha, 4455, "Failed=%x.\n", rval);
  } else {
#line 620
    ql_dbg(536903680U, vha, 4456, "Done %s.\n", "qlafx00_driver_shutdown");
  }
#line 624
  return (rval);
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_get_firmware_state(scsi_qla_host_t *vha , uint32_t *states ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 647
  mcp = & mc;
#line 649
  ql_dbg(536903680U, vha, 4457, "Entered %s.\n", "qlafx00_get_firmware_state");
#line 652
  mcp->mb[0] = 105U;
#line 653
  mcp->out_mb = 1U;
#line 654
  mcp->in_mb = 3U;
#line 655
  mcp->tov = 30U;
#line 656
  mcp->flags = 0U;
#line 657
  rval = qlafx00_mailbox_command(vha, mcp);
#line 660
  *states = mcp->mb[1];
#line 662
  if (rval != 0) {
#line 663
    ql_dbg(536870912U, vha, 4458, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 666
    ql_dbg(536903680U, vha, 4459, "Done %s.\n", "qlafx00_get_firmware_state");
  }
#line 669
  return (rval);
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_init_firmware(scsi_qla_host_t *vha , uint16_t size ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;
  struct qla_hw_data *ha ;

  {
#line 694
  mcp = & mc;
#line 695
  ha = vha->hw;
#line 697
  ql_dbg(536903680U, vha, 4460, "Entered %s.\n", "qlafx00_init_firmware");
#line 700
  mcp->mb[0] = 96U;
#line 702
  mcp->mb[1] = 0U;
#line 703
  mcp->mb[2] = (unsigned int )(ha->init_cb_dma >> 32ULL);
#line 704
  mcp->mb[3] = (unsigned int )ha->init_cb_dma;
#line 706
  mcp->out_mb = 15U;
#line 707
  mcp->in_mb = 1U;
#line 708
  mcp->buf_size = (long )size;
#line 709
  mcp->flags = 2U;
#line 710
  mcp->tov = 30U;
#line 711
  rval = qlafx00_mailbox_command(vha, mcp);
#line 713
  if (rval != 0) {
#line 714
    ql_dbg(536870912U, vha, 4461, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 717
    ql_dbg(536903680U, vha, 4462, "Done %s.\n", "qlafx00_init_firmware");
  }
#line 720
  return (rval);
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_mbx_reg_test(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct mbx_cmd_32 mc ;
  struct mbx_cmd_32 *mcp ;

  {
#line 731
  mcp = & mc;
#line 733
  ql_dbg(536903680U, vha, 4463, "Entered %s.\n", "qlafx00_mbx_reg_test");
#line 737
  mcp->mb[0] = 6U;
#line 738
  mcp->mb[1] = 43690U;
#line 739
  mcp->mb[2] = 21845U;
#line 740
  mcp->mb[3] = 43605U;
#line 741
  mcp->mb[4] = 21930U;
#line 742
  mcp->mb[5] = 42405U;
#line 743
  mcp->mb[6] = 23130U;
#line 744
  mcp->mb[7] = 9509U;
#line 745
  mcp->mb[8] = 48059U;
#line 746
  mcp->mb[9] = 26214U;
#line 747
  mcp->mb[10] = 47974U;
#line 748
  mcp->mb[11] = 26299U;
#line 749
  mcp->mb[12] = 46774U;
#line 750
  mcp->mb[13] = 27499U;
#line 751
  mcp->mb[14] = 13878U;
#line 752
  mcp->mb[15] = 52428U;
#line 755
  mcp->out_mb = 65535U;
#line 757
  mcp->in_mb = 65535U;
#line 759
  mcp->buf_size = 0L;
#line 760
  mcp->flags = 2U;
#line 761
  mcp->tov = 30U;
#line 762
  rval = qlafx00_mailbox_command(vha, mcp);
#line 763
  if (rval == 0) {
#line 764
    if (((mcp->mb[17] != 43690U || mcp->mb[18] != 21845U) || mcp->mb[19] != 43605U) || mcp->mb[20] != 21930U) {
#line 766
      rval = 258;
    } else {

    }
#line 767
    if (((mcp->mb[21] != 42405U || mcp->mb[22] != 23130U) || mcp->mb[23] != 9509U) || mcp->mb[24] != 48059U) {
#line 769
      rval = 258;
    } else {

    }
#line 770
    if (((mcp->mb[25] != 26214U || mcp->mb[26] != 47974U) || mcp->mb[27] != 26299U) || mcp->mb[28] != 46774U) {
#line 772
      rval = 258;
    } else {

    }
#line 773
    if ((mcp->mb[29] != 27499U || mcp->mb[30] != 13878U) || mcp->mb[31] != 52428U) {
#line 775
      rval = 258;
    } else {

    }
  } else {

  }
#line 778
  if (rval != 0) {
#line 779
    ql_dbg(536870912U, vha, 4464, "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
  } else {
#line 782
    ql_dbg(536903680U, vha, 4465, "Done %s.\n", "qlafx00_mbx_reg_test");
  }
#line 785
  return (rval);
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_pci_config(struct scsi_qla_host *vha ) 
{ 
  uint16_t w ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 798
  ha = vha->hw;
#line 800
  pci_set_master(ha->pdev);
#line 801
  pci_try_set_mwi(ha->pdev);
#line 803
  pci_read_config_word((struct pci_dev  const  *)ha->pdev, 4, & w);
#line 804
  w = (uint16_t )((unsigned int )w | 320U);
#line 805
  w = (unsigned int )w & 64511U;
#line 806
  pci_write_config_word((struct pci_dev  const  *)ha->pdev, 4, (int )w);
#line 809
  tmp = pci_find_capability(ha->pdev, 16);
#line 809
  if (tmp != 0) {
#line 810
    pcie_set_readrq(ha->pdev, 2048);
  } else {

  }
#line 812
  ha->chip_revision = (uint16_t )(ha->pdev)->revision;
#line 814
  return (0);
}
}
#line 823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
__inline static void qlafx00_soc_cpu_reset(scsi_qla_host_t *vha ) 
{ 
  unsigned long flags ;
  struct qla_hw_data *ha ;
  int i ;
  int core ;
  uint32_t cnt ;
  raw_spinlock_t *tmp ;

  {
#line 825
  flags = 0UL;
#line 826
  ha = vha->hw;
#line 831
  i = 0;
#line 831
  goto ldv_43628;
  ldv_43627: 
#line 832
  writel(3841U, (void volatile   *)ha->cregbase + (unsigned long )((i + 16640) * 8));
#line 831
  i = i + 1;
  ldv_43628: ;
#line 831
  if (i <= 3) {
#line 833
    goto ldv_43627;
  } else {

  }
#line 837
  i = 0;
#line 837
  goto ldv_43631;
  ldv_43630: 
#line 838
  writel(16843009U, (void volatile   *)ha->cregbase + (unsigned long )(i * 8 + 133124));
#line 837
  i = i + 1;
  ldv_43631: ;
#line 837
  if (i <= 3) {
#line 839
    goto ldv_43630;
  } else {

  }
#line 843
  writel(18809089U, (void volatile   *)ha->cregbase + 133184U);
#line 846
  i = 0;
#line 846
  goto ldv_43634;
  ldv_43633: 
#line 847
  writel(0U, (void volatile   *)ha->cregbase + (unsigned long )((i + 33472) * 4));
#line 846
  i = i + 1;
  ldv_43634: ;
#line 846
  if (i <= 114) {
#line 848
    goto ldv_43633;
  } else {

  }
#line 852
  core = 0;
#line 852
  goto ldv_43640;
  ldv_43639: 
#line 853
  i = 0;
#line 853
  goto ldv_43637;
  ldv_43636: 
#line 854
  writel(0U, (void volatile   *)ha->cregbase + (unsigned long )(((core * 64 + i) + 34324) * 4));
#line 853
  i = i + 1;
  ldv_43637: ;
#line 853
  if (i <= 7) {
#line 855
    goto ldv_43636;
  } else {

  }
#line 852
  core = core + 1;
  ldv_43640: ;
#line 852
  if (core <= 3) {
#line 854
    goto ldv_43639;
  } else {

  }
#line 858
  core = 0;
#line 858
  goto ldv_43643;
  ldv_43642: 
#line 859
  writel(1023U, (void volatile   *)ha->cregbase + (unsigned long )(core * 256 + 137396));
#line 858
  core = core + 1;
  ldv_43643: ;
#line 858
  if (core <= 3) {
#line 860
    goto ldv_43642;
  } else {

  }
#line 863
  writel(2U, (void volatile   *)ha->cregbase + 131584U);
#line 864
  writel(3U, (void volatile   *)ha->cregbase + 131588U);
#line 866
  tmp = spinlock_check(& ha->hardware_lock);
#line 866
  flags = _raw_spin_lock_irqsave(tmp);
#line 869
  writel(0U, (void volatile   *)ha->cregbase + 133184U);
#line 872
  writel(3840U, (void volatile   *)ha->cregbase + 133120U);
#line 875
  cnt = 10U;
#line 875
  goto ldv_43649;
  ldv_43648: 
#line 876
  msleep(1000U);
#line 877
  __asm__  volatile   ("": : : "memory");
#line 875
  cnt = cnt - 1U;
  ldv_43649: ;
#line 875
  if (cnt != 0U) {
#line 877
    goto ldv_43648;
  } else {

  }
#line 879
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 880
  return;
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_soft_reset(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 891
  ha = vha->hw;
#line 893
  tmp = pci_channel_offline(ha->pdev);
#line 893
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 893
  if (tmp___0 != 0L) {
#line 893
    tmp___1 = ldv__builtin_expect(*((unsigned long *)ha + 2UL) != 0UL, 0L);
#line 893
    if (tmp___1 != 0L) {
#line 895
      return;
    } else {

    }
  } else {

  }
#line 897
  (*((ha->isp_ops)->disable_intrs))(ha);
#line 898
  qlafx00_soc_cpu_reset(vha);
#line 899
  (*((ha->isp_ops)->enable_intrs))(ha);
#line 900
  return;
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_chip_diag(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  struct req_que *req ;

  {
#line 911
  rval = 0;
#line 912
  ha = vha->hw;
#line 913
  req = *(ha->req_q_map);
#line 915
  ha->fw_transfer_size = (uint32_t )req->length * 64U;
#line 917
  rval = qlafx00_mbx_reg_test(vha);
#line 918
  if (rval != 0) {
#line 919
    ql_log(1U, vha, 4453, "Failed mailbox send register test\n");
  } else {
#line 923
    rval = 0;
  }
#line 925
  return (rval);
}
}
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  struct init_cb_fx *icb ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 931
  ha = vha->hw;
#line 932
  reg = & (ha->iobase)->ispfx00;
#line 934
  req = *(ha->req_q_map);
#line 935
  rsp = *(ha->rsp_q_map);
#line 938
  icb = (struct init_cb_fx *)ha->init_cb;
#line 939
  icb->request_q_outpointer = 0U;
#line 940
  icb->response_q_inpointer = 0U;
#line 941
  icb->request_q_length = req->length;
#line 942
  icb->response_q_length = rsp->length;
#line 943
  icb->request_q_address[0] = (unsigned int )req->dma;
#line 944
  icb->request_q_address[1] = (unsigned int )(req->dma >> 32ULL);
#line 945
  icb->response_q_address[0] = (unsigned int )rsp->dma;
#line 946
  icb->response_q_address[1] = (unsigned int )(rsp->dma >> 32ULL);
#line 948
  writel(0U, (void volatile   *)(& reg->req_q_in));
#line 949
  writel(0U, (void volatile   *)(& reg->req_q_out));
#line 951
  writel(0U, (void volatile   *)(& reg->rsp_q_in));
#line 952
  writel(0U, (void volatile   *)(& reg->rsp_q_out));
#line 955
  readl((void const volatile   *)(& reg->rsp_q_out));
#line 956
  return;
}
}
#line 959 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
char *qlafx00_pci_info_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;
  int pcie_reg ;

  {
#line 961
  ha = vha->hw;
#line 964
  pcie_reg = pci_find_capability(ha->pdev, 16);
#line 965
  if (pcie_reg != 0) {
#line 966
    strcpy(str, "PCIe iSA");
#line 967
    return (str);
  } else {

  }
#line 969
  return (str);
}
}
#line 973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
char *qlafx00_fw_version_str(struct scsi_qla_host *vha , char *str ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 975
  ha = vha->hw;
#line 977
  sprintf(str, "%s", (uint8_t *)(& ha->mr.fw_version));
#line 978
  return (str);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_enable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
#line 984
  flags = 0UL;
#line 986
  tmp = spinlock_check(& ha->hardware_lock);
#line 986
  flags = _raw_spin_lock_irqsave(tmp);
#line 987
  ha->interrupts_on = 1U;
#line 988
  tmp___0 = readl((void const volatile   *)ha->cregbase + 133896U);
#line 988
  writel(tmp___0 | 2147483648U, (void volatile   *)ha->cregbase + 133896U);
#line 989
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 990
  return;
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_disable_intrs(struct qla_hw_data *ha ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
#line 995
  flags = 0UL;
#line 997
  tmp = spinlock_check(& ha->hardware_lock);
#line 997
  flags = _raw_spin_lock_irqsave(tmp);
#line 998
  ha->interrupts_on = 0U;
#line 999
  tmp___0 = readl((void const volatile   *)ha->cregbase + 133896U);
#line 999
  writel(tmp___0 & 2147483647U, (void volatile   *)ha->cregbase + 133896U);
#line 1000
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1001
  return;
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_tmf_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *tmf ;

  {
#line 1006
  sp = (srb_t *)data;
#line 1007
  tmf = & sp->u.iocb_cmd;
#line 1009
  tmf->u.tmf.comp_status = 6U;
#line 1010
  complete(& tmf->u.tmf.comp);
#line 1011
  return;
}
}
#line 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_tmf_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *tmf ;

  {
#line 1016
  sp = (srb_t *)ptr;
#line 1017
  tmf = & sp->u.iocb_cmd;
#line 1019
  complete(& tmf->u.tmf.comp);
#line 1020
  return;
}
}
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_async_tm_cmd(fc_port_t *fcport , uint32_t flags , uint32_t lun ,
                                uint32_t tag ) 
{ 
  scsi_qla_host_t *vha ;
  struct srb_iocb *tm_iocb ;
  srb_t *sp ;
  int rval ;
  unsigned long tmp ;

  {
#line 1026
  vha = fcport->vha;
#line 1029
  rval = 258;
#line 1031
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 1032
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 1033
    goto done;
  } else {

  }
#line 1035
  tm_iocb = & sp->u.iocb_cmd;
#line 1036
  sp->type = 7U;
#line 1037
  sp->name = (char *)"tmf";
#line 1038
  tmp = qla2x00_get_async_timeout(vha);
#line 1038
  qla2x00_init_timer(sp, tmp);
#line 1039
  tm_iocb->u.tmf.flags = flags;
#line 1040
  tm_iocb->u.tmf.lun = lun;
#line 1041
  tm_iocb->u.tmf.data = tag;
#line 1042
  sp->done = & qlafx00_tmf_sp_done;
#line 1043
  tm_iocb->timeout = & qlafx00_tmf_iocb_timeout;
#line 1044
  init_completion(& tm_iocb->u.tmf.comp);
#line 1046
  rval = qla2x00_start_sp(sp);
#line 1047
  if (rval != 0) {
#line 1048
    goto done_free_sp;
  } else {

  }
#line 1050
  ql_dbg(33554432U, vha, 20603, "Task management command issued target_id=%x\n", (int )fcport->tgt_id);
#line 1054
  wait_for_completion(& tm_iocb->u.tmf.comp);
#line 1056
  rval = (unsigned int )tm_iocb->u.tmf.comp_status == 0U ? 0 : 258;
  done_free_sp: 
#line 1060
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 1062
  return (rval);
}
}
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_abort_target(fc_port_t *fcport , unsigned int l , int tag ) 
{ 
  int tmp ;

  {
#line 1068
  tmp = qlafx00_async_tm_cmd(fcport, 2U, l, (uint32_t )tag);
#line 1068
  return (tmp);
}
}
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_lun_reset(fc_port_t *fcport , unsigned int l , int tag ) 
{ 
  int tmp ;

  {
#line 1074
  tmp = qlafx00_async_tm_cmd(fcport, 16U, l, (uint32_t )tag);
#line 1074
  return (tmp);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_loop_reset(scsi_qla_host_t *vha ) 
{ 
  int ret ;
  struct fc_port *fcport ;
  struct qla_hw_data *ha ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1082
  ha = vha->hw;
#line 1084
  if (ql2xtargetreset != 0) {
#line 1085
    __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1085
    fcport = (struct fc_port *)__mptr;
#line 1085
    goto ldv_43740;
    ldv_43739: ;
#line 1086
    if ((unsigned int )fcport->port_type != 5U) {
#line 1087
      goto ldv_43738;
    } else {

    }
#line 1089
    ret = (*((ha->isp_ops)->target_reset))(fcport, 0U, 0);
#line 1090
    if (ret != 0) {
#line 1091
      ql_dbg(4194304U, vha, 32829, "Bus Reset failed: Reset=%d d_id=%x.\n", ret, (int )fcport->d_id.b24);
    } else {

    }
    ldv_43738: 
#line 1085
    __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1085
    fcport = (struct fc_port *)__mptr___0;
    ldv_43740: ;
#line 1085
    if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1087
      goto ldv_43739;
    } else {

    }

  } else {

  }
#line 1097
  return (0);
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_iospace_config(struct qla_hw_data *ha ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  uint8_t tmp___8 ;

  {
#line 1103
  tmp___0 = pci_request_selected_regions(ha->pdev, ha->bars, "qla2xxx");
#line 1103
  if (tmp___0 != 0) {
#line 1105
    tmp = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1105
    ql_log_pci(0U, ha->pdev, 334, "Failed to reserve PIO/MMIO regions (%s), aborting.\n",
               tmp);
#line 1108
    goto iospace_error_exit;
  } else {

  }
#line 1112
  if (((ha->pdev)->resource[0].flags & 512UL) == 0UL) {
#line 1113
    tmp___1 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1113
    ql_log_pci(1U, ha->pdev, 335, "Invalid pci I/O region size (%s).\n", tmp___1);
#line 1116
    goto iospace_error_exit;
  } else {

  }
#line 1118
  if (((ha->pdev)->resource[0].start == 0ULL && (ha->pdev)->resource[0].end == (ha->pdev)->resource[0].start) || ((ha->pdev)->resource[0].end - (ha->pdev)->resource[0].start) + 1ULL <= 1048575ULL) {
#line 1119
    tmp___2 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1119
    ql_log_pci(1U, ha->pdev, 295, "Invalid PCI mem BAR0 region size (%s), aborting\n",
               tmp___2);
#line 1122
    goto iospace_error_exit;
  } else {

  }
#line 1125
  ha->cregbase = ioremap_nocache((ha->pdev)->resource[0].start, 1048576UL);
#line 1127
  if ((unsigned long )ha->cregbase == (unsigned long )((void *)0)) {
#line 1128
    tmp___3 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1128
    ql_log_pci(0U, ha->pdev, 296, "cannot remap MMIO (%s), aborting\n", tmp___3);
#line 1130
    goto iospace_error_exit;
  } else {

  }
#line 1133
  if (((ha->pdev)->resource[2].flags & 512UL) == 0UL) {
#line 1134
    tmp___4 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1134
    ql_log_pci(1U, ha->pdev, 297, "region #2 not an MMIO resource (%s), aborting\n",
               tmp___4);
#line 1137
    goto iospace_error_exit;
  } else {

  }
#line 1139
  if (((ha->pdev)->resource[2].start == 0ULL && (ha->pdev)->resource[2].end == (ha->pdev)->resource[2].start) || ((ha->pdev)->resource[2].end - (ha->pdev)->resource[2].start) + 1ULL <= 131071ULL) {
#line 1140
    tmp___5 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1140
    ql_log_pci(1U, ha->pdev, 298, "Invalid PCI mem BAR2 region size (%s), aborting\n",
               tmp___5);
#line 1143
    goto iospace_error_exit;
  } else {

  }
#line 1146
  tmp___6 = ioremap_nocache((ha->pdev)->resource[2].start, 131072UL);
#line 1146
  ha->iobase = (device_reg_t *)tmp___6;
#line 1148
  if ((unsigned long )ha->iobase == (unsigned long )((device_reg_t *)0)) {
#line 1149
    tmp___7 = pci_name((struct pci_dev  const  *)ha->pdev);
#line 1149
    ql_log_pci(0U, ha->pdev, 299, "cannot remap MMIO (%s), aborting\n", tmp___7);
#line 1151
    goto iospace_error_exit;
  } else {

  }
#line 1155
  tmp___8 = 1U;
#line 1155
  ha->max_rsp_queues = tmp___8;
#line 1155
  ha->max_req_queues = tmp___8;
#line 1157
  ql_log_pci(2U, ha->pdev, 300, "Bars 0x%x, iobase0 0x%p, iobase2 0x%p\n", ha->bars,
             ha->cregbase, ha->iobase);
#line 1161
  return (0);
  iospace_error_exit: ;
#line 1164
  return (-12);
}
}
#line 1168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_save_queue_ptrs(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;

  {
#line 1170
  ha = vha->hw;
#line 1171
  req = *(ha->req_q_map);
#line 1172
  rsp = *(ha->rsp_q_map);
#line 1174
  req->length_fx00 = req->length;
#line 1175
  req->ring_fx00 = req->ring;
#line 1176
  req->dma_fx00 = req->dma;
#line 1178
  rsp->length_fx00 = rsp->length;
#line 1179
  rsp->ring_fx00 = rsp->ring;
#line 1180
  rsp->dma_fx00 = rsp->dma;
#line 1182
  ql_dbg(1073741824U, vha, 301, "req: %p, ring_fx00: %p, length_fx00: 0x%x,req->dma_fx00: 0x%llx\n",
         req, req->ring_fx00, (int )req->length_fx00, req->dma_fx00);
#line 1187
  ql_dbg(1073741824U, vha, 302, "rsp: %p, ring_fx00: %p, length_fx00: 0x%x,rsp->dma_fx00: 0x%llx\n",
         rsp, rsp->ring_fx00, (int )rsp->length_fx00, rsp->dma_fx00);
#line 1191
  return;
}
}
#line 1194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_config_queues(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  dma_addr_t bar2_hdl ;

  {
#line 1196
  ha = vha->hw;
#line 1197
  req = *(ha->req_q_map);
#line 1198
  rsp = *(ha->rsp_q_map);
#line 1199
  bar2_hdl = (ha->pdev)->resource[2].start;
#line 1201
  req->length = (uint16_t )ha->req_que_len;
#line 1202
  req->ring = (request_t *)ha->iobase + (unsigned long )ha->req_que_off;
#line 1203
  req->dma = (dma_addr_t )ha->req_que_off + bar2_hdl;
#line 1204
  if ((unsigned long )req->ring == (unsigned long )((request_t *)0) || (unsigned int )req->length == 0U) {
#line 1205
    ql_log_pci(2U, ha->pdev, 303, "Unable to allocate memory for req_ring\n");
#line 1207
    return (258);
  } else {

  }
#line 1210
  ql_dbg(1073741824U, vha, 304, "req: %p req_ring pointer %p req len 0x%x req off 0x%x\n, req->dma: 0x%llx",
         req, req->ring, (int )req->length, ha->req_que_off, req->dma);
#line 1216
  rsp->length = (uint16_t )ha->rsp_que_len;
#line 1217
  rsp->ring = (response_t *)ha->iobase + (unsigned long )ha->rsp_que_off;
#line 1218
  rsp->dma = (dma_addr_t )ha->rsp_que_off + bar2_hdl;
#line 1219
  if ((unsigned long )rsp->ring == (unsigned long )((response_t *)0) || (unsigned int )rsp->length == 0U) {
#line 1220
    ql_log_pci(2U, ha->pdev, 305, "Unable to allocate memory for rsp_ring\n");
#line 1222
    return (258);
  } else {

  }
#line 1225
  ql_dbg(1073741824U, vha, 306, "rsp: %p rsp_ring pointer %p rsp len 0x%x rsp off 0x%x, rsp->dma: 0x%llx\n",
         rsp, rsp->ring, (int )rsp->length, ha->rsp_que_off, rsp->dma);
#line 1231
  return (0);
}
}
#line 1235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_init_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  uint16_t wait_time ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  uint32_t aenmbx ;
  uint32_t aenmbx7 ;
  uint32_t pseudo_aen ;
  uint32_t state[5U] ;
  bool done ;
  unsigned int tmp ;

  {
#line 1237
  rval = 0;
#line 1240
  ha = vha->hw;
#line 1241
  reg = & (ha->iobase)->ispfx00;
#line 1242
  aenmbx7 = 0U;
#line 1245
  done = 0;
#line 1248
  wait_time = 30U;
#line 1250
  pseudo_aen = readl((void const volatile   *)(& reg->pseudoaen));
#line 1251
  if (pseudo_aen == 1U) {
#line 1252
    aenmbx7 = readl((void const volatile   *)(& reg->initval7));
#line 1253
    ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 1254
    ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 1255
    rval = qlafx00_driver_shutdown(vha, 10);
#line 1256
    if (rval != 0) {
#line 1257
      qlafx00_soft_reset(vha);
    } else {

    }
  } else {

  }
#line 1261
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
  ldv_43788: 
#line 1263
  aenmbx = readl((void const volatile   *)(& reg->aenmailbox0));
#line 1264
  __asm__  volatile   ("": : : "memory");
#line 1265
  ql_dbg(536870912U, vha, 307, "aenmbx: 0x%x\n", aenmbx);
#line 1268
  switch (aenmbx) {
  case 32848U: ;
  case 32849U: ;
#line 1271
  goto ldv_43774;
  case 32770U: ;
  case 32771U: ;
  case 32772U: ;
  case 33793U: 
#line 1277
  qlafx00_soft_reset(vha);
#line 1278
  goto ldv_43774;
  case 32864U: 
#line 1282
  aenmbx7 = readl((void const volatile   *)(& reg->aenmailbox7));
#line 1283
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 1284
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 1285
  ha->req_que_off = readl((void const volatile   *)(& reg->aenmailbox1));
#line 1286
  ha->rsp_que_off = readl((void const volatile   *)(& reg->aenmailbox3));
#line 1287
  ha->req_que_len = readl((void const volatile   *)(& reg->aenmailbox5));
#line 1288
  ha->rsp_que_len = readl((void const volatile   *)(& reg->aenmailbox6));
#line 1289
  writel(0U, (void volatile   *)(& reg->aenmailbox0));
#line 1290
  __readl((void const volatile   *)(& reg->aenmailbox0));
#line 1291
  ql_dbg(1073741824U, vha, 308, "f/w returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code);
#line 1295
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1296
  rval = 0;
#line 1297
  done = 1;
#line 1298
  goto ldv_43774;
  default: 
#line 1317
  aenmbx7 = readl((void const volatile   *)(& reg->initval7));
#line 1318
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 1319
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 1320
  ha->req_que_off = readl((void const volatile   *)(& reg->initval1));
#line 1321
  ha->rsp_que_off = readl((void const volatile   *)(& reg->initval3));
#line 1322
  ha->req_que_len = readl((void const volatile   *)(& reg->initval5));
#line 1323
  ha->rsp_que_len = readl((void const volatile   *)(& reg->initval6));
#line 1324
  ql_dbg(1073741824U, vha, 309, "f/w returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code);
#line 1328
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1331
  rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
#line 1332
  if (rval != 0) {
#line 1334
    goto ldv_43774;
  } else {

  }
#line 1337
  if (state[0] == 0U) {
#line 1341
    rval = 0;
#line 1342
    done = 1;
#line 1343
    goto ldv_43774;
  } else {

  }
#line 1350
  ql_dbg(1073741824U, vha, 310, "Sending Driver shutdown fw_state 0x%x\n", state[0]);
#line 1354
  rval = qlafx00_driver_shutdown(vha, 10);
#line 1355
  if (rval != 0) {
#line 1356
    rval = 258;
#line 1357
    goto ldv_43774;
  } else {

  }
#line 1359
  msleep(500U);
#line 1361
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 1362
  goto ldv_43774;
  }
  ldv_43774: ;
#line 1365
  if (! done) {
#line 1366
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 1367
      tmp = readl((void const volatile   *)(& reg->aenmailbox7));
#line 1367
      ql_dbg(1073741824U, vha, 311, "Init f/w failed: aen[7]: 0x%x\n", tmp);
#line 1370
      rval = 258;
#line 1371
      done = 1;
#line 1372
      goto ldv_43787;
    } else {

    }
#line 1375
    msleep(500U);
  } else {

  }
#line 1377
  if (! done) {
#line 1379
    goto ldv_43788;
  } else {

  }
  ldv_43787: ;
#line 1379
  if (rval != 0) {
#line 1380
    ql_dbg(1073741824U, vha, 312, "%s **** FAILED ****.\n", "qlafx00_init_fw_ready");
  } else {
#line 1383
    ql_dbg(1073741824U, vha, 313, "%s **** SUCCESS ****.\n", "qlafx00_init_fw_ready");
  }
#line 1386
  return (rval);
}
}
#line 1396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_fw_ready(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long wtime ;
  uint16_t wait_time ;
  uint32_t state[5U] ;

  {
#line 1403
  rval = 0;
#line 1405
  wait_time = 10U;
#line 1408
  wtime = (unsigned long )((int )wait_time * 250) + (unsigned long )jiffies;
#line 1411
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 1412
    ql_dbg(1073741824U, vha, 314, "Waiting for init to complete...\n");
  } else {

  }
  ldv_43804: 
#line 1416
  rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
#line 1418
  if (rval == 0) {
#line 1419
    if (state[0] == 4096U) {
#line 1420
      ql_dbg(1073741824U, vha, 315, "fw_state=%x\n", state[0]);
#line 1422
      rval = 0;
#line 1423
      goto ldv_43797;
    } else {

    }
  } else {

  }
#line 1426
  rval = 258;
#line 1428
  if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 1429
    goto ldv_43797;
  } else {

  }
#line 1432
  msleep(500U);
#line 1434
  ql_dbg(1073741824U, vha, 316, "fw_state=%x curr time=%lx.\n", state[0], jiffies);
#line 1436
  goto ldv_43804;
  ldv_43797: ;
#line 1439
  if (rval != 0) {
#line 1440
    ql_dbg(1073741824U, vha, 317, "Firmware ready **** FAILED ****.\n");
  } else {
#line 1443
    ql_dbg(1073741824U, vha, 318, "Firmware ready **** SUCCESS ****.\n");
  }
#line 1446
  return (rval);
}
}
#line 1450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_find_all_targets(scsi_qla_host_t *vha , struct list_head *new_fcports ) 
{ 
  int rval ;
  uint16_t tgt_id ;
  fc_port_t *fcport ;
  fc_port_t *new_fcport ;
  int found ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  struct list_head  const  *__mptr ;
  int tmp___4 ;
  int tmp___5 ;
  u64 tmp___6 ;
  u64 tmp___7 ;
  int tmp___8 ;
  u64 tmp___9 ;
  u64 tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr___0 ;
  unsigned long tmp___12 ;

  {
#line 1457
  ha = vha->hw;
#line 1459
  rval = 0;
#line 1461
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1461
  if (tmp == 0) {
#line 1462
    return (258);
  } else {

  }
#line 1464
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1464
  if (tmp___0 != 0) {
#line 1466
    atomic_set(& vha->loop_down_timer, 0);
#line 1467
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1468
    return (258);
  } else {
#line 1464
    tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1464
    if (tmp___1 != 0) {
#line 1466
      atomic_set(& vha->loop_down_timer, 0);
#line 1467
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1468
      return (258);
    } else {
#line 1464
      tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1464
      if (tmp___2 != 0) {
#line 1466
        atomic_set(& vha->loop_down_timer, 0);
#line 1467
        set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1468
        return (258);
      } else {

      }
    }
  }
#line 1471
  ql_dbg(1342177280U, vha, 8328, "Listing Target bit map...\n");
#line 1473
  ql_dump_buffer(1342177280U, vha, 8329, (uint8_t *)ha->gid_list, 32U);
#line 1477
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 1478
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 1479
    return (259);
  } else {

  }
#line 1481
  tmp___3 = find_first_bit((unsigned long const   *)ha->gid_list, 128UL);
#line 1481
  tgt_id = (uint16_t )tmp___3;
#line 1481
  goto ldv_43826;
  ldv_43825: 
#line 1485
  new_fcport->tgt_id = tgt_id;
#line 1486
  rval = qlafx00_fx_disc(vha, new_fcport, 128);
#line 1488
  if (rval != 0) {
#line 1489
    ql_log(1U, vha, 8330, "Target info scan failed -- assuming zero-entry result...\n");
#line 1492
    goto ldv_43815;
  } else {

  }
#line 1496
  found = 0;
#line 1497
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1497
  fcport = (fc_port_t *)__mptr;
#line 1497
  goto ldv_43824;
  ldv_43823: 
#line 1498
  tmp___4 = memcmp((void const   *)(& new_fcport->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 1498
  if (tmp___4 != 0) {
#line 1500
    goto ldv_43820;
  } else {

  }
#line 1502
  found = found + 1;
#line 1508
  if ((int )fcport->tgt_id == (int )new_fcport->tgt_id) {
#line 1508
    tmp___5 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1508
    if (tmp___5 == 4) {
#line 1510
      goto ldv_43821;
    } else {

    }
  } else {

  }
#line 1515
  tmp___6 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1515
  tmp___7 = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1515
  tmp___8 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1515
  ql_dbg(1342177280U, vha, 8331, "TGT-ID Change(%s): Present tgt id: 0x%x state: 0x%x wwnn = %llx wwpn = %llx.\n",
         "qlafx00_find_all_targets", (int )fcport->tgt_id, tmp___8, tmp___7, tmp___6);
#line 1524
  tmp___9 = wwn_to_u64((u8 *)(& new_fcport->port_name));
#line 1524
  tmp___10 = wwn_to_u64((u8 *)(& new_fcport->node_name));
#line 1524
  ql_log(2U, vha, 8332, "TGT-ID Announce(%s): Discovered tgt id 0x%x wwnn = %llx wwpn = %llx.\n",
         "qlafx00_find_all_targets", (int )new_fcport->tgt_id, tmp___10, tmp___9);
#line 1533
  tmp___11 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1533
  if (tmp___11 != 4) {
#line 1534
    fcport->old_tgt_id = fcport->tgt_id;
#line 1535
    fcport->tgt_id = new_fcport->tgt_id;
#line 1536
    ql_log(2U, vha, 8333, "TGT-ID: New fcport Added: %p\n", fcport);
#line 1538
    qla2x00_update_fcport(vha, fcport);
  } else {
#line 1540
    ql_log(2U, vha, 8334, " Existing TGT-ID %x did not get  offline event from firmware.\n",
           (int )fcport->old_tgt_id);
#line 1544
    qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 1545
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1546
    kfree((void const   *)new_fcport);
#line 1547
    return (rval);
  }
#line 1549
  goto ldv_43821;
  ldv_43820: 
#line 1497
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1497
  fcport = (fc_port_t *)__mptr___0;
  ldv_43824: ;
#line 1497
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1499
    goto ldv_43823;
  } else {

  }
  ldv_43821: ;
#line 1552
  if (found != 0) {
#line 1553
    goto ldv_43815;
  } else {

  }
#line 1556
  list_add_tail(& new_fcport->list, new_fcports);
#line 1559
  new_fcport = qla2x00_alloc_fcport(vha, 208U);
#line 1560
  if ((unsigned long )new_fcport == (unsigned long )((fc_port_t *)0)) {
#line 1561
    return (259);
  } else {

  }
  ldv_43815: 
#line 1481
  tmp___12 = find_next_bit((unsigned long const   *)ha->gid_list, 128UL, (unsigned long )((int )tgt_id + 1));
#line 1481
  tgt_id = (uint16_t )tmp___12;
  ldv_43826: ;
#line 1481
  if ((unsigned int )tgt_id <= 127U) {
#line 1483
    goto ldv_43825;
  } else {

  }
#line 1564
  kfree((void const   *)new_fcport);
#line 1565
  return (rval);
}
}
#line 1580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_configure_all_targets(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  fc_port_t *fcport ;
  fc_port_t *rmptemp ;
  struct list_head new_fcports ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  int tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 1584
  new_fcports.next = & new_fcports;
#line 1584
  new_fcports.prev = & new_fcports;
#line 1586
  rval = qlafx00_fx_disc(vha, & (vha->hw)->mr.fcport, 129);
#line 1588
  if (rval != 0) {
#line 1589
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1590
    return (rval);
  } else {

  }
#line 1593
  rval = qlafx00_find_all_targets(vha, & new_fcports);
#line 1594
  if (rval != 0) {
#line 1595
    set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1596
    return (rval);
  } else {

  }
#line 1602
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1602
  fcport = (fc_port_t *)__mptr;
#line 1602
  goto ldv_43841;
  ldv_43840: 
#line 1603
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1603
  if (tmp != 0) {
#line 1604
    goto ldv_43839;
  } else {

  }
#line 1606
  tmp___0 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1606
  if (tmp___0 == 3) {
#line 1607
    if ((unsigned int )fcport->port_type != 4U) {
#line 1608
      qla2x00_mark_device_lost(vha, fcport, 0, 0);
    } else {

    }
  } else {

  }
#line 1602
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1602
  fcport = (fc_port_t *)__mptr___0;
  ldv_43841: ;
#line 1602
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1604
    goto ldv_43840;
  } else {

  }
  ldv_43839: 
#line 1615
  __mptr___1 = (struct list_head  const  *)new_fcports.next;
#line 1615
  fcport = (fc_port_t *)__mptr___1;
#line 1615
  __mptr___2 = (struct list_head  const  *)fcport->list.next;
#line 1615
  rmptemp = (fc_port_t *)__mptr___2;
#line 1615
  goto ldv_43850;
  ldv_43849: 
#line 1616
  tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1616
  if (tmp___1 != 0) {
#line 1617
    goto ldv_43848;
  } else {

  }
#line 1619
  qla2x00_update_fcport(vha, fcport);
#line 1620
  list_move_tail(& fcport->list, & vha->vp_fcports);
#line 1621
  tmp___2 = wwn_to_u64((u8 *)(& fcport->port_name));
#line 1621
  tmp___3 = wwn_to_u64((u8 *)(& fcport->node_name));
#line 1621
  ql_log(2U, vha, 8335, "Attach new target id 0x%x wwnn = %llx wwpn = %llx.\n", (int )fcport->tgt_id,
         tmp___3, tmp___2);
#line 1615
  fcport = rmptemp;
#line 1615
  __mptr___3 = (struct list_head  const  *)rmptemp->list.next;
#line 1615
  rmptemp = (fc_port_t *)__mptr___3;
  ldv_43850: ;
#line 1615
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 1617
    goto ldv_43849;
  } else {

  }
  ldv_43848: 
#line 1630
  __mptr___4 = (struct list_head  const  *)new_fcports.next;
#line 1630
  fcport = (fc_port_t *)__mptr___4;
#line 1630
  __mptr___5 = (struct list_head  const  *)fcport->list.next;
#line 1630
  rmptemp = (fc_port_t *)__mptr___5;
#line 1630
  goto ldv_43858;
  ldv_43857: 
#line 1631
  list_del(& fcport->list);
#line 1632
  kfree((void const   *)fcport);
#line 1630
  fcport = rmptemp;
#line 1630
  __mptr___6 = (struct list_head  const  *)rmptemp->list.next;
#line 1630
  rmptemp = (fc_port_t *)__mptr___6;
  ldv_43858: ;
#line 1630
  if ((unsigned long )(& fcport->list) != (unsigned long )(& new_fcports)) {
#line 1632
    goto ldv_43857;
  } else {

  }

#line 1635
  return (rval);
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_configure_devices(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  unsigned long flags ;
  unsigned long save_flags ;
  int tmp ;

  {
#line 1655
  rval = 0;
#line 1657
  flags = vha->dpc_flags;
#line 1657
  save_flags = flags;
#line 1659
  ql_dbg(268435456U, vha, 8336, "Configure devices -- dpc flags =0x%lx\n", flags);
#line 1662
  rval = qlafx00_configure_all_targets(vha);
#line 1664
  if (rval == 0) {
#line 1665
    tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1665
    if (tmp != 0) {
#line 1666
      rval = 258;
    } else {
#line 1668
      atomic_set(& vha->loop_state, 5);
#line 1669
      ql_log(2U, vha, 8337, "Device Ready\n");
    }
  } else {

  }
#line 1674
  if (rval != 0) {
#line 1675
    ql_dbg(268435456U, vha, 8338, "%s *** FAILED ***.\n", "qlafx00_configure_devices");
  } else {
#line 1678
    ql_dbg(268435456U, vha, 8339, "%s: exiting normally.\n", "qlafx00_configure_devices");
  }
#line 1681
  return (rval);
}
}
#line 1685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_abort_isp_cleanup(scsi_qla_host_t *vha , bool critemp ) 
{ 
  struct qla_hw_data *ha ;
  fc_port_t *fcport ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1687
  ha = vha->hw;
#line 1690
  vha->flags.online = 0U;
#line 1691
  ha->mr.fw_hbt_en = 0U;
#line 1693
  if (! critemp) {
#line 1694
    ha->flags.chip_reset_done = 0U;
#line 1695
    clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1696
    vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 1697
    ql_log(2U, vha, 319, "Performing ISP error recovery - ha = %p.\n", ha);
#line 1699
    (*((ha->isp_ops)->reset_chip))(vha);
  } else {

  }
#line 1702
  tmp___0 = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 1702
  if (tmp___0 != 2) {
#line 1703
    atomic_set(& vha->loop_state, 2);
#line 1704
    atomic_set(& vha->loop_down_timer, 615);
  } else {
#line 1707
    tmp = atomic_read((atomic_t const   *)(& vha->loop_down_timer));
#line 1707
    if (tmp == 0) {
#line 1708
      atomic_set(& vha->loop_down_timer, 615);
    } else {

    }
  }
#line 1713
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1713
  fcport = (fc_port_t *)__mptr;
#line 1713
  goto ldv_43878;
  ldv_43877: 
#line 1714
  fcport->flags = 0U;
#line 1715
  tmp___1 = atomic_read((atomic_t const   *)(& fcport->state));
#line 1715
  if (tmp___1 == 4) {
#line 1716
    qla2x00_set_fcport_state___3(fcport, 3);
  } else {

  }
#line 1713
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1713
  fcport = (fc_port_t *)__mptr___0;
  ldv_43878: ;
#line 1713
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1715
    goto ldv_43877;
  } else {

  }

#line 1719
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1720
    if ((int )critemp) {
#line 1721
      qla2x00_abort_all_cmds(vha, 65536);
    } else {
#line 1724
      qla2x00_abort_all_cmds(vha, 524288);
    }
  } else {

  }
#line 1728
  qla2x00_free_irqs(vha);
#line 1729
  if ((int )critemp) {
#line 1730
    set_bit(27L, (unsigned long volatile   *)(& vha->dpc_flags));
  } else {
#line 1732
    set_bit(25L, (unsigned long volatile   *)(& vha->dpc_flags));
  }
#line 1735
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1737
  ql_log(2U, vha, 320, "%s Done done - ha=%p.\n", "qlafx00_abort_isp_cleanup", ha);
#line 1739
  return;
}
}
#line 1751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_init_response_q_entries(struct rsp_que *rsp ) 
{ 
  uint16_t cnt ;
  response_t *pkt ;

  {
#line 1756
  rsp->ring_ptr = rsp->ring;
#line 1757
  rsp->ring_index = 0U;
#line 1758
  rsp->status_srb = (srb_t *)0;
#line 1759
  pkt = rsp->ring_ptr;
#line 1760
  cnt = 0U;
#line 1760
  goto ldv_43887;
  ldv_43886: 
#line 1761
  pkt->signature = 3735936685U;
#line 1762
  writel(3735936685U, (void volatile   *)(& pkt->signature));
#line 1764
  pkt = pkt + 1;
#line 1760
  cnt = (uint16_t )((int )cnt + 1);
  ldv_43887: ;
#line 1760
  if ((int )rsp->length > (int )cnt) {
#line 1762
    goto ldv_43886;
  } else {

  }

#line 1767
  return;
}
}
#line 1769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_rescan_isp(scsi_qla_host_t *vha ) 
{ 
  uint32_t status ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  uint32_t aenmbx7 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1771
  status = 258U;
#line 1772
  ha = vha->hw;
#line 1773
  reg = & (ha->iobase)->ispfx00;
#line 1776
  qla2x00_request_irqs(ha, *(ha->rsp_q_map));
#line 1778
  aenmbx7 = readl((void const volatile   *)(& reg->aenmailbox7));
#line 1779
  ha->mbx_intr_code = (uint32_t )((unsigned short )(aenmbx7 >> 16));
#line 1780
  ha->rqstq_intr_code = (uint32_t )((unsigned short )aenmbx7);
#line 1781
  ha->req_que_off = readl((void const volatile   *)(& reg->aenmailbox1));
#line 1782
  ha->rsp_que_off = readl((void const volatile   *)(& reg->aenmailbox3));
#line 1783
  ha->req_que_len = readl((void const volatile   *)(& reg->aenmailbox5));
#line 1784
  ha->rsp_que_len = readl((void const volatile   *)(& reg->aenmailbox6));
#line 1786
  ql_dbg(268435456U, vha, 8340, "fw returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x  Req que offset 0x%x Rsp que offset 0x%x\n",
         ha->mbx_intr_code, ha->rqstq_intr_code, ha->req_que_off, ha->rsp_que_len);
#line 1793
  writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
#line 1795
  tmp = qla2x00_init_rings(vha);
#line 1795
  status = (uint32_t )tmp;
#line 1796
  if (status == 0U) {
#line 1797
    vha->flags.online = 1U;
#line 1800
    if ((vha->device_flags & 2U) != 0U) {
#line 1801
      status = 0U;
    } else {

    }
#line 1803
    tmp___0 = qlafx00_fx_disc(vha, & (vha->hw)->mr.fcport, 153);
#line 1803
    if (tmp___0 != 0) {
#line 1805
      ql_dbg(268435456U, vha, 8341, "failed to register host info\n");
    } else {

    }
  } else {

  }
#line 1808
  scsi_unblock_requests(vha->host);
#line 1809
  return ((int )status);
}
}
#line 1813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_timer_routine(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t fw_heart_beat ;
  uint32_t aenmbx0 ;
  struct device_reg_fx00 *reg ;
  uint32_t tempc ;
  int tmp ;
  int tmp___0 ;
  uint32_t data0 ;
  uint32_t data1 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 1815
  ha = vha->hw;
#line 1818
  reg = & (ha->iobase)->ispfx00;
#line 1822
  if ((unsigned int )ha->mr.fw_hbt_cnt != 0U) {
#line 1823
    ha->mr.fw_hbt_cnt = (uint8_t )((int )ha->mr.fw_hbt_cnt - 1);
  } else {
#line 1825
    if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1825
      tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1825
      if (tmp == 0) {
#line 1825
        tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1825
        if (tmp___0 == 0) {
#line 1825
          if ((unsigned int )ha->mr.fw_hbt_en != 0U) {
#line 1829
            fw_heart_beat = readl((void const volatile   *)(& reg->fwheartbeat));
#line 1830
            if (ha->mr.old_fw_hbt_cnt != fw_heart_beat) {
#line 1831
              ha->mr.old_fw_hbt_cnt = fw_heart_beat;
#line 1832
              ha->mr.fw_hbt_miss_cnt = 0U;
            } else {
#line 1834
              ha->mr.fw_hbt_miss_cnt = (uint8_t )((int )ha->mr.fw_hbt_miss_cnt + 1);
#line 1835
              if ((unsigned int )ha->mr.fw_hbt_miss_cnt == 3U) {
#line 1837
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1839
                qla2xxx_wake_dpc(vha);
#line 1840
                ha->mr.fw_hbt_miss_cnt = 0U;
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1844
    ha->mr.fw_hbt_cnt = 6U;
  }
#line 1847
  tmp___1 = constant_test_bit(25L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1847
  if (tmp___1 != 0) {
#line 1849
    aenmbx0 = readl((void const volatile   *)(& reg->aenmailbox0));
#line 1850
    if ((unsigned int )ha->mr.fw_reset_timer_exp != 0U) {
#line 1851
      set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1852
      qla2xxx_wake_dpc(vha);
#line 1853
      ha->mr.fw_reset_timer_exp = 0U;
    } else
#line 1854
    if (aenmbx0 == 32864U) {
#line 1856
      set_bit(26L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1857
      clear_bit(25L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1858
      qla2xxx_wake_dpc(vha);
#line 1859
      ha->mr.fw_reset_timer_tick = 120U;
    } else
#line 1860
    if (aenmbx0 == 32849U && (unsigned int )ha->mr.fw_hbt_en == 0U) {
#line 1862
      ha->mr.fw_hbt_en = 1U;
    } else
#line 1863
    if ((unsigned int )ha->mr.fw_reset_timer_tick == 0U) {
#line 1864
      if (ha->mr.old_aenmbx0_state == aenmbx0) {
#line 1865
        ha->mr.fw_reset_timer_exp = 1U;
      } else {

      }
#line 1866
      ha->mr.fw_reset_timer_tick = 120U;
    } else
#line 1867
    if (aenmbx0 == 4294967295U) {
#line 1870
      data0 = readl((void const volatile   *)ha->cregbase + 262168U);
#line 1872
      data1 = readl((void const volatile   *)ha->cregbase + 268324U);
#line 1875
      data0 = data0 & 4294901760U;
#line 1876
      data1 = data1 & 65535U;
#line 1878
      writel(data0 | data1, (void volatile   *)ha->cregbase + 268324U);
    } else
#line 1881
    if ((aenmbx0 & 65280U) == 34304U) {
#line 1882
      ha->mr.fw_reset_timer_tick = 600U;
    } else
#line 1884
    if (aenmbx0 == 34050U) {
#line 1885
      ha->mr.fw_reset_timer_tick = 600U;
    } else {

    }
#line 1888
    ha->mr.old_aenmbx0_state = aenmbx0;
#line 1889
    ha->mr.fw_reset_timer_tick = (uint16_t )((int )ha->mr.fw_reset_timer_tick - 1);
  } else {

  }
#line 1891
  tmp___3 = constant_test_bit(27L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 1891
  if (tmp___3 != 0) {
#line 1896
    if ((unsigned int )ha->mr.fw_critemp_timer_tick == 0U) {
#line 1897
      tmp___2 = readl((void const volatile   *)ha->cregbase + 99524U);
#line 1897
      tempc = (3153000U - ((tmp___2 & 1022U) >> 1) * 10000U) / 13825U;
#line 1898
      ql_dbg(16777216U, vha, 24594, "ISPFx00(%s): Critical temp timer, current SOC temperature: %d\n",
             "qlafx00_timer_routine", tempc);
#line 1902
      if (ha->mr.critical_temperature > tempc) {
#line 1903
        set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1904
        clear_bit(27L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1906
        qla2xxx_wake_dpc(vha);
      } else {

      }
#line 1908
      ha->mr.fw_critemp_timer_tick = 60U;
    } else {
#line 1911
      ha->mr.fw_critemp_timer_tick = (uint16_t )((int )ha->mr.fw_critemp_timer_tick - 1);
    }
  } else {

  }
#line 1912
  return;
}
}
#line 1927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_reset_initialize(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1929
  ha = vha->hw;
#line 1931
  if ((vha->device_flags & 32U) != 0U) {
#line 1932
    ql_dbg(1073741824U, vha, 322, "Device in failed state\n");
#line 1934
    return (0);
  } else {

  }
#line 1937
  ha->flags.mr_reset_hdlr_active = 1U;
#line 1939
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1940
    scsi_block_requests(vha->host);
#line 1941
    qlafx00_abort_isp_cleanup(vha, 0);
  } else {

  }
#line 1944
  ql_log(2U, vha, 323, "(%s): succeeded.\n", "qlafx00_reset_initialize");
#line 1946
  ha->flags.mr_reset_hdlr_active = 0U;
#line 1947
  return (0);
}
}
#line 1961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_abort_isp(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1963
  ha = vha->hw;
#line 1965
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1966
    tmp = pci_channel_offline(ha->pdev);
#line 1966
    tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 1966
    if (tmp___0 != 0L) {
#line 1966
      tmp___1 = ldv__builtin_expect(*((unsigned long *)ha + 2UL) != 0UL, 0L);
#line 1966
      if (tmp___1 != 0L) {
#line 1968
        clear_bit(10L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1969
        return (0);
      } else {

      }
    } else {

    }
#line 1972
    scsi_block_requests(vha->host);
#line 1973
    qlafx00_abort_isp_cleanup(vha, 0);
  } else {
#line 1975
    scsi_block_requests(vha->host);
#line 1976
    clear_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1977
    vha->qla_stats.total_isp_aborts = vha->qla_stats.total_isp_aborts + 1U;
#line 1978
    (*((ha->isp_ops)->reset_chip))(vha);
#line 1979
    set_bit(25L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 1981
    writel(4294967288U, (void volatile   *)ha->cregbase + 138096U);
  }
#line 1984
  ql_log(2U, vha, 325, "(%s): succeeded.\n", "qlafx00_abort_isp");
#line 1987
  return (0);
}
}
#line 1991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
__inline static fc_port_t *qlafx00_get_fcport(struct scsi_qla_host *vha , int tgt_id ) 
{ 
  fc_port_t *fcport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1996
  fcport = (fc_port_t *)0;
#line 1997
  __mptr = (struct list_head  const  *)vha->vp_fcports.next;
#line 1997
  fcport = (fc_port_t *)__mptr;
#line 1997
  goto ldv_43928;
  ldv_43927: ;
#line 1998
  if ((int )fcport->tgt_id == tgt_id) {
#line 1999
    ql_dbg(33554432U, vha, 20594, "Matching fcport(%p) found with TGT-ID: 0x%x and Remote TGT_ID: 0x%x\n",
           fcport, (int )fcport->tgt_id, tgt_id);
#line 2003
    goto ldv_43926;
  } else {

  }
#line 1997
  __mptr___0 = (struct list_head  const  *)fcport->list.next;
#line 1997
  fcport = (fc_port_t *)__mptr___0;
  ldv_43928: ;
#line 1997
  if ((unsigned long )(& fcport->list) != (unsigned long )(& vha->vp_fcports)) {
#line 1999
    goto ldv_43927;
  } else {

  }
  ldv_43926: ;
#line 2006
  return (fcport);
}
}
#line 2010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_tgt_detach(struct scsi_qla_host *vha , int tgt_id ) 
{ 
  fc_port_t *fcport ;

  {
#line 2014
  ql_log(2U, vha, 20595, "Detach TGT-ID: 0x%x\n", tgt_id);
#line 2017
  fcport = qlafx00_get_fcport(vha, tgt_id);
#line 2018
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 2019
    return;
  } else {

  }
#line 2021
  qla2x00_mark_device_lost(vha, fcport, 0, 0);
#line 2023
  return;
}
}
#line 2027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_process_aen(struct scsi_qla_host *vha , struct qla_work_evt *evt ) 
{ 
  int rval ;
  uint32_t aen_code ;
  uint32_t aen_data ;
  u32 tmp ;

  {
#line 2029
  rval = 0;
#line 2032
  aen_code = 65535U;
#line 2033
  aen_data = evt->u.aenfx.evtcode;
#line 2035
  switch (evt->u.aenfx.evtcode) {
  case 32788U: ;
#line 2037
  if (evt->u.aenfx.mbx[1] == 0U) {
#line 2038
    if (evt->u.aenfx.mbx[2] == 1U) {
#line 2039
      if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2040
        vha->flags.fw_tgt_reported = 1U;
      } else {

      }
#line 2041
      atomic_set(& vha->loop_down_timer, 0);
#line 2042
      atomic_set(& vha->loop_state, 3);
#line 2043
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2044
      qla2xxx_wake_dpc(vha);
    } else
#line 2045
    if (evt->u.aenfx.mbx[2] == 2U) {
#line 2046
      qlafx00_tgt_detach(vha, (int )evt->u.aenfx.mbx[3]);
    } else {

    }
  } else
#line 2048
  if (evt->u.aenfx.mbx[1] == 65535U) {
#line 2049
    if (evt->u.aenfx.mbx[2] == 1U) {
#line 2050
      if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 2051
        vha->flags.fw_tgt_reported = 1U;
      } else {

      }
#line 2052
      set_bit(4L, (unsigned long volatile   *)(& vha->dpc_flags));
    } else
#line 2053
    if (evt->u.aenfx.mbx[2] == 2U) {
#line 2054
      vha->device_flags = vha->device_flags | 2U;
#line 2055
      qla2x00_mark_all_devices_lost(vha, 1);
    } else {

    }
  } else {

  }
#line 2058
  goto ldv_43942;
  case 32785U: 
#line 2060
  aen_code = 2U;
#line 2061
  aen_data = 0U;
#line 2062
  goto ldv_43942;
  case 32786U: 
#line 2064
  aen_code = 3U;
#line 2065
  aen_data = 0U;
#line 2066
  goto ldv_43942;
  case 32775U: 
#line 2068
  ql_log(2U, vha, 20610, "Process critical temperature event aenmb[0]: %x\n", evt->u.aenfx.evtcode);
#line 2072
  scsi_block_requests(vha->host);
#line 2073
  qlafx00_abort_isp_cleanup(vha, 1);
#line 2074
  scsi_unblock_requests(vha->host);
#line 2075
  goto ldv_43942;
  }
  ldv_43942: 
#line 2078
  tmp = fc_get_event_number();
#line 2078
  fc_host_post_event(vha->host, tmp, (enum fc_host_event_code )aen_code, aen_data);
#line 2081
  return (rval);
}
}
#line 2085 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_update_host_attr(scsi_qla_host_t *vha , struct port_info_data *pinfo ) 
{ 
  u64 port_name ;
  u64 node_name ;

  {
#line 2087
  port_name = 0ULL;
#line 2087
  node_name = 0ULL;
#line 2089
  port_name = wwn_to_u64((u8 *)(& pinfo->port_name));
#line 2090
  node_name = wwn_to_u64((u8 *)(& pinfo->node_name));
#line 2092
  ((struct fc_host_attrs *)(vha->host)->shost_data)->node_name = node_name;
#line 2093
  ((struct fc_host_attrs *)(vha->host)->shost_data)->port_name = port_name;
#line 2094
  if ((unsigned int )pinfo->port_type == 0U) {
#line 2095
    (vha->hw)->current_topology = 8U;
  } else {

  }
#line 2096
  if ((unsigned int )pinfo->link_status == 17U) {
#line 2097
    atomic_set(& vha->loop_state, 5);
  } else
#line 2098
  if ((unsigned int )pinfo->link_status == 16U) {
#line 2099
    atomic_set(& vha->loop_state, 2);
  } else {

  }
#line 2100
  (vha->hw)->link_data_rate = (unsigned short )pinfo->link_config;
#line 2101
  return;
}
}
#line 2104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qla2x00_fxdisc_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;

  {
#line 2106
  sp = (srb_t *)data;
#line 2107
  lio = & sp->u.iocb_cmd;
#line 2109
  complete(& lio->u.fxiocb.fxiocb_comp);
#line 2110
  return;
}
}
#line 2113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qla2x00_fxdisc_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *lio ;

  {
#line 2115
  sp = (srb_t *)ptr;
#line 2116
  lio = & sp->u.iocb_cmd;
#line 2118
  complete(& lio->u.fxiocb.fxiocb_comp);
#line 2119
  return;
}
}
#line 2122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_fx_disc(scsi_qla_host_t *vha , fc_port_t *fcport , uint16_t fx_type ) 
{ 
  srb_t *sp ;
  struct srb_iocb *fdisc ;
  int rval ;
  struct qla_hw_data *ha ;
  struct host_system_info *phost_info ;
  struct register_host_info *preg_hsi ;
  struct new_utsname *p_sysid ;
  struct timeval tv ;
  struct config_info_data *pinfo ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;
  struct port_info_data *pinfo___0 ;
  size_t __len___6 ;
  void *__ret___6 ;
  size_t __len___7 ;
  void *__ret___7 ;
  struct qlafx00_tgt_node_info *pinfo___1 ;
  size_t __len___8 ;
  void *__ret___8 ;
  size_t __len___9 ;
  void *__ret___9 ;
  struct qlafx00_tgt_node_info *pinfo___2 ;
  size_t __len___10 ;
  void *__ret___10 ;

  {
#line 2126
  rval = 258;
#line 2127
  ha = vha->hw;
#line 2130
  p_sysid = (struct new_utsname *)0;
#line 2133
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 2134
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2135
    goto done;
  } else {

  }
#line 2137
  fdisc = & sp->u.iocb_cmd;
#line 2138
  switch ((int )fx_type) {
  case 1: 
#line 2140
  fdisc->u.fxiocb.flags = 2U;
#line 2142
  fdisc->u.fxiocb.rsp_len = 500U;
#line 2143
  goto ldv_43979;
  case 2: 
#line 2145
  fdisc->u.fxiocb.flags = 6U;
#line 2147
  fdisc->u.fxiocb.rsp_len = 304U;
#line 2148
  fdisc->u.fxiocb.req_data = (unsigned int )fcport->port_id;
#line 2149
  goto ldv_43979;
  case 128: 
#line 2151
  fdisc->u.fxiocb.flags = 6U;
#line 2153
  fdisc->u.fxiocb.rsp_len = 212U;
#line 2154
  fdisc->u.fxiocb.req_data = (unsigned int )fcport->tgt_id;
#line 2155
  goto ldv_43979;
  case 129: 
#line 2157
  fdisc->u.fxiocb.flags = 6U;
#line 2159
  fdisc->u.fxiocb.rsp_len = 128U;
#line 2160
  goto ldv_43979;
  case 153: 
#line 2162
  fdisc->u.fxiocb.flags = 1U;
#line 2163
  fdisc->u.fxiocb.req_len = 1036U;
#line 2164
  p_sysid = utsname();
#line 2165
  if ((unsigned long )p_sysid == (unsigned long )((struct new_utsname *)0)) {
#line 2166
    ql_log(1U, vha, 12348, "Not able to get the system information\n");
#line 2168
    goto done_free_sp;
  } else {

  }
#line 2170
  goto ldv_43979;
  default: ;
#line 2172
  goto ldv_43979;
  }
  ldv_43979: ;
#line 2175
  if ((int )fdisc->u.fxiocb.flags & 1) {
#line 2176
    fdisc->u.fxiocb.req_addr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.req_len,
                                               & fdisc->u.fxiocb.req_dma_handle, 208U,
                                               (struct dma_attrs *)0);
#line 2179
    if ((unsigned long )fdisc->u.fxiocb.req_addr == (unsigned long )((void *)0)) {
#line 2180
      goto done_free_sp;
    } else {

    }
#line 2182
    if ((unsigned int )fx_type == 153U) {
#line 2183
      preg_hsi = (struct register_host_info *)fdisc->u.fxiocb.req_addr;
#line 2185
      phost_info = & preg_hsi->hsi;
#line 2186
      memset((void *)preg_hsi, 0, 1036UL);
#line 2187
      phost_info->os_type = 2U;
#line 2188
      strncpy((char *)(& phost_info->sysname), (char const   *)(& p_sysid->sysname),
              128UL);
#line 2190
      strncpy((char *)(& phost_info->nodename), (char const   *)(& p_sysid->nodename),
              64UL);
#line 2192
      strncpy((char *)(& phost_info->release), (char const   *)(& p_sysid->release),
              64UL);
#line 2194
      strncpy((char *)(& phost_info->version), (char const   *)(& p_sysid->version),
              64UL);
#line 2196
      strncpy((char *)(& phost_info->machine), (char const   *)(& p_sysid->machine),
              64UL);
#line 2198
      strncpy((char *)(& phost_info->domainname), (char const   *)(& p_sysid->domainname),
              64UL);
#line 2200
      strncpy((char *)(& phost_info->hostdriver), "8.06.00.08-k", 64UL);
#line 2202
      do_gettimeofday(& tv);
#line 2203
      preg_hsi->utc = (unsigned long long )tv.tv_sec;
#line 2204
      ql_dbg(1073741824U, vha, 329, "ISP%04X: Host registration with firmware\n",
             (int )(ha->pdev)->device);
#line 2207
      ql_dbg(1073741824U, vha, 330, "os_type = \'%d\', sysname = \'%s\', nodname = \'%s\'\n",
             phost_info->os_type, (char *)(& phost_info->sysname), (char *)(& phost_info->nodename));
#line 2212
      ql_dbg(1073741824U, vha, 331, "release = \'%s\', version = \'%s\'\n", (char *)(& phost_info->release),
             (char *)(& phost_info->version));
#line 2216
      ql_dbg(1073741824U, vha, 332, "machine = \'%s\' domainname = \'%s\', hostdriver = \'%s\'\n",
             (char *)(& phost_info->machine), (char *)(& phost_info->domainname),
             (char *)(& phost_info->hostdriver));
#line 2222
      ql_dump_buffer(1342177280U, vha, 333, (uint8_t *)phost_info, 772U);
    } else {

    }
  } else {

  }
#line 2228
  if (((int )fdisc->u.fxiocb.flags & 2) != 0) {
#line 2229
    fdisc->u.fxiocb.rsp_addr = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.rsp_len,
                                               & fdisc->u.fxiocb.rsp_dma_handle, 208U,
                                               (struct dma_attrs *)0);
#line 2232
    if ((unsigned long )fdisc->u.fxiocb.rsp_addr == (unsigned long )((void *)0)) {
#line 2233
      goto done_unmap_req;
    } else {

    }
  } else {

  }
#line 2236
  sp->type = 10U;
#line 2237
  sp->name = (char *)"fxdisc";
#line 2238
  qla2x00_init_timer(sp, 20UL);
#line 2239
  fdisc->timeout = & qla2x00_fxdisc_iocb_timeout;
#line 2240
  fdisc->u.fxiocb.req_func_type = fx_type;
#line 2241
  sp->done = & qla2x00_fxdisc_sp_done;
#line 2243
  rval = qla2x00_start_sp(sp);
#line 2244
  if (rval != 0) {
#line 2245
    goto done_unmap_dma;
  } else {

  }
#line 2247
  wait_for_completion(& fdisc->u.fxiocb.fxiocb_comp);
#line 2249
  if ((unsigned int )fx_type == 1U) {
#line 2250
    pinfo = (struct config_info_data *)fdisc->u.fxiocb.rsp_addr;
#line 2252
    __len = 256UL;
#line 2252
    if (__len > 63UL) {
#line 2252
      __ret = __memcpy((void *)(& (vha->hw)->mr.product_name), (void const   *)(& pinfo->product_name),
                       __len);
    } else {
#line 2252
      __ret = __builtin_memcpy((void *)(& (vha->hw)->mr.product_name), (void const   *)(& pinfo->product_name),
                               __len);
    }
#line 2254
    __len___0 = 64UL;
#line 2254
    if (__len___0 > 63UL) {
#line 2254
      __ret___0 = __memcpy((void *)(& (vha->hw)->mr.symbolic_name), (void const   *)(& pinfo->symbolic_name),
                           __len___0);
    } else {
#line 2254
      __ret___0 = __builtin_memcpy((void *)(& (vha->hw)->mr.symbolic_name), (void const   *)(& pinfo->symbolic_name),
                                   __len___0);
    }
#line 2256
    __len___1 = 32UL;
#line 2256
    if (__len___1 > 63UL) {
#line 2256
      __ret___1 = __memcpy((void *)(& (vha->hw)->mr.serial_num), (void const   *)(& pinfo->serial_num),
                           __len___1);
    } else {
#line 2256
      __ret___1 = __builtin_memcpy((void *)(& (vha->hw)->mr.serial_num), (void const   *)(& pinfo->serial_num),
                                   __len___1);
    }
#line 2258
    __len___2 = 16UL;
#line 2258
    if (__len___2 > 63UL) {
#line 2258
      __ret___2 = __memcpy((void *)(& (vha->hw)->mr.hw_version), (void const   *)(& pinfo->hw_version),
                           __len___2);
    } else {
#line 2258
      __ret___2 = __builtin_memcpy((void *)(& (vha->hw)->mr.hw_version), (void const   *)(& pinfo->hw_version),
                                   __len___2);
    }
#line 2260
    __len___3 = 16UL;
#line 2260
    if (__len___3 > 63UL) {
#line 2260
      __ret___3 = __memcpy((void *)(& (vha->hw)->mr.fw_version), (void const   *)(& pinfo->fw_version),
                           __len___3);
    } else {
#line 2260
      __ret___3 = __builtin_memcpy((void *)(& (vha->hw)->mr.fw_version), (void const   *)(& pinfo->fw_version),
                                   __len___3);
    }
#line 2262
    strim((char *)(& (vha->hw)->mr.fw_version));
#line 2263
    __len___4 = 16UL;
#line 2263
    if (__len___4 > 63UL) {
#line 2263
      __ret___4 = __memcpy((void *)(& (vha->hw)->mr.uboot_version), (void const   *)(& pinfo->uboot_version),
                           __len___4);
    } else {
#line 2263
      __ret___4 = __builtin_memcpy((void *)(& (vha->hw)->mr.uboot_version), (void const   *)(& pinfo->uboot_version),
                                   __len___4);
    }
#line 2265
    __len___5 = 32UL;
#line 2265
    if (__len___5 > 63UL) {
#line 2265
      __ret___5 = __memcpy((void *)(& (vha->hw)->mr.fru_serial_num), (void const   *)(& pinfo->fru_serial_num),
                           __len___5);
    } else {
#line 2265
      __ret___5 = __builtin_memcpy((void *)(& (vha->hw)->mr.fru_serial_num), (void const   *)(& pinfo->fru_serial_num),
                                   __len___5);
    }
#line 2267
    (vha->hw)->mr.critical_temperature = pinfo->nominal_temp_value != 0U ? pinfo->nominal_temp_value : 80U;
#line 2270
    ha->mr.extended_io_enabled = (pinfo->enabled_capabilities & 32U) != 0U;
  } else
#line 2272
  if ((unsigned int )fx_type == 2U) {
#line 2273
    pinfo___0 = (struct port_info_data *)fdisc->u.fxiocb.rsp_addr;
#line 2275
    __len___6 = 8UL;
#line 2275
    if (__len___6 > 63UL) {
#line 2275
      __ret___6 = __memcpy((void *)(& vha->node_name), (void const   *)(& pinfo___0->node_name),
                           __len___6);
    } else {
#line 2275
      __ret___6 = __builtin_memcpy((void *)(& vha->node_name), (void const   *)(& pinfo___0->node_name),
                                   __len___6);
    }
#line 2276
    __len___7 = 8UL;
#line 2276
    if (__len___7 > 63UL) {
#line 2276
      __ret___7 = __memcpy((void *)(& vha->port_name), (void const   *)(& pinfo___0->port_name),
                           __len___7);
    } else {
#line 2276
      __ret___7 = __builtin_memcpy((void *)(& vha->port_name), (void const   *)(& pinfo___0->port_name),
                                   __len___7);
    }
#line 2277
    vha->d_id.b.domain = pinfo___0->port_id[0];
#line 2278
    vha->d_id.b.area = pinfo___0->port_id[1];
#line 2279
    vha->d_id.b.al_pa = pinfo___0->port_id[2];
#line 2280
    qlafx00_update_host_attr(vha, pinfo___0);
#line 2281
    ql_dump_buffer(1073872896U, vha, 321, (uint8_t *)pinfo___0, 16U);
  } else
#line 2283
  if ((unsigned int )fx_type == 128U) {
#line 2284
    pinfo___1 = (struct qlafx00_tgt_node_info *)fdisc->u.fxiocb.rsp_addr;
#line 2286
    __len___8 = 8UL;
#line 2286
    if (__len___8 > 63UL) {
#line 2286
      __ret___8 = __memcpy((void *)(& fcport->node_name), (void const   *)(& pinfo___1->tgt_node_wwnn),
                           __len___8);
    } else {
#line 2286
      __ret___8 = __builtin_memcpy((void *)(& fcport->node_name), (void const   *)(& pinfo___1->tgt_node_wwnn),
                                   __len___8);
    }
#line 2287
    __len___9 = 8UL;
#line 2287
    if (__len___9 > 63UL) {
#line 2287
      __ret___9 = __memcpy((void *)(& fcport->port_name), (void const   *)(& pinfo___1->tgt_node_wwpn),
                           __len___9);
    } else {
#line 2287
      __ret___9 = __builtin_memcpy((void *)(& fcport->port_name), (void const   *)(& pinfo___1->tgt_node_wwpn),
                                   __len___9);
    }
#line 2288
    fcport->port_type = 5;
#line 2289
    ql_dump_buffer(1073872896U, vha, 324, (uint8_t *)pinfo___1, 16U);
  } else
#line 2291
  if ((unsigned int )fx_type == 129U) {
#line 2292
    pinfo___2 = (struct qlafx00_tgt_node_info *)fdisc->u.fxiocb.rsp_addr;
#line 2294
    ql_dump_buffer(1073872896U, vha, 326, (uint8_t *)pinfo___2, 16U);
#line 2296
    __len___10 = 128UL;
#line 2296
    if (__len___10 > 63UL) {
#line 2296
      __ret___10 = __memcpy((void *)(vha->hw)->gid_list, (void const   *)pinfo___2,
                            __len___10);
    } else {
#line 2296
      __ret___10 = __builtin_memcpy((void *)(vha->hw)->gid_list, (void const   *)pinfo___2,
                                    __len___10);
    }
  } else {

  }
#line 2298
  rval = (int )fdisc->u.fxiocb.result;
  done_unmap_dma: ;
#line 2301
  if ((unsigned long )fdisc->u.fxiocb.rsp_addr != (unsigned long )((void *)0)) {
#line 2302
    dma_free_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.rsp_len, fdisc->u.fxiocb.rsp_addr,
                   fdisc->u.fxiocb.rsp_dma_handle, (struct dma_attrs *)0);
  } else {

  }
  done_unmap_req: ;
#line 2306
  if ((unsigned long )fdisc->u.fxiocb.req_addr != (unsigned long )((void *)0)) {
#line 2307
    dma_free_attrs(& (ha->pdev)->dev, (size_t )fdisc->u.fxiocb.req_len, fdisc->u.fxiocb.req_addr,
                   fdisc->u.fxiocb.req_dma_handle, (struct dma_attrs *)0);
  } else {

  }
  done_free_sp: 
#line 2310
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 2312
  return (rval);
}
}
#line 2316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_abort_iocb_timeout(void *data ) 
{ 
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 2318
  sp = (srb_t *)data;
#line 2319
  abt = & sp->u.iocb_cmd;
#line 2321
  abt->u.abt.comp_status = 6U;
#line 2322
  complete(& abt->u.abt.comp);
#line 2323
  return;
}
}
#line 2326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_abort_sp_done(void *data , void *ptr , int res ) 
{ 
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 2328
  sp = (srb_t *)ptr;
#line 2329
  abt = & sp->u.iocb_cmd;
#line 2331
  complete(& abt->u.abt.comp);
#line 2332
  return;
}
}
#line 2335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static int qlafx00_async_abt_cmd(srb_t *cmd_sp ) 
{ 
  scsi_qla_host_t *vha ;
  fc_port_t *fcport ;
  struct srb_iocb *abt_iocb ;
  srb_t *sp ;
  int rval ;

  {
#line 2337
  vha = (cmd_sp->fcport)->vha;
#line 2338
  fcport = cmd_sp->fcport;
#line 2341
  rval = 258;
#line 2343
  sp = qla2x00_get_sp(vha, fcport, 208U);
#line 2344
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2345
    goto done;
  } else {

  }
#line 2347
  abt_iocb = & sp->u.iocb_cmd;
#line 2348
  sp->type = 12U;
#line 2349
  sp->name = (char *)"abort";
#line 2350
  qla2x00_init_timer(sp, 20UL);
#line 2351
  abt_iocb->u.abt.cmd_hndl = cmd_sp->handle;
#line 2352
  sp->done = & qlafx00_abort_sp_done;
#line 2353
  abt_iocb->timeout = & qlafx00_abort_iocb_timeout;
#line 2354
  init_completion(& abt_iocb->u.abt.comp);
#line 2356
  rval = qla2x00_start_sp(sp);
#line 2357
  if (rval != 0) {
#line 2358
    goto done_free_sp;
  } else {

  }
#line 2360
  ql_dbg(33554432U, vha, 20604, "Abort command issued - hdl=%x, target_id=%x\n", cmd_sp->handle,
         (int )fcport->tgt_id);
#line 2364
  wait_for_completion(& abt_iocb->u.abt.comp);
#line 2366
  rval = (unsigned int )abt_iocb->u.abt.comp_status == 0U ? 0 : 258;
  done_free_sp: 
#line 2370
  (*(sp->free))((void *)vha, (void *)sp);
  done: ;
#line 2372
  return (rval);
}
}
#line 2376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_abort_command(srb_t *sp ) 
{ 
  unsigned long flags ;
  uint32_t handle ;
  fc_port_t *fcport ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct req_que *req ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 2378
  flags = 0UL;
#line 2381
  fcport = sp->fcport;
#line 2382
  vha = fcport->vha;
#line 2383
  ha = vha->hw;
#line 2384
  req = vha->req;
#line 2386
  tmp = spinlock_check(& ha->hardware_lock);
#line 2386
  flags = _raw_spin_lock_irqsave(tmp);
#line 2387
  handle = 1U;
#line 2387
  goto ldv_44064;
  ldv_44063: ;
#line 2388
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )sp) {
#line 2389
    goto ldv_44062;
  } else {

  }
#line 2387
  handle = handle + 1U;
  ldv_44064: ;
#line 2387
  if (handle <= 1023U) {
#line 2389
    goto ldv_44063;
  } else {

  }
  ldv_44062: 
#line 2391
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2392
  if (handle == 1024U) {
#line 2394
    return (258);
  } else {

  }
#line 2396
  tmp___0 = qlafx00_async_abt_cmd(sp);
#line 2396
  return (tmp___0);
}
}
#line 2410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_initialize_adapter(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  struct qla_hw_data *ha ;
  uint32_t tempc ;
  unsigned int tmp ;

  {
#line 2413
  ha = vha->hw;
#line 2417
  vha->flags.online = 0U;
#line 2418
  ha->flags.chip_reset_done = 0U;
#line 2419
  vha->flags.reset_active = 0U;
#line 2420
  ha->flags.pci_channel_io_perm_failure = 0U;
#line 2421
  ha->flags.eeh_busy = 0U;
#line 2422
  atomic_set(& vha->loop_down_timer, 255);
#line 2423
  atomic_set(& vha->loop_state, 2);
#line 2424
  vha->device_flags = 2U;
#line 2425
  vha->dpc_flags = 0UL;
#line 2426
  vha->flags.management_server_logged_in = 0U;
#line 2427
  vha->marker_needed = 0U;
#line 2428
  ha->isp_abort_cnt = 0U;
#line 2429
  ha->beacon_blink_led = 0U;
#line 2431
  set_bit(0L, (unsigned long volatile   *)(& ha->req_qid_map));
#line 2432
  set_bit(0L, (unsigned long volatile   *)(& ha->rsp_qid_map));
#line 2434
  ql_dbg(1073741824U, vha, 327, "Configuring PCI space...\n");
#line 2437
  rval = (*((ha->isp_ops)->pci_config))(vha);
#line 2438
  if (rval != 0) {
#line 2439
    ql_log(1U, vha, 328, "Unable to configure PCI space.\n");
#line 2441
    return (rval);
  } else {

  }
#line 2444
  rval = qlafx00_init_fw_ready(vha);
#line 2445
  if (rval != 0) {
#line 2446
    return (rval);
  } else {

  }
#line 2448
  qlafx00_save_queue_ptrs(vha);
#line 2450
  rval = qlafx00_config_queues(vha);
#line 2451
  if (rval != 0) {
#line 2452
    return (rval);
  } else {

  }
#line 2458
  rval = qla2x00_alloc_outstanding_cmds(ha, vha->req);
#line 2459
  if (rval != 0) {
#line 2460
    return (rval);
  } else {

  }
#line 2462
  rval = qla2x00_init_rings(vha);
#line 2463
  ha->flags.chip_reset_done = 1U;
#line 2465
  tmp = readl((void const volatile   *)ha->cregbase + 99524U);
#line 2465
  tempc = (3153000U - ((tmp & 1022U) >> 1) * 10000U) / 13825U;
#line 2466
  ql_dbg(1073741824U, vha, 338, "ISPFx00(%s): Critical temp timer, current SOC temperature: 0x%x\n",
         "qlafx00_initialize_adapter", tempc);
#line 2470
  return (rval);
}
}
#line 2474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
uint32_t qlafx00_fw_state_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  scsi_qla_host_t *vha ;
  struct device  const  *__mptr ;
  void *tmp ;
  int rval ;
  uint32_t state[1U] ;
  int tmp___0 ;

  {
#line 2477
  __mptr = (struct device  const  *)dev;
#line 2477
  tmp = shost_priv((struct Scsi_Host *)__mptr + 0xfffffffffffff7d8UL);
#line 2477
  vha = (scsi_qla_host_t *)tmp;
#line 2478
  rval = 258;
#line 2481
  tmp___0 = qla2x00_reset_active(vha);
#line 2481
  if (tmp___0 != 0) {
#line 2482
    ql_log(1U, vha, 28878, "ISP reset active.\n");
  } else
#line 2484
  if (*((unsigned long *)vha->hw + 2UL) == 0UL) {
#line 2485
    rval = qlafx00_get_firmware_state(vha, (uint32_t *)(& state));
  } else {

  }
#line 2487
  if (rval != 0) {
#line 2488
    memset((void *)(& state), -1, 4UL);
  } else {

  }
#line 2490
  return (state[0]);
}
}
#line 2494 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct qla_hw_data *ha ;
  void *tmp ;
  u32 speed ;

  {
#line 2496
  tmp = shost_priv(shost);
#line 2496
  ha = ((struct scsi_qla_host *)tmp)->hw;
#line 2498
  speed = 0U;
#line 2500
  switch ((int )ha->link_data_rate) {
  case 2: 
#line 2502
  speed = 2U;
#line 2503
  goto ldv_44088;
  case 4: 
#line 2505
  speed = 8U;
#line 2506
  goto ldv_44088;
  case 8: 
#line 2508
  speed = 16U;
#line 2509
  goto ldv_44088;
  case 10: 
#line 2511
  speed = 4U;
#line 2512
  goto ldv_44088;
  }
  ldv_44088: 
#line 2514
  ((struct fc_host_attrs *)shost->shost_data)->speed = speed;
#line 2515
  return;
}
}
#line 2520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
__inline static void qlafx00_handle_sense(srb_t *sp , uint8_t *sense_data , uint32_t par_sense_len ,
                                          uint32_t sense_len , struct rsp_que *rsp ,
                                          int res ) 
{ 
  struct scsi_qla_host *vha ;
  struct scsi_cmnd *cp ;
  uint32_t track_sense_len ;
  size_t __len ;
  void *__ret ;

  {
#line 2523
  vha = (sp->fcport)->vha;
#line 2524
  cp = sp->u.scmd.cmd;
#line 2527
  sp->u.scmd.fw_sense_length = sense_len;
#line 2529
  if (sense_len > 95U) {
#line 2530
    sense_len = 96U;
  } else {

  }
#line 2532
  sp->u.scmd.request_sense_length = sense_len;
#line 2533
  sp->u.scmd.request_sense_ptr = cp->sense_buffer;
#line 2534
  track_sense_len = sense_len;
#line 2536
  if (sense_len > par_sense_len) {
#line 2537
    sense_len = par_sense_len;
  } else {

  }
#line 2539
  __len = (size_t )sense_len;
#line 2539
  __ret = __builtin_memcpy((void *)cp->sense_buffer, (void const   *)sense_data, __len);
#line 2541
  sp->u.scmd.fw_sense_length = sp->u.scmd.fw_sense_length - sense_len;
#line 2543
  sp->u.scmd.request_sense_ptr = cp->sense_buffer + (unsigned long )sense_len;
#line 2544
  track_sense_len = track_sense_len - sense_len;
#line 2545
  sp->u.scmd.request_sense_length = track_sense_len;
#line 2547
  ql_dbg(134217728U, vha, 12365, "sense_len=0x%x par_sense_len=0x%x track_sense_len=0x%x.\n",
         sense_len, par_sense_len, track_sense_len);
#line 2550
  if (sp->u.scmd.fw_sense_length != 0U) {
#line 2551
    rsp->status_srb = sp;
#line 2552
    cp->result = res;
  } else {

  }
#line 2555
  if (sense_len != 0U) {
#line 2556
    ql_dbg(134348800U, vha, 12345, "Check condition Sense data, nexus%ld:%d:%d cmd=%p.\n",
           ((sp->fcport)->vha)->host_no, (cp->device)->id, (cp->device)->lun, cp);
#line 2560
    ql_dump_buffer(134348800U, vha, 12361, cp->sense_buffer, sense_len);
  } else {

  }
#line 2563
  return;
}
}
#line 2566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_tm_iocb_entry(scsi_qla_host_t *vha , struct req_que *req , struct tsk_mgmt_entry_fx00 *pkt ,
                                  srb_t *sp , __le16 sstatus , __le16 cpstatus ) 
{ 
  struct srb_iocb *tmf ;

  {
#line 2572
  tmf = & sp->u.iocb_cmd;
#line 2573
  if ((unsigned int )cpstatus != 0U || ((int )sstatus & 256) != 0) {
#line 2575
    cpstatus = 1U;
  } else {

  }
#line 2576
  tmf->u.tmf.comp_status = cpstatus;
#line 2577
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2578
  return;
}
}
#line 2581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_abort_iocb_entry(scsi_qla_host_t *vha , struct req_que *req ,
                                     struct abort_iocb_entry_fx00 *pkt ) 
{ 
  char func[9U] ;
  srb_t *sp ;
  struct srb_iocb *abt ;

  {
#line 2584
  func[0] = 'A';
#line 2584
  func[1] = 'B';
#line 2584
  func[2] = 'T';
#line 2584
  func[3] = '_';
#line 2584
  func[4] = 'I';
#line 2584
  func[5] = 'O';
#line 2584
  func[6] = 'C';
#line 2584
  func[7] = 'B';
#line 2584
  func[8] = '\000';
#line 2588
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2589
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2590
    return;
  } else {

  }
#line 2592
  abt = & sp->u.iocb_cmd;
#line 2593
  abt->u.abt.comp_status = pkt->tgt_id_sts;
#line 2594
  (*(sp->done))((void *)vha, (void *)sp, 0);
#line 2595
  return;
}
}
#line 2598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_ioctl_iosb_entry(scsi_qla_host_t *vha , struct req_que *req ,
                                     struct ioctl_iocb_entry_fx00 *pkt ) 
{ 
  char func[10U] ;
  srb_t *sp ;
  struct fc_bsg_job *bsg_job ;
  struct srb_iocb *iocb_job ;
  int res ;
  struct qla_mt_iocb_rsp_fx00 fstatus ;
  uint8_t *fw_sts_ptr ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2601
  func[0] = 'I';
#line 2601
  func[1] = 'O';
#line 2601
  func[2] = 'S';
#line 2601
  func[3] = 'B';
#line 2601
  func[4] = '_';
#line 2601
  func[5] = 'I';
#line 2601
  func[6] = 'O';
#line 2601
  func[7] = 'C';
#line 2601
  func[8] = 'B';
#line 2601
  func[9] = '\000';
#line 2609
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 2610
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2611
    return;
  } else {

  }
#line 2613
  if ((unsigned int )sp->type == 10U) {
#line 2614
    iocb_job = & sp->u.iocb_cmd;
#line 2615
    iocb_job->u.fxiocb.seq_number = pkt->seq_no;
#line 2616
    iocb_job->u.fxiocb.fw_flags = pkt->fw_iotcl_flags;
#line 2617
    iocb_job->u.fxiocb.result = pkt->status;
#line 2618
    if (((int )iocb_job->u.fxiocb.flags & 8) != 0) {
#line 2619
      iocb_job->u.fxiocb.req_data = pkt->dataword_r;
    } else {

    }
  } else {
#line 2622
    bsg_job = sp->u.bsg_job;
#line 2624
    memset((void *)(& fstatus), 0, 56UL);
#line 2626
    fstatus.reserved_1 = pkt->reserved_0;
#line 2627
    fstatus.func_type = pkt->comp_func_num;
#line 2628
    fstatus.ioctl_flags = pkt->fw_iotcl_flags;
#line 2629
    fstatus.ioctl_data = pkt->dataword_r;
#line 2630
    fstatus.adapid = pkt->adapid;
#line 2631
    fstatus.adapid_hi = pkt->adapid_hi;
#line 2632
    fstatus.reserved_2 = pkt->reserved_1;
#line 2633
    fstatus.res_count = (int32_t )pkt->residuallen;
#line 2634
    fstatus.status = pkt->status;
#line 2635
    fstatus.seq_number = pkt->seq_no;
#line 2636
    __len = 20UL;
#line 2636
    if (__len > 63UL) {
#line 2636
      __ret = __memcpy((void *)(& fstatus.reserved_3), (void const   *)(& pkt->reserved_2),
                       __len);
    } else {
#line 2636
      __ret = __builtin_memcpy((void *)(& fstatus.reserved_3), (void const   *)(& pkt->reserved_2),
                               __len);
    }
#line 2639
    fw_sts_ptr = (uint8_t *)(bsg_job->req)->sense + 16UL;
#line 2642
    __len___0 = 56UL;
#line 2642
    if (__len___0 > 63UL) {
#line 2642
      __ret___0 = __memcpy((void *)fw_sts_ptr, (void const   *)(& fstatus), __len___0);
    } else {
#line 2642
      __ret___0 = __builtin_memcpy((void *)fw_sts_ptr, (void const   *)(& fstatus),
                                   __len___0);
    }
#line 2644
    bsg_job->reply_len = 73U;
#line 2647
    ql_dump_buffer(8421376U, (sp->fcport)->vha, 20608, (uint8_t *)pkt, 64U);
#line 2651
    ql_dump_buffer(8421376U, (sp->fcport)->vha, 20596, fw_sts_ptr, 56U);
#line 2655
    (bsg_job->reply)->result = 0U;
#line 2655
    res = 0;
#line 2656
    (bsg_job->reply)->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
  }
#line 2659
  (*(sp->done))((void *)vha, (void *)sp, res);
#line 2660
  return;
}
}
#line 2668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_status_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , void *pkt ) 
{ 
  srb_t *sp ;
  fc_port_t *fcport ;
  struct scsi_cmnd *cp ;
  struct sts_entry_fx00 *sts ;
  __le16 comp_status ;
  __le16 scsi_status ;
  uint16_t ox_id ;
  __le16 lscsi_status ;
  int32_t resid ;
  uint32_t sense_len ;
  uint32_t par_sense_len ;
  uint32_t rsp_info_len ;
  uint32_t resid_len ;
  uint32_t fw_resid_len ;
  uint8_t *rsp_info ;
  uint8_t *sense_data ;
  struct qla_hw_data *ha ;
  uint32_t hindex ;
  uint32_t handle ;
  uint16_t que ;
  struct req_que *req ;
  int logit ;
  int res ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 2681
  rsp_info = (uint8_t *)0U;
#line 2681
  sense_data = (uint8_t *)0U;
#line 2682
  ha = vha->hw;
#line 2686
  logit = 1;
#line 2687
  res = 0;
#line 2689
  sts = (struct sts_entry_fx00 *)pkt;
#line 2691
  comp_status = sts->comp_status;
#line 2692
  scsi_status = (unsigned int )sts->scsi_status & 4095U;
#line 2693
  hindex = sts->handle;
#line 2694
  handle = (uint32_t )((unsigned short )hindex);
#line 2696
  que = (unsigned short )(hindex >> 16);
#line 2697
  req = *(ha->req_q_map + (unsigned long )que);
#line 2700
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 2701
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 2703
    sp = (srb_t *)0;
  }
#line 2705
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2706
    ql_dbg(134217728U, vha, 12340, "Invalid status handle (0x%x).\n", handle);
#line 2709
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2710
    qla2xxx_wake_dpc(vha);
#line 2711
    return;
  } else {

  }
#line 2714
  if ((unsigned int )sp->type == 7U) {
#line 2715
    *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2716
    qlafx00_tm_iocb_entry(vha, req, (struct tsk_mgmt_entry_fx00 *)pkt, sp, (int )scsi_status,
                          (int )comp_status);
#line 2718
    return;
  } else {

  }
#line 2722
  if ((unsigned int )comp_status == 0U && (unsigned int )scsi_status == 0U) {
#line 2723
    qla2x00_do_host_ramp_up(vha);
#line 2724
    qla2x00_process_completed_request(vha, req, handle);
#line 2725
    return;
  } else {

  }
#line 2728
  *(req->outstanding_cmds + (unsigned long )handle) = (srb_t *)0;
#line 2729
  cp = sp->u.scmd.cmd;
#line 2730
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2731
    ql_dbg(134217728U, vha, 12360, "Command already returned (0x%x/%p).\n", handle,
           sp);
#line 2735
    return;
  } else {

  }
#line 2738
  lscsi_status = (unsigned int )scsi_status & 254U;
#line 2740
  fcport = sp->fcport;
#line 2742
  ox_id = 0U;
#line 2743
  fw_resid_len = 0U;
#line 2743
  resid_len = fw_resid_len;
#line 2743
  rsp_info_len = resid_len;
#line 2743
  par_sense_len = rsp_info_len;
#line 2743
  sense_len = par_sense_len;
#line 2745
  if (((int )scsi_status & 512) != 0) {
#line 2746
    sense_len = sts->sense_len;
  } else {

  }
#line 2747
  if (((int )scsi_status & 3072) != 0) {
#line 2749
    resid_len = sts->residual_len;
  } else {

  }
#line 2750
  if ((unsigned int )comp_status == 21U) {
#line 2751
    fw_resid_len = sts->residual_len;
  } else {

  }
#line 2752
  sense_data = (uint8_t *)(& sts->data);
#line 2752
  rsp_info = sense_data;
#line 2753
  par_sense_len = 32U;
#line 2756
  if ((unsigned int )comp_status == 0U && ((int )scsi_status & 1024) != 0) {
#line 2758
    comp_status = 7U;
  } else {

  }
#line 2763
  switch ((int )comp_status) {
  case 0: ;
  case 28: ;
#line 2766
  if ((unsigned int )scsi_status == 0U) {
#line 2767
    res = 0;
#line 2768
    goto ldv_44171;
  } else {

  }
#line 2770
  if (((int )scsi_status & 3072) != 0) {
#line 2772
    resid = (int32_t )resid_len;
#line 2773
    scsi_set_resid(cp, resid);
#line 2775
    if ((unsigned int )lscsi_status == 0U) {
#line 2775
      tmp___0 = scsi_bufflen(cp);
#line 2775
      if (tmp___0 - (unsigned int )resid < cp->underflow) {
#line 2778
        tmp = scsi_bufflen(cp);
#line 2778
        ql_dbg(134217728U, fcport->vha, 12368, "Mid-layer underflow detected (0x%x of 0x%x bytes).\n",
               resid, tmp);
#line 2783
        res = 458752;
#line 2784
        goto ldv_44171;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2787
  res = (int )lscsi_status;
#line 2789
  if ((unsigned int )lscsi_status == 40U) {
#line 2791
    ql_dbg(134217728U, fcport->vha, 12369, "QUEUE FULL detected.\n");
#line 2793
    goto ldv_44171;
  } else {

  }
#line 2795
  logit = 0;
#line 2796
  if ((unsigned int )lscsi_status != 2U) {
#line 2797
    goto ldv_44171;
  } else {

  }
#line 2799
  memset((void *)cp->sense_buffer, 0, 96UL);
#line 2800
  if (((int )scsi_status & 512) == 0) {
#line 2801
    goto ldv_44171;
  } else {

  }
#line 2803
  qlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
#line 2805
  goto ldv_44171;
  case 21: ;
#line 2809
  if ((ha->device_type & 134217728U) != 0U || (ha->device_type & 131072U) != 0U) {
#line 2810
    resid = (int32_t )fw_resid_len;
  } else {
#line 2812
    resid = (int32_t )resid_len;
  }
#line 2813
  scsi_set_resid(cp, resid);
#line 2814
  if (((int )scsi_status & 2048) != 0) {
#line 2815
    if (((ha->device_type & 134217728U) != 0U || (ha->device_type & 131072U) != 0U) && fw_resid_len != resid_len) {
#line 2817
      tmp___1 = scsi_bufflen(cp);
#line 2817
      ql_dbg(134217728U, fcport->vha, 12370, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
             resid, tmp___1);
#line 2822
      res = (int )lscsi_status | 458752;
#line 2824
      goto check_scsi_status;
    } else {

    }
#line 2827
    if ((unsigned int )lscsi_status == 0U) {
#line 2827
      tmp___3 = scsi_bufflen(cp);
#line 2827
      if (tmp___3 - (unsigned int )resid < cp->underflow) {
#line 2830
        tmp___2 = scsi_bufflen(cp);
#line 2830
        ql_dbg(134217728U, fcport->vha, 12371, "Mid-layer underflow detected (0x%x of 0x%x bytes, cp->underflow: 0x%x).\n",
               resid, tmp___2, cp->underflow);
#line 2836
        res = 458752;
#line 2837
        goto ldv_44171;
      } else {

      }
    } else {

    }
  } else
#line 2839
  if ((unsigned int )lscsi_status != 40U && (unsigned int )lscsi_status != 8U) {
#line 2847
    tmp___4 = scsi_bufflen(cp);
#line 2847
    ql_dbg(134217728U, fcport->vha, 12372, "Dropped frame(s) detected (0x%x of 0x%x bytes).\n",
           resid, tmp___4);
#line 2852
    res = (int )lscsi_status | 458752;
#line 2853
    goto check_scsi_status;
  } else {
#line 2855
    ql_dbg(134217728U, fcport->vha, 12373, "scsi_status: 0x%x, lscsi_status: 0x%x\n",
           (int )scsi_status, (int )lscsi_status);
  }
#line 2860
  res = (int )lscsi_status;
#line 2861
  logit = 0;
  check_scsi_status: ;
#line 2868
  if ((unsigned int )lscsi_status != 0U) {
#line 2869
    if ((unsigned int )lscsi_status == 40U) {
#line 2871
      ql_dbg(134217728U, fcport->vha, 12374, "QUEUE FULL detected.\n");
#line 2873
      logit = 1;
#line 2874
      goto ldv_44171;
    } else {

    }
#line 2876
    if ((unsigned int )lscsi_status != 2U) {
#line 2878
      goto ldv_44171;
    } else {

    }
#line 2880
    memset((void *)cp->sense_buffer, 0, 96UL);
#line 2881
    if (((int )scsi_status & 512) == 0) {
#line 2883
      goto ldv_44171;
    } else {

    }
#line 2885
    qlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len, rsp, res);
  } else {

  }
#line 2888
  goto ldv_44171;
  case 41: ;
  case 42: ;
  case 43: ;
  case 1: ;
  case 40: ;
  case 6: ;
  case 4: 
#line 2903
  res = 917504;
#line 2905
  tmp___5 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2905
  ql_dbg(134217728U, fcport->vha, 12375, "Port down status: port-state=0x%x.\n", tmp___5);
#line 2909
  tmp___6 = atomic_read((atomic_t const   *)(& fcport->state));
#line 2909
  if (tmp___6 == 4) {
#line 2910
    qla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);
  } else {

  }
#line 2911
  goto ldv_44171;
  case 5: 
#line 2914
  res = 524288;
#line 2915
  goto ldv_44171;
  default: 
#line 2918
  res = 458752;
#line 2919
  goto ldv_44171;
  }
  ldv_44171: ;
#line 2922
  if (logit != 0) {
#line 2923
    tmp___7 = scsi_bufflen(cp);
#line 2923
    ql_dbg(134217728U, fcport->vha, 12376, "FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%d tgt_id: 0x%x lscsi_status: 0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x sense_len=0x%x, par_sense_len=0x%x, rsp_info_len=0x%x\n",
           (int )comp_status, (int )scsi_status, res, vha->host_no, (cp->device)->id,
           (cp->device)->lun, (int )fcport->tgt_id, (int )lscsi_status, cp->cmnd,
           tmp___7, rsp_info_len, resid_len, fw_resid_len, sense_len, par_sense_len,
           rsp_info_len);
  } else {

  }
#line 2934
  if (res == 0) {
#line 2935
    qla2x00_do_host_ramp_up(vha);
  } else {

  }
#line 2937
  if ((unsigned long )rsp->status_srb == (unsigned long )((srb_t *)0)) {
#line 2938
    (*(sp->done))((void *)ha, (void *)sp, res);
  } else {

  }
#line 2939
  return;
}
}
#line 2949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_status_cont_entry(struct rsp_que *rsp , sts_cont_entry_t *pkt ) 
{ 
  uint8_t sense_sz ;
  struct qla_hw_data *ha ;
  struct scsi_qla_host *vha ;
  void *tmp ;
  srb_t *sp ;
  struct scsi_cmnd *cp ;
  uint32_t sense_len ;
  uint8_t *sense_ptr ;
  size_t __len ;
  void *__ret ;

  {
#line 2951
  sense_sz = 0U;
#line 2952
  ha = rsp->hw;
#line 2953
  tmp = pci_get_drvdata(ha->pdev);
#line 2953
  vha = (struct scsi_qla_host *)tmp;
#line 2954
  sp = rsp->status_srb;
#line 2959
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 2960
    ql_dbg(134217728U, vha, 12343, "no SP, sp = %p\n", sp);
#line 2962
    return;
  } else {

  }
#line 2965
  if (sp->u.scmd.fw_sense_length == 0U) {
#line 2966
    ql_dbg(134217728U, vha, 12363, "no fw sense data, sp = %p\n", sp);
#line 2968
    return;
  } else {

  }
#line 2970
  cp = sp->u.scmd.cmd;
#line 2971
  if ((unsigned long )cp == (unsigned long )((struct scsi_cmnd *)0)) {
#line 2972
    ql_log(1U, vha, 12347, "cmd is NULL: already returned to OS (sp=%p).\n", sp);
#line 2975
    rsp->status_srb = (srb_t *)0;
#line 2976
    return;
  } else {

  }
#line 2979
  if (sp->u.scmd.request_sense_length == 0U) {
#line 2980
    ql_dbg(134217728U, vha, 12364, "no sense data, sp = %p\n", sp);
  } else {
#line 2983
    sense_len = sp->u.scmd.request_sense_length;
#line 2984
    sense_ptr = sp->u.scmd.request_sense_ptr;
#line 2985
    ql_dbg(134217728U, vha, 12367, "sp=%p sense_len=0x%x sense_ptr=%p.\n", sp, sense_len,
           sense_ptr);
#line 2989
    if (sense_len > 60U) {
#line 2990
      sense_sz = 60U;
    } else {
#line 2992
      sense_sz = (uint8_t )sense_len;
    }
#line 2995
    ql_dump_buffer(134348800U, vha, 12366, (uint8_t *)pkt, 64U);
#line 2997
    __len = (size_t )sense_sz;
#line 2997
    __ret = __builtin_memcpy((void *)sense_ptr, (void const   *)(& pkt->data), __len);
#line 2998
    ql_dump_buffer(134348800U, vha, 12362, sense_ptr, (uint32_t )sense_sz);
#line 3001
    sense_len = sense_len - (uint32_t )sense_sz;
#line 3002
    sense_ptr = sense_ptr + (unsigned long )sense_sz;
#line 3004
    sp->u.scmd.request_sense_ptr = sense_ptr;
#line 3005
    sp->u.scmd.request_sense_length = sense_len;
  }
#line 3007
  sense_len = sp->u.scmd.fw_sense_length;
#line 3008
  sense_len = sense_len > 60U ? sense_len - 60U : 0U;
#line 3010
  sp->u.scmd.fw_sense_length = sense_len;
#line 3013
  if (sense_len == 0U) {
#line 3014
    rsp->status_srb = (srb_t *)0;
#line 3015
    (*(sp->done))((void *)ha, (void *)sp, cp->result);
  } else {

  }
#line 3017
  return;
}
}
#line 3024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_multistatus_entry(struct scsi_qla_host *vha , struct rsp_que *rsp ,
                                      void *pkt ) 
{ 
  srb_t *sp ;
  struct multi_sts_entry_fx00 *stsmfx ;
  struct qla_hw_data *ha ;
  uint32_t handle ;
  uint32_t hindex ;
  uint32_t handle_count ;
  uint32_t i ;
  uint16_t que ;
  struct req_que *req ;
  __le32 *handle_ptr ;

  {
#line 3029
  ha = vha->hw;
#line 3035
  stsmfx = (struct multi_sts_entry_fx00 *)pkt;
#line 3037
  handle_count = (uint32_t )stsmfx->handle_count;
#line 3039
  if (handle_count > 15U) {
#line 3040
    ql_dbg(134217728U, vha, 12341, "Invalid handle count (0x%x).\n", handle_count);
#line 3042
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3043
    qla2xxx_wake_dpc(vha);
#line 3044
    return;
  } else {

  }
#line 3047
  handle_ptr = (__le32 *)(& stsmfx->handles);
#line 3049
  i = 0U;
#line 3049
  goto ldv_44213;
  ldv_44212: 
#line 3050
  hindex = *handle_ptr;
#line 3051
  handle = (uint32_t )((unsigned short )hindex);
#line 3052
  que = (unsigned short )(hindex >> 16);
#line 3053
  req = *(ha->req_q_map + (unsigned long )que);
#line 3056
  if ((uint32_t )req->num_outstanding_cmds > handle) {
#line 3057
    sp = *(req->outstanding_cmds + (unsigned long )handle);
  } else {
#line 3059
    sp = (srb_t *)0;
  }
#line 3061
  if ((unsigned long )sp == (unsigned long )((srb_t *)0)) {
#line 3062
    ql_dbg(134217728U, vha, 12356, "Invalid status handle (0x%x).\n", handle);
#line 3064
    set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3065
    qla2xxx_wake_dpc(vha);
#line 3066
    return;
  } else {

  }
#line 3068
  qla2x00_process_completed_request(vha, req, handle);
#line 3069
  handle_ptr = handle_ptr + 1;
#line 3049
  i = i + 1U;
  ldv_44213: ;
#line 3049
  if (i < handle_count) {
#line 3051
    goto ldv_44212;
  } else {

  }

#line 3056
  return;
}
}
#line 3079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_error_entry(scsi_qla_host_t *vha , struct rsp_que *rsp , struct sts_entry_fx00 *pkt ,
                                uint8_t estatus , uint8_t etype ) 
{ 
  srb_t *sp ;
  struct qla_hw_data *ha ;
  char func[11U] ;
  uint16_t que ;
  struct req_que *req ;
  int res ;

  {
#line 3083
  ha = vha->hw;
#line 3084
  func[0] = 'E';
#line 3084
  func[1] = 'R';
#line 3084
  func[2] = 'R';
#line 3084
  func[3] = 'O';
#line 3084
  func[4] = 'R';
#line 3084
  func[5] = '-';
#line 3084
  func[6] = 'I';
#line 3084
  func[7] = 'O';
#line 3084
  func[8] = 'C';
#line 3084
  func[9] = 'B';
#line 3084
  func[10] = '\000';
#line 3085
  que = (unsigned short )(pkt->handle >> 16);
#line 3086
  req = (struct req_que *)0;
#line 3087
  res = 458752;
#line 3089
  ql_dbg(33554432U, vha, 20607, "type of error status in response: 0x%x\n", (int )estatus);
#line 3092
  req = *(ha->req_q_map + (unsigned long )que);
#line 3094
  sp = qla2x00_get_sp_from_handle(vha, (char const   *)(& func), req, (void *)pkt);
#line 3095
  if ((unsigned long )sp != (unsigned long )((srb_t *)0)) {
#line 3096
    (*(sp->done))((void *)ha, (void *)sp, res);
#line 3097
    return;
  } else {

  }
#line 3100
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3101
  qla2xxx_wake_dpc(vha);
#line 3102
  return;
}
}
#line 3109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_process_response_queue(struct scsi_qla_host *vha , struct rsp_que *rsp ) 
{ 
  struct sts_entry_fx00 *pkt ;
  response_t *lptr ;
  unsigned int tmp ;

  {
#line 3115
  goto ldv_44243;
  ldv_44242: 
#line 3117
  lptr = rsp->ring_ptr;
#line 3118
  memcpy_fromio((void *)(& rsp->rsp_pkt), (void const volatile   *)lptr, 64UL);
#line 3120
  pkt = (struct sts_entry_fx00 *)(& rsp->rsp_pkt);
#line 3122
  rsp->ring_index = (uint16_t )((int )rsp->ring_index + 1);
#line 3123
  if ((int )rsp->ring_index == (int )rsp->length) {
#line 3124
    rsp->ring_index = 0U;
#line 3125
    rsp->ring_ptr = rsp->ring;
  } else {
#line 3127
    rsp->ring_ptr = rsp->ring_ptr + 1;
  }
#line 3130
  if ((unsigned int )pkt->entry_status != 0U && (unsigned int )pkt->entry_type != 12U) {
#line 3132
    qlafx00_error_entry(vha, rsp, pkt, (int )pkt->entry_status, (int )pkt->entry_type);
#line 3135
    goto next_iter;
  } else {

  }
#line 3139
  switch ((int )pkt->entry_type) {
  case 1: 
#line 3141
  qlafx00_status_entry(vha, rsp, (void *)pkt);
#line 3142
  goto ldv_44236;
  case 4: 
#line 3145
  qlafx00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);
#line 3146
  goto ldv_44236;
  case 13: 
#line 3149
  qlafx00_multistatus_entry(vha, rsp, (void *)pkt);
#line 3150
  goto ldv_44236;
  case 8: 
#line 3153
  qlafx00_abort_iocb_entry(vha, rsp->req, (struct abort_iocb_entry_fx00 *)pkt);
#line 3155
  goto ldv_44236;
  case 12: 
#line 3158
  qlafx00_ioctl_iosb_entry(vha, rsp->req, (struct ioctl_iocb_entry_fx00 *)pkt);
#line 3160
  goto ldv_44236;
  default: 
#line 3163
  ql_dbg(33554432U, vha, 20609, "Received unknown response pkt type %x entry status=%x.\n",
         (int )pkt->entry_type, (int )pkt->entry_status);
#line 3167
  goto ldv_44236;
  }
  ldv_44236: ;
  next_iter: 
#line 3170
  writel(3735936685U, (void volatile   *)(& lptr->signature));
#line 3172
  __asm__  volatile   ("sfence": : : "memory");
  ldv_44243: 
#line 3115
  tmp = readl((void const volatile   *)(& (rsp->ring_ptr)->signature));
#line 3115
  if (tmp != 3735936685U) {
#line 3117
    goto ldv_44242;
  } else {

  }
#line 3176
  writel((unsigned int )rsp->ring_index, (void volatile   *)rsp->rsp_q_out);
#line 3177
  return;
}
}
#line 3184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_async_event(scsi_qla_host_t *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  int data_size ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;

  {
#line 3186
  ha = vha->hw;
#line 3188
  data_size = 1;
#line 3190
  reg = & (ha->iobase)->ispfx00;
#line 3192
  switch (ha->aenmb[0]) {
  case 32770U: 
#line 3194
  ql_log(1U, vha, 20601, "ISP System Error - mbx1=%x\n", ha->aenmb[0]);
#line 3196
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3197
  goto ldv_44252;
  case 32866U: 
#line 3200
  ql_dbg(33554432U, vha, 20598, "Asynchronous FW shutdown requested.\n");
#line 3202
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 3203
  qla2xxx_wake_dpc(vha);
#line 3204
  goto ldv_44252;
  case 32788U: 
#line 3207
  tmp = readw((void const volatile   *)(& reg->aenmailbox1));
#line 3207
  ha->aenmb[1] = (uint32_t )tmp;
#line 3208
  tmp___0 = readw((void const volatile   *)(& reg->aenmailbox2));
#line 3208
  ha->aenmb[2] = (uint32_t )tmp___0;
#line 3209
  tmp___1 = readw((void const volatile   *)(& reg->aenmailbox3));
#line 3209
  ha->aenmb[3] = (uint32_t )tmp___1;
#line 3210
  ql_dbg(33554432U, vha, 20599, "Asynchronous port Update received aenmb[0]: %x, aenmb[1]: %x, aenmb[2]: %x, aenmb[3]: %x\n",
         ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3]);
#line 3214
  data_size = 4;
#line 3215
  goto ldv_44252;
  case 32773U: 
#line 3218
  ql_log(2U, vha, 20613, "Asynchronous over temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 3222
  goto ldv_44252;
  case 32774U: 
#line 3225
  ql_log(2U, vha, 20614, "Asynchronous normal temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 3229
  goto ldv_44252;
  case 32775U: 
#line 3232
  ql_log(2U, vha, 20611, "Asynchronous critical temperature event received aenmb[0]: %x\n",
         ha->aenmb[0]);
#line 3236
  goto ldv_44252;
  default: 
#line 3239
  tmp___2 = readw((void const volatile   *)(& reg->aenmailbox1));
#line 3239
  ha->aenmb[1] = (uint32_t )tmp___2;
#line 3240
  tmp___3 = readw((void const volatile   *)(& reg->aenmailbox2));
#line 3240
  ha->aenmb[2] = (uint32_t )tmp___3;
#line 3241
  tmp___4 = readw((void const volatile   *)(& reg->aenmailbox3));
#line 3241
  ha->aenmb[3] = (uint32_t )tmp___4;
#line 3242
  tmp___5 = readw((void const volatile   *)(& reg->aenmailbox4));
#line 3242
  ha->aenmb[4] = (uint32_t )tmp___5;
#line 3243
  tmp___6 = readw((void const volatile   *)(& reg->aenmailbox5));
#line 3243
  ha->aenmb[5] = (uint32_t )tmp___6;
#line 3244
  tmp___7 = readw((void const volatile   *)(& reg->aenmailbox6));
#line 3244
  ha->aenmb[6] = (uint32_t )tmp___7;
#line 3245
  tmp___8 = readw((void const volatile   *)(& reg->aenmailbox7));
#line 3245
  ha->aenmb[7] = (uint32_t )tmp___8;
#line 3246
  ql_dbg(33554432U, vha, 20600, "AEN:%04x %04x %04x %04x :%04x %04x %04x %04x\n",
         ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3], ha->aenmb[4], ha->aenmb[5],
         ha->aenmb[6], ha->aenmb[7]);
#line 3250
  goto ldv_44252;
  }
  ldv_44252: 
#line 3252
  qlafx00_post_aenfx_work(vha, ha->aenmb[0], (uint32_t *)(& ha->aenmb), data_size);
#line 3254
  return;
}
}
#line 3263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
static void qlafx00_mbx_completion(scsi_qla_host_t *vha , uint32_t mb0 ) 
{ 
  uint16_t cnt ;
  uint16_t *wptr ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  unsigned short tmp ;

  {
#line 3267
  ha = vha->hw;
#line 3268
  reg = & (ha->iobase)->ispfx00;
#line 3270
  if ((unsigned long )ha->mcp32 == (unsigned long )((struct mbx_cmd_32 *)0)) {
#line 3271
    ql_dbg(33554432U, vha, 20606, "MBX pointer OLD_ERROR.\n");
  } else {

  }
#line 3274
  ha->flags.mbox_int = 1U;
#line 3275
  ha->mailbox_out32[0] = mb0;
#line 3276
  wptr = (uint16_t *)(& reg->mailbox17);
#line 3278
  cnt = 1U;
#line 3278
  goto ldv_44268;
  ldv_44267: 
#line 3279
  tmp = readw((void const volatile   *)wptr);
#line 3279
  ha->mailbox_out32[(int )cnt] = (uint32_t )tmp;
#line 3280
  wptr = wptr + 1;
#line 3278
  cnt = (uint16_t )((int )cnt + 1);
  ldv_44268: ;
#line 3278
  if ((int )((unsigned short )ha->mbx_count) > (int )cnt) {
#line 3280
    goto ldv_44267;
  } else {

  }

#line 3285
  return;
}
}
#line 3294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
irqreturn_t qlafx00_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct device_reg_fx00 *reg ;
  int status ;
  unsigned long iter ;
  uint32_t stat ;
  uint32_t mb[8U] ;
  struct rsp_que *rsp ;
  unsigned long flags ;
  uint32_t clr_intr ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  void *tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 3305
  clr_intr = 0U;
#line 3307
  rsp = (struct rsp_que *)dev_id;
#line 3308
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3309
    ql_log(2U, (scsi_qla_host_t *)0, 20605, "%s: NULL response queue pointer.\n",
           "qlafx00_intr_handler");
#line 3311
    return (0);
  } else {

  }
#line 3314
  ha = rsp->hw;
#line 3315
  reg = & (ha->iobase)->ispfx00;
#line 3316
  status = 0;
#line 3318
  tmp = pci_channel_offline(ha->pdev);
#line 3318
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 3318
  if (tmp___0 != 0L) {
#line 3319
    return (1);
  } else {

  }
#line 3321
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3321
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 3322
  tmp___2 = pci_get_drvdata(ha->pdev);
#line 3322
  vha = (scsi_qla_host_t *)tmp___2;
#line 3323
  iter = 50UL;
#line 3323
  goto ldv_44299;
  ldv_44298: 
#line 3324
  stat = readl((void const volatile   *)ha->cregbase + 138096U);
#line 3325
  if ((stat & 7U) == 0U) {
#line 3326
    goto ldv_44288;
  } else {

  }
#line 3328
  switch (stat & 7U) {
  case 1U: ;
  case 3U: ;
  case 5U: ;
  case 7U: 
#line 3333
  tmp___3 = readw((void const volatile   *)(& reg->mailbox16));
#line 3333
  mb[0] = (uint32_t )tmp___3;
#line 3334
  qlafx00_mbx_completion(vha, mb[0]);
#line 3335
  status = status | 1;
#line 3336
  clr_intr = clr_intr | 1U;
#line 3337
  goto ldv_44293;
  case 4U: ;
  case 6U: 
#line 3340
  tmp___4 = readw((void const volatile   *)(& reg->aenmailbox0));
#line 3340
  ha->aenmb[0] = (uint32_t )tmp___4;
#line 3341
  qlafx00_async_event(vha);
#line 3342
  clr_intr = clr_intr | 4U;
#line 3343
  goto ldv_44293;
  case 2U: 
#line 3345
  qlafx00_process_response_queue(vha, rsp);
#line 3346
  clr_intr = clr_intr | 2U;
#line 3347
  goto ldv_44293;
  default: 
#line 3349
  ql_dbg(33554432U, vha, 20602, "Unrecognized interrupt type (%d).\n", stat);
#line 3351
  goto ldv_44293;
  }
  ldv_44293: 
#line 3353
  writel(~ clr_intr, (void volatile   *)ha->cregbase + 138096U);
#line 3354
  readl((void const volatile   *)ha->cregbase + 138096U);
#line 3323
  clr_intr = 0U;
  ldv_44299: 
#line 3323
  tmp___5 = iter;
#line 3323
  iter = iter - 1UL;
#line 3323
  if (tmp___5 != 0UL) {
#line 3325
    goto ldv_44298;
  } else {

  }
  ldv_44288: 
#line 3357
  qla2x00_handle_mbx_completion(ha, status);
#line 3358
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3360
  return (1);
}
}
#line 3366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
__inline static cont_a64_entry_t *qlafx00_prep_cont_type1_iocb(struct req_que *req ,
                                                               cont_a64_entry_t *lcont_pkt ) 
{ 
  cont_a64_entry_t *cont_pkt ;

  {
#line 3372
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 3373
  if ((int )req->ring_index == (int )req->length) {
#line 3374
    req->ring_index = 0U;
#line 3375
    req->ring_ptr = req->ring;
  } else {
#line 3377
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 3380
  cont_pkt = (cont_a64_entry_t *)req->ring_ptr;
#line 3383
  lcont_pkt->entry_type = 3U;
#line 3385
  return (cont_pkt);
}
}
#line 3389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
__inline static void qlafx00_build_scsi_iocbs(srb_t *sp , struct cmd_type_7_fx00 *cmd_pkt ,
                                              uint16_t tot_dsds , struct cmd_type_7_fx00 *lcmd_pkt ) 
{ 
  uint16_t avail_dsds ;
  __le32 *cur_dsd ;
  scsi_qla_host_t *vha ;
  struct scsi_cmnd *cmd ;
  struct scatterlist *sg ;
  int i ;
  int cont ;
  struct req_que *req ;
  cont_a64_entry_t lcont_pkt ;
  cont_a64_entry_t *cont_pkt ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  dma_addr_t sle_dma ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;

  {
#line 3402
  vha = (sp->fcport)->vha;
#line 3403
  req = vha->req;
#line 3405
  cmd = sp->u.scmd.cmd;
#line 3406
  cont = 0;
#line 3407
  cont_pkt = (cont_a64_entry_t *)0;
#line 3410
  lcmd_pkt->entry_type = 7U;
#line 3413
  tmp = scsi_bufflen(cmd);
#line 3413
  if (tmp == 0U || (unsigned int )cmd->sc_data_direction == 3U) {
#line 3414
    lcmd_pkt->byte_count = 0U;
#line 3415
    return;
  } else {

  }
#line 3419
  if ((unsigned int )cmd->sc_data_direction == 1U) {
#line 3420
    lcmd_pkt->cntrl_flags = 1U;
#line 3421
    tmp___0 = scsi_bufflen(cmd);
#line 3421
    vha->qla_stats.output_bytes = vha->qla_stats.output_bytes + (uint64_t )tmp___0;
  } else
#line 3422
  if ((unsigned int )cmd->sc_data_direction == 2U) {
#line 3423
    lcmd_pkt->cntrl_flags = 2U;
#line 3424
    tmp___1 = scsi_bufflen(cmd);
#line 3424
    vha->qla_stats.input_bytes = vha->qla_stats.input_bytes + (uint64_t )tmp___1;
  } else {

  }
#line 3428
  avail_dsds = 1U;
#line 3429
  cur_dsd = (__le32 *)(& lcmd_pkt->dseg_0_address);
#line 3432
  i = 0;
#line 3432
  sg = scsi_sglist(cmd);
#line 3432
  goto ldv_44323;
  ldv_44322: ;
#line 3436
  if ((unsigned int )avail_dsds == 0U) {
#line 3441
    memset((void *)(& lcont_pkt), 0, 64UL);
#line 3442
    cont_pkt = qlafx00_prep_cont_type1_iocb(req, & lcont_pkt);
#line 3444
    cur_dsd = (__le32 *)(& lcont_pkt.dseg_0_address);
#line 3445
    avail_dsds = 5U;
#line 3446
    cont = 1;
  } else {

  }
#line 3449
  sle_dma = sg->dma_address;
#line 3450
  tmp___2 = cur_dsd;
#line 3450
  cur_dsd = cur_dsd + 1;
#line 3450
  *tmp___2 = (unsigned int )sle_dma;
#line 3451
  tmp___3 = cur_dsd;
#line 3451
  cur_dsd = cur_dsd + 1;
#line 3451
  *tmp___3 = (unsigned int )(sle_dma >> 32ULL);
#line 3452
  tmp___4 = cur_dsd;
#line 3452
  cur_dsd = cur_dsd + 1;
#line 3452
  *tmp___4 = sg->dma_length;
#line 3453
  avail_dsds = (uint16_t )((int )avail_dsds - 1);
#line 3454
  if ((unsigned int )avail_dsds == 0U && cont == 1) {
#line 3455
    cont = 0;
#line 3456
    memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
  } else {

  }
#line 3432
  i = i + 1;
#line 3432
  sg = sg_next(sg);
  ldv_44323: ;
#line 3432
  if ((int )tot_dsds > i) {
#line 3434
    goto ldv_44322;
  } else {

  }

#line 3461
  if ((unsigned int )avail_dsds != 0U && cont == 1) {
#line 3462
    memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
  } else {

  }
#line 3463
  return;
}
}
#line 3474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int qlafx00_start_scsi(srb_t *sp ) 
{ 
  int ret ;
  int nseg ;
  unsigned long flags ;
  uint32_t index ;
  uint32_t handle ;
  uint16_t cnt ;
  uint16_t req_cnt ;
  uint16_t tot_dsds ;
  struct req_que *req ;
  struct rsp_que *rsp ;
  struct scsi_cmnd *cmd ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct cmd_type_7_fx00 *cmd_pkt ;
  struct cmd_type_7_fx00 lcmd_pkt ;
  struct scsi_lun llun ;
  char tag[2U] ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 3483
  req = (struct req_que *)0;
#line 3484
  rsp = (struct rsp_que *)0;
#line 3485
  cmd = sp->u.scmd.cmd;
#line 3486
  vha = (sp->fcport)->vha;
#line 3487
  ha = vha->hw;
#line 3494
  ret = 0;
#line 3496
  rsp = *(ha->rsp_q_map);
#line 3497
  req = vha->req;
#line 3500
  tot_dsds = 0U;
#line 3503
  vha->marker_needed = 0U;
#line 3506
  if ((unsigned int )vha->marker_needed != 0U) {
#line 3507
    tmp = qla2x00_marker(vha, req, rsp, 0, 0, 2);
#line 3507
    if (tmp != 0) {
#line 3509
      return (258);
    } else {

    }
#line 3510
    vha->marker_needed = 0U;
  } else {

  }
#line 3514
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 3514
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3517
  handle = req->current_outstanding_cmd;
#line 3518
  index = 1U;
#line 3518
  goto ldv_44350;
  ldv_44349: 
#line 3519
  handle = handle + 1U;
#line 3520
  if ((uint32_t )req->num_outstanding_cmds == handle) {
#line 3521
    handle = 1U;
  } else {

  }
#line 3522
  if ((unsigned long )*(req->outstanding_cmds + (unsigned long )handle) == (unsigned long )((srb_t *)0)) {
#line 3523
    goto ldv_44348;
  } else {

  }
#line 3518
  index = index + 1U;
  ldv_44350: ;
#line 3518
  if ((uint32_t )req->num_outstanding_cmds > index) {
#line 3520
    goto ldv_44349;
  } else {

  }
  ldv_44348: ;
#line 3525
  if ((uint32_t )req->num_outstanding_cmds == index) {
#line 3526
    goto queuing_error;
  } else {

  }
#line 3529
  tmp___4 = scsi_sg_count(cmd);
#line 3529
  if (tmp___4 != 0U) {
#line 3530
    tmp___1 = scsi_sg_count(cmd);
#line 3530
    tmp___2 = scsi_sglist(cmd);
#line 3530
    nseg = dma_map_sg_attrs(& (ha->pdev)->dev, tmp___2, (int )tmp___1, cmd->sc_data_direction,
                            (struct dma_attrs *)0);
#line 3532
    tmp___3 = ldv__builtin_expect(nseg == 0, 0L);
#line 3532
    if (tmp___3 != 0L) {
#line 3533
      goto queuing_error;
    } else {

    }
  } else {
#line 3535
    nseg = 0;
  }
#line 3537
  tot_dsds = (uint16_t )nseg;
#line 3538
  req_cnt = qla24xx_calc_iocbs(vha, (int )tot_dsds);
#line 3539
  if ((int )req->cnt < (int )req_cnt + 2) {
#line 3540
    tmp___5 = __readl((void const volatile   *)req->req_q_out);
#line 3540
    cnt = (uint16_t )tmp___5;
#line 3542
    if ((int )req->ring_index < (int )cnt) {
#line 3543
      req->cnt = (int )cnt - (int )req->ring_index;
    } else {
#line 3545
      req->cnt = (int )req->length + ((int )cnt - (int )req->ring_index);
    }
#line 3547
    if ((int )req->cnt < (int )req_cnt + 2) {
#line 3548
      goto queuing_error;
    } else {

    }
  } else {

  }
#line 3552
  req->current_outstanding_cmd = handle;
#line 3553
  *(req->outstanding_cmds + (unsigned long )handle) = sp;
#line 3554
  sp->handle = handle;
#line 3555
  cmd->host_scribble = (unsigned char *)((unsigned long )handle);
#line 3556
  req->cnt = (int )req->cnt - (int )req_cnt;
#line 3558
  cmd_pkt = (struct cmd_type_7_fx00 *)req->ring_ptr;
#line 3560
  memset((void *)(& lcmd_pkt), 0, 64UL);
#line 3562
  lcmd_pkt.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3563
  lcmd_pkt.handle_hi = 0U;
#line 3564
  lcmd_pkt.dseg_count = tot_dsds;
#line 3565
  lcmd_pkt.tgt_idx = (sp->fcport)->tgt_id;
#line 3567
  int_to_scsilun((cmd->device)->lun, & llun);
#line 3568
  host_to_adap((uint8_t *)(& llun), (uint8_t *)(& lcmd_pkt.lun), 8U);
#line 3572
  tmp___6 = scsi_populate_tag_msg(cmd, (char *)(& tag));
#line 3572
  if (tmp___6 != 0) {
#line 3573
    switch ((int )tag[0]) {
    case 33: 
#line 3575
    lcmd_pkt.task = 1U;
#line 3576
    goto ldv_44353;
    case 34: 
#line 3578
    lcmd_pkt.task = 2U;
#line 3579
    goto ldv_44353;
    }
    ldv_44353: ;
  } else {

  }
#line 3584
  host_to_adap(cmd->cmnd, (uint8_t *)(& lcmd_pkt.fcp_cdb), 16U);
#line 3585
  lcmd_pkt.byte_count = scsi_bufflen(cmd);
#line 3588
  qlafx00_build_scsi_iocbs(sp, cmd_pkt, (int )tot_dsds, & lcmd_pkt);
#line 3591
  lcmd_pkt.entry_count = (unsigned char )req_cnt;
#line 3594
  lcmd_pkt.entry_status = (unsigned char )rsp->id;
#line 3596
  ql_dump_buffer(134348800U, vha, 12334, cmd->cmnd, (uint32_t )cmd->cmd_len);
#line 3598
  ql_dump_buffer(134348800U, vha, 12338, (uint8_t *)(& lcmd_pkt), 64U);
#line 3601
  memcpy_toio((void volatile   *)cmd_pkt, (void const   *)(& lcmd_pkt), 64UL);
#line 3602
  __asm__  volatile   ("sfence": : : "memory");
#line 3605
  req->ring_index = (uint16_t )((int )req->ring_index + 1);
#line 3606
  if ((int )req->ring_index == (int )req->length) {
#line 3607
    req->ring_index = 0U;
#line 3608
    req->ring_ptr = req->ring;
  } else {
#line 3610
    req->ring_ptr = req->ring_ptr + 1;
  }
#line 3612
  sp->flags = (uint16_t )((unsigned int )sp->flags | 1U);
#line 3615
  writel((unsigned int )req->ring_index, (void volatile   *)req->req_q_in);
#line 3616
  writel(ha->rqstq_intr_code, (void volatile   *)ha->cregbase + 133636U);
#line 3618
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3619
  return (0);
  queuing_error: ;
#line 3622
  if ((unsigned int )tot_dsds != 0U) {
#line 3623
    scsi_dma_unmap(cmd);
  } else {

  }
#line 3625
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3627
  return (258);
}
}
#line 3631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_tm_iocb(srb_t *sp , struct tsk_mgmt_entry_fx00 *ptm_iocb ) 
{ 
  struct srb_iocb *fxio ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct tsk_mgmt_entry_fx00 tm_iocb ;
  struct scsi_lun llun ;
  unsigned long tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 3633
  fxio = & sp->u.iocb_cmd;
#line 3634
  vha = (sp->fcport)->vha;
#line 3635
  req = vha->req;
#line 3639
  memset((void *)(& tm_iocb), 0, 64UL);
#line 3640
  tm_iocb.entry_type = 5U;
#line 3641
  tm_iocb.entry_count = 1U;
#line 3642
  tm_iocb.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3643
  tm_iocb.handle_hi = 0U;
#line 3644
  tmp = qla2x00_get_async_timeout(vha);
#line 3644
  tm_iocb.timeout = (unsigned int )((unsigned short )tmp) + 2U;
#line 3645
  tm_iocb.tgt_id = (sp->fcport)->tgt_id;
#line 3646
  tm_iocb.control_flags = fxio->u.tmf.flags;
#line 3647
  if (tm_iocb.control_flags == 16U) {
#line 3648
    int_to_scsilun(fxio->u.tmf.lun, & llun);
#line 3649
    host_to_adap((uint8_t *)(& llun), (uint8_t *)(& tm_iocb.lun), 8U);
  } else {

  }
#line 3653
  __len = 64UL;
#line 3653
  if (__len > 63UL) {
#line 3653
    __ret = __memcpy((void *)ptm_iocb, (void const   *)(& tm_iocb), __len);
  } else {
#line 3653
    __ret = __builtin_memcpy((void *)ptm_iocb, (void const   *)(& tm_iocb), __len);
  }
#line 3655
  __asm__  volatile   ("sfence": : : "memory");
#line 3656
  return;
}
}
#line 3659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_abort_iocb(srb_t *sp , struct abort_iocb_entry_fx00 *pabt_iocb ) 
{ 
  struct srb_iocb *fxio ;
  scsi_qla_host_t *vha ;
  struct req_que *req ;
  struct abort_iocb_entry_fx00 abt_iocb ;
  size_t __len ;
  void *__ret ;

  {
#line 3661
  fxio = & sp->u.iocb_cmd;
#line 3662
  vha = (sp->fcport)->vha;
#line 3663
  req = vha->req;
#line 3666
  memset((void *)(& abt_iocb), 0, 64UL);
#line 3667
  abt_iocb.entry_type = 8U;
#line 3668
  abt_iocb.entry_count = 1U;
#line 3669
  abt_iocb.handle = ((unsigned int )req->id << 16) | sp->handle;
#line 3670
  abt_iocb.abort_handle = ((unsigned int )req->id << 16) | fxio->u.abt.cmd_hndl;
#line 3672
  abt_iocb.tgt_id_sts = (sp->fcport)->tgt_id;
#line 3673
  abt_iocb.req_que_no = req->id;
#line 3675
  __len = 64UL;
#line 3675
  if (__len > 63UL) {
#line 3675
    __ret = __memcpy((void *)pabt_iocb, (void const   *)(& abt_iocb), __len);
  } else {
#line 3675
    __ret = __builtin_memcpy((void *)pabt_iocb, (void const   *)(& abt_iocb), __len);
  }
#line 3677
  __asm__  volatile   ("sfence": : : "memory");
#line 3678
  return;
}
}
#line 3681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void qlafx00_fxdisc_iocb(srb_t *sp , struct fxdisc_entry_fx00 *pfxiocb ) 
{ 
  struct srb_iocb *fxio ;
  struct qla_mt_iocb_rqst_fx00 *piocb_rqst ;
  struct fc_bsg_job *bsg_job ;
  struct fxdisc_entry_fx00 fx_iocb ;
  uint8_t entry_cnt ;
  struct scatterlist *sg ;
  int avail_dsds ;
  int tot_dsds ;
  cont_a64_entry_t lcont_pkt ;
  cont_a64_entry_t *cont_pkt ;
  __le32 *cur_dsd ;
  int index ;
  int cont ;
  dma_addr_t sle_dma ;
  __le32 *tmp ;
  __le32 *tmp___0 ;
  __le32 *tmp___1 ;
  int avail_dsds___0 ;
  int tot_dsds___0 ;
  cont_a64_entry_t lcont_pkt___0 ;
  cont_a64_entry_t *cont_pkt___0 ;
  __le32 *cur_dsd___0 ;
  int index___0 ;
  int cont___0 ;
  dma_addr_t sle_dma___0 ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 3683
  fxio = & sp->u.iocb_cmd;
#line 3687
  entry_cnt = 1U;
#line 3689
  memset((void *)(& fx_iocb), 0, 64UL);
#line 3690
  fx_iocb.entry_type = 11U;
#line 3691
  fx_iocb.handle = sp->handle;
#line 3692
  fx_iocb.entry_count = entry_cnt;
#line 3694
  if ((unsigned int )sp->type == 10U) {
#line 3695
    fx_iocb.func_num = sp->u.iocb_cmd.u.fxiocb.req_func_type;
#line 3697
    fx_iocb.adapid = fxio->u.fxiocb.adapter_id;
#line 3698
    fx_iocb.adapid_hi = fxio->u.fxiocb.adapter_id_hi;
#line 3699
    fx_iocb.reserved_0 = fxio->u.fxiocb.reserved_0;
#line 3700
    fx_iocb.reserved_1 = fxio->u.fxiocb.reserved_1;
#line 3701
    fx_iocb.dataword_extra = fxio->u.fxiocb.req_data_extra;
#line 3703
    if ((int )fxio->u.fxiocb.flags & 1) {
#line 3704
      fx_iocb.req_dsdcnt = 1U;
#line 3705
      fx_iocb.req_xfrcnt = (unsigned short )fxio->u.fxiocb.req_len;
#line 3707
      fx_iocb.dseg_rq_address[0] = (unsigned int )fxio->u.fxiocb.req_dma_handle;
#line 3709
      fx_iocb.dseg_rq_address[1] = (unsigned int )(fxio->u.fxiocb.req_dma_handle >> 32ULL);
#line 3711
      fx_iocb.dseg_rq_len = fxio->u.fxiocb.req_len;
    } else {

    }
#line 3715
    if (((int )fxio->u.fxiocb.flags & 2) != 0) {
#line 3716
      fx_iocb.rsp_dsdcnt = 1U;
#line 3717
      fx_iocb.rsp_xfrcnt = (unsigned short )fxio->u.fxiocb.rsp_len;
#line 3719
      fx_iocb.dseg_rsp_address[0] = (unsigned int )fxio->u.fxiocb.rsp_dma_handle;
#line 3721
      fx_iocb.dseg_rsp_address[1] = (unsigned int )(fxio->u.fxiocb.rsp_dma_handle >> 32ULL);
#line 3723
      fx_iocb.dseg_rsp_len = fxio->u.fxiocb.rsp_len;
    } else {

    }
#line 3727
    if (((int )fxio->u.fxiocb.flags & 4) != 0) {
#line 3728
      fx_iocb.dataword = fxio->u.fxiocb.req_data;
    } else {

    }
#line 3730
    fx_iocb.flags = fxio->u.fxiocb.flags;
  } else {
#line 3733
    bsg_job = sp->u.bsg_job;
#line 3734
    piocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)(& (bsg_job->request)->rqst_data.h_vendor.vendor_cmd) + 1U;
#line 3737
    fx_iocb.func_num = piocb_rqst->func_type;
#line 3738
    fx_iocb.adapid = piocb_rqst->adapid;
#line 3739
    fx_iocb.adapid_hi = piocb_rqst->adapid_hi;
#line 3740
    fx_iocb.reserved_0 = piocb_rqst->reserved_0;
#line 3741
    fx_iocb.reserved_1 = piocb_rqst->reserved_1;
#line 3742
    fx_iocb.dataword_extra = piocb_rqst->dataword_extra;
#line 3743
    fx_iocb.dataword = piocb_rqst->dataword;
#line 3744
    fx_iocb.req_xfrcnt = piocb_rqst->req_len;
#line 3745
    fx_iocb.rsp_xfrcnt = piocb_rqst->rsp_len;
#line 3747
    if ((int )piocb_rqst->flags & 1) {
#line 3750
      cont_pkt = (cont_a64_entry_t *)0;
#line 3752
      index = 0;
#line 3752
      cont = 0;
#line 3754
      fx_iocb.req_dsdcnt = (unsigned short )bsg_job->request_payload.sg_cnt;
#line 3756
      tot_dsds = bsg_job->request_payload.sg_cnt;
#line 3758
      cur_dsd = (__le32 *)(& fx_iocb.dseg_rq_address);
#line 3759
      avail_dsds = 1;
#line 3760
      index = 0;
#line 3760
      sg = bsg_job->request_payload.sg_list;
#line 3760
      goto ldv_44397;
      ldv_44396: ;
#line 3765
      if (avail_dsds == 0) {
#line 3770
        memset((void *)(& lcont_pkt), 0, 64UL);
#line 3772
        cont_pkt = qlafx00_prep_cont_type1_iocb(((sp->fcport)->vha)->req, & lcont_pkt);
#line 3776
        cur_dsd = (__le32 *)(& lcont_pkt.dseg_0_address);
#line 3778
        avail_dsds = 5;
#line 3779
        cont = 1;
#line 3780
        entry_cnt = (uint8_t )((int )entry_cnt + 1);
      } else {

      }
#line 3783
      sle_dma = sg->dma_address;
#line 3784
      tmp = cur_dsd;
#line 3784
      cur_dsd = cur_dsd + 1;
#line 3784
      *tmp = (unsigned int )sle_dma;
#line 3785
      tmp___0 = cur_dsd;
#line 3785
      cur_dsd = cur_dsd + 1;
#line 3785
      *tmp___0 = (unsigned int )(sle_dma >> 32ULL);
#line 3786
      tmp___1 = cur_dsd;
#line 3786
      cur_dsd = cur_dsd + 1;
#line 3786
      *tmp___1 = sg->dma_length;
#line 3787
      avail_dsds = avail_dsds - 1;
#line 3789
      if (avail_dsds == 0 && cont == 1) {
#line 3790
        cont = 0;
#line 3791
        memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
#line 3794
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12354, (uint8_t *)(& lcont_pkt),
                       64U);
      } else {

      }
#line 3760
      index = index + 1;
#line 3760
      sg = sg_next(sg);
      ldv_44397: ;
#line 3760
      if (index < tot_dsds) {
#line 3762
        goto ldv_44396;
      } else {

      }

#line 3801
      if (avail_dsds != 0 && cont == 1) {
#line 3802
        memcpy_toio((void volatile   *)cont_pkt, (void const   *)(& lcont_pkt), 64UL);
#line 3804
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12355, (uint8_t *)(& lcont_pkt),
                       64U);
      } else {

      }
    } else {

    }
#line 3810
    if (((int )piocb_rqst->flags & 2) != 0) {
#line 3813
      cont_pkt___0 = (cont_a64_entry_t *)0;
#line 3815
      index___0 = 0;
#line 3815
      cont___0 = 0;
#line 3817
      fx_iocb.rsp_dsdcnt = (unsigned short )bsg_job->reply_payload.sg_cnt;
#line 3819
      tot_dsds___0 = bsg_job->reply_payload.sg_cnt;
#line 3820
      cur_dsd___0 = (__le32 *)(& fx_iocb.dseg_rsp_address);
#line 3821
      avail_dsds___0 = 1;
#line 3823
      index___0 = 0;
#line 3823
      sg = bsg_job->reply_payload.sg_list;
#line 3823
      goto ldv_44408;
      ldv_44407: ;
#line 3828
      if (avail_dsds___0 == 0) {
#line 3833
        memset((void *)(& lcont_pkt___0), 0, 64UL);
#line 3835
        cont_pkt___0 = qlafx00_prep_cont_type1_iocb(((sp->fcport)->vha)->req, & lcont_pkt___0);
#line 3839
        cur_dsd___0 = (__le32 *)(& lcont_pkt___0.dseg_0_address);
#line 3841
        avail_dsds___0 = 5;
#line 3842
        cont___0 = 1;
#line 3843
        entry_cnt = (uint8_t )((int )entry_cnt + 1);
      } else {

      }
#line 3846
      sle_dma___0 = sg->dma_address;
#line 3847
      tmp___2 = cur_dsd___0;
#line 3847
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3847
      *tmp___2 = (unsigned int )sle_dma___0;
#line 3848
      tmp___3 = cur_dsd___0;
#line 3848
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3848
      *tmp___3 = (unsigned int )(sle_dma___0 >> 32ULL);
#line 3849
      tmp___4 = cur_dsd___0;
#line 3849
      cur_dsd___0 = cur_dsd___0 + 1;
#line 3849
      *tmp___4 = sg->dma_length;
#line 3850
      avail_dsds___0 = avail_dsds___0 - 1;
#line 3852
      if (avail_dsds___0 == 0 && cont___0 == 1) {
#line 3853
        cont___0 = 0;
#line 3854
        memcpy_toio((void volatile   *)cont_pkt___0, (void const   *)(& lcont_pkt___0),
                    64UL);
#line 3857
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12357, (uint8_t *)(& lcont_pkt___0),
                       64U);
      } else {

      }
#line 3823
      index___0 = index___0 + 1;
#line 3823
      sg = sg_next(sg);
      ldv_44408: ;
#line 3823
      if (index___0 < tot_dsds___0) {
#line 3825
        goto ldv_44407;
      } else {

      }

#line 3864
      if (avail_dsds___0 != 0 && cont___0 == 1) {
#line 3865
        memcpy_toio((void volatile   *)cont_pkt___0, (void const   *)(& lcont_pkt___0),
                    64UL);
#line 3867
        ql_dump_buffer(8421376U, (sp->fcport)->vha, 12358, (uint8_t *)(& lcont_pkt___0),
                       64U);
      } else {

      }
    } else {

    }
#line 3873
    if (((int )piocb_rqst->flags & 4) != 0) {
#line 3874
      fx_iocb.dataword = piocb_rqst->dataword;
    } else {

    }
#line 3875
    fx_iocb.flags = piocb_rqst->flags;
#line 3876
    fx_iocb.entry_count = entry_cnt;
  }
#line 3879
  ql_dump_buffer(8421376U, (sp->fcport)->vha, 12359, (uint8_t *)(& fx_iocb), 64U);
#line 3883
  __len = 64UL;
#line 3883
  if (__len > 63UL) {
#line 3883
    __ret = __memcpy((void *)pfxiocb, (void const   *)(& fx_iocb), __len);
  } else {
#line 3883
    __ret = __builtin_memcpy((void *)pfxiocb, (void const   *)(& fx_iocb), __len);
  }
#line 3885
  __asm__  volatile   ("sfence": : : "memory");
#line 3886
  return;
}
}
#line 3889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int reg_timer_15(struct timer_list *timer ) 
{ 


  {
#line 3890
  ldv_timer_list_15 = timer;
#line 3891
  ldv_timer_state_15 = 1;
#line 3892
  return (0);
}
}
#line 3895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3895
  if ((unsigned long )ldv_timer_list_15 == (unsigned long )timer) {
#line 3896
    if (ldv_timer_state_15 == 2 || pending_flag != 0) {
#line 3897
      ldv_timer_list_15 = timer;
#line 3898
      ldv_timer_list_15->data = data;
#line 3899
      ldv_timer_state_15 = 1;
    } else {

    }
#line 3901
    return;
  } else {

  }
#line 3903
  reg_timer_15(timer);
#line 3904
  ldv_timer_list_15->data = data;
#line 3905
  return;
}
}
#line 3908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void choose_timer_15(struct timer_list *timer ) 
{ 


  {
#line 3909
  LDV_IN_INTERRUPT = 2;
#line 3910
  (*(timer->function))(timer->data);
#line 3911
  LDV_IN_INTERRUPT = 1;
#line 3912
  ldv_timer_state_15 = 2;
#line 3913
  return;
}
}
#line 3916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
void disable_suitable_timer_15(struct timer_list *timer ) 
{ 


  {
#line 3917
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_15) {
#line 3918
    ldv_timer_state_15 = 0;
#line 3919
    return;
  } else {

  }
#line 3921
  return;
}
}
#line 3923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int ldv_del_timer_73(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 3927
  tmp = del_timer(ldv_func_arg1);
#line 3927
  ldv_func_res = tmp;
#line 3929
  disable_suitable_timer_7(ldv_func_arg1);
#line 3931
  return (ldv_func_res);
}
}
#line 3934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_mr.o.c.prepared"
int ldv_scsi_add_host_with_dma_74(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 3938
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 3938
  ldv_func_res = tmp;
#line 3940
  if (ldv_func_res == 0) {
#line 3941
    ldv_state_variable_72 = 1;
#line 3941
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 3945
  return (ldv_func_res);
}
}
#line 178 "include/linux/timer.h"
int ldv_del_timer_77(struct timer_list *ldv_func_arg1 ) ;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void disable_suitable_timer_16(struct timer_list *timer ) ;
#line 261
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 268
int reg_timer_16(struct timer_list *timer ) ;
#line 272
void choose_timer_16(struct timer_list *timer ) ;
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_78(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 1182 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx.h"
static int const   MD_MIU_TEST_AGT_RDDATA___0[4U]  = {      1090519208,      1090519212,      1090519224,      1090519228};
#line 491 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
static uint32_t const   qla8044_reg_tbl[14U]  = 
#line 491 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_nx2.h"
  {      13480U,      13484U,      13488U,      14216U, 
        14212U,      14220U,      13640U,      14304U, 
        14208U,      13648U,      13652U,      13656U, 
        13904U,      14260U};
#line 484 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_gbl.h"
uint8_t *qla8044_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) ;
#line 724
__inline void qla8044_set_qsnt_ready(struct scsi_qla_host *vha ) ;
#line 725
static void qla8044_need_reset_handler(struct scsi_qla_host *vha ) ;
#line 729
void qla8044_get_minidump(struct scsi_qla_host *vha ) ;
#line 730
int qla8044_collect_md_data(struct scsi_qla_host *vha ) ;
#line 8 "include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
uint32_t qla8044_rd_reg(struct qla_hw_data *ha , ulong addr ) 
{ 
  unsigned int tmp ;

  {
#line 318
  tmp = readl((void const volatile   *)(ha->nx_pcibase + addr));
#line 318
  return (tmp);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_wr_reg(struct qla_hw_data *ha , ulong addr , uint32_t val ) 
{ 


  {
#line 324
  writel(val, (void volatile   *)(ha->nx_pcibase + addr));
#line 325
  return;
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_rd_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 331
  ha = vha->hw;
#line 333
  if ((unsigned int )crb_reg <= 13U) {
#line 334
    tmp = qla8044_rd_reg(ha, (ulong )qla8044_reg_tbl[crb_reg]);
#line 334
    return ((int )tmp);
  } else {
#line 336
    return (258);
  }
}
}
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_wr_direct(struct scsi_qla_host *vha , uint32_t const   crb_reg , uint32_t const   value ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 344
  ha = vha->hw;
#line 346
  if ((unsigned int )crb_reg <= 13U) {
#line 347
    qla8044_wr_reg(ha, (ulong )qla8044_reg_tbl[crb_reg], value);
  } else {

  }
#line 348
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_set_win_base(scsi_qla_host_t *vha , uint32_t addr ) 
{ 
  uint32_t val ;
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 354
  ret_val = 0;
#line 355
  ha = vha->hw;
#line 357
  qla8044_wr_reg(ha, (ulong )(((int )ha->portnum + 3584) * 4), addr);
#line 358
  val = qla8044_rd_reg(ha, (ulong )(((int )ha->portnum + 3584) * 4));
#line 360
  if (val != addr) {
#line 361
    ql_log(1U, vha, 45191, "%s: Failed to set register window : addr written 0x%x, read 0x%x!\n",
           "qla8044_set_win_base", addr, val);
#line 365
    ret_val = 258;
  } else {

  }
#line 367
  return (ret_val);
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_rd_reg_indirect(scsi_qla_host_t *vha , uint32_t addr , uint32_t *data ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 373
  ret_val = 0;
#line 374
  ha = vha->hw;
#line 376
  ret_val = qla8044_set_win_base(vha, addr);
#line 377
  if (ret_val == 0) {
#line 378
    *data = qla8044_rd_reg(ha, 14576UL);
  } else {
#line 380
    ql_log(1U, vha, 45192, "%s: failed read of addr 0x%x!\n", "qla8044_rd_reg_indirect",
           addr);
  }
#line 382
  return (ret_val);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_wr_reg_indirect(scsi_qla_host_t *vha , uint32_t addr , uint32_t data ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 388
  ret_val = 0;
#line 389
  ha = vha->hw;
#line 391
  ret_val = qla8044_set_win_base(vha, addr);
#line 392
  if (ret_val == 0) {
#line 393
    qla8044_wr_reg(ha, 14576UL, data);
  } else {
#line 395
    ql_log(1U, vha, 45193, "%s: failed wrt to addr 0x%x, data 0x%x\n", "qla8044_wr_reg_indirect",
           addr, data);
  }
#line 398
  return (ret_val);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_read_write_crb_reg(struct scsi_qla_host *vha , uint32_t raddr ,
                                       uint32_t waddr ) 
{ 
  uint32_t value ;

  {
#line 415
  qla8044_rd_reg_indirect(vha, raddr, & value);
#line 416
  qla8044_wr_reg_indirect(vha, waddr, value);
#line 417
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_rmw_crb_reg(struct scsi_qla_host *vha , uint32_t raddr , uint32_t waddr ,
                                struct qla8044_rmw *p_rmw_hdr ) 
{ 
  uint32_t value ;

  {
#line 435
  if ((unsigned int )p_rmw_hdr->index_a != 0U) {
#line 436
    value = vha->reset_tmplt.array[(int )p_rmw_hdr->index_a];
  } else {
#line 438
    qla8044_rd_reg_indirect(vha, raddr, & value);
  }
#line 439
  value = p_rmw_hdr->test_mask & value;
#line 440
  value = value << (int )p_rmw_hdr->shl;
#line 441
  value = value >> (int )p_rmw_hdr->shr;
#line 442
  value = p_rmw_hdr->or_value | value;
#line 443
  value = p_rmw_hdr->xor_value ^ value;
#line 444
  qla8044_wr_reg_indirect(vha, waddr, value);
#line 445
  return;
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
__inline void qla8044_set_qsnt_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t qsnt_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 452
  ha = vha->hw;
#line 454
  tmp = qla8044_rd_direct(vha, 5U);
#line 454
  qsnt_state = (uint32_t )tmp;
#line 455
  qsnt_state = (uint32_t )(1 << (int )ha->portnum) | qsnt_state;
#line 456
  qla8044_wr_direct(vha, 5U, qsnt_state);
#line 457
  ql_log(2U, vha, 45198, "%s(%ld): qsnt_state: 0x%08x\n", "qla8044_set_qsnt_ready",
         vha->host_no, qsnt_state);
#line 459
  return;
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_clear_qsnt_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t qsnt_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 465
  ha = vha->hw;
#line 467
  tmp = qla8044_rd_direct(vha, 5U);
#line 467
  qsnt_state = (uint32_t )tmp;
#line 468
  qsnt_state = (uint32_t )(~ (1 << (int )ha->portnum)) & qsnt_state;
#line 469
  qla8044_wr_direct(vha, 5U, qsnt_state);
#line 470
  ql_log(2U, vha, 45199, "%s(%ld): qsnt_state: 0x%08x\n", "qla8044_clear_qsnt_ready",
         vha->host_no, qsnt_state);
#line 472
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_lock_recovery(struct scsi_qla_host *vha ) 
{ 
  uint32_t lock ;
  uint32_t lockid ;
  struct qla_hw_data *ha ;

  {
#line 503
  lock = 0U;
#line 504
  ha = vha->hw;
#line 506
  lockid = qla8044_rd_reg(ha, 14236UL);
#line 509
  if ((lockid & 3U) != 0U) {
#line 510
    return (258);
  } else {

  }
#line 513
  qla8044_wr_reg(ha, 14236UL, (uint32_t )(((int )ha->portnum << 2) | 1));
#line 516
  msleep(200U);
#line 519
  lockid = qla8044_rd_reg(ha, 14236UL);
#line 520
  if ((lockid & 60U) != (uint32_t )((int )ha->portnum << 2)) {
#line 522
    return (258);
  } else {

  }
#line 524
  ql_dbg(524288U, vha, 45195, "%s:%d: IDC Lock recovery initiated\n", "qla8044_lock_recovery",
         (int )ha->portnum);
#line 528
  qla8044_wr_reg(ha, 14236UL, (uint32_t )(((int )ha->portnum << 2) | 2));
#line 533
  qla8044_wr_reg(ha, 13572UL, 255U);
#line 534
  qla8044_rd_reg(ha, 14444UL);
#line 537
  qla8044_wr_reg(ha, 14236UL, 0U);
#line 540
  lock = qla8044_rd_reg(ha, 14440UL);
#line 541
  if (lock != 0U) {
#line 542
    lockid = qla8044_rd_reg(ha, 13572UL);
#line 543
    lockid = ((lockid + 256U) & 4294967040U) | (uint32_t )ha->portnum;
#line 544
    qla8044_wr_reg(ha, 13572UL, lockid);
#line 545
    return (0);
  } else {
#line 547
    return (258);
  }
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_idc_lock(struct qla_hw_data *ha ) 
{ 
  uint32_t ret_val ;
  uint32_t timeout ;
  uint32_t status ;
  uint32_t lock_id ;
  uint32_t lock_cnt ;
  uint32_t func_num ;
  uint32_t tmo_owner ;
  uint32_t first_owner ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  int tmp___0 ;

  {
#line 553
  ret_val = 0U;
#line 553
  timeout = 0U;
#line 553
  status = 0U;
#line 554
  tmo_owner = 0U;
#line 554
  first_owner = 0U;
#line 555
  tmp = pci_get_drvdata(ha->pdev);
#line 555
  vha = (scsi_qla_host_t *)tmp;
#line 557
  goto ldv_43544;
  ldv_43543: 
#line 559
  status = qla8044_rd_reg(ha, 14440UL);
#line 561
  if (status != 0U) {
#line 564
    lock_id = qla8044_rd_reg(ha, 13572UL);
#line 565
    lock_id = ((lock_id + 256U) & 4294967040U) | (uint32_t )ha->portnum;
#line 566
    qla8044_wr_reg(ha, 13572UL, lock_id);
#line 567
    goto ldv_43541;
  } else {

  }
#line 570
  if (timeout == 0U) {
#line 571
    first_owner = qla8044_rd_reg(ha, 13572UL);
  } else {

  }
#line 573
  timeout = timeout + 1U;
#line 573
  if (timeout > 9U) {
#line 575
    tmo_owner = qla8044_rd_reg(ha, 13572UL);
#line 576
    func_num = tmo_owner & 255U;
#line 577
    lock_cnt = tmo_owner >> 8;
#line 578
    ql_log(1U, vha, 45332, "%s: Lock by func %d failed after 2s, lock held by func %d, lock count %d, first_owner %d\n",
           "qla8044_idc_lock", (int )ha->portnum, func_num, lock_cnt, first_owner & 255U);
#line 583
    if (first_owner != tmo_owner) {
#line 588
      ql_dbg(524288U, vha, 45333, "%s: %d: IDC lock failed\n", "qla8044_idc_lock",
             (int )ha->portnum);
#line 591
      timeout = 0U;
    } else {
#line 595
      tmp___0 = qla8044_lock_recovery(vha);
#line 595
      if (tmp___0 == 0) {
#line 597
        ret_val = 0U;
#line 598
        ql_dbg(524288U, vha, 45334, "%s:IDC lock Recovery by %dsuccessful...\n", "qla8044_idc_lock",
               (int )ha->portnum);
      } else {

      }
#line 607
      ql_dbg(524288U, vha, 45194, "%s: IDC lock Recovery by %d failed, Retrying timout\n",
             "qla8044_idc_lock", (int )ha->portnum);
#line 611
      timeout = 0U;
    }
  } else {

  }
#line 614
  msleep(200U);
  ldv_43544: ;
#line 557
  if (status == 0U) {
#line 559
    goto ldv_43543;
  } else {

  }
  ldv_43541: ;
#line 616
  return ((int )ret_val);
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_idc_unlock(struct qla_hw_data *ha ) 
{ 
  int id ;
  scsi_qla_host_t *vha ;
  void *tmp ;
  uint32_t tmp___0 ;

  {
#line 623
  tmp = pci_get_drvdata(ha->pdev);
#line 623
  vha = (scsi_qla_host_t *)tmp;
#line 625
  tmp___0 = qla8044_rd_reg(ha, 13572UL);
#line 625
  id = (int )tmp___0;
#line 627
  if ((id & 255) != (int )ha->portnum) {
#line 628
    ql_log(1U, vha, 45336, "%s: IDC Unlock by %d failed, lock owner is %d!\n", "qla8044_idc_unlock",
           (int )ha->portnum, id & 255);
#line 631
    return;
  } else {

  }
#line 635
  qla8044_wr_reg(ha, 13572UL, (uint32_t )(id | 255));
#line 636
  qla8044_rd_reg(ha, 14444UL);
#line 637
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_flash_lock(scsi_qla_host_t *vha ) 
{ 
  int lock_owner ;
  int timeout ;
  uint32_t lock_status ;
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 644
  timeout = 0;
#line 645
  lock_status = 0U;
#line 646
  ret_val = 0;
#line 647
  ha = vha->hw;
#line 649
  goto ldv_43562;
  ldv_43561: 
#line 650
  lock_status = qla8044_rd_reg(ha, 14416UL);
#line 651
  if (lock_status != 0U) {
#line 652
    goto ldv_43559;
  } else {

  }
#line 654
  timeout = timeout + 1;
#line 654
  if (timeout > 499) {
#line 655
    tmp = qla8044_rd_reg(ha, 13568UL);
#line 655
    lock_owner = (int )tmp;
#line 657
    ql_log(1U, vha, 45331, "%s: flash lock by %d failed, held by %d\n", "qla8044_flash_lock",
           (int )ha->portnum, lock_owner);
#line 660
    ret_val = 258;
#line 661
    goto ldv_43559;
  } else {

  }
#line 663
  msleep(20U);
  ldv_43562: ;
#line 649
  if (lock_status == 0U) {
#line 651
    goto ldv_43561;
  } else {

  }
  ldv_43559: 
#line 665
  qla8044_wr_reg(ha, 13568UL, (uint32_t )ha->portnum);
#line 666
  return (ret_val);
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_flash_unlock(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;

  {
#line 673
  ha = vha->hw;
#line 676
  qla8044_wr_reg(ha, 13568UL, 255U);
#line 677
  tmp = qla8044_rd_reg(ha, 14420UL);
#line 677
  ret_val = (int )tmp;
#line 678
  return;
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_flash_lock_recovery(struct scsi_qla_host *vha ) 
{ 
  int tmp ;

  {
#line 685
  tmp = qla8044_flash_lock(vha);
#line 685
  if (tmp != 0) {
#line 687
    ql_log(1U, vha, 45344, "Resetting flash_lock\n");
  } else {

  }
#line 695
  qla8044_flash_unlock(vha);
#line 696
  return;
}
}
#line 702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_read_flash_data(scsi_qla_host_t *vha , uint8_t *p_data , uint32_t flash_addr ,
                                   int u32_word_count ) 
{ 
  int i ;
  int ret_val ;
  uint32_t u32_word ;
  int tmp ;
  int tmp___0 ;

  {
#line 705
  ret_val = 0;
#line 708
  tmp = qla8044_flash_lock(vha);
#line 708
  if (tmp != 0) {
#line 709
    ret_val = 258;
#line 710
    goto exit_lock_error;
  } else {

  }
#line 713
  if ((flash_addr & 3U) != 0U) {
#line 714
    ql_log(1U, vha, 45335, "%s: Illegal addr = 0x%x\n", "qla8044_read_flash_data",
           flash_addr);
#line 716
    ret_val = 258;
#line 717
    goto exit_flash_read;
  } else {

  }
#line 720
  i = 0;
#line 720
  goto ldv_43584;
  ldv_43583: 
#line 721
  tmp___0 = qla8044_wr_reg_indirect(vha, 1108410416U, flash_addr & 4294901760U);
#line 721
  if (tmp___0 != 0) {
#line 723
    ql_log(1U, vha, 45337, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW\n! ",
           "qla8044_read_flash_data", flash_addr);
#line 727
    ret_val = 258;
#line 728
    goto exit_flash_read;
  } else {

  }
#line 731
  ret_val = qla8044_rd_reg_indirect(vha, (flash_addr & 65535U) | 1108672512U, & u32_word);
#line 734
  if (ret_val != 0) {
#line 735
    ql_log(1U, vha, 45196, "%s: failed to read addr 0x%x!\n", "qla8044_read_flash_data",
           flash_addr);
#line 738
    goto exit_flash_read;
  } else {

  }
#line 741
  *((uint32_t *)p_data) = u32_word;
#line 742
  p_data = p_data + 4UL;
#line 743
  flash_addr = flash_addr + 4U;
#line 720
  i = i + 1;
  ldv_43584: ;
#line 720
  if (i < u32_word_count) {
#line 722
    goto ldv_43583;
  } else {

  }

  exit_flash_read: 
#line 747
  qla8044_flash_unlock(vha);
  exit_lock_error: ;
#line 750
  return (ret_val);
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
uint8_t *qla8044_read_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                                  uint32_t length ) 
{ 
  int tmp ;

  {
#line 760
  scsi_block_requests(vha->host);
#line 761
  tmp = qla8044_read_flash_data(vha, buf, offset, (int )(length / 4U));
#line 761
  if (tmp != 0) {
#line 763
    ql_log(1U, vha, 45197, "%s: Failed to read from flash\n", "qla8044_read_optrom_data");
  } else {

  }
#line 767
  scsi_unblock_requests(vha->host);
#line 768
  return (buf);
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
__inline int qla8044_need_reset(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_state ;
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 776
  ha = vha->hw;
#line 778
  tmp = qla8044_rd_direct(vha, 3U);
#line 778
  drv_active = (uint32_t )tmp;
#line 779
  tmp___0 = qla8044_rd_direct(vha, 5U);
#line 779
  drv_state = (uint32_t )tmp___0;
#line 781
  rval = (int )((uint32_t )(1 << (int )ha->portnum) & drv_state);
#line 783
  if (*((unsigned long *)ha + 2UL) != 0UL && drv_active != 0U) {
#line 784
    rval = 1;
  } else {

  }
#line 785
  return (rval);
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  uint32_t i ;

  {
#line 804
  p_entry = (struct qla8044_entry *)p_hdr + 8U;
#line 807
  i = 0U;
#line 807
  goto ldv_43607;
  ldv_43606: 
#line 808
  qla8044_wr_reg_indirect(vha, p_entry->arg1, p_entry->arg2);
#line 809
  if ((unsigned int )p_hdr->delay != 0U) {
#line 810
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 807
  i = i + 1U;
#line 807
  p_entry = p_entry + 1;
  ldv_43607: ;
#line 807
  if ((uint32_t )p_hdr->count > i) {
#line 809
    goto ldv_43606;
  } else {

  }

#line 814
  return;
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_read_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  uint32_t i ;

  {
#line 830
  p_entry = (struct qla8044_entry *)p_hdr + 8U;
#line 833
  i = 0U;
#line 833
  goto ldv_43616;
  ldv_43615: 
#line 834
  qla8044_read_write_crb_reg(vha, p_entry->arg1, p_entry->arg2);
#line 836
  if ((unsigned int )p_hdr->delay != 0U) {
#line 837
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 833
  i = i + 1U;
#line 833
  p_entry = p_entry + 1;
  ldv_43616: ;
#line 833
  if ((uint32_t )p_hdr->count > i) {
#line 835
    goto ldv_43615;
  } else {

  }

#line 840
  return;
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_poll_reg(struct scsi_qla_host *vha , uint32_t addr , int duration ,
                            uint32_t test_mask , uint32_t test_result ) 
{ 
  uint32_t value ;
  int timeout_error ;
  uint8_t retries ;
  int ret_val ;
  uint8_t tmp ;

  {
#line 860
  ret_val = 0;
#line 862
  ret_val = qla8044_rd_reg_indirect(vha, addr, & value);
#line 863
  if (ret_val == 258) {
#line 864
    timeout_error = 1;
#line 865
    goto exit_poll_reg;
  } else {

  }
#line 869
  retries = (uint8_t )(duration / 10);
  ldv_43631: ;
#line 872
  if ((value & test_mask) != test_result) {
#line 873
    timeout_error = 1;
#line 874
    msleep((unsigned int )(duration / 10));
#line 875
    ret_val = qla8044_rd_reg_indirect(vha, addr, & value);
#line 876
    if (ret_val == 258) {
#line 877
      timeout_error = 1;
#line 878
      goto exit_poll_reg;
    } else {

    }
  } else {
#line 881
    timeout_error = 0;
#line 882
    goto ldv_43630;
  }
#line 884
  tmp = retries;
#line 884
  retries = (uint8_t )((int )retries - 1);
#line 884
  if ((unsigned int )tmp != 0U) {
#line 886
    goto ldv_43631;
  } else {

  }
  ldv_43630: ;
  exit_poll_reg: ;
#line 887
  if (timeout_error != 0) {
#line 888
    vha->reset_tmplt.seq_error = vha->reset_tmplt.seq_error + 1;
#line 889
    ql_log(0U, vha, 45200, "%s: Poll Failed: 0x%08x 0x%08x 0x%08x\n", "qla8044_poll_reg",
           value, test_mask, test_result);
  } else {

  }
#line 894
  return (timeout_error);
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_poll_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  struct qla8044_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  uint32_t value ;
  int tmp ;

  {
#line 916
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 922
  p_entry = (struct qla8044_entry *)p_poll + 8U;
#line 925
  delay = (long )p_hdr->delay;
#line 927
  if (delay == 0L) {
#line 928
    i = 0U;
#line 928
    goto ldv_43643;
    ldv_43642: 
#line 929
    qla8044_poll_reg(vha, p_entry->arg1, (int )delay, p_poll->test_mask, p_poll->test_value);
#line 928
    i = i + 1U;
#line 928
    p_entry = p_entry + 1;
    ldv_43643: ;
#line 928
    if ((uint32_t )p_hdr->count > i) {
#line 930
      goto ldv_43642;
    } else {

    }

  } else {
#line 932
    i = 0U;
#line 932
    goto ldv_43646;
    ldv_43645: ;
#line 933
    if (delay != 0L) {
#line 934
      tmp = qla8044_poll_reg(vha, p_entry->arg1, (int )delay, p_poll->test_mask, p_poll->test_value);
#line 934
      if (tmp != 0) {
#line 943
        qla8044_rd_reg_indirect(vha, p_entry->arg1, & value);
#line 945
        qla8044_rd_reg_indirect(vha, p_entry->arg2, & value);
      } else {

      }
    } else {

    }
#line 932
    i = i + 1U;
#line 932
    p_entry = p_entry + 1;
    ldv_43646: ;
#line 932
    if ((uint32_t )p_hdr->count > i) {
#line 934
      goto ldv_43645;
    } else {

    }

  }
#line 940
  return;
}
}
#line 963 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_poll_write_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  struct qla8044_quad_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  int tmp ;

  {
#line 971
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 974
  p_entry = (struct qla8044_quad_entry *)p_poll + 8U;
#line 977
  delay = (long )p_hdr->delay;
#line 979
  i = 0U;
#line 979
  goto ldv_43658;
  ldv_43657: 
#line 980
  qla8044_wr_reg_indirect(vha, p_entry->dr_addr, p_entry->dr_value);
#line 982
  qla8044_wr_reg_indirect(vha, p_entry->ar_addr, p_entry->ar_value);
#line 984
  if (delay != 0L) {
#line 985
    tmp = qla8044_poll_reg(vha, p_entry->ar_addr, (int )delay, p_poll->test_mask,
                           p_poll->test_value);
#line 985
    if (tmp != 0) {
#line 989
      ql_dbg(524288U, vha, 45201, "%s: Timeout Error: poll list, ", "qla8044_poll_write_list");
#line 992
      ql_dbg(524288U, vha, 45202, "item_num %d, entry_num %d\n", i, vha->reset_tmplt.seq_index);
    } else {

    }
  } else {

  }
#line 979
  i = i + 1U;
#line 979
  p_entry = p_entry + 1;
  ldv_43658: ;
#line 979
  if ((uint32_t )p_hdr->count > i) {
#line 981
    goto ldv_43657;
  } else {

  }

#line 986
  return;
}
}
#line 1010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_read_modify_write(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  struct qla8044_entry *p_entry ;
  struct qla8044_rmw *p_rmw_hdr ;
  uint32_t i ;

  {
#line 1017
  p_rmw_hdr = (struct qla8044_rmw *)p_hdr + 8U;
#line 1020
  p_entry = (struct qla8044_entry *)p_rmw_hdr + 16U;
#line 1023
  i = 0U;
#line 1023
  goto ldv_43668;
  ldv_43667: 
#line 1024
  qla8044_rmw_crb_reg(vha, p_entry->arg1, p_entry->arg2, p_rmw_hdr);
#line 1026
  if ((unsigned int )p_hdr->delay != 0U) {
#line 1027
    __udelay((unsigned long )p_hdr->delay);
  } else {

  }
#line 1023
  i = i + 1U;
#line 1023
  p_entry = p_entry + 1;
  ldv_43668: ;
#line 1023
  if ((uint32_t )p_hdr->count > i) {
#line 1025
    goto ldv_43667;
  } else {

  }

#line 1030
  return;
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_pause(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 1043
  if ((unsigned int )p_hdr->delay != 0U) {
#line 1044
    __ms = (unsigned long )p_hdr->delay;
#line 1044
    goto ldv_43676;
    ldv_43675: 
#line 1044
    __const_udelay(4295000UL);
    ldv_43676: 
#line 1044
    tmp = __ms;
#line 1044
    __ms = __ms - 1UL;
#line 1044
    if (tmp != 0UL) {
#line 1046
      goto ldv_43675;
    } else {

    }

  } else {

  }
#line 1053
  return;
}
}
#line 1055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_template_end(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 


  {
#line 1058
  vha->reset_tmplt.template_end = 1U;
#line 1060
  if (vha->reset_tmplt.seq_error == 0) {
#line 1061
    ql_dbg(524288U, vha, 45203, "%s: Reset sequence completed SUCCESSFULLY.\n", "qla8044_template_end");
  } else {
#line 1064
    ql_log(0U, vha, 45204, "%s: Reset sequence completed with some timeout errors.\n",
           "qla8044_template_end");
  }
#line 1067
  return;
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_poll_read_list(struct scsi_qla_host *vha , struct qla8044_reset_entry_hdr *p_hdr ) 
{ 
  long delay ;
  int index ;
  struct qla8044_quad_entry *p_entry ;
  struct qla8044_poll *p_poll ;
  uint32_t i ;
  uint32_t value ;
  int tmp ;
  int tmp___0 ;

  {
#line 1090
  p_poll = (struct qla8044_poll *)p_hdr + 8U;
#line 1093
  p_entry = (struct qla8044_quad_entry *)p_poll + 8U;
#line 1096
  delay = (long )p_hdr->delay;
#line 1098
  i = 0U;
#line 1098
  goto ldv_43695;
  ldv_43694: 
#line 1099
  qla8044_wr_reg_indirect(vha, p_entry->ar_addr, p_entry->ar_value);
#line 1101
  if (delay != 0L) {
#line 1102
    tmp___0 = qla8044_poll_reg(vha, p_entry->ar_addr, (int )delay, p_poll->test_mask,
                               p_poll->test_value);
#line 1102
    if (tmp___0 != 0) {
#line 1104
      ql_dbg(524288U, vha, 45205, "%s: Timeout Error: poll list, ", "qla8044_poll_read_list");
#line 1107
      ql_dbg(524288U, vha, 45206, "Item_num %d, entry_num %d\n", i, vha->reset_tmplt.seq_index);
    } else {
#line 1112
      index = vha->reset_tmplt.array_index;
#line 1113
      qla8044_rd_reg_indirect(vha, p_entry->dr_addr, & value);
#line 1115
      tmp = index;
#line 1115
      index = index + 1;
#line 1115
      vha->reset_tmplt.array[tmp] = value;
#line 1116
      if (index == 16) {
#line 1117
        vha->reset_tmplt.array_index = 1;
      } else {

      }
    }
  } else {

  }
#line 1098
  i = i + 1U;
#line 1098
  p_entry = p_entry + 1;
  ldv_43695: ;
#line 1098
  if ((uint32_t )p_hdr->count > i) {
#line 1100
    goto ldv_43694;
  } else {

  }

#line 1105
  return;
}
}
#line 1135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_process_reset_template(struct scsi_qla_host *vha , char *p_buff ) 
{ 
  int index ;
  int entries ;
  struct qla8044_reset_entry_hdr *p_hdr ;
  char *p_entry ;

  {
#line 1140
  p_entry = p_buff;
#line 1142
  vha->reset_tmplt.seq_end = 0U;
#line 1143
  vha->reset_tmplt.template_end = 0U;
#line 1144
  entries = (int )(vha->reset_tmplt.hdr)->entries;
#line 1145
  index = vha->reset_tmplt.seq_index;
#line 1147
  goto ldv_43719;
  ldv_43718: 
#line 1148
  p_hdr = (struct qla8044_reset_entry_hdr *)p_entry;
#line 1149
  switch ((int )p_hdr->cmd) {
  case 0: ;
#line 1151
  goto ldv_43706;
  case 1: 
#line 1153
  qla8044_write_list(vha, p_hdr);
#line 1154
  goto ldv_43706;
  case 2: 
#line 1156
  qla8044_read_write_list(vha, p_hdr);
#line 1157
  goto ldv_43706;
  case 4: 
#line 1159
  qla8044_poll_list(vha, p_hdr);
#line 1160
  goto ldv_43706;
  case 8: 
#line 1162
  qla8044_poll_write_list(vha, p_hdr);
#line 1163
  goto ldv_43706;
  case 16: 
#line 1165
  qla8044_read_modify_write(vha, p_hdr);
#line 1166
  goto ldv_43706;
  case 32: 
#line 1168
  qla8044_pause(vha, p_hdr);
#line 1169
  goto ldv_43706;
  case 64: 
#line 1171
  vha->reset_tmplt.seq_end = 1U;
#line 1172
  goto ldv_43706;
  case 128: 
#line 1174
  qla8044_template_end(vha, p_hdr);
#line 1175
  goto ldv_43706;
  case 256: 
#line 1177
  qla8044_poll_read_list(vha, p_hdr);
#line 1178
  goto ldv_43706;
  default: 
#line 1180
  ql_log(0U, vha, 45207, "%s: Unknown command ==> 0x%04x on entry = %d\n", "qla8044_process_reset_template",
         (int )p_hdr->cmd, index);
#line 1183
  goto ldv_43706;
  }
  ldv_43706: 
#line 1188
  p_entry = p_entry + (unsigned long )p_hdr->size;
#line 1147
  index = index + 1;
  ldv_43719: ;
#line 1147
  if ((unsigned int )vha->reset_tmplt.seq_end == 0U && index < entries) {
#line 1149
    goto ldv_43718;
  } else {

  }
#line 1190
  vha->reset_tmplt.seq_index = index;
#line 1191
  return;
}
}
#line 1194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_process_init_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 1196
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.init_offset);
#line 1198
  if ((unsigned int )vha->reset_tmplt.seq_end != 1U) {
#line 1199
    ql_log(0U, vha, 45208, "%s: Abrupt INIT Sub-Sequence end.\n", "qla8044_process_init_seq");
  } else {

  }
#line 1202
  return;
}
}
#line 1205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_process_stop_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 1207
  vha->reset_tmplt.seq_index = 0;
#line 1208
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.stop_offset);
#line 1209
  if ((unsigned int )vha->reset_tmplt.seq_end != 1U) {
#line 1210
    ql_log(0U, vha, 45209, "%s: Abrupt STOP Sub-Sequence end.\n", "qla8044_process_stop_seq");
  } else {

  }
#line 1212
  return;
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_process_start_seq(struct scsi_qla_host *vha ) 
{ 


  {
#line 1217
  qla8044_process_reset_template(vha, (char *)vha->reset_tmplt.start_offset);
#line 1218
  if ((unsigned int )vha->reset_tmplt.template_end != 1U) {
#line 1219
    ql_log(0U, vha, 45210, "%s: Abrupt START Sub-Sequence end.\n", "qla8044_process_start_seq");
  } else {

  }
#line 1222
  return;
}
}
#line 1225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_lockless_flash_read_u32(struct scsi_qla_host *vha , uint32_t flash_addr ,
                                           uint8_t *p_data , int u32_word_count ) 
{ 
  uint32_t i ;
  uint32_t u32_word ;
  uint32_t flash_offset ;
  uint32_t addr ;
  int ret_val ;

  {
#line 1231
  addr = flash_addr;
#line 1232
  ret_val = 0;
#line 1234
  flash_offset = addr & 65535U;
#line 1236
  if ((addr & 3U) != 0U) {
#line 1237
    ql_log(0U, vha, 45211, "%s: Illegal addr = 0x%x\n", "qla8044_lockless_flash_read_u32",
           addr);
#line 1239
    ret_val = 258;
#line 1240
    goto exit_lockless_read;
  } else {

  }
#line 1243
  ret_val = qla8044_wr_reg_indirect(vha, 1108410416U, addr);
#line 1246
  if (ret_val != 0) {
#line 1247
    ql_log(0U, vha, 45212, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",
           "qla8044_lockless_flash_read_u32", addr);
#line 1250
    goto exit_lockless_read;
  } else {

  }
#line 1254
  if ((unsigned long )flash_offset + (unsigned long )u32_word_count * 4UL > 65535UL) {
#line 1257
    i = 0U;
#line 1257
    goto ldv_43747;
    ldv_43746: 
#line 1258
    ret_val = qla8044_rd_reg_indirect(vha, (addr & 65535U) | 1108672512U, & u32_word);
#line 1260
    if (ret_val != 0) {
#line 1261
      ql_log(0U, vha, 45213, "%s: failed to read addr 0x%x!\n", "qla8044_lockless_flash_read_u32",
             addr);
#line 1264
      goto exit_lockless_read;
    } else {

    }
#line 1266
    *((uint32_t *)p_data) = u32_word;
#line 1267
    p_data = p_data + 4UL;
#line 1268
    addr = addr + 4U;
#line 1269
    flash_offset = flash_offset + 4U;
#line 1270
    if (flash_offset > 65535U) {
#line 1272
      ret_val = qla8044_wr_reg_indirect(vha, 1108410416U, addr);
#line 1274
      if (ret_val != 0) {
#line 1275
        ql_log(0U, vha, 45215, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",
               "qla8044_lockless_flash_read_u32", addr);
#line 1279
        goto exit_lockless_read;
      } else {

      }
#line 1281
      flash_offset = 0U;
    } else {

    }
#line 1257
    i = i + 1U;
    ldv_43747: ;
#line 1257
    if ((uint32_t )u32_word_count > i) {
#line 1259
      goto ldv_43746;
    } else {

    }

  } else {
#line 1286
    i = 0U;
#line 1286
    goto ldv_43750;
    ldv_43749: 
#line 1287
    ret_val = qla8044_rd_reg_indirect(vha, (addr & 65535U) | 1108672512U, & u32_word);
#line 1289
    if (ret_val != 0) {
#line 1290
      ql_log(0U, vha, 45216, "%s: failed to read addr 0x%x!\n", "qla8044_lockless_flash_read_u32",
             addr);
#line 1293
      goto exit_lockless_read;
    } else {

    }
#line 1295
    *((uint32_t *)p_data) = u32_word;
#line 1296
    p_data = p_data + 4UL;
#line 1297
    addr = addr + 4U;
#line 1286
    i = i + 1U;
    ldv_43750: ;
#line 1286
    if ((uint32_t )u32_word_count > i) {
#line 1288
      goto ldv_43749;
    } else {

    }

  }
  exit_lockless_read: ;
#line 1302
  return (ret_val);
}
}
#line 1316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_ms_mem_write_128b(struct scsi_qla_host *vha , uint64_t addr , uint32_t *data ,
                                     uint32_t count ) 
{ 
  int i ;
  int j ;
  int ret_val ;
  uint32_t agt_ctrl ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;
  int tmp___0 ;
  uint32_t *tmp___1 ;
  int tmp___2 ;
  uint32_t *tmp___3 ;
  int tmp___4 ;
  uint32_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1319
  ret_val = 0;
#line 1322
  ha = vha->hw;
#line 1325
  if ((addr & 15ULL) != 0ULL) {
#line 1326
    ret_val = 258;
#line 1327
    goto exit_ms_mem_write;
  } else {

  }
#line 1329
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 1332
  ret_val = qla8044_wr_reg_indirect(vha, 1090519192U, 0U);
#line 1333
  if (ret_val == 258) {
#line 1334
    ql_log(0U, vha, 45217, "%s: write to AGT_ADDR_HI failed!\n", "qla8044_ms_mem_write_128b");
#line 1336
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1339
  i = 0;
#line 1339
  goto ldv_43771;
  ldv_43770: ;
#line 1340
  if ((addr > 13019119615ULL || addr <= 12884901887ULL) && addr > 268435455ULL) {
#line 1344
    ret_val = 258;
#line 1345
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1348
  ret_val = qla8044_wr_reg_indirect(vha, 1090519188U, (uint32_t )addr);
#line 1352
  tmp = data;
#line 1352
  data = data + 1;
#line 1352
  tmp___0 = qla8044_wr_reg_indirect(vha, 1090519200U, *tmp);
#line 1352
  ret_val = tmp___0 + ret_val;
#line 1354
  tmp___1 = data;
#line 1354
  data = data + 1;
#line 1354
  tmp___2 = qla8044_wr_reg_indirect(vha, 1090519204U, *tmp___1);
#line 1354
  ret_val = tmp___2 + ret_val;
#line 1356
  tmp___3 = data;
#line 1356
  data = data + 1;
#line 1356
  tmp___4 = qla8044_wr_reg_indirect(vha, 1090519216U, *tmp___3);
#line 1356
  ret_val = tmp___4 + ret_val;
#line 1358
  tmp___5 = data;
#line 1358
  data = data + 1;
#line 1358
  tmp___6 = qla8044_wr_reg_indirect(vha, 1090519220U, *tmp___5);
#line 1358
  ret_val = tmp___6 + ret_val;
#line 1360
  if (ret_val == 258) {
#line 1361
    ql_log(0U, vha, 45218, "%s: write to AGT_WRDATA failed!\n", "qla8044_ms_mem_write_128b");
#line 1364
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1368
  ret_val = qla8044_wr_reg_indirect(vha, 1090519184U, 6U);
#line 1370
  tmp___7 = qla8044_wr_reg_indirect(vha, 1090519184U, 7U);
#line 1370
  ret_val = tmp___7 + ret_val;
#line 1372
  if (ret_val == 258) {
#line 1373
    ql_log(0U, vha, 45219, "%s: write to AGT_CTRL failed!\n", "qla8044_ms_mem_write_128b");
#line 1375
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1378
  j = 0;
#line 1378
  goto ldv_43769;
  ldv_43768: 
#line 1379
  ret_val = qla8044_rd_reg_indirect(vha, 1090519184U, & agt_ctrl);
#line 1381
  if (ret_val == 258) {
#line 1382
    ql_log(0U, vha, 45220, "%s: failed to read MD_MIU_TEST_AGT_CTRL!\n", "qla8044_ms_mem_write_128b");
#line 1385
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1387
  if ((agt_ctrl & 8U) == 0U) {
#line 1388
    goto ldv_43767;
  } else {

  }
#line 1378
  j = j + 1;
  ldv_43769: ;
#line 1378
  if (j <= 999) {
#line 1380
    goto ldv_43768;
  } else {

  }
  ldv_43767: ;
#line 1392
  if (j > 999) {
#line 1393
    ql_log(0U, vha, 45221, "%s: MS memory write failed!\n", "qla8044_ms_mem_write_128b");
#line 1396
    ret_val = 258;
#line 1397
    goto exit_ms_mem_write_unlock;
  } else {

  }
#line 1339
  i = i + 1;
#line 1339
  addr = addr + 16ULL;
  ldv_43771: ;
#line 1339
  if ((uint32_t )i < count) {
#line 1341
    goto ldv_43770;
  } else {

  }

  exit_ms_mem_write_unlock: 
#line 1402
  ldv_write_unlock_irqrestore(& ha->hw_lock);
  exit_ms_mem_write: ;
#line 1405
  return (ret_val);
}
}
#line 1409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_copy_bootloader(struct scsi_qla_host *vha ) 
{ 
  uint8_t *p_cache ;
  uint32_t src ;
  uint32_t count ;
  uint32_t size ;
  uint64_t dest ;
  int ret_val ;
  struct qla_hw_data *ha ;
  uint32_t tmp ;
  void *tmp___0 ;

  {
#line 1414
  ret_val = 0;
#line 1415
  ha = vha->hw;
#line 1417
  src = 65536U;
#line 1418
  tmp = qla8044_rd_reg(ha, 13660UL);
#line 1418
  dest = (uint64_t )tmp;
#line 1419
  size = qla8044_rd_reg(ha, 13664UL);
#line 1422
  if ((size & 15U) != 0U) {
#line 1423
    size = (size + 16U) & 4294967280U;
  } else {

  }
#line 1426
  count = size / 16U;
#line 1428
  tmp___0 = vmalloc((unsigned long )size);
#line 1428
  p_cache = (uint8_t *)tmp___0;
#line 1429
  if ((unsigned long )p_cache == (unsigned long )((uint8_t *)0U)) {
#line 1430
    ql_log(0U, vha, 45222, "%s: Failed to allocate memory for boot loader cache\n",
           "qla8044_copy_bootloader");
#line 1433
    ret_val = 258;
#line 1434
    goto exit_copy_bootloader;
  } else {

  }
#line 1437
  ret_val = qla8044_lockless_flash_read_u32(vha, src, p_cache, (int )(size / 4U));
#line 1439
  if (ret_val == 258) {
#line 1440
    ql_log(0U, vha, 45223, "%s: Error reading F/W from flash!!!\n", "qla8044_copy_bootloader");
#line 1442
    goto exit_copy_error;
  } else {

  }
#line 1444
  ql_dbg(524288U, vha, 45224, "%s: Read F/W from flash!\n", "qla8044_copy_bootloader");
#line 1448
  ret_val = qla8044_ms_mem_write_128b(vha, dest, (uint32_t *)p_cache, count);
#line 1450
  if (ret_val == 258) {
#line 1451
    ql_log(0U, vha, 45225, "%s: Error writing F/W to MS !!!\n", "qla8044_copy_bootloader");
#line 1453
    goto exit_copy_error;
  } else {

  }
#line 1455
  ql_dbg(524288U, vha, 45226, "%s: Wrote F/W (size %d) to MS !!!\n", "qla8044_copy_bootloader",
         size);
  exit_copy_error: 
#line 1460
  vfree((void const   *)p_cache);
  exit_copy_bootloader: ;
#line 1463
  return (ret_val);
}
}
#line 1467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_restart(struct scsi_qla_host *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1469
  ret_val = 0;
#line 1470
  ha = vha->hw;
#line 1472
  qla8044_process_stop_seq(vha);
#line 1475
  if (ql2xmdenable != 0) {
#line 1476
    qla8044_get_minidump(vha);
  } else {
#line 1478
    ql_log(0U, vha, 45388, "Minidump disabled.\n");
  }
#line 1481
  qla8044_process_init_seq(vha);
#line 1483
  tmp = qla8044_copy_bootloader(vha);
#line 1483
  if (tmp != 0) {
#line 1484
    ql_log(0U, vha, 45227, "%s: Copy bootloader, firmware restart failed!\n", "qla8044_restart");
#line 1487
    ret_val = 258;
#line 1488
    goto exit_restart;
  } else {

  }
#line 1494
  qla8044_wr_reg(ha, 13820UL, 0U);
#line 1496
  qla8044_process_start_seq(vha);
  exit_restart: ;
#line 1499
  return (ret_val);
}
}
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_check_cmd_peg_status(struct scsi_qla_host *vha ) 
{ 
  uint32_t val ;
  uint32_t ret_val ;
  int retries ;
  struct qla_hw_data *ha ;

  {
#line 1513
  ret_val = 258U;
#line 1514
  retries = 60;
#line 1515
  ha = vha->hw;
  ldv_43802: 
#line 1518
  val = qla8044_rd_reg(ha, 13904UL);
#line 1519
  if (val == 65281U) {
#line 1520
    ql_dbg(524288U, vha, 45228, "%s: Command Peg initialization complete! state=0x%x\n",
           "qla8044_check_cmd_peg_status", val);
#line 1523
    ret_val = 0U;
#line 1524
    goto ldv_43801;
  } else {

  }
#line 1526
  msleep(500U);
#line 1527
  retries = retries - 1;
#line 1527
  if (retries != 0) {
#line 1529
    goto ldv_43802;
  } else {

  }
  ldv_43801: ;
#line 1529
  return ((int )ret_val);
}
}
#line 1533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_start_firmware(struct scsi_qla_host *vha ) 
{ 
  int ret_val ;
  int tmp ;

  {
#line 1535
  ret_val = 0;
#line 1537
  tmp = qla8044_restart(vha);
#line 1537
  if (tmp != 0) {
#line 1538
    ql_log(0U, vha, 45229, "%s: Restart Error!!!, Need Reset!!!\n", "qla8044_start_firmware");
#line 1541
    ret_val = 258;
#line 1542
    goto exit_start_fw;
  } else {
#line 1544
    ql_dbg(524288U, vha, 45231, "%s: Restart done!\n", "qla8044_start_firmware");
  }
#line 1547
  ret_val = qla8044_check_cmd_peg_status(vha);
#line 1548
  if (ret_val != 0) {
#line 1549
    ql_log(0U, vha, 45232, "%s: Peg not initialized!\n", "qla8044_start_firmware");
#line 1551
    ret_val = 258;
  } else {

  }
  exit_start_fw: ;
#line 1555
  return (ret_val);
}
}
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_clear_drv_active(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1562
  ha = vha->hw;
#line 1564
  tmp = qla8044_rd_direct(vha, 3U);
#line 1564
  drv_active = (uint32_t )tmp;
#line 1565
  drv_active = (uint32_t )(~ (1 << (int )ha->portnum)) & drv_active;
#line 1567
  ql_log(2U, vha, 45233, "%s(%ld): drv_active: 0x%08x\n", "qla8044_clear_drv_active",
         vha->host_no, drv_active);
#line 1571
  qla8044_wr_direct(vha, 3U, drv_active);
#line 1572
  return;
}
}
#line 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_device_bootstrap(struct scsi_qla_host *vha ) 
{ 
  int rval ;
  int i ;
  uint32_t old_count ;
  uint32_t count ;
  int need_reset ;
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 1583
  rval = 258;
#line 1585
  old_count = 0U;
#line 1585
  count = 0U;
#line 1586
  need_reset = 0;
#line 1588
  ha = vha->hw;
#line 1590
  need_reset = qla8044_need_reset(vha);
#line 1592
  if (need_reset == 0) {
#line 1593
    tmp = qla8044_rd_direct(vha, 2U);
#line 1593
    old_count = (uint32_t )tmp;
#line 1596
    i = 0;
#line 1596
    goto ldv_43827;
    ldv_43826: 
#line 1597
    msleep(200U);
#line 1599
    tmp___0 = qla8044_rd_direct(vha, 2U);
#line 1599
    count = (uint32_t )tmp___0;
#line 1601
    if (count != old_count) {
#line 1602
      rval = 0;
#line 1603
      goto dev_ready;
    } else {

    }
#line 1596
    i = i + 1;
    ldv_43827: ;
#line 1596
    if (i <= 9) {
#line 1598
      goto ldv_43826;
    } else {

    }
#line 1606
    qla8044_flash_lock_recovery(vha);
  } else
#line 1609
  if (*((unsigned long *)ha + 2UL) != 0UL) {
#line 1610
    qla8044_flash_lock_recovery(vha);
  } else {

  }
#line 1614
  ql_log(2U, vha, 45234, "%s: HW State: INITIALIZING\n", "qla8044_device_bootstrap");
#line 1616
  qla8044_wr_direct(vha, 4U, 2U);
#line 1619
  qla8044_idc_unlock(ha);
#line 1620
  rval = qla8044_start_firmware(vha);
#line 1621
  qla8044_idc_lock(ha);
#line 1623
  if (rval != 0) {
#line 1624
    ql_log(2U, vha, 45235, "%s: HW State: FAILED\n", "qla8044_device_bootstrap");
#line 1626
    qla8044_clear_drv_active(vha);
#line 1627
    qla8044_wr_direct(vha, 4U, 6U);
#line 1629
    return (rval);
  } else {

  }
#line 1634
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1635
  if ((idc_ctrl & 2U) != 0U) {
#line 1636
    qla8044_wr_reg(ha, 14224UL, idc_ctrl & 4294967293U);
#line 1638
    ha->fw_dumped = 0;
  } else {

  }
  dev_ready: 
#line 1642
  ql_log(2U, vha, 45236, "%s: HW State: READY\n", "qla8044_device_bootstrap");
#line 1644
  qla8044_wr_direct(vha, 4U, 3U);
#line 1646
  return (rval);
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_dump_reset_seq_hdr(struct scsi_qla_host *vha ) 
{ 
  u8 *phdr ;

  {
#line 1655
  if ((unsigned long )vha->reset_tmplt.buff == (unsigned long )((uint8_t *)0U)) {
#line 1656
    ql_log(0U, vha, 45237, "%s: Error Invalid reset_seq_template\n", "qla8044_dump_reset_seq_hdr");
#line 1658
    return;
  } else {

  }
#line 1661
  phdr = vha->reset_tmplt.buff;
#line 1662
  ql_dbg(524288U, vha, 45238, "Reset Template :\n\t0x%X 0x%X 0x%X 0x%X0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n\t0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n\n",
         (int )*phdr, (int )*(phdr + 1UL), (int )*(phdr + 2UL), (int )*(phdr + 3UL),
         (int )*(phdr + 4UL), (int )*(phdr + 5UL), (int )*(phdr + 6UL), (int )*(phdr + 7UL),
         (int )*(phdr + 8UL), (int )*(phdr + 9UL), (int )*(phdr + 10UL), (int )*(phdr + 11UL),
         (int )*(phdr + 12UL), (int )*(phdr + 13UL), (int )*(phdr + 14UL), (int )*(phdr + 15UL));
#line 1670
  return;
}
}
#line 1680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_reset_seq_checksum_test(struct scsi_qla_host *vha ) 
{ 
  uint32_t sum ;
  uint16_t *buff ;
  int u16_count ;
  uint16_t *tmp ;
  int tmp___0 ;

  {
#line 1682
  sum = 0U;
#line 1683
  buff = (uint16_t *)vha->reset_tmplt.buff;
#line 1684
  u16_count = (int )((unsigned int )(vha->reset_tmplt.hdr)->size / 2U);
#line 1686
  goto ldv_43842;
  ldv_43841: 
#line 1687
  tmp = buff;
#line 1687
  buff = buff + 1;
#line 1687
  sum = (uint32_t )*tmp + sum;
  ldv_43842: 
#line 1686
  tmp___0 = u16_count;
#line 1686
  u16_count = u16_count - 1;
#line 1686
  if (tmp___0 > 0) {
#line 1688
    goto ldv_43841;
  } else {

  }

#line 1689
  goto ldv_43845;
  ldv_43844: 
#line 1690
  sum = (sum & 65535U) + (sum >> 16);
  ldv_43845: ;
#line 1689
  if (sum >> 16 != 0U) {
#line 1691
    goto ldv_43844;
  } else {

  }

#line 1693
  if (sum != 4294967295U) {
#line 1694
    return (0);
  } else {
#line 1696
    ql_log(0U, vha, 45239, "%s: Reset seq checksum failed\n", "qla8044_reset_seq_checksum_test");
#line 1698
    return (258);
  }
}
}
#line 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_read_reset_template(struct scsi_qla_host *vha ) 
{ 
  uint8_t *p_buff ;
  uint32_t addr ;
  uint32_t tmplt_hdr_def_size ;
  uint32_t tmplt_hdr_size ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1714
  vha->reset_tmplt.seq_error = 0;
#line 1715
  tmp = vmalloc(8192UL);
#line 1715
  vha->reset_tmplt.buff = (uint8_t *)tmp;
#line 1716
  if ((unsigned long )vha->reset_tmplt.buff == (unsigned long )((uint8_t *)0U)) {
#line 1717
    ql_log(0U, vha, 45240, "%s: Failed to allocate reset template resources\n", "qla8044_read_reset_template");
#line 1720
    goto exit_read_reset_template;
  } else {

  }
#line 1723
  p_buff = vha->reset_tmplt.buff;
#line 1724
  addr = 5177344U;
#line 1726
  tmplt_hdr_def_size = 4U;
#line 1729
  ql_dbg(524288U, vha, 45241, "%s: Read template hdr size %d from Flash\n", "qla8044_read_reset_template",
         tmplt_hdr_def_size);
#line 1734
  tmp___0 = qla8044_read_flash_data(vha, p_buff, addr, (int )tmplt_hdr_def_size);
#line 1734
  if (tmp___0 != 0) {
#line 1735
    ql_log(0U, vha, 45242, "%s: Failed to read reset template\n", "qla8044_read_reset_template");
#line 1737
    goto exit_read_template_error;
  } else {

  }
#line 1740
  vha->reset_tmplt.hdr = (struct qla8044_reset_template_hdr *)vha->reset_tmplt.buff;
#line 1744
  tmplt_hdr_size = (unsigned int )(vha->reset_tmplt.hdr)->hdr_size / 4U;
#line 1745
  if (tmplt_hdr_size != tmplt_hdr_def_size || (unsigned int )(vha->reset_tmplt.hdr)->signature != 51966U) {
#line 1747
    ql_log(0U, vha, 45243, "%s: Template Header size invalid %d tmplt_hdr_def_size %d!!!\n",
           "qla8044_read_reset_template", tmplt_hdr_size, tmplt_hdr_def_size);
#line 1751
    goto exit_read_template_error;
  } else {

  }
#line 1754
  addr = (uint32_t )((int )(vha->reset_tmplt.hdr)->hdr_size + 5177344);
#line 1755
  p_buff = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->hdr_size;
#line 1756
  tmplt_hdr_def_size = (uint32_t )((unsigned long )((int )(vha->reset_tmplt.hdr)->size - (int )(vha->reset_tmplt.hdr)->hdr_size) / 4UL);
#line 1759
  ql_dbg(524288U, vha, 45244, "%s: Read rest of the template size %d\n", "qla8044_read_reset_template",
         (int )(vha->reset_tmplt.hdr)->size);
#line 1764
  tmp___1 = qla8044_read_flash_data(vha, p_buff, addr, (int )tmplt_hdr_def_size);
#line 1764
  if (tmp___1 != 0) {
#line 1765
    ql_log(0U, vha, 45245, "%s: Failed to read reset tempelate\n", "qla8044_read_reset_template");
#line 1767
    goto exit_read_template_error;
  } else {

  }
#line 1771
  tmp___2 = qla8044_reset_seq_checksum_test(vha);
#line 1771
  if (tmp___2 != 0) {
#line 1772
    ql_log(0U, vha, 45246, "%s: Reset Seq checksum failed!\n", "qla8044_read_reset_template");
#line 1774
    goto exit_read_template_error;
  } else {

  }
#line 1777
  ql_dbg(524288U, vha, 45247, "%s: Reset Seq checksum passed! Get stop, start and init seq offsets\n",
         "qla8044_read_reset_template");
#line 1782
  vha->reset_tmplt.init_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->init_seq_offset;
#line 1785
  vha->reset_tmplt.start_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->start_seq_offset;
#line 1788
  vha->reset_tmplt.stop_offset = vha->reset_tmplt.buff + (unsigned long )(vha->reset_tmplt.hdr)->hdr_size;
#line 1791
  qla8044_dump_reset_seq_hdr(vha);
#line 1793
  goto exit_read_reset_template;
  exit_read_template_error: 
#line 1796
  vfree((void const   *)vha->reset_tmplt.buff);
  exit_read_reset_template: ;
#line 1799
  return;
}
}
#line 1803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_set_idc_dontreset(struct scsi_qla_host *vha ) 
{ 
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;

  {
#line 1806
  ha = vha->hw;
#line 1808
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1809
  idc_ctrl = idc_ctrl | 1U;
#line 1810
  ql_dbg(524288U, vha, 45248, "%s: idc_ctrl = %d\n", "qla8044_set_idc_dontreset",
         idc_ctrl);
#line 1812
  qla8044_wr_reg(ha, 14224UL, idc_ctrl);
#line 1813
  return;
}
}
#line 1816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
__inline void qla8044_set_rst_ready(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_state ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1819
  ha = vha->hw;
#line 1821
  tmp = qla8044_rd_direct(vha, 5U);
#line 1821
  drv_state = (uint32_t )tmp;
#line 1825
  drv_state = (uint32_t )(1 << (int )ha->portnum) | drv_state;
#line 1827
  ql_log(2U, vha, 45249, "%s(%ld): drv_state: 0x%08x\n", "qla8044_set_rst_ready",
         vha->host_no, drv_state);
#line 1830
  qla8044_wr_direct(vha, 5U, drv_state);
#line 1831
  return;
}
}
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_need_reset_handler(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  unsigned long reset_timeout ;
  unsigned long dev_init_timeout ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1842
  dev_state = 0U;
#line 1844
  ha = vha->hw;
#line 1846
  ql_log(0U, vha, 45250, "%s: Performing ISP error recovery\n", "qla8044_need_reset_handler");
#line 1849
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 1850
    qla8044_idc_unlock(ha);
#line 1851
    qla2x00_abort_isp_cleanup(vha);
#line 1852
    (*((ha->isp_ops)->get_flash_version))(vha, (void *)(vha->req)->ring);
#line 1853
    (*((ha->isp_ops)->nvram_config))(vha);
#line 1854
    qla8044_idc_lock(ha);
  } else {

  }
#line 1857
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1858
    ql_dbg(524288U, vha, 45251, "%s(%ld): reset acknowledged\n", "qla8044_need_reset_handler",
           vha->host_no);
#line 1861
    qla8044_set_rst_ready(vha);
#line 1866
    dev_init_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
    ldv_43887: ;
#line 1869
    if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 1870
      ql_log(2U, vha, 45252, "%s: Non Reset owner DEV INIT TIMEOUT!\n", "qla8044_need_reset_handler");
#line 1873
      goto ldv_43886;
    } else {

    }
#line 1876
    qla8044_idc_unlock(ha);
#line 1877
    msleep(1000U);
#line 1878
    qla8044_idc_lock(ha);
#line 1880
    tmp = qla8044_rd_direct(vha, 4U);
#line 1880
    dev_state = (uint32_t )tmp;
#line 1882
    if (dev_state == 4U) {
#line 1884
      goto ldv_43887;
    } else {

    }
    ldv_43886: ;
  } else {
#line 1884
    qla8044_set_rst_ready(vha);
#line 1887
    reset_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 1889
    tmp___0 = qla8044_rd_direct(vha, 5U);
#line 1889
    drv_state = (uint32_t )tmp___0;
#line 1891
    tmp___1 = qla8044_rd_direct(vha, 3U);
#line 1891
    drv_active = (uint32_t )tmp___1;
#line 1894
    ql_log(2U, vha, 45253, "%s(%ld): drv_state = 0x%x, drv_active = 0x%x\n", "qla8044_need_reset_handler",
           vha->host_no, drv_state, drv_active);
#line 1898
    goto ldv_43896;
    ldv_43895: ;
#line 1899
    if ((long )((unsigned long )jiffies - reset_timeout) >= 0L) {
#line 1900
      ql_log(2U, vha, 45254, "%s: RESET TIMEOUT!drv_state: 0x%08x, drv_active: 0x%08x\n",
             (char *)"qla2xxx", drv_state, drv_active);
#line 1904
      goto ldv_43894;
    } else {

    }
#line 1907
    qla8044_idc_unlock(ha);
#line 1908
    msleep(1000U);
#line 1909
    qla8044_idc_lock(ha);
#line 1911
    tmp___2 = qla8044_rd_direct(vha, 5U);
#line 1911
    drv_state = (uint32_t )tmp___2;
#line 1913
    tmp___3 = qla8044_rd_direct(vha, 3U);
#line 1913
    drv_active = (uint32_t )tmp___3;
    ldv_43896: ;
#line 1898
    if (drv_state != drv_active) {
#line 1900
      goto ldv_43895;
    } else {

    }
    ldv_43894: ;
#line 1917
    if (drv_state != drv_active) {
#line 1918
      ql_log(2U, vha, 45255, "%s(%ld): Reset_owner turning off drv_active of non-acking function 0x%x\n",
             "qla8044_need_reset_handler", vha->host_no, drv_active ^ drv_state);
#line 1922
      drv_active = drv_active & drv_state;
#line 1923
      qla8044_wr_direct(vha, 3U, drv_active);
    } else {

    }
#line 1931
    ha->flags.nic_core_reset_owner = 0U;
#line 1934
    qla8044_device_bootstrap(vha);
  }
#line 1936
  return;
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_set_drv_active(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 1942
  ha = vha->hw;
#line 1944
  tmp = qla8044_rd_direct(vha, 3U);
#line 1944
  drv_active = (uint32_t )tmp;
#line 1948
  drv_active = (uint32_t )(1 << (int )ha->portnum) | drv_active;
#line 1950
  ql_log(2U, vha, 45256, "%s(%ld): drv_active: 0x%08x\n", "qla8044_set_drv_active",
         vha->host_no, drv_active);
#line 1953
  qla8044_wr_direct(vha, 3U, drv_active);
#line 1954
  return;
}
}
#line 1957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_clear_idc_dontreset(struct scsi_qla_host *vha ) 
{ 
  uint32_t idc_ctrl ;
  struct qla_hw_data *ha ;

  {
#line 1960
  ha = vha->hw;
#line 1962
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 1963
  idc_ctrl = idc_ctrl & 4294967294U;
#line 1964
  ql_log(2U, vha, 45257, "%s: idc_ctrl = %d\n", "qla8044_clear_idc_dontreset", idc_ctrl);
#line 1967
  qla8044_wr_reg(ha, 14224UL, idc_ctrl);
#line 1968
  return;
}
}
#line 1971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_set_idc_ver(struct scsi_qla_host *vha ) 
{ 
  int idc_ver ;
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 1975
  rval = 0;
#line 1976
  ha = vha->hw;
#line 1978
  tmp = qla8044_rd_direct(vha, 3U);
#line 1978
  drv_active = (uint32_t )tmp;
#line 1979
  if ((uint32_t )(1 << (int )ha->portnum) == drv_active) {
#line 1980
    idc_ver = qla8044_rd_direct(vha, 8U);
#line 1982
    idc_ver = idc_ver & -256;
#line 1983
    idc_ver = idc_ver | 1;
#line 1984
    qla8044_wr_direct(vha, 8U, (uint32_t const   )idc_ver);
#line 1986
    ql_log(2U, vha, 45258, "%s: IDC version updated to %d\n", "qla8044_set_idc_ver",
           idc_ver);
  } else {
#line 1990
    idc_ver = qla8044_rd_direct(vha, 8U);
#line 1992
    idc_ver = idc_ver & 255;
#line 1993
    if (idc_ver != 1) {
#line 1994
      ql_log(2U, vha, 45259, "%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\n",
             "qla8044_set_idc_ver", 1, idc_ver);
#line 2000
      rval = 258;
#line 2001
      goto exit_set_idc_ver;
    } else {

    }
  }
#line 2006
  tmp___0 = qla8044_rd_reg(ha, 14232UL);
#line 2006
  idc_ver = (int )tmp___0;
#line 2007
  idc_ver = ~ (3 << (int )ha->portnum * 2) & idc_ver;
#line 2008
  idc_ver = idc_ver;
#line 2009
  qla8044_wr_reg(ha, 14232UL, (uint32_t )idc_ver);
  exit_set_idc_ver: ;
#line 2012
  return (rval);
}
}
#line 2016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_update_idc_reg(struct scsi_qla_host *vha ) 
{ 
  uint32_t drv_active ;
  int rval ;
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 2019
  rval = 0;
#line 2020
  ha = vha->hw;
#line 2022
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 2023
    goto exit_update_idc_reg;
  } else {

  }
#line 2025
  qla8044_idc_lock(ha);
#line 2026
  qla8044_set_drv_active(vha);
#line 2028
  tmp = qla8044_rd_direct(vha, 3U);
#line 2028
  drv_active = (uint32_t )tmp;
#line 2033
  if ((uint32_t )(1 << (int )ha->portnum) == drv_active && ql2xdontresethba == 0) {
#line 2034
    qla8044_clear_idc_dontreset(vha);
  } else {

  }
#line 2036
  rval = qla8044_set_idc_ver(vha);
#line 2037
  if (rval == 258) {
#line 2038
    qla8044_clear_drv_active(vha);
  } else {

  }
#line 2039
  qla8044_idc_unlock(ha);
  exit_update_idc_reg: ;
#line 2042
  return (rval);
}
}
#line 2050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_need_qsnt_handler(struct scsi_qla_host *vha ) 
{ 
  unsigned long qsnt_timeout ;
  uint32_t drv_state ;
  uint32_t drv_active ;
  uint32_t dev_state ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2054
  ha = vha->hw;
#line 2056
  if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 2057
    qla2x00_quiesce_io(vha);
  } else {
#line 2059
    return;
  }
#line 2061
  qla8044_set_qsnt_ready(vha);
#line 2064
  qsnt_timeout = (unsigned long )jiffies + 7500UL;
#line 2065
  tmp = qla8044_rd_direct(vha, 5U);
#line 2065
  drv_state = (uint32_t )tmp;
#line 2066
  tmp___0 = qla8044_rd_direct(vha, 3U);
#line 2066
  drv_active = (uint32_t )tmp___0;
#line 2070
  drv_active = drv_active << 1;
#line 2072
  goto ldv_43940;
  ldv_43939: ;
#line 2073
  if ((long )((unsigned long )jiffies - qsnt_timeout) >= 0L) {
#line 2077
    clear_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2078
    qla8044_wr_direct(vha, 4U, 3U);
#line 2080
    qla8044_clear_qsnt_ready(vha);
#line 2081
    ql_log(2U, vha, 45260, "Timeout waiting for quiescent ack!!!\n");
#line 2083
    return;
  } else {

  }
#line 2085
  qla8044_idc_unlock(ha);
#line 2086
  msleep(1000U);
#line 2087
  qla8044_idc_lock(ha);
#line 2089
  tmp___1 = qla8044_rd_direct(vha, 5U);
#line 2089
  drv_state = (uint32_t )tmp___1;
#line 2091
  tmp___2 = qla8044_rd_direct(vha, 3U);
#line 2091
  drv_active = (uint32_t )tmp___2;
#line 2093
  drv_active = drv_active << 1;
  ldv_43940: ;
#line 2072
  if (drv_state != drv_active) {
#line 2074
    goto ldv_43939;
  } else {

  }
#line 2097
  tmp___3 = qla8044_rd_direct(vha, 4U);
#line 2097
  dev_state = (uint32_t )tmp___3;
#line 2099
  if (dev_state == 5U) {
#line 2100
    qla8044_wr_direct(vha, 4U, 7U);
#line 2102
    ql_log(2U, vha, 45261, "%s: HW State: QUIESCENT\n", "qla8044_need_qsnt_handler");
  } else {

  }
#line 2105
  return;
}
}
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_device_state_handler(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  int rval ;
  unsigned long dev_init_timeout ;
  struct qla_hw_data *ha ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 2117
  rval = 0;
#line 2119
  ha = vha->hw;
#line 2121
  rval = qla8044_update_idc_reg(vha);
#line 2122
  if (rval == 258) {
#line 2123
    goto exit_error;
  } else {

  }
#line 2125
  tmp = qla8044_rd_direct(vha, 4U);
#line 2125
  dev_state = (uint32_t )tmp;
#line 2126
  if (dev_state <= 7U) {
#line 2126
    tmp___0 = qdev_state(dev_state);
#line 2126
    tmp___1 = tmp___0;
  } else {
#line 2126
    tmp___1 = (char *)"Unknown";
  }
#line 2126
  ql_dbg(524288U, vha, 45262, "Device state is 0x%x = %s\n", dev_state, tmp___1);
#line 2132
  dev_init_timeout = (unsigned long )(ha->fcoe_dev_init_timeout * 250U) + (unsigned long )jiffies;
#line 2134
  qla8044_idc_lock(ha);
  ldv_43967: ;
#line 2137
  if ((long )((unsigned long )jiffies - dev_init_timeout) >= 0L) {
#line 2138
    if (dev_state <= 7U) {
#line 2138
      tmp___2 = qdev_state(dev_state);
#line 2138
      tmp___3 = tmp___2;
    } else {
#line 2138
      tmp___3 = (char *)"Unknown";
    }
#line 2138
    ql_log(1U, vha, 45263, "%s: Device Init Failed 0x%x = %s\n", (char *)"qla2xxx",
           dev_state, tmp___3);
#line 2144
    qla8044_wr_direct(vha, 4U, 6U);
  } else {

  }
#line 2148
  tmp___4 = qla8044_rd_direct(vha, 4U);
#line 2148
  dev_state = (uint32_t )tmp___4;
#line 2149
  if (dev_state <= 7U) {
#line 2149
    tmp___5 = qdev_state(dev_state);
#line 2149
    tmp___6 = tmp___5;
  } else {
#line 2149
    tmp___6 = (char *)"Unknown";
  }
#line 2149
  ql_log(2U, vha, 45264, "Device state is 0x%x = %s\n", dev_state, tmp___6);
#line 2155
  switch (dev_state) {
  case 3U: 
#line 2157
  ha->flags.nic_core_reset_owner = 0U;
#line 2158
  goto exit;
  case 1U: 
#line 2160
  rval = qla8044_device_bootstrap(vha);
#line 2161
  goto exit;
  case 2U: 
#line 2163
  qla8044_idc_unlock(ha);
#line 2164
  msleep(1000U);
#line 2165
  qla8044_idc_lock(ha);
#line 2166
  goto ldv_43961;
  case 4U: 
#line 2171
  qla8044_need_reset_handler(vha);
#line 2172
  goto ldv_43961;
  case 5U: 
#line 2175
  qla8044_need_qsnt_handler(vha);
#line 2178
  dev_init_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 2180
  goto ldv_43961;
  case 7U: 
#line 2182
  ql_log(2U, vha, 45265, "HW State: QUIESCENT\n");
#line 2185
  qla8044_idc_unlock(ha);
#line 2186
  msleep(1000U);
#line 2187
  qla8044_idc_lock(ha);
#line 2190
  dev_init_timeout = (unsigned long )(ha->fcoe_reset_timeout * 250U) + (unsigned long )jiffies;
#line 2192
  goto ldv_43961;
  case 6U: 
#line 2194
  ha->flags.nic_core_reset_owner = 0U;
#line 2195
  qla8044_idc_unlock(ha);
#line 2196
  qla8xxx_dev_failed_handler(vha);
#line 2197
  rval = 258;
#line 2198
  qla8044_idc_lock(ha);
#line 2199
  goto exit;
  default: 
#line 2201
  qla8044_idc_unlock(ha);
#line 2202
  qla8xxx_dev_failed_handler(vha);
#line 2203
  rval = 258;
#line 2204
  qla8044_idc_lock(ha);
#line 2205
  goto exit;
  }
  ldv_43961: ;
#line 2207
  goto ldv_43967;
  exit: 
#line 2209
  qla8044_idc_unlock(ha);
  exit_error: ;
#line 2212
  return (rval);
}
}
#line 2222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_check_temp(struct scsi_qla_host *vha ) 
{ 
  uint32_t temp ;
  uint32_t temp_state ;
  uint32_t temp_val ;
  int status ;
  int tmp ;

  {
#line 2225
  status = 0;
#line 2227
  tmp = qla8044_rd_direct(vha, 13U);
#line 2227
  temp = (uint32_t )tmp;
#line 2228
  temp_state = temp & 65535U;
#line 2229
  temp_val = temp >> 16;
#line 2231
  if (temp_state == 3U) {
#line 2232
    ql_log(1U, vha, 45266, "Device temperature %d degrees C exceeds maximum allowed. Hardware has been shut down\n",
           temp_val);
#line 2236
    status = 258;
#line 2237
    return (status);
  } else
#line 2238
  if (temp_state == 2U) {
#line 2239
    ql_log(1U, vha, 45267, "Device temperature %d degrees C exceeds operating range. Immediate action needed.\n",
           temp_val);
  } else {

  }
#line 2244
  return (0);
}
}
#line 2247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_read_temperature(scsi_qla_host_t *vha ) 
{ 
  uint32_t temp ;
  int tmp ;

  {
#line 2251
  tmp = qla8044_rd_direct(vha, 13U);
#line 2251
  temp = (uint32_t )tmp;
#line 2252
  return ((int )(temp >> 16));
}
}
#line 2262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_check_fw_alive(struct scsi_qla_host *vha ) 
{ 
  uint32_t fw_heartbeat_counter ;
  uint32_t halt_status1 ;
  uint32_t halt_status2 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2266
  status = 0;
#line 2268
  tmp = qla8044_rd_direct(vha, 2U);
#line 2268
  fw_heartbeat_counter = (uint32_t )tmp;
#line 2272
  if (fw_heartbeat_counter == 4294967295U) {
#line 2273
    ql_dbg(524288U, vha, 45268, "scsi%ld: %s: Device in frozen state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",
           vha->host_no, "qla8044_check_fw_alive");
#line 2277
    return (status);
  } else {

  }
#line 2280
  if ((uint32_t )vha->fw_heartbeat_counter == fw_heartbeat_counter) {
#line 2281
    vha->seconds_since_last_heartbeat = vha->seconds_since_last_heartbeat + 1;
#line 2283
    if (vha->seconds_since_last_heartbeat == 2) {
#line 2284
      vha->seconds_since_last_heartbeat = 0;
#line 2285
      tmp___0 = qla8044_rd_direct(vha, 0U);
#line 2285
      halt_status1 = (uint32_t )tmp___0;
#line 2287
      tmp___1 = qla8044_rd_direct(vha, 1U);
#line 2287
      halt_status2 = (uint32_t )tmp___1;
#line 2290
      ql_log(2U, vha, 45269, "scsi(%ld): %s, ISP8044 Dumping hw/fw registers:\n PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\n",
             vha->host_no, "qla8044_check_fw_alive", halt_status1, halt_status2);
#line 2297
      status = 258;
    } else {

    }
  } else {
#line 2300
    vha->seconds_since_last_heartbeat = 0;
  }
#line 2302
  vha->fw_heartbeat_counter = (int )fw_heartbeat_counter;
#line 2303
  return (status);
}
}
#line 2307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_watchdog(struct scsi_qla_host *vha ) 
{ 
  uint32_t dev_state ;
  uint32_t halt_status ;
  int halt_status_unrecoverable ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2310
  halt_status_unrecoverable = 0;
#line 2311
  ha = vha->hw;
#line 2314
  tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2314
  if (tmp___5 == 0) {
#line 2314
    tmp___6 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2314
    if (tmp___6 == 0) {
#line 2314
      tmp___7 = constant_test_bit(10L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2314
      if (tmp___7 == 0) {
#line 2314
        tmp___8 = constant_test_bit(18L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2314
        if (tmp___8 == 0) {
#line 2318
          tmp = qla8044_rd_direct(vha, 4U);
#line 2318
          dev_state = (uint32_t )tmp;
#line 2320
          tmp___4 = qla8044_check_temp(vha);
#line 2320
          if (tmp___4 != 0) {
#line 2321
            set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2322
            ha->flags.isp82xx_fw_hung = 1U;
#line 2323
            qla2xxx_wake_dpc(vha);
          } else
#line 2324
          if (dev_state == 4U) {
#line 2324
            tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2324
            if (tmp___3 == 0) {
#line 2326
              ql_log(2U, vha, 45270, "%s: HW State: NEED RESET!\n", "qla8044_watchdog");
#line 2329
              set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2330
              qla2xxx_wake_dpc(vha);
            } else {
#line 2324
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 2331
          if (dev_state == 5U) {
#line 2331
            tmp___2 = constant_test_bit(20L, (unsigned long const volatile   *)(& vha->dpc_flags));
#line 2331
            if (tmp___2 == 0) {
#line 2333
              ql_log(2U, vha, 45271, "%s: HW State: NEED QUIES detected!\n", "qla8044_watchdog");
#line 2336
              set_bit(20L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2337
              qla2xxx_wake_dpc(vha);
            } else {
#line 2331
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 2340
            tmp___1 = qla8044_check_fw_alive(vha);
#line 2340
            if (tmp___1 != 0) {
#line 2341
              tmp___0 = qla8044_rd_direct(vha, 0U);
#line 2341
              halt_status = (uint32_t )tmp___0;
#line 2343
              if ((halt_status & 1073741824U) != 0U) {
#line 2345
                ql_log(0U, vha, 45272, "%s: Firmware error detected device is being reset\n",
                       "qla8044_watchdog");
              } else
#line 2350
              if ((int )halt_status < 0) {
#line 2352
                halt_status_unrecoverable = 1;
              } else {

              }
#line 2358
              if (halt_status_unrecoverable != 0) {
#line 2359
                set_bit(17L, (unsigned long volatile   *)(& vha->dpc_flags));
              } else
#line 2362
              if (dev_state == 7U) {
#line 2364
                set_bit(18L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2366
                ql_log(2U, vha, 45273, "%s: FW CONTEXT Reset needed!\n", "qla8044_watchdog");
              } else {
#line 2370
                ql_log(2U, vha, 45274, "%s: detect abort needed\n", "qla8044_watchdog");
#line 2374
                set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 2376
                qla82xx_clear_pending_mbx(vha);
              }
#line 2379
              ha->flags.isp82xx_fw_hung = 1U;
#line 2380
              ql_log(1U, vha, 45322, "Firmware hung.\n");
#line 2382
              qla2xxx_wake_dpc(vha);
            } else {

            }
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 2385
  return;
}
}
#line 2390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_minidump_process_control(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ) 
{ 
  struct qla8044_minidump_entry_crb *crb_entry ;
  uint32_t read_value ;
  uint32_t opcode ;
  uint32_t poll_time ;
  uint32_t addr ;
  uint32_t index ;
  uint32_t crb_addr ;
  uint32_t rval ;
  unsigned long wtime ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;
  int i ;
  struct qla_hw_data *ha ;

  {
#line 2395
  rval = 0U;
#line 2399
  ha = vha->hw;
#line 2401
  ql_dbg(524288U, vha, 45277, "Entering fn: %s\n", "qla8044_minidump_process_control");
#line 2402
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 2404
  crb_entry = (struct qla8044_minidump_entry_crb *)entry_hdr;
#line 2406
  crb_addr = crb_entry->addr;
#line 2407
  i = 0;
#line 2407
  goto ldv_44021;
  ldv_44020: 
#line 2408
  opcode = (uint32_t )crb_entry->crb_ctrl.opcode;
#line 2410
  if ((int )opcode & 1) {
#line 2411
    qla8044_wr_reg_indirect(vha, crb_addr, crb_entry->value_1);
#line 2413
    opcode = opcode & 4294967294U;
  } else {

  }
#line 2416
  if ((opcode & 2U) != 0U) {
#line 2417
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2418
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
#line 2419
    opcode = opcode & 4294967293U;
  } else {

  }
#line 2422
  if ((opcode & 4U) != 0U) {
#line 2423
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2424
    read_value = crb_entry->value_2 & read_value;
#line 2425
    opcode = opcode & 4294967291U;
#line 2426
    if ((opcode & 8U) != 0U) {
#line 2427
      read_value = crb_entry->value_3 | read_value;
#line 2428
      opcode = opcode & 4294967287U;
    } else {

    }
#line 2430
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
  } else {

  }
#line 2432
  if ((opcode & 8U) != 0U) {
#line 2433
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
#line 2434
    read_value = crb_entry->value_3 | read_value;
#line 2435
    qla8044_wr_reg_indirect(vha, crb_addr, read_value);
#line 2436
    opcode = opcode & 4294967287U;
  } else {

  }
#line 2438
  if ((opcode & 16U) != 0U) {
#line 2439
    poll_time = (uint32_t )crb_entry->crb_strd.poll_timeout;
#line 2440
    wtime = (unsigned long )poll_time + (unsigned long )jiffies;
#line 2441
    qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
    ldv_44019: ;
#line 2444
    if ((crb_entry->value_2 & read_value) == crb_entry->value_1) {
#line 2446
      goto ldv_44012;
    } else
#line 2447
    if ((long )((unsigned long )jiffies - wtime) >= 0L) {
#line 2449
      rval = 258U;
#line 2450
      goto ldv_44012;
    } else {
#line 2452
      qla8044_rd_reg_indirect(vha, crb_addr, & read_value);
    }
#line 2455
    goto ldv_44019;
    ldv_44012: 
#line 2456
    opcode = opcode & 4294967279U;
  } else {

  }
#line 2459
  if ((opcode & 32U) != 0U) {
#line 2460
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 2461
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 2462
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 2464
      addr = crb_addr;
    }
#line 2467
    qla8044_rd_reg_indirect(vha, addr, & read_value);
#line 2468
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2469
    tmplt_hdr->saved_state_array[index] = read_value;
#line 2470
    opcode = opcode & 4294967263U;
  } else {

  }
#line 2473
  if ((opcode & 64U) != 0U) {
#line 2474
    if ((unsigned int )crb_entry->crb_strd.state_index_a != 0U) {
#line 2475
      index = (uint32_t )crb_entry->crb_strd.state_index_a;
#line 2476
      addr = tmplt_hdr->saved_state_array[index];
    } else {
#line 2478
      addr = crb_addr;
    }
#line 2481
    if ((unsigned int )crb_entry->crb_ctrl.state_index_v != 0U) {
#line 2482
      index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2483
      read_value = tmplt_hdr->saved_state_array[index];
    } else {
#line 2486
      read_value = crb_entry->value_1;
    }
#line 2489
    qla8044_wr_reg_indirect(vha, addr, read_value);
#line 2490
    opcode = opcode & 4294967231U;
  } else {

  }
#line 2493
  if ((opcode & 128U) != 0U) {
#line 2494
    index = (uint32_t )crb_entry->crb_ctrl.state_index_v;
#line 2495
    read_value = tmplt_hdr->saved_state_array[index];
#line 2496
    read_value = read_value << (int )crb_entry->crb_ctrl.shl;
#line 2497
    read_value = read_value >> (int )crb_entry->crb_ctrl.shr;
#line 2498
    if (crb_entry->value_2 != 0U) {
#line 2499
      read_value = crb_entry->value_2 & read_value;
    } else {

    }
#line 2500
    read_value = crb_entry->value_3 | read_value;
#line 2501
    read_value = crb_entry->value_1 + read_value;
#line 2502
    tmplt_hdr->saved_state_array[index] = read_value;
#line 2503
    opcode = opcode & 4294967167U;
  } else {

  }
#line 2505
  crb_addr = (uint32_t )crb_entry->crb_strd.addr_stride + crb_addr;
#line 2407
  i = i + 1;
  ldv_44021: ;
#line 2407
  if ((uint32_t )i < crb_entry->op_count) {
#line 2409
    goto ldv_44020;
  } else {

  }

#line 2507
  return ((int )rval);
}
}
#line 2511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_rdcrb(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_crb *crb_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2516
  data_ptr = *d_ptr;
#line 2518
  ql_dbg(524288U, vha, 45278, "Entering fn: %s\n", "qla8044_minidump_process_rdcrb");
#line 2519
  crb_hdr = (struct qla8044_minidump_entry_crb *)entry_hdr;
#line 2520
  r_addr = crb_hdr->addr;
#line 2521
  r_stride = (uint32_t )crb_hdr->crb_strd.addr_stride;
#line 2522
  loop_cnt = crb_hdr->op_count;
#line 2524
  i = 0U;
#line 2524
  goto ldv_44037;
  ldv_44036: 
#line 2525
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2526
  tmp = data_ptr;
#line 2526
  data_ptr = data_ptr + 1;
#line 2526
  *tmp = r_addr;
#line 2527
  tmp___0 = data_ptr;
#line 2527
  data_ptr = data_ptr + 1;
#line 2527
  *tmp___0 = r_value;
#line 2528
  r_addr = r_addr + r_stride;
#line 2524
  i = i + 1U;
  ldv_44037: ;
#line 2524
  if (i < loop_cnt) {
#line 2526
    goto ldv_44036;
  } else {

  }
#line 2530
  *d_ptr = data_ptr;
#line 2531
  return;
}
}
#line 2534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_minidump_process_rdmem(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_value ;
  uint32_t r_data ;
  uint32_t i ;
  uint32_t j ;
  uint32_t loop_cnt ;
  struct qla8044_minidump_entry_rdmem *m_hdr ;
  uint32_t *data_ptr ;
  struct qla_hw_data *ha ;
  struct ratelimit_state _rs ;
  int tmp ;
  uint32_t *tmp___0 ;

  {
#line 2541
  data_ptr = *d_ptr;
#line 2542
  ha = vha->hw;
#line 2544
  ql_dbg(524288U, vha, 45279, "Entering fn: %s\n", "qla8044_minidump_process_rdmem");
#line 2545
  m_hdr = (struct qla8044_minidump_entry_rdmem *)entry_hdr;
#line 2546
  r_addr = m_hdr->read_addr;
#line 2547
  loop_cnt = m_hdr->read_data_size / 16U;
#line 2549
  ql_dbg(524288U, vha, 45296, "[%s]: Read addr: 0x%x, read_data_size: 0x%x\n", "qla8044_minidump_process_rdmem",
         r_addr, m_hdr->read_data_size);
#line 2553
  if ((r_addr & 15U) != 0U) {
#line 2554
    ql_dbg(524288U, vha, 45297, "[%s]: Read addr 0x%x not 16 bytes alligned\n", "qla8044_minidump_process_rdmem",
           r_addr);
#line 2557
    return (258);
  } else {

  }
#line 2560
  if ((m_hdr->read_data_size & 15U) != 0U) {
#line 2561
    ql_dbg(524288U, vha, 45298, "[%s]: Read data[0x%x] not multiple of 16 bytes\n",
           "qla8044_minidump_process_rdmem", m_hdr->read_data_size);
#line 2564
    return (258);
  } else {

  }
#line 2567
  ql_dbg(524288U, vha, 45299, "[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",
         "qla8044_minidump_process_rdmem", r_addr, m_hdr->read_data_size, loop_cnt);
#line 2571
  ldv_write_lock_irqsave(& ha->hw_lock);
#line 2572
  i = 0U;
#line 2572
  goto ldv_44064;
  ldv_44063: 
#line 2573
  qla8044_wr_reg_indirect(vha, 1090519188U, r_addr);
#line 2574
  r_value = 0U;
#line 2575
  qla8044_wr_reg_indirect(vha, 1090519192U, r_value);
#line 2576
  r_value = 2U;
#line 2577
  qla8044_wr_reg_indirect(vha, 1090519184U, r_value);
#line 2578
  r_value = 3U;
#line 2579
  qla8044_wr_reg_indirect(vha, 1090519184U, r_value);
#line 2581
  j = 0U;
#line 2581
  goto ldv_44057;
  ldv_44056: 
#line 2582
  qla8044_rd_reg_indirect(vha, 1090519184U, & r_value);
#line 2584
  if ((r_value & 8U) == 0U) {
#line 2585
    goto ldv_44055;
  } else {

  }
#line 2581
  j = j + 1U;
  ldv_44057: ;
#line 2581
  if (j <= 999U) {
#line 2583
    goto ldv_44056;
  } else {

  }
  ldv_44055: ;
#line 2588
  if (j > 999U) {
#line 2589
    _rs.lock.raw_lock.ldv_1464.head_tail = 0U;
#line 2589
    _rs.lock.magic = 3735899821U;
#line 2589
    _rs.lock.owner_cpu = 4294967295U;
#line 2589
    _rs.lock.owner = (void *)-1;
#line 2589
    _rs.lock.dep_map.key = 0;
#line 2589
    _rs.lock.dep_map.class_cache[0] = 0;
#line 2589
    _rs.lock.dep_map.class_cache[1] = 0;
#line 2589
    _rs.lock.dep_map.name = "_rs.lock";
#line 2589
    _rs.lock.dep_map.cpu = 0;
#line 2589
    _rs.lock.dep_map.ip = 0UL;
#line 2589
    _rs.interval = 1250;
#line 2589
    _rs.burst = 10;
#line 2589
    _rs.printed = 0;
#line 2589
    _rs.missed = 0;
#line 2589
    _rs.begin = 0UL;
#line 2589
    tmp = ___ratelimit(& _rs, "qla8044_minidump_process_rdmem");
#line 2589
    if (tmp != 0) {
#line 2589
      printk("\v%s: failed to read through agent\n", "qla8044_minidump_process_rdmem");
    } else {

    }
#line 2591
    ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 2592
    return (0);
  } else {

  }
#line 2595
  j = 0U;
#line 2595
  goto ldv_44061;
  ldv_44060: 
#line 2596
  qla8044_rd_reg_indirect(vha, (uint32_t )MD_MIU_TEST_AGT_RDDATA___0[j], & r_data);
#line 2598
  tmp___0 = data_ptr;
#line 2598
  data_ptr = data_ptr + 1;
#line 2598
  *tmp___0 = r_data;
#line 2595
  j = j + 1U;
  ldv_44061: ;
#line 2595
  if (j <= 3U) {
#line 2597
    goto ldv_44060;
  } else {

  }
#line 2601
  r_addr = r_addr + 16U;
#line 2572
  i = i + 1U;
  ldv_44064: ;
#line 2572
  if (i < loop_cnt) {
#line 2574
    goto ldv_44063;
  } else {

  }
#line 2603
  ldv_write_unlock_irqrestore(& ha->hw_lock);
#line 2605
  ql_dbg(524288U, vha, 45300, "Leaving fn: %s datacount: 0x%x\n", "qla8044_minidump_process_rdmem",
         loop_cnt * 16U);
#line 2609
  *d_ptr = data_ptr;
#line 2610
  return (0);
}
}
#line 2615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static uint32_t qla8044_minidump_process_rdrom(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                               uint32_t **d_ptr ) 
{ 
  uint32_t fl_addr ;
  uint32_t u32_count ;
  uint32_t rval ;
  struct qla8044_minidump_entry_rdrom *rom_hdr ;
  uint32_t *data_ptr ;
  int tmp ;

  {
#line 2620
  data_ptr = *d_ptr;
#line 2622
  rom_hdr = (struct qla8044_minidump_entry_rdrom *)entry_hdr;
#line 2623
  fl_addr = rom_hdr->read_addr;
#line 2624
  u32_count = rom_hdr->read_data_size / 4U;
#line 2626
  ql_dbg(524288U, vha, 45301, "[%s]: fl_addr: 0x%x, count: 0x%x\n", "qla8044_minidump_process_rdrom",
         fl_addr, u32_count);
#line 2629
  tmp = qla8044_lockless_flash_read_u32(vha, fl_addr, (uint8_t *)data_ptr, (int )u32_count);
#line 2629
  rval = (uint32_t )tmp;
#line 2632
  if (rval != 0U) {
#line 2633
    ql_log(0U, vha, 45302, "%s: Flash Read Error,Count=%d\n", "qla8044_minidump_process_rdrom",
           u32_count);
#line 2635
    return (258U);
  } else {
#line 2637
    data_ptr = data_ptr + (unsigned long )u32_count;
#line 2638
    *d_ptr = data_ptr;
#line 2639
    return (0U);
  }
}
}
#line 2644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_mark_entry_skipped(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                       int index ) 
{ 


  {
#line 2647
  entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 2649
  ql_log(2U, vha, 45303, "scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",
         vha->host_no, index, entry_hdr->entry_type, (int )entry_hdr->d_ctrl.entry_capture_mask);
#line 2653
  return;
}
}
#line 2656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_minidump_process_l2tag(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                          uint32_t **d_ptr ) 
{ 
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  unsigned long p_wait ;
  unsigned long w_time ;
  unsigned long p_mask ;
  uint32_t c_value_w ;
  uint32_t c_value_r ;
  struct qla8044_minidump_entry_cache *cache_hdr ;
  int rval ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2665
  rval = 258;
#line 2666
  data_ptr = *d_ptr;
#line 2668
  ql_dbg(524288U, vha, 45304, "Entering fn: %s\n", "qla8044_minidump_process_l2tag");
#line 2669
  cache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;
#line 2671
  loop_count = cache_hdr->op_count;
#line 2672
  r_addr = cache_hdr->read_addr;
#line 2673
  c_addr = cache_hdr->control_addr;
#line 2674
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 2676
  t_r_addr = cache_hdr->tag_reg_addr;
#line 2677
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 2678
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 2679
  p_wait = (unsigned long )cache_hdr->cache_ctrl.poll_wait;
#line 2680
  p_mask = (unsigned long )cache_hdr->cache_ctrl.poll_mask;
#line 2682
  i = 0U;
#line 2682
  goto ldv_44118;
  ldv_44117: 
#line 2683
  qla8044_wr_reg_indirect(vha, t_r_addr, t_value);
#line 2684
  if (c_value_w != 0U) {
#line 2685
    qla8044_wr_reg_indirect(vha, c_addr, c_value_w);
  } else {

  }
#line 2687
  if (p_mask != 0UL) {
#line 2688
    w_time = (unsigned long )jiffies + p_wait;
    ldv_44113: 
#line 2690
    qla8044_rd_reg_indirect(vha, c_addr, & c_value_r);
#line 2692
    if (((unsigned long )c_value_r & p_mask) == 0UL) {
#line 2693
      goto ldv_44106;
    } else
#line 2694
    if ((long )((unsigned long )jiffies - w_time) >= 0L) {
#line 2696
      return (rval);
    } else {

    }
#line 2698
    goto ldv_44113;
    ldv_44106: ;
  } else {

  }
#line 2701
  addr = r_addr;
#line 2702
  k = 0U;
#line 2702
  goto ldv_44115;
  ldv_44114: 
#line 2703
  qla8044_rd_reg_indirect(vha, addr, & r_value);
#line 2704
  tmp = data_ptr;
#line 2704
  data_ptr = data_ptr + 1;
#line 2704
  *tmp = r_value;
#line 2705
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 2702
  k = k + 1U;
  ldv_44115: ;
#line 2702
  if (k < r_cnt) {
#line 2704
    goto ldv_44114;
  } else {

  }
#line 2707
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 2682
  i = i + 1U;
  ldv_44118: ;
#line 2682
  if (i < loop_count) {
#line 2684
    goto ldv_44117;
  } else {

  }
#line 2709
  *d_ptr = data_ptr;
#line 2710
  return (0);
}
}
#line 2714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_l1cache(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                             uint32_t **d_ptr ) 
{ 
  uint32_t addr ;
  uint32_t r_addr ;
  uint32_t c_addr ;
  uint32_t t_r_addr ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_count ;
  uint32_t t_value ;
  uint32_t r_cnt ;
  uint32_t r_value ;
  uint32_t c_value_w ;
  struct qla8044_minidump_entry_cache *cache_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2721
  data_ptr = *d_ptr;
#line 2723
  cache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;
#line 2724
  loop_count = cache_hdr->op_count;
#line 2725
  r_addr = cache_hdr->read_addr;
#line 2726
  c_addr = cache_hdr->control_addr;
#line 2727
  c_value_w = (uint32_t )cache_hdr->cache_ctrl.write_value;
#line 2729
  t_r_addr = cache_hdr->tag_reg_addr;
#line 2730
  t_value = (uint32_t )cache_hdr->addr_ctrl.init_tag_value;
#line 2731
  r_cnt = (uint32_t )cache_hdr->read_ctrl.read_addr_cnt;
#line 2733
  i = 0U;
#line 2733
  goto ldv_44142;
  ldv_44141: 
#line 2734
  qla8044_wr_reg_indirect(vha, t_r_addr, t_value);
#line 2735
  qla8044_wr_reg_indirect(vha, c_addr, c_value_w);
#line 2736
  addr = r_addr;
#line 2737
  k = 0U;
#line 2737
  goto ldv_44139;
  ldv_44138: 
#line 2738
  qla8044_rd_reg_indirect(vha, addr, & r_value);
#line 2739
  tmp = data_ptr;
#line 2739
  data_ptr = data_ptr + 1;
#line 2739
  *tmp = r_value;
#line 2740
  addr = (uint32_t )cache_hdr->read_ctrl.read_addr_stride + addr;
#line 2737
  k = k + 1U;
  ldv_44139: ;
#line 2737
  if (k < r_cnt) {
#line 2739
    goto ldv_44138;
  } else {

  }
#line 2742
  t_value = (uint32_t )cache_hdr->addr_ctrl.tag_value_stride + t_value;
#line 2733
  i = i + 1U;
  ldv_44142: ;
#line 2733
  if (i < loop_count) {
#line 2735
    goto ldv_44141;
  } else {

  }
#line 2744
  *d_ptr = data_ptr;
#line 2745
  return;
}
}
#line 2748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_rdocm(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_rdocm *ocm_hdr ;
  uint32_t *data_ptr ;
  struct qla_hw_data *ha ;
  uint32_t *tmp ;

  {
#line 2753
  data_ptr = *d_ptr;
#line 2754
  ha = vha->hw;
#line 2756
  ql_dbg(524288U, vha, 45305, "Entering fn: %s\n", "qla8044_minidump_process_rdocm");
#line 2758
  ocm_hdr = (struct qla8044_minidump_entry_rdocm *)entry_hdr;
#line 2759
  r_addr = ocm_hdr->read_addr;
#line 2760
  r_stride = ocm_hdr->read_addr_stride;
#line 2761
  loop_cnt = ocm_hdr->op_count;
#line 2763
  ql_dbg(524288U, vha, 45306, "[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\n",
         "qla8044_minidump_process_rdocm", r_addr, r_stride, loop_cnt);
#line 2767
  i = 0U;
#line 2767
  goto ldv_44159;
  ldv_44158: 
#line 2768
  r_value = readl((void const volatile   *)((unsigned long )r_addr + ha->nx_pcibase));
#line 2769
  tmp = data_ptr;
#line 2769
  data_ptr = data_ptr + 1;
#line 2769
  *tmp = r_value;
#line 2770
  r_addr = r_addr + r_stride;
#line 2767
  i = i + 1U;
  ldv_44159: ;
#line 2767
  if (i < loop_cnt) {
#line 2769
    goto ldv_44158;
  } else {

  }
#line 2772
  ql_dbg(524288U, vha, 45307, "Leaving fn: %s datacount: 0x%lx\n", "qla8044_minidump_process_rdocm",
         (unsigned long )loop_cnt * 4UL);
#line 2775
  *d_ptr = data_ptr;
#line 2776
  return;
}
}
#line 2779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_rdmux(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t s_stride ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t loop_cnt ;
  uint32_t i ;
  uint32_t r_value ;
  struct qla8044_minidump_entry_mux *mux_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2785
  data_ptr = *d_ptr;
#line 2787
  ql_dbg(524288U, vha, 45308, "Entering fn: %s\n", "qla8044_minidump_process_rdmux");
#line 2789
  mux_hdr = (struct qla8044_minidump_entry_mux *)entry_hdr;
#line 2790
  r_addr = mux_hdr->read_addr;
#line 2791
  s_addr = mux_hdr->select_addr;
#line 2792
  s_stride = mux_hdr->select_value_stride;
#line 2793
  s_value = mux_hdr->select_value;
#line 2794
  loop_cnt = mux_hdr->op_count;
#line 2796
  i = 0U;
#line 2796
  goto ldv_44177;
  ldv_44176: 
#line 2797
  qla8044_wr_reg_indirect(vha, s_addr, s_value);
#line 2798
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2799
  tmp = data_ptr;
#line 2799
  data_ptr = data_ptr + 1;
#line 2799
  *tmp = s_value;
#line 2800
  tmp___0 = data_ptr;
#line 2800
  data_ptr = data_ptr + 1;
#line 2800
  *tmp___0 = r_value;
#line 2801
  s_value = s_value + s_stride;
#line 2796
  i = i + 1U;
  ldv_44177: ;
#line 2796
  if (i < loop_cnt) {
#line 2798
    goto ldv_44176;
  } else {

  }
#line 2803
  *d_ptr = data_ptr;
#line 2804
  return;
}
}
#line 2807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_queue(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                           uint32_t **d_ptr ) 
{ 
  uint32_t s_addr ;
  uint32_t r_addr ;
  uint32_t r_stride ;
  uint32_t r_value ;
  uint32_t r_cnt ;
  uint32_t qid ;
  uint32_t i ;
  uint32_t k ;
  uint32_t loop_cnt ;
  struct qla8044_minidump_entry_queue *q_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;

  {
#line 2812
  qid = 0U;
#line 2815
  data_ptr = *d_ptr;
#line 2817
  ql_dbg(524288U, vha, 45309, "Entering fn: %s\n", "qla8044_minidump_process_queue");
#line 2818
  q_hdr = (struct qla8044_minidump_entry_queue *)entry_hdr;
#line 2819
  s_addr = q_hdr->select_addr;
#line 2820
  r_cnt = (uint32_t )q_hdr->rd_strd.read_addr_cnt;
#line 2821
  r_stride = (uint32_t )q_hdr->rd_strd.read_addr_stride;
#line 2822
  loop_cnt = q_hdr->op_count;
#line 2824
  i = 0U;
#line 2824
  goto ldv_44200;
  ldv_44199: 
#line 2825
  qla8044_wr_reg_indirect(vha, s_addr, qid);
#line 2826
  r_addr = q_hdr->read_addr;
#line 2827
  k = 0U;
#line 2827
  goto ldv_44197;
  ldv_44196: 
#line 2828
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2829
  tmp = data_ptr;
#line 2829
  data_ptr = data_ptr + 1;
#line 2829
  *tmp = r_value;
#line 2830
  r_addr = r_addr + r_stride;
#line 2827
  k = k + 1U;
  ldv_44197: ;
#line 2827
  if (k < r_cnt) {
#line 2829
    goto ldv_44196;
  } else {

  }
#line 2832
  qid = (uint32_t )q_hdr->q_strd.queue_id_stride + qid;
#line 2824
  i = i + 1U;
  ldv_44200: ;
#line 2824
  if (i < loop_cnt) {
#line 2826
    goto ldv_44199;
  } else {

  }
#line 2834
  *d_ptr = data_ptr;
#line 2835
  return;
}
}
#line 2839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static uint32_t qla8044_minidump_process_pollrd(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                uint32_t **d_ptr ) 
{ 
  uint32_t r_addr ;
  uint32_t s_addr ;
  uint32_t s_value ;
  uint32_t r_value ;
  uint32_t poll_wait ;
  uint32_t poll_mask ;
  uint16_t s_stride ;
  uint16_t i ;
  struct qla8044_minidump_entry_pollrd *pollrd_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2846
  data_ptr = *d_ptr;
#line 2848
  pollrd_hdr = (struct qla8044_minidump_entry_pollrd *)entry_hdr;
#line 2849
  s_addr = pollrd_hdr->select_addr;
#line 2850
  r_addr = pollrd_hdr->read_addr;
#line 2851
  s_value = pollrd_hdr->select_value;
#line 2852
  s_stride = pollrd_hdr->select_value_stride;
#line 2854
  poll_wait = pollrd_hdr->poll_wait;
#line 2855
  poll_mask = pollrd_hdr->poll_mask;
#line 2857
  i = 0U;
#line 2857
  goto ldv_44222;
  ldv_44221: 
#line 2858
  qla8044_wr_reg_indirect(vha, s_addr, s_value);
#line 2859
  poll_wait = pollrd_hdr->poll_wait;
  ldv_44220: 
#line 2861
  qla8044_rd_reg_indirect(vha, s_addr, & r_value);
#line 2862
  if ((r_value & poll_mask) != 0U) {
#line 2863
    goto ldv_44217;
  } else {
#line 2865
    usleep_range(1000UL, 1100UL);
#line 2866
    poll_wait = poll_wait - 1U;
#line 2866
    if (poll_wait == 0U) {
#line 2867
      ql_log(0U, vha, 45310, "%s: TIMEOUT\n", "qla8044_minidump_process_pollrd");
#line 2869
      goto error;
    } else {

    }
  }
#line 2872
  goto ldv_44220;
  ldv_44217: 
#line 2873
  qla8044_rd_reg_indirect(vha, r_addr, & r_value);
#line 2874
  tmp = data_ptr;
#line 2874
  data_ptr = data_ptr + 1;
#line 2874
  *tmp = s_value;
#line 2875
  tmp___0 = data_ptr;
#line 2875
  data_ptr = data_ptr + 1;
#line 2875
  *tmp___0 = r_value;
#line 2877
  s_value = (uint32_t )s_stride + s_value;
#line 2857
  i = (uint16_t )((int )i + 1);
  ldv_44222: ;
#line 2857
  if ((int )pollrd_hdr->op_count > (int )i) {
#line 2859
    goto ldv_44221;
  } else {

  }
#line 2879
  *d_ptr = data_ptr;
#line 2880
  return (0U);
  error: ;
#line 2883
  return (258U);
}
}
#line 2887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_minidump_process_rdmux2(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                            uint32_t **d_ptr ) 
{ 
  uint32_t sel_val1 ;
  uint32_t sel_val2 ;
  uint32_t t_sel_val ;
  uint32_t data ;
  uint32_t i ;
  uint32_t sel_addr1 ;
  uint32_t sel_addr2 ;
  uint32_t sel_val_mask ;
  uint32_t read_addr ;
  struct qla8044_minidump_entry_rdmux2 *rdmux2_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 2893
  data_ptr = *d_ptr;
#line 2895
  rdmux2_hdr = (struct qla8044_minidump_entry_rdmux2 *)entry_hdr;
#line 2896
  sel_val1 = rdmux2_hdr->select_value_1;
#line 2897
  sel_val2 = rdmux2_hdr->select_value_2;
#line 2898
  sel_addr1 = rdmux2_hdr->select_addr_1;
#line 2899
  sel_addr2 = rdmux2_hdr->select_addr_2;
#line 2900
  sel_val_mask = rdmux2_hdr->select_value_mask;
#line 2901
  read_addr = rdmux2_hdr->read_addr;
#line 2903
  i = 0U;
#line 2903
  goto ldv_44241;
  ldv_44240: 
#line 2904
  qla8044_wr_reg_indirect(vha, sel_addr1, sel_val1);
#line 2905
  t_sel_val = sel_val1 & sel_val_mask;
#line 2906
  tmp = data_ptr;
#line 2906
  data_ptr = data_ptr + 1;
#line 2906
  *tmp = t_sel_val;
#line 2908
  qla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);
#line 2909
  qla8044_rd_reg_indirect(vha, read_addr, & data);
#line 2911
  tmp___0 = data_ptr;
#line 2911
  data_ptr = data_ptr + 1;
#line 2911
  *tmp___0 = data;
#line 2913
  qla8044_wr_reg_indirect(vha, sel_addr1, sel_val2);
#line 2914
  t_sel_val = sel_val2 & sel_val_mask;
#line 2915
  tmp___1 = data_ptr;
#line 2915
  data_ptr = data_ptr + 1;
#line 2915
  *tmp___1 = t_sel_val;
#line 2917
  qla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);
#line 2918
  qla8044_rd_reg_indirect(vha, read_addr, & data);
#line 2920
  tmp___2 = data_ptr;
#line 2920
  data_ptr = data_ptr + 1;
#line 2920
  *tmp___2 = data;
#line 2922
  sel_val1 = (uint32_t )rdmux2_hdr->select_value_stride + sel_val1;
#line 2923
  sel_val2 = (uint32_t )rdmux2_hdr->select_value_stride + sel_val2;
#line 2903
  i = i + 1U;
  ldv_44241: ;
#line 2903
  if (rdmux2_hdr->op_count > i) {
#line 2905
    goto ldv_44240;
  } else {

  }
#line 2926
  *d_ptr = data_ptr;
#line 2927
  return;
}
}
#line 2930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static uint32_t qla8044_minidump_process_pollrdmwr(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                                   uint32_t **d_ptr ) 
{ 
  uint32_t poll_wait ;
  uint32_t poll_mask ;
  uint32_t r_value ;
  uint32_t data ;
  uint32_t addr_1 ;
  uint32_t addr_2 ;
  uint32_t value_1 ;
  uint32_t value_2 ;
  struct qla8044_minidump_entry_pollrdmwr *poll_hdr ;
  uint32_t *data_ptr ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 2937
  data_ptr = *d_ptr;
#line 2939
  poll_hdr = (struct qla8044_minidump_entry_pollrdmwr *)entry_hdr;
#line 2940
  addr_1 = poll_hdr->addr_1;
#line 2941
  addr_2 = poll_hdr->addr_2;
#line 2942
  value_1 = poll_hdr->value_1;
#line 2943
  value_2 = poll_hdr->value_2;
#line 2944
  poll_mask = poll_hdr->poll_mask;
#line 2946
  qla8044_wr_reg_indirect(vha, addr_1, value_1);
#line 2948
  poll_wait = poll_hdr->poll_wait;
  ldv_44261: 
#line 2950
  qla8044_rd_reg_indirect(vha, addr_1, & r_value);
#line 2952
  if ((r_value & poll_mask) != 0U) {
#line 2953
    goto ldv_44258;
  } else {
#line 2955
    usleep_range(1000UL, 1100UL);
#line 2956
    poll_wait = poll_wait - 1U;
#line 2956
    if (poll_wait == 0U) {
#line 2957
      ql_log(0U, vha, 45311, "%s: TIMEOUT\n", "qla8044_minidump_process_pollrdmwr");
#line 2959
      goto error;
    } else {

    }
  }
#line 2962
  goto ldv_44261;
  ldv_44258: 
#line 2964
  qla8044_rd_reg_indirect(vha, addr_2, & data);
#line 2965
  data = poll_hdr->modify_mask & data;
#line 2966
  qla8044_wr_reg_indirect(vha, addr_2, data);
#line 2967
  qla8044_wr_reg_indirect(vha, addr_1, value_2);
#line 2969
  poll_wait = poll_hdr->poll_wait;
  ldv_44263: 
#line 2971
  qla8044_rd_reg_indirect(vha, addr_1, & r_value);
#line 2973
  if ((r_value & poll_mask) != 0U) {
#line 2974
    goto ldv_44262;
  } else {
#line 2976
    usleep_range(1000UL, 1100UL);
#line 2977
    poll_wait = poll_wait - 1U;
#line 2977
    if (poll_wait == 0U) {
#line 2978
      ql_log(0U, vha, 45312, "%s: TIMEOUT2\n", "qla8044_minidump_process_pollrdmwr");
#line 2980
      goto error;
    } else {

    }
  }
#line 2983
  goto ldv_44263;
  ldv_44262: 
#line 2985
  tmp = data_ptr;
#line 2985
  data_ptr = data_ptr + 1;
#line 2985
  *tmp = addr_2;
#line 2986
  tmp___0 = data_ptr;
#line 2986
  data_ptr = data_ptr + 1;
#line 2986
  *tmp___0 = data;
#line 2988
  *d_ptr = data_ptr;
#line 2990
  return (0U);
  error: ;
#line 2993
  return (258U);
}
}
#line 3007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_check_dma_engine_state(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  uint32_t dma_eng_num ;
  uint32_t cmd_sts_and_cntrl ;
  uint64_t dma_base_addr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;

  {
#line 3009
  ha = vha->hw;
#line 3010
  rval = 0;
#line 3011
  dma_eng_num = 0U;
#line 3011
  cmd_sts_and_cntrl = 0U;
#line 3012
  dma_base_addr = 0ULL;
#line 3013
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)0;
#line 3015
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 3016
  dma_eng_num = tmplt_hdr->saved_state_array[8];
#line 3018
  dma_base_addr = (uint64_t )((dma_eng_num + 30514U) * 65536U);
#line 3022
  rval = qla8044_rd_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, & cmd_sts_and_cntrl);
#line 3025
  if (rval != 0) {
#line 3026
    return (258);
  } else {

  }
#line 3029
  if ((int )cmd_sts_and_cntrl < 0) {
#line 3030
    return (0);
  } else {

  }
#line 3032
  return (258);
}
}
#line 3036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_start_pex_dma(struct scsi_qla_host *vha , struct qla8044_minidump_entry_rdmem_pex_dma *m_hdr ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  int wait ;
  uint32_t dma_eng_num ;
  uint32_t cmd_sts_and_cntrl ;
  uint64_t dma_base_addr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;

  {
#line 3039
  ha = vha->hw;
#line 3040
  rval = 0;
#line 3040
  wait = 0;
#line 3041
  dma_eng_num = 0U;
#line 3041
  cmd_sts_and_cntrl = 0U;
#line 3042
  dma_base_addr = 0ULL;
#line 3043
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)0;
#line 3045
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 3046
  dma_eng_num = tmplt_hdr->saved_state_array[8];
#line 3048
  dma_base_addr = (uint64_t )((dma_eng_num + 30514U) * 65536U);
#line 3051
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr, m_hdr->desc_card_addr);
#line 3054
  if (rval != 0) {
#line 3055
    goto error_exit;
  } else {

  }
#line 3057
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr + 4U, 0U);
#line 3059
  if (rval != 0) {
#line 3060
    goto error_exit;
  } else {

  }
#line 3062
  rval = qla8044_wr_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, m_hdr->start_dma_cmd);
#line 3065
  if (rval != 0) {
#line 3066
    goto error_exit;
  } else {

  }
#line 3069
  wait = 0;
#line 3069
  goto ldv_44287;
  ldv_44286: 
#line 3070
  rval = qla8044_rd_reg_indirect(vha, (uint32_t )dma_base_addr + 8U, & cmd_sts_and_cntrl);
#line 3073
  if (rval != 0) {
#line 3074
    goto error_exit;
  } else {

  }
#line 3076
  if ((cmd_sts_and_cntrl & 2U) == 0U) {
#line 3077
    goto ldv_44285;
  } else {

  }
#line 3079
  __const_udelay(42950UL);
#line 3069
  wait = wait + 1;
  ldv_44287: ;
#line 3069
  if (wait <= 9999) {
#line 3071
    goto ldv_44286;
  } else {

  }
  ldv_44285: ;
#line 3083
  if (wait > 9999) {
#line 3084
    rval = 258;
#line 3085
    goto error_exit;
  } else {

  }
  error_exit: ;
#line 3089
  return (rval);
}
}
#line 3093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_minidump_pex_dma_read(struct scsi_qla_host *vha , struct qla8044_minidump_entry_hdr *entry_hdr ,
                                         uint32_t **d_ptr ) 
{ 
  struct qla_hw_data *ha ;
  int rval ;
  struct qla8044_minidump_entry_rdmem_pex_dma *m_hdr ;
  uint32_t chunk_size ;
  uint32_t read_size ;
  uint8_t *data_ptr ;
  void *rdmem_buffer ;
  dma_addr_t rdmem_dma ;
  struct qla8044_pex_dma_descriptor dma_desc ;
  size_t __len ;
  void *__ret ;

  {
#line 3096
  ha = vha->hw;
#line 3097
  rval = 0;
#line 3098
  m_hdr = (struct qla8044_minidump_entry_rdmem_pex_dma *)0;
#line 3100
  data_ptr = (uint8_t *)*d_ptr;
#line 3101
  rdmem_buffer = (void *)0;
#line 3105
  rval = qla8044_check_dma_engine_state(vha);
#line 3106
  if (rval != 0) {
#line 3107
    ql_dbg(524288U, vha, 45383, "DMA engine not available. Fallback to rdmem-read.\n");
#line 3109
    return (258);
  } else {

  }
#line 3112
  m_hdr = (struct qla8044_minidump_entry_rdmem_pex_dma *)entry_hdr;
#line 3114
  rdmem_buffer = dma_alloc_attrs(& (ha->pdev)->dev, 16384UL, & rdmem_dma, 208U, (struct dma_attrs *)0);
#line 3116
  if ((unsigned long )rdmem_buffer == (unsigned long )((void *)0)) {
#line 3117
    ql_dbg(524288U, vha, 45384, "Unable to allocate rdmem dma buffer\n");
#line 3119
    return (258);
  } else {

  }
#line 3130
  dma_desc.cmd.dma_desc_cmd = (unsigned int )m_hdr->dma_desc_cmd & 65295U;
#line 3131
  dma_desc.cmd.dma_desc_cmd = (unsigned int )dma_desc.cmd.dma_desc_cmd | (((unsigned int )((uint16_t )(ha->pdev)->devfn) & 7U) << 4U);
#line 3134
  dma_desc.dma_bus_addr = rdmem_dma;
#line 3135
  chunk_size = 16384U;
#line 3135
  dma_desc.cmd.read_data_size = chunk_size;
#line 3136
  read_size = 0U;
#line 3142
  goto ldv_44308;
  ldv_44307: ;
#line 3143
  if (m_hdr->read_data_size - read_size <= 16383U) {
#line 3145
    chunk_size = m_hdr->read_data_size - read_size;
#line 3146
    dma_desc.cmd.read_data_size = chunk_size;
  } else {

  }
#line 3149
  dma_desc.src_addr = (uint64_t )(m_hdr->read_addr + read_size);
#line 3152
  rval = qla8044_ms_mem_write_128b(vha, (uint64_t )m_hdr->desc_card_addr, (uint32_t *)(& dma_desc),
                                   3U);
#line 3155
  if (rval != 0) {
#line 3156
    ql_log(1U, vha, 45386, "%s: Error writing rdmem-dma-init to MS !!!\n", "qla8044_minidump_pex_dma_read");
#line 3159
    goto error_exit;
  } else {

  }
#line 3161
  ql_dbg(524288U, vha, 45387, "%s: Dma-descriptor: Instruct for rdmem dma (chunk_size 0x%x).\n",
         "qla8044_minidump_pex_dma_read", chunk_size);
#line 3166
  rval = qla8044_start_pex_dma(vha, m_hdr);
#line 3167
  if (rval != 0) {
#line 3168
    goto error_exit;
  } else {

  }
#line 3170
  __len = (size_t )chunk_size;
#line 3170
  __ret = __builtin_memcpy((void *)data_ptr, (void const   *)rdmem_buffer, __len);
#line 3171
  data_ptr = data_ptr + (unsigned long )chunk_size;
#line 3172
  read_size = read_size + chunk_size;
  ldv_44308: ;
#line 3142
  if (m_hdr->read_data_size > read_size) {
#line 3144
    goto ldv_44307;
  } else {

  }
#line 3175
  *d_ptr = (uint32_t *)data_ptr;
  error_exit: ;
#line 3178
  if ((unsigned long )rdmem_buffer != (unsigned long )((void *)0)) {
#line 3179
    dma_free_attrs(& (ha->pdev)->dev, 16384UL, rdmem_buffer, rdmem_dma, (struct dma_attrs *)0);
  } else {

  }
#line 3182
  return (rval);
}
}
#line 3191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_collect_md_data(struct scsi_qla_host *vha ) 
{ 
  int num_entry_hdr ;
  struct qla8044_minidump_entry_hdr *entry_hdr ;
  struct qla8044_minidump_template_hdr *tmplt_hdr ;
  uint32_t *data_ptr ;
  uint32_t data_collected ;
  uint32_t f_capture_mask ;
  int i ;
  int rval ;
  uint64_t now ;
  uint32_t timestamp ;
  uint32_t idc_control ;
  struct qla_hw_data *ha ;
  int tmp ;
  unsigned int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 3193
  num_entry_hdr = 0;
#line 3197
  data_collected = 0U;
#line 3198
  rval = 258;
#line 3201
  ha = vha->hw;
#line 3203
  if ((unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 3204
    ql_log(2U, vha, 45313, "%s(%ld) No buffer to dump\n", "qla8044_collect_md_data",
           vha->host_no);
#line 3207
    return (rval);
  } else {

  }
#line 3210
  if (ha->fw_dumped != 0) {
#line 3211
    ql_log(1U, vha, 45325, "Firmware has been previously dumped (%p) -- ignoring request.\n",
           ha->fw_dump);
#line 3214
    goto md_failed;
  } else {

  }
#line 3217
  ha->fw_dumped = 0;
#line 3219
  if ((unsigned long )ha->md_tmplt_hdr == (unsigned long )((void *)0) || (unsigned long )ha->md_dump == (unsigned long )((void *)0)) {
#line 3220
    ql_log(1U, vha, 45326, "Memory not allocated for minidump capture\n");
#line 3222
    goto md_failed;
  } else {

  }
#line 3225
  qla8044_idc_lock(ha);
#line 3226
  idc_control = qla8044_rd_reg(ha, 14224UL);
#line 3227
  if ((idc_control & 2U) != 0U) {
#line 3228
    ql_log(1U, vha, 45330, "Forced reset from application, ignore minidump capture\n");
#line 3231
    qla8044_wr_reg(ha, 14224UL, idc_control & 4294967293U);
#line 3233
    qla8044_idc_unlock(ha);
#line 3235
    goto md_failed;
  } else {

  }
#line 3237
  qla8044_idc_unlock(ha);
#line 3239
  tmp = qla82xx_validate_template_chksum(vha);
#line 3239
  if (tmp != 0) {
#line 3240
    ql_log(2U, vha, 45321, "Template checksum validation error\n");
#line 3242
    goto md_failed;
  } else {

  }
#line 3245
  tmplt_hdr = (struct qla8044_minidump_template_hdr *)ha->md_tmplt_hdr;
#line 3247
  data_ptr = (uint32_t *)ha->md_dump;
#line 3248
  num_entry_hdr = (int )tmplt_hdr->num_of_entries;
#line 3250
  ql_dbg(524288U, vha, 45338, "Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);
#line 3253
  f_capture_mask = tmplt_hdr->capture_debug_level & 255U;
#line 3256
  if ((f_capture_mask & 3U) != 3U) {
#line 3257
    ql_log(1U, vha, 45327, "Minimum required capture mask[0x%x] level not set\n",
           f_capture_mask);
  } else {

  }
#line 3262
  tmplt_hdr->driver_capture_mask = (uint32_t )ql2xmdcapmask;
#line 3263
  ql_log(2U, vha, 45314, "[%s]: starting data ptr: %p\n", "qla8044_collect_md_data",
         data_ptr);
#line 3266
  ql_log(2U, vha, 45323, "[%s]: no of entry headers in Template: 0x%x\n", "qla8044_collect_md_data",
         num_entry_hdr);
#line 3269
  ql_log(2U, vha, 45324, "[%s]: Total_data_size 0x%x, %d obtained\n", "qla8044_collect_md_data",
         ha->md_dump_size, ha->md_dump_size);
#line 3274
  now = get_jiffies_64();
#line 3275
  tmp___0 = jiffies_to_msecs((unsigned long const   )now);
#line 3275
  timestamp = tmp___0 / 1000U;
#line 3276
  tmplt_hdr->driver_timestamp = timestamp;
#line 3278
  entry_hdr = (struct qla8044_minidump_entry_hdr *)ha->md_tmplt_hdr + (unsigned long )tmplt_hdr->first_entry_offset;
#line 3280
  tmplt_hdr->saved_state_array[3] = tmplt_hdr->ocm_window_reg[(int )ha->portnum];
#line 3284
  i = 0;
#line 3284
  goto ldv_44352;
  ldv_44351: ;
#line 3285
  if (ha->md_dump_size < data_collected) {
#line 3286
    ql_log(2U, vha, 45315, "Data collected: [0x%x], Total Dump size: [0x%x]\n", data_collected,
           ha->md_dump_size);
#line 3290
    return (rval);
  } else {

  }
#line 3293
  if (((int )entry_hdr->d_ctrl.entry_capture_mask & ql2xmdcapmask) == 0) {
#line 3295
    entry_hdr->d_ctrl.driver_flags = (uint8_t )((unsigned int )entry_hdr->d_ctrl.driver_flags | 128U);
#line 3297
    goto skip_nxt_entry;
  } else {

  }
#line 3300
  ql_dbg(524288U, vha, 45316, "Data collected: [0x%x], Dump size left:[0x%x]\n", data_collected,
         ha->md_dump_size - data_collected);
#line 3308
  switch (entry_hdr->entry_type) {
  case 255U: 
#line 3310
  qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3311
  goto ldv_44329;
  case 98U: 
#line 3313
  rval = qla8044_minidump_process_control(vha, entry_hdr);
#line 3315
  if (rval != 0) {
#line 3316
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3317
    goto md_failed;
  } else {

  }
#line 3319
  goto ldv_44329;
  case 1U: 
#line 3321
  qla8044_minidump_process_rdcrb(vha, entry_hdr, & data_ptr);
#line 3323
  goto ldv_44329;
  case 72U: 
#line 3325
  rval = qla8044_minidump_pex_dma_read(vha, entry_hdr, & data_ptr);
#line 3327
  if (rval != 0) {
#line 3328
    rval = qla8044_minidump_process_rdmem(vha, entry_hdr, & data_ptr);
#line 3330
    if (rval != 0) {
#line 3331
      qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3333
      goto md_failed;
    } else {

    }
  } else {

  }
#line 3336
  goto ldv_44329;
  case 4U: ;
  case 71U: 
#line 3339
  tmp___1 = qla8044_minidump_process_rdrom(vha, entry_hdr, & data_ptr);
#line 3339
  rval = (int )tmp___1;
#line 3341
  if (rval != 0) {
#line 3342
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3345
  goto ldv_44329;
  case 21U: ;
  case 22U: ;
  case 23U: ;
  case 24U: 
#line 3350
  rval = qla8044_minidump_process_l2tag(vha, entry_hdr, & data_ptr);
#line 3352
  if (rval != 0) {
#line 3353
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3354
    goto md_failed;
  } else {

  }
#line 3356
  goto ldv_44329;
  case 8U: ;
  case 9U: ;
  case 11U: ;
  case 12U: 
#line 3361
  qla8044_minidump_process_l1cache(vha, entry_hdr, & data_ptr);
#line 3363
  goto ldv_44329;
  case 6U: 
#line 3365
  qla8044_minidump_process_rdocm(vha, entry_hdr, & data_ptr);
#line 3367
  goto ldv_44329;
  case 2U: 
#line 3369
  qla8044_minidump_process_rdmux(vha, entry_hdr, & data_ptr);
#line 3371
  goto ldv_44329;
  case 3U: 
#line 3373
  qla8044_minidump_process_queue(vha, entry_hdr, & data_ptr);
#line 3375
  goto ldv_44329;
  case 35U: 
#line 3377
  tmp___2 = qla8044_minidump_process_pollrd(vha, entry_hdr, & data_ptr);
#line 3377
  rval = (int )tmp___2;
#line 3379
  if (rval != 0) {
#line 3380
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3381
  goto ldv_44329;
  case 36U: 
#line 3383
  qla8044_minidump_process_rdmux2(vha, entry_hdr, & data_ptr);
#line 3385
  goto ldv_44329;
  case 37U: 
#line 3387
  tmp___3 = qla8044_minidump_process_pollrdmwr(vha, entry_hdr, & data_ptr);
#line 3387
  rval = (int )tmp___3;
#line 3389
  if (rval != 0) {
#line 3390
    qla8044_mark_entry_skipped(vha, entry_hdr, i);
  } else {

  }
#line 3391
  goto ldv_44329;
  case 0U: ;
  default: 
#line 3394
  qla8044_mark_entry_skipped(vha, entry_hdr, i);
#line 3395
  goto ldv_44329;
  }
  ldv_44329: 
#line 3398
  data_collected = (uint32_t )((long )data_ptr) - (uint32_t )((long )ha->md_dump);
  skip_nxt_entry: 
#line 3404
  entry_hdr = entry_hdr + (unsigned long )entry_hdr->entry_size;
#line 3284
  i = i + 1;
  ldv_44352: ;
#line 3284
  if (i < num_entry_hdr) {
#line 3286
    goto ldv_44351;
  } else {

  }

#line 3408
  if (ha->md_dump_size != data_collected) {
#line 3409
    ql_log(2U, vha, 45317, "Dump data mismatch: Data collected: [0x%x], total_data_size:[0x%x]\n",
           data_collected, ha->md_dump_size);
#line 3413
    goto md_failed;
  } else {

  }
#line 3416
  ql_log(2U, vha, 45328, "Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",
         vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);
#line 3419
  ha->fw_dumped = 1;
#line 3420
  qla2x00_post_uevent_work(vha, 0U);
#line 3423
  ql_log(2U, vha, 45318, "Leaving fn: %s Last entry: 0x%x\n", "qla8044_collect_md_data",
         i);
  md_failed: ;
#line 3427
  return (rval);
}
}
#line 3431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void qla8044_get_minidump(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  int tmp ;

  {
#line 3433
  ha = vha->hw;
#line 3435
  tmp = qla8044_collect_md_data(vha);
#line 3435
  if (tmp == 0) {
#line 3436
    ha->fw_dumped = 1;
  } else {
#line 3438
    ql_log(0U, vha, 45275, "%s: Unable to collect minidump\n", "qla8044_get_minidump");
  }
#line 3441
  return;
}
}
#line 3445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_poll_flash_status_reg(struct scsi_qla_host *vha ) 
{ 
  uint32_t flash_status ;
  int retries ;
  int ret_val ;
  int tmp ;

  {
#line 3448
  retries = 2000;
#line 3449
  ret_val = 0;
#line 3451
  goto ldv_44368;
  ldv_44367: 
#line 3452
  ret_val = qla8044_rd_reg_indirect(vha, 1108344836U, & flash_status);
#line 3454
  if (ret_val != 0) {
#line 3455
    ql_log(1U, vha, 45372, "%s: Failed to read FLASH_STATUS reg.\n", "qla8044_poll_flash_status_reg");
#line 3458
    goto ldv_44366;
  } else {

  }
#line 3460
  if ((flash_status & 6U) == 6U) {
#line 3462
    goto ldv_44366;
  } else {

  }
#line 3463
  msleep(1U);
  ldv_44368: 
#line 3451
  tmp = retries;
#line 3451
  retries = retries - 1;
#line 3451
  if (tmp != 0) {
#line 3453
    goto ldv_44367;
  } else {

  }
  ldv_44366: ;
#line 3466
  if (retries == 0) {
#line 3467
    ret_val = 258;
  } else {

  }
#line 3469
  return (ret_val);
}
}
#line 3473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_write_flash_status_reg(struct scsi_qla_host *vha , uint32_t data ) 
{ 
  int ret_val ;
  uint32_t cmd ;

  {
#line 3476
  ret_val = 0;
#line 3479
  cmd = (vha->hw)->fdt_wrt_sts_reg_cmd;
#line 3481
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, cmd | 16580864U);
#line 3483
  if (ret_val != 0) {
#line 3484
    ql_log(1U, vha, 45349, "%s: Failed to write to FLASH_ADDR.\n", "qla8044_write_flash_status_reg");
#line 3486
    goto exit_func;
  } else {

  }
#line 3489
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, data);
#line 3490
  if (ret_val != 0) {
#line 3491
    ql_log(1U, vha, 45350, "%s: Failed to write to FLASH_WRDATA.\n", "qla8044_write_flash_status_reg");
#line 3493
    goto exit_func;
  } else {

  }
#line 3496
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 5U);
#line 3498
  if (ret_val != 0) {
#line 3499
    ql_log(1U, vha, 45351, "%s: Failed to write to FLASH_CONTROL.\n", "qla8044_write_flash_status_reg");
#line 3501
    goto exit_func;
  } else {

  }
#line 3504
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3505
  if (ret_val != 0) {
#line 3506
    ql_log(1U, vha, 45352, "%s: Error polling flash status reg.\n", "qla8044_write_flash_status_reg");
  } else {

  }
  exit_func: ;
#line 3510
  return (ret_val);
}
}
#line 3517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_unprotect_flash(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 3520
  ha = vha->hw;
#line 3522
  ret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_enable);
#line 3523
  if (ret_val != 0) {
#line 3524
    ql_log(1U, vha, 45369, "%s: Write flash status failed.\n", "qla8044_unprotect_flash");
  } else {

  }
#line 3527
  return (ret_val);
}
}
#line 3534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_protect_flash(scsi_qla_host_t *vha ) 
{ 
  int ret_val ;
  struct qla_hw_data *ha ;

  {
#line 3537
  ha = vha->hw;
#line 3539
  ret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_disable);
#line 3540
  if (ret_val != 0) {
#line 3541
    ql_log(1U, vha, 45371, "%s: Write flash status failed.\n", "qla8044_protect_flash");
  } else {

  }
#line 3544
  return (ret_val);
}
}
#line 3549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_erase_flash_sector(struct scsi_qla_host *vha , uint32_t sector_start_addr ) 
{ 
  uint32_t reversed_addr ;
  int ret_val ;

  {
#line 3553
  ret_val = 0;
#line 3555
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3556
  if (ret_val != 0) {
#line 3557
    ql_log(1U, vha, 45358, "%s: Poll flash status after erase failed..\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3561
  reversed_addr = (((sector_start_addr & 255U) << 16) | (sector_start_addr & 65280U)) | ((sector_start_addr & 16711680U) >> 16);
#line 3565
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, reversed_addr);
#line 3567
  if (ret_val != 0) {
#line 3568
    ql_log(1U, vha, 45359, "%s: Failed to write to FLASH_WRDATA.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3571
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, (vha->hw)->fdt_erase_cmd | 16581376U);
#line 3573
  if (ret_val != 0) {
#line 3574
    ql_log(1U, vha, 45360, "%s: Failed to write to FLASH_ADDR.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3577
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 61U);
#line 3579
  if (ret_val != 0) {
#line 3580
    ql_log(1U, vha, 45361, "%s: Failed write to FLASH_CONTROL.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3583
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3584
  if (ret_val != 0) {
#line 3585
    ql_log(1U, vha, 45362, "%s: Poll flash status failed.\n", "qla8044_erase_flash_sector");
  } else {

  }
#line 3590
  return (ret_val);
}
}
#line 3605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_flash_write_u32(struct scsi_qla_host *vha , uint32_t addr , uint32_t *p_data ) 
{ 
  int ret_val ;

  {
#line 3608
  ret_val = 0;
#line 3610
  ret_val = qla8044_wr_reg_indirect(vha, 1108410376U, (addr >> 2) | 8388608U);
#line 3612
  if (ret_val != 0) {
#line 3613
    ql_log(1U, vha, 45364, "%s: Failed write to FLASH_ADDR.\n", "qla8044_flash_write_u32");
#line 3615
    goto exit_func;
  } else {

  }
#line 3617
  ret_val = qla8044_wr_reg_indirect(vha, 1108410380U, *p_data);
#line 3618
  if (ret_val != 0) {
#line 3619
    ql_log(1U, vha, 45365, "%s: Failed write to FLASH_WRDATA.\n", "qla8044_flash_write_u32");
#line 3621
    goto exit_func;
  } else {

  }
#line 3623
  ret_val = qla8044_wr_reg_indirect(vha, 1108410372U, 61U);
#line 3624
  if (ret_val != 0) {
#line 3625
    ql_log(1U, vha, 45366, "%s: Failed write to FLASH_CONTROL.\n", "qla8044_flash_write_u32");
#line 3627
    goto exit_func;
  } else {

  }
#line 3629
  ret_val = qla8044_poll_flash_status_reg(vha);
#line 3630
  if (ret_val != 0) {
#line 3631
    ql_log(1U, vha, 45367, "%s: Poll flash status failed.\n", "qla8044_flash_write_u32");
  } else {

  }
  exit_func: ;
#line 3636
  return (ret_val);
}
}
#line 3640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_write_flash_buffer_mode(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                           uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t spi_val ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;

  {
#line 3643
  ret = 258;
#line 3646
  if (dwords <= 1U || dwords > 64U) {
#line 3648
    ql_dbg(8388608U, vha, 45347, "Got unsupported dwords = 0x%x.\n", dwords);
#line 3651
    return (258);
  } else {

  }
#line 3654
  qla8044_rd_reg_indirect(vha, 671670292U, & spi_val);
#line 3655
  qla8044_wr_reg_indirect(vha, 671670292U, spi_val | 4U);
#line 3657
  qla8044_wr_reg_indirect(vha, 1108410376U, 8388608U);
#line 3661
  tmp = dwptr;
#line 3661
  dwptr = dwptr + 1;
#line 3661
  ret = qla8044_wr_reg_indirect(vha, 1108410380U, *tmp);
#line 3663
  qla8044_wr_reg_indirect(vha, 1108410372U, 67U);
#line 3666
  ret = qla8044_poll_flash_status_reg(vha);
#line 3667
  if (ret != 0) {
#line 3668
    ql_log(1U, vha, 45348, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3670
    goto exit_func;
  } else {

  }
#line 3673
  dwords = dwords - 1U;
#line 3675
  qla8044_wr_reg_indirect(vha, 1108410376U, 8388609U);
#line 3680
  goto ldv_44415;
  ldv_44414: 
#line 3681
  tmp___0 = dwptr;
#line 3681
  dwptr = dwptr + 1;
#line 3681
  qla8044_wr_reg_indirect(vha, 1108410380U, *tmp___0);
#line 3682
  qla8044_wr_reg_indirect(vha, 1108410372U, 127U);
#line 3684
  ret = qla8044_poll_flash_status_reg(vha);
#line 3685
  if (ret != 0) {
#line 3686
    ql_log(1U, vha, 45353, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3688
    goto exit_func;
  } else {

  }
#line 3690
  dwords = dwords - 1U;
  ldv_44415: ;
#line 3680
  if (dwords != 1U) {
#line 3682
    goto ldv_44414;
  } else {

  }
#line 3693
  qla8044_wr_reg_indirect(vha, 1108410376U, (faddr >> 2) | 8388608U);
#line 3697
  tmp___1 = dwptr;
#line 3697
  dwptr = dwptr + 1;
#line 3697
  qla8044_wr_reg_indirect(vha, 1108410380U, *tmp___1);
#line 3698
  qla8044_wr_reg_indirect(vha, 1108410372U, 125U);
#line 3700
  ret = qla8044_poll_flash_status_reg(vha);
#line 3701
  if (ret != 0) {
#line 3702
    ql_log(1U, vha, 45354, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3704
    goto exit_func;
  } else {

  }
#line 3706
  qla8044_rd_reg_indirect(vha, 671670288U, & spi_val);
#line 3708
  if ((spi_val & 4U) != 0U) {
#line 3709
    ql_log(1U, vha, 45355, "%s: Failed.\n", "qla8044_write_flash_buffer_mode");
#line 3711
    spi_val = 0U;
#line 3713
    qla8044_rd_reg_indirect(vha, 671670292U, & spi_val);
#line 3715
    qla8044_wr_reg_indirect(vha, 671670292U, spi_val | 4U);
  } else {

  }
  exit_func: ;
#line 3719
  return (ret);
}
}
#line 3723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_write_flash_dword_mode(scsi_qla_host_t *vha , uint32_t *dwptr ,
                                          uint32_t faddr , uint32_t dwords ) 
{ 
  int ret ;
  uint32_t liter ;

  {
#line 3726
  ret = 258;
#line 3729
  liter = 0U;
#line 3729
  goto ldv_44428;
  ldv_44427: 
#line 3730
  ret = qla8044_flash_write_u32(vha, faddr, dwptr);
#line 3731
  if (ret != 0) {
#line 3732
    ql_dbg(524288U, vha, 45377, "%s: flash address=%x data=%x.\n", "qla8044_write_flash_dword_mode",
           faddr, *dwptr);
#line 3735
    goto ldv_44426;
  } else {

  }
#line 3729
  liter = liter + 1U;
#line 3729
  faddr = faddr + 4U;
#line 3729
  dwptr = dwptr + 1;
  ldv_44428: ;
#line 3729
  if (liter < dwords) {
#line 3731
    goto ldv_44427;
  } else {

  }
  ldv_44426: ;
#line 3739
  return (ret);
}
}
#line 3743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_write_optrom_data(struct scsi_qla_host *vha , uint8_t *buf , uint32_t offset ,
                              uint32_t length ) 
{ 
  int rval ;
  int i ;
  int burst_iter_count ;
  int dword_count ;
  int erase_sec_count ;
  uint32_t erase_offset ;
  uint8_t *p_cache ;
  uint8_t *p_src ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 3746
  rval = 258;
#line 3751
  erase_offset = offset;
#line 3753
  tmp = kcalloc((size_t )length, 1UL, 208U);
#line 3753
  p_cache = (uint8_t *)tmp;
#line 3754
  if ((unsigned long )p_cache == (unsigned long )((uint8_t *)0U)) {
#line 3755
    return (258);
  } else {

  }
#line 3757
  __len = (size_t )length;
#line 3757
  __ret = __builtin_memcpy((void *)p_cache, (void const   *)buf, __len);
#line 3758
  p_src = p_cache;
#line 3759
  dword_count = (int )(length / 4U);
#line 3763
  burst_iter_count = dword_count / 64;
#line 3764
  erase_sec_count = (int )(length / 65536U);
#line 3767
  scsi_block_requests(vha->host);
#line 3769
  qla8044_flash_lock(vha);
#line 3770
  qla8044_unprotect_flash(vha);
#line 3773
  i = 0;
#line 3773
  goto ldv_44448;
  ldv_44447: 
#line 3774
  rval = qla8044_erase_flash_sector(vha, erase_offset);
#line 3775
  ql_dbg(8388608U, vha, 45368, "Done erase of sector=0x%x.\n", erase_offset);
#line 3778
  if (rval != 0) {
#line 3779
    ql_log(1U, vha, 45345, "Failed to erase the sector having address: 0x%x.\n", erase_offset);
#line 3782
    goto out;
  } else {

  }
#line 3784
  erase_offset = erase_offset + 65536U;
#line 3773
  i = i + 1;
  ldv_44448: ;
#line 3773
  if (i < erase_sec_count) {
#line 3775
    goto ldv_44447;
  } else {

  }
#line 3786
  ql_dbg(8388608U, vha, 45375, "Got write for addr = 0x%x length=0x%x.\n", offset,
         length);
#line 3790
  i = 0;
#line 3790
  goto ldv_44451;
  ldv_44450: 
#line 3793
  rval = qla8044_write_flash_buffer_mode(vha, (uint32_t *)p_src, offset, 64U);
#line 3795
  if (rval != 0) {
#line 3797
    ql_log(1U, vha, 45346, "Failed to write flash in buffer mode, Reverting to slow-write.\n");
#line 3800
    rval = qla8044_write_flash_dword_mode(vha, (uint32_t *)p_src, offset, 64U);
  } else {

  }
#line 3804
  p_src = p_src + 256UL;
#line 3805
  offset = offset + 256U;
#line 3790
  i = i + 1;
  ldv_44451: ;
#line 3790
  if (i < burst_iter_count) {
#line 3792
    goto ldv_44450;
  } else {

  }
#line 3807
  ql_dbg(8388608U, vha, 45363, "Done writing.\n");
  out: 
#line 3811
  qla8044_protect_flash(vha);
#line 3812
  qla8044_flash_unlock(vha);
#line 3813
  scsi_unblock_requests(vha->host);
#line 3814
  kfree((void const   *)p_cache);
#line 3816
  return (rval);
}
}
#line 3832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
irqreturn_t qla8044_intr_handler(int irq , void *dev_id ) 
{ 
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct rsp_que *rsp ;
  struct device_reg_82xx *reg ;
  int status ;
  unsigned long flags ;
  unsigned long iter ;
  uint32_t stat ;
  uint16_t mb[4U] ;
  uint32_t leg_int_ptr ;
  uint32_t pf_bit ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 3838
  status = 0;
#line 3843
  leg_int_ptr = 0U;
#line 3845
  rsp = (struct rsp_que *)dev_id;
#line 3846
  if ((unsigned long )rsp == (unsigned long )((struct rsp_que *)0)) {
#line 3847
    ql_log(2U, (scsi_qla_host_t *)0, 45379, "%s(): NULL response queue pointer\n",
           "qla8044_intr_handler");
#line 3849
    return (0);
  } else {

  }
#line 3851
  ha = rsp->hw;
#line 3852
  tmp = pci_get_drvdata(ha->pdev);
#line 3852
  vha = (scsi_qla_host_t *)tmp;
#line 3854
  tmp___0 = pci_channel_offline(ha->pdev);
#line 3854
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 3854
  if (tmp___1 != 0L) {
#line 3855
    return (1);
  } else {

  }
#line 3857
  leg_int_ptr = qla8044_rd_reg(ha, 14528UL);
#line 3860
  if ((int )leg_int_ptr >= 0) {
#line 3861
    ql_dbg(524288U, vha, 45380, "%s: Legacy Interrupt Bit 31 not set, spurious interrupt!\n",
           "qla8044_intr_handler");
#line 3864
    return (0);
  } else {

  }
#line 3867
  pf_bit = (uint32_t )((int )ha->portnum << 16);
#line 3869
  if ((leg_int_ptr & 983040U) != pf_bit) {
#line 3870
    ql_dbg(524288U, vha, 45381, "%s: Incorrect function ID 0x%x in legacy interrupt register, ha->pf_bit = 0x%x\n",
           "qla8044_intr_handler", leg_int_ptr & 983040U, pf_bit);
#line 3875
    return (0);
  } else {

  }
#line 3882
  qla8044_wr_reg(ha, 14532UL, 0U);
  ldv_44470: 
#line 3884
  leg_int_ptr = qla8044_rd_reg(ha, 14528UL);
#line 3885
  if ((leg_int_ptr & 983040U) != pf_bit) {
#line 3886
    goto ldv_44469;
  } else {

  }
#line 3887
  if ((leg_int_ptr & 1073741824U) != 0U) {
#line 3889
    goto ldv_44470;
  } else {

  }
  ldv_44469: 
#line 3889
  reg = & (ha->iobase)->isp82;
#line 3890
  tmp___2 = spinlock_check(& ha->hardware_lock);
#line 3890
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 3891
  iter = 1UL;
#line 3891
  goto ldv_44484;
  ldv_44483: 
#line 3893
  tmp___3 = readl((void const volatile   *)(& reg->host_int));
#line 3893
  if (tmp___3 != 0U) {
#line 3894
    stat = readl((void const volatile   *)(& reg->host_status));
#line 3895
    if ((stat & 32768U) == 0U) {
#line 3896
      goto ldv_44474;
    } else {

    }
#line 3898
    switch (stat & 255U) {
    case 1U: ;
    case 2U: ;
    case 16U: ;
    case 17U: 
#line 3903
    qla82xx_mbx_completion(vha, (int )((unsigned short )(stat >> 16)));
#line 3904
    status = status | 1;
#line 3905
    goto ldv_44479;
    case 18U: 
#line 3907
    mb[0] = (unsigned short )(stat >> 16);
#line 3908
    mb[1] = readw((void const volatile   *)(& reg->mailbox_out) + 1U);
#line 3909
    mb[2] = readw((void const volatile   *)(& reg->mailbox_out) + 2U);
#line 3910
    mb[3] = readw((void const volatile   *)(& reg->mailbox_out) + 3U);
#line 3911
    qla2x00_async_event(vha, rsp, (uint16_t *)(& mb));
#line 3912
    goto ldv_44479;
    case 19U: 
#line 3914
    qla24xx_process_response_queue(vha, rsp);
#line 3915
    goto ldv_44479;
    default: 
#line 3917
    ql_dbg(524288U, vha, 45382, "Unrecognized interrupt type (%d).\n", stat & 255U);
#line 3920
    goto ldv_44479;
    }
    ldv_44479: ;
  } else {

  }
#line 3923
  writel(0U, (void volatile   *)(& reg->host_int));
  ldv_44484: 
#line 3891
  tmp___4 = iter;
#line 3891
  iter = iter - 1UL;
#line 3891
  if (tmp___4 != 0UL) {
#line 3893
    goto ldv_44483;
  } else {

  }
  ldv_44474: 
#line 3926
  qla2x00_handle_mbx_completion(ha, status);
#line 3927
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3929
  return (1);
}
}
#line 3933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static int qla8044_idc_dontreset(struct qla_hw_data *ha ) 
{ 
  uint32_t idc_ctrl ;

  {
#line 3937
  idc_ctrl = qla8044_rd_reg(ha, 14224UL);
#line 3938
  return ((int )idc_ctrl & 1);
}
}
#line 3942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
static void qla8044_clear_rst_ready(scsi_qla_host_t *vha ) 
{ 
  uint32_t drv_state ;
  int tmp ;

  {
#line 3946
  tmp = qla8044_rd_direct(vha, 5U);
#line 3946
  drv_state = (uint32_t )tmp;
#line 3953
  drv_state = (uint32_t )(~ (1 << (int )(vha->hw)->portnum)) & drv_state;
#line 3955
  ql_dbg(524288U, vha, 45373, "drv_state: 0x%08x\n", drv_state);
#line 3957
  qla8044_wr_direct(vha, 5U, drv_state);
#line 3958
  return;
}
}
#line 3961 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int qla8044_abort_isp(scsi_qla_host_t *vha ) 
{ 
  int rval ;
  uint32_t dev_state ;
  struct qla_hw_data *ha ;
  int tmp ;
  int tmp___0 ;

  {
#line 3965
  ha = vha->hw;
#line 3967
  qla8044_idc_lock(ha);
#line 3968
  tmp = qla8044_rd_direct(vha, 4U);
#line 3968
  dev_state = (uint32_t )tmp;
#line 3970
  if (ql2xdontresethba != 0) {
#line 3971
    qla8044_set_idc_dontreset(vha);
  } else {

  }
#line 3979
  if (dev_state == 3U) {
#line 3982
    tmp___0 = qla8044_idc_dontreset(ha);
#line 3982
    if (tmp___0 == 1) {
#line 3983
      ql_dbg(524288U, vha, 45374, "Reset recovery disabled\n");
#line 3985
      rval = 258;
#line 3986
      goto exit_isp_reset;
    } else {

    }
#line 3989
    ql_dbg(524288U, vha, 45376, "HW State: NEED RESET\n");
#line 3991
    qla8044_wr_direct(vha, 4U, 4U);
  } else {

  }
#line 3998
  qla83xx_reset_ownership(vha);
#line 4000
  qla8044_idc_unlock(ha);
#line 4001
  rval = qla8044_device_state_handler(vha);
#line 4002
  qla8044_idc_lock(ha);
#line 4003
  qla8044_clear_rst_ready(vha);
  exit_isp_reset: 
#line 4006
  qla8044_idc_unlock(ha);
#line 4007
  if (rval == 0) {
#line 4008
    ha->flags.isp82xx_fw_hung = 0U;
#line 4009
    ha->flags.nic_core_reset_hdlr_active = 0U;
#line 4010
    rval = qla82xx_restart_isp(vha);
  } else {

  }
#line 4013
  return (rval);
}
}
#line 4018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void disable_suitable_timer_16(struct timer_list *timer ) 
{ 


  {
#line 4019
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_16) {
#line 4020
    ldv_timer_state_16 = 0;
#line 4021
    return;
  } else {

  }
#line 4023
  return;
}
}
#line 4026 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 4026
  if ((unsigned long )ldv_timer_list_16 == (unsigned long )timer) {
#line 4027
    if (ldv_timer_state_16 == 2 || pending_flag != 0) {
#line 4028
      ldv_timer_list_16 = timer;
#line 4029
      ldv_timer_list_16->data = data;
#line 4030
      ldv_timer_state_16 = 1;
    } else {

    }
#line 4032
    return;
  } else {

  }
#line 4034
  reg_timer_16(timer);
#line 4035
  ldv_timer_list_16->data = data;
#line 4036
  return;
}
}
#line 4039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int reg_timer_16(struct timer_list *timer ) 
{ 


  {
#line 4040
  ldv_timer_list_16 = timer;
#line 4041
  ldv_timer_state_16 = 1;
#line 4042
  return (0);
}
}
#line 4045 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
void choose_timer_16(struct timer_list *timer ) 
{ 


  {
#line 4046
  LDV_IN_INTERRUPT = 2;
#line 4047
  (*(timer->function))(timer->data);
#line 4048
  LDV_IN_INTERRUPT = 1;
#line 4049
  ldv_timer_state_16 = 2;
#line 4050
  return;
}
}
#line 4052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int ldv_del_timer_77(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 4056
  tmp = del_timer(ldv_func_arg1);
#line 4056
  ldv_func_res = tmp;
#line 4058
  disable_suitable_timer_7(ldv_func_arg1);
#line 4060
  return (ldv_func_res);
}
}
#line 4063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_nx2.o.c.prepared"
int ldv_scsi_add_host_with_dma_78(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 4067
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 4067
  ldv_func_res = tmp;
#line 4069
  if (ldv_func_res == 0) {
#line 4070
    ldv_state_variable_72 = 1;
#line 4070
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 4074
  return (ldv_func_res);
}
}
#line 332 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 336
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 341
  return (oldbit);
}
}
#line 14 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 55 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 203 "include/linux/printk.h"
extern void dump_stack(void) ;
#line 45 "include/linux/dynamic_debug.h"
extern int __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
#line 47 "include/linux/string.h"
extern int strcasecmp(char const   * , char const   * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 291 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 293
  _raw_spin_lock(& lock->ldv_6105.rlock);
#line 294
  return;
}
}
#line 331 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 333
  _raw_spin_unlock(& lock->ldv_6105.rlock);
#line 334
  return;
}
}
#line 143 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 887
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 889
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 892
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 94 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 178
int ldv_del_timer_81(struct timer_list *ldv_func_arg1 ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 375
extern struct workqueue_struct *system_wq ;
#line 469
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 476
extern void flush_scheduled_work(void) ;
#line 485
extern bool flush_delayed_work(struct delayed_work * ) ;
#line 521 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 525
  tmp = queue_delayed_work_on(4096, wq, dwork, delay);
#line 525
  return (tmp);
}
}
#line 566 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 568
  tmp = queue_work(system_wq, work);
#line 568
  return (tmp);
}
}
#line 594 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 597
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 597
  return (tmp);
}
}
#line 116 "include/linux/slab.h"
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 296
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 626 "include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 628
  tmp = kmem_cache_alloc(k, flags | 32768U);
#line 628
  return (tmp);
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_suitable_timer_17(struct timer_list *timer ) ;
#line 254
void choose_timer_17(struct timer_list *timer ) ;
#line 279
int reg_timer_17(struct timer_list *timer ) ;
#line 283
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 57 "include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ 
  unsigned long page_link ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 59
  page_link = sg->page_link & 3UL;
#line 65
  tmp = ldv__builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
#line 65
  if (tmp != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (65), "i" (12UL));
    ldv_31894: ;
#line 65
    goto ldv_31894;
  } else {

  }
#line 67
  tmp___0 = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 67
  if (tmp___0 != 0L) {
#line 67
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (67), "i" (12UL));
    ldv_31895: ;
#line 67
    goto ldv_31895;
  } else {

  }
#line 68
  tmp___1 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 68
  if (tmp___1 != 0L) {
#line 68
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (68), "i" (12UL));
    ldv_31896: ;
#line 68
    goto ldv_31896;
  } else {

  }
#line 70
  sg->page_link = page_link | (unsigned long )page;
#line 71
  return;
}
}
#line 87 "include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 


  {
#line 90
  sg_assign_page(sg, page);
#line 91
  sg->offset = offset;
#line 92
  sg->length = len;
#line 93
  return;
}
}
#line 95 "include/linux/scatterlist.h"
__inline static struct page *sg_page___3(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 98
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 98
  if (tmp != 0L) {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
    ldv_31906: ;
#line 98
    goto ldv_31906;
  } else {

  }
#line 99
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 99
  if (tmp___0 != 0L) {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
    ldv_31907: ;
#line 99
    goto ldv_31907;
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 218 "include/linux/scatterlist.h"
__inline static void *sg_virt___2(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 220
  tmp = sg_page___3(sg);
#line 220
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 220
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 226
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 42 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs___2(struct device *dev , struct scatterlist *sg ,
                                         int nents , enum dma_data_direction dir ,
                                         struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 46
  tmp = get_dma_ops(dev);
#line 46
  ops = tmp;
#line 50
  i = 0;
#line 50
  s = sg;
#line 50
  goto ldv_32456;
  ldv_32455: 
#line 51
  tmp___0 = sg_virt___2(s);
#line 51
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 50
  i = i + 1;
#line 50
  s = sg_next(s);
  ldv_32456: ;
#line 50
  if (i < nents) {
#line 52
    goto ldv_32455;
  } else {

  }
#line 52
  tmp___1 = valid_dma_direction((int )dir);
#line 52
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 52
  if (tmp___2 != 0L) {
#line 52
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (52), "i" (12UL));
    ldv_32458: ;
#line 52
    goto ldv_32458;
  } else {

  }
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 56
  return (ents);
}
}
#line 59 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs___1(struct device *dev , struct scatterlist *sg ,
                                            int nents , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 65
  if (tmp___1 != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
    ldv_32467: ;
#line 65
    goto ldv_32467;
  } else {

  }
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 69
  return;
}
}
#line 57 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ 
  int tmp ;

  {
#line 60
  tmp = dma_map_sg_attrs___2((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 60
  return (tmp);
}
}
#line 64 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ 


  {
#line 67
  dma_unmap_sg_attrs___1((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 68
  return;
}
}
#line 12 "include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_le32(void const   *p ) 
{ 
  __u32 tmp ;

  {
#line 14
  tmp = __le32_to_cpup((__le32 const   *)p);
#line 14
  return (tmp);
}
}
#line 62 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be64(u64 val , void *p ) 
{ 
  __u64 tmp ;

  {
#line 64
  tmp = __fswab64(val);
#line 64
  *((__be64 *)p) = tmp;
#line 65
  return;
}
}
#line 786 "include/scsi/scsi_host.h"
int ldv_scsi_add_host_with_dma_82(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 401 "include/scsi/scsi_device.h"
extern int scsilun_to_int(struct scsi_lun * ) ;
#line 928 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
void qlt_disable_vha(struct scsi_qla_host *vha ) ;
#line 935
int qlt_lport_register(struct qla_tgt_func_tmpl *qla_tgt_ops , u64 wwpn , int (*callback)(struct scsi_qla_host * ) ,
                       void *target_lport_ptr ) ;
#line 937
void qlt_lport_deregister(struct scsi_qla_host *vha ) ;
#line 938
void qlt_unreg_sess(struct qla_tgt_sess *sess ) ;
#line 941
void qlt_set_mode(struct scsi_qla_host *vha ) ;
#line 942
void qlt_clear_mode(struct scsi_qla_host *vha ) ;
#line 964 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.12-rc1.tar.xz/linux-3.12-rc1/drivers/scsi/qla2xxx/qla_target.h"
__inline static void qla_reverse_ini_mode(struct scsi_qla_host *ha ) 
{ 


  {
#line 966
  if ((int )(ha->host)->active_mode & 1) {
#line 967
    (ha->host)->active_mode = (unsigned int )(ha->host)->active_mode & 2U;
  } else {
#line 969
    (ha->host)->active_mode = (unsigned char )((unsigned int )(ha->host)->active_mode | 1U);
  }
#line 970
  return;
}
}
#line 975
void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha , struct atio_from_isp *atio ) ;
#line 978
int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd ) ;
#line 979
int qlt_xmit_response(struct qla_tgt_cmd *cmd , int xmit_type , uint8_t scsi_status ) ;
#line 980
void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd ) ;
#line 981
void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd ) ;
#line 982
void qlt_free_cmd(struct qla_tgt_cmd *cmd ) ;
#line 984
void qlt_enable_vha(struct scsi_qla_host *vha ) ;
#line 1005
void qlt_stop_phase1(struct qla_tgt *tgt ) ;
#line 1006
void qlt_stop_phase2(struct qla_tgt *tgt ) ;
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static char *qlini_mode  =    (char *)"enabled";
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int ql2x_ini_mode  =    0;
#line 394
static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha , struct atio_from_isp *atio ) ;
#line 396
static void qlt_response_pkt(struct scsi_qla_host *vha , response_t *pkt ) ;
#line 397
static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess , uint32_t lun , int fn ,
                               void *iocb , int flags ) ;
#line 399
static void qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                   struct atio_from_isp *atio , int ha_locked ) ;
#line 401
static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha , struct qla_tgt_srr_imm *imm ,
                                    int ha_locked ) ;
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct kmem_cache *qla_tgt_cmd_cachep  ;
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct kmem_cache *qla_tgt_mgmt_cmd_cachep  ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static mempool_t *qla_tgt_mgmt_cmd_mempool  ;
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct workqueue_struct *qla_tgt_wq  ;
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct mutex qla_tgt_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "qla_tgt_mutex.wait_lock",
                                                           0, 0UL}}}}, {& qla_tgt_mutex.wait_list,
                                                                        & qla_tgt_mutex.wait_list},
    0, 0, (void *)(& qla_tgt_mutex), {0, {0, 0}, "qla_tgt_mutex", 0, 0UL}};
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct list_head qla_tgt_glist  =    {& qla_tgt_glist, & qla_tgt_glist};
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct qla_tgt_sess *qlt_find_sess_by_port_name(struct qla_tgt *tgt , uint8_t const   *port_name ) 
{ 
  struct qla_tgt_sess *sess ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 420
  __mptr = (struct list_head  const  *)tgt->sess_list.next;
#line 420
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 420
  goto ldv_61186;
  ldv_61185: 
#line 421
  tmp = memcmp((void const   *)(& sess->port_name), (void const   *)port_name, 8UL);
#line 421
  if (tmp == 0) {
#line 422
    return (sess);
  } else {

  }
#line 420
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 420
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_61186: ;
#line 420
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& tgt->sess_list)) {
#line 422
    goto ldv_61185;
  } else {

  }

#line 425
  return ((struct qla_tgt_sess *)0);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int qlt_issue_marker(struct scsi_qla_host *vha , int vha_locked ) 
{ 
  int rc ;
  int tmp ;
  long tmp___0 ;

  {
#line 432
  tmp___0 = ldv__builtin_expect((unsigned int )vha->marker_needed != 0U, 0L);
#line 432
  if (tmp___0 != 0L) {
#line 433
    tmp = qla2x00_issue_marker(vha, vha_locked);
#line 433
    rc = tmp;
#line 434
    if (rc != 0) {
#line 435
      ql_dbg(16384U, vha, 57405, "qla_target(%d): issue_marker() failed\n", (int )vha->vp_idx);
    } else {

    }
#line 439
    return (rc);
  } else {

  }
#line 441
  return (0);
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static struct scsi_qla_host *qlt_find_host_by_d_id(struct scsi_qla_host *vha ,
                                                            uint8_t *d_id ) 
{ 
  struct qla_hw_data *ha ;
  uint8_t vp_idx ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 448
  ha = vha->hw;
#line 451
  if ((int )vha->d_id.b.area != (int )*(d_id + 1UL) || (int )vha->d_id.b.domain != (int )*d_id) {
#line 452
    return ((struct scsi_qla_host *)0);
  } else {

  }
#line 454
  if ((int )vha->d_id.b.al_pa == (int )*(d_id + 2UL)) {
#line 455
    return (vha);
  } else {

  }
#line 457
  tmp = ldv__builtin_expect((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0),
                         0L);
#line 457
  if (tmp != 0L) {
#line 457
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (457), "i" (12UL));
    ldv_61199: ;
#line 457
    goto ldv_61199;
  } else {

  }
#line 458
  vp_idx = (ha->tgt.tgt_vp_map + (unsigned long )*(d_id + 2UL))->idx;
#line 459
  tmp___0 = variable_test_bit((long )vp_idx, (unsigned long const volatile   *)(& ha->vp_idx_map));
#line 459
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 1L);
#line 459
  if (tmp___1 != 0L) {
#line 460
    return ((ha->tgt.tgt_vp_map + (unsigned long )vp_idx)->vha);
  } else {

  }
#line 462
  return ((struct scsi_qla_host *)0);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static struct scsi_qla_host *qlt_find_host_by_vp_idx(struct scsi_qla_host *vha ,
                                                              uint16_t vp_idx ) 
{ 
  struct qla_hw_data *ha ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 469
  ha = vha->hw;
#line 471
  if ((int )vha->vp_idx == (int )vp_idx) {
#line 472
    return (vha);
  } else {

  }
#line 474
  tmp = ldv__builtin_expect((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0),
                         0L);
#line 474
  if (tmp != 0L) {
#line 474
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (474), "i" (12UL));
    ldv_61205: ;
#line 474
    goto ldv_61205;
  } else {

  }
#line 475
  tmp___0 = variable_test_bit((long )vp_idx, (unsigned long const volatile   *)(& ha->vp_idx_map));
#line 475
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 1L);
#line 475
  if (tmp___1 != 0L) {
#line 476
    return ((ha->tgt.tgt_vp_map + (unsigned long )vp_idx)->vha);
  } else {

  }
#line 478
  return ((struct scsi_qla_host *)0);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct scsi_qla_host *host ;
  struct scsi_qla_host *tmp ;
  long tmp___0 ;
  struct scsi_qla_host *host___0 ;
  struct imm_ntfy_from_isp *entry ;
  long tmp___1 ;

  {
#line 484
  switch ((int )atio->u.raw.entry_type) {
  case 6: 
#line 487
  tmp = qlt_find_host_by_d_id(vha, (uint8_t *)(& atio->u.isp24.fcp_hdr.d_id));
#line 487
  host = tmp;
#line 489
  tmp___0 = ldv__builtin_expect((unsigned long )host == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 489
  if (tmp___0 != 0L) {
#line 490
    ql_dbg(16384U, vha, 57406, "qla_target(%d): Received ATIO_TYPE7 with unknown d_id %x:%x:%x\n",
           (int )vha->vp_idx, (int )atio->u.isp24.fcp_hdr.d_id[0], (int )atio->u.isp24.fcp_hdr.d_id[1],
           (int )atio->u.isp24.fcp_hdr.d_id[2]);
#line 496
    goto ldv_61212;
  } else {

  }
#line 498
  qlt_24xx_atio_pkt(host, atio);
#line 499
  goto ldv_61212;
  case 13: 
#line 504
  host___0 = vha;
#line 505
  entry = (struct imm_ntfy_from_isp *)atio;
#line 508
  if ((unsigned int )entry->u.isp24.vp_index != 255U && (unsigned int )entry->u.isp24.nport_handle != 65535U) {
#line 510
    host___0 = qlt_find_host_by_vp_idx(vha, (int )entry->u.isp24.vp_index);
#line 512
    tmp___1 = ldv__builtin_expect((unsigned long )host___0 == (unsigned long )((struct scsi_qla_host *)0),
                               0L);
#line 512
    if (tmp___1 != 0L) {
#line 513
      ql_dbg(16384U, vha, 57407, "qla_target(%d): Received ATIO (IMMED_NOTIFY_TYPE) with unknown vp_index %d\n",
             (int )vha->vp_idx, (int )entry->u.isp24.vp_index);
#line 518
      goto ldv_61212;
    } else {

    }
  } else {

  }
#line 521
  qlt_24xx_atio_pkt(host___0, atio);
#line 522
  goto ldv_61212;
  default: 
#line 526
  ql_dbg(16384U, vha, 57408, "qla_target(%d): Received unknown ATIO atio type %x\n",
         (int )vha->vp_idx, (int )atio->u.raw.entry_type);
#line 529
  goto ldv_61212;
  }
  ldv_61212: ;
#line 532
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_response_pkt_all_vps(struct scsi_qla_host *vha , response_t *pkt ) 
{ 
  struct ctio7_from_24xx *entry ;
  struct scsi_qla_host *host ;
  struct scsi_qla_host *tmp ;
  long tmp___0 ;
  struct scsi_qla_host *host___0 ;
  struct imm_ntfy_from_isp *entry___0 ;
  long tmp___1 ;
  struct scsi_qla_host *host___1 ;
  struct nack_to_isp *entry___1 ;
  long tmp___2 ;
  struct abts_recv_from_24xx *entry___2 ;
  struct scsi_qla_host *host___2 ;
  struct scsi_qla_host *tmp___3 ;
  long tmp___4 ;
  struct abts_resp_to_24xx *entry___3 ;
  struct scsi_qla_host *host___3 ;
  struct scsi_qla_host *tmp___5 ;
  long tmp___6 ;

  {
#line 537
  switch ((int )pkt->entry_type) {
  case 18: 
#line 540
  entry = (struct ctio7_from_24xx *)pkt;
#line 541
  tmp = qlt_find_host_by_vp_idx(vha, (int )entry->vp_index);
#line 541
  host = tmp;
#line 543
  tmp___0 = ldv__builtin_expect((unsigned long )host == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 543
  if (tmp___0 != 0L) {
#line 544
    ql_dbg(16384U, vha, 57409, "qla_target(%d): Response pkt (CTIO_TYPE7) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry->vp_index);
#line 548
    goto ldv_61224;
  } else {

  }
#line 550
  qlt_response_pkt(host, pkt);
#line 551
  goto ldv_61224;
  case 13: 
#line 556
  host___0 = vha;
#line 557
  entry___0 = (struct imm_ntfy_from_isp *)pkt;
#line 560
  host___0 = qlt_find_host_by_vp_idx(vha, (int )entry___0->u.isp24.vp_index);
#line 561
  tmp___1 = ldv__builtin_expect((unsigned long )host___0 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 561
  if (tmp___1 != 0L) {
#line 562
    ql_dbg(16384U, vha, 57410, "qla_target(%d): Response pkt (IMMED_NOTIFY_TYPE) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___0->u.isp24.vp_index);
#line 566
    goto ldv_61224;
  } else {

  }
#line 568
  qlt_response_pkt(host___0, pkt);
#line 569
  goto ldv_61224;
  case 14: 
#line 574
  host___1 = vha;
#line 575
  entry___1 = (struct nack_to_isp *)pkt;
#line 577
  if ((unsigned int )entry___1->u.isp24.vp_index != 255U) {
#line 578
    host___1 = qlt_find_host_by_vp_idx(vha, (int )entry___1->u.isp24.vp_index);
#line 580
    tmp___2 = ldv__builtin_expect((unsigned long )host___1 == (unsigned long )((struct scsi_qla_host *)0),
                               0L);
#line 580
    if (tmp___2 != 0L) {
#line 581
      ql_dbg(16384U, vha, 57411, "qla_target(%d): Response pkt (NOTIFY_ACK_TYPE) received, with unknown vp_index %d\n",
             (int )vha->vp_idx, (int )entry___1->u.isp24.vp_index);
#line 587
      goto ldv_61224;
    } else {

    }
  } else {

  }
#line 590
  qlt_response_pkt(host___1, pkt);
#line 591
  goto ldv_61224;
  case 84: 
#line 596
  entry___2 = (struct abts_recv_from_24xx *)pkt;
#line 598
  tmp___3 = qlt_find_host_by_vp_idx(vha, (int )entry___2->vp_index);
#line 598
  host___2 = tmp___3;
#line 600
  tmp___4 = ldv__builtin_expect((unsigned long )host___2 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 600
  if (tmp___4 != 0L) {
#line 601
    ql_dbg(16384U, vha, 57412, "qla_target(%d): Response pkt (ABTS_RECV_24XX) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___2->vp_index);
#line 605
    goto ldv_61224;
  } else {

  }
#line 607
  qlt_response_pkt(host___2, pkt);
#line 608
  goto ldv_61224;
  case 85: 
#line 613
  entry___3 = (struct abts_resp_to_24xx *)pkt;
#line 615
  tmp___5 = qlt_find_host_by_vp_idx(vha, (int )entry___3->vp_index);
#line 615
  host___3 = tmp___5;
#line 617
  tmp___6 = ldv__builtin_expect((unsigned long )host___3 == (unsigned long )((struct scsi_qla_host *)0),
                             0L);
#line 617
  if (tmp___6 != 0L) {
#line 618
    ql_dbg(16384U, vha, 57413, "qla_target(%d): Response pkt (ABTS_RECV_24XX) received, with unknown vp_index %d\n",
           (int )vha->vp_idx, (int )entry___3->vp_index);
#line 622
    goto ldv_61224;
  } else {

  }
#line 624
  qlt_response_pkt(host___3, pkt);
#line 625
  goto ldv_61224;
  default: 
#line 629
  qlt_response_pkt(vha, pkt);
#line 630
  goto ldv_61224;
  }
  ldv_61224: ;
#line 634
  return;
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_free_session_done(struct work_struct *work ) 
{ 
  struct qla_tgt_sess *sess ;
  struct work_struct  const  *__mptr ;
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  long tmp ;

  {
#line 637
  __mptr = (struct work_struct  const  *)work;
#line 637
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffa8UL;
#line 639
  tgt = sess->tgt;
#line 640
  vha = sess->vha;
#line 641
  ha = vha->hw;
#line 643
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 643
  if (tmp != 0L) {
#line 643
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (643), "i" (12UL));
    ldv_61247: ;
#line 643
    goto ldv_61247;
  } else {

  }
#line 647
  if ((unsigned long )sess->se_sess != (unsigned long )((struct se_session *)0)) {
#line 648
    (*((ha->tgt.tgt_ops)->free_session))(sess);
  } else {

  }
#line 650
  ql_dbg(8192U, vha, 61441, "Unregistration of sess %p finished\n", sess);
#line 653
  kfree((void const   *)sess);
#line 658
  tgt->sess_count = tgt->sess_count - 1;
#line 659
  if (tgt->sess_count == 0) {
#line 660
    __wake_up(& tgt->waitQ, 3U, 0, (void *)0);
  } else {

  }
#line 661
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_unreg_sess(struct qla_tgt_sess *sess ) 
{ 
  struct scsi_qla_host *vha ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 666
  vha = sess->vha;
#line 668
  (*(((vha->hw)->tgt.tgt_ops)->clear_nacl_from_fcport_map))(sess);
#line 670
  list_del(& sess->sess_list_entry);
#line 671
  if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 672
    list_del(& sess->del_list_entry);
  } else {

  }
#line 674
  __init_work(& sess->free_work, 0);
#line 674
  __constr_expr_0.counter = 137438953408L;
#line 674
  sess->free_work.data = __constr_expr_0;
#line 674
  lockdep_init_map(& sess->free_work.lockdep_map, "(&sess->free_work)", & __key, 0);
#line 674
  INIT_LIST_HEAD(& sess->free_work.entry);
#line 674
  sess->free_work.func = & qlt_free_session_done;
#line 675
  schedule_work(& sess->free_work);
#line 676
  return;
}
}
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_reset(struct scsi_qla_host *vha , void *iocb , int mcmd ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  uint32_t unpacked_lun ;
  uint32_t lun ;
  uint16_t loop_id ;
  int res ;
  struct imm_ntfy_from_isp *n ;
  struct atio_from_isp *a ;
  int tmp ;
  int tmp___0 ;

  {
#line 682
  ha = vha->hw;
#line 683
  sess = (struct qla_tgt_sess *)0;
#line 684
  lun = 0U;
#line 686
  res = 0;
#line 687
  n = (struct imm_ntfy_from_isp *)iocb;
#line 688
  a = (struct atio_from_isp *)iocb;
#line 690
  loop_id = n->u.isp24.nport_handle;
#line 691
  if ((unsigned int )loop_id == 65535U) {

  } else {
#line 721
    sess = (*((ha->tgt.tgt_ops)->find_sess_by_loop_id))(vha, (int )loop_id);
  }
#line 724
  ql_dbg(16384U, vha, 57344, "Using sess for qla_tgt_reset: %p\n", sess);
#line 726
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 727
    res = -3;
#line 728
    return (res);
  } else {

  }
#line 731
  ql_dbg(16384U, vha, 57415, "scsi(%ld): resetting (session %p from port %8phC mcmd %x, loop_id %d)\n",
         vha->host_no, sess, (uint8_t *)(& sess->port_name), mcmd, (int )loop_id);
#line 736
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 737
  tmp = scsilun_to_int((struct scsi_lun *)(& lun));
#line 737
  unpacked_lun = (uint32_t )tmp;
#line 739
  tmp___0 = qlt_issue_task_mgmt(sess, unpacked_lun, mcmd, iocb, 1);
#line 739
  return (tmp___0);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_schedule_sess_for_deletion(struct qla_tgt_sess *sess , bool immediate ) 
{ 
  struct qla_tgt *tgt ;
  uint32_t dev_loss_tmo ;

  {
#line 747
  tgt = sess->tgt;
#line 748
  dev_loss_tmo = (uint32_t )((tgt->ha)->port_down_retry_count + 5);
#line 750
  if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 751
    return;
  } else {

  }
#line 753
  ql_dbg(16384U, sess->vha, 57345, "Scheduling sess %p for deletion\n", sess);
#line 755
  list_add_tail(& sess->del_list_entry, & tgt->del_sess_list);
#line 756
  sess->deleted = 1U;
#line 758
  if ((int )immediate) {
#line 759
    dev_loss_tmo = 0U;
  } else {

  }
#line 761
  sess->expires = (unsigned long )(dev_loss_tmo * 250U) + (unsigned long )jiffies;
#line 763
  ql_dbg(16384U, sess->vha, 57416, "qla_target(%d): session for port %8phC (loop ID %d) scheduled for deletion in %u secs (expires: %lu) immed: %d\n",
         (int )(sess->vha)->vp_idx, (uint8_t *)(& sess->port_name), (int )sess->loop_id,
         dev_loss_tmo, sess->expires, (int )immediate);
#line 769
  if ((int )immediate) {
#line 770
    schedule_delayed_work(& tgt->sess_del_work, 0UL);
  } else {
#line 772
    schedule_delayed_work(& tgt->sess_del_work, (unsigned long )jiffies - sess->expires);
  }
#line 774
  return;
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_clear_tgt_db(struct qla_tgt *tgt , bool local_only ) 
{ 
  struct qla_tgt_sess *sess ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 781
  __mptr = (struct list_head  const  *)tgt->sess_list.next;
#line 781
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 781
  goto ldv_61289;
  ldv_61288: 
#line 782
  qlt_schedule_sess_for_deletion(sess, 1);
#line 781
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 781
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_61289: ;
#line 781
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& tgt->sess_list)) {
#line 783
    goto ldv_61288;
  } else {

  }

#line 788
  return;
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qla24xx_get_loop_id(struct scsi_qla_host *vha , uint8_t const   *s_id ,
                               uint16_t *loop_id ) 
{ 
  struct qla_hw_data *ha ;
  dma_addr_t gid_list_dma ;
  struct gid_list_info *gid_list ;
  char *id_iter ;
  int res ;
  int rc ;
  int i ;
  uint16_t entries ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct gid_list_info *gid ;
  int tmp___2 ;

  {
#line 790
  ha = vha->hw;
#line 797
  tmp = qla2x00_gid_list_size(ha);
#line 797
  tmp___0 = dma_alloc_attrs(& (ha->pdev)->dev, (size_t )tmp, & gid_list_dma, 208U,
                            (struct dma_attrs *)0);
#line 797
  gid_list = (struct gid_list_info *)tmp___0;
#line 799
  if ((unsigned long )gid_list == (unsigned long )((struct gid_list_info *)0)) {
#line 800
    tmp___1 = qla2x00_gid_list_size(ha);
#line 800
    ql_dbg(8192U, vha, 61508, "qla_target(%d): DMA Alloc failed of %u\n", (int )vha->vp_idx,
           tmp___1);
#line 803
    return (-12);
  } else {

  }
#line 807
  rc = qla2x00_get_id_list(vha, (void *)gid_list, gid_list_dma, & entries);
#line 808
  if (rc != 0) {
#line 809
    ql_dbg(8192U, vha, 61509, "qla_target(%d): get_id_list() failed: %x\n", (int )vha->vp_idx,
           rc);
#line 812
    res = -1;
#line 813
    goto out_free_id_list;
  } else {

  }
#line 816
  id_iter = (char *)gid_list;
#line 817
  res = -1;
#line 818
  i = 0;
#line 818
  goto ldv_61308;
  ldv_61307: 
#line 819
  gid = (struct gid_list_info *)id_iter;
#line 820
  if (((int )gid->al_pa == (int )((unsigned char )*(s_id + 2UL)) && (int )gid->area == (int )((unsigned char )*(s_id + 1UL))) && (int )gid->domain == (int )((unsigned char )*s_id)) {
#line 823
    *loop_id = gid->loop_id;
#line 824
    res = 0;
#line 825
    goto ldv_61306;
  } else {

  }
#line 827
  id_iter = id_iter + (unsigned long )ha->gid_list_info_size;
#line 818
  i = i + 1;
  ldv_61308: ;
#line 818
  if ((int )entries > i) {
#line 820
    goto ldv_61307;
  } else {

  }
  ldv_61306: ;
  out_free_id_list: 
#line 831
  tmp___2 = qla2x00_gid_list_size(ha);
#line 831
  dma_free_attrs(& (ha->pdev)->dev, (size_t )tmp___2, (void *)gid_list, gid_list_dma,
                 (struct dma_attrs *)0);
#line 833
  return (res);
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_undelete_sess(struct qla_tgt_sess *sess ) 
{ 
  long tmp ;

  {
#line 839
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)sess + 8UL) == 0U, 0L);
#line 839
  if (tmp != 0L) {
#line 839
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (839), "i" (12UL));
    ldv_61312: ;
#line 839
    goto ldv_61312;
  } else {

  }
#line 841
  list_del(& sess->del_list_entry);
#line 842
  sess->deleted = 0U;
#line 843
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_del_sess_work_fn(struct delayed_work *work ) 
{ 
  struct qla_tgt *tgt ;
  struct delayed_work  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 847
  __mptr = (struct delayed_work  const  *)work;
#line 847
  tgt = (struct qla_tgt *)__mptr + 0xffffffffffffffb0UL;
#line 849
  vha = tgt->vha;
#line 850
  ha = vha->hw;
#line 854
  tmp = spinlock_check(& ha->hardware_lock);
#line 854
  flags = _raw_spin_lock_irqsave(tmp);
#line 855
  goto ldv_61336;
  ldv_61335: 
#line 856
  __mptr___0 = (struct list_head  const  *)tgt->del_sess_list.next;
#line 856
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffc0UL;
#line 858
  if ((long )((unsigned long )jiffies - sess->expires) >= 0L) {
#line 859
    qlt_undelete_sess(sess);
#line 861
    ql_dbg(8192U, vha, 61444, "Timeout: sess %p about to be deleted\n", sess);
#line 864
    (*((ha->tgt.tgt_ops)->shutdown_sess))(sess);
#line 865
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {
#line 867
    schedule_delayed_work(& tgt->sess_del_work, (unsigned long )jiffies - sess->expires);
#line 869
    goto ldv_61334;
  }
  ldv_61336: 
#line 855
  tmp___0 = list_empty((struct list_head  const  *)(& tgt->del_sess_list));
#line 855
  if (tmp___0 == 0) {
#line 857
    goto ldv_61335;
  } else {

  }
  ldv_61334: 
#line 872
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 873
  return;
}
}
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct qla_tgt_sess *qlt_create_sess(struct scsi_qla_host *vha , fc_port_t *fcport ,
                                            bool local ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  unsigned char be_sid[3U] ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  raw_spinlock_t *tmp___3 ;

  {
#line 884
  ha = vha->hw;
#line 890
  tmp = spinlock_check(& ha->hardware_lock);
#line 890
  flags = _raw_spin_lock_irqsave(tmp);
#line 891
  __mptr = (struct list_head  const  *)(ha->tgt.qla_tgt)->sess_list.next;
#line 891
  sess = (struct qla_tgt_sess *)__mptr + 0xffffffffffffffd8UL;
#line 891
  goto ldv_61354;
  ldv_61353: 
#line 893
  tmp___0 = memcmp((void const   *)(& sess->port_name), (void const   *)(& fcport->port_name),
                   8UL);
#line 893
  if (tmp___0 == 0) {
#line 894
    ql_dbg(8192U, vha, 61445, "Double sess %p found (s_id %x:%x:%x, loop_id %d), updating to d_id %x:%x:%x, loop_id %d",
           sess, (int )sess->s_id.b.domain, (int )sess->s_id.b.al_pa, (int )sess->s_id.b.area,
           (int )sess->loop_id, (int )fcport->d_id.b.domain, (int )fcport->d_id.b.al_pa,
           (int )fcport->d_id.b.area, (int )fcport->loop_id);
#line 903
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 904
      qlt_undelete_sess(sess);
    } else {

    }
#line 906
    kref_get(& (sess->se_sess)->sess_kref);
#line 907
    (*((ha->tgt.tgt_ops)->update_sess))(sess, fcport->d_id, (int )fcport->loop_id,
                                        (fcport->flags & 16U) != 0U);
#line 910
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U && ! local) {
#line 911
      sess->local = 0U;
    } else {

    }
#line 912
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 914
    return (sess);
  } else {

  }
#line 891
  __mptr___0 = (struct list_head  const  *)sess->sess_list_entry.next;
#line 891
  sess = (struct qla_tgt_sess *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_61354: ;
#line 891
  if ((unsigned long )(& sess->sess_list_entry) != (unsigned long )(& (ha->tgt.qla_tgt)->sess_list)) {
#line 893
    goto ldv_61353;
  } else {

  }
#line 917
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 919
  tmp___1 = kzalloc(168UL, 208U);
#line 919
  sess = (struct qla_tgt_sess *)tmp___1;
#line 920
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 921
    ql_dbg(8192U, vha, 61514, "qla_target(%u): session allocation failed, all commands from port %8phC will be refused",
           (int )vha->vp_idx, (uint8_t *)(& fcport->port_name));
#line 926
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 928
  sess->tgt = ha->tgt.qla_tgt;
#line 929
  sess->vha = vha;
#line 930
  sess->s_id = fcport->d_id;
#line 931
  sess->loop_id = fcport->loop_id;
#line 932
  sess->local = (unsigned char )local;
#line 934
  ql_dbg(8192U, vha, 61446, "Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",
         sess, ha->tgt.qla_tgt);
#line 938
  be_sid[0] = sess->s_id.b.domain;
#line 939
  be_sid[1] = sess->s_id.b.area;
#line 940
  be_sid[2] = sess->s_id.b.al_pa;
#line 947
  tmp___2 = (*((ha->tgt.tgt_ops)->check_initiator_node_acl))(vha, (unsigned char *)(& fcport->port_name),
                                                             (void *)sess, (uint8_t *)(& be_sid),
                                                             (int )fcport->loop_id);
#line 947
  if (tmp___2 < 0) {
#line 949
    kfree((void const   *)sess);
#line 950
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 956
  kref_get(& (sess->se_sess)->sess_kref);
#line 958
  sess->conf_compl_supported = 0U;
#line 960
  __len = 8UL;
#line 960
  if (__len > 63UL) {
#line 960
    __ret = __memcpy((void *)(& sess->port_name), (void const   *)(& fcport->port_name),
                     __len);
  } else {
#line 960
    __ret = __builtin_memcpy((void *)(& sess->port_name), (void const   *)(& fcport->port_name),
                             __len);
  }
#line 962
  tmp___3 = spinlock_check(& ha->hardware_lock);
#line 962
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 963
  list_add_tail(& sess->sess_list_entry, & (ha->tgt.qla_tgt)->sess_list);
#line 964
  (ha->tgt.qla_tgt)->sess_count = (ha->tgt.qla_tgt)->sess_count + 1;
#line 965
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 967
  ql_dbg(8192U, vha, 61515, "qla_target(%d): %ssession for wwn %8phC (loop_id %d, s_id %x:%x:%x, confirmed completion %ssupported) added\n",
         (int )vha->vp_idx, (int )local ? (char *)"local " : (char *)"", (uint8_t *)(& fcport->port_name),
         (int )fcport->loop_id, (int )sess->s_id.b.domain, (int )sess->s_id.b.area,
         (int )sess->s_id.b.al_pa, (unsigned int )*((unsigned char *)sess + 8UL) != 0U ? (char *)"" : (char *)"not ");
#line 974
  return (sess);
}
}
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_fc_port_added(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 982
  ha = vha->hw;
#line 983
  tgt = ha->tgt.qla_tgt;
#line 987
  if ((unsigned long )(vha->hw)->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 988
    return;
  } else {

  }
#line 990
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0) || (unsigned int )fcport->port_type != 4U) {
#line 991
    return;
  } else {

  }
#line 993
  tmp = spinlock_check(& ha->hardware_lock);
#line 993
  flags = _raw_spin_lock_irqsave(tmp);
#line 994
  if (tgt->tgt_stop != 0) {
#line 995
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 996
    return;
  } else {

  }
#line 998
  sess = qlt_find_sess_by_port_name(tgt, (uint8_t const   *)(& fcport->port_name));
#line 999
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 1000
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1002
    mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 1003
    sess = qlt_create_sess(vha, fcport, 0);
#line 1004
    mutex_unlock(& ha->tgt.tgt_mutex);
#line 1006
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1006
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {
#line 1008
    kref_get(& (sess->se_sess)->sess_kref);
#line 1010
    if ((unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 1011
      qlt_undelete_sess(sess);
#line 1013
      ql_dbg(8192U, vha, 61516, "qla_target(%u): %ssession for port %8phC (loop ID %d) reappeared\n",
             (int )vha->vp_idx, (unsigned int )*((unsigned char *)sess + 8UL) != 0U ? (char *)"local " : (char *)"",
             (uint8_t *)(& sess->port_name), (int )sess->loop_id);
#line 1019
      ql_dbg(8192U, vha, 61447, "Reappeared sess %p\n", sess);
    } else {

    }
#line 1022
    (*((ha->tgt.tgt_ops)->update_sess))(sess, fcport->d_id, (int )fcport->loop_id,
                                        (fcport->flags & 16U) != 0U);
  }
#line 1026
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0) && (unsigned int )*((unsigned char *)sess + 8UL) != 0U) {
#line 1027
    ql_dbg(8192U, vha, 61517, "qla_target(%u): local session for port %8phC (loop ID %d) became global\n",
           (int )vha->vp_idx, (uint8_t *)(& fcport->port_name), (int )sess->loop_id);
#line 1031
    sess->local = 0U;
  } else {

  }
#line 1033
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 1034
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1035
  return;
}
}
#line 1037 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_fc_port_deleted(struct scsi_qla_host *vha , fc_port_t *fcport ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1039
  ha = vha->hw;
#line 1040
  tgt = ha->tgt.qla_tgt;
#line 1044
  if ((unsigned long )(vha->hw)->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 1045
    return;
  } else {

  }
#line 1047
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0) || (unsigned int )fcport->port_type != 4U) {
#line 1048
    return;
  } else {

  }
#line 1050
  tmp = spinlock_check(& ha->hardware_lock);
#line 1050
  flags = _raw_spin_lock_irqsave(tmp);
#line 1051
  if (tgt->tgt_stop != 0) {
#line 1052
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1053
    return;
  } else {

  }
#line 1055
  sess = qlt_find_sess_by_port_name(tgt, (uint8_t const   *)(& fcport->port_name));
#line 1056
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 1057
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1058
    return;
  } else {

  }
#line 1061
  ql_dbg(8192U, vha, 61448, "qla_tgt_fc_port_deleted %p", sess);
#line 1063
  sess->local = 1U;
#line 1064
  qlt_schedule_sess_for_deletion(sess, 0);
#line 1065
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1066
  return;
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int test_tgt_sess_count(struct qla_tgt *tgt ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  int res ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 1070
  ha = tgt->ha;
#line 1077
  tmp = spinlock_check(& ha->hardware_lock);
#line 1077
  flags = _raw_spin_lock_irqsave(tmp);
#line 1078
  tmp___0 = list_empty((struct list_head  const  *)(& tgt->sess_list));
#line 1078
  ql_dbg(16384U, tgt->vha, 57346, "tgt %p, empty(sess_list)=%d sess_count=%d\n", tgt,
         tmp___0, tgt->sess_count);
#line 1081
  res = tgt->sess_count == 0;
#line 1082
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1084
  return (res);
}
}
#line 1088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_stop_phase1(struct qla_tgt *tgt ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___9 ;
  int tmp___10 ;

  {
#line 1090
  vha = tgt->vha;
#line 1091
  ha = tgt->ha;
#line 1094
  if (tgt->tgt_stop != 0 || tgt->tgt_stopped != 0) {
#line 1095
    ql_dbg(8192U, vha, 61518, "Already in tgt->tgt_stop or tgt_stopped state\n");
#line 1097
    dump_stack();
#line 1098
    return;
  } else {

  }
#line 1101
  ql_dbg(16384U, vha, 57347, "Stopping target for host %ld(%p)\n", vha->host_no, vha);
#line 1107
  mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 1108
  tmp = spinlock_check(& ha->hardware_lock);
#line 1108
  flags = _raw_spin_lock_irqsave(tmp);
#line 1109
  tgt->tgt_stop = 1;
#line 1110
  qlt_clear_tgt_db(tgt, 1);
#line 1111
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1112
  mutex_unlock(& ha->tgt.tgt_mutex);
#line 1114
  flush_delayed_work(& tgt->sess_del_work);
#line 1116
  ql_dbg(8192U, vha, 61449, "Waiting for sess works (tgt %p)", tgt);
#line 1118
  tmp___0 = spinlock_check(& tgt->sess_work_lock);
#line 1118
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1119
  goto ldv_61412;
  ldv_61411: 
#line 1120
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 1121
  flush_scheduled_work();
#line 1122
  tmp___1 = spinlock_check(& tgt->sess_work_lock);
#line 1122
  flags = _raw_spin_lock_irqsave(tmp___1);
  ldv_61412: 
#line 1119
  tmp___2 = list_empty((struct list_head  const  *)(& tgt->sess_works_list));
#line 1119
  if (tmp___2 == 0) {
#line 1121
    goto ldv_61411;
  } else {

  }
#line 1124
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 1126
  tmp___3 = list_empty((struct list_head  const  *)(& tgt->sess_list));
#line 1126
  ql_dbg(8192U, vha, 61450, "Waiting for tgt %p: list_empty(sess_list)=%d sess_count=%d\n",
         tgt, tmp___3, tgt->sess_count);
#line 1131
  tmp___4 = test_tgt_sess_count(tgt);
#line 1131
  if (tmp___4 != 0) {
#line 1131
    goto ldv_61414;
  } else {

  }
#line 1131
  tmp___5 = get_current();
#line 1131
  __wait.flags = 0U;
#line 1131
  __wait.private = (void *)tmp___5;
#line 1131
  __wait.func = & autoremove_wake_function;
#line 1131
  __wait.task_list.next = & __wait.task_list;
#line 1131
  __wait.task_list.prev = & __wait.task_list;
  ldv_61417: 
#line 1131
  prepare_to_wait(& tgt->waitQ, & __wait, 2);
#line 1131
  tmp___6 = test_tgt_sess_count(tgt);
#line 1131
  if (tmp___6 != 0) {
#line 1131
    goto ldv_61416;
  } else {

  }
#line 1131
  schedule();
#line 1131
  goto ldv_61417;
  ldv_61416: 
#line 1131
  finish_wait(& tgt->waitQ, & __wait);
  ldv_61414: ;
#line 1134
  if (*((unsigned long *)ha + 2UL) == 0UL) {
#line 1134
    tmp___7 = qla_tgt_mode_enabled(vha);
#line 1134
    if ((int )tmp___7) {
#line 1135
      qlt_disable_vha(vha);
    } else {

    }
  } else {

  }
#line 1138
  tmp___8 = test_tgt_sess_count(tgt);
#line 1138
  if (tmp___8 != 0) {
#line 1138
    goto ldv_61418;
  } else {

  }
#line 1138
  tmp___9 = get_current();
#line 1138
  __wait___0.flags = 0U;
#line 1138
  __wait___0.private = (void *)tmp___9;
#line 1138
  __wait___0.func = & autoremove_wake_function;
#line 1138
  __wait___0.task_list.next = & __wait___0.task_list;
#line 1138
  __wait___0.task_list.prev = & __wait___0.task_list;
  ldv_61421: 
#line 1138
  prepare_to_wait(& tgt->waitQ, & __wait___0, 2);
#line 1138
  tmp___10 = test_tgt_sess_count(tgt);
#line 1138
  if (tmp___10 != 0) {
#line 1138
    goto ldv_61420;
  } else {

  }
#line 1138
  schedule();
#line 1138
  goto ldv_61421;
  ldv_61420: 
#line 1138
  finish_wait(& tgt->waitQ, & __wait___0);
  ldv_61418: ;
#line 1141
  return;
}
}
#line 1143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_stop_phase2(struct qla_tgt *tgt ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1145
  ha = tgt->ha;
#line 1148
  if (tgt->tgt_stopped != 0) {
#line 1149
    ql_dbg(8192U, tgt->vha, 61519, "Already in tgt->tgt_stopped state\n");
#line 1151
    dump_stack();
#line 1152
    return;
  } else {

  }
#line 1155
  ql_dbg(8192U, tgt->vha, 61451, "Waiting for %d IRQ commands to complete (tgt %p)",
         tgt->irq_cmd_count, tgt);
#line 1159
  mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 1160
  tmp = spinlock_check(& ha->hardware_lock);
#line 1160
  flags = _raw_spin_lock_irqsave(tmp);
#line 1161
  goto ldv_61440;
  ldv_61439: 
#line 1162
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1163
  __const_udelay(8590UL);
#line 1164
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 1164
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_61440: ;
#line 1161
  if (tgt->irq_cmd_count != 0) {
#line 1163
    goto ldv_61439;
  } else {

  }
#line 1166
  tgt->tgt_stop = 0;
#line 1167
  tgt->tgt_stopped = 1;
#line 1168
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1169
  mutex_unlock(& ha->tgt.tgt_mutex);
#line 1171
  ql_dbg(8192U, tgt->vha, 61452, "Stop of tgt %p finished", tgt);
#line 1172
  return;
}
}
#line 1177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_release(struct qla_tgt *tgt ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 1179
  ha = tgt->ha;
#line 1181
  if ((unsigned long )ha->tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0) && tgt->tgt_stopped == 0) {
#line 1182
    qlt_stop_phase2(tgt);
  } else {

  }
#line 1184
  ha->tgt.qla_tgt = (struct qla_tgt *)0;
#line 1186
  ql_dbg(8192U, tgt->vha, 61453, "Release of tgt %p finished\n", tgt);
#line 1189
  kfree((void const   *)tgt);
#line 1190
  return;
}
}
#line 1193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_sched_sess_work(struct qla_tgt *tgt , int type , void const   *param ,
                               unsigned int param_size ) 
{ 
  struct qla_tgt_sess_work_param *prm ;
  unsigned long flags ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1199
  tmp = kzalloc(88UL, 32U);
#line 1199
  prm = (struct qla_tgt_sess_work_param *)tmp;
#line 1200
  if ((unsigned long )prm == (unsigned long )((struct qla_tgt_sess_work_param *)0)) {
#line 1201
    ql_dbg(8192U, tgt->vha, 61520, "qla_target(%d): Unable to create session work, command will be refused",
           0);
#line 1204
    return (-12);
  } else {

  }
#line 1207
  ql_dbg(8192U, tgt->vha, 61454, "Scheduling work (type %d, prm %p) to find session for param %p (size %d, tgt %p)\n",
         type, prm, param, param_size, tgt);
#line 1212
  prm->type = type;
#line 1213
  __len = (size_t )param_size;
#line 1213
  __ret = __builtin_memcpy((void *)(& prm->ldv_60976.tm_iocb), param, __len);
#line 1215
  tmp___0 = spinlock_check(& tgt->sess_work_lock);
#line 1215
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1216
  list_add_tail(& prm->sess_works_list_entry, & tgt->sess_works_list);
#line 1217
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 1219
  schedule_work(& tgt->sess_work);
#line 1221
  return (0);
}
}
#line 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_send_notify_ack(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *ntfy ,
                                uint32_t add_flags , uint16_t resp_code , int resp_code_valid ,
                                uint16_t srr_flags , uint16_t srr_reject_code , uint8_t srr_explan ) 
{ 
  struct qla_hw_data *ha ;
  request_t *pkt ;
  struct nack_to_isp *nack ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1232
  ha = vha->hw;
#line 1236
  ql_dbg(16384U, vha, 57348, "Sending NOTIFY_ACK (ha=%p)\n", ha);
#line 1239
  tmp = qlt_issue_marker(vha, 1);
#line 1239
  if (tmp != 0) {
#line 1240
    return;
  } else {

  }
#line 1242
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 1242
  pkt = (request_t *)tmp___0;
#line 1243
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 1244
    ql_dbg(16384U, vha, 57417, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "qlt_send_notify_ack");
#line 1247
    return;
  } else {

  }
#line 1250
  if ((unsigned long )ha->tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0)) {
#line 1251
    (ha->tgt.qla_tgt)->notify_ack_expected = (ha->tgt.qla_tgt)->notify_ack_expected + 1;
  } else {

  }
#line 1253
  pkt->entry_type = 14U;
#line 1254
  pkt->entry_count = 1U;
#line 1256
  nack = (struct nack_to_isp *)pkt;
#line 1257
  nack->ox_id = ntfy->ox_id;
#line 1259
  nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
#line 1260
  if ((unsigned int )ntfy->u.isp24.status == 70U) {
#line 1261
    nack->u.isp24.flags = (unsigned int )ntfy->u.isp24.flags & 1U;
  } else {

  }
#line 1264
  nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
#line 1265
  nack->u.isp24.status = ntfy->u.isp24.status;
#line 1266
  nack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;
#line 1267
  nack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;
#line 1268
  nack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;
#line 1269
  nack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;
#line 1270
  nack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;
#line 1271
  nack->u.isp24.srr_flags = srr_flags;
#line 1272
  nack->u.isp24.srr_reject_code = (uint8_t )srr_reject_code;
#line 1273
  nack->u.isp24.srr_reject_code_expl = srr_explan;
#line 1274
  nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
#line 1276
  ql_dbg(16384U, vha, 57349, "qla_target(%d): Sending 24xx Notify Ack %d\n", (int )vha->vp_idx,
         (int )nack->u.isp24.status);
#line 1280
  qla2x00_start_iocbs(vha, vha->req);
#line 1281
  return;
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_send_abts_resp(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ,
                                    uint32_t status , bool ids_reversed ) 
{ 
  struct qla_hw_data *ha ;
  struct abts_resp_to_24xx *resp ;
  uint32_t f_ctl ;
  uint8_t *p ;
  int tmp ;
  void *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
#line 1290
  ha = vha->hw;
#line 1295
  ql_dbg(16384U, vha, 57350, "Sending task mgmt ABTS response (ha=%p, atio=%p, status=%x\n",
         ha, abts, status);
#line 1300
  tmp = qlt_issue_marker(vha, 1);
#line 1300
  if (tmp != 0) {
#line 1301
    return;
  } else {

  }
#line 1303
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 1303
  resp = (struct abts_resp_to_24xx *)tmp___0;
#line 1304
  if ((unsigned long )resp == (unsigned long )((struct abts_resp_to_24xx *)0)) {
#line 1305
    ql_dbg(16384U, vha, 57418, "qla_target(%d): %s failed: unable to allocate request packet",
           (int )vha->vp_idx, "qlt_24xx_send_abts_resp");
#line 1308
    return;
  } else {

  }
#line 1311
  resp->entry_type = 85U;
#line 1312
  resp->entry_count = 1U;
#line 1313
  resp->nport_handle = abts->nport_handle;
#line 1314
  resp->vp_index = (uint8_t )vha->vp_idx;
#line 1315
  resp->sof_type = abts->sof_type;
#line 1316
  resp->exchange_address = abts->exchange_address;
#line 1317
  resp->fcp_hdr_le = abts->fcp_hdr_le;
#line 1318
  f_ctl = 10027008U;
#line 1321
  p = (uint8_t *)(& f_ctl);
#line 1322
  tmp___1 = p;
#line 1322
  p = p + 1;
#line 1322
  resp->fcp_hdr_le.f_ctl[0] = *tmp___1;
#line 1323
  tmp___2 = p;
#line 1323
  p = p + 1;
#line 1323
  resp->fcp_hdr_le.f_ctl[1] = *tmp___2;
#line 1324
  resp->fcp_hdr_le.f_ctl[2] = *p;
#line 1325
  if ((int )ids_reversed) {
#line 1326
    resp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.d_id[0];
#line 1327
    resp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.d_id[1];
#line 1328
    resp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.d_id[2];
#line 1329
    resp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.s_id[0];
#line 1330
    resp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1331
    resp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.s_id[2];
  } else {
#line 1333
    resp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.s_id[0];
#line 1334
    resp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1335
    resp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.s_id[2];
#line 1336
    resp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.d_id[0];
#line 1337
    resp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.d_id[1];
#line 1338
    resp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.d_id[2];
  }
#line 1340
  resp->exchange_addr_to_abort = abts->exchange_addr_to_abort;
#line 1341
  if (status == 0U) {
#line 1342
    resp->fcp_hdr_le.r_ctl = 132U;
#line 1343
    resp->payload.ba_acct.seq_id_valid = 0U;
#line 1344
    resp->payload.ba_acct.low_seq_cnt = 0U;
#line 1345
    resp->payload.ba_acct.high_seq_cnt = 65535U;
#line 1346
    resp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;
#line 1347
    resp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;
  } else {
#line 1349
    resp->fcp_hdr_le.r_ctl = 133U;
#line 1350
    resp->payload.ba_rjt.reason_code = 9U;
  }
#line 1355
  (ha->tgt.qla_tgt)->abts_resp_expected = (ha->tgt.qla_tgt)->abts_resp_expected + 1;
#line 1357
  qla2x00_start_iocbs(vha, vha->req);
#line 1358
  return;
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_retry_term_exchange(struct scsi_qla_host *vha , struct abts_resp_from_24xx_fw *entry ) 
{ 
  struct ctio7_to_24xx *ctio ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1368
  ql_dbg(16384U, vha, 57351, "Sending retry TERM EXCH CTIO7 (ha=%p)\n", vha->hw);
#line 1371
  tmp = qlt_issue_marker(vha, 1);
#line 1371
  if (tmp != 0) {
#line 1372
    return;
  } else {

  }
#line 1374
  tmp___0 = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 1374
  ctio = (struct ctio7_to_24xx *)tmp___0;
#line 1375
  if ((unsigned long )ctio == (unsigned long )((struct ctio7_to_24xx *)0)) {
#line 1376
    ql_dbg(16384U, vha, 57419, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "qlt_24xx_retry_term_exchange");
#line 1379
    return;
  } else {

  }
#line 1387
  ctio->entry_type = 18U;
#line 1388
  ctio->entry_count = 1U;
#line 1389
  ctio->nport_handle = entry->nport_handle;
#line 1390
  ctio->handle = 4294967295U;
#line 1391
  ctio->timeout = 10U;
#line 1392
  ctio->vp_index = (uint8_t )vha->vp_idx;
#line 1393
  ctio->initiator_id[0] = entry->fcp_hdr_le.d_id[0];
#line 1394
  ctio->initiator_id[1] = entry->fcp_hdr_le.d_id[1];
#line 1395
  ctio->initiator_id[2] = entry->fcp_hdr_le.d_id[2];
#line 1396
  ctio->exchange_addr = entry->exchange_addr_to_abort;
#line 1397
  ctio->u.status1.flags = 16448U;
#line 1400
  ctio->u.status1.ox_id = entry->fcp_hdr_le.ox_id;
#line 1402
  qla2x00_start_iocbs(vha, vha->req);
#line 1404
  qlt_24xx_send_abts_resp(vha, (struct abts_recv_from_24xx *)entry, 0U, 1);
#line 1405
  return;
}
}
#line 1409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ,
                                  struct qla_tgt_sess *sess ) 
{ 
  struct qla_hw_data *ha ;
  struct se_session *se_sess ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  struct se_cmd *se_cmd ;
  u32 lun ;
  int rc ;
  bool found_lun ;
  struct list_head  const  *__mptr ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1412
  ha = vha->hw;
#line 1413
  se_sess = sess->se_sess;
#line 1416
  lun = 0U;
#line 1418
  found_lun = 0;
#line 1420
  spin_lock(& se_sess->sess_cmd_lock);
#line 1421
  __mptr = (struct list_head  const  *)se_sess->sess_cmd_list.next;
#line 1421
  se_cmd = (struct se_cmd *)__mptr + 0xffffffffffffff60UL;
#line 1421
  goto ldv_61518;
  ldv_61517: 
#line 1423
  __mptr___0 = (struct se_cmd  const  *)se_cmd;
#line 1423
  cmd = (struct qla_tgt_cmd *)__mptr___0 + 0xfffffffffffffff0UL;
#line 1424
  if (cmd->tag == abts->exchange_addr_to_abort) {
#line 1425
    lun = cmd->unpacked_lun;
#line 1426
    found_lun = 1;
#line 1427
    goto ldv_61516;
  } else {

  }
#line 1421
  __mptr___1 = (struct list_head  const  *)se_cmd->se_cmd_list.next;
#line 1421
  se_cmd = (struct se_cmd *)__mptr___1 + 0xffffffffffffff60UL;
  ldv_61518: ;
#line 1421
  if ((unsigned long )(& se_cmd->se_cmd_list) != (unsigned long )(& se_sess->sess_cmd_list)) {
#line 1423
    goto ldv_61517;
  } else {

  }
  ldv_61516: 
#line 1430
  spin_unlock(& se_sess->sess_cmd_lock);
#line 1432
  if (! found_lun) {
#line 1433
    return (-2);
  } else {

  }
#line 1435
  ql_dbg(8192U, vha, 61455, "qla_target(%d): task abort (tag=%d)\n", (int )vha->vp_idx,
         abts->exchange_addr_to_abort);
#line 1439
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 1439
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 1440
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 1441
    ql_dbg(8192U, vha, 61521, "qla_target(%d): %s: Allocation of ABORT cmd failed",
           (int )vha->vp_idx, "__qlt_24xx_handle_abts");
#line 1444
    return (-12);
  } else {

  }
#line 1446
  memset((void *)mcmd, 0, 1152UL);
#line 1448
  mcmd->sess = sess;
#line 1449
  __len = 64UL;
#line 1449
  if (__len > 63UL) {
#line 1449
    __ret = __memcpy((void *)(& mcmd->orig_iocb.abts), (void const   *)abts, __len);
  } else {
#line 1449
    __ret = __builtin_memcpy((void *)(& mcmd->orig_iocb.abts), (void const   *)abts,
                             __len);
  }
#line 1451
  rc = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, lun, 1, abts->exchange_addr_to_abort);
#line 1453
  if (rc != 0) {
#line 1454
    ql_dbg(8192U, vha, 61522, "qla_target(%d):  tgt_ops->handle_tmr() failed: %d",
           (int )vha->vp_idx, rc);
#line 1457
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 1458
    return (-14);
  } else {

  }
#line 1461
  return (0);
}
}
#line 1467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_handle_abts(struct scsi_qla_host *vha , struct abts_recv_from_24xx *abts ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  uint32_t tag ;
  uint8_t s_id[3U] ;
  int rc ;

  {
#line 1470
  ha = vha->hw;
#line 1472
  tag = abts->exchange_addr_to_abort;
#line 1476
  if ((int )abts->fcp_hdr_le.parameter & 1) {
#line 1477
    ql_dbg(8192U, vha, 61523, "qla_target(%d): ABTS: Abort Sequence not supported\n",
           (int )vha->vp_idx);
#line 1480
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1481
    return;
  } else {

  }
#line 1484
  if (tag == 4294967295U) {
#line 1485
    ql_dbg(8192U, vha, 61456, "qla_target(%d): ABTS: Unknown Exchange Address received\n",
           (int )vha->vp_idx);
#line 1488
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1489
    return;
  } else {

  }
#line 1492
  ql_dbg(8192U, vha, 61457, "qla_target(%d): task abort (s_id=%x:%x:%x, tag=%d, param=%x)\n",
         (int )vha->vp_idx, (int )abts->fcp_hdr_le.s_id[2], (int )abts->fcp_hdr_le.s_id[1],
         (int )abts->fcp_hdr_le.s_id[0], tag, abts->fcp_hdr_le.parameter);
#line 1498
  s_id[0] = abts->fcp_hdr_le.s_id[2];
#line 1499
  s_id[1] = abts->fcp_hdr_le.s_id[1];
#line 1500
  s_id[2] = abts->fcp_hdr_le.s_id[0];
#line 1502
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& s_id));
#line 1503
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 1504
    ql_dbg(8192U, vha, 61458, "qla_target(%d): task abort for non-existant session\n",
           (int )vha->vp_idx);
#line 1507
    rc = qlt_sched_sess_work(ha->tgt.qla_tgt, 1, (void const   *)abts, 64U);
#line 1509
    if (rc != 0) {
#line 1510
      qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
    } else {

    }
#line 1513
    return;
  } else {

  }
#line 1516
  rc = __qlt_24xx_handle_abts(vha, abts, sess);
#line 1517
  if (rc != 0) {
#line 1518
    ql_dbg(8192U, vha, 61524, "qla_target(%d): __qlt_24xx_handle_abts() failed: %d\n",
           (int )vha->vp_idx, rc);
#line 1521
    qlt_24xx_send_abts_resp(vha, abts, 4U, 0);
#line 1522
    return;
  } else {

  }
#line 1524
  return;
}
}
#line 1529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_send_task_mgmt_ctio(struct scsi_qla_host *ha , struct qla_tgt_mgmt_cmd *mcmd ,
                                         uint32_t resp_code ) 
{ 
  struct atio_from_isp *atio ;
  struct ctio7_to_24xx *ctio ;
  int tmp ;
  void *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 1532
  atio = & mcmd->orig_iocb.atio;
#line 1535
  ql_dbg(16384U, ha, 57352, "Sending task mgmt CTIO7 (ha=%p, atio=%p, resp_code=%x\n",
         ha, atio, resp_code);
#line 1540
  tmp = qlt_issue_marker(ha, 1);
#line 1540
  if (tmp != 0) {
#line 1541
    return;
  } else {

  }
#line 1543
  tmp___0 = qla2x00_alloc_iocbs(ha, (srb_t *)0);
#line 1543
  ctio = (struct ctio7_to_24xx *)tmp___0;
#line 1544
  if ((unsigned long )ctio == (unsigned long )((struct ctio7_to_24xx *)0)) {
#line 1545
    ql_dbg(16384U, ha, 57420, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )ha->vp_idx, "qlt_24xx_send_task_mgmt_ctio");
#line 1548
    return;
  } else {

  }
#line 1551
  ctio->entry_type = 18U;
#line 1552
  ctio->entry_count = 1U;
#line 1553
  ctio->handle = 4294967295U;
#line 1554
  ctio->nport_handle = (mcmd->sess)->loop_id;
#line 1555
  ctio->timeout = 10U;
#line 1556
  ctio->vp_index = (uint8_t )ha->vp_idx;
#line 1557
  ctio->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 1558
  ctio->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 1559
  ctio->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 1560
  ctio->exchange_addr = atio->u.isp24.exchange_addr;
#line 1561
  ctio->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | -32704);
#line 1564
  tmp___1 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 1564
  ctio->u.status1.ox_id = tmp___1;
#line 1565
  ctio->u.status1.scsi_status = 256U;
#line 1567
  ctio->u.status1.response_len = 8U;
#line 1568
  ctio->u.status1.sense_data[0] = (uint8_t )resp_code;
#line 1570
  qla2x00_start_iocbs(ha, ha->req);
#line 1571
  return;
}
}
#line 1573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd ) 
{ 


  {
#line 1575
  mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 1576
  return;
}
}
#line 1580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1582
  vha = (mcmd->sess)->vha;
#line 1583
  ha = vha->hw;
#line 1586
  ql_dbg(8192U, vha, 61459, "TM response mcmd (%p) status %#x state %#x", mcmd, (int )mcmd->fc_tm_rsp,
         mcmd->flags);
#line 1590
  tmp = spinlock_check(& ha->hardware_lock);
#line 1590
  flags = _raw_spin_lock_irqsave(tmp);
#line 1591
  if (mcmd->flags == 1U) {
#line 1592
    qlt_send_notify_ack(vha, & mcmd->orig_iocb.imm_ntfy, 0U, 0, 0, 0, 0, 0);
  } else
#line 1595
  if ((unsigned int )(mcmd->se_cmd.se_tmr_req)->function == 1U) {
#line 1596
    qlt_24xx_send_abts_resp(vha, & mcmd->orig_iocb.abts, (uint32_t )mcmd->fc_tm_rsp,
                            0);
  } else {
#line 1599
    qlt_24xx_send_task_mgmt_ctio(vha, mcmd, (uint32_t )mcmd->fc_tm_rsp);
  }
#line 1610
  (*((ha->tgt.tgt_ops)->free_mcmd))(mcmd);
#line 1611
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 1612
  return;
}
}
#line 1616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_pci_map_calc_cnt(struct qla_tgt_prm *prm ) 
{ 
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  long tmp___0 ;

  {
#line 1618
  cmd = prm->cmd;
#line 1620
  tmp = ldv__builtin_expect(cmd->sg_cnt == 0, 0L);
#line 1620
  if (tmp != 0L) {
#line 1620
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (1620), "i" (12UL));
    ldv_61568: ;
#line 1620
    goto ldv_61568;
  } else {

  }
#line 1622
  prm->sg = cmd->sg;
#line 1623
  prm->seg_cnt = pci_map_sg(((prm->tgt)->ha)->pdev, cmd->sg, cmd->sg_cnt, (int )cmd->dma_data_direction);
#line 1625
  tmp___0 = ldv__builtin_expect(prm->seg_cnt == 0, 0L);
#line 1625
  if (tmp___0 != 0L) {
#line 1626
    goto out_err;
  } else {

  }
#line 1628
  (prm->cmd)->sg_mapped = 1U;
#line 1634
  if (prm->seg_cnt > (prm->tgt)->datasegs_per_cmd) {
#line 1635
    prm->req_cnt = prm->req_cnt + (((prm->seg_cnt - (prm->tgt)->datasegs_per_cmd) + (prm->tgt)->datasegs_per_cont) + -1) / (prm->tgt)->datasegs_per_cont;
  } else {

  }
#line 1638
  ql_dbg(16384U, (prm->cmd)->vha, 57353, "seg_cnt=%d, req_cnt=%d\n", prm->seg_cnt,
         prm->req_cnt);
#line 1640
  return (0);
  out_err: 
#line 1643
  ql_dbg(16384U, (prm->cmd)->vha, 57421, "qla_target(%d): PCI mapping failed: sg_cnt=%d",
         0, (prm->cmd)->sg_cnt);
#line 1646
  return (-1);
}
}
#line 1649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static void qlt_unmap_sg(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ) 
{ 
  struct qla_hw_data *ha ;
  long tmp ;

  {
#line 1652
  ha = vha->hw;
#line 1654
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1256UL) == 0U, 0L);
#line 1654
  if (tmp != 0L) {
#line 1654
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (1654), "i" (12UL));
    ldv_61575: ;
#line 1654
    goto ldv_61575;
  } else {

  }
#line 1655
  pci_unmap_sg(ha->pdev, cmd->sg, cmd->sg_cnt, (int )cmd->dma_data_direction);
#line 1656
  cmd->sg_mapped = 0U;
#line 1657
  return;
}
}
#line 1659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_check_reserve_free_req(struct scsi_qla_host *vha , uint32_t req_cnt ) 
{ 
  struct qla_hw_data *ha ;
  device_reg_t *reg ;
  uint32_t cnt ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 1662
  ha = vha->hw;
#line 1663
  reg = ha->iobase;
#line 1666
  if ((uint32_t )(vha->req)->cnt < req_cnt + 2U) {
#line 1667
    tmp = readl((void const volatile   *)(& reg->isp24.req_q_out));
#line 1667
    cnt = (uint32_t )((unsigned short )tmp);
#line 1669
    ql_dbg(16384U, vha, 57354, "Request ring circled: cnt=%d, vha->->ring_index=%d, vha->req->cnt=%d, req_cnt=%d\n",
           cnt, (int )(vha->req)->ring_index, (int )(vha->req)->cnt, req_cnt);
#line 1673
    if ((uint32_t )(vha->req)->ring_index < cnt) {
#line 1674
      (vha->req)->cnt = (int )((uint16_t )cnt) - (int )(vha->req)->ring_index;
    } else {
#line 1676
      (vha->req)->cnt = (int )(vha->req)->length + ((int )((uint16_t )cnt) - (int )(vha->req)->ring_index);
    }
  } else {

  }
#line 1680
  tmp___0 = ldv__builtin_expect((uint32_t )(vha->req)->cnt < req_cnt + 2U, 0L);
#line 1680
  if (tmp___0 != 0L) {
#line 1681
    ql_dbg(16384U, vha, 57355, "qla_target(%d): There is no room in the request ring: vha->req->ring_index=%d, vha->req->cnt=%d, req_cnt=%d\n",
           (int )vha->vp_idx, (int )(vha->req)->ring_index, (int )(vha->req)->cnt,
           req_cnt);
#line 1686
    return (-11);
  } else {

  }
#line 1688
  (vha->req)->cnt = (int )(vha->req)->cnt - (int )((uint16_t )req_cnt);
#line 1690
  return (0);
}
}
#line 1696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static void *qlt_get_req_pkt(struct scsi_qla_host *vha ) 
{ 


  {
#line 1699
  (vha->req)->ring_index = (uint16_t )((int )(vha->req)->ring_index + 1);
#line 1700
  if ((int )(vha->req)->ring_index == (int )(vha->req)->length) {
#line 1701
    (vha->req)->ring_index = 0U;
#line 1702
    (vha->req)->ring_ptr = (vha->req)->ring;
  } else {
#line 1704
    (vha->req)->ring_ptr = (vha->req)->ring_ptr + 1;
  }
#line 1706
  return ((void *)(vha->req)->ring_ptr);
}
}
#line 1710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static uint32_t qlt_make_handle(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t h ;

  {
#line 1712
  ha = vha->hw;
#line 1715
  h = (uint32_t )ha->tgt.current_handle;
  ldv_61592: 
#line 1718
  h = h + 1U;
#line 1719
  if (h > 1024U) {
#line 1720
    h = 1U;
  } else {

  }
#line 1721
  if ((uint32_t )ha->tgt.current_handle == h) {
#line 1722
    ql_dbg(16384U, vha, 57422, "qla_target(%d): Ran out of empty cmd slots in ha %p\n",
           (int )vha->vp_idx, ha);
#line 1725
    h = 0U;
#line 1726
    goto ldv_61591;
  } else {

  }
#line 1730
  if ((h == 0U || h == 3758096383U) || (unsigned long )ha->tgt.cmds[h - 1U] != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 1732
    goto ldv_61592;
  } else {

  }
  ldv_61591: ;
#line 1732
  if (h != 0U) {
#line 1733
    ha->tgt.current_handle = (uint16_t )h;
  } else {

  }
#line 1735
  return (h);
}
}
#line 1739 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_24xx_build_ctio_pkt(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  uint32_t h ;
  struct ctio7_to_24xx *pkt ;
  struct qla_hw_data *ha ;
  struct atio_from_isp *atio ;
  long tmp ;
  __u16 tmp___0 ;

  {
#line 1744
  ha = vha->hw;
#line 1745
  atio = & (prm->cmd)->atio;
#line 1747
  pkt = (struct ctio7_to_24xx *)(vha->req)->ring_ptr;
#line 1748
  prm->pkt = (void *)pkt;
#line 1749
  memset((void *)pkt, 0, 64UL);
#line 1751
  pkt->entry_type = 18U;
#line 1752
  pkt->entry_count = (unsigned char )prm->req_cnt;
#line 1753
  pkt->vp_index = (uint8_t )vha->vp_idx;
#line 1755
  h = qlt_make_handle(vha);
#line 1756
  tmp = ldv__builtin_expect(h == 0U, 0L);
#line 1756
  if (tmp != 0L) {
#line 1762
    return (-11);
  } else {
#line 1764
    ha->tgt.cmds[h - 1U] = prm->cmd;
  }
#line 1766
  pkt->handle = h | 536870912U;
#line 1767
  pkt->nport_handle = (prm->cmd)->loop_id;
#line 1768
  pkt->timeout = 10U;
#line 1769
  pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 1770
  pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 1771
  pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 1772
  pkt->exchange_addr = atio->u.isp24.exchange_addr;
#line 1773
  pkt->u.status0.flags = (uint16_t )((int )((short )pkt->u.status0.flags) | (int )((short )((int )atio->u.isp24.attr << 9)));
#line 1774
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 1774
  pkt->u.status0.ox_id = tmp___0;
#line 1775
  pkt->u.status0.relative_offset = (unsigned int )(prm->cmd)->offset;
#line 1777
  ql_dbg(16384U, vha, 57356, "qla_target(%d): handle(cmd) -> %08x, timeout %d, ox_id %#x\n",
         (int )vha->vp_idx, pkt->handle, 10, (int )pkt->u.status0.ox_id);
#line 1781
  return (0);
}
}
#line 1788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_load_cont_data_segments(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  uint32_t *dword_ptr ;
  int enable_64bit_addressing ;
  cont_a64_entry_t *cont_pkt64 ;
  void *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 1793
  enable_64bit_addressing = (int )(prm->tgt)->tgt_enable_64bit_addr;
#line 1796
  goto ldv_61613;
  ldv_61612: 
#line 1797
  tmp = qlt_get_req_pkt(vha);
#line 1797
  cont_pkt64 = (cont_a64_entry_t *)tmp;
#line 1807
  memset((void *)cont_pkt64, 0, 64UL);
#line 1809
  cont_pkt64->entry_count = 1U;
#line 1810
  cont_pkt64->sys_define = 0U;
#line 1812
  if (enable_64bit_addressing != 0) {
#line 1813
    cont_pkt64->entry_type = 10U;
#line 1814
    dword_ptr = (uint32_t *)(& cont_pkt64->dseg_0_address);
  } else {
#line 1817
    cont_pkt64->entry_type = 2U;
#line 1818
    dword_ptr = & ((cont_entry_t *)cont_pkt64)->dseg_0_address;
  }
#line 1824
  cnt = 0;
#line 1824
  goto ldv_61610;
  ldv_61609: 
#line 1827
  tmp___0 = dword_ptr;
#line 1827
  dword_ptr = dword_ptr + 1;
#line 1827
  *tmp___0 = (unsigned int )(prm->sg)->dma_address;
#line 1830
  if (enable_64bit_addressing != 0) {
#line 1831
    tmp___1 = dword_ptr;
#line 1831
    dword_ptr = dword_ptr + 1;
#line 1831
    *tmp___1 = (unsigned int )((prm->sg)->dma_address >> 32ULL);
  } else {

  }
#line 1836
  tmp___2 = dword_ptr;
#line 1836
  dword_ptr = dword_ptr + 1;
#line 1836
  *tmp___2 = (prm->sg)->dma_length;
#line 1838
  ql_dbg(16384U, vha, 57357, "S/G Segment Cont. phys_addr=%llx:%llx, len=%d\n", (prm->sg)->dma_address >> 32ULL,
         (prm->sg)->dma_address & 4294967295ULL, (int )(prm->sg)->dma_length);
#line 1846
  prm->sg = sg_next(prm->sg);
#line 1826
  cnt = cnt + 1;
#line 1826
  prm->seg_cnt = prm->seg_cnt - 1;
  ldv_61610: ;
#line 1824
  if ((prm->tgt)->datasegs_per_cont > cnt && prm->seg_cnt != 0) {
#line 1827
    goto ldv_61609;
  } else {

  }

  ldv_61613: ;
#line 1796
  if (prm->seg_cnt > 0) {
#line 1798
    goto ldv_61612;
  } else {

  }

#line 1803
  return;
}
}
#line 1855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_load_data_segments(struct qla_tgt_prm *prm , struct scsi_qla_host *vha ) 
{ 
  int cnt ;
  uint32_t *dword_ptr ;
  int enable_64bit_addressing ;
  struct ctio7_to_24xx *pkt24 ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;

  {
#line 1860
  enable_64bit_addressing = (int )(prm->tgt)->tgt_enable_64bit_addr;
#line 1861
  pkt24 = (struct ctio7_to_24xx *)prm->pkt;
#line 1863
  ql_dbg(16384U, vha, 57358, "iocb->scsi_status=%x, iocb->flags=%x\n", (int )pkt24->u.status0.scsi_status,
         (int )pkt24->u.status0.flags);
#line 1868
  pkt24->u.status0.transfer_length = (unsigned int )(prm->cmd)->bufflen;
#line 1871
  dword_ptr = (uint32_t *)(& pkt24->u.status0.dseg_0_address);
#line 1874
  if (prm->seg_cnt != 0) {
#line 1875
    pkt24->dseg_count = (unsigned short )prm->seg_cnt;
  } else {

  }
#line 1877
  if (prm->seg_cnt == 0) {
#line 1879
    tmp = dword_ptr;
#line 1879
    dword_ptr = dword_ptr + 1;
#line 1879
    *tmp = 0U;
#line 1880
    *dword_ptr = 0U;
#line 1881
    return;
  } else {

  }
#line 1885
  ql_dbg(16384U, vha, 57359, "%s", (char *)"Building S/G data segments...");
#line 1888
  cnt = 0;
#line 1888
  goto ldv_61624;
  ldv_61623: 
#line 1891
  tmp___0 = dword_ptr;
#line 1891
  dword_ptr = dword_ptr + 1;
#line 1891
  *tmp___0 = (unsigned int )(prm->sg)->dma_address;
#line 1893
  if (enable_64bit_addressing != 0) {
#line 1894
    tmp___1 = dword_ptr;
#line 1894
    dword_ptr = dword_ptr + 1;
#line 1894
    *tmp___1 = (unsigned int )((prm->sg)->dma_address >> 32ULL);
  } else {

  }
#line 1898
  tmp___2 = dword_ptr;
#line 1898
  dword_ptr = dword_ptr + 1;
#line 1898
  *tmp___2 = (prm->sg)->dma_length;
#line 1900
  ql_dbg(16384U, vha, 57360, "S/G Segment phys_addr=%llx:%llx, len=%d\n", (prm->sg)->dma_address >> 32ULL,
         (prm->sg)->dma_address & 4294967295ULL, (int )(prm->sg)->dma_length);
#line 1908
  prm->sg = sg_next(prm->sg);
#line 1890
  cnt = cnt + 1;
#line 1890
  prm->seg_cnt = prm->seg_cnt - 1;
  ldv_61624: ;
#line 1888
  if ((prm->tgt)->datasegs_per_cmd > cnt && prm->seg_cnt != 0) {
#line 1891
    goto ldv_61623;
  } else {

  }
#line 1911
  qlt_load_cont_data_segments(prm, vha);
#line 1912
  return;
}
}
#line 1914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int qlt_has_data(struct qla_tgt_cmd *cmd ) 
{ 


  {
#line 1916
  return (cmd->bufflen > 0);
}
}
#line 1922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_pre_xmit_response(struct qla_tgt_cmd *cmd , struct qla_tgt_prm *prm ,
                                 int xmit_type , uint8_t scsi_status , uint32_t *full_req_cnt ) 
{ 
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct se_cmd *se_cmd ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1926
  tgt = cmd->tgt;
#line 1927
  vha = tgt->vha;
#line 1928
  ha = vha->hw;
#line 1929
  se_cmd = & cmd->se_cmd;
#line 1931
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U, 0L);
#line 1931
  if (tmp != 0L) {
#line 1932
    ql_dbg(8192U, vha, 61460, "qla_target(%d): terminating exchange for aborted cmd=%p (se_cmd=%p, tag=%d)",
           (int )vha->vp_idx, cmd, se_cmd, cmd->tag);
#line 1937
    cmd->state = 4;
#line 1939
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 0);
#line 1942
    return (5911);
  } else {

  }
#line 1945
  ql_dbg(16384U, vha, 57361, "qla_target(%d): tag=%u\n", (int )vha->vp_idx, cmd->tag);
#line 1948
  prm->cmd = cmd;
#line 1949
  prm->tgt = tgt;
#line 1950
  prm->rq_result = (uint16_t )scsi_status;
#line 1951
  prm->sense_buffer = (unsigned char *)(& cmd->sense_buffer);
#line 1952
  prm->sense_buffer_len = 96;
#line 1953
  prm->sg = (struct scatterlist *)0;
#line 1954
  prm->seg_cnt = -1;
#line 1955
  prm->req_cnt = 1;
#line 1956
  prm->add_status_pkt = 0;
#line 1958
  ql_dbg(16384U, vha, 57362, "rq_result=%x, xmit_type=%x\n", (int )prm->rq_result,
         xmit_type);
#line 1962
  tmp___0 = qlt_issue_marker(vha, 0);
#line 1962
  if (tmp___0 != 0) {
#line 1963
    return (-14);
  } else {

  }
#line 1965
  ql_dbg(16384U, vha, 57363, "CTIO start: vha(%d)\n", (int )vha->vp_idx);
#line 1967
  if (xmit_type & 1) {
#line 1967
    tmp___2 = qlt_has_data(cmd);
#line 1967
    if (tmp___2 != 0) {
#line 1968
      tmp___1 = qlt_pci_map_calc_cnt(prm);
#line 1968
      if (tmp___1 != 0) {
#line 1969
        return (-11);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1972
  *full_req_cnt = (uint32_t )prm->req_cnt;
#line 1974
  if ((se_cmd->se_cmd_flags & 8192U) != 0U) {
#line 1975
    prm->residual = (int )se_cmd->residual_count;
#line 1976
    ql_dbg(16384U, vha, 57364, "Residual underflow: %d (tag %d, op %x, bufflen %d, rq_result %x)\n",
           prm->residual, cmd->tag, (unsigned long )se_cmd->t_task_cdb != (unsigned long )((unsigned char *)0U) ? (int )*(se_cmd->t_task_cdb) : 0,
           cmd->bufflen, (int )prm->rq_result);
#line 1981
    prm->rq_result = (uint16_t )((unsigned int )prm->rq_result | 2048U);
  } else
#line 1982
  if ((se_cmd->se_cmd_flags & 4096U) != 0U) {
#line 1983
    prm->residual = (int )se_cmd->residual_count;
#line 1984
    ql_dbg(16384U, vha, 57365, "Residual overflow: %d (tag %d, op %x, bufflen %d, rq_result %x)\n",
           prm->residual, cmd->tag, (unsigned long )se_cmd->t_task_cdb != (unsigned long )((unsigned char *)0U) ? (int )*(se_cmd->t_task_cdb) : 0,
           cmd->bufflen, (int )prm->rq_result);
#line 1989
    prm->rq_result = (uint16_t )((unsigned int )prm->rq_result | 1024U);
  } else {

  }
#line 1992
  if ((xmit_type & 2) != 0) {
#line 1997
    tmp___3 = qlt_has_data(cmd);
#line 1997
    if (tmp___3 != 0) {
#line 1998
      if (((unsigned long )prm->sense_buffer != (unsigned long )((unsigned char *)0U) && ((int )*((uint8_t const   *)prm->sense_buffer) & 112) == 112) || ((ha->device_type & 134217728U) != 0U && (unsigned int )prm->rq_result != 0U)) {
#line 2001
        prm->add_status_pkt = 1;
#line 2002
        *full_req_cnt = *full_req_cnt + 1U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2007
  ql_dbg(16384U, vha, 57366, "req_cnt=%d, full_req_cnt=%d, add_status_pkt=%d\n", prm->req_cnt,
         *full_req_cnt, prm->add_status_pkt);
#line 2011
  return (0);
}
}
#line 2014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int qlt_need_explicit_conf(struct qla_hw_data *ha , struct qla_tgt_cmd *cmd ,
                                           int sending_sense ) 
{ 


  {
#line 2017
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 2018
    return (0);
  } else {

  }
#line 2020
  if (sending_sense != 0) {
#line 2021
    return ((int )cmd->conf_compl_supported);
  } else {
#line 2023
    return ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U && (unsigned int )*((unsigned char *)cmd + 1256UL) != 0U);
  }
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static void qlt_check_srr_debug(struct qla_tgt_cmd *cmd , int *xmit_type ) 
{ 


  {
#line 2114
  return;
}
}
#line 2116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio , struct qla_tgt_prm *prm ) 
{ 
  uint32_t __min1 ;
  uint32_t __min2 ;
  int tmp ;
  int i ;
  int tmp___0 ;
  __u32 tmp___1 ;

  {
#line 2119
  __min1 = (uint32_t )prm->sense_buffer_len;
#line 2119
  __min2 = 24U;
#line 2119
  prm->sense_buffer_len = (int )(__min1 < __min2 ? __min1 : __min2);
#line 2121
  ctio->u.status0.flags = (uint16_t )((unsigned int )ctio->u.status0.flags | 32768U);
#line 2123
  tmp = qlt_need_explicit_conf((prm->tgt)->ha, prm->cmd, 0);
#line 2123
  if (tmp != 0) {
#line 2124
    ctio->u.status0.flags = (uint16_t )((unsigned int )ctio->u.status0.flags | 8224U);
  } else {

  }
#line 2128
  ctio->u.status0.residual = (unsigned int )prm->residual;
#line 2129
  ctio->u.status0.scsi_status = prm->rq_result;
#line 2130
  if ((unsigned long )prm->sense_buffer != (unsigned long )((unsigned char *)0U) && ((int )*((uint8_t const   *)prm->sense_buffer) & 112) == 112) {
#line 2133
    tmp___0 = qlt_need_explicit_conf((prm->tgt)->ha, prm->cmd, 1);
#line 2133
    if (tmp___0 != 0) {
#line 2134
      if ((unsigned int )(prm->cmd)->se_cmd.scsi_status != 0U) {
#line 2135
        ql_dbg(16384U, (prm->cmd)->vha, 57367, "Skipping EXPLICIT_CONFORM and CTIO7_FLAGS_CONFORM_REQ for FCP READ w/ non GOOD status\n");
#line 2139
        goto skip_explict_conf;
      } else {

      }
#line 2141
      ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 8224U);
    } else {

    }
    skip_explict_conf: 
#line 2146
    ctio->u.status1.flags = ctio->u.status1.flags;
#line 2148
    ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 64U);
#line 2150
    ctio->u.status1.scsi_status = (uint16_t )((unsigned int )ctio->u.status1.scsi_status | 512U);
#line 2152
    ctio->u.status1.sense_length = (unsigned short )prm->sense_buffer_len;
#line 2154
    i = 0;
#line 2154
    goto ldv_61659;
    ldv_61658: 
#line 2155
    tmp___1 = __fswab32(*((uint32_t *)prm->sense_buffer + (unsigned long )i));
#line 2155
    *((uint32_t *)(& ctio->u.status1.sense_data) + (unsigned long )i) = tmp___1;
#line 2154
    i = i + 1;
    ldv_61659: ;
#line 2154
    if (prm->sense_buffer_len / 4 > i) {
#line 2156
      goto ldv_61658;
    } else {

    }

  } else {
#line 2170
    ctio->u.status1.flags = ctio->u.status1.flags;
#line 2172
    ctio->u.status1.flags = (uint16_t )((unsigned int )ctio->u.status1.flags | 64U);
#line 2174
    ctio->u.status1.sense_length = 0U;
#line 2175
    memset((void *)(& ctio->u.status1.sense_data), 0, 24UL);
  }
#line 2177
  return;
}
}
#line 2186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_xmit_response(struct qla_tgt_cmd *cmd , int xmit_type , uint8_t scsi_status ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct ctio7_to_24xx *pkt ;
  struct qla_tgt_prm prm ;
  uint32_t full_req_cnt ;
  unsigned long flags ;
  int res ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct ctio7_to_24xx *ctio ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;
  struct _ddebug descriptor ;
  long tmp___5 ;
  int tmp___6 ;

  {
#line 2189
  vha = cmd->vha;
#line 2190
  ha = vha->hw;
#line 2193
  full_req_cnt = 0U;
#line 2194
  flags = 0UL;
#line 2197
  memset((void *)(& prm), 0, 72UL);
#line 2198
  qlt_check_srr_debug(cmd, & xmit_type);
#line 2200
  ql_dbg(16384U, cmd->vha, 57368, "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d\n",
         (xmit_type & 2) != 0, cmd->bufflen, cmd->sg_cnt, (unsigned int )cmd->dma_data_direction);
#line 2205
  res = qlt_pre_xmit_response(cmd, & prm, xmit_type, (int )scsi_status, & full_req_cnt);
#line 2207
  tmp = ldv__builtin_expect(res != 0, 0L);
#line 2207
  if (tmp != 0L) {
#line 2208
    if (res == 5911) {
#line 2209
      return (0);
    } else {

    }
#line 2211
    return (res);
  } else {

  }
#line 2214
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 2214
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2217
  res = qlt_check_reserve_free_req(vha, full_req_cnt);
#line 2218
  tmp___1 = ldv__builtin_expect(res != 0, 0L);
#line 2218
  if (tmp___1 != 0L) {
#line 2219
    goto out_unmap_unlock;
  } else {

  }
#line 2221
  res = qlt_24xx_build_ctio_pkt(& prm, vha);
#line 2222
  tmp___2 = ldv__builtin_expect(res != 0, 0L);
#line 2222
  if (tmp___2 != 0L) {
#line 2223
    goto out_unmap_unlock;
  } else {

  }
#line 2226
  pkt = (struct ctio7_to_24xx *)prm.pkt;
#line 2228
  tmp___6 = qlt_has_data(cmd);
#line 2228
  if (tmp___6 != 0 && xmit_type & 1) {
#line 2229
    pkt->u.status0.flags = (uint16_t )((unsigned int )pkt->u.status0.flags | 2U);
#line 2233
    qlt_load_data_segments(& prm, vha);
#line 2235
    if (prm.add_status_pkt == 0) {
#line 2236
      if ((xmit_type & 2) != 0) {
#line 2237
        pkt->u.status0.scsi_status = prm.rq_result;
#line 2239
        pkt->u.status0.residual = (unsigned int )prm.residual;
#line 2241
        pkt->u.status0.flags = (uint16_t )((unsigned int )pkt->u.status0.flags | 32768U);
#line 2243
        tmp___3 = qlt_need_explicit_conf(ha, cmd, 0);
#line 2243
        if (tmp___3 != 0) {
#line 2244
          pkt->u.status0.flags = (uint16_t )((unsigned int )pkt->u.status0.flags | 8224U);
        } else {

        }
      } else {

      }
    } else {
#line 2257
      tmp___4 = qlt_get_req_pkt(vha);
#line 2257
      ctio = (struct ctio7_to_24xx *)tmp___4;
#line 2260
      ql_dbg(16384U, vha, 57369, "Building additional status packet\n");
#line 2263
      __len = 64UL;
#line 2263
      if (__len > 63UL) {
#line 2263
        __ret = __memcpy((void *)ctio, (void const   *)pkt, __len);
      } else {
#line 2263
        __ret = __builtin_memcpy((void *)ctio, (void const   *)pkt, __len);
      }
#line 2264
      ctio->entry_count = 1U;
#line 2265
      ctio->dseg_count = 0U;
#line 2266
      ctio->u.status1.flags = (unsigned int )ctio->u.status1.flags & 65533U;
#line 2270
      pkt->handle = pkt->handle | 1073741824U;
#line 2271
      pkt->u.status0.flags = (uint16_t )((unsigned int )pkt->u.status0.flags | 256U);
#line 2273
      qlt_24xx_init_ctio_to_isp(ctio, & prm);
#line 2275
      descriptor.modname = "qla2xxx";
#line 2275
      descriptor.function = "qlt_xmit_response";
#line 2275
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 2275
      descriptor.format = "Status CTIO7: %p\n";
#line 2275
      descriptor.lineno = 2275U;
#line 2275
      descriptor.flags = 0U;
#line 2275
      tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2275
      if (tmp___5 != 0L) {
#line 2275
        __dynamic_pr_debug(& descriptor, "Status CTIO7: %p\n", ctio);
      } else {

      }
    }
  } else {
#line 2278
    qlt_24xx_init_ctio_to_isp(pkt, & prm);
  }
#line 2281
  cmd->state = 3;
#line 2283
  ql_dbg(16384U, vha, 57370, "Xmitting CTIO7 response pkt for 24xx: %p scsi_status: 0x%02x\n",
         pkt, (int )scsi_status);
#line 2287
  qla2x00_start_iocbs(vha, vha->req);
#line 2288
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2290
  return (0);
  out_unmap_unlock: ;
#line 2293
  if ((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U) {
#line 2294
    qlt_unmap_sg(vha, cmd);
  } else {

  }
#line 2295
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2297
  return (res);
}
}
#line 2301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd ) 
{ 
  struct ctio7_to_24xx *pkt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_prm prm ;
  unsigned long flags ;
  int res ;
  int tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  long tmp___2 ;

  {
#line 2304
  vha = cmd->vha;
#line 2305
  ha = vha->hw;
#line 2306
  tgt = cmd->tgt;
#line 2309
  res = 0;
#line 2311
  memset((void *)(& prm), 0, 72UL);
#line 2312
  prm.cmd = cmd;
#line 2313
  prm.tgt = tgt;
#line 2314
  prm.sg = (struct scatterlist *)0;
#line 2315
  prm.req_cnt = 1;
#line 2318
  tmp = qlt_issue_marker(vha, 0);
#line 2318
  if (tmp != 0) {
#line 2319
    return (-5);
  } else {

  }
#line 2321
  ql_dbg(16384U, vha, 57371, "CTIO_start: vha(%d)", (int )vha->vp_idx);
#line 2325
  tmp___0 = qlt_pci_map_calc_cnt(& prm);
#line 2325
  if (tmp___0 != 0) {
#line 2326
    return (-11);
  } else {

  }
#line 2328
  tmp___1 = spinlock_check(& ha->hardware_lock);
#line 2328
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2331
  res = qlt_check_reserve_free_req(vha, (uint32_t )prm.req_cnt);
#line 2332
  if (res != 0) {
#line 2333
    goto out_unlock_free_unmap;
  } else {

  }
#line 2335
  res = qlt_24xx_build_ctio_pkt(& prm, vha);
#line 2336
  tmp___2 = ldv__builtin_expect(res != 0, 0L);
#line 2336
  if (tmp___2 != 0L) {
#line 2337
    goto out_unlock_free_unmap;
  } else {

  }
#line 2338
  pkt = (struct ctio7_to_24xx *)prm.pkt;
#line 2339
  pkt->u.status0.flags = (uint16_t )((unsigned int )pkt->u.status0.flags | 1U);
#line 2341
  qlt_load_data_segments(& prm, vha);
#line 2343
  cmd->state = 1;
#line 2345
  qla2x00_start_iocbs(vha, vha->req);
#line 2346
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2348
  return (res);
  out_unlock_free_unmap: ;
#line 2351
  if ((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U) {
#line 2352
    qlt_unmap_sg(vha, cmd);
  } else {

  }
#line 2353
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2355
  return (res);
}
}
#line 2361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int __qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                    struct atio_from_isp *atio ) 
{ 
  struct ctio7_to_24xx *ctio24 ;
  struct qla_hw_data *ha ;
  request_t *pkt ;
  int ret ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 2366
  ha = vha->hw;
#line 2368
  ret = 0;
#line 2370
  ql_dbg(16384U, vha, 57372, "Sending TERM EXCH CTIO (ha=%p)\n", ha);
#line 2372
  tmp = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 2372
  pkt = (request_t *)tmp;
#line 2373
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 2374
    ql_dbg(16384U, vha, 57424, "qla_target(%d): %s failed: unable to allocate request packet\n",
           (int )vha->vp_idx, "__qlt_send_term_exchange");
#line 2377
    return (-12);
  } else {

  }
#line 2380
  if ((unsigned long )cmd != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2381
    if (cmd->state <= 2) {
#line 2382
      ql_dbg(16384U, vha, 57425, "qla_target(%d): Terminating cmd %p with incorrect state %d\n",
             (int )vha->vp_idx, cmd, cmd->state);
    } else {
#line 2387
      ret = 1;
    }
  } else {

  }
#line 2390
  pkt->entry_count = 1U;
#line 2391
  pkt->handle = 4294967295U;
#line 2393
  ctio24 = (struct ctio7_to_24xx *)pkt;
#line 2394
  ctio24->entry_type = 18U;
#line 2395
  ctio24->nport_handle = (unsigned long )cmd != (unsigned long )((struct qla_tgt_cmd *)0) ? cmd->loop_id : 65535U;
#line 2396
  ctio24->timeout = 10U;
#line 2397
  ctio24->vp_index = (uint8_t )vha->vp_idx;
#line 2398
  ctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 2399
  ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 2400
  ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 2401
  ctio24->exchange_addr = atio->u.isp24.exchange_addr;
#line 2402
  ctio24->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | 16448);
#line 2405
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 2405
  ctio24->u.status1.ox_id = tmp___0;
#line 2408
  ctio24->u.status1.residual = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 2411
  if (ctio24->u.status1.residual != 0U) {
#line 2412
    ctio24->u.status1.scsi_status = (uint16_t )((unsigned int )ctio24->u.status1.scsi_status | 2048U);
  } else {

  }
#line 2414
  qla2x00_start_iocbs(vha, vha->req);
#line 2415
  return (ret);
}
}
#line 2418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_send_term_exchange(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                   struct atio_from_isp *atio , int ha_locked ) 
{ 
  unsigned long flags ;
  int rc ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  struct thread_info *tmp___1 ;

  {
#line 2424
  tmp = qlt_issue_marker(vha, ha_locked);
#line 2424
  if (tmp < 0) {
#line 2425
    return;
  } else {

  }
#line 2427
  if (ha_locked != 0) {
#line 2428
    rc = __qlt_send_term_exchange(vha, cmd, atio);
#line 2429
    goto done;
  } else {

  }
#line 2431
  tmp___0 = spinlock_check(& (vha->hw)->hardware_lock);
#line 2431
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 2432
  rc = __qlt_send_term_exchange(vha, cmd, atio);
#line 2433
  spin_unlock_irqrestore(& (vha->hw)->hardware_lock, flags);
  done: ;
#line 2435
  if (rc == 1) {
#line 2436
    if (ha_locked == 0) {
#line 2436
      tmp___1 = current_thread_info();
#line 2436
      if (((unsigned long )tmp___1->preempt_count & 134217472UL) == 0UL) {
#line 2437
        msleep(250U);
      } else {

      }
    } else {

    }
#line 2439
    (*(((vha->hw)->tgt.tgt_ops)->free_cmd))(cmd);
  } else {

  }
#line 2441
  return;
}
}
#line 2443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_free_cmd(struct qla_tgt_cmd *cmd ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 2445
  tmp = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U, 0L);
#line 2445
  if (tmp != 0L) {
#line 2445
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (2445), "i" (12UL));
    ldv_61736: ;
#line 2445
    goto ldv_61736;
  } else {

  }
#line 2447
  tmp___0 = ldv__builtin_expect((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U,
                             0L);
#line 2447
  if (tmp___0 != 0L) {
#line 2448
    kfree((void const   *)cmd->sg);
  } else {

  }
#line 2449
  kmem_cache_free(qla_tgt_cmd_cachep, (void *)cmd);
#line 2450
  return;
}
}
#line 2454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_prepare_srr_ctio(struct scsi_qla_host *vha , struct qla_tgt_cmd *cmd ,
                                void *ctio ) 
{ 
  struct qla_tgt_srr_ctio *sc ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_srr_imm *imm ;
  void *tmp ;
  int found ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_imm *ti ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 2458
  ha = vha->hw;
#line 2459
  tgt = ha->tgt.qla_tgt;
#line 2462
  tgt->ctio_srr_id = tgt->ctio_srr_id + 1;
#line 2464
  ql_dbg(8192U, vha, 61465, "qla_target(%d): CTIO with SRR status received\n", (int )vha->vp_idx);
#line 2467
  if ((unsigned long )ctio == (unsigned long )((void *)0)) {
#line 2468
    ql_dbg(8192U, vha, 61525, "qla_target(%d): SRR CTIO, but ctio is NULL\n", (int )vha->vp_idx);
#line 2471
    return (-22);
  } else {

  }
#line 2474
  tmp = kzalloc(32UL, 32U);
#line 2474
  sc = (struct qla_tgt_srr_ctio *)tmp;
#line 2475
  if ((unsigned long )sc != (unsigned long )((struct qla_tgt_srr_ctio *)0)) {
#line 2476
    sc->cmd = cmd;
#line 2478
    spin_lock(& tgt->srr_lock);
#line 2479
    sc->srr_id = tgt->ctio_srr_id;
#line 2480
    list_add_tail(& sc->srr_list_entry, & tgt->srr_ctio_list);
#line 2482
    ql_dbg(8192U, vha, 61466, "CTIO SRR %p added (id %d)\n", sc, sc->srr_id);
#line 2484
    if (tgt->imm_srr_id == tgt->ctio_srr_id) {
#line 2485
      found = 0;
#line 2486
      __mptr = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 2486
      imm = (struct qla_tgt_srr_imm *)__mptr;
#line 2486
      goto ldv_61759;
      ldv_61758: ;
#line 2488
      if (imm->srr_id == sc->srr_id) {
#line 2489
        found = 1;
#line 2490
        goto ldv_61757;
      } else {

      }
#line 2486
      __mptr___0 = (struct list_head  const  *)imm->srr_list_entry.next;
#line 2486
      imm = (struct qla_tgt_srr_imm *)__mptr___0;
      ldv_61759: ;
#line 2486
      if ((unsigned long )(& imm->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 2488
        goto ldv_61758;
      } else {

      }
      ldv_61757: ;
#line 2493
      if (found != 0) {
#line 2494
        ql_dbg(8192U, vha, 61467, "Scheduling srr work\n");
#line 2496
        schedule_work(& tgt->srr_work);
      } else {
#line 2498
        ql_dbg(8192U, vha, 61526, "qla_target(%d): imm_srr_id == ctio_srr_id (%d), but there is no corresponding SRR IMM, deleting CTIO SRR %p\n",
               (int )vha->vp_idx, tgt->ctio_srr_id, sc);
#line 2504
        list_del(& sc->srr_list_entry);
#line 2505
        spin_unlock(& tgt->srr_lock);
#line 2507
        kfree((void const   *)sc);
#line 2508
        return (-22);
      }
    } else {

    }
#line 2511
    spin_unlock(& tgt->srr_lock);
  } else {
#line 2515
    ql_dbg(8192U, vha, 61527, "qla_target(%d): Unable to allocate SRR CTIO entry\n",
           (int )vha->vp_idx);
#line 2518
    spin_lock(& tgt->srr_lock);
#line 2519
    __mptr___1 = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 2519
    imm = (struct qla_tgt_srr_imm *)__mptr___1;
#line 2519
    __mptr___2 = (struct list_head  const  *)imm->srr_list_entry.next;
#line 2519
    ti = (struct qla_tgt_srr_imm *)__mptr___2;
#line 2519
    goto ldv_61768;
    ldv_61767: ;
#line 2521
    if (imm->srr_id == tgt->ctio_srr_id) {
#line 2522
      ql_dbg(8192U, vha, 61468, "IMM SRR %p deleted (id %d)\n", imm, imm->srr_id);
#line 2525
      list_del(& imm->srr_list_entry);
#line 2526
      qlt_reject_free_srr_imm(vha, imm, 1);
    } else {

    }
#line 2519
    imm = ti;
#line 2519
    __mptr___3 = (struct list_head  const  *)ti->srr_list_entry.next;
#line 2519
    ti = (struct qla_tgt_srr_imm *)__mptr___3;
    ldv_61768: ;
#line 2519
    if ((unsigned long )(& imm->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 2521
      goto ldv_61767;
    } else {

    }
#line 2529
    spin_unlock(& tgt->srr_lock);
#line 2531
    return (-12);
  }
#line 2534
  return (0);
}
}
#line 2540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_term_ctio_exchange(struct scsi_qla_host *vha , void *ctio , struct qla_tgt_cmd *cmd ,
                                  uint32_t status ) 
{ 
  int term ;
  struct ctio7_from_24xx *c ;

  {
#line 2543
  term = 0;
#line 2545
  if ((unsigned long )ctio != (unsigned long )((void *)0)) {
#line 2546
    c = (struct ctio7_from_24xx *)ctio;
#line 2547
    term = ((int )c->flags & 16384) == 0;
  } else {
#line 2550
    term = 1;
  }
#line 2552
  if (term != 0) {
#line 2553
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 1);
  } else {

  }
#line 2555
  return (term);
}
}
#line 2559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static struct qla_tgt_cmd *qlt_get_cmd(struct scsi_qla_host *vha , uint32_t handle ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_cmd *cmd ;

  {
#line 2562
  ha = vha->hw;
#line 2564
  handle = handle - 1U;
#line 2565
  if ((unsigned long )ha->tgt.cmds[handle] != (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2566
    cmd = ha->tgt.cmds[handle];
#line 2567
    ha->tgt.cmds[handle] = (struct qla_tgt_cmd *)0;
#line 2568
    return (cmd);
  } else {
#line 2570
    return ((struct qla_tgt_cmd *)0);
  }
}
}
#line 2574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct qla_tgt_cmd *qlt_ctio_to_cmd(struct scsi_qla_host *vha , uint32_t handle ,
                                           void *ctio ) 
{ 
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 2577
  cmd = (struct qla_tgt_cmd *)0;
#line 2580
  handle = handle & 2684354559U;
#line 2583
  if (handle != 0U) {
#line 2584
    tmp = ldv__builtin_expect(handle == 3758096383U, 0L);
#line 2584
    if (tmp != 0L) {
#line 2585
      ql_dbg(16384U, vha, 57373, "%s", (char *)"SKIP_HANDLE CTIO\n");
#line 2587
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
#line 2590
    tmp___0 = ldv__builtin_expect(handle > 1024U, 0L);
#line 2590
    if (tmp___0 != 0L) {
#line 2591
      ql_dbg(16384U, vha, 57426, "qla_target(%d): Wrong handle %x received\n", (int )vha->vp_idx,
             handle);
#line 2594
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
#line 2596
    cmd = qlt_get_cmd(vha, handle);
#line 2597
    tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0),
                               0L);
#line 2597
    if (tmp___1 != 0L) {
#line 2598
      ql_dbg(16384U, vha, 57427, "qla_target(%d): Suspicious: unable to find the command with handle %x\n",
             (int )vha->vp_idx, handle);
#line 2602
      return ((struct qla_tgt_cmd *)0);
    } else {

    }
  } else
#line 2604
  if ((unsigned long )ctio != (unsigned long )((void *)0)) {
#line 2606
    ql_dbg(16384U, vha, 57428, "qla_target(%d): Wrong CTIO received: QLA24xx doesn\'t support NULL handles\n",
           (int )vha->vp_idx);
#line 2609
    return ((struct qla_tgt_cmd *)0);
  } else {

  }
#line 2612
  return (cmd);
}
}
#line 2618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_do_ctio_completion(struct scsi_qla_host *vha , uint32_t handle , uint32_t status ,
                                   void *ctio ) 
{ 
  struct qla_hw_data *ha ;
  struct se_cmd *se_cmd ;
  struct target_core_fabric_ops *tfo ;
  struct qla_tgt_cmd *cmd ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int rx_status ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2621
  ha = vha->hw;
#line 2626
  ql_dbg(16384U, vha, 57374, "qla_target(%d): handle(ctio %p status %#x) <- %08x\n",
         (int )vha->vp_idx, ctio, status, handle);
#line 2630
  if ((handle & 1073741824U) != 0U) {
#line 2632
    if (status != 1U) {
#line 2633
      ql_dbg(8192U, vha, 61469, "Intermediate CTIO received (status %x)\n", status);
    } else {

    }
#line 2637
    return;
  } else {

  }
#line 2640
  cmd = qlt_ctio_to_cmd(vha, handle, ctio);
#line 2641
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2642
    return;
  } else {

  }
#line 2644
  se_cmd = & cmd->se_cmd;
#line 2645
  tfo = se_cmd->se_tfo;
#line 2647
  if ((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U) {
#line 2648
    qlt_unmap_sg(vha, cmd);
  } else {

  }
#line 2650
  tmp___1 = ldv__builtin_expect(status != 1U, 0L);
#line 2650
  if (tmp___1 != 0L) {
#line 2651
    switch (status & 65535U) {
    case 14U: ;
    case 23U: ;
    case 2U: ;
    case 11U: ;
    case 8U: 
#line 2658
    ql_dbg(8192U, vha, 61528, "qla_target(%d): CTIO with status %#x received, state %x, se_cmd %p, (LIP_RESET=e, ABORTED=2, TARGET_RESET=17, TIMEOUT=b, INVALID_RX_ID=8)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 2664
    goto ldv_61805;
    case 41U: ;
    case 40U: 
#line 2668
    ql_dbg(8192U, vha, 61529, "qla_target(%d): CTIO with PORT LOGGED OUT (29) or PORT UNAVAILABLE (28) status %x received (state %x, se_cmd %p)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 2673
    goto ldv_61805;
    case 69U: 
#line 2676
    ql_dbg(8192U, vha, 61530, "qla_target(%d): CTIO with SRR_RECEIVED status %x received (state %x, se_cmd %p)\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 2680
    tmp = qlt_prepare_srr_ctio(vha, cmd, ctio);
#line 2680
    if (tmp != 0) {
#line 2681
      goto ldv_61805;
    } else {
#line 2683
      return;
    }
    default: 
#line 2686
    ql_dbg(8192U, vha, 61531, "qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\n",
           (int )vha->vp_idx, status, cmd->state, se_cmd);
#line 2690
    goto ldv_61805;
    }
    ldv_61805: ;
#line 2693
    if (cmd->state != 1) {
#line 2694
      tmp___0 = qlt_term_ctio_exchange(vha, ctio, cmd, status);
#line 2694
      if (tmp___0 != 0) {
#line 2695
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2698
  if (cmd->state == 3) {
#line 2699
    ql_dbg(16384U, vha, 57375, "Command %p finished\n", cmd);
  } else
#line 2700
  if (cmd->state == 1) {
#line 2701
    rx_status = 0;
#line 2703
    cmd->state = 2;
#line 2705
    tmp___2 = ldv__builtin_expect(status != 1U, 0L);
#line 2705
    if (tmp___2 != 0L) {
#line 2706
      rx_status = -5;
    } else {
#line 2708
      cmd->write_data_transferred = 1U;
    }
#line 2710
    ql_dbg(16384U, vha, 57376, "Data received, context %x, rx_status %d\n", 0, rx_status);
#line 2714
    (*((ha->tgt.tgt_ops)->handle_data))(cmd);
#line 2715
    return;
  } else
#line 2716
  if (cmd->state == 4) {
#line 2717
    ql_dbg(8192U, vha, 61470, "Aborted command %p (tag %d) finished\n", cmd, cmd->tag);
  } else {
#line 2720
    ql_dbg(8192U, vha, 61532, "qla_target(%d): A command in state (%d) should not return a CTIO complete\n",
           (int )vha->vp_idx, cmd->state);
  }
#line 2725
  tmp___3 = ldv__builtin_expect(status != 1U, 0L);
#line 2725
  if (tmp___3 != 0L) {
#line 2726
    ql_dbg(8192U, vha, 61471, "Finishing failed CTIO\n");
#line 2727
    dump_stack();
  } else {

  }
#line 2730
  (*((ha->tgt.tgt_ops)->free_cmd))(cmd);
#line 2731
  return;
}
}
#line 2733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int qlt_get_fcp_task_attr(struct scsi_qla_host *vha , uint8_t task_codes ) 
{ 
  int fcp_task_attr ;

  {
#line 2738
  switch ((int )task_codes) {
  case 0: 
#line 2740
  fcp_task_attr = 32;
#line 2741
  goto ldv_61817;
  case 1: 
#line 2743
  fcp_task_attr = 33;
#line 2744
  goto ldv_61817;
  case 2: 
#line 2746
  fcp_task_attr = 34;
#line 2747
  goto ldv_61817;
  case 4: 
#line 2749
  fcp_task_attr = 36;
#line 2750
  goto ldv_61817;
  case 5: 
#line 2752
  fcp_task_attr = 32;
#line 2753
  goto ldv_61817;
  default: 
#line 2755
  ql_dbg(8192U, vha, 61533, "qla_target: unknown task code %x, use ORDERED instead\n",
         (int )task_codes);
#line 2758
  fcp_task_attr = 34;
#line 2759
  goto ldv_61817;
  }
  ldv_61817: ;
#line 2762
  return (fcp_task_attr);
}
}
#line 2765
static struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha , uint8_t *s_id ) ;
#line 2770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_do_work(struct work_struct *work ) 
{ 
  struct qla_tgt_cmd *cmd ;
  struct work_struct  const  *__mptr ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  struct atio_from_isp *atio ;
  unsigned char *cdb ;
  unsigned long flags ;
  uint32_t data_length ;
  int ret ;
  int fcp_task_attr ;
  int data_dir ;
  int bidi ;
  raw_spinlock_t *tmp ;
  uint8_t *s_id ;
  long tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  __u32 tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  raw_spinlock_t *tmp___5 ;

  {
#line 2772
  __mptr = (struct work_struct  const  *)work;
#line 2772
  cmd = (struct qla_tgt_cmd *)__mptr + 0xfffffffffffffbc8UL;
#line 2773
  vha = cmd->vha;
#line 2774
  ha = vha->hw;
#line 2775
  tgt = ha->tgt.qla_tgt;
#line 2776
  sess = (struct qla_tgt_sess *)0;
#line 2777
  atio = & cmd->atio;
#line 2781
  bidi = 0;
#line 2783
  if (tgt->tgt_stop != 0) {
#line 2784
    goto out_term;
  } else {

  }
#line 2786
  tmp = spinlock_check(& ha->hardware_lock);
#line 2786
  flags = _raw_spin_lock_irqsave(tmp);
#line 2787
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& atio->u.isp24.fcp_hdr.s_id));
#line 2790
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 2791
    kref_get(& (sess->se_sess)->sess_kref);
  } else {

  }
#line 2792
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2794
  tmp___0 = ldv__builtin_expect((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0),
                             0L);
#line 2794
  if (tmp___0 != 0L) {
#line 2795
    s_id = (uint8_t *)(& atio->u.isp24.fcp_hdr.s_id);
#line 2797
    ql_dbg(8192U, vha, 61474, "qla_target(%d): Unable to find wwn login (s_id %x:%x:%x), trying to create it manually\n",
           (int )vha->vp_idx, (int )*s_id, (int )*(s_id + 1UL), (int )*(s_id + 2UL));
#line 2802
    if ((unsigned int )atio->u.raw.entry_count > 1U) {
#line 2803
      ql_dbg(8192U, vha, 61475, "Dropping multy entry cmd %p\n", cmd);
#line 2805
      goto out_term;
    } else {

    }
#line 2808
    mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 2809
    sess = qlt_make_local_sess(vha, s_id);
#line 2811
    mutex_unlock(& ha->tgt.tgt_mutex);
#line 2813
    if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 2814
      goto out_term;
    } else {

    }
  } else {

  }
#line 2817
  cmd->sess = sess;
#line 2818
  cmd->loop_id = sess->loop_id;
#line 2819
  cmd->conf_compl_supported = sess->conf_compl_supported;
#line 2821
  cdb = (unsigned char *)(& atio->u.isp24.fcp_cmnd.cdb);
#line 2822
  cmd->tag = atio->u.isp24.exchange_addr;
#line 2823
  tmp___1 = scsilun_to_int((struct scsi_lun *)(& atio->u.isp24.fcp_cmnd.lun));
#line 2823
  cmd->unpacked_lun = (uint32_t )tmp___1;
#line 2826
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U && (unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 2828
    bidi = 1;
#line 2829
    data_dir = 1;
  } else
#line 2830
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 2831
    data_dir = 2;
  } else
#line 2832
  if ((unsigned int )*((unsigned char *)atio + 43UL) != 0U) {
#line 2833
    data_dir = 1;
  } else {
#line 2835
    data_dir = 3;
  }
#line 2837
  fcp_task_attr = qlt_get_fcp_task_attr(vha, (int )atio->u.isp24.fcp_cmnd.task_attr);
#line 2839
  tmp___2 = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 2839
  tmp___3 = __fswab32(tmp___2);
#line 2839
  data_length = tmp___3;
#line 2843
  ql_dbg(16384U, vha, 57378, "qla_target: START qla command: %p lun: 0x%04x (tag %d)\n",
         cmd, cmd->unpacked_lun, cmd->tag);
#line 2847
  ret = (*(((vha->hw)->tgt.tgt_ops)->handle_cmd))(vha, cmd, cdb, data_length, fcp_task_attr,
                                                  data_dir, bidi);
#line 2849
  if (ret != 0) {
#line 2850
    goto out_term;
  } else {

  }
#line 2854
  tmp___4 = spinlock_check(& ha->hardware_lock);
#line 2854
  flags = _raw_spin_lock_irqsave(tmp___4);
#line 2855
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 2856
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2857
  return;
  out_term: 
#line 2860
  ql_dbg(8192U, vha, 61472, "Terminating work cmd %p", cmd);
#line 2865
  tmp___5 = spinlock_check(& ha->hardware_lock);
#line 2865
  flags = _raw_spin_lock_irqsave(tmp___5);
#line 2866
  qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & cmd->atio, 1);
#line 2867
  kmem_cache_free(qla_tgt_cmd_cachep, (void *)cmd);
#line 2868
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 2869
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {

  }
#line 2870
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 2871
  return;
}
}
#line 2874 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_cmd *cmd ;
  long tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 2877
  ha = vha->hw;
#line 2878
  tgt = ha->tgt.qla_tgt;
#line 2881
  tmp = ldv__builtin_expect(tgt->tgt_stop != 0, 0L);
#line 2881
  if (tmp != 0L) {
#line 2882
    ql_dbg(8192U, vha, 61473, "New command while device %p is shutting down\n", tgt);
#line 2884
    return (-14);
  } else {

  }
#line 2887
  tmp___0 = kmem_cache_zalloc(qla_tgt_cmd_cachep, 32U);
#line 2887
  cmd = (struct qla_tgt_cmd *)tmp___0;
#line 2888
  if ((unsigned long )cmd == (unsigned long )((struct qla_tgt_cmd *)0)) {
#line 2889
    ql_dbg(8192U, vha, 61534, "qla_target(%d): Allocation of cmd failed\n", (int )vha->vp_idx);
#line 2891
    return (-12);
  } else {

  }
#line 2894
  INIT_LIST_HEAD(& cmd->cmd_list);
#line 2896
  __len = 64UL;
#line 2896
  if (__len > 63UL) {
#line 2896
    __ret = __memcpy((void *)(& cmd->atio), (void const   *)atio, __len);
  } else {
#line 2896
    __ret = __builtin_memcpy((void *)(& cmd->atio), (void const   *)atio, __len);
  }
#line 2897
  cmd->state = 0;
#line 2898
  cmd->tgt = ha->tgt.qla_tgt;
#line 2899
  cmd->vha = vha;
#line 2901
  __init_work(& cmd->work, 0);
#line 2901
  __constr_expr_0.counter = 137438953408L;
#line 2901
  cmd->work.data = __constr_expr_0;
#line 2901
  lockdep_init_map(& cmd->work.lockdep_map, "(&cmd->work)", & __key, 0);
#line 2901
  INIT_LIST_HEAD(& cmd->work.entry);
#line 2901
  cmd->work.func = & qlt_do_work;
#line 2902
  queue_work(qla_tgt_wq, & cmd->work);
#line 2903
  return (0);
}
}
#line 2908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess , uint32_t lun , int fn ,
                               void *iocb , int flags ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  int res ;
  uint8_t tmr_func ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2911
  vha = sess->vha;
#line 2912
  ha = vha->hw;
#line 2917
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 2917
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 2918
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 2919
    ql_dbg(4096U, vha, 65545, "qla_target(%d): Allocation of management command failed, some commands and their data could leak\n",
           (int )vha->vp_idx);
#line 2923
    return (-12);
  } else {

  }
#line 2925
  memset((void *)mcmd, 0, 1152UL);
#line 2926
  mcmd->sess = sess;
#line 2928
  if ((unsigned long )iocb != (unsigned long )((void *)0)) {
#line 2929
    __len = 64UL;
#line 2929
    if (__len > 63UL) {
#line 2929
      __ret = __memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb,
                       __len);
    } else {
#line 2929
      __ret = __builtin_memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb,
                               __len);
    }
  } else {

  }
#line 2932
  mcmd->tmr_func = (uint8_t )fn;
#line 2933
  mcmd->flags = (unsigned int )flags;
#line 2935
  switch (fn) {
  case 64: 
#line 2937
  ql_dbg(4096U, vha, 65536, "qla_target(%d): CLEAR_ACA received\n", (int )(sess->vha)->vp_idx);
#line 2939
  tmr_func = 3U;
#line 2940
  goto ldv_61883;
  case 32: 
#line 2943
  ql_dbg(4096U, vha, 65537, "qla_target(%d): TARGET_RESET received\n", (int )(sess->vha)->vp_idx);
#line 2946
  tmr_func = 6U;
#line 2947
  goto ldv_61883;
  case 16: 
#line 2950
  ql_dbg(4096U, vha, 65538, "qla_target(%d): LUN_RESET received\n", (int )(sess->vha)->vp_idx);
#line 2952
  tmr_func = 5U;
#line 2953
  goto ldv_61883;
  case 4: 
#line 2956
  ql_dbg(4096U, vha, 65539, "qla_target(%d): CLEAR_TS received\n", (int )(sess->vha)->vp_idx);
#line 2958
  tmr_func = 4U;
#line 2959
  goto ldv_61883;
  case 2: 
#line 2962
  ql_dbg(4096U, vha, 65540, "qla_target(%d): ABORT_TS received\n", (int )(sess->vha)->vp_idx);
#line 2964
  tmr_func = 2U;
#line 2965
  goto ldv_61883;
  default: 
#line 2995
  ql_dbg(4096U, vha, 65546, "qla_target(%d): Unknown task mgmt fn 0x%x\n", (int )(sess->vha)->vp_idx,
         fn);
#line 2998
  mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 2999
  return (-38);
  }
  ldv_61883: 
#line 3002
  res = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, lun, (int )tmr_func, 0U);
#line 3003
  if (res != 0) {
#line 3004
    ql_dbg(4096U, vha, 65547, "qla_target(%d): tgt.tgt_ops->handle_tmr() failed: %d\n",
           (int )(sess->vha)->vp_idx, res);
#line 3007
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 3008
    return (-14);
  } else {

  }
#line 3011
  return (0);
}
}
#line 3015 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_handle_task_mgmt(struct scsi_qla_host *vha , void *iocb ) 
{ 
  struct atio_from_isp *a ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_sess *sess ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int lun_size ;
  int fn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3017
  a = (struct atio_from_isp *)iocb;
#line 3018
  ha = vha->hw;
#line 3024
  tgt = ha->tgt.qla_tgt;
#line 3026
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 3027
  lun_size = 8;
#line 3028
  fn = (int )a->u.isp24.fcp_cmnd.task_mgmt_flags;
#line 3029
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& a->u.isp24.fcp_hdr.s_id));
#line 3031
  tmp = scsilun_to_int((struct scsi_lun *)(& lun));
#line 3031
  unpacked_lun = (uint32_t )tmp;
#line 3033
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3034
    ql_dbg(8192U, vha, 61476, "qla_target(%d): task mgmt fn 0x%x for non-existant session\n",
           (int )vha->vp_idx, fn);
#line 3037
    tmp___0 = qlt_sched_sess_work(tgt, 2, (void const   *)iocb, 64U);
#line 3037
    return (tmp___0);
  } else {

  }
#line 3041
  tmp___1 = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
#line 3041
  return (tmp___1);
}
}
#line 3045 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int __qlt_abort_task(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ,
                            struct qla_tgt_sess *sess ) 
{ 
  struct atio_from_isp *a ;
  struct qla_hw_data *ha ;
  struct qla_tgt_mgmt_cmd *mcmd ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int rc ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 3048
  a = (struct atio_from_isp *)iocb;
#line 3049
  ha = vha->hw;
#line 3054
  tmp = mempool_alloc(qla_tgt_mgmt_cmd_mempool, 32U);
#line 3054
  mcmd = (struct qla_tgt_mgmt_cmd *)tmp;
#line 3055
  if ((unsigned long )mcmd == (unsigned long )((struct qla_tgt_mgmt_cmd *)0)) {
#line 3056
    ql_dbg(8192U, vha, 61535, "qla_target(%d): %s: Allocation of ABORT cmd failed\n",
           (int )vha->vp_idx, "__qlt_abort_task");
#line 3059
    return (-12);
  } else {

  }
#line 3061
  memset((void *)mcmd, 0, 1152UL);
#line 3063
  mcmd->sess = sess;
#line 3064
  __len = 64UL;
#line 3064
  if (__len > 63UL) {
#line 3064
    __ret = __memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb, __len);
  } else {
#line 3064
    __ret = __builtin_memcpy((void *)(& mcmd->orig_iocb.imm_ntfy), (void const   *)iocb,
                             __len);
  }
#line 3067
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 3068
  tmp___0 = scsilun_to_int((struct scsi_lun *)(& lun));
#line 3068
  unpacked_lun = (uint32_t )tmp___0;
#line 3070
  rc = (*((ha->tgt.tgt_ops)->handle_tmr))(mcmd, unpacked_lun, 1, (uint32_t )iocb->u.isp2x.seq_id);
#line 3072
  if (rc != 0) {
#line 3073
    ql_dbg(8192U, vha, 61536, "qla_target(%d): tgt_ops->handle_tmr() failed: %d\n",
           (int )vha->vp_idx, rc);
#line 3076
    mempool_free((void *)mcmd, qla_tgt_mgmt_cmd_mempool);
#line 3077
    return (-14);
  } else {

  }
#line 3080
  return (0);
}
}
#line 3084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_abort_task(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  int loop_id ;
  int tmp ;
  int tmp___0 ;

  {
#line 3087
  ha = vha->hw;
#line 3091
  loop_id = (int )ha->device_type < 0 ? (int )((struct atio_from_isp *)iocb)->u.isp2x.target.extended : (int )((struct atio_from_isp *)iocb)->u.isp2x.target.id.standard;
#line 3093
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_loop_id))(vha, (int )((uint16_t const   )loop_id));
#line 3094
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3095
    ql_dbg(8192U, vha, 61477, "qla_target(%d): task abort for unexisting session\n",
           (int )vha->vp_idx);
#line 3098
    tmp = qlt_sched_sess_work(ha->tgt.qla_tgt, 1, (void const   *)iocb, 64U);
#line 3098
    return (tmp);
  } else {

  }
#line 3102
  tmp___0 = __qlt_abort_task(vha, iocb, sess);
#line 3102
  return (tmp___0);
}
}
#line 3108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_24xx_handle_els(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_hw_data *ha ;
  int res ;
  struct qla_tgt *tgt ;

  {
#line 3111
  ha = vha->hw;
#line 3112
  res = 0;
#line 3114
  ql_dbg(8192U, vha, 61478, "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
         (int )vha->vp_idx, (uint8_t *)(& iocb->u.isp24.port_id), (int )iocb->u.isp24.status_subcode);
#line 3118
  switch ((int )iocb->u.isp24.status_subcode) {
  case 3: ;
  case 4: ;
  case 32: ;
  case 5: ;
  case 33: 
#line 3124
  res = qlt_reset(vha, (void *)iocb, 65533);
#line 3125
  goto ldv_61934;
  case 80: ;
  case 82: 
#line 3129
  tgt = ha->tgt.qla_tgt;
#line 3130
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 3131
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
#line 3133
    tgt->link_reinit_iocb_pending = 0U;
  } else {

  }
#line 3135
  res = 1;
#line 3136
  goto ldv_61934;
  default: 
#line 3140
  ql_dbg(8192U, vha, 61537, "qla_target(%d): Unsupported ELS command %x received\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.status_subcode);
#line 3143
  res = qlt_reset(vha, (void *)iocb, 65533);
#line 3144
  goto ldv_61934;
  }
  ldv_61934: ;
#line 3147
  return (res);
}
}
#line 3150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_set_data_offset(struct qla_tgt_cmd *cmd , uint32_t offset ) 
{ 
  struct scatterlist *sg ;
  struct scatterlist *sgp ;
  struct scatterlist *sg_srr ;
  struct scatterlist *sg_srr_start ;
  size_t first_offset ;
  size_t rem_offset ;
  size_t tmp ;
  int i ;
  int sg_srr_cnt ;
  int bufflen ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct page *tmp___1 ;
  void *tmp___2 ;
  struct page *tmp___3 ;
  struct page *tmp___4 ;

  {
#line 3152
  sg_srr_start = (struct scatterlist *)0;
#line 3153
  first_offset = 0UL;
#line 3153
  rem_offset = (size_t )offset;
#line 3153
  tmp = 0UL;
#line 3154
  bufflen = 0;
#line 3156
  ql_dbg(16384U, cmd->vha, 57379, "Entering qla_tgt_set_data_offset: cmd: %p, cmd->sg: %p, cmd->sg_cnt: %u, direction: %d\n",
         cmd, cmd->sg, cmd->sg_cnt, (unsigned int )cmd->dma_data_direction);
#line 3165
  descriptor.modname = "qla2xxx";
#line 3165
  descriptor.function = "qlt_set_data_offset";
#line 3165
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 3165
  descriptor.format = "Rejecting non zero SRR rel_offs: %u\n";
#line 3165
  descriptor.lineno = 3165U;
#line 3165
  descriptor.flags = 0U;
#line 3165
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3165
  if (tmp___0 != 0L) {
#line 3165
    __dynamic_pr_debug(& descriptor, "Rejecting non zero SRR rel_offs: %u\n", offset);
  } else {

  }
#line 3166
  return (-1);
#line 3168
  if ((unsigned long )cmd->sg == (unsigned long )((struct scatterlist *)0) || cmd->sg_cnt == 0) {
#line 3169
    ql_dbg(16384U, cmd->vha, 57429, "Missing cmd->sg or zero cmd->sg_cnt in qla_tgt_set_data_offset\n");
#line 3172
    return (-22);
  } else {

  }
#line 3177
  i = 0;
#line 3177
  sg = cmd->sg;
#line 3177
  goto ldv_61957;
  ldv_61956: 
#line 3178
  tmp___1 = sg_page___3(sg);
#line 3178
  ql_dbg(16384U, cmd->vha, 57380, "sg[%d]: %p page: %p, length: %d, offset: %d\n",
         i, sg, tmp___1, sg->length, sg->offset);
#line 3182
  if ((size_t )sg->length + tmp > (size_t )offset) {
#line 3183
    first_offset = rem_offset;
#line 3184
    sg_srr_start = sg;
#line 3185
    ql_dbg(16384U, cmd->vha, 57381, "Found matching sg[%d], using %p as sg_srr_start, and using first_offset: %zu\n",
           i, sg, first_offset);
#line 3189
    goto ldv_61955;
  } else {

  }
#line 3191
  tmp = (size_t )sg->length + tmp;
#line 3192
  rem_offset = rem_offset - (size_t )sg->length;
#line 3177
  i = i + 1;
#line 3177
  sg = sg_next(sg);
  ldv_61957: ;
#line 3177
  if (cmd->sg_cnt > i) {
#line 3179
    goto ldv_61956;
  } else {

  }
  ldv_61955: ;
#line 3195
  if ((unsigned long )sg_srr_start == (unsigned long )((struct scatterlist *)0)) {
#line 3196
    ql_dbg(16384U, cmd->vha, 57430, "Unable to locate sg_srr_start for offset: %u\n",
           offset);
#line 3198
    return (-22);
  } else {

  }
#line 3200
  sg_srr_cnt = cmd->sg_cnt - i;
#line 3202
  tmp___2 = kzalloc((unsigned long )sg_srr_cnt * 40UL, 208U);
#line 3202
  sg_srr = (struct scatterlist *)tmp___2;
#line 3203
  if ((unsigned long )sg_srr == (unsigned long )((struct scatterlist *)0)) {
#line 3204
    ql_dbg(16384U, cmd->vha, 57431, "Unable to allocate sgp\n");
#line 3206
    return (-12);
  } else {

  }
#line 3208
  sg_init_table(sg_srr, (unsigned int )sg_srr_cnt);
#line 3209
  sgp = sg_srr;
#line 3214
  i = 0;
#line 3214
  sg = sg_srr_start;
#line 3214
  goto ldv_61960;
  ldv_61959: ;
#line 3215
  if (first_offset != 0UL) {
#line 3216
    tmp___3 = sg_page___3(sg);
#line 3216
    sg_set_page(sgp, tmp___3, sg->length - (unsigned int )first_offset, (unsigned int )first_offset);
#line 3218
    first_offset = 0UL;
  } else {
#line 3220
    tmp___4 = sg_page___3(sg);
#line 3220
    sg_set_page(sgp, tmp___4, sg->length, 0U);
  }
#line 3222
  bufflen = (int )(sgp->length + (unsigned int )bufflen);
#line 3224
  sgp = sg_next(sgp);
#line 3225
  if ((unsigned long )sgp == (unsigned long )((struct scatterlist *)0)) {
#line 3226
    goto ldv_61958;
  } else {

  }
#line 3214
  i = i + 1;
#line 3214
  sg = sg_next(sg);
  ldv_61960: ;
#line 3214
  if (i < sg_srr_cnt) {
#line 3216
    goto ldv_61959;
  } else {

  }
  ldv_61958: 
#line 3229
  cmd->sg = sg_srr;
#line 3230
  cmd->sg_cnt = sg_srr_cnt;
#line 3231
  cmd->bufflen = bufflen;
#line 3232
  cmd->offset = (int )((uint32_t )cmd->offset + offset);
#line 3233
  cmd->free_sg = 1U;
#line 3235
  ql_dbg(16384U, cmd->vha, 57382, "New cmd->sg: %p\n", cmd->sg);
#line 3236
  ql_dbg(16384U, cmd->vha, 57383, "New cmd->sg_cnt: %u\n", cmd->sg_cnt);
#line 3238
  ql_dbg(16384U, cmd->vha, 57384, "New cmd->bufflen: %u\n", cmd->bufflen);
#line 3240
  ql_dbg(16384U, cmd->vha, 57385, "New cmd->offset: %u\n", cmd->offset);
#line 3243
  if (cmd->sg_cnt < 0) {
#line 3244
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (3244), "i" (12UL));
    ldv_61961: ;
#line 3244
    goto ldv_61961;
  } else {

  }
#line 3246
  if (cmd->bufflen < 0) {
#line 3247
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                         "i" (3247), "i" (12UL));
    ldv_61962: ;
#line 3247
    goto ldv_61962;
  } else {

  }
#line 3249
  return (0);
}
}
#line 3252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
__inline static int qlt_srr_adjust_data(struct qla_tgt_cmd *cmd , uint32_t srr_rel_offs ,
                                        int *xmit_type ) 
{ 
  int res ;
  int rel_offs ;

  {
#line 3255
  res = 0;
#line 3257
  rel_offs = (int )(srr_rel_offs - (uint32_t )cmd->offset);
#line 3258
  ql_dbg(8192U, cmd->vha, 61479, "srr_rel_offs=%d, rel_offs=%d", srr_rel_offs, rel_offs);
#line 3261
  *xmit_type = 3;
#line 3263
  if (rel_offs < 0) {
#line 3264
    ql_dbg(8192U, cmd->vha, 61538, "qla_target(%d): SRR rel_offs (%d) < 0", (int )(cmd->vha)->vp_idx,
           rel_offs);
#line 3267
    res = -1;
  } else
#line 3268
  if (cmd->bufflen == rel_offs) {
#line 3269
    *xmit_type = 2;
  } else
#line 3270
  if (rel_offs > 0) {
#line 3271
    res = qlt_set_data_offset(cmd, (uint32_t )rel_offs);
  } else {

  }
#line 3273
  return (res);
}
}
#line 3277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_handle_srr(struct scsi_qla_host *vha , struct qla_tgt_srr_ctio *sctio ,
                           struct qla_tgt_srr_imm *imm ) 
{ 
  struct imm_ntfy_from_isp *ntfy ;
  struct qla_hw_data *ha ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd *se_cmd ;
  unsigned long flags ;
  int xmit_type ;
  int resp ;
  uint32_t offset ;
  uint16_t srr_ui ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  int tmp___5 ;
  raw_spinlock_t *tmp___6 ;

  {
#line 3280
  ntfy = & imm->imm_ntfy;
#line 3282
  ha = vha->hw;
#line 3283
  cmd = sctio->cmd;
#line 3284
  se_cmd = & cmd->se_cmd;
#line 3286
  xmit_type = 0;
#line 3286
  resp = 0;
#line 3290
  offset = ntfy->u.isp24.srr_rel_offs;
#line 3291
  srr_ui = ntfy->u.isp24.srr_ui;
#line 3293
  ql_dbg(8192U, vha, 61480, "SRR cmd %p, srr_ui %x\n", cmd, (int )srr_ui);
#line 3296
  switch ((int )srr_ui) {
  case 7: 
#line 3298
  tmp = spinlock_check(& ha->hardware_lock);
#line 3298
  flags = _raw_spin_lock_irqsave(tmp);
#line 3299
  qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3301
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3302
  xmit_type = 2;
#line 3303
  resp = 1;
#line 3304
  goto ldv_61988;
  case 1: ;
#line 3306
  if ((unsigned long )cmd->sg == (unsigned long )((struct scatterlist *)0) || cmd->sg_cnt == 0) {
#line 3307
    ql_dbg(8192U, vha, 61539, "Unable to process SRR_IU_DATA_IN due to missing cmd->sg, state: %d\n",
           cmd->state);
#line 3310
    dump_stack();
#line 3311
    goto out_reject;
  } else {

  }
#line 3313
  if ((unsigned int )se_cmd->scsi_status != 0U) {
#line 3314
    ql_dbg(16384U, vha, 57386, "Rejecting SRR_IU_DATA_IN with non GOOD scsi_status\n");
#line 3317
    goto out_reject;
  } else {

  }
#line 3319
  cmd->bufflen = (int )se_cmd->data_length;
#line 3321
  tmp___2 = qlt_has_data(cmd);
#line 3321
  if (tmp___2 != 0) {
#line 3322
    tmp___0 = qlt_srr_adjust_data(cmd, offset, & xmit_type);
#line 3322
    if (tmp___0 != 0) {
#line 3323
      goto out_reject;
    } else {

    }
#line 3324
    tmp___1 = spinlock_check(& ha->hardware_lock);
#line 3324
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 3325
    qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3327
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3328
    resp = 1;
  } else {
#line 3330
    ql_dbg(8192U, vha, 61540, "qla_target(%d): SRR for in data for cmd without them (tag %d, SCSI status %d), reject",
           (int )vha->vp_idx, cmd->tag, (int )cmd->se_cmd.scsi_status);
#line 3335
    goto out_reject;
  }
#line 3337
  goto ldv_61988;
  case 5: ;
#line 3339
  if ((unsigned long )cmd->sg == (unsigned long )((struct scatterlist *)0) || cmd->sg_cnt == 0) {
#line 3340
    ql_dbg(8192U, vha, 61541, "Unable to process SRR_IU_DATA_OUT due to missing cmd->sg\n");
#line 3343
    dump_stack();
#line 3344
    goto out_reject;
  } else {

  }
#line 3346
  if ((unsigned int )se_cmd->scsi_status != 0U) {
#line 3347
    ql_dbg(16384U, vha, 57387, "Rejecting SRR_IU_DATA_OUT with non GOOD scsi_status\n");
#line 3350
    goto out_reject;
  } else {

  }
#line 3352
  cmd->bufflen = (int )se_cmd->data_length;
#line 3354
  tmp___5 = qlt_has_data(cmd);
#line 3354
  if (tmp___5 != 0) {
#line 3355
    tmp___3 = qlt_srr_adjust_data(cmd, offset, & xmit_type);
#line 3355
    if (tmp___3 != 0) {
#line 3356
      goto out_reject;
    } else {

    }
#line 3357
    tmp___4 = spinlock_check(& ha->hardware_lock);
#line 3357
    flags = _raw_spin_lock_irqsave(tmp___4);
#line 3358
    qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 0, 0, 0);
#line 3360
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3361
    if (xmit_type & 1) {
#line 3362
      qlt_rdy_to_xfer(cmd);
    } else {

    }
  } else {
#line 3364
    ql_dbg(8192U, vha, 61542, "qla_target(%d): SRR for out data for cmd without them (tag %d, SCSI status %d), reject",
           (int )vha->vp_idx, cmd->tag, (int )cmd->se_cmd.scsi_status);
#line 3369
    goto out_reject;
  }
#line 3371
  goto ldv_61988;
  default: 
#line 3373
  ql_dbg(8192U, vha, 61543, "qla_target(%d): Unknown srr_ui value %x", (int )vha->vp_idx,
         (int )srr_ui);
#line 3376
  goto out_reject;
  }
  ldv_61988: ;
#line 3380
  if (resp != 0) {
#line 3381
    qlt_xmit_response(cmd, xmit_type, (int )se_cmd->scsi_status);
  } else {

  }
#line 3383
  return;
  out_reject: 
#line 3386
  tmp___6 = spinlock_check(& ha->hardware_lock);
#line 3386
  flags = _raw_spin_lock_irqsave(tmp___6);
#line 3387
  qlt_send_notify_ack(vha, ntfy, 0U, 0, 0, 1, 9, 0);
#line 3391
  if (cmd->state == 1) {
#line 3392
    cmd->state = 2;
#line 3393
    dump_stack();
  } else {
#line 3395
    qlt_send_term_exchange(vha, cmd, & cmd->atio, 1);
  }
#line 3396
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 3397
  return;
}
}
#line 3399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha , struct qla_tgt_srr_imm *imm ,
                                    int ha_locked ) 
{ 
  struct qla_hw_data *ha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 3402
  ha = vha->hw;
#line 3403
  flags = 0UL;
#line 3405
  if (ha_locked == 0) {
#line 3406
    tmp = spinlock_check(& ha->hardware_lock);
#line 3406
    flags = _raw_spin_lock_irqsave(tmp);
  } else {

  }
#line 3408
  qlt_send_notify_ack(vha, & imm->imm_ntfy, 0U, 0, 0, 1, 9, 0);
#line 3413
  if (ha_locked == 0) {
#line 3414
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
  } else {

  }
#line 3416
  kfree((void const   *)imm);
#line 3417
  return;
}
}
#line 3419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_handle_srr_work(struct work_struct *work ) 
{ 
  struct qla_tgt *tgt ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  struct qla_tgt_srr_ctio *sctio ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_imm *imm ;
  struct qla_tgt_srr_imm *i ;
  struct qla_tgt_srr_imm *ti ;
  struct qla_tgt_cmd *cmd ;
  struct se_cmd *se_cmd ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 3421
  __mptr = (struct work_struct  const  *)work;
#line 3421
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffd10UL;
#line 3422
  vha = tgt->vha;
#line 3426
  ql_dbg(8192U, vha, 61481, "Entering SRR work (tgt %p)\n", tgt);
  restart: 
#line 3430
  tmp = spinlock_check(& tgt->srr_lock);
#line 3430
  flags = _raw_spin_lock_irqsave(tmp);
#line 3431
  __mptr___0 = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 3431
  sctio = (struct qla_tgt_srr_ctio *)__mptr___0;
#line 3431
  goto ldv_62045;
  ldv_62044: 
#line 3436
  imm = (struct qla_tgt_srr_imm *)0;
#line 3437
  __mptr___1 = (struct list_head  const  *)tgt->srr_imm_list.next;
#line 3437
  i = (struct qla_tgt_srr_imm *)__mptr___1;
#line 3437
  __mptr___2 = (struct list_head  const  *)i->srr_list_entry.next;
#line 3437
  ti = (struct qla_tgt_srr_imm *)__mptr___2;
#line 3437
  goto ldv_62041;
  ldv_62040: ;
#line 3439
  if (i->srr_id == sctio->srr_id) {
#line 3440
    list_del(& i->srr_list_entry);
#line 3441
    if ((unsigned long )imm != (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 3442
      ql_dbg(8192U, vha, 61544, "qla_target(%d): There must be only one IMM SRR per CTIO SRR (IMM SRR %p, id %d, CTIO %p\n",
             (int )vha->vp_idx, i, i->srr_id, sctio);
#line 3447
      qlt_reject_free_srr_imm(tgt->vha, i, 0);
    } else {
#line 3449
      imm = i;
    }
  } else {

  }
#line 3437
  i = ti;
#line 3437
  __mptr___3 = (struct list_head  const  *)ti->srr_list_entry.next;
#line 3437
  ti = (struct qla_tgt_srr_imm *)__mptr___3;
  ldv_62041: ;
#line 3437
  if ((unsigned long )(& i->srr_list_entry) != (unsigned long )(& tgt->srr_imm_list)) {
#line 3439
    goto ldv_62040;
  } else {

  }
#line 3453
  ql_dbg(8192U, vha, 61482, "IMM SRR %p, CTIO SRR %p (id %d)\n", imm, sctio, sctio->srr_id);
#line 3457
  if ((unsigned long )imm == (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 3458
    ql_dbg(8192U, vha, 61483, "Not found matching IMM for SRR CTIO (id %d)\n", sctio->srr_id);
#line 3461
    goto ldv_62043;
  } else {
#line 3463
    list_del(& sctio->srr_list_entry);
  }
#line 3465
  spin_unlock_irqrestore(& tgt->srr_lock, flags);
#line 3467
  cmd = sctio->cmd;
#line 3473
  cmd->offset = 0;
#line 3474
  if ((unsigned int )*((unsigned char *)cmd + 1256UL) != 0U) {
#line 3475
    kfree((void const   *)cmd->sg);
#line 3476
    cmd->sg = (struct scatterlist *)0;
#line 3477
    cmd->free_sg = 0U;
  } else {

  }
#line 3479
  se_cmd = & cmd->se_cmd;
#line 3481
  cmd->sg_cnt = (int )se_cmd->t_data_nents;
#line 3482
  cmd->sg = se_cmd->t_data_sg;
#line 3484
  ql_dbg(8192U, vha, 61484, "SRR cmd %p (se_cmd %p, tag %d, op %x), sg_cnt=%d, offset=%d",
         cmd, & cmd->se_cmd, cmd->tag, (int )*(se_cmd->t_task_cdb), cmd->sg_cnt, cmd->offset);
#line 3489
  qlt_handle_srr(vha, sctio, imm);
#line 3491
  kfree((void const   *)imm);
#line 3492
  kfree((void const   *)sctio);
#line 3493
  goto restart;
  ldv_62043: 
#line 3431
  __mptr___4 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 3431
  sctio = (struct qla_tgt_srr_ctio *)__mptr___4;
  ldv_62045: ;
#line 3431
  if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 3433
    goto ldv_62044;
  } else {

  }
#line 3495
  spin_unlock_irqrestore(& tgt->srr_lock, flags);
#line 3496
  return;
}
}
#line 3499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_prepare_srr_imm(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_tgt_srr_imm *imm ;
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  struct qla_tgt_srr_ctio *sctio ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int found ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct qla_tgt_srr_ctio *ts ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 3503
  ha = vha->hw;
#line 3504
  tgt = ha->tgt.qla_tgt;
#line 3507
  tgt->imm_srr_id = tgt->imm_srr_id + 1;
#line 3509
  ql_dbg(8192U, vha, 61485, "qla_target(%d): SRR received\n", (int )vha->vp_idx);
#line 3512
  tmp = kzalloc(88UL, 32U);
#line 3512
  imm = (struct qla_tgt_srr_imm *)tmp;
#line 3513
  if ((unsigned long )imm != (unsigned long )((struct qla_tgt_srr_imm *)0)) {
#line 3514
    __len = 64UL;
#line 3514
    if (__len > 63UL) {
#line 3514
      __ret = __memcpy((void *)(& imm->imm_ntfy), (void const   *)iocb, __len);
    } else {
#line 3514
      __ret = __builtin_memcpy((void *)(& imm->imm_ntfy), (void const   *)iocb, __len);
    }
#line 3517
    spin_lock(& tgt->srr_lock);
#line 3518
    imm->srr_id = tgt->imm_srr_id;
#line 3519
    list_add_tail(& imm->srr_list_entry, & tgt->srr_imm_list);
#line 3521
    ql_dbg(8192U, vha, 61486, "IMM NTFY SRR %p added (id %d, ui %x)\n", imm, imm->srr_id,
           (int )iocb->u.isp24.srr_ui);
#line 3524
    if (tgt->imm_srr_id == tgt->ctio_srr_id) {
#line 3525
      found = 0;
#line 3526
      __mptr = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 3526
      sctio = (struct qla_tgt_srr_ctio *)__mptr;
#line 3526
      goto ldv_62065;
      ldv_62064: ;
#line 3528
      if (sctio->srr_id == imm->srr_id) {
#line 3529
        found = 1;
#line 3530
        goto ldv_62063;
      } else {

      }
#line 3526
      __mptr___0 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 3526
      sctio = (struct qla_tgt_srr_ctio *)__mptr___0;
      ldv_62065: ;
#line 3526
      if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 3528
        goto ldv_62064;
      } else {

      }
      ldv_62063: ;
#line 3533
      if (found != 0) {
#line 3534
        ql_dbg(8192U, vha, 61487, "%s", (char *)"Scheduling srr work\n");
#line 3536
        schedule_work(& tgt->srr_work);
      } else {
#line 3538
        ql_dbg(8192U, vha, 61488, "qla_target(%d): imm_srr_id == ctio_srr_id (%d), but there is no corresponding SRR CTIO, deleting IMM SRR %p\n",
               (int )vha->vp_idx, tgt->ctio_srr_id, imm);
#line 3544
        list_del(& imm->srr_list_entry);
#line 3546
        kfree((void const   *)imm);
#line 3548
        spin_unlock(& tgt->srr_lock);
#line 3549
        goto out_reject;
      }
    } else {

    }
#line 3552
    spin_unlock(& tgt->srr_lock);
  } else {
#line 3556
    ql_dbg(8192U, vha, 61545, "qla_target(%d): Unable to allocate SRR IMM entry, SRR request will be rejected\n",
           (int )vha->vp_idx);
#line 3561
    spin_lock(& tgt->srr_lock);
#line 3562
    __mptr___1 = (struct list_head  const  *)tgt->srr_ctio_list.next;
#line 3562
    sctio = (struct qla_tgt_srr_ctio *)__mptr___1;
#line 3562
    __mptr___2 = (struct list_head  const  *)sctio->srr_list_entry.next;
#line 3562
    ts = (struct qla_tgt_srr_ctio *)__mptr___2;
#line 3562
    goto ldv_62075;
    ldv_62074: ;
#line 3564
    if (sctio->srr_id == tgt->imm_srr_id) {
#line 3565
      ql_dbg(8192U, vha, 61489, "CTIO SRR %p deleted (id %d)\n", sctio, sctio->srr_id);
#line 3568
      list_del(& sctio->srr_list_entry);
#line 3569
      qlt_send_term_exchange(vha, sctio->cmd, & (sctio->cmd)->atio, 1);
#line 3571
      kfree((void const   *)sctio);
    } else {

    }
#line 3562
    sctio = ts;
#line 3562
    __mptr___3 = (struct list_head  const  *)ts->srr_list_entry.next;
#line 3562
    ts = (struct qla_tgt_srr_ctio *)__mptr___3;
    ldv_62075: ;
#line 3562
    if ((unsigned long )(& sctio->srr_list_entry) != (unsigned long )(& tgt->srr_ctio_list)) {
#line 3564
      goto ldv_62074;
    } else {

    }
#line 3574
    spin_unlock(& tgt->srr_lock);
#line 3575
    goto out_reject;
  }
#line 3578
  return;
  out_reject: 
#line 3581
  qlt_send_notify_ack(vha, iocb, 0U, 0, 0, 1, 9, 0);
#line 3582
  return;
}
}
#line 3590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_handle_imm_notify(struct scsi_qla_host *vha , struct imm_ntfy_from_isp *iocb ) 
{ 
  struct qla_hw_data *ha ;
  uint32_t add_flags ;
  int send_notify_ack ;
  uint16_t status ;
  int tmp ;
  struct qla_tgt *tgt ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 3593
  ha = vha->hw;
#line 3594
  add_flags = 0U;
#line 3595
  send_notify_ack = 1;
#line 3598
  status = iocb->u.isp2x.status;
#line 3599
  switch ((int )status) {
  case 14: 
#line 3602
  ql_dbg(8192U, vha, 61490, "qla_target(%d): LIP reset (loop %#x), subcode %x\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 3607
  tmp = qlt_reset(vha, (void *)iocb, 65534);
#line 3607
  if (tmp == 0) {
#line 3608
    send_notify_ack = 0;
  } else {

  }
#line 3609
  goto ldv_62086;
  case 15: 
#line 3614
  tgt = ha->tgt.qla_tgt;
#line 3615
  ql_dbg(8192U, vha, 61491, "qla_target(%d): LINK REINIT (loop %#x, subcode %x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 3620
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 3621
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
  } else {

  }
#line 3624
  __len = 64UL;
#line 3624
  if (__len > 63UL) {
#line 3624
    __ret = __memcpy((void *)(& tgt->link_reinit_iocb), (void const   *)iocb, __len);
  } else {
#line 3624
    __ret = __builtin_memcpy((void *)(& tgt->link_reinit_iocb), (void const   *)iocb,
                             __len);
  }
#line 3625
  tgt->link_reinit_iocb_pending = 1U;
#line 3630
  send_notify_ack = 0;
#line 3631
  goto ldv_62086;
  case 41: 
#line 3635
  ql_dbg(8192U, vha, 61492, "qla_target(%d): Port logout (loop %#x, subcode %x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp24.nport_handle, (int )iocb->u.isp24.status_subcode);
#line 3641
  tmp___0 = qlt_reset(vha, (void *)iocb, 65533);
#line 3641
  if (tmp___0 == 0) {
#line 3642
    send_notify_ack = 0;
  } else {

  }
#line 3644
  goto ldv_62086;
  case 45: 
#line 3647
  ql_dbg(8192U, vha, 61493, "qla_target(%d): Global TPRLO (%x)\n", (int )vha->vp_idx,
         (int )status);
#line 3649
  tmp___1 = qlt_reset(vha, (void *)iocb, 65532);
#line 3649
  if (tmp___1 == 0) {
#line 3650
    send_notify_ack = 0;
  } else {

  }
#line 3652
  goto ldv_62086;
  case 42: 
#line 3655
  ql_dbg(8192U, vha, 61494, "qla_target(%d): Port config changed (%x)\n", (int )vha->vp_idx,
         (int )status);
#line 3658
  tmp___2 = qlt_reset(vha, (void *)iocb, 65534);
#line 3658
  if (tmp___2 == 0) {
#line 3659
    send_notify_ack = 0;
  } else {

  }
#line 3661
  goto ldv_62086;
  case 46: 
#line 3664
  ql_dbg(8192U, vha, 61546, "qla_target(%d): Link failure detected\n", (int )vha->vp_idx);
#line 3668
  tmp___3 = qlt_reset(vha, (void *)iocb, 65532);
#line 3668
  if (tmp___3 == 0) {
#line 3669
    send_notify_ack = 0;
  } else {

  }
#line 3670
  goto ldv_62086;
  case 22: 
#line 3673
  ql_dbg(8192U, vha, 61547, "qla_target(%d): Cannot provide requested capability (IOCB overflowed the immediate notify resource count)\n",
         (int )vha->vp_idx);
#line 3677
  goto ldv_62086;
  case 32: 
#line 3680
  ql_dbg(8192U, vha, 61495, "qla_target(%d): Abort Task (S %08x I %#x -> L %#x)\n",
         (int )vha->vp_idx, (int )iocb->u.isp2x.seq_id, (int )ha->device_type < 0 ? (int )((struct atio_from_isp *)iocb)->u.isp2x.target.extended : (int )((struct atio_from_isp *)iocb)->u.isp2x.target.id.standard,
         (int )iocb->u.isp2x.lun);
#line 3686
  tmp___4 = qlt_abort_task(vha, iocb);
#line 3686
  if (tmp___4 == 0) {
#line 3687
    send_notify_ack = 0;
  } else {

  }
#line 3688
  goto ldv_62086;
  case 52: 
#line 3691
  ql_dbg(8192U, vha, 61548, "qla_target(%d): Out of resources, host %ld\n", (int )vha->vp_idx,
         vha->host_no);
#line 3694
  goto ldv_62086;
  case 54: 
#line 3697
  ql_dbg(8192U, vha, 61496, "qla_target(%d): Immediate notify task %x\n", (int )vha->vp_idx,
         (int )iocb->u.isp2x.task_flags);
#line 3700
  tmp___5 = qlt_handle_task_mgmt(vha, (void *)iocb);
#line 3700
  if (tmp___5 == 0) {
#line 3701
    send_notify_ack = 0;
  } else {

  }
#line 3702
  goto ldv_62086;
  case 70: 
#line 3705
  tmp___6 = qlt_24xx_handle_els(vha, iocb);
#line 3705
  if (tmp___6 == 0) {
#line 3706
    send_notify_ack = 0;
  } else {

  }
#line 3707
  goto ldv_62086;
  case 69: 
#line 3710
  qlt_prepare_srr_imm(vha, iocb);
#line 3711
  send_notify_ack = 0;
#line 3712
  goto ldv_62086;
  default: 
#line 3715
  ql_dbg(8192U, vha, 61549, "qla_target(%d): Received unknown immediate notify status %x\n",
         (int )vha->vp_idx, (int )status);
#line 3718
  goto ldv_62086;
  }
  ldv_62086: ;
#line 3721
  if (send_notify_ack != 0) {
#line 3722
    qlt_send_notify_ack(vha, iocb, add_flags, 0, 0, 0, 0, 0);
  } else {

  }
#line 3723
  return;
}
}
#line 3729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_send_busy(struct scsi_qla_host *vha , struct atio_from_isp *atio ,
                          uint16_t status ) 
{ 
  struct ctio7_to_24xx *ctio24 ;
  struct qla_hw_data *ha ;
  request_t *pkt ;
  struct qla_tgt_sess *sess ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 3733
  ha = vha->hw;
#line 3735
  sess = (struct qla_tgt_sess *)0;
#line 3737
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& atio->u.isp24.fcp_hdr.s_id));
#line 3739
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 3740
    qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, atio, 1);
#line 3741
    return;
  } else {

  }
#line 3745
  tmp = qla2x00_alloc_iocbs(vha, (srb_t *)0);
#line 3745
  pkt = (request_t *)tmp;
#line 3746
  if ((unsigned long )pkt == (unsigned long )((request_t *)0)) {
#line 3747
    ql_dbg(8192U, vha, 61550, "qla_target(%d): %s failed: unable to allocate request packet",
           (int )vha->vp_idx, "qlt_send_busy");
#line 3750
    return;
  } else {

  }
#line 3753
  pkt->entry_count = 1U;
#line 3754
  pkt->handle = 4294967295U;
#line 3756
  ctio24 = (struct ctio7_to_24xx *)pkt;
#line 3757
  ctio24->entry_type = 18U;
#line 3758
  ctio24->nport_handle = sess->loop_id;
#line 3759
  ctio24->timeout = 10U;
#line 3760
  ctio24->vp_index = (uint8_t )vha->vp_idx;
#line 3761
  ctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
#line 3762
  ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
#line 3763
  ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
#line 3764
  ctio24->exchange_addr = atio->u.isp24.exchange_addr;
#line 3765
  ctio24->u.status1.flags = (uint16_t )((int )((short )((int )atio->u.isp24.attr << 9)) | -32448);
#line 3773
  tmp___0 = __fswab16((int )atio->u.isp24.fcp_hdr.ox_id);
#line 3773
  ctio24->u.status1.ox_id = tmp___0;
#line 3774
  ctio24->u.status1.scsi_status = status;
#line 3775
  ctio24->u.status1.residual = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 3778
  if (ctio24->u.status1.residual != 0U) {
#line 3779
    ctio24->u.status1.scsi_status = (uint16_t )((unsigned int )ctio24->u.status1.scsi_status | 2048U);
  } else {

  }
#line 3781
  qla2x00_start_iocbs(vha, vha->req);
#line 3782
  return;
}
}
#line 3786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha , struct atio_from_isp *atio ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  int rc ;
  long tmp ;
  u32 tmp___0 ;
  __u32 tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 3789
  ha = vha->hw;
#line 3790
  tgt = ha->tgt.qla_tgt;
#line 3793
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 3793
  if (tmp != 0L) {
#line 3794
    ql_dbg(8192U, vha, 61497, "ATIO pkt, but no tgt (ha %p)", ha);
#line 3796
    return;
  } else {

  }
#line 3798
  ql_dbg(16384U, vha, 57388, "qla_target(%d): ATIO pkt %p: type %02x count %02x",
         (int )vha->vp_idx, atio, (int )atio->u.raw.entry_type, (int )atio->u.raw.entry_count);
#line 3807
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 3809
  switch ((int )atio->u.raw.entry_type) {
  case 6: 
#line 3811
  tmp___0 = get_unaligned_le32((void const   *)(& atio->u.isp24.fcp_cmnd.add_cdb) + (unsigned long )atio->u.isp24.fcp_cmnd.add_cdb_len);
#line 3811
  tmp___1 = __fswab32(tmp___0);
#line 3811
  ql_dbg(16384U, vha, 57389, "ATIO_TYPE7 instance %d, lun %Lx, read/write %d/%d, add_cdb_len %d, data_length %04x, s_id %x:%x:%x\n",
         (int )vha->vp_idx, atio->u.isp24.fcp_cmnd.lun, (int )atio->u.isp24.fcp_cmnd.rddata,
         (int )atio->u.isp24.fcp_cmnd.wrdata, (int )atio->u.isp24.fcp_cmnd.add_cdb_len,
         tmp___1, (int )atio->u.isp24.fcp_hdr.s_id[0], (int )atio->u.isp24.fcp_hdr.s_id[1],
         (int )atio->u.isp24.fcp_hdr.s_id[2]);
#line 3825
  tmp___2 = ldv__builtin_expect(atio->u.isp24.exchange_addr == 4294967295U, 0L);
#line 3825
  if (tmp___2 != 0L) {
#line 3827
    ql_dbg(16384U, vha, 57432, "qla_target(%d): ATIO_TYPE7 received with UNKNOWN exchange address, sending QUEUE_FULL\n",
           (int )vha->vp_idx);
#line 3831
    qlt_send_busy(vha, atio, 40);
#line 3832
    goto ldv_62121;
  } else {

  }
#line 3834
  tmp___3 = ldv__builtin_expect((unsigned int )atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0U,
                             1L);
#line 3834
  if (tmp___3 != 0L) {
#line 3835
    rc = qlt_handle_cmd_for_atio(vha, atio);
  } else {
#line 3837
    rc = qlt_handle_task_mgmt(vha, (void *)atio);
  }
#line 3838
  tmp___4 = ldv__builtin_expect(rc != 0, 0L);
#line 3838
  if (tmp___4 != 0L) {
#line 3839
    if (rc == -3) {
#line 3841
      qlt_send_busy(vha, atio, 8);
    } else
#line 3846
    if (tgt->tgt_stop != 0) {
#line 3847
      ql_dbg(16384U, vha, 57433, "qla_target: Unable to send command to target for req, ignoring.\n");
    } else {
#line 3852
      ql_dbg(16384U, vha, 57434, "qla_target(%d): Unable to send command to target, sending BUSY status.\n",
             (int )vha->vp_idx);
#line 3856
      qlt_send_busy(vha, atio, 8);
    }
  } else {

  }
#line 3860
  goto ldv_62121;
  case 13: 
#line 3864
  tmp___5 = ldv__builtin_expect((unsigned int )atio->u.isp2x.entry_status != 0U, 0L);
#line 3864
  if (tmp___5 != 0L) {
#line 3865
    ql_dbg(16384U, vha, 57435, "qla_target(%d): Received ATIO packet %x with error status %x\n",
           (int )vha->vp_idx, (int )atio->u.raw.entry_type, (int )atio->u.isp2x.entry_status);
#line 3870
    goto ldv_62121;
  } else {

  }
#line 3872
  ql_dbg(16384U, vha, 57390, "%s", (char *)"IMMED_NOTIFY ATIO");
#line 3873
  qlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)atio);
#line 3874
  goto ldv_62121;
  default: 
#line 3878
  ql_dbg(16384U, vha, 57436, "qla_target(%d): Received unknown ATIO atio type %x\n",
         (int )vha->vp_idx, (int )atio->u.raw.entry_type);
#line 3881
  goto ldv_62121;
  }
  ldv_62121: 
#line 3884
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 3885
  return;
}
}
#line 3889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_response_pkt(struct scsi_qla_host *vha , response_t *pkt ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  long tmp ;
  struct ctio7_from_24xx *entry ;
  struct atio_from_isp *atio ;
  int rc ;
  long tmp___0 ;
  struct ctio_to_2xxx *entry___0 ;
  struct ctio_to_2xxx *entry___1 ;
  struct nack_to_isp *entry___2 ;
  struct abts_resp_from_24xx_fw *entry___3 ;

  {
#line 3891
  ha = vha->hw;
#line 3892
  tgt = ha->tgt.qla_tgt;
#line 3894
  tmp = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 3894
  if (tmp != 0L) {
#line 3895
    ql_dbg(16384U, vha, 57437, "qla_target(%d): Response pkt %x received, but no tgt (ha %p)\n",
           (int )vha->vp_idx, (int )pkt->entry_type, ha);
#line 3898
    return;
  } else {

  }
#line 3901
  ql_dbg(16384U, vha, 57391, "qla_target(%d): response pkt %p: T %02x C %02x S %02x handle %#x\n",
         (int )vha->vp_idx, pkt, (int )pkt->entry_type, (int )pkt->entry_count, (int )pkt->entry_status,
         pkt->handle);
#line 3911
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 3913
  switch ((int )pkt->entry_type) {
  case 18: 
#line 3916
  entry = (struct ctio7_from_24xx *)pkt;
#line 3917
  ql_dbg(16384U, vha, 57392, "CTIO_TYPE7: instance %d\n", (int )vha->vp_idx);
#line 3919
  qlt_do_ctio_completion(vha, entry->handle, (uint32_t )((int )entry->status | ((int )pkt->entry_status << 16)),
                         (void *)entry);
#line 3922
  goto ldv_62132;
  case 22: 
#line 3927
  atio = (struct atio_from_isp *)pkt;
#line 3929
  ql_dbg(16384U, vha, 57393, "ACCEPT_TGT_IO instance %d status %04x lun %04x read/write %d data_length %04x target_id %02x rx_id %04x\n ",
         (int )vha->vp_idx, (int )atio->u.isp2x.status, (int )atio->u.isp2x.lun, (int )atio->u.isp2x.execution_codes,
         atio->u.isp2x.data_length, (int )ha->device_type < 0 ? (int )atio->u.isp2x.target.extended : (int )atio->u.isp2x.target.id.standard,
         (int )atio->u.isp2x.rx_id);
#line 3938
  if ((unsigned int )atio->u.isp2x.status != 61U) {
#line 3940
    ql_dbg(16384U, vha, 57438, "qla_target(%d): ATIO with error status %x received\n",
           (int )vha->vp_idx, (int )atio->u.isp2x.status);
#line 3944
    goto ldv_62132;
  } else {

  }
#line 3946
  ql_dbg(16384U, vha, 57394, "FCP CDB: 0x%02x, sizeof(cdb): %lu", (int )atio->u.isp2x.cdb[0],
         16UL);
#line 3951
  rc = qlt_handle_cmd_for_atio(vha, atio);
#line 3952
  tmp___0 = ldv__builtin_expect(rc != 0, 0L);
#line 3952
  if (tmp___0 != 0L) {
#line 3953
    if (rc == -3) {
#line 3955
      qlt_send_busy(vha, atio, 0);
    } else
#line 3960
    if (tgt->tgt_stop != 0) {
#line 3961
      ql_dbg(16384U, vha, 57439, "qla_target: Unable to send command to target, sending TERM EXCHANGE for rsp\n");
#line 3965
      qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, atio, 1);
    } else {
#line 3968
      ql_dbg(16384U, vha, 57440, "qla_target(%d): Unable to send command to target, sending BUSY status\n",
             (int )vha->vp_idx);
#line 3972
      qlt_send_busy(vha, atio, 0);
    }
  } else {

  }
#line 3977
  goto ldv_62132;
  case 23: 
#line 3981
  entry___0 = (struct ctio_to_2xxx *)pkt;
#line 3982
  ql_dbg(16384U, vha, 57395, "CONTINUE_TGT_IO: instance %d\n", (int )vha->vp_idx);
#line 3984
  qlt_do_ctio_completion(vha, entry___0->handle, (uint32_t )((int )entry___0->status | ((int )pkt->entry_status << 16)),
                         (void *)entry___0);
#line 3987
  goto ldv_62132;
  case 31: 
#line 3992
  entry___1 = (struct ctio_to_2xxx *)pkt;
#line 3993
  ql_dbg(16384U, vha, 57396, "CTIO_A64: instance %d\n", (int )vha->vp_idx);
#line 3995
  qlt_do_ctio_completion(vha, entry___1->handle, (uint32_t )((int )entry___1->status | ((int )pkt->entry_status << 16)),
                         (void *)entry___1);
#line 3998
  goto ldv_62132;
  case 13: 
#line 4002
  ql_dbg(16384U, vha, 57397, "%s", (char *)"IMMED_NOTIFY\n");
#line 4003
  qlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)pkt);
#line 4004
  goto ldv_62132;
  case 14: ;
#line 4007
  if (tgt->notify_ack_expected > 0) {
#line 4008
    entry___2 = (struct nack_to_isp *)pkt;
#line 4009
    ql_dbg(16384U, vha, 57398, "NOTIFY_ACK seq %08x status %x\n", (int )entry___2->u.isp2x.seq_id,
           (int )entry___2->u.isp2x.status);
#line 4013
    tgt->notify_ack_expected = tgt->notify_ack_expected - 1;
#line 4014
    if ((unsigned int )entry___2->u.isp2x.status != 1U) {
#line 4016
      ql_dbg(16384U, vha, 57441, "qla_target(%d): NOTIFY_ACK failed %x\n", (int )vha->vp_idx,
             (int )entry___2->u.isp2x.status);
    } else {

    }
  } else {
#line 4022
    ql_dbg(16384U, vha, 57442, "qla_target(%d): Unexpected NOTIFY_ACK received\n",
           (int )vha->vp_idx);
  }
#line 4026
  goto ldv_62132;
  case 84: 
#line 4029
  ql_dbg(16384U, vha, 57399, "ABTS_RECV_24XX: instance %d\n", (int )vha->vp_idx);
#line 4031
  qlt_24xx_handle_abts(vha, (struct abts_recv_from_24xx *)pkt);
#line 4032
  goto ldv_62132;
  case 85: ;
#line 4035
  if (tgt->abts_resp_expected > 0) {
#line 4036
    entry___3 = (struct abts_resp_from_24xx_fw *)pkt;
#line 4038
    ql_dbg(16384U, vha, 57400, "ABTS_RESP_24XX: compl_status %x\n", (int )entry___3->compl_status);
#line 4041
    tgt->abts_resp_expected = tgt->abts_resp_expected - 1;
#line 4042
    if ((unsigned int )entry___3->compl_status != 0U) {
#line 4044
      if (entry___3->error_subcode1 == 30U && entry___3->error_subcode2 == 0U) {
#line 4061
        qlt_24xx_retry_term_exchange(vha, entry___3);
      } else {
#line 4064
        ql_dbg(16384U, vha, 57443, "qla_target(%d): ABTS_RESP_24XX failed %x (subcode %x:%x)",
               (int )vha->vp_idx, (int )entry___3->compl_status, entry___3->error_subcode1,
               entry___3->error_subcode2);
      }
    } else {

    }
  } else {
#line 4072
    ql_dbg(16384U, vha, 57444, "qla_target(%d): Unexpected ABTS_RESP_24XX received\n",
           (int )vha->vp_idx);
  }
#line 4076
  goto ldv_62132;
  default: 
#line 4079
  ql_dbg(16384U, vha, 57445, "qla_target(%d): Received unknown response pkt type %x\n",
         (int )vha->vp_idx, (int )pkt->entry_type);
#line 4082
  goto ldv_62132;
  }
  ldv_62132: 
#line 4085
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4086
  return;
}
}
#line 4091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_async_event(uint16_t code , struct scsi_qla_host *vha , uint16_t *mailbox ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  int login_code ;
  int tmp ;
  long tmp___0 ;

  {
#line 4094
  ha = vha->hw;
#line 4095
  tgt = ha->tgt.qla_tgt;
#line 4098
  tmp = atomic_read((atomic_t const   *)(& vha->loop_state));
#line 4098
  ql_dbg(16384U, vha, 57401, "scsi(%ld): ha state %d init_done %d oper_mode %d topo %d\n",
         vha->host_no, tmp, (int )vha->flags.init_done, (int )ha->operating_mode,
         (int )ha->current_topology);
#line 4103
  if ((unsigned long )ha->tgt.tgt_ops == (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 4104
    return;
  } else {

  }
#line 4106
  tmp___0 = ldv__builtin_expect((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0),
                             0L);
#line 4106
  if (tmp___0 != 0L) {
#line 4107
    ql_dbg(16384U, vha, 57402, "ASYNC EVENT %#x, but no tgt (ha %p)\n", (int )code,
           ha);
#line 4109
    return;
  } else {

  }
#line 4112
  if (((unsigned int )code == 32816U || (unsigned int )code == 32822U) && (int )ha->device_type & 1) {
#line 4114
    return;
  } else {

  }
#line 4120
  tgt->irq_cmd_count = tgt->irq_cmd_count + 1;
#line 4122
  switch ((int )code) {
  case 32769: ;
  case 32770: ;
  case 32771: ;
  case 32772: 
#line 4127
  ql_dbg(8192U, vha, 61498, "qla_target(%d): System error async event %#x occurred",
         (int )vha->vp_idx, (int )code);
#line 4130
  goto ldv_62159;
  case 32773: 
#line 4132
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4133
  goto ldv_62159;
  case 32785: 
#line 4137
  ql_dbg(8192U, vha, 61499, "qla_target(%d): Async LOOP_UP occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4142
  if ((unsigned int )*((unsigned char *)tgt + 32UL) != 0U) {
#line 4143
    qlt_send_notify_ack(vha, & tgt->link_reinit_iocb, 0U, 0, 0, 0, 0, 0);
#line 4145
    tgt->link_reinit_iocb_pending = 0U;
  } else {

  }
#line 4147
  goto ldv_62159;
  case 32784: ;
  case 32786: ;
  case 32787: ;
  case 32789: 
#line 4154
  ql_dbg(8192U, vha, 61500, "qla_target(%d): Async event %#x occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )code, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4159
  goto ldv_62159;
  case 32788: 
#line 4162
  ql_dbg(8192U, vha, 61501, "qla_target(%d): Port update async event %#x occurred: updating the ports database (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )code, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4169
  login_code = (int )*(mailbox + 2UL);
#line 4170
  if (login_code == 4) {
#line 4171
    ql_dbg(8192U, vha, 61502, "Async MB 2: Got PLOGI Complete\n");
  } else
#line 4173
  if (login_code == 7) {
#line 4174
    ql_dbg(8192U, vha, 61503, "Async MB 2: Port Logged Out\n");
  } else {

  }
#line 4176
  goto ldv_62159;
  default: 
#line 4179
  ql_dbg(8192U, vha, 61504, "qla_target(%d): Async event %#x occurred: ignore (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
         (int )vha->vp_idx, (int )code, (int )*mailbox, (int )*(mailbox + 1UL), (int )*(mailbox + 2UL),
         (int )*(mailbox + 3UL));
#line 4184
  goto ldv_62159;
  }
  ldv_62159: 
#line 4187
  tgt->irq_cmd_count = tgt->irq_cmd_count - 1;
#line 4188
  return;
}
}
#line 4190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static fc_port_t *qlt_get_port_database(struct scsi_qla_host *vha , uint16_t loop_id ) 
{ 
  fc_port_t *fcport ;
  int rc ;
  void *tmp ;

  {
#line 4196
  tmp = kzalloc(128UL, 208U);
#line 4196
  fcport = (fc_port_t *)tmp;
#line 4197
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 4198
    ql_dbg(8192U, vha, 61551, "qla_target(%d): Allocation of tmp FC port failed",
           (int )vha->vp_idx);
#line 4201
    return ((fc_port_t *)0);
  } else {

  }
#line 4204
  ql_dbg(8192U, vha, 61505, "loop_id %d", (int )loop_id);
#line 4206
  fcport->loop_id = loop_id;
#line 4208
  rc = qla2x00_get_port_database(vha, fcport, 0);
#line 4209
  if (rc != 0) {
#line 4210
    ql_dbg(8192U, vha, 61552, "qla_target(%d): Failed to retrieve fcport information -- get_port_database() returned %x (loop_id=0x%04x)",
           (int )vha->vp_idx, rc, (int )loop_id);
#line 4214
    kfree((void const   *)fcport);
#line 4215
    return ((fc_port_t *)0);
  } else {

  }
#line 4218
  return (fcport);
}
}
#line 4222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha , uint8_t *s_id ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  fc_port_t *fcport ;
  int rc ;
  int global_resets ;
  uint16_t loop_id ;
  int tmp ;
  int tmp___0 ;

  {
#line 4225
  ha = vha->hw;
#line 4226
  sess = (struct qla_tgt_sess *)0;
#line 4227
  fcport = (fc_port_t *)0;
#line 4229
  loop_id = 0U;
  retry: 
#line 4232
  global_resets = atomic_read((atomic_t const   *)(& (ha->tgt.qla_tgt)->tgt_global_resets_count));
#line 4234
  rc = qla24xx_get_loop_id(vha, (uint8_t const   *)s_id, & loop_id);
#line 4235
  if (rc != 0) {
#line 4236
    if ((unsigned int )*s_id == 255U && (unsigned int )*(s_id + 1UL) == 252U) {
#line 4242
      ql_dbg(8192U, vha, 61506, "Unable to find initiator with S_ID %x:%x:%x", (int )*s_id,
             (int )*(s_id + 1UL), (int )*(s_id + 2UL));
    } else {
#line 4246
      ql_dbg(8192U, vha, 61553, "qla_target(%d): Unable to find initiator with S_ID %x:%x:%x",
             (int )vha->vp_idx, (int )*s_id, (int )*(s_id + 1UL), (int )*(s_id + 2UL));
    }
#line 4251
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 4254
  fcport = qlt_get_port_database(vha, (int )loop_id);
#line 4255
  if ((unsigned long )fcport == (unsigned long )((fc_port_t *)0)) {
#line 4256
    return ((struct qla_tgt_sess *)0);
  } else {

  }
#line 4258
  tmp___0 = atomic_read((atomic_t const   *)(& (ha->tgt.qla_tgt)->tgt_global_resets_count));
#line 4258
  if (tmp___0 != global_resets) {
#line 4260
    tmp = atomic_read((atomic_t const   *)(& (ha->tgt.qla_tgt)->tgt_global_resets_count));
#line 4260
    ql_dbg(8192U, vha, 61507, "qla_target(%d): global reset during session discovery (counter was %d, new %d), retrying",
           (int )vha->vp_idx, global_resets, tmp);
#line 4265
    goto retry;
  } else {

  }
#line 4268
  sess = qlt_create_sess(vha, fcport, 1);
#line 4270
  kfree((void const   *)fcport);
#line 4271
  return (sess);
}
}
#line 4274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_abort_work(struct qla_tgt *tgt , struct qla_tgt_sess_work_param *prm ) 
{ 
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  uint32_t be_s_id ;
  uint8_t s_id[3U] ;
  int rc ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 4277
  vha = tgt->vha;
#line 4278
  ha = vha->hw;
#line 4279
  sess = (struct qla_tgt_sess *)0;
#line 4285
  tmp = spinlock_check(& ha->hardware_lock);
#line 4285
  flags = _raw_spin_lock_irqsave(tmp);
#line 4287
  if (tgt->tgt_stop != 0) {
#line 4288
    goto out_term;
  } else {

  }
#line 4290
  s_id[0] = prm->ldv_60976.abts.fcp_hdr_le.s_id[2];
#line 4291
  s_id[1] = prm->ldv_60976.abts.fcp_hdr_le.s_id[1];
#line 4292
  s_id[2] = prm->ldv_60976.abts.fcp_hdr_le.s_id[0];
#line 4294
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)(& be_s_id));
#line 4296
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4297
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4299
    mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 4300
    sess = qlt_make_local_sess(vha, (uint8_t *)(& s_id));
#line 4302
    mutex_unlock(& ha->tgt.tgt_mutex);
#line 4304
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 4304
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 4305
    if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4306
      goto out_term;
    } else {

    }
  } else {
#line 4308
    kref_get(& (sess->se_sess)->sess_kref);
  }
#line 4311
  if (tgt->tgt_stop != 0) {
#line 4312
    goto out_term;
  } else {

  }
#line 4314
  rc = __qlt_24xx_handle_abts(vha, & prm->ldv_60976.abts, sess);
#line 4315
  if (rc != 0) {
#line 4316
    goto out_term;
  } else {

  }
#line 4318
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 4319
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4320
  return;
  out_term: 
#line 4323
  qlt_24xx_send_abts_resp(vha, & prm->ldv_60976.abts, 4U, 0);
#line 4324
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4325
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {

  }
#line 4326
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4327
  return;
}
}
#line 4329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_tmr_work(struct qla_tgt *tgt , struct qla_tgt_sess_work_param *prm ) 
{ 
  struct atio_from_isp *a ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct qla_tgt_sess *sess ;
  unsigned long flags ;
  uint8_t *s_id ;
  int rc ;
  uint32_t lun ;
  uint32_t unpacked_lun ;
  int lun_size ;
  int fn ;
  void *iocb ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 4332
  a = & prm->ldv_60976.tm_iocb2;
#line 4333
  vha = tgt->vha;
#line 4334
  ha = vha->hw;
#line 4335
  sess = (struct qla_tgt_sess *)0;
#line 4337
  s_id = (uint8_t *)0U;
#line 4343
  tmp = spinlock_check(& ha->hardware_lock);
#line 4343
  flags = _raw_spin_lock_irqsave(tmp);
#line 4345
  if (tgt->tgt_stop != 0) {
#line 4346
    goto out_term;
  } else {

  }
#line 4348
  s_id = (uint8_t *)(& prm->ldv_60976.tm_iocb2.u.isp24.fcp_hdr.s_id);
#line 4349
  sess = (*((ha->tgt.tgt_ops)->find_sess_by_s_id))(vha, (uint8_t const   *)s_id);
#line 4350
  if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4351
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4353
    mutex_lock_nested(& ha->tgt.tgt_mutex, 0U);
#line 4354
    sess = qlt_make_local_sess(vha, s_id);
#line 4356
    mutex_unlock(& ha->tgt.tgt_mutex);
#line 4358
    tmp___0 = spinlock_check(& ha->hardware_lock);
#line 4358
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 4359
    if ((unsigned long )sess == (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4360
      goto out_term;
    } else {

    }
  } else {
#line 4362
    kref_get(& (sess->se_sess)->sess_kref);
  }
#line 4365
  iocb = (void *)a;
#line 4366
  lun = (uint32_t )a->u.isp24.fcp_cmnd.lun;
#line 4367
  lun_size = 4;
#line 4368
  fn = (int )a->u.isp24.fcp_cmnd.task_mgmt_flags;
#line 4369
  tmp___1 = scsilun_to_int((struct scsi_lun *)(& lun));
#line 4369
  unpacked_lun = (uint32_t )tmp___1;
#line 4371
  rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
#line 4372
  if (rc != 0) {
#line 4373
    goto out_term;
  } else {

  }
#line 4375
  (*((ha->tgt.tgt_ops)->put_sess))(sess);
#line 4376
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4377
  return;
  out_term: 
#line 4380
  qlt_send_term_exchange(vha, (struct qla_tgt_cmd *)0, & prm->ldv_60976.tm_iocb2,
                         1);
#line 4381
  if ((unsigned long )sess != (unsigned long )((struct qla_tgt_sess *)0)) {
#line 4382
    (*((ha->tgt.tgt_ops)->put_sess))(sess);
  } else {

  }
#line 4383
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4384
  return;
}
}
#line 4386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_sess_work_fn(struct work_struct *work ) 
{ 
  struct qla_tgt *tgt ;
  struct work_struct  const  *__mptr ;
  struct scsi_qla_host *vha ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct qla_tgt_sess_work_param *prm ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 4388
  __mptr = (struct work_struct  const  *)work;
#line 4388
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffe78UL;
#line 4389
  vha = tgt->vha;
#line 4392
  ql_dbg(8192U, vha, 61440, "Sess work (tgt %p)", tgt);
#line 4394
  tmp = spinlock_check(& tgt->sess_work_lock);
#line 4394
  flags = _raw_spin_lock_irqsave(tmp);
#line 4395
  goto ldv_62249;
  ldv_62248: 
#line 4396
  __mptr___0 = (struct list_head  const  *)tgt->sess_works_list.next;
#line 4396
  prm = (struct qla_tgt_sess_work_param *)__mptr___0;
#line 4404
  list_del(& prm->sess_works_list_entry);
#line 4406
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 4408
  switch (prm->type) {
  case 1: 
#line 4410
  qlt_abort_work(tgt, prm);
#line 4411
  goto ldv_62241;
  case 2: 
#line 4413
  qlt_tmr_work(tgt, prm);
#line 4414
  goto ldv_62241;
  default: 
#line 4416
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                       "i" (4416), "i" (12UL));
  ldv_62244: ;
#line 4416
  goto ldv_62244;
#line 4417
  goto ldv_62241;
  }
  ldv_62241: 
#line 4420
  tmp___0 = spinlock_check(& tgt->sess_work_lock);
#line 4420
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 4422
  kfree((void const   *)prm);
  ldv_62249: 
#line 4395
  tmp___1 = list_empty((struct list_head  const  *)(& tgt->sess_works_list));
#line 4395
  if (tmp___1 == 0) {
#line 4397
    goto ldv_62248;
  } else {

  }
#line 4424
  spin_unlock_irqrestore(& tgt->sess_work_lock, flags);
#line 4425
  return;
}
}
#line 4428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_add_target(struct qla_hw_data *ha , struct scsi_qla_host *base_vha ) 
{ 
  struct qla_tgt *tgt ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_2 ;
  int _min1 ;
  int _min2 ;

  {
#line 4432
  if (ql2x_ini_mode == 2) {
#line 4433
    return (0);
  } else {

  }
#line 4435
  if ((unsigned int )ha->tgt.atio_q_length == 0U) {
#line 4436
    ql_log(1U, base_vha, 57456, "This adapter does not support target mode.\n");
#line 4438
    return (0);
  } else {

  }
#line 4441
  ql_dbg(16384U, base_vha, 57403, "Registering target for host %ld(%p)", base_vha->host_no,
         ha);
#line 4444
  tmp = ldv__builtin_expect((unsigned long )ha->tgt.qla_tgt != (unsigned long )((struct qla_tgt *)0),
                         0L);
#line 4444
  if (tmp != 0L) {
#line 4444
    goto _L;
  } else {
#line 4444
    tmp___0 = ldv__builtin_expect((unsigned long )ha->tgt.tgt_ops != (unsigned long )((struct qla_tgt_func_tmpl *)0),
                               0L);
#line 4444
    if (tmp___0 != 0L) {
      _L: /* CIL Label */ 
#line 4444
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"),
                           "i" (4444), "i" (12UL));
      ldv_62256: ;
#line 4444
      goto ldv_62256;
    } else {

    }
  }
#line 4446
  tmp___1 = kzalloc(856UL, 208U);
#line 4446
  tgt = (struct qla_tgt *)tmp___1;
#line 4447
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 4448
    ql_dbg(16384U, base_vha, 57446, "Unable to allocate struct qla_tgt\n");
#line 4450
    return (-12);
  } else {

  }
#line 4453
  if (((int )((base_vha->host)->hostt)->supported_mode & 2) == 0) {
#line 4454
    ((base_vha->host)->hostt)->supported_mode = (unsigned char )((unsigned int )((base_vha->host)->hostt)->supported_mode | 2U);
  } else {

  }
#line 4456
  tgt->ha = ha;
#line 4457
  tgt->vha = base_vha;
#line 4458
  __init_waitqueue_head(& tgt->waitQ, "&tgt->waitQ", & __key);
#line 4459
  INIT_LIST_HEAD(& tgt->sess_list);
#line 4460
  INIT_LIST_HEAD(& tgt->del_sess_list);
#line 4461
  __init_work(& tgt->sess_del_work.work, 0);
#line 4461
  __constr_expr_0.counter = 137438953408L;
#line 4461
  tgt->sess_del_work.work.data = __constr_expr_0;
#line 4461
  lockdep_init_map(& tgt->sess_del_work.work.lockdep_map, "(&(&tgt->sess_del_work)->work)",
                   & __key___0, 0);
#line 4461
  INIT_LIST_HEAD(& tgt->sess_del_work.work.entry);
#line 4461
  tgt->sess_del_work.work.func = (void (*)(struct work_struct * ))(& qlt_del_sess_work_fn);
#line 4461
  init_timer_key(& tgt->sess_del_work.timer, 2U, "(&(&tgt->sess_del_work)->timer)",
                 & __key___1);
#line 4461
  tgt->sess_del_work.timer.function = & delayed_work_timer_fn;
#line 4461
  tgt->sess_del_work.timer.data = (unsigned long )(& tgt->sess_del_work);
#line 4463
  spinlock_check(& tgt->sess_work_lock);
#line 4463
  __raw_spin_lock_init(& tgt->sess_work_lock.ldv_6105.rlock, "&(&tgt->sess_work_lock)->rlock",
                       & __key___2);
#line 4464
  __init_work(& tgt->sess_work, 0);
#line 4464
  __constr_expr_1.counter = 137438953408L;
#line 4464
  tgt->sess_work.data = __constr_expr_1;
#line 4464
  lockdep_init_map(& tgt->sess_work.lockdep_map, "(&tgt->sess_work)", & __key___3,
                   0);
#line 4464
  INIT_LIST_HEAD(& tgt->sess_work.entry);
#line 4464
  tgt->sess_work.func = & qlt_sess_work_fn;
#line 4465
  INIT_LIST_HEAD(& tgt->sess_works_list);
#line 4466
  spinlock_check(& tgt->srr_lock);
#line 4466
  __raw_spin_lock_init(& tgt->srr_lock.ldv_6105.rlock, "&(&tgt->srr_lock)->rlock",
                       & __key___4);
#line 4467
  INIT_LIST_HEAD(& tgt->srr_ctio_list);
#line 4468
  INIT_LIST_HEAD(& tgt->srr_imm_list);
#line 4469
  __init_work(& tgt->srr_work, 0);
#line 4469
  __constr_expr_2.counter = 137438953408L;
#line 4469
  tgt->srr_work.data = __constr_expr_2;
#line 4469
  lockdep_init_map(& tgt->srr_work.lockdep_map, "(&tgt->srr_work)", & __key___5, 0);
#line 4469
  INIT_LIST_HEAD(& tgt->srr_work.entry);
#line 4469
  tgt->srr_work.func = & qlt_handle_srr_work;
#line 4470
  atomic_set(& tgt->tgt_global_resets_count, 0);
#line 4472
  ha->tgt.qla_tgt = tgt;
#line 4474
  ql_dbg(16384U, base_vha, 57447, "qla_target(%d): using 64 Bit PCI addressing", (int )base_vha->vp_idx);
#line 4477
  tgt->tgt_enable_64bit_addr = 1U;
#line 4479
  _min1 = 1270;
#line 4479
  _min2 = (int )(base_vha->req)->length + -3 > 0 ? (int )(base_vha->req)->length * 5 + -19 : 0;
#line 4479
  tgt->sg_tablesize = _min1 < _min2 ? _min1 : _min2;
#line 4480
  tgt->datasegs_per_cmd = 1;
#line 4481
  tgt->datasegs_per_cont = 5;
#line 4483
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 4484
  list_add_tail(& tgt->tgt_list_entry, & qla_tgt_glist);
#line 4485
  mutex_unlock(& qla_tgt_mutex);
#line 4487
  return (0);
}
}
#line 4491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_remove_target(struct qla_hw_data *ha , struct scsi_qla_host *vha ) 
{ 


  {
#line 4493
  if ((unsigned long )ha->tgt.qla_tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 4494
    return (0);
  } else {

  }
#line 4496
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 4497
  list_del(& (ha->tgt.qla_tgt)->tgt_list_entry);
#line 4498
  mutex_unlock(& qla_tgt_mutex);
#line 4500
  ql_dbg(16384U, vha, 57404, "Unregistering target for host %ld(%p)", vha->host_no,
         ha);
#line 4502
  qlt_release(ha->tgt.qla_tgt);
#line 4504
  return (0);
}
}
#line 4507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static void qlt_lport_dump(struct scsi_qla_host *vha , u64 wwpn , unsigned char *b ) 
{ 
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;

  {
#line 4512
  descriptor.modname = "qla2xxx";
#line 4512
  descriptor.function = "qlt_lport_dump";
#line 4512
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4512
  descriptor.format = "qla2xxx HW vha->node_name: ";
#line 4512
  descriptor.lineno = 4512U;
#line 4512
  descriptor.flags = 0U;
#line 4512
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4512
  if (tmp != 0L) {
#line 4512
    __dynamic_pr_debug(& descriptor, "qla2xxx HW vha->node_name: ");
  } else {

  }
#line 4513
  i = 0;
#line 4513
  goto ldv_62285;
  ldv_62284: 
#line 4514
  descriptor___0.modname = "qla2xxx";
#line 4514
  descriptor___0.function = "qlt_lport_dump";
#line 4514
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4514
  descriptor___0.format = "%02x ";
#line 4514
  descriptor___0.lineno = 4514U;
#line 4514
  descriptor___0.flags = 0U;
#line 4514
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4514
  if (tmp___0 != 0L) {
#line 4514
    __dynamic_pr_debug(& descriptor___0, "%02x ", (int )vha->node_name[i]);
  } else {

  }
#line 4513
  i = i + 1;
  ldv_62285: ;
#line 4513
  if (i <= 7) {
#line 4515
    goto ldv_62284;
  } else {

  }
#line 4515
  descriptor___1.modname = "qla2xxx";
#line 4515
  descriptor___1.function = "qlt_lport_dump";
#line 4515
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4515
  descriptor___1.format = "\n";
#line 4515
  descriptor___1.lineno = 4515U;
#line 4515
  descriptor___1.flags = 0U;
#line 4515
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 4515
  if (tmp___1 != 0L) {
#line 4515
    __dynamic_pr_debug(& descriptor___1, "\n");
  } else {

  }
#line 4516
  descriptor___2.modname = "qla2xxx";
#line 4516
  descriptor___2.function = "qlt_lport_dump";
#line 4516
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4516
  descriptor___2.format = "qla2xxx HW vha->port_name: ";
#line 4516
  descriptor___2.lineno = 4516U;
#line 4516
  descriptor___2.flags = 0U;
#line 4516
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 4516
  if (tmp___2 != 0L) {
#line 4516
    __dynamic_pr_debug(& descriptor___2, "qla2xxx HW vha->port_name: ");
  } else {

  }
#line 4517
  i = 0;
#line 4517
  goto ldv_62291;
  ldv_62290: 
#line 4518
  descriptor___3.modname = "qla2xxx";
#line 4518
  descriptor___3.function = "qlt_lport_dump";
#line 4518
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4518
  descriptor___3.format = "%02x ";
#line 4518
  descriptor___3.lineno = 4518U;
#line 4518
  descriptor___3.flags = 0U;
#line 4518
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 4518
  if (tmp___3 != 0L) {
#line 4518
    __dynamic_pr_debug(& descriptor___3, "%02x ", (int )vha->port_name[i]);
  } else {

  }
#line 4517
  i = i + 1;
  ldv_62291: ;
#line 4517
  if (i <= 7) {
#line 4519
    goto ldv_62290;
  } else {

  }
#line 4519
  descriptor___4.modname = "qla2xxx";
#line 4519
  descriptor___4.function = "qlt_lport_dump";
#line 4519
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4519
  descriptor___4.format = "\n";
#line 4519
  descriptor___4.lineno = 4519U;
#line 4519
  descriptor___4.flags = 0U;
#line 4519
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 4519
  if (tmp___4 != 0L) {
#line 4519
    __dynamic_pr_debug(& descriptor___4, "\n");
  } else {

  }
#line 4521
  descriptor___5.modname = "qla2xxx";
#line 4521
  descriptor___5.function = "qlt_lport_dump";
#line 4521
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4521
  descriptor___5.format = "qla2xxx passed configfs WWPN: ";
#line 4521
  descriptor___5.lineno = 4521U;
#line 4521
  descriptor___5.flags = 0U;
#line 4521
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 4521
  if (tmp___5 != 0L) {
#line 4521
    __dynamic_pr_debug(& descriptor___5, "qla2xxx passed configfs WWPN: ");
  } else {

  }
#line 4522
  put_unaligned_be64(wwpn, (void *)b);
#line 4523
  i = 0;
#line 4523
  goto ldv_62297;
  ldv_62296: 
#line 4524
  descriptor___6.modname = "qla2xxx";
#line 4524
  descriptor___6.function = "qlt_lport_dump";
#line 4524
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4524
  descriptor___6.format = "%02x ";
#line 4524
  descriptor___6.lineno = 4524U;
#line 4524
  descriptor___6.flags = 0U;
#line 4524
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 4524
  if (tmp___6 != 0L) {
#line 4524
    __dynamic_pr_debug(& descriptor___6, "%02x ", (int )*(b + (unsigned long )i));
  } else {

  }
#line 4523
  i = i + 1;
  ldv_62297: ;
#line 4523
  if (i <= 7) {
#line 4525
    goto ldv_62296;
  } else {

  }
#line 4525
  descriptor___7.modname = "qla2xxx";
#line 4525
  descriptor___7.function = "qlt_lport_dump";
#line 4525
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4525
  descriptor___7.format = "\n";
#line 4525
  descriptor___7.lineno = 4525U;
#line 4525
  descriptor___7.flags = 0U;
#line 4525
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 4525
  if (tmp___7 != 0L) {
#line 4525
    __dynamic_pr_debug(& descriptor___7, "\n");
  } else {

  }
#line 4527
  return;
}
}
#line 4536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_lport_register(struct qla_tgt_func_tmpl *qla_tgt_ops , u64 wwpn , int (*callback)(struct scsi_qla_host * ) ,
                       void *target_lport_ptr ) 
{ 
  struct qla_tgt *tgt ;
  struct scsi_qla_host *vha ;
  struct qla_hw_data *ha ;
  struct Scsi_Host *host ;
  unsigned long flags ;
  int rc ;
  u8 b[8U] ;
  struct list_head  const  *__mptr ;
  raw_spinlock_t *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct Scsi_Host *tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4547
  mutex_lock_nested(& qla_tgt_mutex, 0U);
#line 4548
  __mptr = (struct list_head  const  *)qla_tgt_glist.next;
#line 4548
  tgt = (struct qla_tgt *)__mptr + 0xfffffffffffffcb8UL;
#line 4548
  goto ldv_62325;
  ldv_62324: 
#line 4549
  vha = tgt->vha;
#line 4550
  ha = vha->hw;
#line 4552
  host = vha->host;
#line 4553
  if ((unsigned long )host == (unsigned long )((struct Scsi_Host *)0)) {
#line 4554
    goto ldv_62318;
  } else {

  }
#line 4556
  if ((unsigned long )ha->tgt.tgt_ops != (unsigned long )((struct qla_tgt_func_tmpl *)0)) {
#line 4557
    goto ldv_62318;
  } else {

  }
#line 4559
  if (((int )(host->hostt)->supported_mode & 2) == 0) {
#line 4560
    goto ldv_62318;
  } else {

  }
#line 4562
  tmp = spinlock_check(& ha->hardware_lock);
#line 4562
  flags = _raw_spin_lock_irqsave(tmp);
#line 4563
  if (((int )host->active_mode & 2) != 0) {
#line 4564
    descriptor.modname = "qla2xxx";
#line 4564
    descriptor.function = "qlt_lport_register";
#line 4564
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared";
#line 4564
    descriptor.format = "MODE_TARGET already active on qla2xxx(%d)\n";
#line 4564
    descriptor.lineno = 4565U;
#line 4564
    descriptor.flags = 0U;
#line 4564
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4564
    if (tmp___0 != 0L) {
#line 4564
      __dynamic_pr_debug(& descriptor, "MODE_TARGET already active on qla2xxx(%d)\n",
                         host->host_no);
    } else {

    }
#line 4566
    spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4567
    goto ldv_62318;
  } else {

  }
#line 4569
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4571
  tmp___1 = scsi_host_get(host);
#line 4571
  if ((unsigned long )tmp___1 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4572
    ql_dbg(16384U, vha, 57448, "Unable to scsi_host_get() for qla2xxx scsi_host\n");
#line 4575
    goto ldv_62318;
  } else {

  }
#line 4577
  qlt_lport_dump(vha, wwpn, (unsigned char *)(& b));
#line 4579
  tmp___2 = memcmp((void const   *)(& vha->port_name), (void const   *)(& b), 8UL);
#line 4579
  if (tmp___2 != 0) {
#line 4580
    scsi_host_put(host);
#line 4581
    goto ldv_62318;
  } else {

  }
#line 4586
  ha->tgt.tgt_ops = qla_tgt_ops;
#line 4587
  ha->tgt.target_lport_ptr = target_lport_ptr;
#line 4588
  rc = (*callback)(vha);
#line 4589
  if (rc != 0) {
#line 4590
    ha->tgt.tgt_ops = (struct qla_tgt_func_tmpl *)0;
#line 4591
    ha->tgt.target_lport_ptr = (void *)0;
  } else {

  }
#line 4593
  mutex_unlock(& qla_tgt_mutex);
#line 4594
  return (rc);
  ldv_62318: 
#line 4548
  __mptr___0 = (struct list_head  const  *)tgt->tgt_list_entry.next;
#line 4548
  tgt = (struct qla_tgt *)__mptr___0 + 0xfffffffffffffcb8UL;
  ldv_62325: ;
#line 4548
  if ((unsigned long )(& tgt->tgt_list_entry) != (unsigned long )(& qla_tgt_glist)) {
#line 4550
    goto ldv_62324;
  } else {

  }
#line 4596
  mutex_unlock(& qla_tgt_mutex);
#line 4598
  return (-19);
}
}
#line 4607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_lport_deregister(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct Scsi_Host *sh ;

  {
#line 4609
  ha = vha->hw;
#line 4610
  sh = vha->host;
#line 4614
  ha->tgt.target_lport_ptr = (void *)0;
#line 4615
  ha->tgt.tgt_ops = (struct qla_tgt_func_tmpl *)0;
#line 4619
  scsi_host_put(sh);
#line 4620
  return;
}
}
#line 4624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_set_mode(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4626
  ha = vha->hw;
#line 4628
  switch (ql2x_ini_mode) {
  case 1: ;
  case 0: 
#line 4631
  (vha->host)->active_mode = 2U;
#line 4632
  goto ldv_62353;
  case 2: 
#line 4634
  (vha->host)->active_mode = (unsigned char )((unsigned int )(vha->host)->active_mode | 2U);
#line 4635
  goto ldv_62353;
  default: ;
#line 4637
  goto ldv_62353;
  }
  ldv_62353: ;
#line 4640
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 4641
    qla_reverse_ini_mode(vha);
  } else {

  }
#line 4642
  return;
}
}
#line 4645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_clear_mode(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;

  {
#line 4647
  ha = vha->hw;
#line 4649
  switch (ql2x_ini_mode) {
  case 1: 
#line 4651
  (vha->host)->active_mode = 0U;
#line 4652
  goto ldv_62361;
  case 0: 
#line 4654
  (vha->host)->active_mode = 1U;
#line 4655
  goto ldv_62361;
  case 2: 
#line 4657
  (vha->host)->active_mode = (unsigned int )(vha->host)->active_mode & 1U;
#line 4658
  goto ldv_62361;
  default: ;
#line 4660
  goto ldv_62361;
  }
  ldv_62361: ;
#line 4663
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 4664
    qla_reverse_ini_mode(vha);
  } else {

  }
#line 4665
  return;
}
}
#line 4673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_enable_vha(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 4675
  ha = vha->hw;
#line 4676
  tgt = ha->tgt.qla_tgt;
#line 4679
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 4680
    ql_dbg(16384U, vha, 57449, "Unable to locate qla_tgt pointer from struct qla_hw_data\n");
#line 4683
    dump_stack();
#line 4684
    return;
  } else {

  }
#line 4687
  tmp = spinlock_check(& ha->hardware_lock);
#line 4687
  flags = _raw_spin_lock_irqsave(tmp);
#line 4688
  tgt->tgt_stopped = 0;
#line 4689
  qlt_set_mode(vha);
#line 4690
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4692
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4693
  qla2xxx_wake_dpc(vha);
#line 4694
  qla2x00_wait_for_hba_online(vha);
#line 4695
  return;
}
}
#line 4704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_disable_vha(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_tgt *tgt ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 4706
  ha = vha->hw;
#line 4707
  tgt = ha->tgt.qla_tgt;
#line 4710
  if ((unsigned long )tgt == (unsigned long )((struct qla_tgt *)0)) {
#line 4711
    ql_dbg(16384U, vha, 57450, "Unable to locate qla_tgt pointer from struct qla_hw_data\n");
#line 4714
    dump_stack();
#line 4715
    return;
  } else {

  }
#line 4718
  tmp = spinlock_check(& ha->hardware_lock);
#line 4718
  flags = _raw_spin_lock_irqsave(tmp);
#line 4719
  qlt_clear_mode(vha);
#line 4720
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 4722
  set_bit(2L, (unsigned long volatile   *)(& vha->dpc_flags));
#line 4723
  qla2xxx_wake_dpc(vha);
#line 4724
  qla2x00_wait_for_hba_online(vha);
#line 4725
  return;
}
}
#line 4733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_vport_create(struct scsi_qla_host *vha , struct qla_hw_data *ha ) 
{ 
  bool tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 4735
  tmp = qla_tgt_mode_enabled(vha);
#line 4735
  if (tmp) {
#line 4735
    tmp___0 = 0;
  } else {
#line 4735
    tmp___0 = 1;
  }
#line 4735
  if (tmp___0) {
#line 4736
    return;
  } else {

  }
#line 4738
  __mutex_init(& ha->tgt.tgt_mutex, "&ha->tgt.tgt_mutex", & __key);
#line 4739
  __mutex_init(& ha->tgt.tgt_host_action_mutex, "&ha->tgt.tgt_host_action_mutex",
               & __key___0);
#line 4741
  qlt_clear_mode(vha);
#line 4749
  ha->tgt.atio_q_length = 4096U;
#line 4750
  return;
}
}
#line 4753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_rff_id(struct scsi_qla_host *vha , struct ct_sns_req *ct_req ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 4758
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 4758
  if ((int )tmp___1) {
#line 4759
    tmp = qla_ini_mode_enabled(vha);
#line 4759
    if ((int )tmp) {
#line 4760
      ct_req->req.rff_id.fc4_feature = 3U;
    } else {
#line 4762
      ct_req->req.rff_id.fc4_feature = 1U;
    }
  } else {
#line 4763
    tmp___0 = qla_ini_mode_enabled(vha);
#line 4763
    if ((int )tmp___0) {
#line 4764
      ct_req->req.rff_id.fc4_feature = 2U;
    } else {

    }
  }
#line 4765
  return;
}
}
#line 4778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_init_atio_q_entries(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  uint16_t cnt ;
  struct atio_from_isp *pkt ;
  bool tmp ;
  int tmp___0 ;

  {
#line 4780
  ha = vha->hw;
#line 4782
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring;
#line 4784
  tmp = qla_tgt_mode_enabled(vha);
#line 4784
  if (tmp) {
#line 4784
    tmp___0 = 0;
  } else {
#line 4784
    tmp___0 = 1;
  }
#line 4784
  if (tmp___0) {
#line 4785
    return;
  } else {

  }
#line 4787
  cnt = 0U;
#line 4787
  goto ldv_62406;
  ldv_62405: 
#line 4788
  pkt->u.raw.signature = 3735936685U;
#line 4789
  pkt = pkt + 1;
#line 4787
  cnt = (uint16_t )((int )cnt + 1);
  ldv_62406: ;
#line 4787
  if ((int )ha->tgt.atio_q_length > (int )cnt) {
#line 4789
    goto ldv_62405;
  } else {

  }

#line 4794
  return;
}
}
#line 4799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_24xx_process_atio_queue(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct atio_from_isp *pkt ;
  int cnt ;
  int i ;

  {
#line 4801
  ha = vha->hw;
#line 4805
  if (*((unsigned long *)vha + 19UL) == 0UL) {
#line 4806
    return;
  } else {

  }
#line 4808
  goto ldv_62419;
  ldv_62418: 
#line 4809
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
#line 4810
  cnt = (int )pkt->u.raw.entry_count;
#line 4812
  qlt_24xx_atio_pkt_all_vps(vha, pkt);
#line 4814
  i = 0;
#line 4814
  goto ldv_62416;
  ldv_62415: 
#line 4815
  ha->tgt.atio_ring_index = (uint16_t )((int )ha->tgt.atio_ring_index + 1);
#line 4816
  if ((int )ha->tgt.atio_ring_index == (int )ha->tgt.atio_q_length) {
#line 4817
    ha->tgt.atio_ring_index = 0U;
#line 4818
    ha->tgt.atio_ring_ptr = ha->tgt.atio_ring;
  } else {
#line 4820
    ha->tgt.atio_ring_ptr = ha->tgt.atio_ring_ptr + 1;
  }
#line 4822
  pkt->u.raw.signature = 3735936685U;
#line 4823
  pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
#line 4814
  i = i + 1;
  ldv_62416: ;
#line 4814
  if (i < cnt) {
#line 4816
    goto ldv_62415;
  } else {

  }
#line 4825
  __asm__  volatile   ("sfence": : : "memory");
  ldv_62419: ;
#line 4808
  if ((ha->tgt.atio_ring_ptr)->signature != 3735936685U) {
#line 4810
    goto ldv_62418;
  } else {

  }
#line 4829
  writel((unsigned int )ha->tgt.atio_ring_index, (void volatile   *)(vha->hw)->tgt.atio_q_out);
#line 4830
  return;
}
}
#line 4833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_24xx_config_rings(struct scsi_qla_host *vha ) 
{ 
  struct qla_hw_data *ha ;
  struct qla_msix_entry *msix ;
  struct init_cb_24xx *icb ;

  {
#line 4835
  ha = vha->hw;
#line 4836
  if (ql2x_ini_mode == 2) {
#line 4837
    return;
  } else {

  }
#line 4839
  writel(0U, (void volatile   *)(vha->hw)->tgt.atio_q_in);
#line 4840
  writel(0U, (void volatile   *)(vha->hw)->tgt.atio_q_out);
#line 4841
  readl((void const volatile   *)(vha->hw)->tgt.atio_q_out);
#line 4843
  if ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U) {
#line 4844
    msix = ha->msix_entries + 2UL;
#line 4845
    icb = (struct init_cb_24xx *)ha->init_cb;
#line 4847
    icb->msix_atio = msix->entry;
#line 4848
    ql_dbg(1073741824U, vha, 61554, "Registering ICB vector 0x%x for atio que.\n",
           (int )msix->entry);
  } else {

  }
#line 4852
  return;
}
}
#line 4855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_24xx *nv ) 
{ 
  struct qla_hw_data *ha ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 4857
  ha = vha->hw;
#line 4859
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 4859
  if ((int )tmp___1) {
#line 4860
    if (ha->tgt.saved_set == 0) {
#line 4862
      ha->tgt.saved_exchange_count = nv->exchange_count;
#line 4863
      ha->tgt.saved_firmware_options_1 = nv->firmware_options_1;
#line 4865
      ha->tgt.saved_firmware_options_2 = nv->firmware_options_2;
#line 4867
      ha->tgt.saved_firmware_options_3 = nv->firmware_options_3;
#line 4869
      ha->tgt.saved_set = 1;
    } else {

    }
#line 4872
    nv->exchange_count = 65535U;
#line 4875
    nv->firmware_options_1 = nv->firmware_options_1 | 16U;
#line 4878
    tmp = qla_ini_mode_enabled(vha);
#line 4878
    if (tmp) {
#line 4878
      tmp___0 = 0;
    } else {
#line 4878
      tmp___0 = 1;
    }
#line 4878
    if (tmp___0) {
#line 4879
      nv->firmware_options_1 = nv->firmware_options_1 | 32U;
    } else {

    }
#line 4882
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 4884
    nv->firmware_options_1 = nv->firmware_options_1 & 4294966783U;
#line 4886
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 4888
    nv->host_p = nv->host_p & 4294966271U;
#line 4890
    nv->firmware_options_2 = nv->firmware_options_2 | 16384U;
  } else {
#line 4892
    if (ha->tgt.saved_set != 0) {
#line 4893
      nv->exchange_count = ha->tgt.saved_exchange_count;
#line 4894
      nv->firmware_options_1 = ha->tgt.saved_firmware_options_1;
#line 4896
      nv->firmware_options_2 = ha->tgt.saved_firmware_options_2;
#line 4898
      nv->firmware_options_3 = ha->tgt.saved_firmware_options_3;
    } else {

    }
#line 4901
    return;
  }
#line 4905
  nv->firmware_options_3 = nv->firmware_options_3 | 576U;
#line 4907
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 4908
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4909
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 12U;
    } else {

    }
#line 4912
    nv->firmware_options_2 = nv->firmware_options_2 | 256U;
  } else {
#line 4914
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4915
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 8U;
    } else {

    }
#line 4917
    nv->firmware_options_2 = nv->firmware_options_2 & 4294967039U;
  }
#line 4919
  return;
}
}
#line 4922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_24xx *icb ) 
{ 
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 4925
  ha = vha->hw;
#line 4927
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 4928
    __len = 8UL;
#line 4928
    if (__len > 63UL) {
#line 4928
      __ret = __memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
                       __len);
    } else {
#line 4928
      __ret = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
                               __len);
    }
#line 4929
    icb->firmware_options_1 = icb->firmware_options_1 | 16384U;
  } else {

  }
#line 4931
  return;
}
}
#line 4934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha , struct nvram_81xx *nv ) 
{ 
  struct qla_hw_data *ha ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 4936
  ha = vha->hw;
#line 4938
  if (ql2x_ini_mode == 2) {
#line 4939
    return;
  } else {

  }
#line 4941
  tmp___1 = qla_tgt_mode_enabled(vha);
#line 4941
  if ((int )tmp___1) {
#line 4942
    if (ha->tgt.saved_set == 0) {
#line 4944
      ha->tgt.saved_exchange_count = nv->exchange_count;
#line 4945
      ha->tgt.saved_firmware_options_1 = nv->firmware_options_1;
#line 4947
      ha->tgt.saved_firmware_options_2 = nv->firmware_options_2;
#line 4949
      ha->tgt.saved_firmware_options_3 = nv->firmware_options_3;
#line 4951
      ha->tgt.saved_set = 1;
    } else {

    }
#line 4954
    nv->exchange_count = 65535U;
#line 4957
    nv->firmware_options_1 = nv->firmware_options_1 | 16U;
#line 4960
    tmp = qla_ini_mode_enabled(vha);
#line 4960
    if (tmp) {
#line 4960
      tmp___0 = 0;
    } else {
#line 4960
      tmp___0 = 1;
    }
#line 4960
    if (tmp___0) {
#line 4961
      nv->firmware_options_1 = nv->firmware_options_1 | 32U;
    } else {

    }
#line 4965
    nv->firmware_options_1 = nv->firmware_options_1 & 4294959103U;
#line 4967
    nv->firmware_options_1 = nv->firmware_options_1 & 4294966783U;
#line 4969
    nv->firmware_options_2 = nv->firmware_options_2 | 4096U;
#line 4971
    nv->host_p = nv->host_p & 4294966271U;
#line 4973
    nv->firmware_options_2 = nv->firmware_options_2 | 16384U;
  } else {
#line 4975
    if (ha->tgt.saved_set != 0) {
#line 4976
      nv->exchange_count = ha->tgt.saved_exchange_count;
#line 4977
      nv->firmware_options_1 = ha->tgt.saved_firmware_options_1;
#line 4979
      nv->firmware_options_2 = ha->tgt.saved_firmware_options_2;
#line 4981
      nv->firmware_options_3 = ha->tgt.saved_firmware_options_3;
    } else {

    }
#line 4984
    return;
  }
#line 4988
  nv->firmware_options_3 = nv->firmware_options_3 | 576U;
#line 4990
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 4991
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4992
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 12U;
    } else {

    }
#line 4995
    nv->firmware_options_2 = nv->firmware_options_2 | 256U;
  } else {
#line 4997
    if (*((unsigned long *)vha + 19UL) != 0UL) {
#line 4998
      ((struct fc_host_attrs *)(vha->host)->shost_data)->supported_classes = 8U;
    } else {

    }
#line 5000
    nv->firmware_options_2 = nv->firmware_options_2 & 4294967039U;
  }
#line 5002
  return;
}
}
#line 5005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha , struct init_cb_81xx *icb ) 
{ 
  struct qla_hw_data *ha ;
  size_t __len ;
  void *__ret ;

  {
#line 5008
  ha = vha->hw;
#line 5010
  if (ql2x_ini_mode == 2) {
#line 5011
    return;
  } else {

  }
#line 5013
  if ((unsigned int )*((unsigned char *)ha + 3808UL) != 0U) {
#line 5014
    __len = 8UL;
#line 5014
    if (__len > 63UL) {
#line 5014
      __ret = __memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
                       __len);
    } else {
#line 5014
      __ret = __builtin_memcpy((void *)(& icb->node_name), (void const   *)(& ha->tgt.tgt_node_name),
                               __len);
    }
#line 5015
    icb->firmware_options_1 = icb->firmware_options_1 | 16384U;
  } else {

  }
#line 5017
  return;
}
}
#line 5020 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_83xx_iospace_config(struct qla_hw_data *ha ) 
{ 


  {
#line 5022
  if (ql2x_ini_mode == 2) {
#line 5023
    return;
  } else {

  }
#line 5025
  ha->msix_count = (unsigned int )ha->msix_count + 1U;
#line 5026
  return;
}
}
#line 5029 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_24xx_process_response_error(struct scsi_qla_host *vha , struct sts_entry_24xx *pkt ) 
{ 


  {
#line 5032
  switch ((int )pkt->entry_type) {
  case 84: ;
  case 85: ;
  case 18: ;
  case 14: ;
#line 5037
  return (1);
  default: ;
#line 5039
  return (0);
  }
}
}
#line 5044 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_modify_vp_config(struct scsi_qla_host *vha , struct vp_config_entry_24xx *vpmod ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 5047
  tmp = qla_tgt_mode_enabled(vha);
#line 5047
  if ((int )tmp) {
#line 5048
    vpmod->options_idx1 = (unsigned int )vpmod->options_idx1 & 223U;
  } else {

  }
#line 5050
  tmp___0 = qla_ini_mode_enabled(vha);
#line 5050
  if (tmp___0) {
#line 5050
    tmp___1 = 0;
  } else {
#line 5050
    tmp___1 = 1;
  }
#line 5050
  if (tmp___1) {
#line 5051
    vpmod->options_idx1 = (unsigned int )vpmod->options_idx1 & 239U;
  } else {

  }
#line 5052
  return;
}
}
#line 5055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_probe_one_stage1(struct scsi_qla_host *base_vha , struct qla_hw_data *ha ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 5057
  if (ql2x_ini_mode == 2) {
#line 5058
    return;
  } else {

  }
#line 5060
  if ((unsigned int )ha->mqenable != 0U || ((ha->device_type & 32768U) != 0U || (ha->device_type & 65536U) != 0U)) {
#line 5061
    (base_vha->hw)->tgt.atio_q_in = & (ha->mqiobase)->isp25mq.atio_q_in;
#line 5062
    (base_vha->hw)->tgt.atio_q_out = & (ha->mqiobase)->isp25mq.atio_q_out;
  } else {
#line 5064
    (base_vha->hw)->tgt.atio_q_in = & (ha->iobase)->isp24.atio_q_in;
#line 5065
    (base_vha->hw)->tgt.atio_q_out = & (ha->iobase)->isp24.atio_q_out;
  }
#line 5068
  __mutex_init(& ha->tgt.tgt_mutex, "&ha->tgt.tgt_mutex", & __key);
#line 5069
  __mutex_init(& ha->tgt.tgt_host_action_mutex, "&ha->tgt.tgt_host_action_mutex",
               & __key___0);
#line 5070
  qlt_clear_mode(base_vha);
#line 5071
  return;
}
}
#line 5074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
irqreturn_t qla83xx_msix_atio_q(int irq , void *dev_id ) 
{ 
  struct rsp_que *rsp ;
  scsi_qla_host_t *vha ;
  struct qla_hw_data *ha ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 5081
  rsp = (struct rsp_que *)dev_id;
#line 5082
  ha = rsp->hw;
#line 5083
  tmp = pci_get_drvdata(ha->pdev);
#line 5083
  vha = (scsi_qla_host_t *)tmp;
#line 5085
  tmp___0 = spinlock_check(& ha->hardware_lock);
#line 5085
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 5087
  qlt_24xx_process_atio_queue(vha);
#line 5088
  qla24xx_process_response_queue(vha, rsp);
#line 5090
  spin_unlock_irqrestore(& ha->hardware_lock, flags);
#line 5092
  return (1);
}
}
#line 5096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_mem_alloc(struct qla_hw_data *ha ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 5098
  if (ql2x_ini_mode == 2) {
#line 5099
    return (0);
  } else {

  }
#line 5101
  tmp = kzalloc(4096UL, 208U);
#line 5101
  ha->tgt.tgt_vp_map = (struct qla_tgt_vp_map *)tmp;
#line 5103
  if ((unsigned long )ha->tgt.tgt_vp_map == (unsigned long )((struct qla_tgt_vp_map *)0)) {
#line 5104
    return (-12);
  } else {

  }
#line 5106
  tmp___0 = dma_alloc_attrs(& (ha->pdev)->dev, (unsigned long )((int )ha->tgt.atio_q_length + 1) * 64UL,
                            & ha->tgt.atio_dma, 208U, (struct dma_attrs *)0);
#line 5106
  ha->tgt.atio_ring = (struct atio *)tmp___0;
#line 5109
  if ((unsigned long )ha->tgt.atio_ring == (unsigned long )((struct atio *)0)) {
#line 5110
    kfree((void const   *)ha->tgt.tgt_vp_map);
#line 5111
    return (-12);
  } else {

  }
#line 5113
  return (0);
}
}
#line 5117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_mem_free(struct qla_hw_data *ha ) 
{ 


  {
#line 5119
  if (ql2x_ini_mode == 2) {
#line 5120
    return;
  } else {

  }
#line 5122
  if ((unsigned long )ha->tgt.atio_ring != (unsigned long )((struct atio *)0)) {
#line 5123
    dma_free_attrs(& (ha->pdev)->dev, (unsigned long )((int )ha->tgt.atio_q_length + 1) * 64UL,
                   (void *)ha->tgt.atio_ring, ha->tgt.atio_dma, (struct dma_attrs *)0);
  } else {

  }
#line 5127
  kfree((void const   *)ha->tgt.tgt_vp_map);
#line 5128
  return;
}
}
#line 5132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_update_vp_map(struct scsi_qla_host *vha , int cmd ) 
{ 


  {
#line 5134
  if (ql2x_ini_mode == 2) {
#line 5135
    return;
  } else {

  }
#line 5137
  switch (cmd) {
  case 1: 
#line 5139
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->vp_idx)->vha = vha;
#line 5140
  goto ldv_62497;
  case 2: 
#line 5142
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->d_id.b.al_pa)->idx = (uint8_t )vha->vp_idx;
#line 5143
  goto ldv_62497;
  case 3: 
#line 5145
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->vp_idx)->vha = (scsi_qla_host_t *)0;
#line 5146
  goto ldv_62497;
  case 4: 
#line 5148
  ((vha->hw)->tgt.tgt_vp_map + (unsigned long )vha->d_id.b.al_pa)->idx = 0U;
#line 5149
  goto ldv_62497;
  }
  ldv_62497: ;
#line 5152
  return;
}
}
#line 5153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
static int qlt_parse_ini_mode(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5155
  tmp___1 = strcasecmp((char const   *)qlini_mode, "exclusive");
#line 5155
  if (tmp___1 == 0) {
#line 5156
    ql2x_ini_mode = 0;
  } else {
#line 5157
    tmp___0 = strcasecmp((char const   *)qlini_mode, "disabled");
#line 5157
    if (tmp___0 == 0) {
#line 5158
      ql2x_ini_mode = 1;
    } else {
#line 5159
      tmp = strcasecmp((char const   *)qlini_mode, "enabled");
#line 5159
      if (tmp == 0) {
#line 5160
        ql2x_ini_mode = 2;
      } else {
#line 5162
        return (0);
      }
    }
  }
#line 5164
  return (1);
}
}
#line 5167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int qlt_init(void) 
{ 
  int ret ;
  int tmp ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___0 ;

  {
#line 5171
  tmp = qlt_parse_ini_mode();
#line 5171
  if (tmp == 0) {
#line 5172
    ql_log(0U, (scsi_qla_host_t *)0, 57451, "qlt_parse_ini_mode() failed\n");
#line 5174
    return (-22);
  } else {

  }
#line 5177
  if (ql2x_ini_mode == 2) {
#line 5178
    return (0);
  } else {

  }
#line 5180
  qla_tgt_cmd_cachep = kmem_cache_create("qla_tgt_cmd_cachep", 1400UL, 8UL, 0UL, (void (*)(void * ))0);
#line 5183
  if ((unsigned long )qla_tgt_cmd_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 5184
    ql_log(0U, (scsi_qla_host_t *)0, 57452, "kmem_cache_create for qla_tgt_cmd_cachep failed\n");
#line 5186
    return (-12);
  } else {

  }
#line 5189
  qla_tgt_mgmt_cmd_cachep = kmem_cache_create("qla_tgt_mgmt_cmd_cachep", 1152UL, 8UL,
                                              0UL, (void (*)(void * ))0);
#line 5192
  if ((unsigned long )qla_tgt_mgmt_cmd_cachep == (unsigned long )((struct kmem_cache *)0)) {
#line 5193
    ql_log(0U, (scsi_qla_host_t *)0, 57453, "kmem_cache_create for qla_tgt_mgmt_cmd_cachep failed\n");
#line 5195
    ret = -12;
#line 5196
    goto out;
  } else {

  }
#line 5199
  qla_tgt_mgmt_cmd_mempool = mempool_create(25, & mempool_alloc_slab, & mempool_free_slab,
                                            (void *)qla_tgt_mgmt_cmd_cachep);
#line 5201
  if ((unsigned long )qla_tgt_mgmt_cmd_mempool == (unsigned long )((mempool_t *)0)) {
#line 5202
    ql_log(0U, (scsi_qla_host_t *)0, 57454, "mempool_create for qla_tgt_mgmt_cmd_mempool failed\n");
#line 5204
    ret = -12;
#line 5205
    goto out_mgmt_cmd_cachep;
  } else {

  }
#line 5208
  __lock_name = "qla_tgt_wq";
#line 5208
  tmp___0 = __alloc_workqueue_key("qla_tgt_wq", 0U, 0, & __key, __lock_name);
#line 5208
  qla_tgt_wq = tmp___0;
#line 5209
  if ((unsigned long )qla_tgt_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 5210
    ql_log(0U, (scsi_qla_host_t *)0, 57455, "alloc_workqueue for qla_tgt_wq failed\n");
#line 5212
    ret = -12;
#line 5213
    goto out_cmd_mempool;
  } else {

  }
#line 5218
  return (ql2x_ini_mode == 1);
  out_cmd_mempool: 
#line 5221
  mempool_destroy(qla_tgt_mgmt_cmd_mempool);
  out_mgmt_cmd_cachep: 
#line 5223
  kmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);
  out: 
#line 5225
  kmem_cache_destroy(qla_tgt_cmd_cachep);
#line 5226
  return (ret);
}
}
#line 5229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void qlt_exit(void) 
{ 


  {
#line 5231
  if (ql2x_ini_mode == 2) {
#line 5232
    return;
  } else {

  }
#line 5234
  destroy_workqueue(qla_tgt_wq);
#line 5235
  mempool_destroy(qla_tgt_mgmt_cmd_mempool);
#line 5236
  kmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);
#line 5237
  kmem_cache_destroy(qla_tgt_cmd_cachep);
#line 5238
  return;
}
}
#line 5241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void disable_suitable_timer_17(struct timer_list *timer ) 
{ 


  {
#line 5242
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_17) {
#line 5243
    ldv_timer_state_17 = 0;
#line 5244
    return;
  } else {

  }
#line 5246
  return;
}
}
#line 5249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void choose_timer_17(struct timer_list *timer ) 
{ 


  {
#line 5250
  LDV_IN_INTERRUPT = 2;
#line 5251
  (*(timer->function))(timer->data);
#line 5252
  LDV_IN_INTERRUPT = 1;
#line 5253
  ldv_timer_state_17 = 2;
#line 5254
  return;
}
}
#line 5257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int reg_timer_17(struct timer_list *timer ) 
{ 


  {
#line 5258
  ldv_timer_list_17 = timer;
#line 5259
  ldv_timer_state_17 = 1;
#line 5260
  return (0);
}
}
#line 5263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 5263
  if ((unsigned long )ldv_timer_list_17 == (unsigned long )timer) {
#line 5264
    if (ldv_timer_state_17 == 2 || pending_flag != 0) {
#line 5265
      ldv_timer_list_17 = timer;
#line 5266
      ldv_timer_list_17->data = data;
#line 5267
      ldv_timer_state_17 = 1;
    } else {

    }
#line 5269
    return;
  } else {

  }
#line 5271
  reg_timer_17(timer);
#line 5272
  ldv_timer_list_17->data = data;
#line 5273
  return;
}
}
#line 5275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int ldv_del_timer_81(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 5279
  tmp = del_timer(ldv_func_arg1);
#line 5279
  ldv_func_res = tmp;
#line 5281
  disable_suitable_timer_7(ldv_func_arg1);
#line 5283
  return (ldv_func_res);
}
}
#line 5286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/dscv/ri/118_1a/drivers/scsi/qla2xxx/qla_target.o.c.prepared"
int ldv_scsi_add_host_with_dma_82(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 5290
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 5290
  ldv_func_res = tmp;
#line 5292
  if (ldv_func_res == 0) {
#line 5293
    ldv_state_variable_72 = 1;
#line 5293
    ldv_initialize_scsi_host_template_72();
  } else {

  }
#line 5297
  return (ldv_func_res);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void);
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
#line 9 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
int ldv_rlock  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
int ldv_wlock  =    1;
#line 14 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_lock_irqsave(rwlock_t *lock ) 
{ 


  {
#line 16
  if (ldv_wlock == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 18
  ldv_rlock = ldv_rlock + 1;
#line 19
  return;
}
}
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_unlock_irqrestore(rwlock_t *lock ) 
{ 


  {
#line 24
  if (ldv_rlock > 1) {

  } else {
#line 24
    ldv_error();
  }
#line 26
  ldv_rlock = ldv_rlock - 1;
#line 27
  return;
}
}
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_lock_irqsave(rwlock_t *lock ) 
{ 


  {
#line 32
  if (ldv_wlock == 1) {

  } else {
#line 32
    ldv_error();
  }
#line 34
  ldv_wlock = 2;
#line 35
  return;
}
}
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_unlock_irqrestore(rwlock_t *lock ) 
{ 


  {
#line 40
  if (ldv_wlock != 1) {

  } else {
#line 40
    ldv_error();
  }
#line 42
  ldv_wlock = 1;
#line 43
  return;
}
}
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_lock(rwlock_t *lock ) 
{ 


  {
#line 48
  if (ldv_wlock == 1) {

  } else {
#line 48
    ldv_error();
  }
#line 50
  ldv_rlock = ldv_rlock + 1;
#line 51
  return;
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_unlock(rwlock_t *lock ) 
{ 


  {
#line 56
  if (ldv_rlock > 1) {

  } else {
#line 56
    ldv_error();
  }
#line 58
  ldv_rlock = ldv_rlock - 1;
#line 59
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_lock(rwlock_t *lock ) 
{ 


  {
#line 64
  if (ldv_wlock == 1) {

  } else {
#line 64
    ldv_error();
  }
#line 66
  ldv_wlock = 2;
#line 67
  return;
}
}
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_unlock(rwlock_t *lock ) 
{ 


  {
#line 72
  if (ldv_wlock != 1) {

  } else {
#line 72
    ldv_error();
  }
#line 74
  ldv_wlock = 1;
#line 75
  return;
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
int ldv_read_trylock(rwlock_t *lock ) 
{ 
  int tmp ;

  {
#line 80
  if (ldv_wlock == 1) {
#line 80
    tmp = ldv_undef_int();
#line 80
    if (tmp) {
#line 82
      ldv_rlock = ldv_rlock + 1;
#line 84
      return (1);
    } else {
#line 87
      return (0);
    }
  } else {
#line 87
    return (0);
  }
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
int ldv_write_trylock(rwlock_t *lock ) 
{ 
  int tmp ;

  {
#line 94
  if (ldv_wlock == 1) {
#line 94
    tmp = ldv_undef_int();
#line 94
    if (tmp) {
#line 96
      ldv_wlock = 2;
#line 98
      return (1);
    } else {
#line 101
      return (0);
    }
  } else {
#line 101
    return (0);
  }
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_lock_irq(rwlock_t *lock ) 
{ 


  {
#line 108
  if (ldv_wlock == 1) {

  } else {
#line 108
    ldv_error();
  }
#line 110
  ldv_rlock = ldv_rlock + 1;
#line 111
  return;
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_unlock_irq(rwlock_t *lock ) 
{ 


  {
#line 116
  if (ldv_rlock > 1) {

  } else {
#line 116
    ldv_error();
  }
#line 118
  ldv_rlock = ldv_rlock - 1;
#line 119
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_lock_irq(rwlock_t *lock ) 
{ 


  {
#line 124
  if (ldv_wlock == 1) {

  } else {
#line 124
    ldv_error();
  }
#line 126
  ldv_wlock = 2;
#line 127
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_unlock_irq(rwlock_t *lock ) 
{ 


  {
#line 132
  if (ldv_wlock != 1) {

  } else {
#line 132
    ldv_error();
  }
#line 134
  ldv_wlock = 1;
#line 135
  return;
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_lock_bh(rwlock_t *lock ) 
{ 


  {
#line 140
  if (ldv_wlock == 1) {

  } else {
#line 140
    ldv_error();
  }
#line 142
  ldv_rlock = ldv_rlock + 1;
#line 143
  return;
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_read_unlock_bh(rwlock_t *lock ) 
{ 


  {
#line 148
  if (ldv_rlock > 1) {

  } else {
#line 148
    ldv_error();
  }
#line 150
  ldv_rlock = ldv_rlock - 1;
#line 151
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_lock_bh(rwlock_t *lock ) 
{ 


  {
#line 156
  if (ldv_wlock == 1) {

  } else {
#line 156
    ldv_error();
  }
#line 158
  ldv_wlock = 2;
#line 159
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_write_unlock_bh(rwlock_t *lock ) 
{ 


  {
#line 164
  if (ldv_wlock != 1) {

  } else {
#line 164
    ldv_error();
  }
#line 166
  ldv_wlock = 1;
#line 167
  return;
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/scsi/qla2xxx/qla2xxx.ko--X--defaultlinux-3.12-rc1.tar.xz--X--118_1a--X--cpachecker/linux-3.12-rc1.tar.xz/csd_deg_dscv/27/dscv_tempdir/rule-instrumentor/118_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 173
  if (ldv_rlock == 1) {

  } else {
#line 173
    ldv_error();
  }
#line 175
  if (ldv_wlock == 1) {

  } else {
#line 175
    ldv_error();
  }
#line 176
  return;
}
}
