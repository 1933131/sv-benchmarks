/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct class;
#line 199
struct device;
#line 245
struct completion;
#line 277
struct gendisk;
#line 338
struct module;
#line 346
struct mutex;
#line 500
struct request_queue;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_12 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_12 pte_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
struct atomic_notifier_head;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 297
struct timespec;
#line 298
struct compat_timespec;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_nanosleep_31 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 299
struct pollfd;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_29 __annonCompField19 ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
union __anonunion____missing_field_name_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_46 __annonCompField20 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 115
struct kernfs_root;
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_47 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_47 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_48 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_48 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_49 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_49 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct tvec_base;
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 259
enum hrtimer_restart;
#line 270
struct workqueue_struct;
#line 271
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_50 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_50 nodemask_t;
#line 520
struct path;
#line 521
struct inode;
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 1269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196
struct of_device_id;
#line 196
struct acpi_device_id;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kdev_t.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 623
struct mfd_cell;
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
   bool prevent_deferred_probe ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_146 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField32 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_145 __annonCompField33 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct vfsmount;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_148 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField34 ;
   u64 hash_len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_149 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_149 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct mem_cgroup;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_151 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_150 {
   struct __anonstruct____missing_field_name_151 __annonCompField36 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 435
struct pid_namespace;
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct backing_dev_info;
#line 61
struct export_operations;
#line 63
struct iovec;
#line 64
struct nameidata;
#line 65
struct kiocb;
#line 66
struct pipe_inode_info;
#line 67
struct poll_table_struct;
#line 68
struct kstatfs;
#line 69
struct cred;
#line 70
struct swap_info_struct;
#line 71
struct iov_iter;
#line 72
struct vm_fault;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_154 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_154 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_155 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 460
struct address_space;
#line 461
struct writeback_control;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_158 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_159 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_160 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_158 __annonCompField40 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_159 __annonCompField41 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_160 __annonCompField42 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_161 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_161 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_163 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_162 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_163 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_162 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_169 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_170 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_168 {
   struct __anonstruct____missing_field_name_169 __annonCompField45 ;
   struct __anonstruct____missing_field_name_170 __annonCompField46 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_168 __annonCompField47 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_171 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_173 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_177 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_176 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_177 __annonCompField50 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_175 {
   union __anonunion____missing_field_name_176 __annonCompField51 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_174 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_175 __annonCompField52 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_172 {
   union __anonunion____missing_field_name_173 __annonCompField49 ;
   union __anonunion____missing_field_name_174 __annonCompField53 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_179 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_180 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_178 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_179 __annonCompField55 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_180 __annonCompField56 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_181 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   struct __anonstruct____missing_field_name_172 __annonCompField54 ;
   union __anonunion____missing_field_name_178 __annonCompField57 ;
   union __anonunion____missing_field_name_181 __annonCompField58 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_182 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_182 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/page_ext.h"
struct user_struct;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 379 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irq.h"
struct proc_dir_entry;
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_194 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_194 __annonCompField64 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_196 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_196 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_198 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_199 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_200 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_201 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_203 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_202 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_203 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_204 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_205 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_197 {
   int _pad[28U] ;
   struct __anonstruct__kill_198 _kill ;
   struct __anonstruct__timer_199 _timer ;
   struct __anonstruct__rt_200 _rt ;
   struct __anonstruct__sigchld_201 _sigchld ;
   struct __anonstruct__sigfault_202 _sigfault ;
   struct __anonstruct__sigpoll_204 _sigpoll ;
   struct __anonstruct__sigsys_205 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_197 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_208 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_209 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_211 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_210 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_211 __annonCompField67 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_212 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_214 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_213 {
   union __anonunion_payload_214 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_208 __annonCompField65 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_209 __annonCompField66 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_210 __annonCompField68 ;
   union __anonunion_type_data_212 type_data ;
   union __anonunion____missing_field_name_213 __annonCompField69 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct reclaim_state;
#line 825 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
struct ipmi_addr {
   int addr_type ;
   short channel ;
   char data[32U] ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ipmi.h"
struct ipmi_system_interface_addr {
   int addr_type ;
   short channel ;
   unsigned char lun ;
};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ipmi.h"
struct ipmi_ipmb_addr {
   int addr_type ;
   short channel ;
   unsigned char slave_addr ;
   unsigned char lun ;
};
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ipmi.h"
struct ipmi_lan_addr {
   int addr_type ;
   short channel ;
   unsigned char privilege ;
   unsigned char session_handle ;
   unsigned char remote_SWID ;
   unsigned char local_SWID ;
   unsigned char lun ;
};
#line 159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ipmi.h"
struct kernel_ipmi_msg {
   unsigned char netfn ;
   unsigned char cmd ;
   unsigned short data_len ;
   unsigned char *data ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2
} ;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
struct fwnode_handle {
   enum fwnode_type type ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u64 acpi_io_address;
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef void *acpi_handle;
#line 628 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u32 acpi_object_type;
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_integer_219 {
   acpi_object_type type ;
   u64 value ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_string_220 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_buffer_221 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_package_222 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_reference_223 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_processor_224 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_power_resource_225 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_219 integer ;
   struct __anonstruct_string_220 string ;
   struct __anonstruct_buffer_221 buffer ;
   struct __anonstruct_package_222 package ;
   struct __anonstruct_reference_223 reference ;
   struct __anonstruct_processor_224 processor ;
   struct __anonstruct_power_resource_225 power_resource ;
};
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_driver;
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_hotplug_profile {
   struct kobject kobj ;
   int (*scan_dependent)(struct acpi_device * ) ;
   void (*notify_online)(struct acpi_device * ) ;
   bool enabled ;
   bool demand_offline ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_scan_handler {
   struct acpi_device_id  const  *ids ;
   struct list_head list_node ;
   bool (*match)(char * , struct acpi_device_id  const  ** ) ;
   int (*attach)(struct acpi_device * , struct acpi_device_id  const  * ) ;
   void (*detach)(struct acpi_device * ) ;
   void (*bind)(struct device * ) ;
   void (*unbind)(struct device * ) ;
   struct acpi_hotplug_profile hotplug ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_hotplug_context {
   struct acpi_device *self ;
   int (*notify)(struct acpi_device * , u32  ) ;
   void (*uevent)(struct acpi_device * , u32  ) ;
   void (*fixup)(struct acpi_device * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_ops {
   int (*add)(struct acpi_device * ) ;
   int (*remove)(struct acpi_device * ) ;
   void (*notify)(struct acpi_device * , u32  ) ;
};
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_driver {
   char name[80U] ;
   char class[80U] ;
   struct acpi_device_id  const  *ids ;
   unsigned int flags ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_status {
   unsigned char present : 1 ;
   unsigned char enabled : 1 ;
   unsigned char show_in_ui : 1 ;
   unsigned char functional : 1 ;
   unsigned char battery_present : 1 ;
   unsigned int reserved : 27 ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_flags {
   unsigned char dynamic_status : 1 ;
   unsigned char removable : 1 ;
   unsigned char ejectable : 1 ;
   unsigned char power_manageable : 1 ;
   unsigned char match_driver : 1 ;
   unsigned char initialized : 1 ;
   unsigned char visited : 1 ;
   unsigned char hotplug_notify : 1 ;
   unsigned char is_dock_station : 1 ;
   unsigned int reserved : 23 ;
};
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_bus_id[8U];
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef unsigned long acpi_bus_address;
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_device_name[40U];
#line 227 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_device_class[20U];
#line 233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_pnp_type {
   unsigned char hardware_id : 1 ;
   unsigned char bus_address : 1 ;
   unsigned char platform_id : 1 ;
   unsigned int reserved : 29 ;
};
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   struct acpi_pnp_type type ;
   acpi_bus_address bus_address ;
   char *unique_id ;
   struct list_head ids ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
   union acpi_object *str_obj ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power_flags {
   unsigned char explicit_get : 1 ;
   unsigned char power_resources : 1 ;
   unsigned char inrush_current : 1 ;
   unsigned char power_removed : 1 ;
   unsigned char ignore_parent : 1 ;
   unsigned char dsw_present : 1 ;
   unsigned int reserved : 26 ;
};
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct __anonstruct_flags_226 {
   unsigned char valid : 1 ;
   unsigned char os_accessible : 1 ;
   unsigned char explicit_set : 1 ;
   unsigned char reserved : 6 ;
};
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power_state {
   struct __anonstruct_flags_226 flags ;
   int power ;
   int latency ;
   struct list_head resources ;
};
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[5U] ;
};
#line 287 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf_flags {
   u8 reserved ;
};
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct __anonstruct_flags_227 {
   unsigned char valid : 1 ;
   unsigned char reserved : 7 ;
};
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf_state {
   struct __anonstruct_flags_227 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_flags {
   unsigned char valid : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char notifier_present : 1 ;
   unsigned char enabled : 1 ;
};
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_context {
   struct work_struct work ;
   struct device *dev ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   u64 gpe_number ;
   u64 sleep_state ;
   struct list_head resources ;
   struct acpi_device_wakeup_flags flags ;
   struct acpi_device_wakeup_context context ;
   struct wakeup_source *ws ;
   int prepare_count ;
};
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_data {
   union acpi_object  const  *pointer ;
   union acpi_object  const  *properties ;
   union acpi_object  const  *of_compatible ;
};
#line 348
struct acpi_gpio_mapping;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device {
   int device_type ;
   acpi_handle handle ;
   struct fwnode_handle fwnode ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct list_head del_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_device_data data ;
   struct acpi_scan_handler *handler ;
   struct acpi_hotplug_context *hp ;
   struct acpi_driver *driver ;
   struct acpi_gpio_mapping  const  *driver_gpios ;
   void *driver_data ;
   struct device dev ;
   unsigned int physical_node_count ;
   unsigned int dep_unmet ;
   struct list_head physical_node_list ;
   struct mutex physical_node_lock ;
   void (*remove)(struct acpi_device * ) ;
};
#line 638 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/acpi.h"
struct acpi_gpio_params {
   unsigned int crs_entry_index ;
   unsigned int line_index ;
   bool active_low ;
};
#line 691 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/acpi.h"
struct acpi_gpio_mapping {
   char const   *name ;
   struct acpi_gpio_params  const  *data ;
   unsigned int size ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct ipmi_user;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
typedef struct ipmi_user *ipmi_user_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct ipmi_recv_msg {
   struct list_head link ;
   int recv_type ;
   ipmi_user_t user ;
   struct ipmi_addr addr ;
   long msgid ;
   struct kernel_ipmi_msg msg ;
   void *user_msg_data ;
   void (*done)(struct ipmi_recv_msg * ) ;
   unsigned char msg_data[272U] ;
};
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct ipmi_user_hndl {
   void (*ipmi_recv_hndl)(struct ipmi_recv_msg * , void * ) ;
   void (*ipmi_watchdog_pretimeout)(void * ) ;
};
#line 242 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct ipmi_smi_watcher {
   struct list_head link ;
   struct module *owner ;
   void (*new_smi)(int  , struct device * ) ;
   void (*smi_gone)(int  ) ;
};
#line 274
enum ipmi_addr_src {
    SI_INVALID = 0,
    SI_HOTMOD = 1,
    SI_HARDCODED = 2,
    SI_SPMI = 3,
    SI_ACPI = 4,
    SI_SMBIOS = 5,
    SI_PCI = 6,
    SI_DEVICETREE = 7,
    SI_DEFAULT = 8
} ;
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct __anonstruct_acpi_info_228 {
   acpi_handle acpi_handle ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
union ipmi_smi_info_union {
   struct __anonstruct_acpi_info_228 acpi_info ;
};
#line 294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
struct ipmi_smi_info {
   enum ipmi_addr_src addr_src ;
   struct device *dev ;
   union ipmi_smi_info_union addr_info ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
struct ipmi_smi;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
typedef struct ipmi_smi *ipmi_smi_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
struct ipmi_smi_msg {
   struct list_head link ;
   long msgid ;
   void *user_data ;
   int data_size ;
   unsigned char data[272U] ;
   int rsp_size ;
   unsigned char rsp[272U] ;
   void (*done)(struct ipmi_smi_msg * ) ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
struct ipmi_smi_handlers {
   struct module *owner ;
   int (*start_processing)(void * , ipmi_smi_t  ) ;
   int (*get_smi_info)(void * , struct ipmi_smi_info * ) ;
   void (*sender)(void * , struct ipmi_smi_msg * ) ;
   void (*request_events)(void * ) ;
   void (*set_need_watch)(void * , bool  ) ;
   void (*set_run_to_completion)(void * , bool  ) ;
   void (*poll)(void * ) ;
   void (*set_maintenance_mode)(void * , bool  ) ;
   int (*inc_usecount)(void * ) ;
   void (*dec_usecount)(void * ) ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
struct ipmi_device_id {
   unsigned char device_id ;
   unsigned char device_revision ;
   unsigned char firmware_revision_1 ;
   unsigned char firmware_revision_2 ;
   unsigned char ipmi_version ;
   unsigned char additional_device_support ;
   unsigned int manufacturer_id ;
   unsigned int product_id ;
   unsigned char aux_firmware_revision[4U] ;
   unsigned char aux_firmware_revision_set : 1 ;
};
#line 445 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ipmi_user {
   struct list_head link ;
   bool valid ;
   struct kref refcount ;
   struct ipmi_user_hndl *handler ;
   void *handler_data ;
   ipmi_smi_t intf ;
   bool gets_events ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct cmd_rcvr {
   struct list_head link ;
   ipmi_user_t user ;
   unsigned char netfn ;
   unsigned char cmd ;
   unsigned int chans ;
   struct cmd_rcvr *next ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct seq_table {
   unsigned char inuse : 1 ;
   unsigned char broadcast : 1 ;
   unsigned long timeout ;
   unsigned long orig_timeout ;
   unsigned int retries_left ;
   long seqid ;
   struct ipmi_recv_msg *recv_msg ;
};
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ipmi_channel {
   unsigned char medium ;
   unsigned char protocol ;
   unsigned char address ;
   unsigned char lun ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ipmi_proc_entry {
   char *name ;
   struct ipmi_proc_entry *next ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct bmc_device {
   struct platform_device pdev ;
   struct ipmi_device_id id ;
   unsigned char guid[16U] ;
   int guid_set ;
   char name[16U] ;
   struct kref usecount ;
};
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ipmi_smi {
   int intf_num ;
   struct kref refcount ;
   bool in_shutdown ;
   struct list_head link ;
   struct list_head users ;
   unsigned char ipmi_version_major ;
   unsigned char ipmi_version_minor ;
   wait_queue_head_t waitq ;
   struct bmc_device *bmc ;
   char *my_dev_name ;
   struct ipmi_smi_handlers *handlers ;
   void *send_info ;
   struct mutex proc_entry_lock ;
   struct ipmi_proc_entry *proc_entries ;
   struct device *si_dev ;
   spinlock_t seq_lock ;
   struct seq_table seq_table[64U] ;
   int curr_seq ;
   spinlock_t waiting_rcv_msgs_lock ;
   struct list_head waiting_rcv_msgs ;
   atomic_t watchdog_pretimeouts_to_deliver ;
   struct tasklet_struct recv_tasklet ;
   spinlock_t xmit_msgs_lock ;
   struct list_head xmit_msgs ;
   struct ipmi_smi_msg *curr_msg ;
   struct list_head hp_xmit_msgs ;
   struct mutex cmd_rcvrs_mutex ;
   struct list_head cmd_rcvrs ;
   spinlock_t events_lock ;
   struct list_head waiting_events ;
   unsigned int waiting_events_count ;
   char delivering_events ;
   char event_msg_printed ;
   atomic_t event_waiters ;
   unsigned int ticks_to_req_ev ;
   int last_needs_timer ;
   unsigned char event_receiver ;
   unsigned char event_receiver_lun ;
   unsigned char local_sel_device ;
   unsigned char local_event_generator ;
   int maintenance_mode ;
   bool maintenance_mode_enable ;
   int auto_maintenance_timeout ;
   spinlock_t maintenance_mode_lock ;
   void (*null_user_handler)(ipmi_smi_t  , struct ipmi_recv_msg * ) ;
   int curr_channel ;
   struct ipmi_channel channels[16U] ;
   struct proc_dir_entry *proc_dir ;
   char proc_dir_name[10U] ;
   atomic_t stats[28U] ;
   int run_to_completion ;
};
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct watcher_entry {
   int intf_num ;
   ipmi_smi_t intf ;
   struct list_head link ;
};
#line 2220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct prod_dev_id {
   unsigned int product_id ;
   unsigned char device_id ;
};
#line 4616 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ldv_struct_EMGentry_20 {
   int signal_pending ;
};
#line 651 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_struct_dummy_resourceless_instance_14 {
   struct notifier_block *arg0 ;
   int signal_pending ;
};
#line 656 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_struct_timer_instance_15 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
#line 3924 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___0;
#line 3936 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___1;
#line 3948 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___2;
#line 3960 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___3;
#line 3972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___4;
#line 3984 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
typedef int ldv_func_ret_type___5;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 2279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 27
struct usb_device;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct urb;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 16
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 217
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 221
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) ;
#line 222
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) ;
#line 223
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) ;
#line 224
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) ;
#line 225
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) ;
#line 228
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_203(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_200(int ldv_func_arg1 ) ;
#line 75
int ldv_filter_err_code(int ret_val ) ;
#line 122
static void ldv_ldv_check_final_state_201(void) ;
#line 126
static void ldv_ldv_check_final_state_202(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
extern void ldv_after_alloc(void * ) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 312
  ldv_check_alloc_flags(flags);
#line 313
  tmp = ldv_malloc_unknown_size();
  }
#line 313
  return (tmp);
}
}
#line 336
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) ;
#line 337
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) ;
#line 341
int ldv_linux_kernel_module_try_module_get(struct module *module ) ;
#line 343
void ldv_linux_kernel_module_module_put(struct module *module ) ;
#line 366
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) ;
#line 370
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
#line 374
static void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) ;
#line 378
static void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) ;
#line 382
static void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) ;
#line 386
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) ;
#line 390
static void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) ;
#line 394
static void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) ;
#line 398
static void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) ;
#line 402
static void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
#line 406
static void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) ;
#line 410
static void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) ;
#line 414
static void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) ;
#line 418
static void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) ;
#line 422
static void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) ;
#line 426
static void ldv_mutex_lock_164(struct mutex *ldv_func_arg1 ) ;
#line 430
static void ldv_mutex_lock_169(struct mutex *ldv_func_arg1 ) ;
#line 434
static void ldv_mutex_lock_170(struct mutex *ldv_func_arg1 ) ;
#line 438
static void ldv_mutex_lock_172(struct mutex *ldv_func_arg1 ) ;
#line 446
void ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) ;
#line 450
void ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) ;
#line 460
void ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(struct mutex *lock ) ;
#line 464
void ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(struct mutex *lock ) ;
#line 467
void ldv_linux_kernel_locking_mutex_mutex_lock_ipmidriver_mutex(struct mutex *lock ) ;
#line 471
void ldv_linux_kernel_locking_mutex_mutex_unlock_ipmidriver_mutex(struct mutex *lock ) ;
#line 488
void ldv_linux_kernel_locking_mutex_mutex_lock_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) ;
#line 492
void ldv_linux_kernel_locking_mutex_mutex_unlock_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) ;
#line 495
void ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(struct mutex *lock ) ;
#line 499
void ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(struct mutex *lock ) ;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 206
  __asm__  volatile   ("":);
#line 206
  return (0);

#line 206
  return (1);
}
}
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 240
extern struct atomic_notifier_head panic_notifier_list ;
#line 389
extern int sprintf(char * , char const   *  , ...) ;
#line 392
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 400
extern char *kasprintf(gfp_t  , char const   *  , ...) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 63
  __list_add(new, head, head->next);
  }
#line 64
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 77
  __list_add(new, head->prev, head);
  }
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
  }
#line 170
  return;
}
}
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 278
  first = list->next;
#line 279
  last = list->prev;
#line 281
  first->prev = prev;
#line 282
  prev->next = first;
#line 284
  last->next = next;
#line 285
  next->prev = last;
#line 286
  return;
}
}
#line 305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  {
#line 308
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 308
  if (tmp == 0) {
    {
#line 309
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  } else {

  }
#line 310
  return;
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 63
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 64
extern size_t strlen(char const   * ) ;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 117
extern char *kstrdup(char const   * , gfp_t  ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 49
__inline static void atomic_add(int i , atomic_t *v ) ;
#line 67
__inline static void atomic_sub(int i , atomic_t *v ) ;
#line 83
__inline static int atomic_sub_and_test(int i , atomic_t *v ) ;
#line 98
__inline static void atomic_inc(atomic_t *v ) ;
#line 114
__inline static void atomic_dec(atomic_t *v ) ;
#line 159
__inline static int atomic_add_return(int i , atomic_t *v ) ;
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 181
  __old = old;
#line 181
  __new = new;
  {
#line 181
  if (4UL == 1UL) {
#line 181
    goto case_1;
  } else {

  }
#line 181
  if (4UL == 2UL) {
#line 181
    goto case_2;
  } else {

  }
#line 181
  if (4UL == 4UL) {
#line 181
    goto case_4;
  } else {

  }
#line 181
  if (4UL == 8UL) {
#line 181
    goto case_8;
  } else {

  }
#line 181
  goto switch_default;
  case_1: /* CIL Label */ 
#line 181
  __ptr = (u8 volatile   *)(& v->counter);
#line 181
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 181
  goto ldv_6334;
  case_2: /* CIL Label */ 
#line 181
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 181
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 181
  goto ldv_6334;
  case_4: /* CIL Label */ 
#line 181
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 181
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 181
  goto ldv_6334;
  case_8: /* CIL Label */ 
#line 181
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 181
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 181
  goto ldv_6334;
  switch_default: /* CIL Label */ 
  {
#line 181
  __cmpxchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_6334: ;
#line 181
  return (__ret);
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  }
  ldv_6363: 
  {
#line 199
  tmp = __builtin_expect(c == u, 0L);
  }
#line 199
  if (tmp != 0L) {
#line 200
    goto ldv_6362;
  } else {

  }
  {
#line 201
  old = atomic_cmpxchg(v, c, c + a);
#line 202
  tmp___0 = __builtin_expect(old == c, 1L);
  }
#line 202
  if (tmp___0 != 0L) {
#line 203
    goto ldv_6362;
  } else {

  }
#line 204
  c = old;
#line 205
  goto ldv_6363;
  ldv_6362: ;
#line 206
  return (c);
}
}
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/atomic.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int tmp ;

  {
  {
#line 17
  tmp = __atomic_add_unless(v, a, u);
  }
#line 17
  return (tmp != u);
}
}
#line 484 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
extern void __ldv_linux_kernel_locking_spinlock_spin_lock(spinlock_t * ) ;
#line 507
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_109(spinlock_t *ldv_func_arg1 ) ;
#line 511
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_111(spinlock_t *ldv_func_arg1 ) ;
#line 515
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_113(spinlock_t *ldv_func_arg1 ) ;
#line 519
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_119(spinlock_t *ldv_func_arg1 ) ;
#line 523
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_125(spinlock_t *ldv_func_arg1 ) ;
#line 527
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_132(spinlock_t *ldv_func_arg1 ) ;
#line 531
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(spinlock_t *ldv_func_arg1 ) ;
#line 535
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(spinlock_t *ldv_func_arg1 ) ;
#line 539
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_138(spinlock_t *ldv_func_arg1 ) ;
#line 543
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_144(spinlock_t *ldv_func_arg1 ) ;
#line 547
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_146(spinlock_t *ldv_func_arg1 ) ;
#line 551
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_148(spinlock_t *ldv_func_arg1 ) ;
#line 555
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_151(spinlock_t *ldv_func_arg1 ) ;
#line 559
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_176(spinlock_t *ldv_func_arg1 ) ;
#line 563
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_178(spinlock_t *ldv_func_arg1 ) ;
#line 567
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_180(spinlock_t *ldv_func_arg1 ) ;
#line 571
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_182(spinlock_t *ldv_func_arg1 ) ;
#line 575
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_184(spinlock_t *ldv_func_arg1 ) ;
#line 579
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_186(spinlock_t *ldv_func_arg1 ) ;
#line 583
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_189(spinlock_t *ldv_func_arg1 ) ;
#line 587
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_190(spinlock_t *ldv_func_arg1 ) ;
#line 591
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_192(spinlock_t *ldv_func_arg1 ) ;
#line 607
void ldv_linux_kernel_locking_spinlock_spin_lock_events_lock_of_ipmi_smi(void) ;
#line 608
void ldv_linux_kernel_locking_spinlock_spin_unlock_events_lock_of_ipmi_smi(void) ;
#line 639
void ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi(void) ;
#line 640
void ldv_linux_kernel_locking_spinlock_spin_unlock_maintenance_mode_lock_of_ipmi_smi(void) ;
#line 663
void ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi(void) ;
#line 664
void ldv_linux_kernel_locking_spinlock_spin_unlock_seq_lock_of_ipmi_smi(void) ;
#line 679
void ldv_linux_kernel_locking_spinlock_spin_lock_waiting_rcv_msgs_lock_of_ipmi_smi(void) ;
#line 680
void ldv_linux_kernel_locking_spinlock_spin_unlock_waiting_rcv_msgs_lock_of_ipmi_smi(void) ;
#line 687
void ldv_linux_kernel_locking_spinlock_spin_lock_xmit_msgs_lock_of_ipmi_smi(void) ;
#line 688
void ldv_linux_kernel_locking_spinlock_spin_unlock_xmit_msgs_lock_of_ipmi_smi(void) ;
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 193
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) ;
#line 209
static void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) ;
#line 213
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) ;
#line 217
static void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) ;
#line 221
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
#line 225
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) ;
#line 229
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
#line 233
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
#line 237
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) ;
#line 241
static void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
#line 245
static void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) ;
#line 249
static void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) ;
#line 253
static void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) ;
#line 257
static void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) ;
#line 261
static void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) ;
#line 265
static void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) ;
#line 269
static void ldv_mutex_unlock_165(struct mutex *ldv_func_arg1 ) ;
#line 273
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) ;
#line 277
static void ldv_mutex_unlock_167(struct mutex *ldv_func_arg1 ) ;
#line 281
static void ldv_mutex_unlock_168(struct mutex *ldv_func_arg1 ) ;
#line 285
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1 ) ;
#line 289
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) ;
#line 293
static void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 422 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 424
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  }
#line 425
  return;
}
}
#line 454
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 462
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 466
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 470
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 474
__inline static void ldv_spin_unlock_irqrestore_133(spinlock_t *lock , unsigned long flags ) ;
#line 478
__inline static void ldv_spin_unlock_irqrestore_133(spinlock_t *lock , unsigned long flags ) ;
#line 482
__inline static void ldv_spin_unlock_irqrestore_137(spinlock_t *lock , unsigned long flags ) ;
#line 486
__inline static void ldv_spin_unlock_irqrestore_137(spinlock_t *lock , unsigned long flags ) ;
#line 490
__inline static void ldv_spin_unlock_irqrestore_145(spinlock_t *lock , unsigned long flags ) ;
#line 494
__inline static void ldv_spin_unlock_irqrestore_133(spinlock_t *lock , unsigned long flags ) ;
#line 498
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 502
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 506
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 510
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 514
__inline static void ldv_spin_unlock_irqrestore_137(spinlock_t *lock , unsigned long flags ) ;
#line 518
__inline static void ldv_spin_unlock_irqrestore_179(spinlock_t *lock , unsigned long flags ) ;
#line 522
__inline static void ldv_spin_unlock_irqrestore_179(spinlock_t *lock , unsigned long flags ) ;
#line 526
__inline static void ldv_spin_unlock_irqrestore_145(spinlock_t *lock , unsigned long flags ) ;
#line 530
__inline static void ldv_spin_unlock_irqrestore_179(spinlock_t *lock , unsigned long flags ) ;
#line 534
__inline static void ldv_spin_unlock_irqrestore_145(spinlock_t *lock , unsigned long flags ) ;
#line 538
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 542
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) ;
#line 546
__inline static void ldv_spin_unlock_irqrestore_133(spinlock_t *lock , unsigned long flags ) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 913
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
static void ldv_synchronize_sched_35(void) ;
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
__inline static void synchronize_rcu(void) 
{ 


  {
  {
#line 249
  ldv_synchronize_sched_35();
  }
#line 250
  return;
}
}
#line 431
extern int debug_lockdep_rcu_enabled(void) ;
#line 433
extern int rcu_read_lock_held(void) ;
#line 878
__inline static void rcu_read_lock(void) ;
#line 936
__inline static void rcu_read_unlock(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
extern int sysfs_create_link(struct kobject * , struct kobject * , char const   * ) ;
#line 221
extern void sysfs_remove_link(struct kobject * , char const   * ) ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
  {
#line 34
  atomic_set(& kref->refcount, 1);
  }
#line 35
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 47
  if (tmp___2 != 0L) {
    {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 47
    if (tmp___0 != 0L) {
      {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
      }
    } else {

    }
    {
#line 47
    tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
  {
#line 47
  __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 49
  return;
}
}
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 71
  if (tmp != 0L) {
    {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
    }
  } else {

  }
  {
#line 71
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
  }
#line 73
  if (tmp___0 != 0) {
    {
#line 74
    (*release)(kref);
    }
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = kref_sub(kref, 1U, release);
  }
#line 99
  return (tmp);
}
}
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 171
  return ((unsigned long )timer->entry.next != (unsigned long )((struct list_head */* const  */)0));
}
}
#line 176
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 179
static int ldv_mod_timer_194(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
static int ldv_mod_timer_195(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
static int ldv_mod_timer_196(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 248
static int ldv_del_timer_sync_199(struct timer_list *ldv_func_arg1 ) ;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
__inline static bool seq_has_overflowed(struct seq_file *m ) 
{ 


  {
#line 57
  return (m->count == m->size);
}
}
#line 114
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 115
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 118
extern int seq_putc(struct seq_file * , char  ) ;
#line 122
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 130
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 132
extern int single_release(struct inode * , struct file * ) ;
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
extern int atomic_notifier_chain_register(struct atomic_notifier_head * , struct notifier_block * ) ;
#line 122
static int ldv_atomic_notifier_chain_register_197(struct atomic_notifier_head *ldv_func_arg1 ,
                                                  struct notifier_block *ldv_func_arg2 ) ;
#line 135
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head * , struct notifier_block * ) ;
#line 139
static int ldv_atomic_notifier_chain_unregister_198(struct atomic_notifier_head *ldv_func_arg1 ,
                                                    struct notifier_block *ldv_func_arg2 ) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern int driver_register(struct device_driver * ) ;
#line 255
extern void driver_unregister(struct device_driver * ) ;
#line 291
extern struct device *driver_find_device(struct device_driver * , struct device * ,
                                         void * , int (*)(struct device * , void * ) ) ;
#line 801 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static struct device *kobj_to_dev(struct kobject *kobj ) 
{ 
  struct kobject  const  *__mptr ;

  {
#line 803
  __mptr = (struct kobject  const  *)kobj;
#line 803
  return ((struct device *)__mptr + 0xfffffffffffffff0UL);
}
}
#line 1013
extern void put_device(struct device * ) ;
#line 1056
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
extern int platform_device_register(struct platform_device * ) ;
#line 45
extern void platform_device_unregister(struct platform_device * ) ;
#line 47
extern struct bus_type platform_bus_type ;
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist.h"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) ;
#line 103
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) ;
#line 133
__inline static void list_del_rcu(struct list_head *entry ) ;
#line 202
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) ;
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
static bool ldv_try_module_get_107(struct module *ldv_func_arg1 ) ;
#line 465
static bool ldv_try_module_get_116(struct module *ldv_func_arg1 ) ;
#line 471
static void ldv_module_put_108(struct module *ldv_func_arg1 ) ;
#line 475
static void ldv_module_put_117(struct module *ldv_func_arg1 ) ;
#line 479
static void ldv_module_put_130(struct module *ldv_func_arg1 ) ;
#line 483
static void ldv_module_put_173(struct module *ldv_func_arg1 ) ;
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 419
extern void schedule(void) ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 418
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 25
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 39
extern void *PDE_DATA(struct inode  const  * ) ;
#line 41
extern void proc_remove(struct proc_dir_entry * ) ;
#line 42
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi.h"
void ipmi_free_recv_msg(struct ipmi_recv_msg *msg ) ;
#line 102
int ipmi_create_user(unsigned int if_num , struct ipmi_user_hndl *handler , void *handler_data ,
                     ipmi_user_t **user ) ;
#line 113
int ipmi_destroy_user(ipmi_user_t user ) ;
#line 116
void ipmi_get_version(ipmi_user_t user , unsigned char *major , unsigned char *minor ) ;
#line 126
int ipmi_set_my_address(ipmi_user_t user , unsigned int channel , unsigned char address ) ;
#line 129
int ipmi_get_my_address(ipmi_user_t user , unsigned int channel , unsigned char *address ) ;
#line 132
int ipmi_set_my_LUN(ipmi_user_t user , unsigned int channel , unsigned char LUN ) ;
#line 135
int ipmi_get_my_LUN(ipmi_user_t user , unsigned int channel , unsigned char *address ) ;
#line 152
int ipmi_request_settime(ipmi_user_t user , struct ipmi_addr *addr , long msgid ,
                         struct kernel_ipmi_msg *msg , void *user_msg_data , int priority ,
                         int retries , unsigned int retry_time_ms ) ;
#line 170
int ipmi_request_supply_msgs(ipmi_user_t user , struct ipmi_addr *addr , long msgid ,
                             struct kernel_ipmi_msg *msg , void *user_msg_data , void *supplied_smi ,
                             struct ipmi_recv_msg *supplied_recv , int priority ) ;
#line 186
void ipmi_poll_interface(ipmi_user_t user ) ;
#line 197
int ipmi_register_for_cmd(ipmi_user_t user , unsigned char netfn , unsigned char cmd ,
                          unsigned int chans ) ;
#line 201
int ipmi_unregister_for_cmd(ipmi_user_t user , unsigned char netfn , unsigned char cmd ,
                            unsigned int chans ) ;
#line 232
int ipmi_get_maintenance_mode(ipmi_user_t user ) ;
#line 233
int ipmi_set_maintenance_mode(ipmi_user_t user , int mode ) ;
#line 241
int ipmi_set_gets_events(ipmi_user_t user , bool val ) ;
#line 263
int ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher ) ;
#line 264
int ipmi_smi_watcher_unregister(struct ipmi_smi_watcher *watcher ) ;
#line 270
unsigned int ipmi_addr_length(int addr_type ) ;
#line 273
int ipmi_validate_addr(struct ipmi_addr *addr , int len ) ;
#line 282
char const   *ipmi_addr_src_to_str(enum ipmi_addr_src src ) ;
#line 314
int ipmi_get_smi_info(int if_num , struct ipmi_smi_info *data ) ;
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
int ipmi_register_smi(struct ipmi_smi_handlers *handlers , void *send_info , struct ipmi_device_id *device_id ,
                      struct device *si_dev , unsigned char slave_addr ) ;
#line 220
int ipmi_unregister_smi(ipmi_smi_t intf ) ;
#line 228
void ipmi_smi_msg_received(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) ;
#line 232
void ipmi_smi_watchdog_pretimeout(ipmi_smi_t intf ) ;
#line 234
struct ipmi_smi_msg *ipmi_alloc_smi_msg(void) ;
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ipmi_smi.h"
__inline static void ipmi_free_smi_msg(struct ipmi_smi_msg *msg ) 
{ 


  {
  {
#line 237
  (*(msg->done))(msg);
  }
#line 238
  return;
}
}
#line 243
int ipmi_smi_add_proc_entry(ipmi_smi_t smi , char *name , struct file_operations  const  *proc_ops ,
                            void *data ) ;
#line 509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
extern void __tasklet_schedule(struct tasklet_struct * ) ;
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  {
#line 513
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  }
#line 513
  if (tmp == 0) {
    {
#line 514
    __tasklet_schedule(t);
    }
  } else {

  }
#line 515
  return;
}
}
#line 559
extern void tasklet_kill(struct tasklet_struct * ) ;
#line 561
extern void tasklet_init(struct tasklet_struct * , void (*)(unsigned long  ) , unsigned long  ) ;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void) ;
#line 55
static int ipmi_init_msghandler(void) ;
#line 56
static void smi_recv_tasklet(unsigned long val ) ;
#line 57
static void handle_new_recv_msgs(ipmi_smi_t intf ) ;
#line 58
static void need_waiter(ipmi_smi_t intf ) ;
#line 59
static int handle_one_recv_msg(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) ;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int initialized  ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct proc_dir_entry *proc_ipmi_root  ;
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct platform_driver ipmidriver  = 
#line 453
     {0, 0, 0, 0, 0, {"ipmi", & platform_bus_type, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0}, 0, (_Bool)0};
#line 459 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct mutex ipmidriver_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "ipmidriver_mutex.wait_lock",
                                                           0, 0UL}}}}, {& ipmidriver_mutex.wait_list,
                                                                        & ipmidriver_mutex.wait_list},
    0, (void *)(& ipmidriver_mutex), {0, {0, 0}, "ipmidriver_mutex", 0, 0UL}};
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct list_head ipmi_interfaces  =    {& ipmi_interfaces, & ipmi_interfaces};
#line 462 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct mutex ipmi_interfaces_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "ipmi_interfaces_mutex.wait_lock",
                                                           0, 0UL}}}}, {& ipmi_interfaces_mutex.wait_list,
                                                                        & ipmi_interfaces_mutex.wait_list},
    0, (void *)(& ipmi_interfaces_mutex), {0, {0, 0}, "ipmi_interfaces_mutex", 0,
                                           0UL}};
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct list_head smi_watchers  =    {& smi_watchers, & smi_watchers};
#line 468 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct mutex smi_watchers_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "smi_watchers_mutex.wait_lock",
                                                           0, 0UL}}}}, {& smi_watchers_mutex.wait_list,
                                                                        & smi_watchers_mutex.wait_list},
    0, (void *)(& smi_watchers_mutex), {0, {0, 0}, "smi_watchers_mutex", 0, 0UL}};
#line 475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char *addr_src_to_str[9U]  = 
#line 475
  {      (char *)"invalid",      (char *)"hotmod",      (char *)"hardcoded",      (char *)"SPMI", 
        (char *)"ACPI",      (char *)"SMBIOS",      (char *)"PCI",      (char *)"device-tree", 
        (char *)"default"};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
char const   *ipmi_addr_src_to_str(enum ipmi_addr_src src ) 
{ 


  {
#line 481
  if ((unsigned int )src > 8U) {
#line 482
    src = 0;
  } else {

  }
#line 483
  return ((char const   *)addr_src_to_str[(unsigned int )src]);
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_addr_src_to_str[21U]  = 
#line 485
  {      'i',      'p',      'm',      'i', 
        '_',      'a',      'd',      'd', 
        'r',      '_',      's',      'r', 
        'c',      '_',      't',      'o', 
        '_',      's',      't',      'r', 
        '\000'};
#line 485
struct kernel_symbol  const  __ksymtab_ipmi_addr_src_to_str ;
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_addr_src_to_str  =    {(unsigned long )(& ipmi_addr_src_to_str), (char const   *)(& __kstrtab_ipmi_addr_src_to_str)};
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int is_lan_addr(struct ipmi_addr *addr ) 
{ 


  {
#line 489
  return (addr->addr_type == 4);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int is_ipmb_addr(struct ipmi_addr *addr ) 
{ 


  {
#line 494
  return (addr->addr_type == 1);
}
}
#line 497 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int is_ipmb_bcast_addr(struct ipmi_addr *addr ) 
{ 


  {
#line 499
  return (addr->addr_type == 65);
}
}
#line 502 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void free_recv_msg_list(struct list_head *q ) 
{ 
  struct ipmi_recv_msg *msg ;
  struct ipmi_recv_msg *msg2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 506
  __mptr = (struct list_head  const  *)q->next;
#line 506
  msg = (struct ipmi_recv_msg *)__mptr;
#line 506
  __mptr___0 = (struct list_head  const  *)msg->link.next;
#line 506
  msg2 = (struct ipmi_recv_msg *)__mptr___0;
#line 506
  goto ldv_35931;
  ldv_35930: 
  {
#line 507
  list_del(& msg->link);
#line 508
  ipmi_free_recv_msg(msg);
#line 506
  msg = msg2;
#line 506
  __mptr___1 = (struct list_head  const  *)msg2->link.next;
#line 506
  msg2 = (struct ipmi_recv_msg *)__mptr___1;
  }
  ldv_35931: ;
#line 506
  if ((unsigned long )(& msg->link) != (unsigned long )q) {
#line 508
    goto ldv_35930;
  } else {

  }

#line 513
  return;
}
}
#line 512 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void free_smi_msg_list(struct list_head *q ) 
{ 
  struct ipmi_smi_msg *msg ;
  struct ipmi_smi_msg *msg2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 516
  __mptr = (struct list_head  const  *)q->next;
#line 516
  msg = (struct ipmi_smi_msg *)__mptr;
#line 516
  __mptr___0 = (struct list_head  const  *)msg->link.next;
#line 516
  msg2 = (struct ipmi_smi_msg *)__mptr___0;
#line 516
  goto ldv_35945;
  ldv_35944: 
  {
#line 517
  list_del(& msg->link);
#line 518
  ipmi_free_smi_msg(msg);
#line 516
  msg = msg2;
#line 516
  __mptr___1 = (struct list_head  const  *)msg2->link.next;
#line 516
  msg2 = (struct ipmi_smi_msg *)__mptr___1;
  }
  ldv_35945: ;
#line 516
  if ((unsigned long )(& msg->link) != (unsigned long )q) {
#line 518
    goto ldv_35944;
  } else {

  }

#line 523
  return;
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void clean_up_interface_data(ipmi_smi_t intf ) 
{ 
  int i ;
  struct cmd_rcvr *rcvr ;
  struct cmd_rcvr *rcvr2 ;
  struct list_head list ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
#line 528
  tasklet_kill(& intf->recv_tasklet);
#line 530
  free_smi_msg_list(& intf->waiting_rcv_msgs);
#line 531
  free_recv_msg_list(& intf->waiting_events);
#line 537
  ldv_mutex_lock_97(& intf->cmd_rcvrs_mutex);
#line 538
  INIT_LIST_HEAD(& list);
#line 539
  list_splice_init_rcu(& intf->cmd_rcvrs, & list, & synchronize_rcu);
#line 540
  ldv_mutex_unlock_98(& intf->cmd_rcvrs_mutex);
#line 542
  __mptr = (struct list_head  const  *)list.next;
#line 542
  rcvr = (struct cmd_rcvr *)__mptr;
#line 542
  __mptr___0 = (struct list_head  const  *)rcvr->link.next;
#line 542
  rcvr2 = (struct cmd_rcvr *)__mptr___0;
  }
#line 542
  goto ldv_35961;
  ldv_35960: 
  {
#line 543
  kfree((void const   *)rcvr);
#line 542
  rcvr = rcvr2;
#line 542
  __mptr___1 = (struct list_head  const  *)rcvr2->link.next;
#line 542
  rcvr2 = (struct cmd_rcvr *)__mptr___1;
  }
  ldv_35961: ;
#line 542
  if ((unsigned long )(& rcvr->link) != (unsigned long )(& list)) {
#line 544
    goto ldv_35960;
  } else {

  }
#line 545
  i = 0;
#line 545
  goto ldv_35964;
  ldv_35963: ;
#line 546
  if ((unsigned int )intf->seq_table[i].inuse != 0U && (unsigned long )intf->seq_table[i].recv_msg != (unsigned long )((struct ipmi_recv_msg *)0)) {
    {
#line 548
    ipmi_free_recv_msg(intf->seq_table[i].recv_msg);
    }
  } else {

  }
#line 545
  i = i + 1;
  ldv_35964: ;
#line 545
  if (i <= 63) {
#line 547
    goto ldv_35963;
  } else {

  }

#line 552
  return;
}
}
#line 552 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void intf_free(struct kref *ref ) 
{ 
  ipmi_smi_t intf ;
  struct kref  const  *__mptr ;

  {
  {
#line 554
  __mptr = (struct kref  const  *)ref;
#line 554
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffffcUL;
#line 556
  clean_up_interface_data(intf);
#line 557
  kfree((void const   *)intf);
  }
#line 558
  return;
}
}
#line 566 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher ) 
{ 
  ipmi_smi_t intf ;
  struct list_head to_deliver ;
  struct watcher_entry *e ;
  struct watcher_entry *e2 ;
  struct list_head  const  *__mptr ;
  void *tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
  {
#line 569
  to_deliver.next = & to_deliver;
#line 569
  to_deliver.prev = & to_deliver;
#line 572
  ldv_mutex_lock_99(& smi_watchers_mutex);
#line 574
  ldv_mutex_lock_100(& ipmi_interfaces_mutex);
#line 577
  __mptr = (struct list_head  const  *)ipmi_interfaces.next;
#line 577
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
  }
#line 577
  goto ldv_35990;
  ldv_35989: ;
#line 578
  if (intf->intf_num == -1) {
#line 579
    goto ldv_35987;
  } else {

  }
  {
#line 580
  tmp = kmalloc(32UL, 208U);
#line 580
  e = (struct watcher_entry *)tmp;
  }
#line 581
  if ((unsigned long )e == (unsigned long )((struct watcher_entry *)0)) {
#line 582
    goto out_err;
  } else {

  }
  {
#line 583
  kref_get(& intf->refcount);
#line 584
  e->intf = intf;
#line 585
  e->intf_num = intf->intf_num;
#line 586
  list_add_tail(& e->link, & to_deliver);
  }
  ldv_35987: 
#line 577
  __mptr___0 = (struct list_head  const  *)intf->link.next;
#line 577
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_35990: ;
#line 577
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 579
    goto ldv_35989;
  } else {

  }
  {
#line 590
  list_add(& watcher->link, & smi_watchers);
#line 592
  ldv_mutex_unlock_101(& ipmi_interfaces_mutex);
#line 594
  __mptr___1 = (struct list_head  const  *)to_deliver.next;
#line 594
  e = (struct watcher_entry *)__mptr___1 + 0xfffffffffffffff0UL;
#line 594
  __mptr___2 = (struct list_head  const  *)e->link.next;
#line 594
  e2 = (struct watcher_entry *)__mptr___2 + 0xfffffffffffffff0UL;
  }
#line 594
  goto ldv_35999;
  ldv_35998: 
  {
#line 595
  list_del(& e->link);
#line 596
  (*(watcher->new_smi))(e->intf_num, (e->intf)->si_dev);
#line 597
  kref_put(& (e->intf)->refcount, & intf_free);
#line 598
  kfree((void const   *)e);
#line 594
  e = e2;
#line 594
  __mptr___3 = (struct list_head  const  *)e2->link.next;
#line 594
  e2 = (struct watcher_entry *)__mptr___3 + 0xfffffffffffffff0UL;
  }
  ldv_35999: ;
#line 594
  if ((unsigned long )(& e->link) != (unsigned long )(& to_deliver)) {
#line 596
    goto ldv_35998;
  } else {

  }
  {
#line 601
  ldv_mutex_unlock_102(& smi_watchers_mutex);
  }
#line 603
  return (0);
  out_err: 
  {
#line 606
  ldv_mutex_unlock_103(& ipmi_interfaces_mutex);
#line 607
  ldv_mutex_unlock_104(& smi_watchers_mutex);
#line 608
  __mptr___4 = (struct list_head  const  *)to_deliver.next;
#line 608
  e = (struct watcher_entry *)__mptr___4 + 0xfffffffffffffff0UL;
#line 608
  __mptr___5 = (struct list_head  const  *)e->link.next;
#line 608
  e2 = (struct watcher_entry *)__mptr___5 + 0xfffffffffffffff0UL;
  }
#line 608
  goto ldv_36008;
  ldv_36007: 
  {
#line 609
  list_del(& e->link);
#line 610
  kref_put(& (e->intf)->refcount, & intf_free);
#line 611
  kfree((void const   *)e);
#line 608
  e = e2;
#line 608
  __mptr___6 = (struct list_head  const  *)e2->link.next;
#line 608
  e2 = (struct watcher_entry *)__mptr___6 + 0xfffffffffffffff0UL;
  }
  ldv_36008: ;
#line 608
  if ((unsigned long )(& e->link) != (unsigned long )(& to_deliver)) {
#line 610
    goto ldv_36007;
  } else {

  }

#line 613
  return (-12);
}
}
#line 615 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_smi_watcher_register[26U]  = 
#line 615
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'm',      'i', 
        '_',      'w',      'a',      't', 
        'c',      'h',      'e',      'r', 
        '_',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '\000'};
#line 615
struct kernel_symbol  const  __ksymtab_ipmi_smi_watcher_register ;
#line 615 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_smi_watcher_register  =    {(unsigned long )(& ipmi_smi_watcher_register), (char const   *)(& __kstrtab_ipmi_smi_watcher_register)};
#line 617 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_smi_watcher_unregister(struct ipmi_smi_watcher *watcher ) 
{ 


  {
  {
#line 619
  ldv_mutex_lock_105(& smi_watchers_mutex);
#line 620
  list_del(& watcher->link);
#line 621
  ldv_mutex_unlock_106(& smi_watchers_mutex);
  }
#line 622
  return (0);
}
}
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_smi_watcher_unregister[28U]  = 
#line 624
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'm',      'i', 
        '_',      'w',      'a',      't', 
        'c',      'h',      'e',      'r', 
        '_',      'u',      'n',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '\000'};
#line 624
struct kernel_symbol  const  __ksymtab_ipmi_smi_watcher_unregister ;
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_smi_watcher_unregister  =    {(unsigned long )(& ipmi_smi_watcher_unregister), (char const   *)(& __kstrtab_ipmi_smi_watcher_unregister)};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void call_smi_watchers(int i , struct device *dev ) 
{ 
  struct ipmi_smi_watcher *w ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 634
  __mptr = (struct list_head  const  *)smi_watchers.next;
#line 634
  w = (struct ipmi_smi_watcher *)__mptr;
#line 634
  goto ldv_36037;
  ldv_36036: 
  {
#line 635
  tmp = ldv_try_module_get_107(w->owner);
  }
#line 635
  if ((int )tmp) {
    {
#line 636
    (*(w->new_smi))(i, dev);
#line 637
    ldv_module_put_108(w->owner);
    }
  } else {

  }
#line 634
  __mptr___0 = (struct list_head  const  *)w->link.next;
#line 634
  w = (struct ipmi_smi_watcher *)__mptr___0;
  ldv_36037: ;
#line 634
  if ((unsigned long )(& w->link) != (unsigned long )(& smi_watchers)) {
#line 636
    goto ldv_36036;
  } else {

  }

#line 641
  return;
}
}
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int ipmi_addr_equal(struct ipmi_addr *addr1 , struct ipmi_addr *addr2 ) 
{ 
  struct ipmi_system_interface_addr *smi_addr1 ;
  struct ipmi_system_interface_addr *smi_addr2 ;
  struct ipmi_ipmb_addr *ipmb_addr1 ;
  struct ipmi_ipmb_addr *ipmb_addr2 ;
  int tmp ;
  int tmp___0 ;
  struct ipmi_lan_addr *lan_addr1 ;
  struct ipmi_lan_addr *lan_addr2 ;
  int tmp___1 ;

  {
#line 645
  if (addr1->addr_type != addr2->addr_type) {
#line 646
    return (0);
  } else {

  }
#line 648
  if ((int )addr1->channel != (int )addr2->channel) {
#line 649
    return (0);
  } else {

  }
#line 651
  if (addr1->addr_type == 12) {
#line 652
    smi_addr1 = (struct ipmi_system_interface_addr *)addr1;
#line 654
    smi_addr2 = (struct ipmi_system_interface_addr *)addr2;
#line 656
    return ((int )smi_addr1->lun == (int )smi_addr2->lun);
  } else {

  }
  {
#line 659
  tmp = is_ipmb_addr(addr1);
  }
#line 659
  if (tmp != 0) {
#line 660
    ipmb_addr1 = (struct ipmi_ipmb_addr *)addr1;
#line 662
    ipmb_addr2 = (struct ipmi_ipmb_addr *)addr2;
#line 665
    return ((int )*((unsigned short *)ipmb_addr1 + 3UL) == (int )*((unsigned short *)ipmb_addr2 + 3UL));
  } else {
    {
#line 659
    tmp___0 = is_ipmb_bcast_addr(addr1);
    }
#line 659
    if (tmp___0 != 0) {
#line 660
      ipmb_addr1 = (struct ipmi_ipmb_addr *)addr1;
#line 662
      ipmb_addr2 = (struct ipmi_ipmb_addr *)addr2;
#line 665
      return ((int )*((unsigned short *)ipmb_addr1 + 3UL) == (int )*((unsigned short *)ipmb_addr2 + 3UL));
    } else {

    }
  }
  {
#line 669
  tmp___1 = is_lan_addr(addr1);
  }
#line 669
  if (tmp___1 != 0) {
#line 670
    lan_addr1 = (struct ipmi_lan_addr *)addr1;
#line 672
    lan_addr2 = (struct ipmi_lan_addr *)addr2;
#line 675
    return (((int )*((unsigned short *)lan_addr1 + 4UL) == (int )*((unsigned short *)lan_addr2 + 4UL) && (int )lan_addr1->session_handle == (int )lan_addr2->session_handle) && (int )lan_addr1->lun == (int )lan_addr2->lun);
  } else {

  }
#line 682
  return (1);
}
}
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_validate_addr(struct ipmi_addr *addr , int len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 687
  if ((unsigned int )len <= 7U) {
#line 688
    return (-22);
  } else {

  }
#line 690
  if (addr->addr_type == 12) {
#line 691
    if ((int )addr->channel != 15) {
#line 692
      return (-22);
    } else {

    }
#line 693
    return (0);
  } else {

  }
#line 696
  if ((unsigned int )((unsigned short )addr->channel) > 14U) {
#line 699
    return (-22);
  } else {

  }
  {
#line 701
  tmp = is_ipmb_addr(addr);
  }
#line 701
  if (tmp != 0) {
#line 701
    goto _L;
  } else {
    {
#line 701
    tmp___0 = is_ipmb_bcast_addr(addr);
    }
#line 701
    if (tmp___0 != 0) {
      _L: /* CIL Label */ 
#line 702
      if ((unsigned int )len <= 7U) {
#line 703
        return (-22);
      } else {

      }
#line 704
      return (0);
    } else {

    }
  }
  {
#line 707
  tmp___1 = is_lan_addr(addr);
  }
#line 707
  if (tmp___1 != 0) {
#line 708
    if ((unsigned int )len <= 11U) {
#line 709
      return (-22);
    } else {

    }
#line 710
    return (0);
  } else {

  }
#line 713
  return (-22);
}
}
#line 715 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_validate_addr[19U]  = 
#line 715
  {      'i',      'p',      'm',      'i', 
        '_',      'v',      'a',      'l', 
        'i',      'd',      'a',      't', 
        'e',      '_',      'a',      'd', 
        'd',      'r',      '\000'};
#line 715
struct kernel_symbol  const  __ksymtab_ipmi_validate_addr ;
#line 715 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_validate_addr  =    {(unsigned long )(& ipmi_validate_addr), (char const   *)(& __kstrtab_ipmi_validate_addr)};
#line 717 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
unsigned int ipmi_addr_length(int addr_type ) 
{ 


  {
#line 719
  if (addr_type == 12) {
#line 720
    return (8U);
  } else {

  }
#line 722
  if (addr_type == 1 || addr_type == 65) {
#line 724
    return (8U);
  } else {

  }
#line 726
  if (addr_type == 4) {
#line 727
    return (12U);
  } else {

  }
#line 729
  return (0U);
}
}
#line 731 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_addr_length[17U]  = 
#line 731
  {      'i',      'p',      'm',      'i', 
        '_',      'a',      'd',      'd', 
        'r',      '_',      'l',      'e', 
        'n',      'g',      't',      'h', 
        '\000'};
#line 731
struct kernel_symbol  const  __ksymtab_ipmi_addr_length ;
#line 731 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_addr_length  =    {(unsigned long )(& ipmi_addr_length), (char const   *)(& __kstrtab_ipmi_addr_length)};
#line 733 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void deliver_response(struct ipmi_recv_msg *msg ) 
{ 
  ipmi_smi_t intf ;
  ipmi_user_t user ;

  {
#line 735
  if ((unsigned long )msg->user == (unsigned long )((ipmi_user_t )0)) {
#line 736
    intf = (ipmi_smi_t )msg->user_msg_data;
#line 739
    if ((unsigned long )intf->null_user_handler != (unsigned long )((void (*)(ipmi_smi_t  ,
                                                                              struct ipmi_recv_msg * ))0)) {
      {
#line 740
      (*(intf->null_user_handler))(intf, msg);
#line 741
      atomic_inc((atomic_t *)(& intf->stats) + 2UL);
      }
    } else {
      {
#line 744
      atomic_inc((atomic_t *)(& intf->stats) + 3UL);
      }
    }
    {
#line 746
    ipmi_free_recv_msg(msg);
    }
  } else {
    {
#line 748
    user = msg->user;
#line 749
    (*((user->handler)->ipmi_recv_hndl))(msg, user->handler_data);
    }
  }
#line 751
  return;
}
}
#line 754 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void deliver_err_response(struct ipmi_recv_msg *msg , int err ) 
{ 


  {
  {
#line 756
  msg->recv_type = 1;
#line 757
  msg->msg_data[0] = (unsigned char )err;
#line 758
  msg->msg.netfn = (unsigned int )msg->msg.netfn | 1U;
#line 759
  msg->msg.data_len = 1U;
#line 760
  msg->msg.data = (unsigned char *)(& msg->msg_data);
#line 761
  deliver_response(msg);
  }
#line 762
  return;
}
}
#line 769 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int intf_next_seq(ipmi_smi_t intf , struct ipmi_recv_msg *recv_msg , unsigned long timeout ,
                         int retries , int broadcast , unsigned char *seq , long *seqid ) 
{ 
  int rv ;
  unsigned int i ;

  {
#line 777
  rv = 0;
#line 780
  i = (unsigned int )intf->curr_seq;
#line 780
  goto ldv_36093;
  ldv_36092: ;
#line 782
  if ((unsigned int )intf->seq_table[i].inuse == 0U) {
#line 783
    goto ldv_36091;
  } else {

  }
#line 781
  i = (i + 1U) & 63U;
  ldv_36093: ;
#line 780
  if (((i + 1U) & 63U) != (unsigned int )intf->curr_seq) {
#line 782
    goto ldv_36092;
  } else {

  }
  ldv_36091: ;
#line 786
  if ((unsigned int )intf->seq_table[i].inuse == 0U) {
    {
#line 787
    intf->seq_table[i].recv_msg = recv_msg;
#line 793
    intf->seq_table[i].timeout = 60000UL;
#line 794
    intf->seq_table[i].orig_timeout = timeout;
#line 795
    intf->seq_table[i].retries_left = (unsigned int )retries;
#line 796
    intf->seq_table[i].broadcast = (unsigned char )broadcast;
#line 797
    intf->seq_table[i].inuse = 1U;
#line 798
    intf->seq_table[i].seqid = (intf->seq_table[i].seqid + 1L) & 4194303L;
#line 799
    *seq = (unsigned char )i;
#line 800
    *seqid = intf->seq_table[i].seqid;
#line 801
    intf->curr_seq = (int )(i + 1U) & 63;
#line 802
    need_waiter(intf);
    }
  } else {
#line 804
    rv = -11;
  }
#line 807
  return (rv);
}
}
#line 817 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int intf_find_seq(ipmi_smi_t intf , unsigned char seq , short channel , unsigned char cmd ,
                         unsigned char netfn , struct ipmi_addr *addr , struct ipmi_recv_msg **recv_msg ) 
{ 
  int rv ;
  unsigned long flags ;
  struct ipmi_recv_msg *msg ;
  int tmp ;

  {
#line 825
  rv = -19;
#line 828
  if ((unsigned int )seq > 63U) {
#line 829
    return (-22);
  } else {

  }
  {
#line 831
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_109(& intf->seq_lock);
  }
#line 832
  if ((unsigned int )intf->seq_table[(int )seq].inuse != 0U) {
#line 833
    msg = intf->seq_table[(int )seq].recv_msg;
#line 835
    if (((int )msg->addr.channel == (int )channel && (int )msg->msg.cmd == (int )cmd) && (int )msg->msg.netfn == (int )netfn) {
      {
#line 835
      tmp = ipmi_addr_equal(addr, & msg->addr);
      }
#line 835
      if (tmp != 0) {
#line 838
        *recv_msg = msg;
#line 839
        intf->seq_table[(int )seq].inuse = 0U;
#line 840
        rv = 0;
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 843
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
  }
#line 845
  return (rv);
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int intf_start_seq_timer(ipmi_smi_t intf , long msgid ) 
{ 
  int rv ;
  unsigned long flags ;
  unsigned char seq ;
  unsigned long seqid ;
  struct seq_table *ent ;

  {
  {
#line 853
  rv = -19;
#line 859
  seq = (unsigned int )((unsigned char )(msgid >> 26)) & 63U;
#line 859
  seqid = (unsigned long )msgid & 4194303UL;
#line 861
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_111(& intf->seq_lock);
  }
#line 866
  if ((unsigned int )intf->seq_table[(int )seq].inuse != 0U && (unsigned long )intf->seq_table[(int )seq].seqid == seqid) {
#line 868
    ent = (struct seq_table *)(& intf->seq_table) + (unsigned long )seq;
#line 869
    ent->timeout = ent->orig_timeout;
#line 870
    rv = 0;
  } else {

  }
  {
#line 872
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
  }
#line 874
  return (rv);
}
}
#line 878 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int intf_err_seq(ipmi_smi_t intf , long msgid , unsigned int err ) 
{ 
  int rv ;
  unsigned long flags ;
  unsigned char seq ;
  unsigned long seqid ;
  struct ipmi_recv_msg *msg ;
  struct seq_table *ent ;

  {
  {
#line 882
  rv = -19;
#line 886
  msg = (struct ipmi_recv_msg *)0;
#line 889
  seq = (unsigned int )((unsigned char )(msgid >> 26)) & 63U;
#line 889
  seqid = (unsigned long )msgid & 4194303UL;
#line 891
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_113(& intf->seq_lock);
  }
#line 896
  if ((unsigned int )intf->seq_table[(int )seq].inuse != 0U && (unsigned long )intf->seq_table[(int )seq].seqid == seqid) {
#line 898
    ent = (struct seq_table *)(& intf->seq_table) + (unsigned long )seq;
#line 900
    ent->inuse = 0U;
#line 901
    msg = ent->recv_msg;
#line 902
    rv = 0;
  } else {

  }
  {
#line 904
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
  }
#line 906
  if ((unsigned long )msg != (unsigned long )((struct ipmi_recv_msg *)0)) {
    {
#line 907
    deliver_err_response(msg, (int )err);
    }
  } else {

  }
#line 909
  return (rv);
}
}
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_create_user(unsigned int if_num , struct ipmi_user_hndl *handler , void *handler_data ,
                     ipmi_user_t **user ) 
{ 
  unsigned long flags ;
  ipmi_user_t new_user ;
  int rv ;
  ipmi_smi_t intf ;
  void *tmp ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp___0 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 920
  rv = 0;
#line 931
  if ((unsigned long )handler == (unsigned long )((struct ipmi_user_hndl *)0)) {
#line 932
    return (-22);
  } else {

  }
#line 938
  if (initialized == 0) {
    {
#line 939
    rv = ipmi_init_msghandler();
    }
#line 940
    if (rv != 0) {
#line 941
      return (rv);
    } else {

    }
#line 947
    if (initialized == 0) {
#line 948
      return (-19);
    } else {

    }
  } else {

  }
  {
#line 951
  tmp = kmalloc(56UL, 208U);
#line 951
  new_user = (ipmi_user_t )tmp;
  }
#line 952
  if ((unsigned long )new_user == (unsigned long )((ipmi_user_t )0)) {
#line 953
    return (-12);
  } else {

  }
  {
#line 955
  ldv_mutex_lock_115(& ipmi_interfaces_mutex);
#line 956
  __ptr = ipmi_interfaces.next;
#line 956
  __var = (struct list_head *)0;
#line 956
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 956
  ________p1 = _________p1;
#line 956
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 956
  if (tmp___0 != 0 && ! __warned) {
    {
#line 956
    rcu_read_lock_held();
    }
  } else {

  }
#line 956
  __mptr = (struct list_head  const  *)________p1;
#line 956
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 956
  goto ldv_36160;
  ldv_36159: ;
#line 957
  if ((unsigned int )intf->intf_num == if_num) {
#line 958
    goto found;
  } else {

  }
  {
#line 956
  __ptr___0 = intf->link.next;
#line 956
  __var___0 = (struct list_head *)0;
#line 956
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 956
  ________p1___0 = _________p1___0;
#line 956
  tmp___1 = debug_lockdep_rcu_enabled();
  }
#line 956
  if (tmp___1 != 0 && ! __warned___0) {
    {
#line 956
    rcu_read_lock_held();
    }
  } else {

  }
#line 956
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 956
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_36160: ;
#line 956
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 958
    goto ldv_36159;
  } else {

  }
#line 961
  rv = -22;
#line 962
  goto out_kfree;
  found: 
  {
#line 966
  kref_get(& intf->refcount);
#line 968
  kref_init(& new_user->refcount);
#line 969
  new_user->handler = handler;
#line 970
  new_user->handler_data = handler_data;
#line 971
  new_user->intf = intf;
#line 972
  new_user->gets_events = 0;
#line 974
  tmp___2 = ldv_try_module_get_116((intf->handlers)->owner);
  }
#line 974
  if (tmp___2) {
#line 974
    tmp___3 = 0;
  } else {
#line 974
    tmp___3 = 1;
  }
#line 974
  if (tmp___3) {
#line 975
    rv = -19;
#line 976
    goto out_kref;
  } else {

  }
#line 979
  if ((unsigned long )(intf->handlers)->inc_usecount != (unsigned long )((int (*)(void * ))0)) {
    {
#line 980
    rv = (*((intf->handlers)->inc_usecount))(intf->send_info);
    }
#line 981
    if (rv != 0) {
      {
#line 982
      ldv_module_put_117((intf->handlers)->owner);
      }
#line 983
      goto out_kref;
    } else {

    }
  } else {

  }
  {
#line 991
  ldv_mutex_unlock_118(& ipmi_interfaces_mutex);
#line 993
  new_user->valid = 1;
#line 994
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_119(& intf->seq_lock);
#line 995
  list_add_rcu(& new_user->link, & intf->users);
#line 996
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
  }
#line 997
  if ((unsigned long )handler->ipmi_watchdog_pretimeout != (unsigned long )((void (*)(void * ))0)) {
    {
#line 999
    tmp___4 = atomic_add_return(1, & intf->event_waiters);
    }
#line 999
    if (tmp___4 == 1) {
      {
#line 1000
      need_waiter(intf);
      }
    } else {

    }
  } else {

  }
#line 1002
  *user = new_user;
#line 1003
  return (0);
  out_kref: 
  {
#line 1006
  kref_put(& intf->refcount, & intf_free);
  }
  out_kfree: 
  {
#line 1008
  ldv_mutex_unlock_121(& ipmi_interfaces_mutex);
#line 1009
  kfree((void const   *)new_user);
  }
#line 1010
  return (rv);
}
}
#line 1012 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_create_user[17U]  = 
#line 1012
  {      'i',      'p',      'm',      'i', 
        '_',      'c',      'r',      'e', 
        'a',      't',      'e',      '_', 
        'u',      's',      'e',      'r', 
        '\000'};
#line 1012
struct kernel_symbol  const  __ksymtab_ipmi_create_user ;
#line 1012 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_create_user  =    {(unsigned long )(& ipmi_create_user), (char const   *)(& __kstrtab_ipmi_create_user)};
#line 1014 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_get_smi_info(int if_num , struct ipmi_smi_info *data ) 
{ 
  int rv ;
  ipmi_smi_t intf ;
  struct ipmi_smi_handlers *handlers ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;

  {
  {
#line 1016
  rv = 0;
#line 1020
  ldv_mutex_lock_122(& ipmi_interfaces_mutex);
#line 1021
  __ptr = ipmi_interfaces.next;
#line 1021
  __var = (struct list_head *)0;
#line 1021
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 1021
  ________p1 = _________p1;
#line 1021
  tmp = debug_lockdep_rcu_enabled();
  }
#line 1021
  if (tmp != 0 && ! __warned) {
    {
#line 1021
    rcu_read_lock_held();
    }
  } else {

  }
#line 1021
  __mptr = (struct list_head  const  *)________p1;
#line 1021
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 1021
  goto ldv_36205;
  ldv_36204: ;
#line 1022
  if (intf->intf_num == if_num) {
#line 1023
    goto found;
  } else {

  }
  {
#line 1021
  __ptr___0 = intf->link.next;
#line 1021
  __var___0 = (struct list_head *)0;
#line 1021
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 1021
  ________p1___0 = _________p1___0;
#line 1021
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 1021
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 1021
    rcu_read_lock_held();
    }
  } else {

  }
#line 1021
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 1021
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_36205: ;
#line 1021
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 1023
    goto ldv_36204;
  } else {

  }
  {
#line 1026
  rv = -22;
#line 1027
  ldv_mutex_unlock_123(& ipmi_interfaces_mutex);
  }
#line 1028
  return (rv);
  found: 
#line 1031
  handlers = intf->handlers;
#line 1032
  rv = -38;
#line 1033
  if ((unsigned long )handlers->get_smi_info != (unsigned long )((int (*)(void * ,
                                                                          struct ipmi_smi_info * ))0)) {
    {
#line 1034
    rv = (*(handlers->get_smi_info))(intf->send_info, data);
    }
  } else {

  }
  {
#line 1035
  ldv_mutex_unlock_124(& ipmi_interfaces_mutex);
  }
#line 1037
  return (rv);
}
}
#line 1039 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_get_smi_info[18U]  = 
#line 1039
  {      'i',      'p',      'm',      'i', 
        '_',      'g',      'e',      't', 
        '_',      's',      'm',      'i', 
        '_',      'i',      'n',      'f', 
        'o',      '\000'};
#line 1039
struct kernel_symbol  const  __ksymtab_ipmi_get_smi_info ;
#line 1039 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_get_smi_info  =    {(unsigned long )(& ipmi_get_smi_info), (char const   *)(& __kstrtab_ipmi_get_smi_info)};
#line 1041 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void free_user(struct kref *ref ) 
{ 
  ipmi_user_t user ;
  struct kref  const  *__mptr ;

  {
  {
#line 1043
  __mptr = (struct kref  const  *)ref;
#line 1043
  user = (struct ipmi_user *)__mptr + 0xffffffffffffffecUL;
#line 1044
  kfree((void const   *)user);
  }
#line 1045
  return;
}
}
#line 1047 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_destroy_user(ipmi_user_t user ) 
{ 
  ipmi_smi_t intf ;
  int i ;
  unsigned long flags ;
  struct cmd_rcvr *rcvr ;
  struct cmd_rcvr *rcvrs ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;

  {
#line 1049
  intf = user->intf;
#line 1053
  rcvrs = (struct cmd_rcvr *)0;
#line 1055
  user->valid = 0;
#line 1057
  if ((unsigned long )(user->handler)->ipmi_watchdog_pretimeout != (unsigned long )((void (*)(void * ))0)) {
    {
#line 1058
    atomic_dec(& intf->event_waiters);
    }
  } else {

  }
#line 1060
  if ((int )user->gets_events) {
    {
#line 1061
    atomic_dec(& intf->event_waiters);
    }
  } else {

  }
  {
#line 1064
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_125(& intf->seq_lock);
#line 1065
  list_del_rcu(& user->link);
#line 1067
  i = 0;
  }
#line 1067
  goto ldv_36230;
  ldv_36229: ;
#line 1068
  if ((unsigned int )intf->seq_table[i].inuse != 0U && (unsigned long )(intf->seq_table[i].recv_msg)->user == (unsigned long )user) {
    {
#line 1070
    intf->seq_table[i].inuse = 0U;
#line 1071
    ipmi_free_recv_msg(intf->seq_table[i].recv_msg);
    }
  } else {

  }
#line 1067
  i = i + 1;
  ldv_36230: ;
#line 1067
  if (i <= 63) {
#line 1069
    goto ldv_36229;
  } else {

  }
  {
#line 1074
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
#line 1082
  ldv_mutex_lock_127(& intf->cmd_rcvrs_mutex);
#line 1083
  __ptr = intf->cmd_rcvrs.next;
#line 1083
  __var = (struct list_head *)0;
#line 1083
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 1083
  ________p1 = _________p1;
#line 1083
  tmp = debug_lockdep_rcu_enabled();
  }
#line 1083
  if (tmp != 0 && ! __warned) {
    {
#line 1083
    rcu_read_lock_held();
    }
  } else {

  }
#line 1083
  __mptr = (struct list_head  const  *)________p1;
#line 1083
  rcvr = (struct cmd_rcvr *)__mptr;
#line 1083
  goto ldv_36255;
  ldv_36254: ;
#line 1084
  if ((unsigned long )rcvr->user == (unsigned long )user) {
    {
#line 1085
    list_del_rcu(& rcvr->link);
#line 1086
    rcvr->next = rcvrs;
#line 1087
    rcvrs = rcvr;
    }
  } else {

  }
  {
#line 1083
  __ptr___0 = rcvr->link.next;
#line 1083
  __var___0 = (struct list_head *)0;
#line 1083
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 1083
  ________p1___0 = _________p1___0;
#line 1083
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 1083
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 1083
    rcu_read_lock_held();
    }
  } else {

  }
#line 1083
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 1083
  rcvr = (struct cmd_rcvr *)__mptr___0;
  ldv_36255: ;
#line 1083
  if ((unsigned long )(& rcvr->link) != (unsigned long )(& intf->cmd_rcvrs)) {
#line 1085
    goto ldv_36254;
  } else {

  }
  {
#line 1090
  ldv_mutex_unlock_128(& intf->cmd_rcvrs_mutex);
#line 1091
  synchronize_rcu();
  }
#line 1092
  goto ldv_36258;
  ldv_36257: 
  {
#line 1093
  rcvr = rcvrs;
#line 1094
  rcvrs = rcvr->next;
#line 1095
  kfree((void const   *)rcvr);
  }
  ldv_36258: ;
#line 1092
  if ((unsigned long )rcvrs != (unsigned long )((struct cmd_rcvr *)0)) {
#line 1094
    goto ldv_36257;
  } else {

  }
  {
#line 1098
  ldv_mutex_lock_129(& ipmi_interfaces_mutex);
  }
#line 1099
  if ((unsigned long )intf->handlers != (unsigned long )((struct ipmi_smi_handlers *)0)) {
    {
#line 1100
    ldv_module_put_130((intf->handlers)->owner);
    }
#line 1101
    if ((unsigned long )(intf->handlers)->dec_usecount != (unsigned long )((void (*)(void * ))0)) {
      {
#line 1102
      (*((intf->handlers)->dec_usecount))(intf->send_info);
      }
    } else {

    }
  } else {

  }
  {
#line 1104
  ldv_mutex_unlock_131(& ipmi_interfaces_mutex);
#line 1106
  kref_put(& intf->refcount, & intf_free);
#line 1108
  kref_put(& user->refcount, & free_user);
  }
#line 1110
  return (0);
}
}
#line 1112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_destroy_user[18U]  = 
#line 1112
  {      'i',      'p',      'm',      'i', 
        '_',      'd',      'e',      's', 
        't',      'r',      'o',      'y', 
        '_',      'u',      's',      'e', 
        'r',      '\000'};
#line 1112
struct kernel_symbol  const  __ksymtab_ipmi_destroy_user ;
#line 1112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_destroy_user  =    {(unsigned long )(& ipmi_destroy_user), (char const   *)(& __kstrtab_ipmi_destroy_user)};
#line 1114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
void ipmi_get_version(ipmi_user_t user , unsigned char *major , unsigned char *minor ) 
{ 


  {
#line 1118
  *major = (user->intf)->ipmi_version_major;
#line 1119
  *minor = (user->intf)->ipmi_version_minor;
#line 1120
  return;
}
}
#line 1121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_get_version[17U]  = 
#line 1121
  {      'i',      'p',      'm',      'i', 
        '_',      'g',      'e',      't', 
        '_',      'v',      'e',      'r', 
        's',      'i',      'o',      'n', 
        '\000'};
#line 1121
struct kernel_symbol  const  __ksymtab_ipmi_get_version ;
#line 1121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_get_version  =    {(unsigned long )(& ipmi_get_version), (char const   *)(& __kstrtab_ipmi_get_version)};
#line 1123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_set_my_address(ipmi_user_t user , unsigned int channel , unsigned char address ) 
{ 


  {
#line 1127
  if (channel > 15U) {
#line 1128
    return (-22);
  } else {

  }
#line 1129
  (user->intf)->channels[channel].address = address;
#line 1130
  return (0);
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_set_my_address[20U]  = 
#line 1132
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'e',      't', 
        '_',      'm',      'y',      '_', 
        'a',      'd',      'd',      'r', 
        'e',      's',      's',      '\000'};
#line 1132
struct kernel_symbol  const  __ksymtab_ipmi_set_my_address ;
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_set_my_address  =    {(unsigned long )(& ipmi_set_my_address), (char const   *)(& __kstrtab_ipmi_set_my_address)};
#line 1134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_get_my_address(ipmi_user_t user , unsigned int channel , unsigned char *address ) 
{ 


  {
#line 1138
  if (channel > 15U) {
#line 1139
    return (-22);
  } else {

  }
#line 1140
  *address = (user->intf)->channels[channel].address;
#line 1141
  return (0);
}
}
#line 1143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_get_my_address[20U]  = 
#line 1143
  {      'i',      'p',      'm',      'i', 
        '_',      'g',      'e',      't', 
        '_',      'm',      'y',      '_', 
        'a',      'd',      'd',      'r', 
        'e',      's',      's',      '\000'};
#line 1143
struct kernel_symbol  const  __ksymtab_ipmi_get_my_address ;
#line 1143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_get_my_address  =    {(unsigned long )(& ipmi_get_my_address), (char const   *)(& __kstrtab_ipmi_get_my_address)};
#line 1145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_set_my_LUN(ipmi_user_t user , unsigned int channel , unsigned char LUN ) 
{ 


  {
#line 1149
  if (channel > 15U) {
#line 1150
    return (-22);
  } else {

  }
#line 1151
  (user->intf)->channels[channel].lun = (unsigned int )LUN & 3U;
#line 1152
  return (0);
}
}
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_set_my_LUN[16U]  = 
#line 1154
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'e',      't', 
        '_',      'm',      'y',      '_', 
        'L',      'U',      'N',      '\000'};
#line 1154
struct kernel_symbol  const  __ksymtab_ipmi_set_my_LUN ;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_set_my_LUN  =    {(unsigned long )(& ipmi_set_my_LUN), (char const   *)(& __kstrtab_ipmi_set_my_LUN)};
#line 1156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_get_my_LUN(ipmi_user_t user , unsigned int channel , unsigned char *address ) 
{ 


  {
#line 1160
  if (channel > 15U) {
#line 1161
    return (-22);
  } else {

  }
#line 1162
  *address = (user->intf)->channels[channel].lun;
#line 1163
  return (0);
}
}
#line 1165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_get_my_LUN[16U]  = 
#line 1165
  {      'i',      'p',      'm',      'i', 
        '_',      'g',      'e',      't', 
        '_',      'm',      'y',      '_', 
        'L',      'U',      'N',      '\000'};
#line 1165
struct kernel_symbol  const  __ksymtab_ipmi_get_my_LUN ;
#line 1165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_get_my_LUN  =    {(unsigned long )(& ipmi_get_my_LUN), (char const   *)(& __kstrtab_ipmi_get_my_LUN)};
#line 1167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_get_maintenance_mode(ipmi_user_t user ) 
{ 
  int mode ;
  unsigned long flags ;

  {
  {
#line 1172
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_132(& (user->intf)->maintenance_mode_lock);
#line 1173
  mode = (user->intf)->maintenance_mode;
#line 1174
  ldv_spin_unlock_irqrestore_133(& (user->intf)->maintenance_mode_lock, flags);
  }
#line 1176
  return (mode);
}
}
#line 1178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_get_maintenance_mode[26U]  = 
#line 1178
  {      'i',      'p',      'm',      'i', 
        '_',      'g',      'e',      't', 
        '_',      'm',      'a',      'i', 
        'n',      't',      'e',      'n', 
        'a',      'n',      'c',      'e', 
        '_',      'm',      'o',      'd', 
        'e',      '\000'};
#line 1178
struct kernel_symbol  const  __ksymtab_ipmi_get_maintenance_mode ;
#line 1178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_get_maintenance_mode  =    {(unsigned long )(& ipmi_get_maintenance_mode), (char const   *)(& __kstrtab_ipmi_get_maintenance_mode)};
#line 1180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void maintenance_mode_update(ipmi_smi_t intf ) 
{ 


  {
#line 1182
  if ((unsigned long )(intf->handlers)->set_maintenance_mode != (unsigned long )((void (*)(void * ,
                                                                                           bool  ))0)) {
    {
#line 1183
    (*((intf->handlers)->set_maintenance_mode))(intf->send_info, (int )intf->maintenance_mode_enable);
    }
  } else {

  }
#line 1185
  return;
}
}
#line 1187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_set_maintenance_mode(ipmi_user_t user , int mode ) 
{ 
  int rv ;
  unsigned long flags ;
  ipmi_smi_t intf ;

  {
  {
#line 1189
  rv = 0;
#line 1191
  intf = user->intf;
#line 1193
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(& intf->maintenance_mode_lock);
  }
#line 1194
  if (intf->maintenance_mode != mode) {
    {
#line 1196
    if (mode == 0) {
#line 1196
      goto case_0;
    } else {

    }
#line 1201
    if (mode == 1) {
#line 1201
      goto case_1;
    } else {

    }
#line 1205
    if (mode == 2) {
#line 1205
      goto case_2;
    } else {

    }
#line 1209
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1197
    intf->maintenance_mode_enable = intf->auto_maintenance_timeout > 0;
#line 1199
    goto ldv_36360;
    case_1: /* CIL Label */ 
#line 1202
    intf->maintenance_mode_enable = 0;
#line 1203
    goto ldv_36360;
    case_2: /* CIL Label */ 
#line 1206
    intf->maintenance_mode_enable = 1;
#line 1207
    goto ldv_36360;
    switch_default: /* CIL Label */ 
#line 1210
    rv = -22;
#line 1211
    goto out_unlock;
    switch_break: /* CIL Label */ ;
    }
    ldv_36360: 
    {
#line 1213
    intf->maintenance_mode = mode;
#line 1215
    maintenance_mode_update(intf);
    }
  } else {

  }
  out_unlock: 
  {
#line 1218
  ldv_spin_unlock_irqrestore_133(& intf->maintenance_mode_lock, flags);
  }
#line 1220
  return (rv);
}
}
#line 1222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_set_maintenance_mode[26U]  = 
#line 1222
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'e',      't', 
        '_',      'm',      'a',      'i', 
        'n',      't',      'e',      'n', 
        'a',      'n',      'c',      'e', 
        '_',      'm',      'o',      'd', 
        'e',      '\000'};
#line 1222
struct kernel_symbol  const  __ksymtab_ipmi_set_maintenance_mode ;
#line 1222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_set_maintenance_mode  =    {(unsigned long )(& ipmi_set_maintenance_mode), (char const   *)(& __kstrtab_ipmi_set_maintenance_mode)};
#line 1224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_set_gets_events(ipmi_user_t user , bool val ) 
{ 
  unsigned long flags ;
  ipmi_smi_t intf ;
  struct ipmi_recv_msg *msg ;
  struct ipmi_recv_msg *msg2 ;
  struct list_head msgs ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  int tmp___0 ;

  {
  {
#line 1227
  intf = user->intf;
#line 1231
  INIT_LIST_HEAD(& msgs);
#line 1233
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(& intf->events_lock);
  }
#line 1234
  if ((int )user->gets_events == (int )val) {
#line 1235
    goto out;
  } else {

  }
#line 1237
  user->gets_events = val;
#line 1239
  if ((int )val) {
    {
#line 1240
    tmp = atomic_add_return(1, & intf->event_waiters);
    }
#line 1240
    if (tmp == 1) {
      {
#line 1241
      need_waiter(intf);
      }
    } else {

    }
  } else {
    {
#line 1243
    atomic_dec(& intf->event_waiters);
    }
  }
#line 1246
  if ((int )((signed char )intf->delivering_events) != 0) {
#line 1251
    goto out;
  } else {

  }
#line 1254
  goto ldv_36402;
  ldv_36401: 
#line 1255
  __mptr = (struct list_head  const  *)intf->waiting_events.next;
#line 1255
  msg = (struct ipmi_recv_msg *)__mptr;
#line 1255
  __mptr___0 = (struct list_head  const  *)msg->link.next;
#line 1255
  msg2 = (struct ipmi_recv_msg *)__mptr___0;
#line 1255
  goto ldv_36390;
  ldv_36389: 
  {
#line 1256
  list_move_tail(& msg->link, & msgs);
#line 1255
  msg = msg2;
#line 1255
  __mptr___1 = (struct list_head  const  *)msg2->link.next;
#line 1255
  msg2 = (struct ipmi_recv_msg *)__mptr___1;
  }
  ldv_36390: ;
#line 1255
  if ((unsigned long )(& msg->link) != (unsigned long )(& intf->waiting_events)) {
#line 1257
    goto ldv_36389;
  } else {

  }
#line 1257
  intf->waiting_events_count = 0U;
#line 1258
  if ((int )((signed char )intf->event_msg_printed) != 0) {
    {
#line 1259
    printk("\fIPMI message handler: Event queue no longer full\n");
#line 1261
    intf->event_msg_printed = 0;
    }
  } else {

  }
  {
#line 1264
  intf->delivering_events = 1;
#line 1265
  ldv_spin_unlock_irqrestore_137(& intf->events_lock, flags);
#line 1267
  __mptr___2 = (struct list_head  const  *)msgs.next;
#line 1267
  msg = (struct ipmi_recv_msg *)__mptr___2;
#line 1267
  __mptr___3 = (struct list_head  const  *)msg->link.next;
#line 1267
  msg2 = (struct ipmi_recv_msg *)__mptr___3;
  }
#line 1267
  goto ldv_36399;
  ldv_36398: 
  {
#line 1268
  msg->user = user;
#line 1269
  kref_get(& user->refcount);
#line 1270
  deliver_response(msg);
#line 1267
  msg = msg2;
#line 1267
  __mptr___4 = (struct list_head  const  *)msg2->link.next;
#line 1267
  msg2 = (struct ipmi_recv_msg *)__mptr___4;
  }
  ldv_36399: ;
#line 1267
  if ((unsigned long )(& msg->link) != (unsigned long )(& msgs)) {
#line 1269
    goto ldv_36398;
  } else {

  }
  {
#line 1273
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_138(& intf->events_lock);
#line 1274
  intf->delivering_events = 0;
  }
  ldv_36402: ;
#line 1254
  if ((int )user->gets_events) {
    {
#line 1254
    tmp___0 = list_empty((struct list_head  const  *)(& intf->waiting_events));
    }
#line 1254
    if (tmp___0 == 0) {
#line 1256
      goto ldv_36401;
    } else {
#line 1259
      goto ldv_36403;
    }
  } else {

  }
  ldv_36403: ;
  out: 
  {
#line 1278
  ldv_spin_unlock_irqrestore_137(& intf->events_lock, flags);
  }
#line 1280
  return (0);
}
}
#line 1282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_set_gets_events[21U]  = 
#line 1282
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'e',      't', 
        '_',      'g',      'e',      't', 
        's',      '_',      'e',      'v', 
        'e',      'n',      't',      's', 
        '\000'};
#line 1282
struct kernel_symbol  const  __ksymtab_ipmi_set_gets_events ;
#line 1282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_set_gets_events  =    {(unsigned long )(& ipmi_set_gets_events), (char const   *)(& __kstrtab_ipmi_set_gets_events)};
#line 1284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct cmd_rcvr *find_cmd_rcvr(ipmi_smi_t intf , unsigned char netfn , unsigned char cmd ,
                                      unsigned char chan ) 
{ 
  struct cmd_rcvr *rcvr ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;

  {
  {
#line 1291
  __ptr = intf->cmd_rcvrs.next;
#line 1291
  __var = (struct list_head *)0;
#line 1291
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 1291
  ________p1 = _________p1;
#line 1291
  tmp = debug_lockdep_rcu_enabled();
  }
#line 1291
  if (tmp != 0 && ! __warned) {
    {
#line 1291
    rcu_read_lock_held();
    }
  } else {

  }
#line 1291
  __mptr = (struct list_head  const  *)________p1;
#line 1291
  rcvr = (struct cmd_rcvr *)__mptr;
#line 1291
  goto ldv_36442;
  ldv_36441: ;
#line 1292
  if (((int )rcvr->netfn == (int )netfn && (int )rcvr->cmd == (int )cmd) && (rcvr->chans & (unsigned int )(1 << (int )chan)) != 0U) {
#line 1294
    return (rcvr);
  } else {

  }
  {
#line 1291
  __ptr___0 = rcvr->link.next;
#line 1291
  __var___0 = (struct list_head *)0;
#line 1291
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 1291
  ________p1___0 = _________p1___0;
#line 1291
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 1291
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 1291
    rcu_read_lock_held();
    }
  } else {

  }
#line 1291
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 1291
  rcvr = (struct cmd_rcvr *)__mptr___0;
  ldv_36442: ;
#line 1291
  if ((unsigned long )(& rcvr->link) != (unsigned long )(& intf->cmd_rcvrs)) {
#line 1293
    goto ldv_36441;
  } else {

  }

#line 1296
  return ((struct cmd_rcvr *)0);
}
}
#line 1299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int is_cmd_rcvr_exclusive(ipmi_smi_t intf , unsigned char netfn , unsigned char cmd ,
                                 unsigned int chans ) 
{ 
  struct cmd_rcvr *rcvr ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;

  {
  {
#line 1306
  __ptr = intf->cmd_rcvrs.next;
#line 1306
  __var = (struct list_head *)0;
#line 1306
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 1306
  ________p1 = _________p1;
#line 1306
  tmp = debug_lockdep_rcu_enabled();
  }
#line 1306
  if (tmp != 0 && ! __warned) {
    {
#line 1306
    rcu_read_lock_held();
    }
  } else {

  }
#line 1306
  __mptr = (struct list_head  const  *)________p1;
#line 1306
  rcvr = (struct cmd_rcvr *)__mptr;
#line 1306
  goto ldv_36474;
  ldv_36473: ;
#line 1307
  if (((int )rcvr->netfn == (int )netfn && (int )rcvr->cmd == (int )cmd) && (rcvr->chans & chans) != 0U) {
#line 1309
    return (0);
  } else {

  }
  {
#line 1306
  __ptr___0 = rcvr->link.next;
#line 1306
  __var___0 = (struct list_head *)0;
#line 1306
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 1306
  ________p1___0 = _________p1___0;
#line 1306
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 1306
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 1306
    rcu_read_lock_held();
    }
  } else {

  }
#line 1306
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 1306
  rcvr = (struct cmd_rcvr *)__mptr___0;
  ldv_36474: ;
#line 1306
  if ((unsigned long )(& rcvr->link) != (unsigned long )(& intf->cmd_rcvrs)) {
#line 1308
    goto ldv_36473;
  } else {

  }

#line 1311
  return (1);
}
}
#line 1314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_register_for_cmd(ipmi_user_t user , unsigned char netfn , unsigned char cmd ,
                          unsigned int chans ) 
{ 
  ipmi_smi_t intf ;
  struct cmd_rcvr *rcvr ;
  int rv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1319
  intf = user->intf;
#line 1321
  rv = 0;
#line 1324
  tmp = kmalloc(40UL, 208U);
#line 1324
  rcvr = (struct cmd_rcvr *)tmp;
  }
#line 1325
  if ((unsigned long )rcvr == (unsigned long )((struct cmd_rcvr *)0)) {
#line 1326
    return (-12);
  } else {

  }
  {
#line 1327
  rcvr->cmd = cmd;
#line 1328
  rcvr->netfn = netfn;
#line 1329
  rcvr->chans = chans;
#line 1330
  rcvr->user = user;
#line 1332
  ldv_mutex_lock_140(& intf->cmd_rcvrs_mutex);
#line 1334
  tmp___0 = is_cmd_rcvr_exclusive(intf, (int )netfn, (int )cmd, chans);
  }
#line 1334
  if (tmp___0 == 0) {
#line 1335
    rv = -16;
#line 1336
    goto out_unlock;
  } else {

  }
  {
#line 1339
  tmp___1 = atomic_add_return(1, & intf->event_waiters);
  }
#line 1339
  if (tmp___1 == 1) {
    {
#line 1340
    need_waiter(intf);
    }
  } else {

  }
  {
#line 1342
  list_add_rcu(& rcvr->link, & intf->cmd_rcvrs);
  }
  out_unlock: 
  {
#line 1345
  ldv_mutex_unlock_141(& intf->cmd_rcvrs_mutex);
  }
#line 1346
  if (rv != 0) {
    {
#line 1347
    kfree((void const   *)rcvr);
    }
  } else {

  }
#line 1349
  return (rv);
}
}
#line 1351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_register_for_cmd[22U]  = 
#line 1351
  {      'i',      'p',      'm',      'i', 
        '_',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '_',      'f',      'o', 
        'r',      '_',      'c',      'm', 
        'd',      '\000'};
#line 1351
struct kernel_symbol  const  __ksymtab_ipmi_register_for_cmd ;
#line 1351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_register_for_cmd  =    {(unsigned long )(& ipmi_register_for_cmd), (char const   *)(& __kstrtab_ipmi_register_for_cmd)};
#line 1353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_unregister_for_cmd(ipmi_user_t user , unsigned char netfn , unsigned char cmd ,
                            unsigned int chans ) 
{ 
  ipmi_smi_t intf ;
  struct cmd_rcvr *rcvr ;
  struct cmd_rcvr *rcvrs ;
  int i ;
  int rv ;

  {
  {
#line 1358
  intf = user->intf;
#line 1360
  rcvrs = (struct cmd_rcvr *)0;
#line 1361
  rv = -2;
#line 1363
  ldv_mutex_lock_142(& intf->cmd_rcvrs_mutex);
#line 1364
  i = 0;
  }
#line 1364
  goto ldv_36509;
  ldv_36508: ;
#line 1365
  if (((unsigned int )(1 << i) & chans) == 0U) {
#line 1366
    goto ldv_36507;
  } else {

  }
  {
#line 1367
  rcvr = find_cmd_rcvr(intf, (int )netfn, (int )cmd, (int )((unsigned char )i));
  }
#line 1368
  if ((unsigned long )rcvr == (unsigned long )((struct cmd_rcvr *)0)) {
#line 1369
    goto ldv_36507;
  } else {

  }
#line 1370
  if ((unsigned long )rcvr->user == (unsigned long )user) {
#line 1371
    rv = 0;
#line 1372
    rcvr->chans = rcvr->chans & ~ chans;
#line 1373
    if (rcvr->chans == 0U) {
      {
#line 1374
      list_del_rcu(& rcvr->link);
#line 1375
      rcvr->next = rcvrs;
#line 1376
      rcvrs = rcvr;
      }
    } else {

    }
  } else {

  }
  ldv_36507: 
#line 1364
  i = i + 1;
  ldv_36509: ;
#line 1364
  if (i <= 15) {
#line 1366
    goto ldv_36508;
  } else {

  }
  {
#line 1380
  ldv_mutex_unlock_143(& intf->cmd_rcvrs_mutex);
#line 1381
  synchronize_rcu();
  }
#line 1382
  goto ldv_36512;
  ldv_36511: 
  {
#line 1383
  atomic_dec(& intf->event_waiters);
#line 1384
  rcvr = rcvrs;
#line 1385
  rcvrs = rcvr->next;
#line 1386
  kfree((void const   *)rcvr);
  }
  ldv_36512: ;
#line 1382
  if ((unsigned long )rcvrs != (unsigned long )((struct cmd_rcvr *)0)) {
#line 1384
    goto ldv_36511;
  } else {

  }

#line 1388
  return (rv);
}
}
#line 1390 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_unregister_for_cmd[24U]  = 
#line 1390
  {      'i',      'p',      'm',      'i', 
        '_',      'u',      'n',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '_', 
        'f',      'o',      'r',      '_', 
        'c',      'm',      'd',      '\000'};
#line 1390
struct kernel_symbol  const  __ksymtab_ipmi_unregister_for_cmd ;
#line 1390 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_unregister_for_cmd  =    {(unsigned long )(& ipmi_unregister_for_cmd), (char const   *)(& __kstrtab_ipmi_unregister_for_cmd)};
#line 1393 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static unsigned char ipmb_checksum(unsigned char *data , int size ) 
{ 
  unsigned char csum ;

  {
#line 1395
  csum = 0U;
#line 1397
  goto ldv_36530;
  ldv_36529: 
#line 1398
  csum = (int )csum + (int )*data;
#line 1397
  size = size - 1;
#line 1397
  data = data + 1;
  ldv_36530: ;
#line 1397
  if (size > 0) {
#line 1399
    goto ldv_36529;
  } else {

  }

#line 1400
  return (- ((int )csum));
}
}
#line 1403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
__inline static void format_ipmb_msg(struct ipmi_smi_msg *smi_msg , struct kernel_ipmi_msg *msg ,
                                     struct ipmi_ipmb_addr *ipmb_addr , long msgid ,
                                     unsigned char ipmb_seq , int broadcast , unsigned char source_address ,
                                     unsigned char source_lun ) 
{ 
  int i ;

  {
#line 1412
  i = broadcast;
#line 1415
  smi_msg->data[0] = 24U;
#line 1416
  smi_msg->data[1] = 52U;
#line 1417
  smi_msg->data[2] = (unsigned char )ipmb_addr->channel;
#line 1418
  if (broadcast != 0) {
#line 1419
    smi_msg->data[3] = 0U;
  } else {

  }
  {
#line 1420
  smi_msg->data[i + 3] = ipmb_addr->slave_addr;
#line 1421
  smi_msg->data[i + 4] = (unsigned char )((int )((signed char )((int )msg->netfn << 2)) | ((int )((signed char )ipmb_addr->lun) & 3));
#line 1422
  smi_msg->data[i + 5] = ipmb_checksum((unsigned char *)(& smi_msg->data) + ((unsigned long )i + 3UL),
                                       2);
#line 1423
  smi_msg->data[i + 6] = source_address;
#line 1424
  smi_msg->data[i + 7] = (unsigned char )((int )((signed char )((int )ipmb_seq << 2)) | (int )((signed char )source_lun));
#line 1425
  smi_msg->data[i + 8] = msg->cmd;
  }
#line 1428
  if ((unsigned int )msg->data_len != 0U) {
    {
#line 1429
    __memcpy((void *)(& smi_msg->data) + ((unsigned long )i + 9UL), (void const   *)msg->data,
             (size_t )msg->data_len);
    }
  } else {

  }
  {
#line 1431
  smi_msg->data_size = (int )msg->data_len + 9;
#line 1434
  smi_msg->data[i + smi_msg->data_size] = ipmb_checksum((unsigned char *)(& smi_msg->data) + ((unsigned long )i + 6UL),
                                                        smi_msg->data_size + -6);
#line 1442
  smi_msg->data_size = smi_msg->data_size + (i + 1);
#line 1444
  smi_msg->msgid = msgid;
  }
#line 1445
  return;
}
}
#line 1447 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
__inline static void format_lan_msg(struct ipmi_smi_msg *smi_msg , struct kernel_ipmi_msg *msg ,
                                    struct ipmi_lan_addr *lan_addr , long msgid ,
                                    unsigned char ipmb_seq , unsigned char source_lun ) 
{ 


  {
  {
#line 1455
  smi_msg->data[0] = 24U;
#line 1456
  smi_msg->data[1] = 52U;
#line 1457
  smi_msg->data[2] = (unsigned char )lan_addr->channel;
#line 1458
  smi_msg->data[3] = lan_addr->session_handle;
#line 1459
  smi_msg->data[4] = lan_addr->remote_SWID;
#line 1460
  smi_msg->data[5] = (unsigned char )((int )((signed char )((int )msg->netfn << 2)) | ((int )((signed char )lan_addr->lun) & 3));
#line 1461
  smi_msg->data[6] = ipmb_checksum((unsigned char *)(& smi_msg->data) + 4UL, 2);
#line 1462
  smi_msg->data[7] = lan_addr->local_SWID;
#line 1463
  smi_msg->data[8] = (unsigned char )((int )((signed char )((int )ipmb_seq << 2)) | (int )((signed char )source_lun));
#line 1464
  smi_msg->data[9] = msg->cmd;
  }
#line 1467
  if ((unsigned int )msg->data_len != 0U) {
    {
#line 1468
    __memcpy((void *)(& smi_msg->data) + 10U, (void const   *)msg->data, (size_t )msg->data_len);
    }
  } else {

  }
  {
#line 1470
  smi_msg->data_size = (int )msg->data_len + 10;
#line 1473
  smi_msg->data[smi_msg->data_size] = ipmb_checksum((unsigned char *)(& smi_msg->data) + 7UL,
                                                    smi_msg->data_size + -7);
#line 1481
  smi_msg->data_size = smi_msg->data_size + 1;
#line 1483
  smi_msg->msgid = msgid;
  }
#line 1484
  return;
}
}
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct ipmi_smi_msg *smi_add_send_msg(ipmi_smi_t intf , struct ipmi_smi_msg *smi_msg ,
                                             int priority ) 
{ 


  {
#line 1490
  if ((unsigned long )intf->curr_msg != (unsigned long )((struct ipmi_smi_msg *)0)) {
#line 1491
    if (priority > 0) {
      {
#line 1492
      list_add_tail(& smi_msg->link, & intf->hp_xmit_msgs);
      }
    } else {
      {
#line 1494
      list_add_tail(& smi_msg->link, & intf->xmit_msgs);
      }
    }
#line 1495
    smi_msg = (struct ipmi_smi_msg *)0;
  } else {
#line 1497
    intf->curr_msg = smi_msg;
  }
#line 1500
  return (smi_msg);
}
}
#line 1504 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void smi_send(ipmi_smi_t intf , struct ipmi_smi_handlers *handlers , struct ipmi_smi_msg *smi_msg ,
                     int priority ) 
{ 
  int run_to_completion ;
  unsigned long flags ;

  {
#line 1507
  run_to_completion = intf->run_to_completion;
#line 1509
  if (run_to_completion != 0) {
    {
#line 1510
    smi_msg = smi_add_send_msg(intf, smi_msg, priority);
    }
  } else {
    {
#line 1514
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_144(& intf->xmit_msgs_lock);
#line 1515
    smi_msg = smi_add_send_msg(intf, smi_msg, priority);
#line 1516
    ldv_spin_unlock_irqrestore_145(& intf->xmit_msgs_lock, flags);
    }
  }
#line 1519
  if ((unsigned long )smi_msg != (unsigned long )((struct ipmi_smi_msg *)0)) {
    {
#line 1520
    (*(handlers->sender))(intf->send_info, smi_msg);
    }
  } else {

  }
#line 1521
  return;
}
}
#line 1529 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int i_ipmi_request(ipmi_user_t user , ipmi_smi_t intf , struct ipmi_addr *addr ,
                          long msgid , struct kernel_ipmi_msg *msg , void *user_msg_data ,
                          void *supplied_smi , struct ipmi_recv_msg *supplied_recv ,
                          int priority , unsigned char source_address , unsigned char source_lun ,
                          int retries , unsigned int retry_time_ms ) 
{ 
  int rv ;
  struct ipmi_smi_msg *smi_msg ;
  struct ipmi_recv_msg *recv_msg ;
  unsigned long flags ;
  struct ipmi_system_interface_addr *smi_addr ;
  struct ipmi_ipmb_addr *ipmb_addr ;
  unsigned char ipmb_seq ;
  long seqid ;
  int broadcast ;
  struct ipmi_lan_addr *lan_addr ;
  unsigned char ipmb_seq___0 ;
  long seqid___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1543
  rv = 0;
#line 1549
  if ((unsigned long )supplied_recv != (unsigned long )((struct ipmi_recv_msg *)0)) {
#line 1550
    recv_msg = supplied_recv;
  } else {
    {
#line 1552
    recv_msg = ipmi_alloc_recv_msg();
    }
#line 1553
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
#line 1554
      return (-12);
    } else {

    }
  }
#line 1556
  recv_msg->user_msg_data = user_msg_data;
#line 1558
  if ((unsigned long )supplied_smi != (unsigned long )((void *)0)) {
#line 1559
    smi_msg = (struct ipmi_smi_msg *)supplied_smi;
  } else {
    {
#line 1561
    smi_msg = ipmi_alloc_smi_msg();
    }
#line 1562
    if ((unsigned long )smi_msg == (unsigned long )((struct ipmi_smi_msg *)0)) {
      {
#line 1563
      ipmi_free_recv_msg(recv_msg);
      }
#line 1564
      return (-12);
    } else {

    }
  }
  {
#line 1568
  rcu_read_lock();
  }
#line 1569
  if ((int )intf->in_shutdown) {
#line 1570
    rv = -19;
#line 1571
    goto out_err;
  } else {

  }
#line 1574
  recv_msg->user = user;
#line 1575
  if ((unsigned long )user != (unsigned long )((ipmi_user_t )0)) {
    {
#line 1576
    kref_get(& user->refcount);
    }
  } else {

  }
#line 1577
  recv_msg->msgid = msgid;
#line 1582
  recv_msg->msg = *msg;
#line 1584
  if (addr->addr_type == 12) {
#line 1587
    if ((int )msg->netfn & 1) {
#line 1589
      rv = -22;
#line 1590
      goto out_err;
    } else {

    }
#line 1593
    smi_addr = (struct ipmi_system_interface_addr *)addr;
#line 1594
    if ((unsigned int )smi_addr->lun > 3U) {
      {
#line 1595
      atomic_inc((atomic_t *)(& intf->stats));
#line 1596
      rv = -22;
      }
#line 1597
      goto out_err;
    } else {

    }
    {
#line 1600
    __memcpy((void *)(& recv_msg->addr), (void const   *)smi_addr, 8UL);
    }
#line 1602
    if ((unsigned int )msg->netfn == 6U && (unsigned int )msg->cmd - 51U <= 2U) {
      {
#line 1610
      atomic_inc((atomic_t *)(& intf->stats));
#line 1611
      rv = -22;
      }
#line 1612
      goto out_err;
    } else {

    }
#line 1615
    if (((unsigned int )msg->netfn == 6U && (unsigned int )msg->cmd - 2U <= 1U) || (unsigned int )msg->netfn == 8U) {
      {
#line 1619
      ldv___ldv_linux_kernel_locking_spinlock_spin_lock_146(& intf->maintenance_mode_lock);
#line 1620
      intf->auto_maintenance_timeout = 30000;
      }
#line 1622
      if (intf->maintenance_mode == 0 && ! intf->maintenance_mode_enable) {
        {
#line 1624
        intf->maintenance_mode_enable = 1;
#line 1625
        maintenance_mode_update(intf);
        }
      } else {

      }
      {
#line 1627
      ldv_spin_unlock_irqrestore_133(& intf->maintenance_mode_lock, flags);
      }
    } else {

    }
#line 1631
    if ((int )msg->data_len + 2 > 272) {
      {
#line 1632
      atomic_inc((atomic_t *)(& intf->stats));
#line 1633
      rv = -90;
      }
#line 1634
      goto out_err;
    } else {

    }
#line 1637
    smi_msg->data[0] = (unsigned char )((int )((signed char )((int )msg->netfn << 2)) | ((int )((signed char )smi_addr->lun) & 3));
#line 1638
    smi_msg->data[1] = msg->cmd;
#line 1639
    smi_msg->msgid = msgid;
#line 1640
    smi_msg->user_data = (void *)recv_msg;
#line 1641
    if ((unsigned int )msg->data_len != 0U) {
      {
#line 1642
      __memcpy((void *)(& smi_msg->data) + 2U, (void const   *)msg->data, (size_t )msg->data_len);
      }
    } else {

    }
    {
#line 1643
    smi_msg->data_size = (int )msg->data_len + 2;
#line 1644
    atomic_inc((atomic_t *)(& intf->stats) + 1UL);
    }
  } else {
    {
#line 1645
    tmp___0 = is_ipmb_addr(addr);
    }
#line 1645
    if (tmp___0 != 0) {
#line 1645
      goto _L;
    } else {
      {
#line 1645
      tmp___1 = is_ipmb_bcast_addr(addr);
      }
#line 1645
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
#line 1649
        broadcast = 0;
#line 1651
        if ((int )addr->channel > 15) {
          {
#line 1652
          atomic_inc((atomic_t *)(& intf->stats));
#line 1653
          rv = -22;
          }
#line 1654
          goto out_err;
        } else {

        }
#line 1657
        if ((unsigned int )intf->channels[(int )addr->channel].medium != 1U) {
          {
#line 1659
          atomic_inc((atomic_t *)(& intf->stats));
#line 1660
          rv = -22;
          }
#line 1661
          goto out_err;
        } else {

        }
#line 1664
        if (retries < 0) {
#line 1665
          if (addr->addr_type == 65) {
#line 1666
            retries = 0;
          } else {
#line 1668
            retries = 4;
          }
        } else {

        }
#line 1670
        if (addr->addr_type == 65) {
#line 1676
          addr->addr_type = 1;
#line 1677
          broadcast = 1;
        } else {

        }
#line 1682
        if (retry_time_ms == 0U) {
#line 1683
          retry_time_ms = 1000U;
        } else {

        }
#line 1689
        if (((int )msg->data_len + 10) + broadcast > 272) {
          {
#line 1690
          atomic_inc((atomic_t *)(& intf->stats));
#line 1691
          rv = -90;
          }
#line 1692
          goto out_err;
        } else {

        }
#line 1695
        ipmb_addr = (struct ipmi_ipmb_addr *)addr;
#line 1696
        if ((unsigned int )ipmb_addr->lun > 3U) {
          {
#line 1697
          atomic_inc((atomic_t *)(& intf->stats));
#line 1698
          rv = -22;
          }
#line 1699
          goto out_err;
        } else {

        }
        {
#line 1702
        __memcpy((void *)(& recv_msg->addr), (void const   *)ipmb_addr, 8UL);
        }
#line 1704
        if ((int )recv_msg->msg.netfn & 1) {
          {
#line 1709
          atomic_inc((atomic_t *)(& intf->stats) + 9UL);
#line 1710
          format_ipmb_msg(smi_msg, msg, ipmb_addr, msgid, (int )((unsigned char )msgid),
                          broadcast, (int )source_address, (int )source_lun);
#line 1718
          smi_msg->user_data = (void *)recv_msg;
          }
        } else {
          {
#line 1722
          ldv___ldv_linux_kernel_locking_spinlock_spin_lock_148(& intf->seq_lock);
#line 1728
          rv = intf_next_seq(intf, recv_msg, (unsigned long )retry_time_ms, retries,
                             broadcast, & ipmb_seq, & seqid);
          }
#line 1735
          if (rv != 0) {
            {
#line 1740
            ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
            }
#line 1742
            goto out_err;
          } else {

          }
          {
#line 1745
          atomic_inc((atomic_t *)(& intf->stats) + 4UL);
#line 1752
          format_ipmb_msg(smi_msg, msg, ipmb_addr, (long )((int )ipmb_seq << 26) | (seqid & 67108863L),
                          (int )ipmb_seq, broadcast, (int )source_address, (int )source_lun);
#line 1761
          __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& smi_msg->data),
                   (size_t )smi_msg->data_size);
#line 1763
          recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 1764
          recv_msg->msg.data_len = (unsigned short )smi_msg->data_size;
#line 1774
          ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
          }
        }
      } else {
        {
#line 1776
        tmp = is_lan_addr(addr);
        }
#line 1776
        if (tmp != 0) {
#line 1781
          if ((int )addr->channel > 15) {
            {
#line 1782
            atomic_inc((atomic_t *)(& intf->stats));
#line 1783
            rv = -22;
            }
#line 1784
            goto out_err;
          } else {

          }
#line 1787
          if ((unsigned int )intf->channels[(int )addr->channel].medium - 4U > 1U) {
            {
#line 1791
            atomic_inc((atomic_t *)(& intf->stats));
#line 1792
            rv = -22;
            }
#line 1793
            goto out_err;
          } else {

          }
#line 1796
          retries = 4;
#line 1799
          if (retry_time_ms == 0U) {
#line 1800
            retry_time_ms = 1000U;
          } else {

          }
#line 1803
          if ((int )msg->data_len + 12 > 272) {
            {
#line 1804
            atomic_inc((atomic_t *)(& intf->stats));
#line 1805
            rv = -90;
            }
#line 1806
            goto out_err;
          } else {

          }
#line 1809
          lan_addr = (struct ipmi_lan_addr *)addr;
#line 1810
          if ((unsigned int )lan_addr->lun > 3U) {
            {
#line 1811
            atomic_inc((atomic_t *)(& intf->stats));
#line 1812
            rv = -22;
            }
#line 1813
            goto out_err;
          } else {

          }
          {
#line 1816
          __memcpy((void *)(& recv_msg->addr), (void const   *)lan_addr, 12UL);
          }
#line 1818
          if ((int )recv_msg->msg.netfn & 1) {
            {
#line 1823
            atomic_inc((atomic_t *)(& intf->stats) + 17UL);
#line 1824
            format_lan_msg(smi_msg, msg, lan_addr, msgid, (int )((unsigned char )msgid),
                           (int )source_lun);
#line 1831
            smi_msg->user_data = (void *)recv_msg;
            }
          } else {
            {
#line 1835
            ldv___ldv_linux_kernel_locking_spinlock_spin_lock_151(& intf->seq_lock);
#line 1841
            rv = intf_next_seq(intf, recv_msg, (unsigned long )retry_time_ms, retries,
                               0, & ipmb_seq___0, & seqid___0);
            }
#line 1848
            if (rv != 0) {
              {
#line 1853
              ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
              }
#line 1855
              goto out_err;
            } else {

            }
            {
#line 1858
            atomic_inc((atomic_t *)(& intf->stats) + 13UL);
#line 1865
            format_lan_msg(smi_msg, msg, lan_addr, (long )((int )ipmb_seq___0 << 26) | (seqid___0 & 67108863L),
                           (int )ipmb_seq___0, (int )source_lun);
#line 1873
            __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& smi_msg->data),
                     (size_t )smi_msg->data_size);
#line 1875
            recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 1876
            recv_msg->msg.data_len = (unsigned short )smi_msg->data_size;
#line 1886
            ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
            }
          }
        } else {
          {
#line 1890
          atomic_inc((atomic_t *)(& intf->stats));
#line 1891
          rv = -22;
          }
#line 1892
          goto out_err;
        }
      }
    }
  }
  {
#line 1904
  smi_send(intf, intf->handlers, smi_msg, priority);
#line 1905
  rcu_read_unlock();
  }
#line 1907
  return (0);
  out_err: 
  {
#line 1910
  rcu_read_unlock();
#line 1911
  ipmi_free_smi_msg(smi_msg);
#line 1912
  ipmi_free_recv_msg(recv_msg);
  }
#line 1913
  return (rv);
}
}
#line 1916 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int check_addr(ipmi_smi_t intf , struct ipmi_addr *addr , unsigned char *saddr ,
                      unsigned char *lun ) 
{ 


  {
#line 1921
  if ((int )addr->channel > 15) {
#line 1922
    return (-22);
  } else {

  }
#line 1923
  *lun = intf->channels[(int )addr->channel].lun;
#line 1924
  *saddr = intf->channels[(int )addr->channel].address;
#line 1925
  return (0);
}
}
#line 1928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_request_settime(ipmi_user_t user , struct ipmi_addr *addr , long msgid ,
                         struct kernel_ipmi_msg *msg , void *user_msg_data , int priority ,
                         int retries , unsigned int retry_time_ms ) 
{ 
  unsigned char saddr ;
  unsigned char lun ;
  int rv ;
  int tmp ;

  {
#line 1937
  saddr = 0U;
#line 1937
  lun = 0U;
#line 1940
  if ((unsigned long )user == (unsigned long )((ipmi_user_t )0)) {
#line 1941
    return (-22);
  } else {

  }
  {
#line 1942
  rv = check_addr(user->intf, addr, & saddr, & lun);
  }
#line 1943
  if (rv != 0) {
#line 1944
    return (rv);
  } else {

  }
  {
#line 1945
  tmp = i_ipmi_request(user, user->intf, addr, msgid, msg, user_msg_data, (void *)0,
                       (struct ipmi_recv_msg *)0, priority, (int )saddr, (int )lun,
                       retries, retry_time_ms);
  }
#line 1945
  return (tmp);
}
}
#line 1958 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_request_settime[21U]  = 
#line 1958
  {      'i',      'p',      'm',      'i', 
        '_',      'r',      'e',      'q', 
        'u',      'e',      's',      't', 
        '_',      's',      'e',      't', 
        't',      'i',      'm',      'e', 
        '\000'};
#line 1958
struct kernel_symbol  const  __ksymtab_ipmi_request_settime ;
#line 1958 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_request_settime  =    {(unsigned long )(& ipmi_request_settime), (char const   *)(& __kstrtab_ipmi_request_settime)};
#line 1960 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_request_supply_msgs(ipmi_user_t user , struct ipmi_addr *addr , long msgid ,
                             struct kernel_ipmi_msg *msg , void *user_msg_data , void *supplied_smi ,
                             struct ipmi_recv_msg *supplied_recv , int priority ) 
{ 
  unsigned char saddr ;
  unsigned char lun ;
  int rv ;
  int tmp ;

  {
#line 1969
  saddr = 0U;
#line 1969
  lun = 0U;
#line 1972
  if ((unsigned long )user == (unsigned long )((ipmi_user_t )0)) {
#line 1973
    return (-22);
  } else {

  }
  {
#line 1974
  rv = check_addr(user->intf, addr, & saddr, & lun);
  }
#line 1975
  if (rv != 0) {
#line 1976
    return (rv);
  } else {

  }
  {
#line 1977
  tmp = i_ipmi_request(user, user->intf, addr, msgid, msg, user_msg_data, supplied_smi,
                       supplied_recv, priority, (int )saddr, (int )lun, -1, 0U);
  }
#line 1977
  return (tmp);
}
}
#line 1990 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_request_supply_msgs[25U]  = 
#line 1990
  {      'i',      'p',      'm',      'i', 
        '_',      'r',      'e',      'q', 
        'u',      'e',      's',      't', 
        '_',      's',      'u',      'p', 
        'p',      'l',      'y',      '_', 
        'm',      's',      'g',      's', 
        '\000'};
#line 1990
struct kernel_symbol  const  __ksymtab_ipmi_request_supply_msgs ;
#line 1990 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_request_supply_msgs  =    {(unsigned long )(& ipmi_request_supply_msgs), (char const   *)(& __kstrtab_ipmi_request_supply_msgs)};
#line 1993 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_ipmb_proc_show(struct seq_file *m , void *v ) 
{ 
  ipmi_smi_t intf ;
  int i ;
  bool tmp ;

  {
  {
#line 1995
  intf = (ipmi_smi_t )m->private;
#line 1998
  seq_printf(m, "%x", (int )intf->channels[0].address);
#line 1999
  i = 1;
  }
#line 1999
  goto ldv_36659;
  ldv_36658: 
  {
#line 2000
  seq_printf(m, " %x", (int )intf->channels[i].address);
#line 1999
  i = i + 1;
  }
  ldv_36659: ;
#line 1999
  if (i <= 15) {
#line 2001
    goto ldv_36658;
  } else {

  }
  {
#line 2001
  seq_putc(m, 10);
#line 2003
  tmp = seq_has_overflowed(m);
  }
#line 2003
  return ((int )tmp);
}
}
#line 2006 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_ipmb_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2008
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 2008
  tmp___0 = single_open(file, & smi_ipmb_proc_show, tmp);
  }
#line 2008
  return (tmp___0);
}
}
#line 2011 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct file_operations  const  smi_ipmb_proc_ops  = 
#line 2011
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & smi_ipmb_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2018 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_version_proc_show(struct seq_file *m , void *v ) 
{ 
  ipmi_smi_t intf ;
  bool tmp ;

  {
  {
#line 2020
  intf = (ipmi_smi_t )m->private;
#line 2022
  seq_printf(m, "%u.%u\n", (int )(intf->bmc)->id.ipmi_version & 15, (int )(intf->bmc)->id.ipmi_version >> 4);
#line 2026
  tmp = seq_has_overflowed(m);
  }
#line 2026
  return ((int )tmp);
}
}
#line 2029 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_version_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2031
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 2031
  tmp___0 = single_open(file, & smi_version_proc_show, tmp);
  }
#line 2031
  return (tmp___0);
}
}
#line 2034 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct file_operations  const  smi_version_proc_ops  = 
#line 2034
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & smi_version_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2041 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_stats_proc_show(struct seq_file *m , void *v ) 
{ 
  ipmi_smi_t intf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 2043
  intf = (ipmi_smi_t )m->private;
#line 2045
  tmp = atomic_read((atomic_t const   *)(& intf->stats));
#line 2045
  seq_printf(m, "sent_invalid_commands:       %u\n", (unsigned int )tmp);
#line 2047
  tmp___0 = atomic_read((atomic_t const   *)(& intf->stats) + 1U);
#line 2047
  seq_printf(m, "sent_local_commands:         %u\n", (unsigned int )tmp___0);
#line 2049
  tmp___1 = atomic_read((atomic_t const   *)(& intf->stats) + 2U);
#line 2049
  seq_printf(m, "handled_local_responses:     %u\n", (unsigned int )tmp___1);
#line 2051
  tmp___2 = atomic_read((atomic_t const   *)(& intf->stats) + 3U);
#line 2051
  seq_printf(m, "unhandled_local_responses:   %u\n", (unsigned int )tmp___2);
#line 2053
  tmp___3 = atomic_read((atomic_t const   *)(& intf->stats) + 4U);
#line 2053
  seq_printf(m, "sent_ipmb_commands:          %u\n", (unsigned int )tmp___3);
#line 2055
  tmp___4 = atomic_read((atomic_t const   *)(& intf->stats) + 5U);
#line 2055
  seq_printf(m, "sent_ipmb_command_errs:      %u\n", (unsigned int )tmp___4);
#line 2057
  tmp___5 = atomic_read((atomic_t const   *)(& intf->stats) + 6U);
#line 2057
  seq_printf(m, "retransmitted_ipmb_commands: %u\n", (unsigned int )tmp___5);
#line 2059
  tmp___6 = atomic_read((atomic_t const   *)(& intf->stats) + 7U);
#line 2059
  seq_printf(m, "timed_out_ipmb_commands:     %u\n", (unsigned int )tmp___6);
#line 2061
  tmp___7 = atomic_read((atomic_t const   *)(& intf->stats) + 8U);
#line 2061
  seq_printf(m, "timed_out_ipmb_broadcasts:   %u\n", (unsigned int )tmp___7);
#line 2063
  tmp___8 = atomic_read((atomic_t const   *)(& intf->stats) + 9U);
#line 2063
  seq_printf(m, "sent_ipmb_responses:         %u\n", (unsigned int )tmp___8);
#line 2065
  tmp___9 = atomic_read((atomic_t const   *)(& intf->stats) + 10U);
#line 2065
  seq_printf(m, "handled_ipmb_responses:      %u\n", (unsigned int )tmp___9);
#line 2067
  tmp___10 = atomic_read((atomic_t const   *)(& intf->stats) + 11U);
#line 2067
  seq_printf(m, "invalid_ipmb_responses:      %u\n", (unsigned int )tmp___10);
#line 2069
  tmp___11 = atomic_read((atomic_t const   *)(& intf->stats) + 12U);
#line 2069
  seq_printf(m, "unhandled_ipmb_responses:    %u\n", (unsigned int )tmp___11);
#line 2071
  tmp___12 = atomic_read((atomic_t const   *)(& intf->stats) + 13U);
#line 2071
  seq_printf(m, "sent_lan_commands:           %u\n", (unsigned int )tmp___12);
#line 2073
  tmp___13 = atomic_read((atomic_t const   *)(& intf->stats) + 14U);
#line 2073
  seq_printf(m, "sent_lan_command_errs:       %u\n", (unsigned int )tmp___13);
#line 2075
  tmp___14 = atomic_read((atomic_t const   *)(& intf->stats) + 15U);
#line 2075
  seq_printf(m, "retransmitted_lan_commands:  %u\n", (unsigned int )tmp___14);
#line 2077
  tmp___15 = atomic_read((atomic_t const   *)(& intf->stats) + 16U);
#line 2077
  seq_printf(m, "timed_out_lan_commands:      %u\n", (unsigned int )tmp___15);
#line 2079
  tmp___16 = atomic_read((atomic_t const   *)(& intf->stats) + 17U);
#line 2079
  seq_printf(m, "sent_lan_responses:          %u\n", (unsigned int )tmp___16);
#line 2081
  tmp___17 = atomic_read((atomic_t const   *)(& intf->stats) + 18U);
#line 2081
  seq_printf(m, "handled_lan_responses:       %u\n", (unsigned int )tmp___17);
#line 2083
  tmp___18 = atomic_read((atomic_t const   *)(& intf->stats) + 19U);
#line 2083
  seq_printf(m, "invalid_lan_responses:       %u\n", (unsigned int )tmp___18);
#line 2085
  tmp___19 = atomic_read((atomic_t const   *)(& intf->stats) + 20U);
#line 2085
  seq_printf(m, "unhandled_lan_responses:     %u\n", (unsigned int )tmp___19);
#line 2087
  tmp___20 = atomic_read((atomic_t const   *)(& intf->stats) + 21U);
#line 2087
  seq_printf(m, "handled_commands:            %u\n", (unsigned int )tmp___20);
#line 2089
  tmp___21 = atomic_read((atomic_t const   *)(& intf->stats) + 22U);
#line 2089
  seq_printf(m, "invalid_commands:            %u\n", (unsigned int )tmp___21);
#line 2091
  tmp___22 = atomic_read((atomic_t const   *)(& intf->stats) + 23U);
#line 2091
  seq_printf(m, "unhandled_commands:          %u\n", (unsigned int )tmp___22);
#line 2093
  tmp___23 = atomic_read((atomic_t const   *)(& intf->stats) + 24U);
#line 2093
  seq_printf(m, "invalid_events:              %u\n", (unsigned int )tmp___23);
#line 2095
  tmp___24 = atomic_read((atomic_t const   *)(& intf->stats) + 25U);
#line 2095
  seq_printf(m, "events:                      %u\n", (unsigned int )tmp___24);
#line 2097
  tmp___25 = atomic_read((atomic_t const   *)(& intf->stats) + 27U);
#line 2097
  seq_printf(m, "failed rexmit LAN msgs:      %u\n", (unsigned int )tmp___25);
#line 2099
  tmp___26 = atomic_read((atomic_t const   *)(& intf->stats) + 26U);
#line 2099
  seq_printf(m, "failed rexmit IPMB msgs:     %u\n", (unsigned int )tmp___26);
  }
#line 2101
  return (0);
}
}
#line 2104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int smi_stats_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2106
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 2106
  tmp___0 = single_open(file, & smi_stats_proc_show, tmp);
  }
#line 2106
  return (tmp___0);
}
}
#line 2109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct file_operations  const  smi_stats_proc_ops  = 
#line 2109
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & smi_stats_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_smi_add_proc_entry(ipmi_smi_t smi , char *name , struct file_operations  const  *proc_ops ,
                            void *data ) 
{ 
  int rv ;
  struct proc_dir_entry *file ;
  struct ipmi_proc_entry *entry ;
  void *tmp ;

  {
  {
#line 2121
  rv = 0;
#line 2127
  tmp = kmalloc(16UL, 208U);
#line 2127
  entry = (struct ipmi_proc_entry *)tmp;
  }
#line 2128
  if ((unsigned long )entry == (unsigned long )((struct ipmi_proc_entry *)0)) {
#line 2129
    return (-12);
  } else {

  }
  {
#line 2130
  entry->name = kstrdup((char const   *)name, 208U);
  }
#line 2131
  if ((unsigned long )entry->name == (unsigned long )((char *)0)) {
    {
#line 2132
    kfree((void const   *)entry);
    }
#line 2133
    return (-12);
  } else {

  }
  {
#line 2136
  file = proc_create_data((char const   *)name, 0, smi->proc_dir, proc_ops, data);
  }
#line 2137
  if ((unsigned long )file == (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 2138
    kfree((void const   *)entry->name);
#line 2139
    kfree((void const   *)entry);
#line 2140
    rv = -12;
    }
  } else {
    {
#line 2142
    ldv_mutex_lock_154(& smi->proc_entry_lock);
#line 2144
    entry->next = smi->proc_entries;
#line 2145
    smi->proc_entries = entry;
#line 2146
    ldv_mutex_unlock_155(& smi->proc_entry_lock);
    }
  }
#line 2150
  return (rv);
}
}
#line 2152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_smi_add_proc_entry[24U]  = 
#line 2152
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'm',      'i', 
        '_',      'a',      'd',      'd', 
        '_',      'p',      'r',      'o', 
        'c',      '_',      'e',      'n', 
        't',      'r',      'y',      '\000'};
#line 2152
struct kernel_symbol  const  __ksymtab_ipmi_smi_add_proc_entry ;
#line 2152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_smi_add_proc_entry  =    {(unsigned long )(& ipmi_smi_add_proc_entry), (char const   *)(& __kstrtab_ipmi_smi_add_proc_entry)};
#line 2154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int add_proc_entries(ipmi_smi_t smi , int num ) 
{ 
  int rv ;

  {
  {
#line 2156
  rv = 0;
#line 2159
  sprintf((char *)(& smi->proc_dir_name), "%d", num);
#line 2160
  smi->proc_dir = proc_mkdir((char const   *)(& smi->proc_dir_name), proc_ipmi_root);
  }
#line 2161
  if ((unsigned long )smi->proc_dir == (unsigned long )((struct proc_dir_entry *)0)) {
#line 2162
    rv = -12;
  } else {

  }
#line 2164
  if (rv == 0) {
    {
#line 2165
    rv = ipmi_smi_add_proc_entry(smi, (char *)"stats", & smi_stats_proc_ops, (void *)smi);
    }
  } else {

  }
#line 2169
  if (rv == 0) {
    {
#line 2170
    rv = ipmi_smi_add_proc_entry(smi, (char *)"ipmb", & smi_ipmb_proc_ops, (void *)smi);
    }
  } else {

  }
#line 2174
  if (rv == 0) {
    {
#line 2175
    rv = ipmi_smi_add_proc_entry(smi, (char *)"version", & smi_version_proc_ops, (void *)smi);
    }
  } else {

  }
#line 2180
  return (rv);
}
}
#line 2183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void remove_proc_entries(ipmi_smi_t smi ) 
{ 
  struct ipmi_proc_entry *entry ;

  {
  {
#line 2188
  ldv_mutex_lock_156(& smi->proc_entry_lock);
  }
#line 2189
  goto ldv_36715;
  ldv_36714: 
  {
#line 2190
  entry = smi->proc_entries;
#line 2191
  smi->proc_entries = entry->next;
#line 2193
  remove_proc_entry((char const   *)entry->name, smi->proc_dir);
#line 2194
  kfree((void const   *)entry->name);
#line 2195
  kfree((void const   *)entry);
  }
  ldv_36715: ;
#line 2189
  if ((unsigned long )smi->proc_entries != (unsigned long )((struct ipmi_proc_entry *)0)) {
#line 2191
    goto ldv_36714;
  } else {

  }
  {
#line 2197
  ldv_mutex_unlock_157(& smi->proc_entry_lock);
#line 2198
  remove_proc_entry((char const   *)(& smi->proc_dir_name), proc_ipmi_root);
  }
#line 2199
  return;
}
}
#line 2202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int __find_bmc_guid(struct device *dev , void *data ) 
{ 
  unsigned char *id ;
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2204
  id = (unsigned char *)data;
#line 2205
  __mptr = (struct device  const  *)dev;
#line 2205
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2206
  tmp = memcmp((void const   *)(& bmc->guid), (void const   *)id, 16UL);
  }
#line 2206
  return (tmp == 0);
}
}
#line 2209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct bmc_device *ipmi_find_bmc_guid(struct device_driver *drv , unsigned char *guid ) 
{ 
  struct device *dev ;
  struct device  const  *__mptr ;

  {
  {
#line 2214
  dev = driver_find_device(drv, (struct device *)0, (void *)guid, & __find_bmc_guid);
  }
#line 2215
  if ((unsigned long )dev != (unsigned long )((struct device *)0)) {
#line 2216
    __mptr = (struct device  const  *)dev;
#line 2216
    return ((struct bmc_device *)__mptr + 0xfffffffffffffff0UL);
  } else {
#line 2218
    return ((struct bmc_device *)0);
  }
}
}
#line 2226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int __find_bmc_prod_dev_id(struct device *dev , void *data ) 
{ 
  struct prod_dev_id *id ;
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;

  {
#line 2228
  id = (struct prod_dev_id *)data;
#line 2229
  __mptr = (struct device  const  *)dev;
#line 2229
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2231
  return (bmc->id.product_id == id->product_id && (int )bmc->id.device_id == (int )id->device_id);
}
}
#line 2235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct bmc_device *ipmi_find_bmc_prod_dev_id(struct device_driver *drv , unsigned int product_id ,
                                                    unsigned char device_id ) 
{ 
  struct prod_dev_id id ;
  struct device *dev ;
  struct device  const  *__mptr ;

  {
  {
#line 2239
  id.product_id = product_id;
#line 2239
  id.device_id = device_id;
#line 2245
  dev = driver_find_device(drv, (struct device *)0, (void *)(& id), & __find_bmc_prod_dev_id);
  }
#line 2246
  if ((unsigned long )dev != (unsigned long )((struct device *)0)) {
#line 2247
    __mptr = (struct device  const  *)dev;
#line 2247
    return ((struct bmc_device *)__mptr + 0xfffffffffffffff0UL);
  } else {
#line 2249
    return ((struct bmc_device *)0);
  }
}
}
#line 2252 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t device_id_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2256
  __mptr = (struct device  const  *)dev;
#line 2256
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2258
  tmp = snprintf(buf, 10UL, "%u\n", (int )bmc->id.device_id);
  }
#line 2258
  return ((ssize_t )tmp);
}
}
#line 2260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_device_id  =    {{"device_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & device_id_show, (ssize_t (*)(struct device * , struct device_attribute * , char const   * ,
                                   size_t  ))0};
#line 2262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t provides_device_sdrs_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2266
  __mptr = (struct device  const  *)dev;
#line 2266
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2268
  tmp = snprintf(buf, 10UL, "%u\n", (int )bmc->id.device_revision >> 7);
  }
#line 2268
  return ((ssize_t )tmp);
}
}
#line 2272 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_provides_device_sdrs  =    {{"provides_device_sdrs", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}, {(char)0},
                                                  {(char)0}, {(char)0}}}}, & provides_device_sdrs_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 2274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t revision_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2277
  __mptr = (struct device  const  *)dev;
#line 2277
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2279
  tmp = snprintf(buf, 20UL, "%u\n", (int )bmc->id.device_revision & 15);
  }
#line 2279
  return ((ssize_t )tmp);
}
}
#line 2282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_revision  =    {{"revision", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & revision_show, (ssize_t (*)(struct device * , struct device_attribute * , char const   * ,
                                  size_t  ))0};
#line 2284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t firmware_revision_show(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2288
  __mptr = (struct device  const  *)dev;
#line 2288
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2290
  tmp = snprintf(buf, 20UL, "%u.%x\n", (int )bmc->id.firmware_revision_1, (int )bmc->id.firmware_revision_2);
  }
#line 2290
  return ((ssize_t )tmp);
}
}
#line 2293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_firmware_revision  =    {{"firmware_revision", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & firmware_revision_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                           char const   * , size_t  ))0};
#line 2295 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t ipmi_version_show(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2299
  __mptr = (struct device  const  *)dev;
#line 2299
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2301
  tmp = snprintf(buf, 20UL, "%u.%u\n", (int )bmc->id.ipmi_version & 15, (int )bmc->id.ipmi_version >> 4);
  }
#line 2301
  return ((ssize_t )tmp);
}
}
#line 2305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_ipmi_version  =    {{"ipmi_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & ipmi_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                      char const   * , size_t  ))0};
#line 2307 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t add_dev_support_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2311
  __mptr = (struct device  const  *)dev;
#line 2311
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2313
  tmp = snprintf(buf, 10UL, "0x%02x\n", (int )bmc->id.additional_device_support);
  }
#line 2313
  return ((ssize_t )tmp);
}
}
#line 2317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_additional_device_support  =    {{"additional_device_support", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                       {(char)0}, {(char)0}, {(char)0},
                                                       {(char)0}, {(char)0}}}}, & add_dev_support_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 2319 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t manufacturer_id_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2323
  __mptr = (struct device  const  *)dev;
#line 2323
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2325
  tmp = snprintf(buf, 20UL, "0x%6.6x\n", bmc->id.manufacturer_id);
  }
#line 2325
  return ((ssize_t )tmp);
}
}
#line 2327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_manufacturer_id  =    {{"manufacturer_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                             {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & manufacturer_id_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                         char const   * , size_t  ))0};
#line 2329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t product_id_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2333
  __mptr = (struct device  const  *)dev;
#line 2333
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2335
  tmp = snprintf(buf, 10UL, "0x%4.4x\n", bmc->id.product_id);
  }
#line 2335
  return ((ssize_t )tmp);
}
}
#line 2337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_product_id  =    {{"product_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & product_id_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                    char const   * , size_t  ))0};
#line 2339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t aux_firmware_rev_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2343
  __mptr = (struct device  const  *)dev;
#line 2343
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2345
  tmp = snprintf(buf, 21UL, "0x%02x 0x%02x 0x%02x 0x%02x\n", (int )bmc->id.aux_firmware_revision[3],
                 (int )bmc->id.aux_firmware_revision[2], (int )bmc->id.aux_firmware_revision[1],
                 (int )bmc->id.aux_firmware_revision[0]);
  }
#line 2345
  return ((ssize_t )tmp);
}
}
#line 2351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_aux_firmware_revision  =    {{"aux_firmware_revision", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                   {(char)0}, {(char)0}, {(char)0},
                                                   {(char)0}, {(char)0}}}}, & aux_firmware_rev_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 2353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static ssize_t guid_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 2356
  __mptr = (struct device  const  *)dev;
#line 2356
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2358
  tmp = snprintf(buf, 100UL, "%Lx%Lx\n", (long long )bmc->guid[0], (long long )bmc->guid[8]);
  }
#line 2358
  return ((ssize_t )tmp);
}
}
#line 2362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_attribute dev_attr_guid  =    {{"guid", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & guid_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 2364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct attribute *bmc_dev_attrs[11U]  = 
#line 2364
  {      & dev_attr_device_id.attr,      & dev_attr_provides_device_sdrs.attr,      & dev_attr_revision.attr,      & dev_attr_firmware_revision.attr, 
        & dev_attr_ipmi_version.attr,      & dev_attr_additional_device_support.attr,      & dev_attr_manufacturer_id.attr,      & dev_attr_product_id.attr, 
        & dev_attr_aux_firmware_revision.attr,      & dev_attr_guid.attr,      (struct attribute *)0};
#line 2378 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static umode_t bmc_dev_attr_is_visible(struct kobject *kobj , struct attribute *attr ,
                                       int idx ) 
{ 
  struct device *dev ;
  struct device *tmp ;
  struct bmc_device *bmc ;
  struct device  const  *__mptr ;
  umode_t mode ;

  {
  {
#line 2381
  tmp = kobj_to_dev(kobj);
#line 2381
  dev = tmp;
#line 2382
  __mptr = (struct device  const  *)dev;
#line 2382
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffff0UL;
#line 2383
  mode = attr->mode;
  }
#line 2385
  if ((unsigned long )attr == (unsigned long )(& dev_attr_aux_firmware_revision.attr)) {
#line 2386
    return ((unsigned int )*((unsigned char *)bmc + 1484UL) != 0U ? mode : 0U);
  } else {

  }
#line 2387
  if ((unsigned long )attr == (unsigned long )(& dev_attr_guid.attr)) {
#line 2388
    return (bmc->guid_set != 0 ? mode : 0U);
  } else {

  }
#line 2389
  return (mode);
}
}
#line 2392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct attribute_group bmc_dev_attr_group  =    {0, & bmc_dev_attr_is_visible, (struct attribute **)(& bmc_dev_attrs), 0};
#line 2397 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct attribute_group  const  *bmc_dev_attr_groups[2U]  = {      (struct attribute_group  const  *)(& bmc_dev_attr_group),      (struct attribute_group  const  *)0};
#line 2402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct device_type bmc_device_type  =    {0, (struct attribute_group  const  **)(& bmc_dev_attr_groups), 0, 0, 0, 0};
#line 2407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void release_bmc_device(struct device *dev ) 
{ 
  struct device  const  *__mptr ;

  {
  {
#line 2409
  __mptr = (struct device  const  *)dev;
#line 2409
  kfree((void const   *)((struct bmc_device *)__mptr + 0xfffffffffffffff0UL));
  }
#line 2411
  return;
}
}
#line 2413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void cleanup_bmc_device(struct kref *ref ) 
{ 
  struct bmc_device *bmc ;
  struct kref  const  *__mptr ;

  {
  {
#line 2415
  __mptr = (struct kref  const  *)ref;
#line 2415
  bmc = (struct bmc_device *)__mptr + 0xfffffffffffffa0cUL;
#line 2417
  platform_device_unregister(& bmc->pdev);
  }
#line 2418
  return;
}
}
#line 2420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void ipmi_bmc_unregister(ipmi_smi_t intf ) 
{ 
  struct bmc_device *bmc ;

  {
  {
#line 2422
  bmc = intf->bmc;
#line 2424
  sysfs_remove_link(& (intf->si_dev)->kobj, "bmc");
  }
#line 2425
  if ((unsigned long )intf->my_dev_name != (unsigned long )((char *)0)) {
    {
#line 2426
    sysfs_remove_link(& bmc->pdev.dev.kobj, (char const   *)intf->my_dev_name);
#line 2427
    kfree((void const   *)intf->my_dev_name);
#line 2428
    intf->my_dev_name = (char *)0;
    }
  } else {

  }
  {
#line 2431
  ldv_mutex_lock_158(& ipmidriver_mutex);
#line 2432
  kref_put(& bmc->usecount, & cleanup_bmc_device);
#line 2433
  intf->bmc = (struct bmc_device *)0;
#line 2434
  ldv_mutex_unlock_159(& ipmidriver_mutex);
  }
#line 2435
  return;
}
}
#line 2437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int ipmi_bmc_register(ipmi_smi_t intf , int ifnum ) 
{ 
  int rv ;
  struct bmc_device *bmc ;
  struct bmc_device *old_bmc ;
  unsigned char orig_dev_id ;
  int warn_printed ;
  struct bmc_device *tmp ;

  {
  {
#line 2440
  bmc = intf->bmc;
#line 2443
  ldv_mutex_lock_160(& ipmidriver_mutex);
  }
#line 2449
  if (bmc->guid_set != 0) {
    {
#line 2450
    old_bmc = ipmi_find_bmc_guid(& ipmidriver.driver, (unsigned char *)(& bmc->guid));
    }
  } else {
    {
#line 2452
    old_bmc = ipmi_find_bmc_prod_dev_id(& ipmidriver.driver, bmc->id.product_id, (int )bmc->id.device_id);
    }
  }
#line 2460
  if ((unsigned long )old_bmc != (unsigned long )((struct bmc_device *)0)) {
    {
#line 2461
    kfree((void const   *)bmc);
#line 2462
    intf->bmc = old_bmc;
#line 2463
    bmc = old_bmc;
#line 2465
    kref_get(& bmc->usecount);
#line 2466
    ldv_mutex_unlock_161(& ipmidriver_mutex);
#line 2468
    printk("\016ipmi: interfacing existing BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\n",
           bmc->id.manufacturer_id, bmc->id.product_id, (int )bmc->id.device_id);
    }
  } else {
    {
#line 2475
    orig_dev_id = bmc->id.device_id;
#line 2476
    warn_printed = 0;
#line 2478
    snprintf((char *)(& bmc->name), 16UL, "ipmi_bmc.%4.4x", bmc->id.product_id);
#line 2480
    bmc->pdev.name = (char const   *)(& bmc->name);
    }
#line 2482
    goto ldv_36982;
    ldv_36981: ;
#line 2485
    if (warn_printed == 0) {
      {
#line 2486
      printk("\fIPMI message handler: This machine has two different BMCs with the same product id and device id.  This is an error in the firmware, but incrementing the device id to work around the problem. Prod ID = 0x%x, Dev ID = 0x%x\n",
             bmc->id.product_id, (int )bmc->id.device_id);
#line 2494
      warn_printed = 1;
      }
    } else {

    }
#line 2496
    bmc->id.device_id = (unsigned char )((int )bmc->id.device_id + 1);
#line 2497
    if ((int )bmc->id.device_id == (int )orig_dev_id) {
      {
#line 2498
      printk("\vIPMI message handler: Out of device ids!\n");
      }
#line 2500
      goto ldv_36980;
    } else {

    }
    ldv_36982: 
    {
#line 2482
    tmp = ipmi_find_bmc_prod_dev_id(& ipmidriver.driver, bmc->id.product_id, (int )bmc->id.device_id);
    }
#line 2482
    if ((unsigned long )tmp != (unsigned long )((struct bmc_device *)0)) {
#line 2484
      goto ldv_36981;
    } else {

    }
    ldv_36980: 
    {
#line 2504
    bmc->pdev.dev.driver = & ipmidriver.driver;
#line 2505
    bmc->pdev.id = (int )bmc->id.device_id;
#line 2506
    bmc->pdev.dev.release = & release_bmc_device;
#line 2507
    bmc->pdev.dev.type = (struct device_type  const  *)(& bmc_device_type);
#line 2508
    kref_init(& bmc->usecount);
#line 2510
    rv = platform_device_register(& bmc->pdev);
#line 2511
    ldv_mutex_unlock_162(& ipmidriver_mutex);
    }
#line 2512
    if (rv != 0) {
      {
#line 2513
      put_device(& bmc->pdev.dev);
#line 2514
      printk("\vipmi_msghandler: Unable to register bmc device: %d\n", rv);
      }
#line 2522
      return (rv);
    } else {

    }
    {
#line 2525
    _dev_info((struct device  const  *)intf->si_dev, "Found new BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\n",
              bmc->id.manufacturer_id, bmc->id.product_id, (int )bmc->id.device_id);
    }
  }
  {
#line 2536
  rv = sysfs_create_link(& (intf->si_dev)->kobj, & bmc->pdev.dev.kobj, "bmc");
  }
#line 2537
  if (rv != 0) {
    {
#line 2538
    printk("\vipmi_msghandler: Unable to create bmc symlink: %d\n", rv);
    }
#line 2541
    goto out_err;
  } else {

  }
  {
#line 2544
  intf->my_dev_name = kasprintf(208U, "ipmi%d", ifnum);
  }
#line 2545
  if ((unsigned long )intf->my_dev_name == (unsigned long )((char *)0)) {
    {
#line 2546
    rv = -12;
#line 2547
    printk("\vipmi_msghandler: allocate link from BMC: %d\n", rv);
    }
#line 2550
    goto out_err;
  } else {

  }
  {
#line 2553
  rv = sysfs_create_link(& bmc->pdev.dev.kobj, & (intf->si_dev)->kobj, (char const   *)intf->my_dev_name);
  }
#line 2555
  if (rv != 0) {
    {
#line 2556
    kfree((void const   *)intf->my_dev_name);
#line 2557
    intf->my_dev_name = (char *)0;
#line 2558
    printk("\vipmi_msghandler: Unable to create symlink to bmc: %d\n", rv);
    }
#line 2562
    goto out_err;
  } else {

  }
#line 2565
  return (0);
  out_err: 
  {
#line 2568
  ipmi_bmc_unregister(intf);
  }
#line 2569
  return (rv);
}
}
#line 2573 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int send_guid_cmd(ipmi_smi_t intf , int chan ) 
{ 
  struct kernel_ipmi_msg msg ;
  struct ipmi_system_interface_addr si ;
  int tmp ;

  {
  {
#line 2578
  si.addr_type = 12;
#line 2579
  si.channel = 15;
#line 2580
  si.lun = 0U;
#line 2582
  msg.netfn = 6U;
#line 2583
  msg.cmd = 8U;
#line 2584
  msg.data = (unsigned char *)0U;
#line 2585
  msg.data_len = 0U;
#line 2586
  tmp = i_ipmi_request((ipmi_user_t )0, intf, (struct ipmi_addr *)(& si), 0L, & msg,
                       (void *)intf, (void *)0, (struct ipmi_recv_msg *)0, 0, (int )intf->channels[0].address,
                       (int )intf->channels[0].lun, -1, 0U);
  }
#line 2586
  return (tmp);
}
}
#line 2601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void guid_handler(ipmi_smi_t intf , struct ipmi_recv_msg *msg ) 
{ 


  {
#line 2603
  if (msg->addr.addr_type != 12 || (unsigned int )*((unsigned short *)msg + 40UL) != 2055U) {
#line 2607
    return;
  } else {

  }
#line 2609
  if ((unsigned int )*(msg->msg.data) != 0U) {
#line 2611
    (intf->bmc)->guid_set = 0;
#line 2612
    goto out;
  } else {

  }
#line 2615
  if ((unsigned int )msg->msg.data_len <= 16U) {
    {
#line 2616
    (intf->bmc)->guid_set = 0;
#line 2617
    printk("\fIPMI message handler: guid_handler: The GUID response from the BMC was too short, it was %d but should have been 17.  Assuming GUID is not available.\n",
           (int )msg->msg.data_len);
    }
#line 2622
    goto out;
  } else {

  }
  {
#line 2625
  __memcpy((void *)(& (intf->bmc)->guid), (void const   *)msg->msg.data, 16UL);
#line 2626
  (intf->bmc)->guid_set = 1;
  }
  out: 
  {
#line 2628
  __wake_up(& intf->waitq, 3U, 1, (void *)0);
  }
#line 2629
  return;
}
}
#line 2632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void get_guid(ipmi_smi_t intf ) 
{ 
  int rv ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp ;

  {
  {
#line 2636
  (intf->bmc)->guid_set = 2;
#line 2637
  intf->null_user_handler = & guid_handler;
#line 2638
  rv = send_guid_cmd(intf, 0);
  }
#line 2639
  if (rv != 0) {
#line 2641
    (intf->bmc)->guid_set = 0;
  } else {

  }
  {
#line 2642
  __might_sleep("drivers/char/ipmi/ipmi_msghandler.c", 2642, 0);
  }
#line 2642
  if ((intf->bmc)->guid_set != 2) {
#line 2642
    goto ldv_36999;
  } else {

  }
  {
#line 2642
  __ret = 0L;
#line 2642
  INIT_LIST_HEAD(& __wait.task_list);
#line 2642
  __wait.flags = 0U;
  }
  ldv_37005: 
  {
#line 2642
  tmp = prepare_to_wait_event(& intf->waitq, & __wait, 2);
#line 2642
  __int = tmp;
  }
#line 2642
  if ((intf->bmc)->guid_set != 2) {
#line 2642
    goto ldv_37004;
  } else {

  }
  {
#line 2642
  schedule();
  }
#line 2642
  goto ldv_37005;
  ldv_37004: 
  {
#line 2642
  finish_wait(& intf->waitq, & __wait);
  }

  ldv_36999: 
#line 2643
  intf->null_user_handler = (void (*)(ipmi_smi_t  , struct ipmi_recv_msg * ))0;
#line 2644
  return;
}
}
#line 2647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int send_channel_info_cmd(ipmi_smi_t intf , int chan ) 
{ 
  struct kernel_ipmi_msg msg ;
  unsigned char data[1U] ;
  struct ipmi_system_interface_addr si ;
  int tmp ;

  {
  {
#line 2653
  si.addr_type = 12;
#line 2654
  si.channel = 15;
#line 2655
  si.lun = 0U;
#line 2657
  msg.netfn = 6U;
#line 2658
  msg.cmd = 66U;
#line 2659
  msg.data = (unsigned char *)(& data);
#line 2660
  msg.data_len = 1U;
#line 2661
  data[0] = (unsigned char )chan;
#line 2662
  tmp = i_ipmi_request((ipmi_user_t )0, intf, (struct ipmi_addr *)(& si), 0L, & msg,
                       (void *)intf, (void *)0, (struct ipmi_recv_msg *)0, 0, (int )intf->channels[0].address,
                       (int )intf->channels[0].lun, -1, 0U);
  }
#line 2662
  return (tmp);
}
}
#line 2677 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void channel_handler(ipmi_smi_t intf , struct ipmi_recv_msg *msg ) 
{ 
  int rv ;
  int chan ;

  {
#line 2679
  rv = 0;
#line 2682
  if (msg->addr.addr_type == 12 && (unsigned int )*((unsigned short *)msg + 40UL) == 16903U) {
#line 2686
    if ((unsigned int )*(msg->msg.data) != 0U) {
#line 2689
      if ((unsigned int )*(msg->msg.data) == 193U) {
        {
#line 2696
        intf->channels[0].medium = 1U;
#line 2698
        intf->channels[0].protocol = 1U;
#line 2701
        intf->curr_channel = 16;
#line 2702
        __wake_up(& intf->waitq, 3U, 1, (void *)0);
        }
#line 2703
        goto out;
      } else {

      }
#line 2705
      goto next_channel;
    } else {

    }
#line 2707
    if ((unsigned int )msg->msg.data_len <= 3U) {
#line 2709
      goto next_channel;
    } else {

    }
#line 2711
    chan = intf->curr_channel;
#line 2712
    intf->channels[chan].medium = (unsigned int )*(msg->msg.data + 2UL) & 127U;
#line 2713
    intf->channels[chan].protocol = (unsigned int )*(msg->msg.data + 3UL) & 31U;
    next_channel: 
#line 2716
    intf->curr_channel = intf->curr_channel + 1;
#line 2717
    if (intf->curr_channel > 15) {
      {
#line 2718
      __wake_up(& intf->waitq, 3U, 1, (void *)0);
      }
    } else {
      {
#line 2720
      rv = send_channel_info_cmd(intf, intf->curr_channel);
      }
    }
#line 2722
    if (rv != 0) {
      {
#line 2724
      printk("\fIPMI message handler: Error sending channel information for channel %d: %d\n",
             intf->curr_channel, rv);
#line 2728
      intf->curr_channel = 16;
#line 2729
      __wake_up(& intf->waitq, 3U, 1, (void *)0);
      }
    } else {

    }
  } else {

  }
  out: ;
#line 2733
  return;
}
}
#line 2736 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void ipmi_poll(ipmi_smi_t intf ) 
{ 


  {
#line 2738
  if ((unsigned long )(intf->handlers)->poll != (unsigned long )((void (*)(void * ))0)) {
    {
#line 2739
    (*((intf->handlers)->poll))(intf->send_info);
    }
  } else {

  }
  {
#line 2741
  handle_new_recv_msgs(intf);
  }
#line 2742
  return;
}
}
#line 2744 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
void ipmi_poll_interface(ipmi_user_t user ) 
{ 


  {
  {
#line 2746
  ipmi_poll(user->intf);
  }
#line 2747
  return;
}
}
#line 2748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_poll_interface[20U]  = 
#line 2748
  {      'i',      'p',      'm',      'i', 
        '_',      'p',      'o',      'l', 
        'l',      '_',      'i',      'n', 
        't',      'e',      'r',      'f', 
        'a',      'c',      'e',      '\000'};
#line 2748
struct kernel_symbol  const  __ksymtab_ipmi_poll_interface ;
#line 2748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_poll_interface  =    {(unsigned long )(& ipmi_poll_interface), (char const   *)(& __kstrtab_ipmi_poll_interface)};
#line 2750 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_register_smi(struct ipmi_smi_handlers *handlers , void *send_info , struct ipmi_device_id *device_id ,
                      struct device *si_dev , unsigned char slave_addr ) 
{ 
  int i ;
  int j ;
  int rv ;
  ipmi_smi_t intf ;
  ipmi_smi_t tintf ;
  struct list_head *link ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp___1 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___3 ;

  {
#line 2766
  if (initialized == 0) {
    {
#line 2767
    rv = ipmi_init_msghandler();
    }
#line 2768
    if (rv != 0) {
#line 2769
      return (rv);
    } else {

    }
#line 2774
    if (initialized == 0) {
#line 2775
      return (-19);
    } else {

    }
  } else {

  }
  {
#line 2778
  tmp = kzalloc(4344UL, 208U);
#line 2778
  intf = (ipmi_smi_t )tmp;
  }
#line 2779
  if ((unsigned long )intf == (unsigned long )((ipmi_smi_t )0)) {
#line 2780
    return (-12);
  } else {

  }
  {
#line 2782
  intf->ipmi_version_major = (unsigned int )device_id->ipmi_version & 15U;
#line 2783
  intf->ipmi_version_minor = (int )device_id->ipmi_version >> 4;
#line 2785
  tmp___0 = kzalloc(1528UL, 208U);
#line 2785
  intf->bmc = (struct bmc_device *)tmp___0;
  }
#line 2786
  if ((unsigned long )intf->bmc == (unsigned long )((struct bmc_device *)0)) {
    {
#line 2787
    kfree((void const   *)intf);
    }
#line 2788
    return (-12);
  } else {

  }
  {
#line 2790
  intf->intf_num = -1;
#line 2791
  kref_init(& intf->refcount);
#line 2792
  (intf->bmc)->id = *device_id;
#line 2793
  intf->si_dev = si_dev;
#line 2794
  j = 0;
  }
#line 2794
  goto ldv_37049;
  ldv_37048: 
#line 2795
  intf->channels[j].address = 32U;
#line 2796
  intf->channels[j].lun = 2U;
#line 2794
  j = j + 1;
  ldv_37049: ;
#line 2794
  if (j <= 15) {
#line 2796
    goto ldv_37048;
  } else {

  }

#line 2798
  if ((unsigned int )slave_addr != 0U) {
#line 2799
    intf->channels[0].address = slave_addr;
  } else {

  }
  {
#line 2800
  INIT_LIST_HEAD(& intf->users);
#line 2801
  intf->handlers = handlers;
#line 2802
  intf->send_info = send_info;
#line 2803
  spinlock_check(& intf->seq_lock);
#line 2803
  __raw_spin_lock_init(& intf->seq_lock.__annonCompField18.rlock, "&(&intf->seq_lock)->rlock",
                       & __key);
#line 2804
  j = 0;
  }
#line 2804
  goto ldv_37053;
  ldv_37052: 
#line 2805
  intf->seq_table[j].inuse = 0U;
#line 2806
  intf->seq_table[j].seqid = 0L;
#line 2804
  j = j + 1;
  ldv_37053: ;
#line 2804
  if (j <= 63) {
#line 2806
    goto ldv_37052;
  } else {

  }
  {
#line 2808
  intf->curr_seq = 0;
#line 2810
  __mutex_init(& intf->proc_entry_lock, "&intf->proc_entry_lock", & __key___0);
#line 2812
  spinlock_check(& intf->waiting_rcv_msgs_lock);
#line 2812
  __raw_spin_lock_init(& intf->waiting_rcv_msgs_lock.__annonCompField18.rlock, "&(&intf->waiting_rcv_msgs_lock)->rlock",
                       & __key___1);
#line 2813
  INIT_LIST_HEAD(& intf->waiting_rcv_msgs);
#line 2814
  tasklet_init(& intf->recv_tasklet, & smi_recv_tasklet, (unsigned long )intf);
#line 2817
  atomic_set(& intf->watchdog_pretimeouts_to_deliver, 0);
#line 2818
  spinlock_check(& intf->xmit_msgs_lock);
#line 2818
  __raw_spin_lock_init(& intf->xmit_msgs_lock.__annonCompField18.rlock, "&(&intf->xmit_msgs_lock)->rlock",
                       & __key___2);
#line 2819
  INIT_LIST_HEAD(& intf->xmit_msgs);
#line 2820
  INIT_LIST_HEAD(& intf->hp_xmit_msgs);
#line 2821
  spinlock_check(& intf->events_lock);
#line 2821
  __raw_spin_lock_init(& intf->events_lock.__annonCompField18.rlock, "&(&intf->events_lock)->rlock",
                       & __key___3);
#line 2822
  atomic_set(& intf->event_waiters, 0);
#line 2823
  intf->ticks_to_req_ev = 1U;
#line 2824
  INIT_LIST_HEAD(& intf->waiting_events);
#line 2825
  intf->waiting_events_count = 0U;
#line 2826
  __mutex_init(& intf->cmd_rcvrs_mutex, "&intf->cmd_rcvrs_mutex", & __key___4);
#line 2827
  spinlock_check(& intf->maintenance_mode_lock);
#line 2827
  __raw_spin_lock_init(& intf->maintenance_mode_lock.__annonCompField18.rlock, "&(&intf->maintenance_mode_lock)->rlock",
                       & __key___5);
#line 2828
  INIT_LIST_HEAD(& intf->cmd_rcvrs);
#line 2829
  __init_waitqueue_head(& intf->waitq, "&intf->waitq", & __key___6);
#line 2830
  i = 0;
  }
#line 2830
  goto ldv_37063;
  ldv_37062: 
  {
#line 2831
  atomic_set((atomic_t *)(& intf->stats) + (unsigned long )i, 0);
#line 2830
  i = i + 1;
  }
  ldv_37063: ;
#line 2830
  if (i <= 27) {
#line 2832
    goto ldv_37062;
  } else {

  }
  {
#line 2833
  intf->proc_dir = (struct proc_dir_entry *)0;
#line 2835
  ldv_mutex_lock_163(& smi_watchers_mutex);
#line 2836
  ldv_mutex_lock_164(& ipmi_interfaces_mutex);
#line 2838
  i = 0;
#line 2839
  link = & ipmi_interfaces;
#line 2840
  __ptr = ipmi_interfaces.next;
#line 2840
  __var = (struct list_head *)0;
#line 2840
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 2840
  ________p1 = _________p1;
#line 2840
  tmp___1 = debug_lockdep_rcu_enabled();
  }
#line 2840
  if (tmp___1 != 0 && ! __warned) {
    {
#line 2840
    rcu_read_lock_held();
    }
  } else {

  }
#line 2840
  __mptr = (struct list_head  const  *)________p1;
#line 2840
  tintf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 2840
  goto ldv_37089;
  ldv_37088: ;
#line 2841
  if (tintf->intf_num != i) {
#line 2842
    link = & tintf->link;
#line 2843
    goto ldv_37087;
  } else {

  }
  {
#line 2845
  i = i + 1;
#line 2840
  __ptr___0 = tintf->link.next;
#line 2840
  __var___0 = (struct list_head *)0;
#line 2840
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 2840
  ________p1___0 = _________p1___0;
#line 2840
  tmp___2 = debug_lockdep_rcu_enabled();
  }
#line 2840
  if (tmp___2 != 0 && ! __warned___0) {
    {
#line 2840
    rcu_read_lock_held();
    }
  } else {

  }
#line 2840
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 2840
  tintf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_37089: ;
#line 2840
  if ((unsigned long )(& tintf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 2842
    goto ldv_37088;
  } else {

  }
  ldv_37087: ;
#line 2848
  if (i == 0) {
    {
#line 2849
    list_add_rcu(& intf->link, & ipmi_interfaces);
    }
  } else {
    {
#line 2851
    list_add_rcu(& intf->link, link);
    }
  }
  {
#line 2853
  rv = (*(handlers->start_processing))(send_info, intf);
  }
#line 2854
  if (rv != 0) {
#line 2855
    goto out;
  } else {

  }
  {
#line 2857
  get_guid(intf);
  }
#line 2859
  if ((unsigned int )intf->ipmi_version_major > 1U || ((unsigned int )intf->ipmi_version_major == 1U && (unsigned int )intf->ipmi_version_minor > 4U)) {
    {
#line 2866
    intf->null_user_handler = & channel_handler;
#line 2867
    intf->curr_channel = 0;
#line 2868
    rv = send_channel_info_cmd(intf, 0);
    }
#line 2869
    if (rv != 0) {
      {
#line 2870
      printk("\fIPMI message handler: Error sending channel information for channel 0, %d\n",
             rv);
      }
#line 2873
      goto out;
    } else {

    }
    {
#line 2877
    __might_sleep("drivers/char/ipmi/ipmi_msghandler.c", 2878, 0);
    }
#line 2877
    if (intf->curr_channel > 15) {
#line 2877
      goto ldv_37091;
    } else {

    }
    {
#line 2877
    __ret = 0L;
#line 2877
    INIT_LIST_HEAD(& __wait.task_list);
#line 2877
    __wait.flags = 0U;
    }
    ldv_37097: 
    {
#line 2877
    tmp___3 = prepare_to_wait_event(& intf->waitq, & __wait, 2);
#line 2877
    __int = tmp___3;
    }
#line 2877
    if (intf->curr_channel > 15) {
#line 2877
      goto ldv_37096;
    } else {

    }
    {
#line 2877
    schedule();
    }
#line 2877
    goto ldv_37097;
    ldv_37096: 
    {
#line 2877
    finish_wait(& intf->waitq, & __wait);
    }

    ldv_37091: 
#line 2879
    intf->null_user_handler = (void (*)(ipmi_smi_t  , struct ipmi_recv_msg * ))0;
  } else {
#line 2882
    intf->channels[0].medium = 1U;
#line 2883
    intf->channels[0].protocol = 1U;
#line 2884
    intf->curr_channel = 16;
  }
#line 2887
  if (rv == 0) {
    {
#line 2888
    rv = add_proc_entries(intf, i);
    }
  } else {

  }
  {
#line 2890
  rv = ipmi_bmc_register(intf, i);
  }
  out: ;
#line 2893
  if (rv != 0) {
#line 2894
    if ((unsigned long )intf->proc_dir != (unsigned long )((struct proc_dir_entry *)0)) {
      {
#line 2895
      remove_proc_entries(intf);
      }
    } else {

    }
    {
#line 2896
    intf->handlers = (struct ipmi_smi_handlers *)0;
#line 2897
    list_del_rcu(& intf->link);
#line 2898
    ldv_mutex_unlock_165(& ipmi_interfaces_mutex);
#line 2899
    ldv_mutex_unlock_166(& smi_watchers_mutex);
#line 2900
    synchronize_rcu();
#line 2901
    kref_put(& intf->refcount, & intf_free);
    }
  } else {
    {
#line 2908
    __asm__  volatile   ("": : : "memory");
#line 2909
    intf->intf_num = i;
#line 2910
    ldv_mutex_unlock_167(& ipmi_interfaces_mutex);
#line 2912
    call_smi_watchers(i, intf->si_dev);
#line 2913
    ldv_mutex_unlock_168(& smi_watchers_mutex);
    }
  }
#line 2916
  return (rv);
}
}
#line 2918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_register_smi[18U]  = 
#line 2918
  {      'i',      'p',      'm',      'i', 
        '_',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '_',      's',      'm', 
        'i',      '\000'};
#line 2918
struct kernel_symbol  const  __ksymtab_ipmi_register_smi ;
#line 2918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_register_smi  =    {(unsigned long )(& ipmi_register_smi), (char const   *)(& __kstrtab_ipmi_register_smi)};
#line 2920 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void deliver_smi_err_response(ipmi_smi_t intf , struct ipmi_smi_msg *msg ,
                                     unsigned char err ) 
{ 


  {
  {
#line 2924
  msg->rsp[0] = (unsigned int )msg->data[0] | 4U;
#line 2925
  msg->rsp[1] = msg->data[1];
#line 2926
  msg->rsp[2] = err;
#line 2927
  msg->rsp_size = 3;
#line 2929
  handle_one_recv_msg(intf, msg);
  }
#line 2930
  return;
}
}
#line 2932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void cleanup_smi_msgs(ipmi_smi_t intf ) 
{ 
  int i ;
  struct seq_table *ent ;
  struct ipmi_smi_msg *msg ;
  struct list_head *entry ;
  struct list_head tmplist ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  {
#line 2941
  INIT_LIST_HEAD(& tmplist);
#line 2942
  list_splice_tail(& intf->hp_xmit_msgs, & tmplist);
#line 2943
  list_splice_tail(& intf->xmit_msgs, & tmplist);
  }
#line 2946
  goto ldv_37124;
  ldv_37123: 
  {
#line 2948
  schedule_timeout(1L);
  }
  ldv_37124: ;
#line 2946
  if ((unsigned long )intf->curr_msg != (unsigned long )((struct ipmi_smi_msg *)0)) {
    {
#line 2946
    tmp = list_empty((struct list_head  const  *)(& intf->waiting_rcv_msgs));
    }
#line 2946
    if (tmp == 0) {
#line 2948
      goto ldv_37123;
    } else {
#line 2951
      goto ldv_37125;
    }
  } else {

  }
  ldv_37125: ;
#line 2957
  goto ldv_37129;
  ldv_37128: 
  {
#line 2958
  entry = tmplist.next;
#line 2959
  list_del(entry);
#line 2960
  __mptr = (struct list_head  const  *)entry;
#line 2960
  msg = (struct ipmi_smi_msg *)__mptr;
#line 2961
  deliver_smi_err_response(intf, msg, 255);
  }
  ldv_37129: 
  {
#line 2957
  tmp___0 = list_empty((struct list_head  const  *)(& tmplist));
  }
#line 2957
  if (tmp___0 == 0) {
#line 2959
    goto ldv_37128;
  } else {

  }
#line 2964
  i = 0;
#line 2964
  goto ldv_37133;
  ldv_37132: 
#line 2965
  ent = (struct seq_table *)(& intf->seq_table) + (unsigned long )i;
#line 2966
  if ((unsigned int )*((unsigned char *)ent + 0UL) == 0U) {
#line 2967
    goto ldv_37131;
  } else {

  }
  {
#line 2968
  deliver_err_response(ent->recv_msg, 255);
  }
  ldv_37131: 
#line 2964
  i = i + 1;
  ldv_37133: ;
#line 2964
  if (i <= 63) {
#line 2966
    goto ldv_37132;
  } else {

  }

#line 2971
  return;
}
}
#line 2972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
int ipmi_unregister_smi(ipmi_smi_t intf ) 
{ 
  struct ipmi_smi_watcher *w ;
  int intf_num ;
  ipmi_user_t user ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  {
#line 2975
  intf_num = intf->intf_num;
#line 2978
  ipmi_bmc_unregister(intf);
#line 2980
  ldv_mutex_lock_169(& smi_watchers_mutex);
#line 2981
  ldv_mutex_lock_170(& ipmi_interfaces_mutex);
#line 2982
  intf->intf_num = -1;
#line 2983
  intf->in_shutdown = 1;
#line 2984
  list_del_rcu(& intf->link);
#line 2985
  ldv_mutex_unlock_171(& ipmi_interfaces_mutex);
#line 2986
  synchronize_rcu();
#line 2988
  cleanup_smi_msgs(intf);
#line 2991
  ldv_mutex_lock_172(& ipmi_interfaces_mutex);
#line 2992
  rcu_read_lock();
#line 2993
  __ptr = intf->users.next;
#line 2993
  __var = (struct list_head *)0;
#line 2993
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 2993
  ________p1 = _________p1;
#line 2993
  tmp = debug_lockdep_rcu_enabled();
  }
#line 2993
  if (tmp != 0 && ! __warned) {
    {
#line 2993
    rcu_read_lock_held();
    }
  } else {

  }
#line 2993
  __mptr = (struct list_head  const  *)________p1;
#line 2993
  user = (struct ipmi_user *)__mptr;
#line 2993
  goto ldv_37164;
  ldv_37163: 
  {
#line 2994
  ldv_module_put_173((intf->handlers)->owner);
  }
#line 2995
  if ((unsigned long )(intf->handlers)->dec_usecount != (unsigned long )((void (*)(void * ))0)) {
    {
#line 2996
    (*((intf->handlers)->dec_usecount))(intf->send_info);
    }
  } else {

  }
  {
#line 2993
  __ptr___0 = user->link.next;
#line 2993
  __var___0 = (struct list_head *)0;
#line 2993
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 2993
  ________p1___0 = _________p1___0;
#line 2993
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 2993
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 2993
    rcu_read_lock_held();
    }
  } else {

  }
#line 2993
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 2993
  user = (struct ipmi_user *)__mptr___0;
  ldv_37164: ;
#line 2993
  if ((unsigned long )(& user->link) != (unsigned long )(& intf->users)) {
#line 2995
    goto ldv_37163;
  } else {

  }
  {
#line 2998
  rcu_read_unlock();
#line 2999
  intf->handlers = (struct ipmi_smi_handlers *)0;
#line 3000
  ldv_mutex_unlock_174(& ipmi_interfaces_mutex);
#line 3002
  remove_proc_entries(intf);
#line 3008
  __mptr___1 = (struct list_head  const  *)smi_watchers.next;
#line 3008
  w = (struct ipmi_smi_watcher *)__mptr___1;
  }
#line 3008
  goto ldv_37171;
  ldv_37170: 
  {
#line 3009
  (*(w->smi_gone))(intf_num);
#line 3008
  __mptr___2 = (struct list_head  const  *)w->link.next;
#line 3008
  w = (struct ipmi_smi_watcher *)__mptr___2;
  }
  ldv_37171: ;
#line 3008
  if ((unsigned long )(& w->link) != (unsigned long )(& smi_watchers)) {
#line 3010
    goto ldv_37170;
  } else {

  }
  {
#line 3010
  ldv_mutex_unlock_175(& smi_watchers_mutex);
#line 3012
  kref_put(& intf->refcount, & intf_free);
  }
#line 3013
  return (0);
}
}
#line 3015 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_unregister_smi[20U]  = 
#line 3015
  {      'i',      'p',      'm',      'i', 
        '_',      'u',      'n',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '_', 
        's',      'm',      'i',      '\000'};
#line 3015
struct kernel_symbol  const  __ksymtab_ipmi_unregister_smi ;
#line 3015 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_unregister_smi  =    {(unsigned long )(& ipmi_unregister_smi), (char const   *)(& __kstrtab_ipmi_unregister_smi)};
#line 3017 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_ipmb_get_msg_rsp(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct ipmi_ipmb_addr ipmb_addr ;
  struct ipmi_recv_msg *recv_msg ;
  int tmp ;

  {
#line 3027
  if (msg->rsp_size <= 10) {
    {
#line 3029
    atomic_inc((atomic_t *)(& intf->stats) + 11UL);
    }
#line 3030
    return (0);
  } else {

  }
#line 3033
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3035
    return (0);
  } else {

  }
  {
#line 3038
  ipmb_addr.addr_type = 1;
#line 3039
  ipmb_addr.slave_addr = msg->rsp[6];
#line 3040
  ipmb_addr.channel = (int )((short )msg->rsp[3]) & 15;
#line 3041
  ipmb_addr.lun = (unsigned int )msg->rsp[7] & 3U;
#line 3047
  tmp = intf_find_seq(intf, (int )msg->rsp[7] >> 2, (int )msg->rsp[3] & 15, (int )msg->rsp[8],
                      ((int )msg->rsp[4] >> 2) & 254, (struct ipmi_addr *)(& ipmb_addr),
                      & recv_msg);
  }
#line 3047
  if (tmp != 0) {
    {
#line 3058
    atomic_inc((atomic_t *)(& intf->stats) + 12UL);
    }
#line 3059
    return (0);
  } else {

  }
  {
#line 3062
  __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 9U, (size_t )(msg->rsp_size + -9));
#line 3070
  recv_msg->msg.netfn = (int )msg->rsp[4] >> 2;
#line 3071
  recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3072
  recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65526U;
#line 3073
  recv_msg->recv_type = 1;
#line 3074
  atomic_inc((atomic_t *)(& intf->stats) + 10UL);
#line 3075
  deliver_response(recv_msg);
  }
#line 3077
  return (0);
}
}
#line 3080 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_ipmb_get_msg_cmd(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct cmd_rcvr *rcvr ;
  int rv ;
  unsigned char netfn ;
  unsigned char cmd ;
  unsigned char chan ;
  ipmi_user_t user ;
  struct ipmi_ipmb_addr *ipmb_addr ;
  struct ipmi_recv_msg *recv_msg ;

  {
#line 3084
  rv = 0;
#line 3088
  user = (ipmi_user_t )0;
#line 3092
  if (msg->rsp_size <= 9) {
    {
#line 3094
    atomic_inc((atomic_t *)(& intf->stats) + 22UL);
    }
#line 3095
    return (0);
  } else {

  }
#line 3098
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3100
    return (0);
  } else {

  }
  {
#line 3103
  netfn = (int )msg->rsp[4] >> 2;
#line 3104
  cmd = msg->rsp[8];
#line 3105
  chan = (unsigned int )msg->rsp[3] & 15U;
#line 3107
  rcu_read_lock();
#line 3108
  rcvr = find_cmd_rcvr(intf, (int )netfn, (int )cmd, (int )chan);
  }
#line 3109
  if ((unsigned long )rcvr != (unsigned long )((struct cmd_rcvr *)0)) {
    {
#line 3110
    user = rcvr->user;
#line 3111
    kref_get(& user->refcount);
    }
  } else {
#line 3113
    user = (ipmi_user_t )0;
  }
  {
#line 3114
  rcu_read_unlock();
  }
#line 3116
  if ((unsigned long )user == (unsigned long )((ipmi_user_t )0)) {
    {
#line 3118
    atomic_inc((atomic_t *)(& intf->stats) + 23UL);
#line 3120
    msg->data[0] = 24U;
#line 3121
    msg->data[1] = 52U;
#line 3122
    msg->data[2] = msg->rsp[3];
#line 3123
    msg->data[3] = msg->rsp[6];
#line 3124
    msg->data[4] = (unsigned char )((int )((signed char )(((int )netfn + 1) << 2)) | ((int )((signed char )msg->rsp[7]) & 3));
#line 3125
    msg->data[5] = ipmb_checksum((unsigned char *)(& msg->data) + 3UL, 2);
#line 3126
    msg->data[6] = intf->channels[(int )msg->rsp[3] & 15].address;
#line 3128
    msg->data[7] = (unsigned char )(((int )((signed char )msg->rsp[7]) & -4) | ((int )((signed char )msg->rsp[4]) & 3));
#line 3129
    msg->data[8] = msg->rsp[8];
#line 3130
    msg->data[9] = 193U;
#line 3131
    msg->data[10] = ipmb_checksum((unsigned char *)(& msg->data) + 6UL, 4);
#line 3132
    msg->data_size = 11;
#line 3143
    rcu_read_lock();
    }
#line 3144
    if (! intf->in_shutdown) {
      {
#line 3145
      smi_send(intf, intf->handlers, msg, 0);
#line 3151
      rv = -1;
      }
    } else {

    }
    {
#line 3153
    rcu_read_unlock();
    }
  } else {
    {
#line 3156
    atomic_inc((atomic_t *)(& intf->stats) + 21UL);
#line 3158
    recv_msg = ipmi_alloc_recv_msg();
    }
#line 3159
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
      {
#line 3165
      rv = 1;
#line 3166
      kref_put(& user->refcount, & free_user);
      }
    } else {
      {
#line 3169
      ipmb_addr = (struct ipmi_ipmb_addr *)(& recv_msg->addr);
#line 3170
      ipmb_addr->addr_type = 1;
#line 3171
      ipmb_addr->slave_addr = msg->rsp[6];
#line 3172
      ipmb_addr->lun = (unsigned int )msg->rsp[7] & 3U;
#line 3173
      ipmb_addr->channel = (int )((short )msg->rsp[3]) & 15;
#line 3179
      recv_msg->user = user;
#line 3180
      recv_msg->recv_type = 3;
#line 3181
      recv_msg->msgid = (long )((int )msg->rsp[7] >> 2);
#line 3182
      recv_msg->msg.netfn = (int )msg->rsp[4] >> 2;
#line 3183
      recv_msg->msg.cmd = msg->rsp[8];
#line 3184
      recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3190
      recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65526U;
#line 3191
      __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 9U,
               (size_t )(msg->rsp_size + -10));
#line 3194
      deliver_response(recv_msg);
      }
    }
  }
#line 3198
  return (rv);
}
}
#line 3201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_lan_get_msg_rsp(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct ipmi_lan_addr lan_addr ;
  struct ipmi_recv_msg *recv_msg ;
  int tmp ;

  {
#line 3212
  if (msg->rsp_size <= 12) {
    {
#line 3214
    atomic_inc((atomic_t *)(& intf->stats) + 19UL);
    }
#line 3215
    return (0);
  } else {

  }
#line 3218
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3220
    return (0);
  } else {

  }
  {
#line 3223
  lan_addr.addr_type = 4;
#line 3224
  lan_addr.session_handle = msg->rsp[4];
#line 3225
  lan_addr.remote_SWID = msg->rsp[8];
#line 3226
  lan_addr.local_SWID = msg->rsp[5];
#line 3227
  lan_addr.channel = (int )((short )msg->rsp[3]) & 15;
#line 3228
  lan_addr.privilege = (int )msg->rsp[3] >> 4;
#line 3229
  lan_addr.lun = (unsigned int )msg->rsp[9] & 3U;
#line 3235
  tmp = intf_find_seq(intf, (int )msg->rsp[9] >> 2, (int )msg->rsp[3] & 15, (int )msg->rsp[10],
                      ((int )msg->rsp[6] >> 2) & 254, (struct ipmi_addr *)(& lan_addr),
                      & recv_msg);
  }
#line 3235
  if (tmp != 0) {
    {
#line 3246
    atomic_inc((atomic_t *)(& intf->stats) + 20UL);
    }
#line 3247
    return (0);
  } else {

  }
  {
#line 3250
  __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 11U, (size_t )(msg->rsp_size + -11));
#line 3258
  recv_msg->msg.netfn = (int )msg->rsp[6] >> 2;
#line 3259
  recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3260
  recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65524U;
#line 3261
  recv_msg->recv_type = 1;
#line 3262
  atomic_inc((atomic_t *)(& intf->stats) + 18UL);
#line 3263
  deliver_response(recv_msg);
  }
#line 3265
  return (0);
}
}
#line 3268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_lan_get_msg_cmd(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct cmd_rcvr *rcvr ;
  int rv ;
  unsigned char netfn ;
  unsigned char cmd ;
  unsigned char chan ;
  ipmi_user_t user ;
  struct ipmi_lan_addr *lan_addr ;
  struct ipmi_recv_msg *recv_msg ;

  {
#line 3272
  rv = 0;
#line 3276
  user = (ipmi_user_t )0;
#line 3280
  if (msg->rsp_size <= 11) {
    {
#line 3282
    atomic_inc((atomic_t *)(& intf->stats) + 22UL);
    }
#line 3283
    return (0);
  } else {

  }
#line 3286
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3288
    return (0);
  } else {

  }
  {
#line 3291
  netfn = (int )msg->rsp[6] >> 2;
#line 3292
  cmd = msg->rsp[10];
#line 3293
  chan = (unsigned int )msg->rsp[3] & 15U;
#line 3295
  rcu_read_lock();
#line 3296
  rcvr = find_cmd_rcvr(intf, (int )netfn, (int )cmd, (int )chan);
  }
#line 3297
  if ((unsigned long )rcvr != (unsigned long )((struct cmd_rcvr *)0)) {
    {
#line 3298
    user = rcvr->user;
#line 3299
    kref_get(& user->refcount);
    }
  } else {
#line 3301
    user = (ipmi_user_t )0;
  }
  {
#line 3302
  rcu_read_unlock();
  }
#line 3304
  if ((unsigned long )user == (unsigned long )((ipmi_user_t )0)) {
    {
#line 3306
    atomic_inc((atomic_t *)(& intf->stats) + 23UL);
#line 3312
    rv = 0;
    }
  } else {
    {
#line 3315
    atomic_inc((atomic_t *)(& intf->stats) + 21UL);
#line 3317
    recv_msg = ipmi_alloc_recv_msg();
    }
#line 3318
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
      {
#line 3323
      rv = 1;
#line 3324
      kref_put(& user->refcount, & free_user);
      }
    } else {
      {
#line 3327
      lan_addr = (struct ipmi_lan_addr *)(& recv_msg->addr);
#line 3328
      lan_addr->addr_type = 4;
#line 3329
      lan_addr->session_handle = msg->rsp[4];
#line 3330
      lan_addr->remote_SWID = msg->rsp[8];
#line 3331
      lan_addr->local_SWID = msg->rsp[5];
#line 3332
      lan_addr->lun = (unsigned int )msg->rsp[9] & 3U;
#line 3333
      lan_addr->channel = (int )((short )msg->rsp[3]) & 15;
#line 3334
      lan_addr->privilege = (int )msg->rsp[3] >> 4;
#line 3340
      recv_msg->user = user;
#line 3341
      recv_msg->recv_type = 3;
#line 3342
      recv_msg->msgid = (long )((int )msg->rsp[9] >> 2);
#line 3343
      recv_msg->msg.netfn = (int )msg->rsp[6] >> 2;
#line 3344
      recv_msg->msg.cmd = msg->rsp[10];
#line 3345
      recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3351
      recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65524U;
#line 3352
      __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 11U,
               (size_t )(msg->rsp_size + -12));
#line 3355
      deliver_response(recv_msg);
      }
    }
  }
#line 3359
  return (rv);
}
}
#line 3368 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_oem_get_msg_cmd(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct cmd_rcvr *rcvr ;
  int rv ;
  unsigned char netfn ;
  unsigned char cmd ;
  unsigned char chan ;
  ipmi_user_t user ;
  struct ipmi_system_interface_addr *smi_addr ;
  struct ipmi_recv_msg *recv_msg ;

  {
#line 3372
  rv = 0;
#line 3376
  user = (ipmi_user_t )0;
#line 3384
  if (msg->rsp_size <= 3) {
    {
#line 3386
    atomic_inc((atomic_t *)(& intf->stats) + 22UL);
    }
#line 3387
    return (0);
  } else {

  }
#line 3390
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3392
    return (0);
  } else {

  }
  {
#line 3399
  netfn = (int )msg->rsp[0] >> 2;
#line 3400
  cmd = msg->rsp[1];
#line 3401
  chan = (unsigned int )msg->rsp[3] & 15U;
#line 3403
  rcu_read_lock();
#line 3404
  rcvr = find_cmd_rcvr(intf, (int )netfn, (int )cmd, (int )chan);
  }
#line 3405
  if ((unsigned long )rcvr != (unsigned long )((struct cmd_rcvr *)0)) {
    {
#line 3406
    user = rcvr->user;
#line 3407
    kref_get(& user->refcount);
    }
  } else {
#line 3409
    user = (ipmi_user_t )0;
  }
  {
#line 3410
  rcu_read_unlock();
  }
#line 3412
  if ((unsigned long )user == (unsigned long )((ipmi_user_t )0)) {
    {
#line 3414
    atomic_inc((atomic_t *)(& intf->stats) + 23UL);
#line 3421
    rv = 0;
    }
  } else {
    {
#line 3424
    atomic_inc((atomic_t *)(& intf->stats) + 21UL);
#line 3426
    recv_msg = ipmi_alloc_recv_msg();
    }
#line 3427
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
      {
#line 3433
      rv = 1;
#line 3434
      kref_put(& user->refcount, & free_user);
      }
    } else {
      {
#line 3442
      smi_addr = (struct ipmi_system_interface_addr *)(& recv_msg->addr);
#line 3444
      smi_addr->addr_type = 12;
#line 3445
      smi_addr->channel = 15;
#line 3446
      smi_addr->lun = (unsigned int )msg->rsp[0] & 3U;
#line 3448
      recv_msg->user = user;
#line 3449
      recv_msg->user_msg_data = (void *)0;
#line 3450
      recv_msg->recv_type = 5;
#line 3451
      recv_msg->msg.netfn = (int )msg->rsp[0] >> 2;
#line 3452
      recv_msg->msg.cmd = msg->rsp[1];
#line 3453
      recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3459
      recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65532U;
#line 3460
      __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 4U,
               (size_t )(msg->rsp_size + -4));
#line 3463
      deliver_response(recv_msg);
      }
    }
  }
#line 3467
  return (rv);
}
}
#line 3470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void copy_event_into_recv_msg(struct ipmi_recv_msg *recv_msg , struct ipmi_smi_msg *msg ) 
{ 
  struct ipmi_system_interface_addr *smi_addr ;

  {
  {
#line 3475
  recv_msg->msgid = 0L;
#line 3476
  smi_addr = (struct ipmi_system_interface_addr *)(& recv_msg->addr);
#line 3477
  smi_addr->addr_type = 12;
#line 3478
  smi_addr->channel = 15;
#line 3479
  smi_addr->lun = (unsigned int )msg->rsp[0] & 3U;
#line 3480
  recv_msg->recv_type = 2;
#line 3481
  recv_msg->msg.netfn = (int )msg->rsp[0] >> 2;
#line 3482
  recv_msg->msg.cmd = msg->rsp[1];
#line 3483
  __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 3U, (size_t )(msg->rsp_size + -3));
#line 3484
  recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3485
  recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65533U;
  }
#line 3486
  return;
}
}
#line 3488 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_read_event_rsp(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct ipmi_recv_msg *recv_msg ;
  struct ipmi_recv_msg *recv_msg2 ;
  struct list_head msgs ;
  ipmi_user_t user ;
  int rv ;
  int deliver_count ;
  unsigned long flags ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
#line 3494
  rv = 0;
#line 3495
  deliver_count = 0;
#line 3498
  if (msg->rsp_size <= 18) {
    {
#line 3500
    atomic_inc((atomic_t *)(& intf->stats) + 24UL);
    }
#line 3501
    return (0);
  } else {

  }
#line 3504
  if ((unsigned int )msg->rsp[2] != 0U) {
#line 3506
    return (0);
  } else {

  }
  {
#line 3509
  INIT_LIST_HEAD(& msgs);
#line 3511
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_176(& intf->events_lock);
#line 3513
  atomic_inc((atomic_t *)(& intf->stats) + 25UL);
#line 3519
  rcu_read_lock();
#line 3520
  __ptr = intf->users.next;
#line 3520
  __var = (struct list_head *)0;
#line 3520
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 3520
  ________p1 = _________p1;
#line 3520
  tmp = debug_lockdep_rcu_enabled();
  }
#line 3520
  if (tmp != 0 && ! __warned) {
    {
#line 3520
    rcu_read_lock_held();
    }
  } else {

  }
#line 3520
  __mptr = (struct list_head  const  *)________p1;
#line 3520
  user = (struct ipmi_user *)__mptr;
#line 3520
  goto ldv_37278;
  ldv_37277: ;
#line 3521
  if (! user->gets_events) {
#line 3522
    goto ldv_37266;
  } else {

  }
  {
#line 3524
  recv_msg = ipmi_alloc_recv_msg();
  }
#line 3525
  if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
    {
#line 3526
    rcu_read_unlock();
#line 3527
    __mptr___0 = (struct list_head  const  *)msgs.next;
#line 3527
    recv_msg = (struct ipmi_recv_msg *)__mptr___0;
#line 3527
    __mptr___1 = (struct list_head  const  *)recv_msg->link.next;
#line 3527
    recv_msg2 = (struct ipmi_recv_msg *)__mptr___1;
    }
#line 3527
    goto ldv_37274;
    ldv_37273: 
    {
#line 3529
    list_del(& recv_msg->link);
#line 3530
    ipmi_free_recv_msg(recv_msg);
#line 3527
    recv_msg = recv_msg2;
#line 3527
    __mptr___2 = (struct list_head  const  *)recv_msg2->link.next;
#line 3527
    recv_msg2 = (struct ipmi_recv_msg *)__mptr___2;
    }
    ldv_37274: ;
#line 3527
    if ((unsigned long )(& recv_msg->link) != (unsigned long )(& msgs)) {
#line 3529
      goto ldv_37273;
    } else {

    }
#line 3537
    rv = 1;
#line 3538
    goto out;
  } else {

  }
  {
#line 3541
  deliver_count = deliver_count + 1;
#line 3543
  copy_event_into_recv_msg(recv_msg, msg);
#line 3544
  recv_msg->user = user;
#line 3545
  kref_get(& user->refcount);
#line 3546
  list_add_tail(& recv_msg->link, & msgs);
  }
  ldv_37266: 
  {
#line 3520
  __ptr___0 = user->link.next;
#line 3520
  __var___0 = (struct list_head *)0;
#line 3520
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 3520
  ________p1___0 = _________p1___0;
#line 3520
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 3520
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 3520
    rcu_read_lock_held();
    }
  } else {

  }
#line 3520
  __mptr___3 = (struct list_head  const  *)________p1___0;
#line 3520
  user = (struct ipmi_user *)__mptr___3;
  ldv_37278: ;
#line 3520
  if ((unsigned long )(& user->link) != (unsigned long )(& intf->users)) {
#line 3522
    goto ldv_37277;
  } else {

  }
  {
#line 3548
  rcu_read_unlock();
  }
#line 3550
  if (deliver_count != 0) {
#line 3552
    __mptr___4 = (struct list_head  const  *)msgs.next;
#line 3552
    recv_msg = (struct ipmi_recv_msg *)__mptr___4;
#line 3552
    __mptr___5 = (struct list_head  const  *)recv_msg->link.next;
#line 3552
    recv_msg2 = (struct ipmi_recv_msg *)__mptr___5;
#line 3552
    goto ldv_37287;
    ldv_37286: 
    {
#line 3553
    list_del(& recv_msg->link);
#line 3554
    deliver_response(recv_msg);
#line 3552
    recv_msg = recv_msg2;
#line 3552
    __mptr___6 = (struct list_head  const  *)recv_msg2->link.next;
#line 3552
    recv_msg2 = (struct ipmi_recv_msg *)__mptr___6;
    }
    ldv_37287: ;
#line 3552
    if ((unsigned long )(& recv_msg->link) != (unsigned long )(& msgs)) {
#line 3554
      goto ldv_37286;
    } else {

    }

  } else
#line 3556
  if (intf->waiting_events_count <= 24U) {
    {
#line 3561
    recv_msg = ipmi_alloc_recv_msg();
    }
#line 3562
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
#line 3568
      rv = 1;
#line 3569
      goto out;
    } else {

    }
    {
#line 3572
    copy_event_into_recv_msg(recv_msg, msg);
#line 3573
    list_add_tail(& recv_msg->link, & intf->waiting_events);
#line 3574
    intf->waiting_events_count = intf->waiting_events_count + 1U;
    }
  } else
#line 3575
  if ((int )((signed char )intf->event_msg_printed) == 0) {
    {
#line 3580
    printk("\fIPMI message handler: Event queue full, discarding incoming events\n");
#line 3582
    intf->event_msg_printed = 1;
    }
  } else {

  }
  out: 
  {
#line 3586
  ldv_spin_unlock_irqrestore_137(& intf->events_lock, flags);
  }
#line 3588
  return (rv);
}
}
#line 3591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_bmc_rsp(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  struct ipmi_recv_msg *recv_msg ;
  struct ipmi_user *user ;
  struct ipmi_system_interface_addr *smi_addr ;

  {
#line 3597
  recv_msg = (struct ipmi_recv_msg *)msg->user_data;
#line 3598
  if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
    {
#line 3599
    printk("\fIPMI message received with no owner. This\ncould be because of a malformed message, or\nbecause of a hardware error.  Contact your\nhardware vender for assistance\n");
    }
#line 3604
    return (0);
  } else {

  }
#line 3607
  user = recv_msg->user;
#line 3609
  if ((unsigned long )user != (unsigned long )((struct ipmi_user *)0) && ! user->valid) {
    {
#line 3611
    atomic_inc((atomic_t *)(& intf->stats) + 3UL);
#line 3612
    ipmi_free_recv_msg(recv_msg);
    }
  } else {
    {
#line 3616
    atomic_inc((atomic_t *)(& intf->stats) + 2UL);
#line 3617
    recv_msg->recv_type = 1;
#line 3618
    recv_msg->msgid = msg->msgid;
#line 3619
    smi_addr = (struct ipmi_system_interface_addr *)(& recv_msg->addr);
#line 3621
    smi_addr->addr_type = 12;
#line 3622
    smi_addr->channel = 15;
#line 3623
    smi_addr->lun = (unsigned int )msg->rsp[0] & 3U;
#line 3624
    recv_msg->msg.netfn = (int )msg->rsp[0] >> 2;
#line 3625
    recv_msg->msg.cmd = msg->rsp[1];
#line 3626
    __memcpy((void *)(& recv_msg->msg_data), (void const   *)(& msg->rsp) + 2U, (size_t )(msg->rsp_size + -2));
#line 3629
    recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3630
    recv_msg->msg.data_len = (unsigned int )((unsigned short )msg->rsp_size) + 65534U;
#line 3631
    deliver_response(recv_msg);
    }
  }
#line 3634
  return (0);
}
}
#line 3642 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int handle_one_recv_msg(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  int requeue ;
  int chan ;
  struct ipmi_recv_msg *recv_msg ;

  {
#line 3655
  if (msg->rsp_size <= 1) {
    {
#line 3657
    printk("\fIPMI message handler: BMC returned to small a message for netfn %x cmd %x, got %d bytes\n",
           (int )((unsigned int )((int )msg->data[0] >> 2) | 1U), (int )msg->data[1],
           msg->rsp_size);
#line 3662
    msg->rsp[0] = (unsigned int )msg->data[0] | 4U;
#line 3663
    msg->rsp[1] = msg->data[1];
#line 3664
    msg->rsp[2] = 255U;
#line 3665
    msg->rsp_size = 3;
    }
  } else
#line 3666
  if ((unsigned int )((int )msg->rsp[0] >> 2) != ((unsigned int )((int )msg->data[0] >> 2) | 1U) || (int )msg->rsp[1] != (int )msg->data[1]) {
    {
#line 3672
    printk("\fIPMI message handler: BMC returned incorrect response, expected netfn %x cmd %x, got netfn %x cmd %x\n",
           (int )((unsigned int )((int )msg->data[0] >> 2) | 1U), (int )msg->data[1],
           (int )msg->rsp[0] >> 2, (int )msg->rsp[1]);
#line 3678
    msg->rsp[0] = (unsigned int )msg->data[0] | 4U;
#line 3679
    msg->rsp[1] = msg->data[1];
#line 3680
    msg->rsp[2] = 255U;
#line 3681
    msg->rsp_size = 3;
    }
  } else {

  }
#line 3684
  if ((unsigned int )*((unsigned short *)msg + 156UL) == 13340U && (unsigned long )msg->user_data != (unsigned long )((void *)0)) {
#line 3691
    recv_msg = (struct ipmi_recv_msg *)msg->user_data;
#line 3693
    requeue = 0;
#line 3694
    if (msg->rsp_size <= 1) {
#line 3696
      goto out;
    } else {

    }
#line 3698
    chan = (int )msg->data[2] & 15;
#line 3699
    if (chan > 15) {
#line 3701
      goto out;
    } else {

    }
#line 3703
    if ((unsigned long )recv_msg == (unsigned long )((struct ipmi_recv_msg *)0)) {
#line 3704
      goto out;
    } else {

    }
#line 3707
    if ((unsigned long )recv_msg->user == (unsigned long )((ipmi_user_t )0) || ! (recv_msg->user)->valid) {
#line 3708
      goto out;
    } else {

    }
    {
#line 3710
    recv_msg->recv_type = 4;
#line 3711
    recv_msg->msg.data = (unsigned char *)(& recv_msg->msg_data);
#line 3712
    recv_msg->msg.data_len = 1U;
#line 3713
    recv_msg->msg_data[0] = msg->rsp[2];
#line 3714
    deliver_response(recv_msg);
    }
  } else
#line 3715
  if ((unsigned int )*((unsigned short *)msg + 156UL) == 13084U) {
#line 3718
    chan = (int )msg->rsp[3] & 15;
#line 3719
    if (chan > 15) {
#line 3721
      requeue = 0;
#line 3722
      goto out;
    } else {

    }
#line 3731
    if (intf->curr_channel <= 15) {
#line 3732
      requeue = 0;
#line 3733
      goto out;
    } else {

    }
    {
#line 3737
    if ((int )intf->channels[chan].medium == 1) {
#line 3737
      goto case_1;
    } else {

    }
#line 3753
    if ((int )intf->channels[chan].medium == 4) {
#line 3753
      goto case_4;
    } else {

    }
#line 3754
    if ((int )intf->channels[chan].medium == 5) {
#line 3754
      goto case_5;
    } else {

    }
#line 3770
    goto switch_default;
    case_1: /* CIL Label */ ;
#line 3738
    if (((int )msg->rsp[4] & 4) != 0) {
      {
#line 3743
      requeue = handle_ipmb_get_msg_rsp(intf, msg);
      }
    } else {
      {
#line 3749
      requeue = handle_ipmb_get_msg_cmd(intf, msg);
      }
    }
#line 3751
    goto ldv_37305;
    case_4: /* CIL Label */ ;
    case_5: /* CIL Label */ ;
#line 3755
    if (((int )msg->rsp[6] & 4) != 0) {
      {
#line 3760
      requeue = handle_lan_get_msg_rsp(intf, msg);
      }
    } else {
      {
#line 3766
      requeue = handle_lan_get_msg_cmd(intf, msg);
      }
    }
#line 3768
    goto ldv_37305;
    switch_default: /* CIL Label */ ;
#line 3773
    if ((unsigned int )intf->channels[chan].medium - 96U <= 31U) {
      {
#line 3777
      requeue = handle_oem_get_msg_cmd(intf, msg);
      }
    } else {
#line 3783
      requeue = 0;
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_37305: ;
  } else
#line 3787
  if ((unsigned int )*((unsigned short *)msg + 156UL) == 13596U) {
    {
#line 3790
    requeue = handle_read_event_rsp(intf, msg);
    }
  } else {
    {
#line 3793
    requeue = handle_bmc_rsp(intf, msg);
    }
  }
  out: ;
#line 3797
  return (requeue);
}
}
#line 3803 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void handle_new_recv_msgs(ipmi_smi_t intf ) 
{ 
  struct ipmi_smi_msg *smi_msg ;
  unsigned long flags ;
  int rv ;
  int run_to_completion ;
  struct list_head  const  *__mptr ;
  int tmp ;
  ipmi_user_t user ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp___0 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3806
  flags = 0UL;
#line 3808
  run_to_completion = intf->run_to_completion;
#line 3811
  if (run_to_completion == 0) {
    {
#line 3812
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_178(& intf->waiting_rcv_msgs_lock);
    }
  } else {

  }
#line 3813
  goto ldv_37320;
  ldv_37319: 
#line 3814
  __mptr = (struct list_head  const  *)intf->waiting_rcv_msgs.next;
#line 3814
  smi_msg = (struct ipmi_smi_msg *)__mptr;
#line 3816
  if (run_to_completion == 0) {
    {
#line 3817
    ldv_spin_unlock_irqrestore_179(& intf->waiting_rcv_msgs_lock, flags);
    }
  } else {

  }
  {
#line 3819
  rv = handle_one_recv_msg(intf, smi_msg);
  }
#line 3820
  if (run_to_completion == 0) {
    {
#line 3821
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_180(& intf->waiting_rcv_msgs_lock);
    }
  } else {

  }
#line 3822
  if (rv > 0) {
#line 3827
    goto ldv_37318;
  } else {
    {
#line 3829
    list_del(& smi_msg->link);
    }
#line 3830
    if (rv == 0) {
      {
#line 3832
      ipmi_free_smi_msg(smi_msg);
      }
    } else {

    }
  }
  ldv_37320: 
  {
#line 3813
  tmp = list_empty((struct list_head  const  *)(& intf->waiting_rcv_msgs));
  }
#line 3813
  if (tmp == 0) {
#line 3815
    goto ldv_37319;
  } else {

  }
  ldv_37318: ;
#line 3836
  if (run_to_completion == 0) {
    {
#line 3837
    ldv_spin_unlock_irqrestore_179(& intf->waiting_rcv_msgs_lock, flags);
    }
  } else {

  }
  {
#line 3843
  tmp___2 = atomic_add_unless(& intf->watchdog_pretimeouts_to_deliver, -1, 0);
  }
#line 3843
  if (tmp___2 != 0) {
    {
#line 3846
    rcu_read_lock();
#line 3847
    __ptr = intf->users.next;
#line 3847
    __var = (struct list_head *)0;
#line 3847
    _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 3847
    ________p1 = _________p1;
#line 3847
    tmp___0 = debug_lockdep_rcu_enabled();
    }
#line 3847
    if (tmp___0 != 0 && ! __warned) {
      {
#line 3847
      rcu_read_lock_held();
      }
    } else {

    }
#line 3847
    __mptr___0 = (struct list_head  const  *)________p1;
#line 3847
    user = (struct ipmi_user *)__mptr___0;
#line 3847
    goto ldv_37345;
    ldv_37344: ;
#line 3848
    if ((unsigned long )(user->handler)->ipmi_watchdog_pretimeout != (unsigned long )((void (*)(void * ))0)) {
      {
#line 3849
      (*((user->handler)->ipmi_watchdog_pretimeout))(user->handler_data);
      }
    } else {

    }
    {
#line 3847
    __ptr___0 = user->link.next;
#line 3847
    __var___0 = (struct list_head *)0;
#line 3847
    _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 3847
    ________p1___0 = _________p1___0;
#line 3847
    tmp___1 = debug_lockdep_rcu_enabled();
    }
#line 3847
    if (tmp___1 != 0 && ! __warned___0) {
      {
#line 3847
      rcu_read_lock_held();
      }
    } else {

    }
#line 3847
    __mptr___1 = (struct list_head  const  *)________p1___0;
#line 3847
    user = (struct ipmi_user *)__mptr___1;
    ldv_37345: ;
#line 3847
    if ((unsigned long )(& user->link) != (unsigned long )(& intf->users)) {
#line 3849
      goto ldv_37344;
    } else {

    }
    {
#line 3852
    rcu_read_unlock();
    }
  } else {

  }
#line 3854
  return;
}
}
#line 3856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void smi_recv_tasklet(unsigned long val ) 
{ 
  unsigned long flags ;
  ipmi_smi_t intf ;
  int run_to_completion ;
  struct ipmi_smi_msg *newmsg ;
  struct list_head *entry ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;

  {
#line 3858
  flags = 0UL;
#line 3859
  intf = (struct ipmi_smi *)val;
#line 3860
  run_to_completion = intf->run_to_completion;
#line 3861
  newmsg = (struct ipmi_smi_msg *)0;
#line 3870
  if (run_to_completion == 0) {
    {
#line 3871
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_182(& intf->xmit_msgs_lock);
    }
  } else {

  }
#line 3872
  if ((unsigned long )intf->curr_msg == (unsigned long )((struct ipmi_smi_msg *)0) && ! intf->in_shutdown) {
    {
#line 3873
    entry = (struct list_head *)0;
#line 3876
    tmp___0 = list_empty((struct list_head  const  *)(& intf->hp_xmit_msgs));
    }
#line 3876
    if (tmp___0 == 0) {
#line 3877
      entry = intf->hp_xmit_msgs.next;
    } else {
      {
#line 3878
      tmp = list_empty((struct list_head  const  *)(& intf->xmit_msgs));
      }
#line 3878
      if (tmp == 0) {
#line 3879
        entry = intf->xmit_msgs.next;
      } else {

      }
    }
#line 3881
    if ((unsigned long )entry != (unsigned long )((struct list_head *)0)) {
      {
#line 3882
      list_del(entry);
#line 3883
      __mptr = (struct list_head  const  *)entry;
#line 3883
      newmsg = (struct ipmi_smi_msg *)__mptr;
#line 3884
      intf->curr_msg = newmsg;
      }
    } else {

    }
  } else {

  }
#line 3887
  if (run_to_completion == 0) {
    {
#line 3888
    ldv_spin_unlock_irqrestore_145(& intf->xmit_msgs_lock, flags);
    }
  } else {

  }
#line 3889
  if ((unsigned long )newmsg != (unsigned long )((struct ipmi_smi_msg *)0)) {
    {
#line 3890
    (*((intf->handlers)->sender))(intf->send_info, newmsg);
    }
  } else {

  }
  {
#line 3892
  handle_new_recv_msgs(intf);
  }
#line 3893
  return;
}
}
#line 3896 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
void ipmi_smi_msg_received(ipmi_smi_t intf , struct ipmi_smi_msg *msg ) 
{ 
  unsigned long flags ;
  int run_to_completion ;
  int chan ;

  {
#line 3899
  flags = 0UL;
#line 3900
  run_to_completion = intf->run_to_completion;
#line 3902
  if ((msg->data_size > 1 && (unsigned int )*((unsigned short *)msg + 18UL) == 13336U) && (unsigned long )msg->user_data == (unsigned long )((void *)0)) {
#line 3907
    if ((int )intf->in_shutdown) {
#line 3908
      goto free_msg;
    } else {

    }
#line 3923
    if (((((msg->rsp_size > 2 && (unsigned int )msg->rsp[2] != 0U) && (unsigned int )msg->rsp[2] != 192U) && (unsigned int )msg->rsp[2] != 129U) && (unsigned int )msg->rsp[2] != 130U) && (unsigned int )msg->rsp[2] != 131U) {
#line 3928
      chan = (int )msg->rsp[3] & 15;
#line 3931
      if (chan > 15) {

      } else
#line 3933
      if ((unsigned int )intf->channels[chan].medium - 4U <= 1U) {
        {
#line 3937
        atomic_inc((atomic_t *)(& intf->stats) + 14UL);
        }
      } else {
        {
#line 3939
        atomic_inc((atomic_t *)(& intf->stats) + 5UL);
        }
      }
      {
#line 3940
      intf_err_seq(intf, msg->msgid, (unsigned int )msg->rsp[2]);
      }
    } else {
      {
#line 3943
      intf_start_seq_timer(intf, msg->msgid);
      }
    }
    free_msg: 
    {
#line 3946
    ipmi_free_smi_msg(msg);
    }
  } else {
#line 3952
    if (run_to_completion == 0) {
      {
#line 3953
      ldv___ldv_linux_kernel_locking_spinlock_spin_lock_184(& intf->waiting_rcv_msgs_lock);
      }
    } else {

    }
    {
#line 3954
    list_add_tail(& msg->link, & intf->waiting_rcv_msgs);
    }
#line 3955
    if (run_to_completion == 0) {
      {
#line 3956
      ldv_spin_unlock_irqrestore_179(& intf->waiting_rcv_msgs_lock, flags);
      }
    } else {

    }
  }
#line 3960
  if (run_to_completion == 0) {
    {
#line 3961
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_186(& intf->xmit_msgs_lock);
    }
  } else {

  }
#line 3962
  if ((unsigned long )msg == (unsigned long )intf->curr_msg) {
#line 3963
    intf->curr_msg = (struct ipmi_smi_msg *)0;
  } else {

  }
#line 3964
  if (run_to_completion == 0) {
    {
#line 3965
    ldv_spin_unlock_irqrestore_145(& intf->xmit_msgs_lock, flags);
    }
  } else {

  }
#line 3967
  if (run_to_completion != 0) {
    {
#line 3968
    smi_recv_tasklet((unsigned long )intf);
    }
  } else {
    {
#line 3970
    tasklet_schedule(& intf->recv_tasklet);
    }
  }
#line 3971
  return;
}
}
#line 3972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_smi_msg_received[22U]  = 
#line 3972
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'm',      'i', 
        '_',      'm',      's',      'g', 
        '_',      'r',      'e',      'c', 
        'e',      'i',      'v',      'e', 
        'd',      '\000'};
#line 3972
struct kernel_symbol  const  __ksymtab_ipmi_smi_msg_received ;
#line 3972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_smi_msg_received  =    {(unsigned long )(& ipmi_smi_msg_received), (char const   *)(& __kstrtab_ipmi_smi_msg_received)};
#line 3974 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
void ipmi_smi_watchdog_pretimeout(ipmi_smi_t intf ) 
{ 


  {
#line 3976
  if ((int )intf->in_shutdown) {
#line 3977
    return;
  } else {

  }
  {
#line 3979
  atomic_set(& intf->watchdog_pretimeouts_to_deliver, 1);
#line 3980
  tasklet_schedule(& intf->recv_tasklet);
  }
#line 3981
  return;
}
}
#line 3982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_smi_watchdog_pretimeout[29U]  = 
#line 3982
  {      'i',      'p',      'm',      'i', 
        '_',      's',      'm',      'i', 
        '_',      'w',      'a',      't', 
        'c',      'h',      'd',      'o', 
        'g',      '_',      'p',      'r', 
        'e',      't',      'i',      'm', 
        'e',      'o',      'u',      't', 
        '\000'};
#line 3982
struct kernel_symbol  const  __ksymtab_ipmi_smi_watchdog_pretimeout ;
#line 3982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_smi_watchdog_pretimeout  =    {(unsigned long )(& ipmi_smi_watchdog_pretimeout), (char const   *)(& __kstrtab_ipmi_smi_watchdog_pretimeout)};
#line 3985 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct ipmi_smi_msg *smi_from_recv_msg(ipmi_smi_t intf , struct ipmi_recv_msg *recv_msg ,
                                              unsigned char seq , long seqid ) 
{ 
  struct ipmi_smi_msg *smi_msg ;
  struct ipmi_smi_msg *tmp ;

  {
  {
#line 3988
  tmp = ipmi_alloc_smi_msg();
#line 3988
  smi_msg = tmp;
  }
#line 3989
  if ((unsigned long )smi_msg == (unsigned long )((struct ipmi_smi_msg *)0)) {
#line 3994
    return ((struct ipmi_smi_msg *)0);
  } else {

  }
  {
#line 3996
  __memcpy((void *)(& smi_msg->data), (void const   *)recv_msg->msg.data, (size_t )recv_msg->msg.data_len);
#line 3997
  smi_msg->data_size = (int )recv_msg->msg.data_len;
#line 3998
  smi_msg->msgid = (long )((int )seq << 26) | (seqid & 67108863L);
  }
#line 4009
  return (smi_msg);
}
}
#line 4012 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void check_msg_timeout(ipmi_smi_t intf , struct seq_table *ent , struct list_head *timeouts ,
                              long timeout_period , int slot , unsigned long *flags ,
                              unsigned int *waiting_msgs ) 
{ 
  struct ipmi_recv_msg *msg ;
  struct ipmi_smi_handlers *handlers ;
  int tmp ;
  struct ipmi_smi_msg *smi_msg ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4020
  if ((int )intf->in_shutdown) {
#line 4021
    return;
  } else {

  }
#line 4023
  if ((unsigned int )*((unsigned char *)ent + 0UL) == 0U) {
#line 4024
    return;
  } else {

  }
#line 4026
  ent->timeout = ent->timeout - (unsigned long )timeout_period;
#line 4027
  if (ent->timeout != 0UL) {
#line 4028
    *waiting_msgs = *waiting_msgs + 1U;
#line 4029
    return;
  } else {

  }
#line 4032
  if (ent->retries_left == 0U) {
    {
#line 4034
    ent->inuse = 0U;
#line 4035
    msg = ent->recv_msg;
#line 4036
    list_add_tail(& msg->link, timeouts);
    }
#line 4037
    if ((unsigned int )*((unsigned char *)ent + 0UL) != 0U) {
      {
#line 4038
      atomic_inc((atomic_t *)(& intf->stats) + 8UL);
      }
    } else {
      {
#line 4039
      tmp = is_lan_addr(& (ent->recv_msg)->addr);
      }
#line 4039
      if (tmp != 0) {
        {
#line 4040
        atomic_inc((atomic_t *)(& intf->stats) + 16UL);
        }
      } else {
        {
#line 4042
        atomic_inc((atomic_t *)(& intf->stats) + 7UL);
        }
      }
    }
  } else {
    {
#line 4047
    *waiting_msgs = *waiting_msgs + 1U;
#line 4053
    ent->timeout = 60000UL;
#line 4054
    ent->retries_left = ent->retries_left - 1U;
#line 4055
    smi_msg = smi_from_recv_msg(intf, ent->recv_msg, (int )((unsigned char )slot),
                                ent->seqid);
    }
#line 4057
    if ((unsigned long )smi_msg == (unsigned long )((struct ipmi_smi_msg *)0)) {
      {
#line 4058
      tmp___0 = is_lan_addr(& (ent->recv_msg)->addr);
      }
#line 4058
      if (tmp___0 != 0) {
        {
#line 4059
        atomic_inc((atomic_t *)(& intf->stats) + 27UL);
        }
      } else {
        {
#line 4062
        atomic_inc((atomic_t *)(& intf->stats) + 26UL);
        }
      }
#line 4064
      return;
    } else {

    }
    {
#line 4067
    ldv_spin_unlock_irqrestore_110(& intf->seq_lock, *flags);
#line 4076
    handlers = intf->handlers;
    }
#line 4077
    if ((unsigned long )handlers != (unsigned long )((struct ipmi_smi_handlers *)0)) {
      {
#line 4078
      tmp___1 = is_lan_addr(& (ent->recv_msg)->addr);
      }
#line 4078
      if (tmp___1 != 0) {
        {
#line 4079
        atomic_inc((atomic_t *)(& intf->stats) + 15UL);
        }
      } else {
        {
#line 4082
        atomic_inc((atomic_t *)(& intf->stats) + 6UL);
        }
      }
      {
#line 4085
      smi_send(intf, intf->handlers, smi_msg, 0);
      }
    } else {
      {
#line 4087
      ipmi_free_smi_msg(smi_msg);
      }
    }
    {
#line 4089
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_189(& intf->seq_lock);
    }
  }
#line 4091
  return;
}
}
#line 4093 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static unsigned int ipmi_timeout_handler(ipmi_smi_t intf , long timeout_period ) 
{ 
  struct list_head timeouts ;
  struct ipmi_recv_msg *msg ;
  struct ipmi_recv_msg *msg2 ;
  unsigned long flags ;
  int i ;
  unsigned int waiting_msgs ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
#line 4099
  waiting_msgs = 0U;
#line 4106
  INIT_LIST_HEAD(& timeouts);
#line 4107
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_190(& intf->seq_lock);
#line 4108
  i = 0;
  }
#line 4108
  goto ldv_37413;
  ldv_37412: 
  {
#line 4109
  check_msg_timeout(intf, (struct seq_table *)(& intf->seq_table) + (unsigned long )i,
                    & timeouts, timeout_period, i, & flags, & waiting_msgs);
#line 4108
  i = i + 1;
  }
  ldv_37413: ;
#line 4108
  if (i <= 63) {
#line 4110
    goto ldv_37412;
  } else {

  }
  {
#line 4112
  ldv_spin_unlock_irqrestore_110(& intf->seq_lock, flags);
#line 4114
  __mptr = (struct list_head  const  *)timeouts.next;
#line 4114
  msg = (struct ipmi_recv_msg *)__mptr;
#line 4114
  __mptr___0 = (struct list_head  const  *)msg->link.next;
#line 4114
  msg2 = (struct ipmi_recv_msg *)__mptr___0;
  }
#line 4114
  goto ldv_37422;
  ldv_37421: 
  {
#line 4115
  deliver_err_response(msg, 195);
#line 4114
  msg = msg2;
#line 4114
  __mptr___1 = (struct list_head  const  *)msg2->link.next;
#line 4114
  msg2 = (struct ipmi_recv_msg *)__mptr___1;
  }
  ldv_37422: ;
#line 4114
  if ((unsigned long )(& msg->link) != (unsigned long )(& timeouts)) {
#line 4116
    goto ldv_37421;
  } else {

  }

#line 4125
  if (intf->auto_maintenance_timeout > 0) {
    {
#line 4126
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_192(& intf->maintenance_mode_lock);
    }
#line 4127
    if (intf->auto_maintenance_timeout > 0) {
#line 4129
      intf->auto_maintenance_timeout = (int )((unsigned int )intf->auto_maintenance_timeout - (unsigned int )timeout_period);
#line 4130
      if (intf->maintenance_mode == 0 && intf->auto_maintenance_timeout <= 0) {
        {
#line 4132
        intf->maintenance_mode_enable = 0;
#line 4133
        maintenance_mode_update(intf);
        }
      } else {

      }
    } else {

    }
    {
#line 4136
    ldv_spin_unlock_irqrestore_133(& intf->maintenance_mode_lock, flags);
    }
  } else {

  }
  {
#line 4140
  tasklet_schedule(& intf->recv_tasklet);
  }
#line 4142
  return (waiting_msgs);
}
}
#line 4145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void ipmi_request_event(ipmi_smi_t intf ) 
{ 


  {
#line 4148
  if ((int )intf->maintenance_mode_enable) {
#line 4149
    return;
  } else {

  }
#line 4151
  if (! intf->in_shutdown) {
    {
#line 4152
    (*((intf->handlers)->request_events))(intf->send_info);
    }
  } else {

  }
#line 4153
  return;
}
}
#line 4155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct timer_list ipmi_timer  ;
#line 4157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static atomic_t stop_operation  ;
#line 4159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void ipmi_timeout(unsigned long data ) 
{ 
  ipmi_smi_t intf ;
  int nt ;
  int tmp ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp___0 ;
  int lnt ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___3 ;

  {
  {
#line 4162
  nt = 0;
#line 4164
  tmp = atomic_read((atomic_t const   *)(& stop_operation));
  }
#line 4164
  if (tmp != 0) {
#line 4165
    return;
  } else {

  }
  {
#line 4167
  rcu_read_lock();
#line 4168
  __ptr = ipmi_interfaces.next;
#line 4168
  __var = (struct list_head *)0;
#line 4168
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 4168
  ________p1 = _________p1;
#line 4168
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 4168
  if (tmp___0 != 0 && ! __warned) {
    {
#line 4168
    rcu_read_lock_held();
    }
  } else {

  }
#line 4168
  __mptr = (struct list_head  const  *)________p1;
#line 4168
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 4168
  goto ldv_37458;
  ldv_37457: 
  {
#line 4169
  lnt = 0;
#line 4171
  tmp___1 = atomic_read((atomic_t const   *)(& intf->event_waiters));
  }
#line 4171
  if (tmp___1 != 0) {
#line 4172
    intf->ticks_to_req_ev = intf->ticks_to_req_ev - 1U;
#line 4173
    if (intf->ticks_to_req_ev == 0U) {
      {
#line 4174
      ipmi_request_event(intf);
#line 4175
      intf->ticks_to_req_ev = 1U;
      }
    } else {

    }
#line 4177
    lnt = lnt + 1;
  } else {

  }
  {
#line 4180
  tmp___2 = ipmi_timeout_handler(intf, 1000L);
#line 4180
  lnt = (int )((unsigned int )lnt + tmp___2);
#line 4182
  lnt = lnt != 0;
  }
#line 4183
  if (lnt != intf->last_needs_timer && (unsigned long )(intf->handlers)->set_need_watch != (unsigned long )((void (*)(void * ,
                                                                                                                      bool  ))0)) {
    {
#line 4185
    (*((intf->handlers)->set_need_watch))(intf->send_info, lnt != 0);
    }
  } else {

  }
  {
#line 4186
  intf->last_needs_timer = lnt;
#line 4188
  nt = nt + lnt;
#line 4168
  __ptr___0 = intf->link.next;
#line 4168
  __var___0 = (struct list_head *)0;
#line 4168
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 4168
  ________p1___0 = _________p1___0;
#line 4168
  tmp___3 = debug_lockdep_rcu_enabled();
  }
#line 4168
  if (tmp___3 != 0 && ! __warned___0) {
    {
#line 4168
    rcu_read_lock_held();
    }
  } else {

  }
#line 4168
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 4168
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_37458: ;
#line 4168
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 4170
    goto ldv_37457;
  } else {

  }
  {
#line 4190
  rcu_read_unlock();
  }
#line 4192
  if (nt != 0) {
    {
#line 4193
    ldv_mod_timer_194(& ipmi_timer, (unsigned long )jiffies + 250UL);
    }
  } else {

  }
#line 4194
  return;
}
}
#line 4196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void need_waiter(ipmi_smi_t intf ) 
{ 
  int tmp ;

  {
  {
#line 4199
  tmp = timer_pending((struct timer_list  const  *)(& ipmi_timer));
  }
#line 4199
  if (tmp == 0) {
    {
#line 4200
    ldv_mod_timer_195(& ipmi_timer, (unsigned long )jiffies + 250UL);
    }
  } else {

  }
#line 4201
  return;
}
}
#line 4203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static atomic_t smi_msg_inuse_count  =    {0};
#line 4204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static atomic_t recv_msg_inuse_count  =    {0};
#line 4206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void free_smi_msg(struct ipmi_smi_msg *msg ) 
{ 


  {
  {
#line 4208
  atomic_dec(& smi_msg_inuse_count);
#line 4209
  kfree((void const   *)msg);
  }
#line 4210
  return;
}
}
#line 4212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct ipmi_smi_msg *ipmi_alloc_smi_msg(void) 
{ 
  struct ipmi_smi_msg *rv ;
  void *tmp ;

  {
  {
#line 4215
  tmp = kmalloc(592UL, 32U);
#line 4215
  rv = (struct ipmi_smi_msg *)tmp;
  }
#line 4216
  if ((unsigned long )rv != (unsigned long )((struct ipmi_smi_msg *)0)) {
    {
#line 4217
    rv->done = & free_smi_msg;
#line 4218
    rv->user_data = (void *)0;
#line 4219
    atomic_inc(& smi_msg_inuse_count);
    }
  } else {

  }
#line 4221
  return (rv);
}
}
#line 4223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_alloc_smi_msg[19U]  = 
#line 4223
  {      'i',      'p',      'm',      'i', 
        '_',      'a',      'l',      'l', 
        'o',      'c',      '_',      's', 
        'm',      'i',      '_',      'm', 
        's',      'g',      '\000'};
#line 4223
struct kernel_symbol  const  __ksymtab_ipmi_alloc_smi_msg ;
#line 4223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_alloc_smi_msg  =    {(unsigned long )(& ipmi_alloc_smi_msg), (char const   *)(& __kstrtab_ipmi_alloc_smi_msg)};
#line 4225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void free_recv_msg(struct ipmi_recv_msg *msg ) 
{ 


  {
  {
#line 4227
  atomic_dec(& recv_msg_inuse_count);
#line 4228
  kfree((void const   *)msg);
  }
#line 4229
  return;
}
}
#line 4231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void) 
{ 
  struct ipmi_recv_msg *rv ;
  void *tmp ;

  {
  {
#line 4235
  tmp = kmalloc(384UL, 32U);
#line 4235
  rv = (struct ipmi_recv_msg *)tmp;
  }
#line 4236
  if ((unsigned long )rv != (unsigned long )((struct ipmi_recv_msg *)0)) {
    {
#line 4237
    rv->user = (ipmi_user_t )0;
#line 4238
    rv->done = & free_recv_msg;
#line 4239
    atomic_inc(& recv_msg_inuse_count);
    }
  } else {

  }
#line 4241
  return (rv);
}
}
#line 4244 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
void ipmi_free_recv_msg(struct ipmi_recv_msg *msg ) 
{ 


  {
#line 4246
  if ((unsigned long )msg->user != (unsigned long )((ipmi_user_t )0)) {
    {
#line 4247
    kref_put(& (msg->user)->refcount, & free_user);
    }
  } else {

  }
  {
#line 4248
  (*(msg->done))(msg);
  }
#line 4249
  return;
}
}
#line 4250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static char const   __kstrtab_ipmi_free_recv_msg[19U]  = 
#line 4250
  {      'i',      'p',      'm',      'i', 
        '_',      'f',      'r',      'e', 
        'e',      '_',      'r',      'e', 
        'c',      'v',      '_',      'm', 
        's',      'g',      '\000'};
#line 4250
struct kernel_symbol  const  __ksymtab_ipmi_free_recv_msg ;
#line 4250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
struct kernel_symbol  const  __ksymtab_ipmi_free_recv_msg  =    {(unsigned long )(& ipmi_free_recv_msg), (char const   *)(& __kstrtab_ipmi_free_recv_msg)};
#line 4254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static atomic_t panic_done_count  =    {0};
#line 4256 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void dummy_smi_done_handler(struct ipmi_smi_msg *msg ) 
{ 


  {
  {
#line 4258
  atomic_dec(& panic_done_count);
  }
#line 4259
  return;
}
}
#line 4261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void dummy_recv_done_handler(struct ipmi_recv_msg *msg ) 
{ 


  {
  {
#line 4263
  atomic_dec(& panic_done_count);
  }
#line 4264
  return;
}
}
#line 4269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void ipmi_panic_request_and_wait(ipmi_smi_t intf , struct ipmi_addr *addr ,
                                        struct kernel_ipmi_msg *msg ) 
{ 
  struct ipmi_smi_msg smi_msg ;
  struct ipmi_recv_msg recv_msg ;
  int rv ;
  int tmp ;

  {
  {
#line 4277
  smi_msg.done = & dummy_smi_done_handler;
#line 4278
  recv_msg.done = & dummy_recv_done_handler;
#line 4279
  atomic_add(2, & panic_done_count);
#line 4280
  rv = i_ipmi_request((ipmi_user_t )0, intf, addr, 0L, msg, (void *)intf, (void *)(& smi_msg),
                      & recv_msg, 0, (int )intf->channels[0].address, (int )intf->channels[0].lun,
                      0, 1U);
  }
#line 4292
  if (rv != 0) {
    {
#line 4293
    atomic_sub(2, & panic_done_count);
    }
  } else {

  }
#line 4294
  goto ldv_37511;
  ldv_37510: 
  {
#line 4295
  ipmi_poll(intf);
  }
  ldv_37511: 
  {
#line 4294
  tmp = atomic_read((atomic_t const   *)(& panic_done_count));
  }
#line 4294
  if (tmp != 0) {
#line 4296
    goto ldv_37510;
  } else {

  }

#line 4301
  return;
}
}
#line 4299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void event_receiver_fetcher(ipmi_smi_t intf , struct ipmi_recv_msg *msg ) 
{ 


  {
#line 4301
  if ((msg->addr.addr_type == 12 && (unsigned int )*((unsigned short *)msg + 40UL) == 261U) && (unsigned int )*(msg->msg.data) == 0U) {
#line 4306
    intf->event_receiver = *(msg->msg.data + 1UL);
#line 4307
    intf->event_receiver_lun = (unsigned int )*(msg->msg.data + 2UL) & 3U;
  } else {

  }
#line 4309
  return;
}
}
#line 4311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void device_id_fetcher(ipmi_smi_t intf , struct ipmi_recv_msg *msg ) 
{ 


  {
#line 4313
  if ((msg->addr.addr_type == 12 && (unsigned int )*((unsigned short *)msg + 40UL) == 263U) && (unsigned int )*(msg->msg.data) == 0U) {
#line 4321
    intf->local_sel_device = (unsigned int )((int )*(msg->msg.data + 6UL) >> 2) & 1U;
#line 4322
    intf->local_event_generator = (unsigned int )((int )*(msg->msg.data + 6UL) >> 5) & 1U;
  } else {

  }
#line 4324
  return;
}
}
#line 4327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void send_panic_events(char *str ) 
{ 
  struct kernel_ipmi_msg msg ;
  ipmi_smi_t intf ;
  unsigned char data[16U] ;
  struct ipmi_system_interface_addr *si ;
  struct ipmi_addr addr ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;
  struct list_head *__ptr___1 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *________p1___1 ;
  struct list_head *_________p1___1 ;
  struct list_head *__var___1 ;
  bool __warned___1 ;
  int tmp___1 ;
  char *p ;
  struct ipmi_ipmb_addr *ipmb ;
  int j ;
  int size ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct list_head *__ptr___2 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head *________p1___2 ;
  struct list_head *_________p1___2 ;
  struct list_head *__var___2 ;
  bool __warned___2 ;
  int tmp___4 ;

  {
#line 4335
  si = (struct ipmi_system_interface_addr *)(& addr);
#line 4336
  si->addr_type = 12;
#line 4337
  si->channel = 15;
#line 4338
  si->lun = 0U;
#line 4341
  msg.netfn = 4U;
#line 4342
  msg.cmd = 2U;
#line 4343
  msg.data = (unsigned char *)(& data);
#line 4344
  msg.data_len = 8U;
#line 4345
  data[0] = 65U;
#line 4346
  data[1] = 3U;
#line 4347
  data[2] = 32U;
#line 4348
  data[4] = 111U;
#line 4349
  data[5] = 161U;
#line 4355
  if ((unsigned long )str != (unsigned long )((char *)0)) {
#line 4356
    data[3] = (unsigned char )*str;
#line 4357
    data[6] = (unsigned char )*(str + 1UL);
#line 4358
    data[7] = (unsigned char )*(str + 2UL);
  } else {

  }
  {
#line 4362
  __ptr = ipmi_interfaces.next;
#line 4362
  __var = (struct list_head *)0;
#line 4362
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 4362
  ________p1 = _________p1;
#line 4362
  tmp = debug_lockdep_rcu_enabled();
  }
#line 4362
  if (tmp != 0 && ! __warned) {
    {
#line 4362
    rcu_read_lock_held();
    }
  } else {

  }
#line 4362
  __mptr = (struct list_head  const  *)________p1;
#line 4362
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 4362
  goto ldv_37553;
  ldv_37552: ;
#line 4363
  if ((unsigned long )intf->handlers == (unsigned long )((struct ipmi_smi_handlers *)0)) {
#line 4365
    goto ldv_37551;
  } else {

  }
  {
#line 4367
  intf->run_to_completion = 1;
#line 4369
  (*((intf->handlers)->set_run_to_completion))(intf->send_info, 1);
#line 4370
  ipmi_panic_request_and_wait(intf, & addr, & msg);
  }
  ldv_37551: 
  {
#line 4362
  __ptr___0 = intf->link.next;
#line 4362
  __var___0 = (struct list_head *)0;
#line 4362
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 4362
  ________p1___0 = _________p1___0;
#line 4362
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 4362
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 4362
    rcu_read_lock_held();
    }
  } else {

  }
#line 4362
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 4362
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_37553: ;
#line 4362
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 4364
    goto ldv_37552;
  } else {

  }

#line 4378
  if ((unsigned long )str == (unsigned long )((char *)0)) {
#line 4379
    return;
  } else {

  }
  {
#line 4382
  __ptr___1 = ipmi_interfaces.next;
#line 4382
  __var___1 = (struct list_head *)0;
#line 4382
  _________p1___1 = *((struct list_head * volatile  *)(& __ptr___1));
#line 4382
  ________p1___1 = _________p1___1;
#line 4382
  tmp___1 = debug_lockdep_rcu_enabled();
  }
#line 4382
  if (tmp___1 != 0 && ! __warned___1) {
    {
#line 4382
    rcu_read_lock_held();
    }
  } else {

  }
#line 4382
  __mptr___1 = (struct list_head  const  *)________p1___1;
#line 4382
  intf = (struct ipmi_smi *)__mptr___1 + 0xfffffffffffffff0UL;
#line 4382
  goto ldv_37586;
  ldv_37585: 
#line 4383
  p = str;
#line 4387
  if (intf->intf_num == -1) {
#line 4389
    goto ldv_37580;
  } else {

  }
  {
#line 4397
  __asm__  volatile   ("": : : "memory");
#line 4408
  intf->local_sel_device = 0U;
#line 4409
  intf->local_event_generator = 0U;
#line 4410
  intf->event_receiver = 0U;
#line 4413
  msg.netfn = 6U;
#line 4414
  msg.cmd = 1U;
#line 4415
  msg.data = (unsigned char *)0U;
#line 4416
  msg.data_len = 0U;
#line 4417
  intf->null_user_handler = & device_id_fetcher;
#line 4418
  ipmi_panic_request_and_wait(intf, & addr, & msg);
  }
#line 4420
  if ((unsigned int )intf->local_event_generator != 0U) {
    {
#line 4422
    msg.netfn = 4U;
#line 4423
    msg.cmd = 1U;
#line 4424
    msg.data = (unsigned char *)0U;
#line 4425
    msg.data_len = 0U;
#line 4426
    intf->null_user_handler = & event_receiver_fetcher;
#line 4427
    ipmi_panic_request_and_wait(intf, & addr, & msg);
    }
  } else {

  }
#line 4429
  intf->null_user_handler = (void (*)(ipmi_smi_t  , struct ipmi_recv_msg * ))0;
#line 4436
  if ((((int )intf->event_receiver & 1) == 0 && (unsigned int )intf->event_receiver != 0U) && (int )intf->event_receiver != (int )intf->channels[0].address) {
#line 4443
    ipmb = (struct ipmi_ipmb_addr *)(& addr);
#line 4444
    ipmb->addr_type = 1;
#line 4445
    ipmb->channel = 0;
#line 4446
    ipmb->lun = intf->event_receiver_lun;
#line 4447
    ipmb->slave_addr = intf->event_receiver;
  } else
#line 4448
  if ((unsigned int )intf->local_sel_device != 0U) {
#line 4454
    si = (struct ipmi_system_interface_addr *)(& addr);
#line 4455
    si->addr_type = 12;
#line 4456
    si->channel = 15;
#line 4457
    si->lun = 0U;
  } else {
#line 4459
    goto ldv_37580;
  }
#line 4461
  msg.netfn = 10U;
#line 4462
  msg.cmd = 68U;
#line 4463
  msg.data = (unsigned char *)(& data);
#line 4464
  msg.data_len = 16U;
#line 4466
  j = 0;
#line 4467
  goto ldv_37583;
  ldv_37582: 
  {
#line 4468
  tmp___2 = strlen((char const   *)p);
#line 4468
  size = (int )tmp___2;
  }
#line 4470
  if (size > 11) {
#line 4471
    size = 11;
  } else {

  }
  {
#line 4472
  data[0] = 0U;
#line 4473
  data[1] = 0U;
#line 4474
  data[2] = 240U;
#line 4475
  data[3] = intf->channels[0].address;
#line 4476
  tmp___3 = j;
#line 4476
  j = j + 1;
#line 4476
  data[4] = (unsigned char )tmp___3;
#line 4481
  strncpy((char *)(& data) + 5U, (char const   *)p, 11UL);
#line 4482
  p = p + (unsigned long )size;
#line 4484
  ipmi_panic_request_and_wait(intf, & addr, & msg);
  }
  ldv_37583: ;
#line 4467
  if ((int )((signed char )*p) != 0) {
#line 4469
    goto ldv_37582;
  } else {

  }

  ldv_37580: 
  {
#line 4382
  __ptr___2 = intf->link.next;
#line 4382
  __var___2 = (struct list_head *)0;
#line 4382
  _________p1___2 = *((struct list_head * volatile  *)(& __ptr___2));
#line 4382
  ________p1___2 = _________p1___2;
#line 4382
  tmp___4 = debug_lockdep_rcu_enabled();
  }
#line 4382
  if (tmp___4 != 0 && ! __warned___2) {
    {
#line 4382
    rcu_read_lock_held();
    }
  } else {

  }
#line 4382
  __mptr___2 = (struct list_head  const  *)________p1___2;
#line 4382
  intf = (struct ipmi_smi *)__mptr___2 + 0xfffffffffffffff0UL;
  ldv_37586: ;
#line 4382
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 4384
    goto ldv_37585;
  } else {

  }

#line 4389
  return;
}
}
#line 4491 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int has_panicked  ;
#line 4493 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int panic_event(struct notifier_block *this , unsigned long event , void *ptr ) 
{ 
  ipmi_smi_t intf ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  struct list_head *__var ;
  bool __warned ;
  int tmp ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  struct list_head *__var___0 ;
  bool __warned___0 ;
  int tmp___0 ;

  {
#line 4499
  if (has_panicked != 0) {
#line 4500
    return (0);
  } else {

  }
  {
#line 4501
  has_panicked = 1;
#line 4504
  __ptr = ipmi_interfaces.next;
#line 4504
  __var = (struct list_head *)0;
#line 4504
  _________p1 = *((struct list_head * volatile  *)(& __ptr));
#line 4504
  ________p1 = _________p1;
#line 4504
  tmp = debug_lockdep_rcu_enabled();
  }
#line 4504
  if (tmp != 0 && ! __warned) {
    {
#line 4504
    rcu_read_lock_held();
    }
  } else {

  }
#line 4504
  __mptr = (struct list_head  const  *)________p1;
#line 4504
  intf = (struct ipmi_smi *)__mptr + 0xfffffffffffffff0UL;
#line 4504
  goto ldv_37619;
  ldv_37618: ;
#line 4505
  if ((unsigned long )intf->handlers == (unsigned long )((struct ipmi_smi_handlers *)0)) {
#line 4507
    goto ldv_37617;
  } else {

  }
  {
#line 4509
  intf->run_to_completion = 1;
#line 4510
  (*((intf->handlers)->set_run_to_completion))(intf->send_info, 1);
  }
  ldv_37617: 
  {
#line 4504
  __ptr___0 = intf->link.next;
#line 4504
  __var___0 = (struct list_head *)0;
#line 4504
  _________p1___0 = *((struct list_head * volatile  *)(& __ptr___0));
#line 4504
  ________p1___0 = _________p1___0;
#line 4504
  tmp___0 = debug_lockdep_rcu_enabled();
  }
#line 4504
  if (tmp___0 != 0 && ! __warned___0) {
    {
#line 4504
    rcu_read_lock_held();
    }
  } else {

  }
#line 4504
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 4504
  intf = (struct ipmi_smi *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_37619: ;
#line 4504
  if ((unsigned long )(& intf->link) != (unsigned long )(& ipmi_interfaces)) {
#line 4506
    goto ldv_37618;
  } else {

  }
  {
#line 4514
  send_panic_events((char *)ptr);
  }
#line 4517
  return (0);
}
}
#line 4520 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static struct notifier_block panic_block  =    {& panic_event, (struct notifier_block *)0, 200};
#line 4526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int ipmi_init_msghandler(void) 
{ 
  int rv ;
  struct lock_class_key __key ;

  {
#line 4530
  if (initialized != 0) {
#line 4531
    return (0);
  } else {

  }
  {
#line 4533
  rv = driver_register(& ipmidriver.driver);
  }
#line 4534
  if (rv != 0) {
    {
#line 4535
    printk("\vIPMI message handler: Could not register IPMI driver\n");
    }
#line 4536
    return (rv);
  } else {

  }
  {
#line 4539
  printk("\016ipmi message handler version 39.2\n");
#line 4543
  proc_ipmi_root = proc_mkdir("ipmi", (struct proc_dir_entry *)0);
  }
#line 4544
  if ((unsigned long )proc_ipmi_root == (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 4545
    printk("\vIPMI message handler: Unable to create IPMI proc dir");
#line 4546
    driver_unregister(& ipmidriver.driver);
    }
#line 4547
    return (-12);
  } else {

  }
  {
#line 4552
  init_timer_key(& ipmi_timer, 0U, "((&ipmi_timer))", & __key);
#line 4552
  ipmi_timer.function = & ipmi_timeout;
#line 4552
  ipmi_timer.data = 0UL;
#line 4553
  ldv_mod_timer_196(& ipmi_timer, (unsigned long )jiffies + 250UL);
#line 4555
  ldv_atomic_notifier_chain_register_197(& panic_notifier_list, & panic_block);
#line 4557
  initialized = 1;
  }
#line 4559
  return (0);
}
}
#line 4562 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static int ipmi_init_msghandler_mod(void) 
{ 


  {
  {
#line 4564
  ipmi_init_msghandler();
  }
#line 4565
  return (0);
}
}
#line 4568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/char/ipmi/ipmi_msghandler.c"
static void cleanup_ipmi(void) 
{ 
  int count ;

  {
#line 4572
  if (initialized == 0) {
#line 4573
    return;
  } else {

  }
  {
#line 4575
  ldv_atomic_notifier_chain_unregister_198(& panic_notifier_list, & panic_block);
#line 4587
  atomic_inc(& stop_operation);
#line 4588
  ldv_del_timer_sync_199(& ipmi_timer);
#line 4591
  proc_remove(proc_ipmi_root);
#line 4594
  driver_unregister(& ipmidriver.driver);
#line 4596
  initialized = 0;
#line 4599
  count = atomic_read((atomic_t const   *)(& smi_msg_inuse_count));
  }
#line 4600
  if (count != 0) {
    {
#line 4601
    printk("\fIPMI message handler: SMI message count %d at exit\n", count);
    }
  } else {

  }
  {
#line 4603
  count = atomic_read((atomic_t const   *)(& recv_msg_inuse_count));
  }
#line 4604
  if (count != 0) {
    {
#line 4605
    printk("\fIPMI message handler: recv message count %d at exit\n", count);
    }
  } else {

  }
#line 4606
  return;
}
}
#line 663 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_EMGentry_exit_cleanup_ipmi_20_2(void (*arg0)(void) ) ;
#line 664
int ldv_EMGentry_init_ipmi_init_msghandler_mod_20_13(int (*arg0)(void) ) ;
#line 665
int ldv_atomic_notifier_chain_register(int arg0 , struct atomic_notifier_head *arg1 ,
                                       struct notifier_block *arg2 ) ;
#line 666
int ldv_atomic_notifier_chain_unregister(int arg0 , struct atomic_notifier_head *arg1 ,
                                         struct notifier_block *arg2 ) ;
#line 667
int ldv_del_timer_sync(int arg0 , struct timer_list *arg1 ) ;
#line 668
void ldv_dispatch_deregister_18_1(struct notifier_block *arg0 ) ;
#line 669
void ldv_dispatch_deregister_dummy_resourceless_instance_4_20_4(void) ;
#line 670
void ldv_dispatch_deregister_dummy_resourceless_instance_5_20_5(void) ;
#line 671
void ldv_dispatch_deregister_file_operations_instance_3_20_6(void) ;
#line 672
void ldv_dispatch_instance_deregister_16_1(struct timer_list *arg0 ) ;
#line 673
void ldv_dispatch_instance_register_17_2(struct timer_list *arg0 ) ;
#line 674
void ldv_dispatch_register_19_2(struct notifier_block *arg0 ) ;
#line 675
void ldv_dispatch_register_dummy_resourceless_instance_4_20_7(void) ;
#line 676
void ldv_dispatch_register_dummy_resourceless_instance_5_20_8(void) ;
#line 677
void ldv_dispatch_register_file_operations_instance_3_20_9(void) ;
#line 678
void ldv_dummy_resourceless_instance_callback_10_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 679
void ldv_dummy_resourceless_instance_callback_11_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 680
void ldv_dummy_resourceless_instance_callback_12_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 681
void ldv_dummy_resourceless_instance_callback_13_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 682
void ldv_dummy_resourceless_instance_callback_14_3(int (*arg0)(struct notifier_block * ,
                                                               unsigned long  , void * ) ,
                                                   struct notifier_block *arg1 , unsigned long arg2 ,
                                                   void *arg3 ) ;
#line 683
void ldv_dummy_resourceless_instance_callback_3_3(unsigned short (*arg0)(struct kobject * ,
                                                                         struct attribute * ,
                                                                         int  ) ,
                                                  struct kobject *arg1 , struct attribute *arg2 ,
                                                  int arg3 ) ;
#line 684
void ldv_dummy_resourceless_instance_callback_4_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 685
void ldv_dummy_resourceless_instance_callback_5_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 686
void ldv_dummy_resourceless_instance_callback_6_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 687
void ldv_dummy_resourceless_instance_callback_7_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 688
void ldv_dummy_resourceless_instance_callback_8_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 689
void ldv_dummy_resourceless_instance_callback_9_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 690
void ldv_entry_EMGentry_20(void *arg0 ) ;
#line 691
void main(void) ;
#line 692
void ldv_file_operations_file_operations_instance_0(void *arg0 ) ;
#line 693
void ldv_file_operations_file_operations_instance_1(void *arg0 ) ;
#line 694
void ldv_file_operations_file_operations_instance_2(void *arg0 ) ;
#line 695
void ldv_file_operations_instance_callback_0_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 696
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 697
void ldv_file_operations_instance_callback_1_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 698
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 699
void ldv_file_operations_instance_callback_2_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 700
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 701
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 702
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 703
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 704
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 705
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 706
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 707
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 708
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 709
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 710
int ldv_mod_timer(int arg0 , struct timer_list *arg1 , unsigned long arg2 ) ;
#line 711
void ldv_struct_attribute_group_dummy_resourceless_instance_3(void *arg0 ) ;
#line 712
void ldv_struct_device_attribute_dummy_resourceless_instance_10(void *arg0 ) ;
#line 713
void ldv_struct_device_attribute_dummy_resourceless_instance_11(void *arg0 ) ;
#line 714
void ldv_struct_device_attribute_dummy_resourceless_instance_12(void *arg0 ) ;
#line 715
void ldv_struct_device_attribute_dummy_resourceless_instance_13(void *arg0 ) ;
#line 716
void ldv_struct_device_attribute_dummy_resourceless_instance_4(void *arg0 ) ;
#line 717
void ldv_struct_device_attribute_dummy_resourceless_instance_5(void *arg0 ) ;
#line 718
void ldv_struct_device_attribute_dummy_resourceless_instance_6(void *arg0 ) ;
#line 719
void ldv_struct_device_attribute_dummy_resourceless_instance_7(void *arg0 ) ;
#line 720
void ldv_struct_device_attribute_dummy_resourceless_instance_8(void *arg0 ) ;
#line 721
void ldv_struct_device_attribute_dummy_resourceless_instance_9(void *arg0 ) ;
#line 722
void ldv_struct_notifier_block_dummy_resourceless_instance_14(void *arg0 ) ;
#line 723
void ldv_timer_instance_callback_15_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 724
void ldv_timer_timer_instance_15(void *arg0 ) ;
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 728 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_10  ;
#line 730 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_11  ;
#line 731 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_12  ;
#line 732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_13  ;
#line 733 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_14  ;
#line 734 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_15  ;
#line 735 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 736 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_20  ;
#line 737 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 738 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 739 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_5  ;
#line 740 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_6  ;
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 742 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_8  ;
#line 743 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
struct ldv_thread ldv_thread_9  ;
#line 749 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_EMGentry_exit_cleanup_ipmi_20_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 750
  cleanup_ipmi();
  }
#line 751
  return;
}
}
#line 754 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_EMGentry_init_ipmi_init_msghandler_mod_20_13(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 755
  tmp = ipmi_init_msghandler_mod();
  }
#line 755
  return (tmp);
}
}
#line 759 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_atomic_notifier_chain_register(int arg0 , struct atomic_notifier_head *arg1 ,
                                       struct notifier_block *arg2 ) 
{ 
  struct notifier_block *ldv_19_struct_notifier_block_struct_notifier_block ;
  int tmp ;

  {
  {
#line 766
  tmp = ldv_undef_int();
  }
#line 766
  if (tmp != 0) {
    {
#line 768
    ldv_assume(arg0 == 0);
#line 769
    ldv_19_struct_notifier_block_struct_notifier_block = arg2;
#line 773
    ldv_dispatch_register_19_2(ldv_19_struct_notifier_block_struct_notifier_block);
    }
#line 777
    return (arg0);
  } else {
    {
#line 781
    ldv_assume(arg0 != 0);
    }
#line 785
    return (arg0);
  }
#line 788
  return (arg0);
}
}
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_atomic_notifier_chain_unregister(int arg0 , struct atomic_notifier_head *arg1 ,
                                         struct notifier_block *arg2 ) 
{ 
  struct notifier_block *ldv_18_struct_notifier_block_struct_notifier_block ;

  {
  {
#line 799
  ldv_18_struct_notifier_block_struct_notifier_block = arg2;
#line 803
  ldv_dispatch_deregister_18_1(ldv_18_struct_notifier_block_struct_notifier_block);
  }
#line 807
  return (arg0);
#line 809
  return (arg0);
}
}
#line 814 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_del_timer_sync(int arg0 , struct timer_list *arg1 ) 
{ 
  struct timer_list *ldv_16_timer_list_timer_list ;

  {
  {
#line 820
  ldv_16_timer_list_timer_list = arg1;
#line 824
  ldv_dispatch_instance_deregister_16_1(ldv_16_timer_list_timer_list);
  }
#line 828
  return (arg0);
#line 830
  return (arg0);
}
}
#line 835 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_deregister_18_1(struct notifier_block *arg0 ) 
{ 


  {
#line 839
  return;
}
}
#line 843 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_4_20_4(void) 
{ 


  {
#line 847
  return;
}
}
#line 851 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_5_20_5(void) 
{ 


  {
#line 873
  return;
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_deregister_file_operations_instance_3_20_6(void) 
{ 


  {
#line 885
  return;
}
}
#line 889 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_instance_deregister_16_1(struct timer_list *arg0 ) 
{ 


  {
#line 893
  return;
}
}
#line 897 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_instance_register_17_2(struct timer_list *arg0 ) 
{ 
  struct ldv_struct_timer_instance_15 *cf_arg_15 ;
  void *tmp ;

  {
  {
#line 900
  tmp = ldv_xmalloc(16UL);
#line 900
  cf_arg_15 = (struct ldv_struct_timer_instance_15 *)tmp;
#line 901
  cf_arg_15->arg0 = arg0;
#line 902
  ldv_timer_timer_instance_15((void *)cf_arg_15);
  }
#line 903
  return;
}
}
#line 907 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_register_19_2(struct notifier_block *arg0 ) 
{ 
  struct ldv_struct_dummy_resourceless_instance_14 *cf_arg_14 ;
  void *tmp ;

  {
  {
#line 910
  tmp = ldv_xmalloc(16UL);
#line 910
  cf_arg_14 = (struct ldv_struct_dummy_resourceless_instance_14 *)tmp;
#line 911
  cf_arg_14->arg0 = arg0;
#line 912
  ldv_struct_notifier_block_dummy_resourceless_instance_14((void *)cf_arg_14);
  }
#line 913
  return;
}
}
#line 917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_4_20_7(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_3 ;
  void *tmp ;

  {
  {
#line 920
  tmp = ldv_xmalloc(4UL);
#line 920
  cf_arg_3 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 921
  ldv_struct_attribute_group_dummy_resourceless_instance_3((void *)cf_arg_3);
  }
#line 922
  return;
}
}
#line 926 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_5_20_8(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_4 ;
  struct ldv_struct_EMGentry_20 *cf_arg_5 ;
  struct ldv_struct_EMGentry_20 *cf_arg_6 ;
  struct ldv_struct_EMGentry_20 *cf_arg_7 ;
  struct ldv_struct_EMGentry_20 *cf_arg_8 ;
  struct ldv_struct_EMGentry_20 *cf_arg_9 ;
  struct ldv_struct_EMGentry_20 *cf_arg_10 ;
  struct ldv_struct_EMGentry_20 *cf_arg_11 ;
  struct ldv_struct_EMGentry_20 *cf_arg_12 ;
  struct ldv_struct_EMGentry_20 *cf_arg_13 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 938
  tmp = ldv_xmalloc(4UL);
#line 938
  cf_arg_4 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 939
  ldv_struct_device_attribute_dummy_resourceless_instance_4((void *)cf_arg_4);
#line 940
  tmp___0 = ldv_xmalloc(4UL);
#line 940
  cf_arg_5 = (struct ldv_struct_EMGentry_20 *)tmp___0;
#line 941
  ldv_struct_device_attribute_dummy_resourceless_instance_5((void *)cf_arg_5);
#line 942
  tmp___1 = ldv_xmalloc(4UL);
#line 942
  cf_arg_6 = (struct ldv_struct_EMGentry_20 *)tmp___1;
#line 943
  ldv_struct_device_attribute_dummy_resourceless_instance_6((void *)cf_arg_6);
#line 944
  tmp___2 = ldv_xmalloc(4UL);
#line 944
  cf_arg_7 = (struct ldv_struct_EMGentry_20 *)tmp___2;
#line 945
  ldv_struct_device_attribute_dummy_resourceless_instance_7((void *)cf_arg_7);
#line 946
  tmp___3 = ldv_xmalloc(4UL);
#line 946
  cf_arg_8 = (struct ldv_struct_EMGentry_20 *)tmp___3;
#line 947
  ldv_struct_device_attribute_dummy_resourceless_instance_8((void *)cf_arg_8);
#line 948
  tmp___4 = ldv_xmalloc(4UL);
#line 948
  cf_arg_9 = (struct ldv_struct_EMGentry_20 *)tmp___4;
#line 949
  ldv_struct_device_attribute_dummy_resourceless_instance_9((void *)cf_arg_9);
#line 950
  tmp___5 = ldv_xmalloc(4UL);
#line 950
  cf_arg_10 = (struct ldv_struct_EMGentry_20 *)tmp___5;
#line 951
  ldv_struct_device_attribute_dummy_resourceless_instance_10((void *)cf_arg_10);
#line 952
  tmp___6 = ldv_xmalloc(4UL);
#line 952
  cf_arg_11 = (struct ldv_struct_EMGentry_20 *)tmp___6;
#line 953
  ldv_struct_device_attribute_dummy_resourceless_instance_11((void *)cf_arg_11);
#line 954
  tmp___7 = ldv_xmalloc(4UL);
#line 954
  cf_arg_12 = (struct ldv_struct_EMGentry_20 *)tmp___7;
#line 955
  ldv_struct_device_attribute_dummy_resourceless_instance_12((void *)cf_arg_12);
#line 956
  tmp___8 = ldv_xmalloc(4UL);
#line 956
  cf_arg_13 = (struct ldv_struct_EMGentry_20 *)tmp___8;
#line 957
  ldv_struct_device_attribute_dummy_resourceless_instance_13((void *)cf_arg_13);
  }
#line 958
  return;
}
}
#line 962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dispatch_register_file_operations_instance_3_20_9(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_0 ;
  struct ldv_struct_EMGentry_20 *cf_arg_1 ;
  struct ldv_struct_EMGentry_20 *cf_arg_2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 967
  tmp = ldv_xmalloc(4UL);
#line 967
  cf_arg_0 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 968
  ldv_file_operations_file_operations_instance_0((void *)cf_arg_0);
#line 969
  tmp___0 = ldv_xmalloc(4UL);
#line 969
  cf_arg_1 = (struct ldv_struct_EMGentry_20 *)tmp___0;
#line 970
  ldv_file_operations_file_operations_instance_1((void *)cf_arg_1);
#line 971
  tmp___1 = ldv_xmalloc(4UL);
#line 971
  cf_arg_2 = (struct ldv_struct_EMGentry_20 *)tmp___1;
#line 972
  ldv_file_operations_file_operations_instance_2((void *)cf_arg_2);
  }
#line 973
  return;
}
}
#line 977 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_10_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 978
  manufacturer_id_show(arg1, arg2, arg3);
  }
#line 979
  return;
}
}
#line 982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_11_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 983
  product_id_show(arg1, arg2, arg3);
  }
#line 984
  return;
}
}
#line 987 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_12_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 988
  provides_device_sdrs_show(arg1, arg2, arg3);
  }
#line 989
  return;
}
}
#line 992 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_13_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 993
  revision_show(arg1, arg2, arg3);
  }
#line 994
  return;
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_14_3(int (*arg0)(struct notifier_block * ,
                                                               unsigned long  , void * ) ,
                                                   struct notifier_block *arg1 , unsigned long arg2 ,
                                                   void *arg3 ) 
{ 


  {
  {
#line 998
  panic_event(arg1, arg2, arg3);
  }
#line 999
  return;
}
}
#line 1002 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_3_3(unsigned short (*arg0)(struct kobject * ,
                                                                         struct attribute * ,
                                                                         int  ) ,
                                                  struct kobject *arg1 , struct attribute *arg2 ,
                                                  int arg3 ) 
{ 


  {
  {
#line 1003
  bmc_dev_attr_is_visible(arg1, arg2, arg3);
  }
#line 1004
  return;
}
}
#line 1007 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_4_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1008
  add_dev_support_show(arg1, arg2, arg3);
  }
#line 1009
  return;
}
}
#line 1012 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_5_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1013
  aux_firmware_rev_show(arg1, arg2, arg3);
  }
#line 1014
  return;
}
}
#line 1017 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_6_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1018
  device_id_show(arg1, arg2, arg3);
  }
#line 1019
  return;
}
}
#line 1022 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_7_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1023
  firmware_revision_show(arg1, arg2, arg3);
  }
#line 1024
  return;
}
}
#line 1027 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_8_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1028
  guid_show(arg1, arg2, arg3);
  }
#line 1029
  return;
}
}
#line 1032 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_dummy_resourceless_instance_callback_9_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1033
  ipmi_version_show(arg1, arg2, arg3);
  }
#line 1034
  return;
}
}
#line 1037 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_entry_EMGentry_20(void *arg0 ) 
{ 
  void (*ldv_20_exit_cleanup_ipmi_default)(void) ;
  int (*ldv_20_init_ipmi_init_msghandler_mod_default)(void) ;
  int ldv_20_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1046
  ldv_20_ret_default = ldv_EMGentry_init_ipmi_init_msghandler_mod_20_13(ldv_20_init_ipmi_init_msghandler_mod_default);
#line 1048
  ldv_20_ret_default = ldv_ldv_post_init_200(ldv_20_ret_default);
#line 1051
  tmp___0 = ldv_undef_int();
  }
#line 1051
  if (tmp___0 != 0) {
    {
#line 1053
    ldv_assume(ldv_20_ret_default != 0);
#line 1057
    ldv_ldv_check_final_state_201();
#line 1058
    ldv_stop();
    }
#line 1062
    return;
  } else {
    {
#line 1066
    ldv_assume(ldv_20_ret_default == 0);
#line 1069
    tmp = ldv_undef_int();
    }
#line 1069
    if (tmp != 0) {
      {
#line 1071
      ldv_dispatch_register_file_operations_instance_3_20_9();
#line 1075
      ldv_dispatch_register_dummy_resourceless_instance_5_20_8();
#line 1079
      ldv_dispatch_register_dummy_resourceless_instance_4_20_7();
#line 1083
      ldv_dispatch_deregister_file_operations_instance_3_20_6();
#line 1087
      ldv_dispatch_deregister_dummy_resourceless_instance_5_20_5();
#line 1091
      ldv_dispatch_deregister_dummy_resourceless_instance_4_20_4();
      }
    } else {

    }
    {
#line 1102
    ldv_EMGentry_exit_cleanup_ipmi_20_2(ldv_20_exit_cleanup_ipmi_default);
#line 1106
    ldv_ldv_check_final_state_202();
#line 1107
    ldv_stop();
    }
#line 1111
    return;
  }
#line 1114
  return;
}
}
#line 1119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void main(void) 
{ 


  {
  {
#line 1120
  ldv_ldv_initialize_203();
#line 1121
  ldv_entry_EMGentry_20((void *)0);
  }
#line 1122
  return;
}
}
#line 1126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_file_operations_instance_0(void *arg0 ) 
{ 
  long long (*ldv_0_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_0_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_0_container_file_operations ;
  char *ldv_0_ldv_param_22_1_default ;
  long long *ldv_0_ldv_param_22_3_default ;
  char *ldv_0_ldv_param_4_1_default ;
  long long *ldv_0_ldv_param_4_3_default ;
  long long ldv_0_ldv_param_5_1_default ;
  int ldv_0_ldv_param_5_2_default ;
  struct file *ldv_0_resource_file ;
  struct inode *ldv_0_resource_inode ;
  int ldv_0_ret_default ;
  unsigned long ldv_0_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1144
  ldv_0_ret_default = 1;
#line 1149
  tmp = ldv_xmalloc(504UL);
#line 1149
  ldv_0_resource_file = (struct file *)tmp;
#line 1150
  tmp___0 = ldv_xmalloc(976UL);
#line 1150
  ldv_0_resource_inode = (struct inode *)tmp___0;
#line 1151
  tmp___1 = ldv_undef_int();
#line 1151
  ldv_0_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1158
  goto ldv_main_0;
#line 1160
  return;
  ldv_main_0: 
  {
#line 1166
  tmp___3 = ldv_undef_int();
  }
#line 1166
  if (tmp___3 != 0) {
    {
#line 1169
    ldv_0_ret_default = ldv_file_operations_instance_probe_0_12(ldv_0_container_file_operations->open,
                                                                ldv_0_resource_inode,
                                                                ldv_0_resource_file);
#line 1171
    ldv_0_ret_default = ldv_filter_err_code(ldv_0_ret_default);
#line 1174
    tmp___2 = ldv_undef_int();
    }
#line 1174
    if (tmp___2 != 0) {
      {
#line 1176
      ldv_assume(ldv_0_ret_default == 0);
      }
#line 1183
      goto ldv_call_0;
    } else {
      {
#line 1187
      ldv_assume(ldv_0_ret_default != 0);
      }
#line 1194
      goto ldv_main_0;
    }
  } else {
    {
#line 1199
    ldv_free((void *)ldv_0_resource_file);
#line 1200
    ldv_free((void *)ldv_0_resource_inode);
    }
#line 1208
    return;
  }
#line 1211
  return;
  ldv_call_0: 
  {
#line 1217
  tmp___4 = ldv_undef_int();
  }
  {
#line 1218
  if (tmp___4 == 1) {
#line 1218
    goto case_1;
  } else {

  }
#line 1245
  if (tmp___4 == 2) {
#line 1245
    goto case_2;
  } else {

  }
#line 1258
  if (tmp___4 == 3) {
#line 1258
    goto case_3;
  } else {

  }
#line 1288
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1220
  tmp___5 = ldv_xmalloc(1UL);
#line 1220
  ldv_0_ldv_param_4_1_default = (char *)tmp___5;
#line 1221
  tmp___6 = ldv_xmalloc(8UL);
#line 1221
  ldv_0_ldv_param_4_3_default = (long long *)tmp___6;
#line 1226
  ldv_assume(ldv_0_size_cnt_write_size <= 2147479552UL);
  }
#line 1227
  if ((unsigned long )ldv_0_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1229
    ldv_file_operations_instance_write_0_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_0_container_file_operations->write,
                                           ldv_0_resource_file, ldv_0_ldv_param_4_1_default,
                                           ldv_0_size_cnt_write_size, ldv_0_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1234
  ldv_free((void *)ldv_0_ldv_param_4_1_default);
#line 1235
  ldv_free((void *)ldv_0_ldv_param_4_3_default);
  }
#line 1242
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 1248
  ldv_file_operations_instance_release_0_2(ldv_0_container_file_operations->release,
                                           ldv_0_resource_inode, ldv_0_resource_file);
  }
#line 1255
  goto ldv_main_0;
  case_3: /* CIL Label */ 
  {
#line 1262
  tmp___9 = ldv_undef_int();
  }
#line 1262
  if (tmp___9 != 0) {
    {
#line 1264
    tmp___7 = ldv_xmalloc(1UL);
#line 1264
    ldv_0_ldv_param_22_1_default = (char *)tmp___7;
#line 1265
    tmp___8 = ldv_xmalloc(8UL);
#line 1265
    ldv_0_ldv_param_22_3_default = (long long *)tmp___8;
#line 1270
    ldv_file_operations_instance_callback_0_22(ldv_0_callback_read, ldv_0_resource_file,
                                               ldv_0_ldv_param_22_1_default, ldv_0_size_cnt_write_size,
                                               ldv_0_ldv_param_22_3_default);
#line 1274
    ldv_free((void *)ldv_0_ldv_param_22_1_default);
#line 1275
    ldv_free((void *)ldv_0_ldv_param_22_3_default);
    }
  } else {
    {
#line 1282
    ldv_file_operations_instance_callback_0_5(ldv_0_callback_llseek, ldv_0_resource_file,
                                              ldv_0_ldv_param_5_1_default, ldv_0_ldv_param_5_2_default);
    }
  }
#line 1286
  goto ldv_38207;
  switch_default: /* CIL Label */ 
  {
#line 1288
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_38207: ;
#line 1297
  goto ldv_call_0;
#line 1299
  goto ldv_call_0;
#line 1301
  return;
}
}
#line 1306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_file_operations_instance_1(void *arg0 ) 
{ 
  long long (*ldv_1_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_1_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_1_container_file_operations ;
  char *ldv_1_ldv_param_22_1_default ;
  long long *ldv_1_ldv_param_22_3_default ;
  char *ldv_1_ldv_param_4_1_default ;
  long long *ldv_1_ldv_param_4_3_default ;
  long long ldv_1_ldv_param_5_1_default ;
  int ldv_1_ldv_param_5_2_default ;
  struct file *ldv_1_resource_file ;
  struct inode *ldv_1_resource_inode ;
  int ldv_1_ret_default ;
  unsigned long ldv_1_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1324
  ldv_1_ret_default = 1;
#line 1329
  tmp = ldv_xmalloc(504UL);
#line 1329
  ldv_1_resource_file = (struct file *)tmp;
#line 1330
  tmp___0 = ldv_xmalloc(976UL);
#line 1330
  ldv_1_resource_inode = (struct inode *)tmp___0;
#line 1331
  tmp___1 = ldv_undef_int();
#line 1331
  ldv_1_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1338
  goto ldv_main_1;
#line 1340
  return;
  ldv_main_1: 
  {
#line 1346
  tmp___3 = ldv_undef_int();
  }
#line 1346
  if (tmp___3 != 0) {
    {
#line 1349
    ldv_1_ret_default = ldv_file_operations_instance_probe_1_12(ldv_1_container_file_operations->open,
                                                                ldv_1_resource_inode,
                                                                ldv_1_resource_file);
#line 1351
    ldv_1_ret_default = ldv_filter_err_code(ldv_1_ret_default);
#line 1354
    tmp___2 = ldv_undef_int();
    }
#line 1354
    if (tmp___2 != 0) {
      {
#line 1356
      ldv_assume(ldv_1_ret_default == 0);
      }
#line 1363
      goto ldv_call_1;
    } else {
      {
#line 1367
      ldv_assume(ldv_1_ret_default != 0);
      }
#line 1374
      goto ldv_main_1;
    }
  } else {
    {
#line 1379
    ldv_free((void *)ldv_1_resource_file);
#line 1380
    ldv_free((void *)ldv_1_resource_inode);
    }
#line 1388
    return;
  }
#line 1391
  return;
  ldv_call_1: 
  {
#line 1397
  tmp___4 = ldv_undef_int();
  }
  {
#line 1398
  if (tmp___4 == 1) {
#line 1398
    goto case_1;
  } else {

  }
#line 1425
  if (tmp___4 == 2) {
#line 1425
    goto case_2;
  } else {

  }
#line 1438
  if (tmp___4 == 3) {
#line 1438
    goto case_3;
  } else {

  }
#line 1468
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1400
  tmp___5 = ldv_xmalloc(1UL);
#line 1400
  ldv_1_ldv_param_4_1_default = (char *)tmp___5;
#line 1401
  tmp___6 = ldv_xmalloc(8UL);
#line 1401
  ldv_1_ldv_param_4_3_default = (long long *)tmp___6;
#line 1406
  ldv_assume(ldv_1_size_cnt_write_size <= 2147479552UL);
  }
#line 1407
  if ((unsigned long )ldv_1_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1409
    ldv_file_operations_instance_write_1_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_1_container_file_operations->write,
                                           ldv_1_resource_file, ldv_1_ldv_param_4_1_default,
                                           ldv_1_size_cnt_write_size, ldv_1_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1414
  ldv_free((void *)ldv_1_ldv_param_4_1_default);
#line 1415
  ldv_free((void *)ldv_1_ldv_param_4_3_default);
  }
#line 1422
  goto ldv_call_1;
  case_2: /* CIL Label */ 
  {
#line 1428
  ldv_file_operations_instance_release_1_2(ldv_1_container_file_operations->release,
                                           ldv_1_resource_inode, ldv_1_resource_file);
  }
#line 1435
  goto ldv_main_1;
  case_3: /* CIL Label */ 
  {
#line 1442
  tmp___9 = ldv_undef_int();
  }
#line 1442
  if (tmp___9 != 0) {
    {
#line 1444
    tmp___7 = ldv_xmalloc(1UL);
#line 1444
    ldv_1_ldv_param_22_1_default = (char *)tmp___7;
#line 1445
    tmp___8 = ldv_xmalloc(8UL);
#line 1445
    ldv_1_ldv_param_22_3_default = (long long *)tmp___8;
#line 1450
    ldv_file_operations_instance_callback_1_22(ldv_1_callback_read, ldv_1_resource_file,
                                               ldv_1_ldv_param_22_1_default, ldv_1_size_cnt_write_size,
                                               ldv_1_ldv_param_22_3_default);
#line 1454
    ldv_free((void *)ldv_1_ldv_param_22_1_default);
#line 1455
    ldv_free((void *)ldv_1_ldv_param_22_3_default);
    }
  } else {
    {
#line 1462
    ldv_file_operations_instance_callback_1_5(ldv_1_callback_llseek, ldv_1_resource_file,
                                              ldv_1_ldv_param_5_1_default, ldv_1_ldv_param_5_2_default);
    }
  }
#line 1466
  goto ldv_38237;
  switch_default: /* CIL Label */ 
  {
#line 1468
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_38237: ;
#line 1477
  goto ldv_call_1;
#line 1479
  goto ldv_call_1;
#line 1481
  return;
}
}
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_file_operations_instance_2(void *arg0 ) 
{ 
  long long (*ldv_2_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_2_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_2_container_file_operations ;
  char *ldv_2_ldv_param_22_1_default ;
  long long *ldv_2_ldv_param_22_3_default ;
  char *ldv_2_ldv_param_4_1_default ;
  long long *ldv_2_ldv_param_4_3_default ;
  long long ldv_2_ldv_param_5_1_default ;
  int ldv_2_ldv_param_5_2_default ;
  struct file *ldv_2_resource_file ;
  struct inode *ldv_2_resource_inode ;
  int ldv_2_ret_default ;
  unsigned long ldv_2_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1504
  ldv_2_ret_default = 1;
#line 1509
  tmp = ldv_xmalloc(504UL);
#line 1509
  ldv_2_resource_file = (struct file *)tmp;
#line 1510
  tmp___0 = ldv_xmalloc(976UL);
#line 1510
  ldv_2_resource_inode = (struct inode *)tmp___0;
#line 1511
  tmp___1 = ldv_undef_int();
#line 1511
  ldv_2_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1518
  goto ldv_main_2;
#line 1520
  return;
  ldv_main_2: 
  {
#line 1526
  tmp___3 = ldv_undef_int();
  }
#line 1526
  if (tmp___3 != 0) {
    {
#line 1529
    ldv_2_ret_default = ldv_file_operations_instance_probe_2_12(ldv_2_container_file_operations->open,
                                                                ldv_2_resource_inode,
                                                                ldv_2_resource_file);
#line 1531
    ldv_2_ret_default = ldv_filter_err_code(ldv_2_ret_default);
#line 1534
    tmp___2 = ldv_undef_int();
    }
#line 1534
    if (tmp___2 != 0) {
      {
#line 1536
      ldv_assume(ldv_2_ret_default == 0);
      }
#line 1543
      goto ldv_call_2;
    } else {
      {
#line 1547
      ldv_assume(ldv_2_ret_default != 0);
      }
#line 1554
      goto ldv_main_2;
    }
  } else {
    {
#line 1559
    ldv_free((void *)ldv_2_resource_file);
#line 1560
    ldv_free((void *)ldv_2_resource_inode);
    }
#line 1568
    return;
  }
#line 1571
  return;
  ldv_call_2: 
  {
#line 1577
  tmp___4 = ldv_undef_int();
  }
  {
#line 1578
  if (tmp___4 == 1) {
#line 1578
    goto case_1;
  } else {

  }
#line 1605
  if (tmp___4 == 2) {
#line 1605
    goto case_2;
  } else {

  }
#line 1618
  if (tmp___4 == 3) {
#line 1618
    goto case_3;
  } else {

  }
#line 1648
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1580
  tmp___5 = ldv_xmalloc(1UL);
#line 1580
  ldv_2_ldv_param_4_1_default = (char *)tmp___5;
#line 1581
  tmp___6 = ldv_xmalloc(8UL);
#line 1581
  ldv_2_ldv_param_4_3_default = (long long *)tmp___6;
#line 1586
  ldv_assume(ldv_2_size_cnt_write_size <= 2147479552UL);
  }
#line 1587
  if ((unsigned long )ldv_2_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1589
    ldv_file_operations_instance_write_2_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_2_container_file_operations->write,
                                           ldv_2_resource_file, ldv_2_ldv_param_4_1_default,
                                           ldv_2_size_cnt_write_size, ldv_2_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1594
  ldv_free((void *)ldv_2_ldv_param_4_1_default);
#line 1595
  ldv_free((void *)ldv_2_ldv_param_4_3_default);
  }
#line 1602
  goto ldv_call_2;
  case_2: /* CIL Label */ 
  {
#line 1608
  ldv_file_operations_instance_release_2_2(ldv_2_container_file_operations->release,
                                           ldv_2_resource_inode, ldv_2_resource_file);
  }
#line 1615
  goto ldv_main_2;
  case_3: /* CIL Label */ 
  {
#line 1622
  tmp___9 = ldv_undef_int();
  }
#line 1622
  if (tmp___9 != 0) {
    {
#line 1624
    tmp___7 = ldv_xmalloc(1UL);
#line 1624
    ldv_2_ldv_param_22_1_default = (char *)tmp___7;
#line 1625
    tmp___8 = ldv_xmalloc(8UL);
#line 1625
    ldv_2_ldv_param_22_3_default = (long long *)tmp___8;
#line 1630
    ldv_file_operations_instance_callback_2_22(ldv_2_callback_read, ldv_2_resource_file,
                                               ldv_2_ldv_param_22_1_default, ldv_2_size_cnt_write_size,
                                               ldv_2_ldv_param_22_3_default);
#line 1634
    ldv_free((void *)ldv_2_ldv_param_22_1_default);
#line 1635
    ldv_free((void *)ldv_2_ldv_param_22_3_default);
    }
  } else {
    {
#line 1642
    ldv_file_operations_instance_callback_2_5(ldv_2_callback_llseek, ldv_2_resource_file,
                                              ldv_2_ldv_param_5_1_default, ldv_2_ldv_param_5_2_default);
    }
  }
#line 1646
  goto ldv_38267;
  switch_default: /* CIL Label */ 
  {
#line 1648
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_38267: ;
#line 1657
  goto ldv_call_2;
#line 1659
  goto ldv_call_2;
#line 1661
  return;
}
}
#line 1666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_0_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1667
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1668
  return;
}
}
#line 1671 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1672
  seq_lseek(arg1, arg2, arg3);
  }
#line 1673
  return;
}
}
#line 1676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_1_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1677
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1678
  return;
}
}
#line 1681 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1682
  seq_lseek(arg1, arg2, arg3);
  }
#line 1683
  return;
}
}
#line 1686 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_2_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1687
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1688
  return;
}
}
#line 1691 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1692
  seq_lseek(arg1, arg2, arg3);
  }
#line 1693
  return;
}
}
#line 1696 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1697
  tmp = smi_ipmb_proc_open(arg1, arg2);
  }
#line 1697
  return (tmp);
}
}
#line 1701 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1702
  tmp = smi_stats_proc_open(arg1, arg2);
  }
#line 1702
  return (tmp);
}
}
#line 1706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1707
  tmp = smi_version_proc_open(arg1, arg2);
  }
#line 1707
  return (tmp);
}
}
#line 1711 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1712
  single_release(arg1, arg2);
  }
#line 1713
  return;
}
}
#line 1716 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1717
  single_release(arg1, arg2);
  }
#line 1718
  return;
}
}
#line 1721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1722
  single_release(arg1, arg2);
  }
#line 1723
  return;
}
}
#line 1726 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1727
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1728
  return;
}
}
#line 1731 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1732
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1733
  return;
}
}
#line 1736 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1737
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1738
  return;
}
}
#line 1741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
int ldv_mod_timer(int arg0 , struct timer_list *arg1 , unsigned long arg2 ) 
{ 
  struct timer_list *ldv_17_timer_list_timer_list ;
  int tmp ;

  {
  {
#line 1748
  tmp = ldv_undef_int();
  }
#line 1748
  if (tmp != 0) {
    {
#line 1750
    ldv_assume(arg0 == 0);
#line 1751
    ldv_17_timer_list_timer_list = arg1;
#line 1755
    ldv_dispatch_instance_register_17_2(ldv_17_timer_list_timer_list);
    }
#line 1759
    return (arg0);
  } else {
    {
#line 1763
    ldv_assume(arg0 != 0);
    }
#line 1767
    return (arg0);
  }
#line 1770
  return (arg0);
}
}
#line 1775 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_attribute_group_dummy_resourceless_instance_3(void *arg0 ) 
{ 
  unsigned short (*ldv_3_callback_is_visible)(struct kobject * , struct attribute * ,
                                              int  ) ;
  struct attribute *ldv_3_container_struct_attribute_ptr ;
  struct kobject *ldv_3_container_struct_kobject_ptr ;
  int ldv_3_ldv_param_3_2_default ;
  int tmp ;

  {
#line 1790
  goto ldv_call_3;
#line 1792
  return;
  ldv_call_3: 
  {
#line 1798
  tmp = ldv_undef_int();
  }
#line 1798
  if (tmp != 0) {
    {
#line 1804
    ldv_dummy_resourceless_instance_callback_3_3(ldv_3_callback_is_visible, ldv_3_container_struct_kobject_ptr,
                                                 ldv_3_container_struct_attribute_ptr,
                                                 ldv_3_ldv_param_3_2_default);
    }
#line 1814
    goto ldv_call_3;
  } else {
#line 1822
    return;
  }
#line 1825
  return;
}
}
#line 1830 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_10(void *arg0 ) 
{ 
  long (*ldv_10_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_10_container_struct_device_attribute ;
  struct device *ldv_10_container_struct_device_ptr ;
  char *ldv_10_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1845
  goto ldv_call_10;
#line 1847
  return;
  ldv_call_10: 
  {
#line 1853
  tmp___0 = ldv_undef_int();
  }
#line 1853
  if (tmp___0 != 0) {
    {
#line 1855
    tmp = ldv_xmalloc(1UL);
#line 1855
    ldv_10_ldv_param_3_2_default = (char *)tmp;
#line 1860
    ldv_dummy_resourceless_instance_callback_10_3(ldv_10_callback_show, ldv_10_container_struct_device_ptr,
                                                  ldv_10_container_struct_device_attribute,
                                                  ldv_10_ldv_param_3_2_default);
#line 1864
    ldv_free((void *)ldv_10_ldv_param_3_2_default);
    }
#line 1871
    goto ldv_call_10;
  } else {
#line 1879
    return;
  }
#line 1882
  return;
}
}
#line 1887 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_11(void *arg0 ) 
{ 
  long (*ldv_11_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_11_container_struct_device_attribute ;
  struct device *ldv_11_container_struct_device_ptr ;
  char *ldv_11_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1902
  goto ldv_call_11;
#line 1904
  return;
  ldv_call_11: 
  {
#line 1910
  tmp___0 = ldv_undef_int();
  }
#line 1910
  if (tmp___0 != 0) {
    {
#line 1912
    tmp = ldv_xmalloc(1UL);
#line 1912
    ldv_11_ldv_param_3_2_default = (char *)tmp;
#line 1917
    ldv_dummy_resourceless_instance_callback_11_3(ldv_11_callback_show, ldv_11_container_struct_device_ptr,
                                                  ldv_11_container_struct_device_attribute,
                                                  ldv_11_ldv_param_3_2_default);
#line 1921
    ldv_free((void *)ldv_11_ldv_param_3_2_default);
    }
#line 1928
    goto ldv_call_11;
  } else {
#line 1936
    return;
  }
#line 1939
  return;
}
}
#line 1944 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_12(void *arg0 ) 
{ 
  long (*ldv_12_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_12_container_struct_device_attribute ;
  struct device *ldv_12_container_struct_device_ptr ;
  char *ldv_12_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1959
  goto ldv_call_12;
#line 1961
  return;
  ldv_call_12: 
  {
#line 1967
  tmp___0 = ldv_undef_int();
  }
#line 1967
  if (tmp___0 != 0) {
    {
#line 1969
    tmp = ldv_xmalloc(1UL);
#line 1969
    ldv_12_ldv_param_3_2_default = (char *)tmp;
#line 1974
    ldv_dummy_resourceless_instance_callback_12_3(ldv_12_callback_show, ldv_12_container_struct_device_ptr,
                                                  ldv_12_container_struct_device_attribute,
                                                  ldv_12_ldv_param_3_2_default);
#line 1978
    ldv_free((void *)ldv_12_ldv_param_3_2_default);
    }
#line 1985
    goto ldv_call_12;
  } else {
#line 1993
    return;
  }
#line 1996
  return;
}
}
#line 2001 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_13(void *arg0 ) 
{ 
  long (*ldv_13_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_13_container_struct_device_attribute ;
  struct device *ldv_13_container_struct_device_ptr ;
  char *ldv_13_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2016
  goto ldv_call_13;
#line 2018
  return;
  ldv_call_13: 
  {
#line 2024
  tmp___0 = ldv_undef_int();
  }
#line 2024
  if (tmp___0 != 0) {
    {
#line 2026
    tmp = ldv_xmalloc(1UL);
#line 2026
    ldv_13_ldv_param_3_2_default = (char *)tmp;
#line 2031
    ldv_dummy_resourceless_instance_callback_13_3(ldv_13_callback_show, ldv_13_container_struct_device_ptr,
                                                  ldv_13_container_struct_device_attribute,
                                                  ldv_13_ldv_param_3_2_default);
#line 2035
    ldv_free((void *)ldv_13_ldv_param_3_2_default);
    }
#line 2042
    goto ldv_call_13;
  } else {
#line 2050
    return;
  }
#line 2053
  return;
}
}
#line 2058 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_4(void *arg0 ) 
{ 
  long (*ldv_4_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_4_container_struct_device_attribute ;
  struct device *ldv_4_container_struct_device_ptr ;
  char *ldv_4_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2073
  goto ldv_call_4;
#line 2075
  return;
  ldv_call_4: 
  {
#line 2081
  tmp___0 = ldv_undef_int();
  }
#line 2081
  if (tmp___0 != 0) {
    {
#line 2083
    tmp = ldv_xmalloc(1UL);
#line 2083
    ldv_4_ldv_param_3_2_default = (char *)tmp;
#line 2088
    ldv_dummy_resourceless_instance_callback_4_3(ldv_4_callback_show, ldv_4_container_struct_device_ptr,
                                                 ldv_4_container_struct_device_attribute,
                                                 ldv_4_ldv_param_3_2_default);
#line 2092
    ldv_free((void *)ldv_4_ldv_param_3_2_default);
    }
#line 2099
    goto ldv_call_4;
  } else {
#line 2107
    return;
  }
#line 2110
  return;
}
}
#line 2115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_5(void *arg0 ) 
{ 
  long (*ldv_5_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_5_container_struct_device_attribute ;
  struct device *ldv_5_container_struct_device_ptr ;
  char *ldv_5_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2130
  goto ldv_call_5;
#line 2132
  return;
  ldv_call_5: 
  {
#line 2138
  tmp___0 = ldv_undef_int();
  }
#line 2138
  if (tmp___0 != 0) {
    {
#line 2140
    tmp = ldv_xmalloc(1UL);
#line 2140
    ldv_5_ldv_param_3_2_default = (char *)tmp;
#line 2145
    ldv_dummy_resourceless_instance_callback_5_3(ldv_5_callback_show, ldv_5_container_struct_device_ptr,
                                                 ldv_5_container_struct_device_attribute,
                                                 ldv_5_ldv_param_3_2_default);
#line 2149
    ldv_free((void *)ldv_5_ldv_param_3_2_default);
    }
#line 2156
    goto ldv_call_5;
  } else {
#line 2164
    return;
  }
#line 2167
  return;
}
}
#line 2172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_6(void *arg0 ) 
{ 
  long (*ldv_6_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_6_container_struct_device_attribute ;
  struct device *ldv_6_container_struct_device_ptr ;
  char *ldv_6_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2187
  goto ldv_call_6;
#line 2189
  return;
  ldv_call_6: 
  {
#line 2195
  tmp___0 = ldv_undef_int();
  }
#line 2195
  if (tmp___0 != 0) {
    {
#line 2197
    tmp = ldv_xmalloc(1UL);
#line 2197
    ldv_6_ldv_param_3_2_default = (char *)tmp;
#line 2202
    ldv_dummy_resourceless_instance_callback_6_3(ldv_6_callback_show, ldv_6_container_struct_device_ptr,
                                                 ldv_6_container_struct_device_attribute,
                                                 ldv_6_ldv_param_3_2_default);
#line 2206
    ldv_free((void *)ldv_6_ldv_param_3_2_default);
    }
#line 2213
    goto ldv_call_6;
  } else {
#line 2221
    return;
  }
#line 2224
  return;
}
}
#line 2229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_7(void *arg0 ) 
{ 
  long (*ldv_7_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_7_container_struct_device_attribute ;
  struct device *ldv_7_container_struct_device_ptr ;
  char *ldv_7_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2244
  goto ldv_call_7;
#line 2246
  return;
  ldv_call_7: 
  {
#line 2252
  tmp___0 = ldv_undef_int();
  }
#line 2252
  if (tmp___0 != 0) {
    {
#line 2254
    tmp = ldv_xmalloc(1UL);
#line 2254
    ldv_7_ldv_param_3_2_default = (char *)tmp;
#line 2259
    ldv_dummy_resourceless_instance_callback_7_3(ldv_7_callback_show, ldv_7_container_struct_device_ptr,
                                                 ldv_7_container_struct_device_attribute,
                                                 ldv_7_ldv_param_3_2_default);
#line 2263
    ldv_free((void *)ldv_7_ldv_param_3_2_default);
    }
#line 2270
    goto ldv_call_7;
  } else {
#line 2278
    return;
  }
#line 2281
  return;
}
}
#line 2286 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_8(void *arg0 ) 
{ 
  long (*ldv_8_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_8_container_struct_device_attribute ;
  struct device *ldv_8_container_struct_device_ptr ;
  char *ldv_8_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2301
  goto ldv_call_8;
#line 2303
  return;
  ldv_call_8: 
  {
#line 2309
  tmp___0 = ldv_undef_int();
  }
#line 2309
  if (tmp___0 != 0) {
    {
#line 2311
    tmp = ldv_xmalloc(1UL);
#line 2311
    ldv_8_ldv_param_3_2_default = (char *)tmp;
#line 2316
    ldv_dummy_resourceless_instance_callback_8_3(ldv_8_callback_show, ldv_8_container_struct_device_ptr,
                                                 ldv_8_container_struct_device_attribute,
                                                 ldv_8_ldv_param_3_2_default);
#line 2320
    ldv_free((void *)ldv_8_ldv_param_3_2_default);
    }
#line 2327
    goto ldv_call_8;
  } else {
#line 2335
    return;
  }
#line 2338
  return;
}
}
#line 2343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_9(void *arg0 ) 
{ 
  long (*ldv_9_callback_show)(struct device * , struct device_attribute * , char * ) ;
  struct device_attribute *ldv_9_container_struct_device_attribute ;
  struct device *ldv_9_container_struct_device_ptr ;
  char *ldv_9_ldv_param_3_2_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2358
  goto ldv_call_9;
#line 2360
  return;
  ldv_call_9: 
  {
#line 2366
  tmp___0 = ldv_undef_int();
  }
#line 2366
  if (tmp___0 != 0) {
    {
#line 2368
    tmp = ldv_xmalloc(1UL);
#line 2368
    ldv_9_ldv_param_3_2_default = (char *)tmp;
#line 2373
    ldv_dummy_resourceless_instance_callback_9_3(ldv_9_callback_show, ldv_9_container_struct_device_ptr,
                                                 ldv_9_container_struct_device_attribute,
                                                 ldv_9_ldv_param_3_2_default);
#line 2377
    ldv_free((void *)ldv_9_ldv_param_3_2_default);
    }
#line 2384
    goto ldv_call_9;
  } else {
#line 2392
    return;
  }
#line 2395
  return;
}
}
#line 2400 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_struct_notifier_block_dummy_resourceless_instance_14(void *arg0 ) 
{ 
  int (*ldv_14_callback_notifier_call)(struct notifier_block * , unsigned long  ,
                                       void * ) ;
  struct notifier_block *ldv_14_container_struct_notifier_block ;
  unsigned long ldv_14_ldv_param_3_1_default ;
  void *ldv_14_ldv_param_3_2_default ;
  struct ldv_struct_dummy_resourceless_instance_14 *data ;
  int tmp ;

  {
#line 2408
  data = (struct ldv_struct_dummy_resourceless_instance_14 *)arg0;
#line 2413
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_dummy_resourceless_instance_14 *)0)) {
    {
#line 2414
    ldv_14_container_struct_notifier_block = data->arg0;
#line 2415
    ldv_free((void *)data);
    }
  } else {

  }
#line 2423
  goto ldv_call_14;
#line 2425
  return;
  ldv_call_14: 
  {
#line 2431
  tmp = ldv_undef_int();
  }
#line 2431
  if (tmp != 0) {
    {
#line 2433
    ldv_14_ldv_param_3_2_default = ldv_xmalloc(1UL);
#line 2438
    ldv_dummy_resourceless_instance_callback_14_3(ldv_14_callback_notifier_call, ldv_14_container_struct_notifier_block,
                                                  ldv_14_ldv_param_3_1_default, ldv_14_ldv_param_3_2_default);
#line 2442
    ldv_free(ldv_14_ldv_param_3_2_default);
    }
#line 2449
    goto ldv_call_14;
  } else {
#line 2457
    return;
  }
#line 2460
  return;
}
}
#line 2465 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_timer_instance_callback_15_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 2466
  (*arg0)(arg1);
  }
#line 2467
  return;
}
}
#line 2470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
void ldv_timer_timer_instance_15(void *arg0 ) 
{ 
  struct timer_list *ldv_15_container_timer_list ;
  struct ldv_struct_timer_instance_15 *data ;

  {
#line 2475
  data = (struct ldv_struct_timer_instance_15 *)arg0;
#line 2480
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_timer_instance_15 *)0)) {
    {
#line 2481
    ldv_15_container_timer_list = data->arg0;
#line 2482
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 2488
  ldv_switch_to_interrupt_context();
  }
#line 2489
  if ((unsigned long )ldv_15_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 2491
    ldv_timer_instance_callback_15_2(ldv_15_container_timer_list->function, ldv_15_container_timer_list->data);
    }
  } else {

  }
  {
#line 2494
  ldv_switch_to_process_context();
  }
#line 2502
  return;
#line 2504
  return;
}
}
#line 2557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
  {
#line 2560
  ldv_linux_usb_dev_atomic_add(i, v);
  }
#line 2561
  return;
}
}
#line 2563 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
  {
#line 2566
  ldv_linux_usb_dev_atomic_sub(i, v);
  }
#line 2567
  return;
}
}
#line 2569 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 2572
  tmp = ldv_linux_usb_dev_atomic_sub_and_test(i, v);
  }
#line 2572
  return (tmp);
}
}
#line 2575 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  {
#line 2578
  ldv_linux_usb_dev_atomic_inc(v);
  }
#line 2579
  return;
}
}
#line 2581 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
  {
#line 2584
  ldv_linux_usb_dev_atomic_dec(v);
  }
#line 2585
  return;
}
}
#line 2605 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 2608
  tmp = ldv_linux_usb_dev_atomic_add_return(i, v);
  }
#line 2608
  return (tmp);
}
}
#line 2745 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_synchronize_sched_35(void) 
{ 


  {
  {
#line 2748
  ldv_check_for_read_section();
  }
#line 2749
  return;
}
}
#line 2751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void rcu_read_lock(void) 
{ 


  {
  {
#line 2754
  ldv_linux_kernel_rcu_update_lock_rcu_read_lock();
  }
#line 2755
  return;
}
}
#line 2757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void rcu_read_unlock(void) 
{ 


  {
  {
#line 2760
  ldv_linux_kernel_rcu_update_lock_rcu_read_unlock();
  }
#line 2761
  return;
}
}
#line 2904 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 2907
  ldv_check_for_read_section();
  }
#line 2908
  return;
}
}
#line 2928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void list_del_rcu(struct list_head *entry ) 
{ 


  {
  {
#line 2931
  ldv_check_for_read_section();
  }
#line 2932
  return;
}
}
#line 2940 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ 


  {
  {
#line 2943
  ldv_check_for_read_section();
  }
#line 2944
  return;
}
}
#line 3124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 3128
  ldv_check_alloc_flags(flags);
#line 3129
  res = ldv_malloc_unknown_size();
#line 3130
  ldv_after_alloc(res);
  }
#line 3131
  return (res);
}
}
#line 3175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3178
  tmp = ldv_kzalloc(size, flags);
  }
#line 3178
  return (tmp);
}
}
#line 3203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3207
  ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3208
  return;
}
}
#line 3210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3214
  ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3215
  return;
}
}
#line 3217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3221
  ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3222
  return;
}
}
#line 3224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3228
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3229
  return;
}
}
#line 3231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3235
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3236
  return;
}
}
#line 3238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3242
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3243
  return;
}
}
#line 3245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3249
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3250
  return;
}
}
#line 3252 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3256
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3257
  return;
}
}
#line 3259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3263
  ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3264
  return;
}
}
#line 3266 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3270
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3271
  return;
}
}
#line 3273 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static bool ldv_try_module_get_107(struct module *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3276
  tmp = ldv_linux_kernel_module_try_module_get(ldv_func_arg1);
  }
#line 3276
  return (tmp != 0);
}
}
#line 3279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_module_put_108(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3282
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3283
  return;
}
}
#line 3285 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_109(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3288
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3290
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3291
  return;
}
}
#line 3293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void ldv_spin_unlock_irqrestore_110(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 3296
  ldv_linux_kernel_locking_spinlock_spin_unlock_seq_lock_of_ipmi_smi();
#line 3298
  spin_unlock_irqrestore(lock, flags);
  }
#line 3299
  return;
}
}
#line 3301 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_111(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3304
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3306
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3307
  return;
}
}
#line 3317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_113(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3320
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3322
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3323
  return;
}
}
#line 3333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3337
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3338
  return;
}
}
#line 3340 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static bool ldv_try_module_get_116(struct module *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3343
  tmp = ldv_linux_kernel_module_try_module_get(ldv_func_arg1);
  }
#line 3343
  return (tmp != 0);
}
}
#line 3346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_module_put_117(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3349
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3350
  return;
}
}
#line 3352 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3356
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3357
  return;
}
}
#line 3359 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_119(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3362
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3364
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3365
  return;
}
}
#line 3375 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3379
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3380
  return;
}
}
#line 3382 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3386
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3387
  return;
}
}
#line 3389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3393
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3394
  return;
}
}
#line 3396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3400
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3401
  return;
}
}
#line 3403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_125(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3406
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3408
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3409
  return;
}
}
#line 3419 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3423
  ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3424
  return;
}
}
#line 3426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3430
  ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3431
  return;
}
}
#line 3433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3437
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3438
  return;
}
}
#line 3440 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_module_put_130(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3443
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3444
  return;
}
}
#line 3446 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3450
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3451
  return;
}
}
#line 3453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_132(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3456
  ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi();
#line 3458
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3459
  return;
}
}
#line 3461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void ldv_spin_unlock_irqrestore_133(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 3464
  ldv_linux_kernel_locking_spinlock_spin_unlock_maintenance_mode_lock_of_ipmi_smi();
#line 3466
  spin_unlock_irqrestore(lock, flags);
  }
#line 3467
  return;
}
}
#line 3469 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3472
  ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi();
#line 3474
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3475
  return;
}
}
#line 3485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3488
  ldv_linux_kernel_locking_spinlock_spin_lock_events_lock_of_ipmi_smi();
#line 3490
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3491
  return;
}
}
#line 3493 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void ldv_spin_unlock_irqrestore_137(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 3496
  ldv_linux_kernel_locking_spinlock_spin_unlock_events_lock_of_ipmi_smi();
#line 3498
  spin_unlock_irqrestore(lock, flags);
  }
#line 3499
  return;
}
}
#line 3501 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_138(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3504
  ldv_linux_kernel_locking_spinlock_spin_lock_events_lock_of_ipmi_smi();
#line 3506
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3507
  return;
}
}
#line 3517 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3521
  ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3522
  return;
}
}
#line 3524 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3528
  ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3529
  return;
}
}
#line 3531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3535
  ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3536
  return;
}
}
#line 3538 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3542
  ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(ldv_func_arg1);
  }
#line 3543
  return;
}
}
#line 3545 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_144(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3548
  ldv_linux_kernel_locking_spinlock_spin_lock_xmit_msgs_lock_of_ipmi_smi();
#line 3550
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3551
  return;
}
}
#line 3553 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void ldv_spin_unlock_irqrestore_145(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 3556
  ldv_linux_kernel_locking_spinlock_spin_unlock_xmit_msgs_lock_of_ipmi_smi();
#line 3558
  spin_unlock_irqrestore(lock, flags);
  }
#line 3559
  return;
}
}
#line 3561 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_146(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3564
  ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi();
#line 3566
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3567
  return;
}
}
#line 3577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_148(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3580
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3582
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3583
  return;
}
}
#line 3601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_151(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3604
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3606
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3607
  return;
}
}
#line 3625 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3629
  ldv_linux_kernel_locking_mutex_mutex_lock_proc_entry_lock_of_ipmi_smi(ldv_func_arg1);
  }
#line 3630
  return;
}
}
#line 3632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3636
  ldv_linux_kernel_locking_mutex_mutex_unlock_proc_entry_lock_of_ipmi_smi(ldv_func_arg1);
  }
#line 3637
  return;
}
}
#line 3639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3643
  ldv_linux_kernel_locking_mutex_mutex_lock_proc_entry_lock_of_ipmi_smi(ldv_func_arg1);
  }
#line 3644
  return;
}
}
#line 3646 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3650
  ldv_linux_kernel_locking_mutex_mutex_unlock_proc_entry_lock_of_ipmi_smi(ldv_func_arg1);
  }
#line 3651
  return;
}
}
#line 3653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3657
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmidriver_mutex(ldv_func_arg1);
  }
#line 3658
  return;
}
}
#line 3660 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3664
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmidriver_mutex(ldv_func_arg1);
  }
#line 3665
  return;
}
}
#line 3667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3671
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmidriver_mutex(ldv_func_arg1);
  }
#line 3672
  return;
}
}
#line 3674 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3678
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmidriver_mutex(ldv_func_arg1);
  }
#line 3679
  return;
}
}
#line 3681 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3685
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmidriver_mutex(ldv_func_arg1);
  }
#line 3686
  return;
}
}
#line 3688 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3692
  ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3693
  return;
}
}
#line 3695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_164(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3699
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3700
  return;
}
}
#line 3702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_165(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3706
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3707
  return;
}
}
#line 3709 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3713
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3714
  return;
}
}
#line 3716 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_167(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3720
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3721
  return;
}
}
#line 3723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_168(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3727
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3728
  return;
}
}
#line 3730 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_169(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3734
  ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3735
  return;
}
}
#line 3737 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_170(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3741
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3742
  return;
}
}
#line 3744 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3748
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3749
  return;
}
}
#line 3751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_lock_172(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3755
  ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3756
  return;
}
}
#line 3758 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_module_put_173(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3761
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3762
  return;
}
}
#line 3764 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3768
  ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(ldv_func_arg1);
  }
#line 3769
  return;
}
}
#line 3771 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3775
  ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(ldv_func_arg1);
  }
#line 3776
  return;
}
}
#line 3778 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_176(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3781
  ldv_linux_kernel_locking_spinlock_spin_lock_events_lock_of_ipmi_smi();
#line 3783
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3784
  return;
}
}
#line 3794 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_178(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3797
  ldv_linux_kernel_locking_spinlock_spin_lock_waiting_rcv_msgs_lock_of_ipmi_smi();
#line 3799
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3800
  return;
}
}
#line 3802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
__inline static void ldv_spin_unlock_irqrestore_179(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 3805
  ldv_linux_kernel_locking_spinlock_spin_unlock_waiting_rcv_msgs_lock_of_ipmi_smi();
#line 3807
  spin_unlock_irqrestore(lock, flags);
  }
#line 3808
  return;
}
}
#line 3810 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_180(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3813
  ldv_linux_kernel_locking_spinlock_spin_lock_waiting_rcv_msgs_lock_of_ipmi_smi();
#line 3815
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3816
  return;
}
}
#line 3826 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_182(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3829
  ldv_linux_kernel_locking_spinlock_spin_lock_xmit_msgs_lock_of_ipmi_smi();
#line 3831
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3832
  return;
}
}
#line 3842 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_184(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3845
  ldv_linux_kernel_locking_spinlock_spin_lock_waiting_rcv_msgs_lock_of_ipmi_smi();
#line 3847
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3848
  return;
}
}
#line 3858 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_186(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3861
  ldv_linux_kernel_locking_spinlock_spin_lock_xmit_msgs_lock_of_ipmi_smi();
#line 3863
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3864
  return;
}
}
#line 3882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_189(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3885
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3887
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3888
  return;
}
}
#line 3890 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_190(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3893
  ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi();
#line 3895
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3896
  return;
}
}
#line 3906 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_192(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3909
  ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi();
#line 3911
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3912
  return;
}
}
#line 3922 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_mod_timer_194(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3926
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3926
  ldv_func_res = tmp;
#line 3929
  tmp___0 = ldv_mod_timer(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3929
  return (tmp___0);
#line 3931
  return (ldv_func_res);
}
}
#line 3934 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_mod_timer_195(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3938
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3938
  ldv_func_res = tmp;
#line 3941
  tmp___0 = ldv_mod_timer(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3941
  return (tmp___0);
#line 3943
  return (ldv_func_res);
}
}
#line 3946 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_mod_timer_196(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3950
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3950
  ldv_func_res = tmp;
#line 3953
  tmp___0 = ldv_mod_timer(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3953
  return (tmp___0);
#line 3955
  return (ldv_func_res);
}
}
#line 3958 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_atomic_notifier_chain_register_197(struct atomic_notifier_head *ldv_func_arg1 ,
                                                  struct notifier_block *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3962
  tmp = atomic_notifier_chain_register(ldv_func_arg1, ldv_func_arg2);
#line 3962
  ldv_func_res = tmp;
#line 3965
  tmp___0 = ldv_atomic_notifier_chain_register(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3965
  return (tmp___0);
#line 3967
  return (ldv_func_res);
}
}
#line 3970 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_atomic_notifier_chain_unregister_198(struct atomic_notifier_head *ldv_func_arg1 ,
                                                    struct notifier_block *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3974
  tmp = atomic_notifier_chain_unregister(ldv_func_arg1, ldv_func_arg2);
#line 3974
  ldv_func_res = tmp;
#line 3977
  tmp___0 = ldv_atomic_notifier_chain_unregister(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3977
  return (tmp___0);
#line 3979
  return (ldv_func_res);
}
}
#line 3982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_del_timer_sync_199(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3986
  tmp = del_timer_sync(ldv_func_arg1);
#line 3986
  ldv_func_res = tmp;
#line 3989
  tmp___0 = ldv_del_timer_sync(ldv_func_res, ldv_func_arg1);
  }
#line 3989
  return (tmp___0);
#line 3991
  return (ldv_func_res);
}
}
#line 3994 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static int ldv_ldv_post_init_200(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3998
  ldv_linux_net_register_reset_error_counter();
#line 4002
  ldv_linux_usb_register_reset_error_counter();
#line 4005
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 4005
  return (tmp);
}
}
#line 4008 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_ldv_check_final_state_201(void) 
{ 


  {
  {
#line 4012
  ldv_linux_arch_io_check_final_state();
#line 4016
  ldv_linux_block_genhd_check_final_state();
#line 4020
  ldv_linux_block_queue_check_final_state();
#line 4024
  ldv_linux_block_request_check_final_state();
#line 4028
  ldv_linux_drivers_base_class_check_final_state();
#line 4036
  ldv_linux_fs_char_dev_check_final_state();
#line 4040
  ldv_linux_fs_sysfs_check_final_state();
#line 4044
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 4048
  ldv_linux_kernel_module_check_final_state();
#line 4052
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 4056
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 4060
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 4064
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 4068
  ldv_linux_lib_idr_check_final_state();
#line 4072
  ldv_linux_mmc_sdio_func_check_final_state();
#line 4076
  ldv_linux_net_rtnetlink_check_final_state();
#line 4080
  ldv_linux_net_sock_check_final_state();
#line 4084
  ldv_linux_usb_coherent_check_final_state();
#line 4088
  ldv_linux_usb_gadget_check_final_state();
#line 4092
  ldv_linux_usb_urb_check_final_state();
  }
#line 4093
  return;
}
}
#line 4096 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_ldv_check_final_state_202(void) 
{ 


  {
  {
#line 4100
  ldv_linux_arch_io_check_final_state();
#line 4104
  ldv_linux_block_genhd_check_final_state();
#line 4108
  ldv_linux_block_queue_check_final_state();
#line 4112
  ldv_linux_block_request_check_final_state();
#line 4116
  ldv_linux_drivers_base_class_check_final_state();
#line 4124
  ldv_linux_fs_char_dev_check_final_state();
#line 4128
  ldv_linux_fs_sysfs_check_final_state();
#line 4132
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 4136
  ldv_linux_kernel_module_check_final_state();
#line 4140
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 4144
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 4148
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 4152
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 4156
  ldv_linux_lib_idr_check_final_state();
#line 4160
  ldv_linux_mmc_sdio_func_check_final_state();
#line 4164
  ldv_linux_net_rtnetlink_check_final_state();
#line 4168
  ldv_linux_net_sock_check_final_state();
#line 4172
  ldv_linux_usb_coherent_check_final_state();
#line 4176
  ldv_linux_usb_gadget_check_final_state();
#line 4180
  ldv_linux_usb_urb_check_final_state();
  }
#line 4181
  return;
}
}
#line 4184 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/weaver/.tmp_ipmi_msghandler.c.aux"
static void ldv_ldv_initialize_203(void) 
{ 


  {
  {
#line 4188
  ldv_linux_lib_find_bit_initialize();
  }
#line 4189
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 67 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_post_probe(int probe_ret_val ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_cmd_rcvrs_mutex_of_ipmi_smi(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(atomic_t *cnt ,
                                                                                         struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_cmd_rcvrs_mutex_of_ipmi_smi(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_cmd_rcvrs_mutex_of_ipmi_smi(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_ipmi_interfaces_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_ipmi_interfaces_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_ipmi_interfaces_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_ipmi_interfaces_mutex(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_ipmi_interfaces_mutex(atomic_t *cnt ,
                                                                                   struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_ipmi_interfaces_mutex(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_ipmi_interfaces_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex = 0;
  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex  ;
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_ipmidriver_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 312
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex);
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex = 1;
  }
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_ipmidriver_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex);
#line 323
  tmp = ldv_undef_int();
  }
#line 323
  if (tmp != 0) {
#line 325
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex = 1;
#line 327
    return (0);
  } else {
#line 331
    return (-4);
  }
}
}
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_ipmidriver_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex) {
#line 341
    return (1);
  } else {
    {
#line 344
    tmp = ldv_undef_int();
    }
#line 344
    if (tmp != 0) {
#line 346
      return (1);
    } else {
#line 350
      return (0);
    }
  }
}
}
#line 355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_ipmidriver_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 358
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex);
#line 361
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_ipmidriver_mutex(lock);
  }
#line 361
  if (tmp != 0) {
#line 363
    return (0);
  } else {
#line 367
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex = 1;
#line 369
    return (1);
  }
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_ipmidriver_mutex(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 377
  cnt->counter = cnt->counter - 1;
#line 380
  if (cnt->counter != 0) {
#line 382
    return (0);
  } else {
    {
#line 385
    ldv_linux_kernel_locking_mutex_mutex_lock_ipmidriver_mutex(lock);
    }
#line 387
    return (1);
  }
}
}
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_ipmidriver_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 395
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex);
#line 397
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex = 0;
  }
#line 398
  return;
}
}
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 405
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 407
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 408
  return;
}
}
#line 411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 414
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 416
  tmp = ldv_undef_int();
  }
#line 416
  if (tmp != 0) {
#line 418
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 420
    return (0);
  } else {
#line 424
    return (-4);
  }
}
}
#line 429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 432
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 434
    return (1);
  } else {
    {
#line 437
    tmp = ldv_undef_int();
    }
#line 437
    if (tmp != 0) {
#line 439
      return (1);
    } else {
#line 443
      return (0);
    }
  }
}
}
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 451
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 454
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 454
  if (tmp != 0) {
#line 456
    return (0);
  } else {
#line 460
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 462
    return (1);
  }
}
}
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 470
  cnt->counter = cnt->counter - 1;
#line 473
  if (cnt->counter != 0) {
#line 475
    return (0);
  } else {
    {
#line 478
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 488
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 490
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 491
  return;
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 495 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 498
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 500
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 501
  return;
}
}
#line 504 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 507
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 509
  tmp = ldv_undef_int();
  }
#line 509
  if (tmp != 0) {
#line 511
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 513
    return (0);
  } else {
#line 517
    return (-4);
  }
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 525
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 527
    return (1);
  } else {
    {
#line 530
    tmp = ldv_undef_int();
    }
#line 530
    if (tmp != 0) {
#line 532
      return (1);
    } else {
#line 536
      return (0);
    }
  }
}
}
#line 541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 544
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 547
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 547
  if (tmp != 0) {
#line 549
    return (0);
  } else {
#line 553
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 555
    return (1);
  }
}
}
#line 560 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 563
  cnt->counter = cnt->counter - 1;
#line 566
  if (cnt->counter != 0) {
#line 568
    return (0);
  } else {
    {
#line 571
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 573
    return (1);
  }
}
}
#line 578 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 581
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 583
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 584
  return;
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi  ;
#line 588 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) 
{ 


  {
  {
#line 591
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi);
#line 593
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi = 1;
  }
#line 594
  return;
}
}
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 600
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi);
#line 602
  tmp = ldv_undef_int();
  }
#line 602
  if (tmp != 0) {
#line 604
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi = 1;
#line 606
    return (0);
  } else {
#line 610
    return (-4);
  }
}
}
#line 615 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 618
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi) {
#line 620
    return (1);
  } else {
    {
#line 623
    tmp = ldv_undef_int();
    }
#line 623
    if (tmp != 0) {
#line 625
      return (1);
    } else {
#line 629
      return (0);
    }
  }
}
}
#line 634 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 637
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi);
#line 640
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_proc_entry_lock_of_ipmi_smi(lock);
  }
#line 640
  if (tmp != 0) {
#line 642
    return (0);
  } else {
#line 646
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi = 1;
#line 648
    return (1);
  }
}
}
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_proc_entry_lock_of_ipmi_smi(atomic_t *cnt ,
                                                                                         struct mutex *lock ) 
{ 


  {
#line 656
  cnt->counter = cnt->counter - 1;
#line 659
  if (cnt->counter != 0) {
#line 661
    return (0);
  } else {
    {
#line 664
    ldv_linux_kernel_locking_mutex_mutex_lock_proc_entry_lock_of_ipmi_smi(lock);
    }
#line 666
    return (1);
  }
}
}
#line 671 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_proc_entry_lock_of_ipmi_smi(struct mutex *lock ) 
{ 


  {
  {
#line 674
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi);
#line 676
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi = 0;
  }
#line 677
  return;
}
}
#line 678 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex  ;
#line 681 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 684
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex);
#line 686
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex = 1;
  }
#line 687
  return;
}
}
#line 690 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_smi_watchers_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 693
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex);
#line 695
  tmp = ldv_undef_int();
  }
#line 695
  if (tmp != 0) {
#line 697
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex = 1;
#line 699
    return (0);
  } else {
#line 703
    return (-4);
  }
}
}
#line 708 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_smi_watchers_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 711
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex) {
#line 713
    return (1);
  } else {
    {
#line 716
    tmp = ldv_undef_int();
    }
#line 716
    if (tmp != 0) {
#line 718
      return (1);
    } else {
#line 722
      return (0);
    }
  }
}
}
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_smi_watchers_mutex(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 730
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex);
#line 733
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_smi_watchers_mutex(lock);
  }
#line 733
  if (tmp != 0) {
#line 735
    return (0);
  } else {
#line 739
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex = 1;
#line 741
    return (1);
  }
}
}
#line 746 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_smi_watchers_mutex(atomic_t *cnt ,
                                                                                struct mutex *lock ) 
{ 


  {
#line 749
  cnt->counter = cnt->counter - 1;
#line 752
  if (cnt->counter != 0) {
#line 754
    return (0);
  } else {
    {
#line 757
    ldv_linux_kernel_locking_mutex_mutex_lock_smi_watchers_mutex(lock);
    }
#line 759
    return (1);
  }
}
}
#line 764 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_smi_watchers_mutex(struct mutex *lock ) 
{ 


  {
  {
#line 767
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex);
#line 769
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex = 0;
  }
#line 770
  return;
}
}
#line 772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 775
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi = 0;
#line 777
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 779
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex = 0;
#line 781
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex = 0;
#line 783
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 785
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 787
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi = 0;
#line 789
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex = 0;
#line 790
  return;
}
}
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_cmd_rcvrs_mutex_of_ipmi_smi);
#line 798
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 800
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmi_interfaces_mutex);
#line 802
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ipmidriver_mutex);
#line 804
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 806
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 808
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_proc_entry_lock_of_ipmi_smi);
#line 810
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_smi_watchers_mutex);
  }
#line 811
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_events_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_events_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_events_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_events_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_events_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_events_lock_of_ipmi_smi(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_events_lock_of_ipmi_smi();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_events_lock_of_ipmi_smi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_events_lock_of_ipmi_smi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_maintenance_mode_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_maintenance_mode_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_maintenance_mode_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_maintenance_mode_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_maintenance_mode_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_maintenance_mode_lock_of_ipmi_smi(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_maintenance_mode_lock_of_ipmi_smi();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_maintenance_mode_lock_of_ipmi_smi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_maintenance_mode_lock_of_ipmi_smi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ptl  =    1;
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ptl(void) 
{ 


  {
  {
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 926
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 928
  ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ptl(void) 
{ 


  {
  {
#line 935
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 937
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 939
  ldv_linux_kernel_locking_spinlock_spin_ptl = 1;
  }
#line 940
  return;
}
}
#line 943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 950
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 953
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 956
  if (is_spin_held_by_another_thread != 0) {
#line 958
    return (0);
  } else {
#line 962
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 964
    return (1);
  }
}
}
#line 969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ptl(void) 
{ 


  {
  {
#line 972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 974
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
  }
#line 975
  return;
}
}
#line 978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 983
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 986
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 1 && is_spin_held_by_another_thread == 0) {
#line 988
    return (0);
  } else {
#line 992
    return (1);
  }
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ptl(void) 
{ 
  int tmp ;

  {
  {
#line 1000
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl();
  }
#line 1000
  return (tmp == 0);
}
}
#line 1004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ptl(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1009
  is_spin_contended = ldv_undef_int();
  }
#line 1012
  if (is_spin_contended != 0) {
#line 1014
    return (0);
  } else {
#line 1018
    return (1);
  }
}
}
#line 1023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ptl(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1028
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1030
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1033
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1036
  if (atomic_value_after_dec == 0) {
#line 1038
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 1040
    return (1);
  } else {

  }
#line 1044
  return (0);
}
}
#line 1046 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi  =    1;
#line 1049 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_seq_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1054
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1056
  ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi = 2;
  }
#line 1057
  return;
}
}
#line 1060 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_seq_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1063
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 2);
#line 1065
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 2);
#line 1067
  ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi = 1;
  }
#line 1068
  return;
}
}
#line 1071 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_seq_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1078
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1081
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1084
  if (is_spin_held_by_another_thread != 0) {
#line 1086
    return (0);
  } else {
#line 1090
    ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi = 2;
#line 1092
    return (1);
  }
}
}
#line 1097 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_seq_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1102
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
  }
#line 1103
  return;
}
}
#line 1106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_seq_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1111
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1114
  if (ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1 && is_spin_held_by_another_thread == 0) {
#line 1116
    return (0);
  } else {
#line 1120
    return (1);
  }
}
}
#line 1125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_seq_lock_of_ipmi_smi(void) 
{ 
  int tmp ;

  {
  {
#line 1128
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_seq_lock_of_ipmi_smi();
  }
#line 1128
  return (tmp == 0);
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_seq_lock_of_ipmi_smi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1137
  is_spin_contended = ldv_undef_int();
  }
#line 1140
  if (is_spin_contended != 0) {
#line 1142
    return (0);
  } else {
#line 1146
    return (1);
  }
}
}
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_seq_lock_of_ipmi_smi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1161
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1164
  if (atomic_value_after_dec == 0) {
#line 1166
    ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi = 2;
#line 1168
    return (1);
  } else {

  }
#line 1172
  return (0);
}
}
#line 1174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 1177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1184
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 1185
  return;
}
}
#line 1188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1191
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1193
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1195
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 1196
  return;
}
}
#line 1199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1209
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1212
  if (is_spin_held_by_another_thread != 0) {
#line 1214
    return (0);
  } else {
#line 1218
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1220
    return (1);
  }
}
}
#line 1225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1230
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 1231
  return;
}
}
#line 1234 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1239
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1242
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 1244
    return (0);
  } else {
#line 1248
    return (1);
  }
}
}
#line 1253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 1256
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 1256
  return (tmp == 0);
}
}
#line 1260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1265
  is_spin_contended = ldv_undef_int();
  }
#line 1268
  if (is_spin_contended != 0) {
#line 1270
    return (0);
  } else {
#line 1274
    return (1);
  }
}
}
#line 1279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1289
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1292
  if (atomic_value_after_dec == 0) {
#line 1294
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1296
    return (1);
  } else {

  }
#line 1300
  return (0);
}
}
#line 1302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi  =    1;
#line 1305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1312
  ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi = 2;
  }
#line 1313
  return;
}
}
#line 1316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1319
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 2);
#line 1321
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 2);
#line 1323
  ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi = 1;
  }
#line 1324
  return;
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1337
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1340
  if (is_spin_held_by_another_thread != 0) {
#line 1342
    return (0);
  } else {
#line 1346
    ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi = 2;
#line 1348
    return (1);
  }
}
}
#line 1353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1356
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1358
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
  }
#line 1359
  return;
}
}
#line 1362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1367
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1370
  if (ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1 && is_spin_held_by_another_thread == 0) {
#line 1372
    return (0);
  } else {
#line 1376
    return (1);
  }
}
}
#line 1381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 
  int tmp ;

  {
  {
#line 1384
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_waiting_rcv_msgs_lock_of_ipmi_smi();
  }
#line 1384
  return (tmp == 0);
}
}
#line 1388 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1393
  is_spin_contended = ldv_undef_int();
  }
#line 1396
  if (is_spin_contended != 0) {
#line 1398
    return (0);
  } else {
#line 1402
    return (1);
  }
}
}
#line 1407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_waiting_rcv_msgs_lock_of_ipmi_smi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1417
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1420
  if (atomic_value_after_dec == 0) {
#line 1422
    ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi = 2;
#line 1424
    return (1);
  } else {

  }
#line 1428
  return (0);
}
}
#line 1430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi  =    1;
#line 1433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_xmit_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1440
  ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi = 2;
  }
#line 1441
  return;
}
}
#line 1444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_xmit_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1447
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 2);
#line 1449
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 2);
#line 1451
  ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi = 1;
  }
#line 1452
  return;
}
}
#line 1455 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_xmit_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1465
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1468
  if (is_spin_held_by_another_thread != 0) {
#line 1470
    return (0);
  } else {
#line 1474
    ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi = 2;
#line 1476
    return (1);
  }
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_xmit_msgs_lock_of_ipmi_smi(void) 
{ 


  {
  {
#line 1484
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1486
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
  }
#line 1487
  return;
}
}
#line 1490 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_xmit_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1495
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1498
  if (ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1 && is_spin_held_by_another_thread == 0) {
#line 1500
    return (0);
  } else {
#line 1504
    return (1);
  }
}
}
#line 1509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_xmit_msgs_lock_of_ipmi_smi(void) 
{ 
  int tmp ;

  {
  {
#line 1512
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_xmit_msgs_lock_of_ipmi_smi();
  }
#line 1512
  return (tmp == 0);
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_xmit_msgs_lock_of_ipmi_smi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1521
  is_spin_contended = ldv_undef_int();
  }
#line 1524
  if (is_spin_contended != 0) {
#line 1526
    return (0);
  } else {
#line 1530
    return (1);
  }
}
}
#line 1535 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_xmit_msgs_lock_of_ipmi_smi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
#line 1545
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1548
  if (atomic_value_after_dec == 0) {
#line 1550
    ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi = 2;
#line 1552
    return (1);
  } else {

  }
#line 1556
  return (0);
}
}
#line 1559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 1562
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 1564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 1);
#line 1566
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 1568
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1570
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1572
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 1);
#line 1574
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1576
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1578
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 1);
#line 1580
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1582
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 1);
#line 1584
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 1);
  }
#line 1585
  return;
}
}
#line 1588 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 1591
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 1593
    return (1);
  } else {

  }
#line 1596
  if (ldv_linux_kernel_locking_spinlock_spin_events_lock_of_ipmi_smi == 2) {
#line 1598
    return (1);
  } else {

  }
#line 1601
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 1603
    return (1);
  } else {

  }
#line 1606
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 1608
    return (1);
  } else {

  }
#line 1611
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 1613
    return (1);
  } else {

  }
#line 1616
  if (ldv_linux_kernel_locking_spinlock_spin_maintenance_mode_lock_of_ipmi_smi == 2) {
#line 1618
    return (1);
  } else {

  }
#line 1621
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 1623
    return (1);
  } else {

  }
#line 1626
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 2) {
#line 1628
    return (1);
  } else {

  }
#line 1631
  if (ldv_linux_kernel_locking_spinlock_spin_seq_lock_of_ipmi_smi == 2) {
#line 1633
    return (1);
  } else {

  }
#line 1636
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 1638
    return (1);
  } else {

  }
#line 1641
  if (ldv_linux_kernel_locking_spinlock_spin_waiting_rcv_msgs_lock_of_ipmi_smi == 2) {
#line 1643
    return (1);
  } else {

  }
#line 1646
  if (ldv_linux_kernel_locking_spinlock_spin_xmit_msgs_lock_of_ipmi_smi == 2) {
#line 1648
    return (1);
  } else {

  }
#line 1651
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion = 2;
  }
#line 52
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/char/ipmi/ipmi_msghandler.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error();
    }
  } else {

  }
#line 383
  return;
}
}
