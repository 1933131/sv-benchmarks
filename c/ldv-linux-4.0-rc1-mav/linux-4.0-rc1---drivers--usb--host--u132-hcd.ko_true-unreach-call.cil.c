/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u16 __le16;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct class;
#line 131
struct urb;
#line 199
struct device;
#line 245
struct completion;
#line 252
struct usb_device;
#line 277
struct gendisk;
#line 338
struct module;
#line 346
struct mutex;
#line 510
struct request_queue;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 609
struct timespec;
#line 610
struct compat_timespec;
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_nanosleep_31 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 611
struct pollfd;
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_29 __annonCompField19 ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
union __anonunion____missing_field_name_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_46 __annonCompField20 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 115
struct kernfs_root;
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_47 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_47 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_48 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_48 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_49 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_49 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct tvec_base;
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_50 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_50 nodemask_t;
#line 520
struct path;
#line 521
struct inode;
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 1269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196
struct of_device_id;
#line 196
struct acpi_device_id;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 623
struct mfd_cell;
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
   bool prevent_deferred_probe ;
};
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kmod.h"
struct cred;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_153 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_154 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_152 {
   struct __anonstruct____missing_field_name_153 __annonCompField36 ;
   struct __anonstruct____missing_field_name_154 __annonCompField37 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_152 __annonCompField38 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_161 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_161 __annonCompField41 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   union __anonunion____missing_field_name_160 __annonCompField42 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_159 __annonCompField43 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   union __anonunion____missing_field_name_157 __annonCompField40 ;
   union __anonunion____missing_field_name_158 __annonCompField44 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_163 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_164 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_162 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_163 __annonCompField46 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_164 __annonCompField47 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_165 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   struct __anonstruct____missing_field_name_156 __annonCompField45 ;
   union __anonunion____missing_field_name_162 __annonCompField48 ;
   union __anonunion____missing_field_name_165 __annonCompField49 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_166 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_166 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_171 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_171 __annonCompField50 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/shm.h"
struct user_struct;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_173 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_173 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_175 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_176 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_177 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_178 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_180 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_179 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_180 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_181 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_182 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_174 {
   int _pad[28U] ;
   struct __anonstruct__kill_175 _kill ;
   struct __anonstruct__timer_176 _timer ;
   struct __anonstruct__rt_177 _rt ;
   struct __anonstruct__sigchld_178 _sigchld ;
   struct __anonstruct__sigfault_179 _sigfault ;
   struct __anonstruct__sigpoll_181 _sigpoll ;
   struct __anonstruct__sigsys_182 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_174 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_185 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_186 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_188 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_187 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_188 __annonCompField53 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_189 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_191 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_190 {
   union __anonunion_payload_191 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_185 __annonCompField51 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_187 __annonCompField54 ;
   union __anonunion_type_data_189 type_data ;
   union __anonunion____missing_field_name_190 __annonCompField55 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct backing_dev_info;
#line 825
struct reclaim_state;
#line 826 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1073
struct io_context;
#line 1107
struct pipe_inode_info;
#line 1109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 445 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 926
enum usb3_link_state {
    USB3_LPM_U0 = 0,
    USB3_LPM_U1 = 1,
    USB3_LPM_U2 = 2,
    USB3_LPM_U3 = 3
} ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_201 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_200 {
   struct __anonstruct____missing_field_name_201 __annonCompField62 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_200 __annonCompField63 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct vfsmount;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_203 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_202 {
   struct __anonstruct____missing_field_name_203 __annonCompField64 ;
   u64 hash_len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_202 __annonCompField65 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_204 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_204 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_206 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_205 {
   struct __anonstruct____missing_field_name_206 __annonCompField66 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_205 __annonCompField67 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct iovec;
#line 63
struct nameidata;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_208 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_208 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_209 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_209 __annonCompField69 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 460
struct writeback_control;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_212 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_213 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532
struct cdev;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_214 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_212 __annonCompField70 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_213 __annonCompField71 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_214 __annonCompField72 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_215 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_215 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_217 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_216 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_217 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_216 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_runtime.h"
struct wusb_dev;
#line 284
struct ep_device;
#line 285 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 230 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 318
struct mon_bus;
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 369
struct usb_tt;
#line 370
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 404 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 443 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1236
struct scatterlist;
#line 1236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 1868 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct giveback_urb_bh {
   bool running ;
   spinlock_t lock ;
   struct list_head head ;
   struct tasklet_struct bh ;
   struct usb_host_endpoint *completing_ep ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb/hcd.h"
struct hc_driver;
#line 78
struct usb_phy;
#line 78
struct phy;
#line 78
struct dma_pool;
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb/hcd.h"
struct usb_hcd {
   struct usb_bus self ;
   struct kref kref ;
   char const   *product_desc ;
   int speed ;
   char irq_descr[24U] ;
   struct timer_list rh_timer ;
   struct urb *status_urb ;
   struct work_struct wakeup_work ;
   struct hc_driver  const  *driver ;
   struct usb_phy *usb_phy ;
   struct phy *phy ;
   unsigned long flags ;
   unsigned char rh_registered : 1 ;
   unsigned char rh_pollable : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char remove_phy : 1 ;
   unsigned char uses_new_polling : 1 ;
   unsigned char wireless : 1 ;
   unsigned char authorized_default : 1 ;
   unsigned char has_tt : 1 ;
   unsigned char amd_resume_bug : 1 ;
   unsigned char can_do_streams : 1 ;
   unsigned char tpl_support : 1 ;
   unsigned char cant_recv_wakeups : 1 ;
   unsigned int irq ;
   void *regs ;
   resource_size_t rsrc_start ;
   resource_size_t rsrc_len ;
   unsigned int power_budget ;
   struct giveback_urb_bh high_prio_bh ;
   struct giveback_urb_bh low_prio_bh ;
   struct mutex *bandwidth_mutex ;
   struct usb_hcd *shared_hcd ;
   struct usb_hcd *primary_hcd ;
   struct dma_pool *pool[4U] ;
   int state ;
   unsigned long hcd_priv[0U] ;
};
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb/hcd.h"
struct hc_driver {
   char const   *description ;
   char const   *product_desc ;
   size_t hcd_priv_size ;
   irqreturn_t (*irq)(struct usb_hcd * ) ;
   int flags ;
   int (*reset)(struct usb_hcd * ) ;
   int (*start)(struct usb_hcd * ) ;
   int (*pci_suspend)(struct usb_hcd * , bool  ) ;
   int (*pci_resume)(struct usb_hcd * , bool  ) ;
   void (*stop)(struct usb_hcd * ) ;
   void (*shutdown)(struct usb_hcd * ) ;
   int (*get_frame_number)(struct usb_hcd * ) ;
   int (*urb_enqueue)(struct usb_hcd * , struct urb * , gfp_t  ) ;
   int (*urb_dequeue)(struct usb_hcd * , struct urb * , int  ) ;
   int (*map_urb_for_dma)(struct usb_hcd * , struct urb * , gfp_t  ) ;
   void (*unmap_urb_for_dma)(struct usb_hcd * , struct urb * ) ;
   void (*endpoint_disable)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   void (*endpoint_reset)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   int (*hub_status_data)(struct usb_hcd * , char * ) ;
   int (*hub_control)(struct usb_hcd * , u16  , u16  , u16  , char * , u16  ) ;
   int (*bus_suspend)(struct usb_hcd * ) ;
   int (*bus_resume)(struct usb_hcd * ) ;
   int (*start_port_reset)(struct usb_hcd * , unsigned int  ) ;
   void (*relinquish_port)(struct usb_hcd * , int  ) ;
   int (*port_handed_over)(struct usb_hcd * , int  ) ;
   void (*clear_tt_buffer_complete)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   int (*alloc_dev)(struct usb_hcd * , struct usb_device * ) ;
   void (*free_dev)(struct usb_hcd * , struct usb_device * ) ;
   int (*alloc_streams)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint ** ,
                        unsigned int  , unsigned int  , gfp_t  ) ;
   int (*free_streams)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint ** ,
                       unsigned int  , gfp_t  ) ;
   int (*add_endpoint)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ;
   int (*drop_endpoint)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ;
   int (*check_bandwidth)(struct usb_hcd * , struct usb_device * ) ;
   void (*reset_bandwidth)(struct usb_hcd * , struct usb_device * ) ;
   int (*address_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*enable_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*update_hub_device)(struct usb_hcd * , struct usb_device * , struct usb_tt * ,
                            gfp_t  ) ;
   int (*reset_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*update_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*set_usb2_hw_lpm)(struct usb_hcd * , struct usb_device * , int  ) ;
   int (*enable_usb3_lpm_timeout)(struct usb_hcd * , struct usb_device * , enum usb3_link_state  ) ;
   int (*disable_usb3_lpm_timeout)(struct usb_hcd * , struct usb_device * , enum usb3_link_state  ) ;
   int (*find_raw_port_number)(struct usb_hcd * , int  ) ;
   int (*port_power)(struct usb_hcd * , int  , bool  ) ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch11.h"
struct __anonstruct_hs_219 {
   __u8 DeviceRemovable[4U] ;
   __u8 PortPwrCtrlMask[4U] ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch11.h"
struct __anonstruct_ss_220 {
   __u8 bHubHdrDecLat ;
   __le16 wHubDelay ;
   __le16 DeviceRemovable ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch11.h"
union __anonunion_u_218 {
   struct __anonstruct_hs_219 hs ;
   struct __anonstruct_ss_220 ss ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch11.h"
struct usb_hub_descriptor {
   __u8 bDescLength ;
   __u8 bDescriptorType ;
   __u8 bNbrPorts ;
   __le16 wHubCharacteristics ;
   __u8 bPwrOn2PwrGood ;
   __u8 bHubContrCurrent ;
   union __anonunion_u_218 u ;
};
#line 266 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch11.h"
struct usb_tt {
   struct usb_device *hub ;
   int multi ;
   unsigned int think_time ;
   void *hcpriv ;
   spinlock_t lock ;
   struct list_head clear_list ;
   struct work_struct clear_work ;
};
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_port {
   struct u132 *u132 ;
   int reset ;
   int enable ;
   int power ;
   int Status ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_addr {
   u8 address ;
};
#line 126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_udev {
   struct kref kref ;
   struct usb_device *usb_device ;
   u8 enumeration ;
   u8 udev_number ;
   u8 usb_addr ;
   u8 portnumber ;
   u8 endp_number_in[16U] ;
   u8 endp_number_out[16U] ;
};
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_urbq {
   struct list_head urb_more ;
   struct urb *urb ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_spin {
   spinlock_t slock ;
};
#line 146
struct u132_ring;
#line 146 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_endp {
   struct kref kref ;
   u8 udev_number ;
   u8 endp_number ;
   u8 usb_addr ;
   u8 usb_endp ;
   struct u132 *u132 ;
   struct list_head endp_ring ;
   struct u132_ring *ring ;
   unsigned char toggle_bits : 2 ;
   unsigned char active : 1 ;
   unsigned char delayed : 1 ;
   unsigned char input : 1 ;
   unsigned char output : 1 ;
   unsigned char pipetype : 2 ;
   unsigned char dequeueing : 1 ;
   unsigned char edset_flush : 1 ;
   unsigned short spare_bits : 14 ;
   unsigned long jiffies ;
   struct usb_host_endpoint *hep ;
   struct u132_spin queue_lock ;
   u16 queue_size ;
   u16 queue_last ;
   u16 queue_next ;
   struct urb *urb_list[8U] ;
   struct list_head urb_more ;
   struct delayed_work scheduler ;
};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132_ring {
   unsigned char in_use : 1 ;
   unsigned char length : 7 ;
   u8 number ;
   struct u132 *u132 ;
   struct u132_endp *curr_endp ;
   struct delayed_work scheduler ;
};
#line 182
struct u132_platform_data;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct u132 {
   struct kref kref ;
   struct list_head u132_list ;
   struct mutex sw_lock ;
   struct mutex scheduler_lock ;
   struct u132_platform_data *board ;
   struct platform_device *platform_dev ;
   struct u132_ring ring[4U] ;
   int sequence_num ;
   int going ;
   int power ;
   int reset ;
   int num_ports ;
   u32 hc_control ;
   u32 hc_fminterval ;
   u32 hc_roothub_status ;
   u32 hc_roothub_a ;
   u32 hc_roothub_portstatus[15U] ;
   int flags ;
   unsigned long next_statechange ;
   struct delayed_work monitor ;
   int num_endpoints ;
   struct u132_addr addr[128U] ;
   struct u132_udev udev[4U] ;
   struct u132_port port[7U] ;
   struct u132_endp *endp[100U] ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/misc/usb_u132.h"
struct u132_platform_data {
   u16 vendor ;
   u16 device ;
   u8 potpg ;
   void (*port_power)(struct device * , int  ) ;
   void (*reset)(struct device * ) ;
};
#line 3261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
struct ldv_struct_platform_instance_0 {
   struct platform_driver *arg0 ;
   int signal_pending ;
};
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_struct_timer_instance_3 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
#line 3780 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
typedef int ldv_func_ret_type___0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 16
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 97
void ldv_linux_net_register_check_return_value_probe(int retval ) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 127
void ldv_linux_usb_register_check_return_value_probe(int retval ) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 223
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) ;
#line 228
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_259(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_256(int ldv_func_arg1 ) ;
#line 58
extern void ldv_pre_probe(void) ;
#line 61
static void ldv_ldv_pre_probe_260(void) ;
#line 67
int ldv_post_probe(int probe_ret_val ) ;
#line 70
static int ldv_ldv_post_probe_261(int retval ) ;
#line 79
int ldv_filter_err_code(int ret_val ) ;
#line 122
static void ldv_ldv_check_final_state_257(void) ;
#line 126
static void ldv_ldv_check_final_state_258(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
extern void ldv_after_alloc(void * ) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 312
  ldv_check_alloc_flags(flags);
#line 313
  tmp = ldv_malloc_unknown_size();
  }
#line 313
  return (tmp);
}
}
#line 366
static void ldv_mutex_lock_94(struct mutex *ldv_func_arg1 ) ;
#line 370
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) ;
#line 374
static void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) ;
#line 378
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) ;
#line 382
static void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) ;
#line 386
static void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) ;
#line 390
static void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) ;
#line 394
static void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) ;
#line 398
static void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) ;
#line 402
static void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) ;
#line 406
static void ldv_mutex_lock_161(struct mutex *ldv_func_arg1 ) ;
#line 410
static void ldv_mutex_lock_167(struct mutex *ldv_func_arg1 ) ;
#line 414
static void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) ;
#line 418
static void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) ;
#line 422
static void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) ;
#line 426
static void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) ;
#line 430
static void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) ;
#line 434
static void ldv_mutex_lock_213(struct mutex *ldv_func_arg1 ) ;
#line 438
static void ldv_mutex_lock_215(struct mutex *ldv_func_arg1 ) ;
#line 442
static void ldv_mutex_lock_217(struct mutex *ldv_func_arg1 ) ;
#line 446
static void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) ;
#line 450
static void ldv_mutex_lock_246(struct mutex *ldv_func_arg1 ) ;
#line 454
static void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) ;
#line 458
static void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) ;
#line 462
static void ldv_mutex_lock_253(struct mutex *ldv_func_arg1 ) ;
#line 491
void ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(struct mutex *lock ) ;
#line 495
void ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(struct mutex *lock ) ;
#line 498
void ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(struct mutex *lock ) ;
#line 502
void ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(struct mutex *lock ) ;
#line 505
void ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(struct mutex *lock ) ;
#line 509
void ldv_linux_kernel_locking_mutex_mutex_unlock_u132_module_lock(struct mutex *lock ) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 389
extern int sprintf(char * , char const   *  , ...) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 77
  __list_add(new, head->prev, head);
  }
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
  }
#line 147
  return;
}
}
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memset(void * , int  , size_t  ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = __builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 804
  if (tmp != 0L) {
    {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
#line 804
    __builtin_unreachable();
    }
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 83
__inline static int atomic_sub_and_test(int i , atomic_t *v ) ;
#line 159
__inline static int atomic_add_return(int i , atomic_t *v ) ;
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
extern void __ldv_linux_kernel_locking_spinlock_spin_lock(spinlock_t * ) ;
#line 493
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(spinlock_t *ldv_func_arg1 ) ;
#line 497
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_104(spinlock_t *ldv_func_arg1 ) ;
#line 501
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_219(spinlock_t *ldv_func_arg1 ) ;
#line 505
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_222(spinlock_t *ldv_func_arg1 ) ;
#line 509
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_225(spinlock_t *ldv_func_arg1 ) ;
#line 513
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_229(spinlock_t *ldv_func_arg1 ) ;
#line 517
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_231(spinlock_t *ldv_func_arg1 ) ;
#line 521
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_233(spinlock_t *ldv_func_arg1 ) ;
#line 525
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_235(spinlock_t *ldv_func_arg1 ) ;
#line 581
void ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin(void) ;
#line 582
void ldv_linux_kernel_locking_spinlock_spin_unlock_slock_of_u132_spin(void) ;
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 193
static void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) ;
#line 209
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 213
static void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) ;
#line 217
static void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) ;
#line 221
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1 ) ;
#line 225
static void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) ;
#line 229
static void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) ;
#line 233
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) ;
#line 237
static void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) ;
#line 241
static void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1 ) ;
#line 245
static void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) ;
#line 249
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
#line 253
static void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) ;
#line 257
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
#line 261
static void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) ;
#line 265
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
#line 269
static void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) ;
#line 273
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) ;
#line 277
static void ldv_mutex_unlock_127(struct mutex *ldv_func_arg1 ) ;
#line 281
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
#line 285
static void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) ;
#line 289
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 293
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) ;
#line 297
static void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) ;
#line 301
static void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) ;
#line 305
static void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) ;
#line 309
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) ;
#line 313
static void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 317
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 321
static void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) ;
#line 325
static void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
#line 329
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
#line 333
static void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) ;
#line 337
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
#line 341
static void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 345
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 349
static void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) ;
#line 353
static void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) ;
#line 357
static void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) ;
#line 361
static void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) ;
#line 365
static void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) ;
#line 369
static void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 373
static void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) ;
#line 377
static void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) ;
#line 381
static void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) ;
#line 385
static void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) ;
#line 389
static void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) ;
#line 393
static void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) ;
#line 397
static void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) ;
#line 401
static void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) ;
#line 405
static void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) ;
#line 409
static void ldv_mutex_unlock_165(struct mutex *ldv_func_arg1 ) ;
#line 413
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) ;
#line 417
static void ldv_mutex_unlock_168(struct mutex *ldv_func_arg1 ) ;
#line 421
static void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) ;
#line 425
static void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) ;
#line 429
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1 ) ;
#line 433
static void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) ;
#line 437
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) ;
#line 441
static void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) ;
#line 445
static void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) ;
#line 449
static void ldv_mutex_unlock_177(struct mutex *ldv_func_arg1 ) ;
#line 453
static void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) ;
#line 457
static void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) ;
#line 461
static void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) ;
#line 465
static void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) ;
#line 469
static void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) ;
#line 473
static void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) ;
#line 477
static void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) ;
#line 481
static void ldv_mutex_unlock_187(struct mutex *ldv_func_arg1 ) ;
#line 485
static void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) ;
#line 489
static void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) ;
#line 493
static void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) ;
#line 497
static void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) ;
#line 501
static void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) ;
#line 505
static void ldv_mutex_unlock_194(struct mutex *ldv_func_arg1 ) ;
#line 509
static void ldv_mutex_unlock_195(struct mutex *ldv_func_arg1 ) ;
#line 513
static void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) ;
#line 517
static void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) ;
#line 521
static void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) ;
#line 525
static void ldv_mutex_unlock_200(struct mutex *ldv_func_arg1 ) ;
#line 529
static void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
#line 533
static void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) ;
#line 537
static void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) ;
#line 541
static void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
#line 545
static void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) ;
#line 549
static void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) ;
#line 553
static void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) ;
#line 557
static void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) ;
#line 561
static void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) ;
#line 565
static void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) ;
#line 569
static void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) ;
#line 573
static void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) ;
#line 577
static void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) ;
#line 581
static void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) ;
#line 585
static void ldv_mutex_unlock_218(struct mutex *ldv_func_arg1 ) ;
#line 589
static void ldv_mutex_unlock_245(struct mutex *ldv_func_arg1 ) ;
#line 593
static void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) ;
#line 597
static void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) ;
#line 601
static void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) ;
#line 605
static void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 422 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 424
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  }
#line 425
  return;
}
}
#line 454
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 462
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 466
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 470
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 474
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 478
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 482
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 486
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 490
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 494
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 498
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 502
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 506
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 510
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 514
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 518
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 522
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 526
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 530
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 534
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 538
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) ;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
  {
#line 34
  atomic_set(& kref->refcount, 1);
  }
#line 35
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 47
  if (tmp___2 != 0L) {
    {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 47
    if (tmp___0 != 0L) {
      {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
      }
    } else {

    }
    {
#line 47
    tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
  {
#line 47
  __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 49
  return;
}
}
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 71
  if (tmp != 0L) {
    {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
    }
  } else {

  }
  {
#line 71
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
  }
#line 73
  if (tmp___0 != 0) {
    {
#line 74
    (*release)(kref);
    }
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = kref_sub(kref, 1U, release);
  }
#line 99
  return (tmp);
}
}
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 291
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 180
extern void __init_work(struct work_struct * , int  ) ;
#line 360
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 420
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 429
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 434
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 446
extern bool cancel_delayed_work(struct delayed_work * ) ;
#line 481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 485
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
  }
#line 485
  return (tmp);
}
}
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_wakeup.h"
extern int device_wakeup_enable(struct device * ) ;
#line 809 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 812
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 813
    return ((char const   *)dev->init_name);
  } else {

  }
  {
#line 815
  tmp = kobject_name(& dev->kobj);
  }
#line 815
  return (tmp);
}
}
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 842
  return ((void *)dev->driver_data);
}
}
#line 962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void *dev_get_platdata(struct device  const  *dev ) 
{ 


  {
#line 964
  return ((void *)dev->platform_data);
}
}
#line 1050
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 1052
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1056
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
extern void platform_device_unregister(struct platform_device * ) ;
#line 193
extern int __platform_driver_register(struct platform_driver * , struct module * ) ;
#line 197
static int ldv___platform_driver_register_252(struct platform_driver *ldv_func_arg1 ,
                                              struct module *ldv_func_arg2 ) ;
#line 199
extern void platform_driver_unregister(struct platform_driver * ) ;
#line 202
static void ldv_platform_driver_unregister_255(struct platform_driver *ldv_func_arg1 ) ;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
__inline static void *platform_get_drvdata(struct platform_device  const  *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 215
  tmp = dev_get_drvdata(& pdev->dev);
  }
#line 215
  return (tmp);
}
}
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 419 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern void schedule(void) ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 418
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 1173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
extern int usb_disabled(void) ;
#line 400 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb/hcd.h"
extern int usb_hcd_link_urb_to_ep(struct usb_hcd * , struct urb * ) ;
#line 401
extern int usb_hcd_check_unlink_urb(struct usb_hcd * , struct urb * , int  ) ;
#line 403
extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd * , struct urb * ) ;
#line 407
extern void usb_hcd_giveback_urb(struct usb_hcd * , struct urb * , int  ) ;
#line 426
extern struct usb_hcd *usb_create_hcd(struct hc_driver  const  * , struct device * ,
                                      char const   * ) ;
#line 432
extern void usb_put_hcd(struct usb_hcd * ) ;
#line 434
extern int usb_add_hcd(struct usb_hcd * , unsigned int  , unsigned long  ) ;
#line 436
extern void usb_remove_hcd(struct usb_hcd * ) ;
#line 470
extern void usb_hc_died(struct usb_hcd * ) ;
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/ohci.h"
static int const   cc_to_error[16U]  = 
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/ohci.h"
  {      0,      -84,      -71,      -84, 
        -32,      -62,      -71,      -71, 
        -75,      -121,      -5,      -5, 
        -70,      -63,      -114,      -114};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static bool distrust_firmware  =    1;
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static wait_queue_head_t u132_hcd_wait  =    {{{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "u132_hcd_wait.lock",
                                                      0, 0UL}}}}, {& u132_hcd_wait.task_list,
                                                                   & u132_hcd_wait.task_list}};
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static struct mutex u132_module_lock  ;
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_exiting  ;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_instances  ;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static struct list_head u132_static_list  ;
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static struct workqueue_struct *workqueue  ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static char const   *cc_to_text[16U]  = 
#line 98
  {      "No Error ",      "CRC Error ",      "Bit Stuff ",      "Data Togg ", 
        "Stall ",      "DevNotResp ",      "PIDCheck ",      "UnExpPID ", 
        "DataOver ",      "DataUnder ",      "(for hw) ",      "(for hw) ", 
        "BufferOver ",      "BuffUnder ",      "(for HCD) ",      "(for HCD) "};
#line 230 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static struct u132 *hcd_to_u132(struct usb_hcd *hcd ) 
{ 


  {
#line 232
  return ((struct u132 *)(& hcd->hcd_priv));
}
}
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static struct usb_hcd *u132_to_hcd(struct u132 *u132 ) 
{ 
  unsigned long const   (*__mptr)[0U] ;

  {
#line 237
  __mptr = (unsigned long const   *)u132;
#line 237
  return ((struct usb_hcd *)__mptr + 0xfffffffffffffc38UL);
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_disable(struct u132 *u132 ) 
{ 
  struct usb_hcd *tmp ;

  {
  {
#line 242
  tmp = u132_to_hcd(u132);
#line 242
  tmp->state = 0;
  }
#line 243
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/misc/usb_u132.h"
extern void ftdi_elan_gone_away(struct platform_device * ) ;
#line 71
extern int usb_ftdi_elan_edset_single(struct platform_device * , u8  , void * , struct urb * ,
                                      u8  , u8  , u8  , void (*)(void * , struct urb * ,
                                                                 u8 * , int  , int  ,
                                                                 int  , int  , int  ,
                                                                 int  , int  , int  ,
                                                                 int  ) ) ;
#line 76
extern int usb_ftdi_elan_edset_output(struct platform_device * , u8  , void * , struct urb * ,
                                      u8  , u8  , u8  , void (*)(void * , struct urb * ,
                                                                 u8 * , int  , int  ,
                                                                 int  , int  , int  ,
                                                                 int  , int  , int  ,
                                                                 int  ) ) ;
#line 81
extern int usb_ftdi_elan_edset_empty(struct platform_device * , u8  , void * , struct urb * ,
                                     u8  , u8  , u8  , void (*)(void * , struct urb * ,
                                                                u8 * , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  ) ) ;
#line 86
extern int usb_ftdi_elan_edset_input(struct platform_device * , u8  , void * , struct urb * ,
                                     u8  , u8  , u8  , void (*)(void * , struct urb * ,
                                                                u8 * , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  ) ) ;
#line 91
extern int usb_ftdi_elan_edset_setup(struct platform_device * , u8  , void * , struct urb * ,
                                     u8  , u8  , u8  , void (*)(void * , struct urb * ,
                                                                u8 * , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  , int  , int  ,
                                                                int  ) ) ;
#line 96
extern int usb_ftdi_elan_edset_flush(struct platform_device * , u8  , void * ) ;
#line 98
extern int usb_ftdi_elan_read_pcimem(struct platform_device * , int  , u8  , u32 * ) ;
#line 100
extern int usb_ftdi_elan_write_pcimem(struct platform_device * , int  , u8  , u32  ) ;
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static char const   hcd_name[9U]  = 
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
  {      'u',      '1',      '3',      '2', 
        '_',      'h',      'c',      'd', 
        '\000'};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_delete(struct kref *kref ) 
{ 
  struct u132 *u132 ;
  struct kref  const  *__mptr ;
  struct platform_device *pdev ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
  {
#line 256
  __mptr = (struct kref  const  *)kref;
#line 256
  u132 = (struct u132 *)__mptr;
#line 257
  pdev = u132->platform_dev;
#line 258
  tmp = u132_to_hcd(u132);
#line 258
  hcd = tmp;
#line 259
  u132->going = u132->going + 1;
#line 260
  ldv_mutex_lock_94(& u132_module_lock);
#line 261
  list_del_init(& u132->u132_list);
#line 262
  u132_instances = u132_instances + -1;
#line 263
  ldv_mutex_unlock_95(& u132_module_lock);
#line 264
  dev_warn((struct device  const  *)(& (u132->platform_dev)->dev), "FREEING the hcd=%p and thus the u132=%p going=%d pdev=%p\n",
           hcd, u132, u132->going, pdev);
#line 266
  usb_put_hcd(hcd);
  }
#line 267
  return;
}
}
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_u132_put_kref(struct u132 *u132 ) 
{ 


  {
  {
#line 271
  kref_put(& u132->kref, & u132_hcd_delete);
  }
#line 272
  return;
}
}
#line 274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_u132_init_kref(struct u132 *u132 ) 
{ 


  {
  {
#line 276
  kref_init(& u132->kref);
  }
#line 277
  return;
}
}
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_udev_delete(struct kref *kref ) 
{ 
  struct u132_udev *udev ;
  struct kref  const  *__mptr ;

  {
#line 281
  __mptr = (struct kref  const  *)kref;
#line 281
  udev = (struct u132_udev *)__mptr;
#line 282
  udev->udev_number = 0U;
#line 283
  udev->usb_device = (struct usb_device *)0;
#line 284
  udev->usb_addr = 0U;
#line 285
  udev->enumeration = 0U;
#line 286
  return;
}
}
#line 288 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_udev_put_kref(struct u132 *u132 , struct u132_udev *udev ) 
{ 


  {
  {
#line 290
  kref_put(& udev->kref, & u132_udev_delete);
  }
#line 291
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_udev_get_kref(struct u132 *u132 , struct u132_udev *udev ) 
{ 


  {
  {
#line 295
  kref_get(& udev->kref);
  }
#line 296
  return;
}
}
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_udev_init_kref(struct u132 *u132 , struct u132_udev *udev ) 
{ 


  {
  {
#line 301
  kref_init(& udev->kref);
  }
#line 302
  return;
}
}
#line 304 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_ring_put_kref(struct u132 *u132 , struct u132_ring *ring ) 
{ 


  {
  {
#line 306
  kref_put(& u132->kref, & u132_hcd_delete);
  }
#line 307
  return;
}
}
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_ring_requeue_work(struct u132 *u132 , struct u132_ring *ring , unsigned int delta ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 312
  if (delta != 0U) {
    {
#line 313
    tmp = queue_delayed_work(workqueue, & ring->scheduler, (unsigned long )delta);
    }
#line 313
    if ((int )tmp) {
#line 314
      return;
    } else {

    }
  } else {
    {
#line 315
    tmp___0 = queue_delayed_work(workqueue, & ring->scheduler, 0UL);
    }
#line 315
    if ((int )tmp___0) {
#line 316
      return;
    } else {

    }
  }
  {
#line 317
  kref_put(& u132->kref, & u132_hcd_delete);
  }
#line 318
  return;
}
}
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_ring_queue_work(struct u132 *u132 , struct u132_ring *ring , unsigned int delta ) 
{ 


  {
  {
#line 323
  kref_get(& u132->kref);
#line 324
  u132_ring_requeue_work(u132, ring, delta);
  }
#line 325
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_ring_cancel_work(struct u132 *u132 , struct u132_ring *ring ) 
{ 
  bool tmp ;

  {
  {
#line 329
  tmp = cancel_delayed_work(& ring->scheduler);
  }
#line 329
  if ((int )tmp) {
    {
#line 330
    kref_put(& u132->kref, & u132_hcd_delete);
    }
  } else {

  }
#line 331
  return;
}
}
#line 333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_endp_delete(struct kref *kref ) 
{ 
  struct u132_endp *endp ;
  struct kref  const  *__mptr ;
  struct u132 *u132 ;
  u8 usb_addr ;
  u8 usb_endp ;
  u8 address ;
  struct u132_udev *udev ;
  u8 endp_number ;
  struct usb_host_endpoint *hep ;
  struct u132_ring *ring ;
  struct list_head *head ;
  struct u132_endp *next_endp ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;

  {
#line 335
  __mptr = (struct kref  const  *)kref;
#line 335
  endp = (struct u132_endp *)__mptr;
#line 336
  u132 = endp->u132;
#line 337
  usb_addr = endp->usb_addr;
#line 338
  usb_endp = endp->usb_endp;
#line 339
  address = u132->addr[(int )usb_addr].address;
#line 340
  udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 341
  endp_number = endp->endp_number;
#line 342
  hep = endp->hep;
#line 343
  ring = endp->ring;
#line 344
  head = & endp->endp_ring;
#line 345
  ring->length = (unsigned char )((unsigned int )ring->length + 255U);
#line 346
  if ((unsigned long )endp == (unsigned long )ring->curr_endp) {
    {
#line 347
    tmp = list_empty((struct list_head  const  *)head);
    }
#line 347
    if (tmp != 0) {
      {
#line 348
      ring->curr_endp = (struct u132_endp *)0;
#line 349
      list_del(head);
      }
    } else {
      {
#line 351
      __mptr___0 = (struct list_head  const  *)head->next;
#line 351
      next_endp = (struct u132_endp *)__mptr___0 + 0xfffffffffffffff0UL;
#line 353
      ring->curr_endp = next_endp;
#line 354
      list_del(head);
      }
    }
  } else {
    {
#line 357
    list_del(head);
    }
  }
#line 358
  if ((unsigned int )*((unsigned char *)endp + 40UL) != 0U) {
    {
#line 359
    udev->endp_number_in[(int )usb_endp] = 0U;
#line 360
    u132_udev_put_kref(u132, udev);
    }
  } else {

  }
#line 362
  if ((unsigned int )*((unsigned char *)endp + 40UL) != 0U) {
    {
#line 363
    udev->endp_number_out[(int )usb_endp] = 0U;
#line 364
    u132_udev_put_kref(u132, udev);
    }
  } else {

  }
  {
#line 366
  u132->endp[(int )endp_number + -1] = (struct u132_endp *)0;
#line 367
  hep->hcpriv = (void *)0;
#line 368
  kfree((void const   *)endp);
#line 369
  u132_u132_put_kref(u132);
  }
#line 370
  return;
}
}
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_endp_put_kref(struct u132 *u132 , struct u132_endp *endp ) 
{ 


  {
  {
#line 374
  kref_put(& endp->kref, & u132_endp_delete);
  }
#line 375
  return;
}
}
#line 377 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_endp_get_kref(struct u132 *u132 , struct u132_endp *endp ) 
{ 


  {
  {
#line 379
  kref_get(& endp->kref);
  }
#line 380
  return;
}
}
#line 382 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static void u132_endp_init_kref(struct u132 *u132 , struct u132_endp *endp ) 
{ 


  {
  {
#line 385
  kref_init(& endp->kref);
#line 386
  kref_get(& u132->kref);
  }
#line 387
  return;
}
}
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_endp_queue_work(struct u132 *u132 , struct u132_endp *endp , unsigned int delta ) 
{ 
  bool tmp ;

  {
  {
#line 392
  tmp = queue_delayed_work(workqueue, & endp->scheduler, (unsigned long )delta);
  }
#line 392
  if ((int )tmp) {
    {
#line 393
    kref_get(& endp->kref);
    }
  } else {

  }
#line 394
  return;
}
}
#line 396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_endp_cancel_work(struct u132 *u132 , struct u132_endp *endp ) 
{ 
  bool tmp ;

  {
  {
#line 398
  tmp = cancel_delayed_work(& endp->scheduler);
  }
#line 398
  if ((int )tmp) {
    {
#line 399
    kref_put(& endp->kref, & u132_endp_delete);
    }
  } else {

  }
#line 400
  return;
}
}
#line 407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_monitor_queue_work(struct u132 *u132 , unsigned int delta ) 
{ 
  bool tmp ;

  {
  {
#line 409
  tmp = queue_delayed_work(workqueue, & u132->monitor, (unsigned long )delta);
  }
#line 409
  if ((int )tmp) {
    {
#line 410
    kref_get(& u132->kref);
    }
  } else {

  }
#line 411
  return;
}
}
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_monitor_requeue_work(struct u132 *u132 , unsigned int delta ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 415
  tmp = queue_delayed_work(workqueue, & u132->monitor, (unsigned long )delta);
  }
#line 415
  if (tmp) {
#line 415
    tmp___0 = 0;
  } else {
#line 415
    tmp___0 = 1;
  }
#line 415
  if (tmp___0) {
    {
#line 416
    kref_put(& u132->kref, & u132_hcd_delete);
    }
  } else {

  }
#line 417
  return;
}
}
#line 419 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_monitor_cancel_work(struct u132 *u132 ) 
{ 
  bool tmp ;

  {
  {
#line 421
  tmp = cancel_delayed_work(& u132->monitor);
  }
#line 421
  if ((int )tmp) {
    {
#line 422
    kref_put(& u132->kref, & u132_hcd_delete);
    }
  } else {

  }
#line 423
  return;
}
}
#line 425 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int read_roothub_info(struct u132 *u132 ) 
{ 
  u32 revision ;
  int retval ;
  int I ;
  int i ;
  int tmp ;

  {
  {
#line 429
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 0, 0, & revision);
  }
#line 430
  if (retval != 0) {
    {
#line 431
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "error %d accessing device control\n",
            retval);
    }
#line 433
    return (retval);
  } else
#line 434
  if ((revision & 255U) == 16U) {

  } else
#line 435
  if ((revision & 255U) == 17U) {

  } else {
    {
#line 437
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device revision is not valid %08X\n",
            revision);
    }
#line 439
    return (-19);
  }
  {
#line 441
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & u132->hc_control);
  }
#line 442
  if (retval != 0) {
    {
#line 443
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "error %d accessing device control\n",
            retval);
    }
#line 445
    return (retval);
  } else {

  }
  {
#line 447
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 80, 0, & u132->hc_roothub_status);
  }
#line 449
  if (retval != 0) {
    {
#line 450
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "error %d accessing device reg roothub.status\n",
            retval);
    }
#line 452
    return (retval);
  } else {

  }
  {
#line 454
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 72, 0, & u132->hc_roothub_a);
  }
#line 455
  if (retval != 0) {
    {
#line 456
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "error %d accessing device reg roothub.a\n",
            retval);
    }
#line 458
    return (retval);
  } else {

  }
#line 461
  I = u132->num_ports;
#line 462
  i = 0;
#line 463
  goto ldv_30532;
  ldv_30531: 
  {
#line 464
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )i + 21UL) * 4U),
                                     0, (u32 *)(& u132->hc_roothub_portstatus) + (unsigned long )i);
  }
#line 466
  if (retval != 0) {
    {
#line 467
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "error %d accessing device roothub.portstatus[%d]\n",
            retval, i);
    }
#line 470
    return (retval);
  } else {
#line 472
    i = i + 1;
  }
  ldv_30532: 
#line 463
  tmp = I;
#line 463
  I = I - 1;
#line 463
  if (tmp > 0) {
#line 465
    goto ldv_30531;
  } else {

  }

#line 475
  return (0);
}
}
#line 478 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_monitor_work(struct work_struct *work ) 
{ 
  struct u132 *u132 ;
  struct work_struct  const  *__mptr ;
  int retval ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
#line 480
  __mptr = (struct work_struct  const  *)work;
#line 480
  u132 = (struct u132 *)__mptr + 0xfffffffffffffa48UL;
#line 481
  if (u132->going > 1) {
    {
#line 482
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 484
    u132_u132_put_kref(u132);
    }
#line 485
    return;
  } else
#line 486
  if (u132->going > 0) {
    {
#line 487
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
#line 488
    u132_u132_put_kref(u132);
    }
#line 489
    return;
  } else {
    {
#line 492
    ldv_mutex_lock_96(& u132->sw_lock);
#line 493
    retval = read_roothub_info(u132);
    }
#line 494
    if (retval != 0) {
      {
#line 495
      tmp = u132_to_hcd(u132);
#line 495
      hcd = tmp;
#line 496
      u132_disable(u132);
#line 497
      u132->going = 1;
#line 498
      ldv_mutex_unlock_97(& u132->sw_lock);
#line 499
      usb_hc_died(hcd);
#line 500
      ftdi_elan_gone_away(u132->platform_dev);
#line 501
      u132_u132_put_kref(u132);
      }
#line 502
      return;
    } else {
      {
#line 504
      u132_monitor_requeue_work(u132, 500U);
#line 505
      ldv_mutex_unlock_98(& u132->sw_lock);
      }
#line 506
      return;
    }
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_giveback_urb(struct u132 *u132 , struct u132_endp *endp , struct urb *urb ,
                                  int status ) 
{ 
  struct u132_ring *ring ;
  unsigned long irqs ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  struct list_head *next ;
  struct u132_urbq *urbq ;
  struct list_head  const  *__mptr ;
  u16 tmp___0 ;

  {
  {
#line 516
  tmp = u132_to_hcd(u132);
#line 516
  hcd = tmp;
#line 517
  urb->error_count = 0;
#line 518
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(& endp->queue_lock.slock);
#line 519
  usb_hcd_unlink_urb_from_ep(hcd, urb);
#line 520
  endp->queue_next = (unsigned int )endp->queue_next + 1U;
#line 521
  endp->queue_size = (u16 )((int )endp->queue_size - 1);
  }
#line 521
  if ((unsigned int )endp->queue_size <= 7U) {
    {
#line 522
    endp->active = 0U;
#line 523
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
    }
  } else {
    {
#line 525
    next = endp->urb_more.next;
#line 526
    __mptr = (struct list_head  const  *)next;
#line 526
    urbq = (struct u132_urbq *)__mptr;
#line 528
    list_del(next);
#line 529
    tmp___0 = endp->queue_last;
#line 529
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 529
    endp->urb_list[(int )tmp___0 & 7] = urbq->urb;
#line 531
    endp->active = 0U;
#line 532
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 533
    kfree((void const   *)urbq);
    }
  }
  {
#line 535
  ldv_mutex_lock_102(& u132->scheduler_lock);
#line 536
  ring = endp->ring;
#line 537
  ring->in_use = 0U;
#line 538
  u132_ring_cancel_work(u132, ring);
#line 539
  u132_ring_queue_work(u132, ring, 0U);
#line 540
  ldv_mutex_unlock_103(& u132->scheduler_lock);
#line 541
  u132_endp_put_kref(u132, endp);
#line 542
  usb_hcd_giveback_urb(hcd, urb, status);
  }
#line 543
  return;
}
}
#line 545 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_forget_urb(struct u132 *u132 , struct u132_endp *endp , struct urb *urb ,
                                int status ) 
{ 


  {
  {
#line 548
  u132_endp_put_kref(u132, endp);
  }
#line 549
  return;
}
}
#line 551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_abandon_urb(struct u132 *u132 , struct u132_endp *endp , struct urb *urb ,
                                 int status ) 
{ 
  unsigned long irqs ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  struct list_head *next ;
  struct u132_urbq *urbq ;
  struct list_head  const  *__mptr ;
  u16 tmp___0 ;

  {
  {
#line 555
  tmp = u132_to_hcd(u132);
#line 555
  hcd = tmp;
#line 556
  urb->error_count = 0;
#line 557
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_104(& endp->queue_lock.slock);
#line 558
  usb_hcd_unlink_urb_from_ep(hcd, urb);
#line 559
  endp->queue_next = (unsigned int )endp->queue_next + 1U;
#line 560
  endp->queue_size = (u16 )((int )endp->queue_size - 1);
  }
#line 560
  if ((unsigned int )endp->queue_size <= 7U) {
    {
#line 561
    endp->active = 0U;
#line 562
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
    }
  } else {
    {
#line 564
    next = endp->urb_more.next;
#line 565
    __mptr = (struct list_head  const  *)next;
#line 565
    urbq = (struct u132_urbq *)__mptr;
#line 567
    list_del(next);
#line 568
    tmp___0 = endp->queue_last;
#line 568
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 568
    endp->urb_list[(int )tmp___0 & 7] = urbq->urb;
#line 570
    endp->active = 0U;
#line 571
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 572
    kfree((void const   *)urbq);
    }
  }
  {
#line 574
  usb_hcd_giveback_urb(hcd, urb, status);
  }
#line 575
  return;
}
}
#line 577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static int edset_input(struct u132 *u132 , struct u132_ring *ring , struct u132_endp *endp ,
                                struct urb *urb , u8 address , u8 toggle_bits , void (*callback)(void * ,
                                                                                                 struct urb * ,
                                                                                                 u8 * ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ) ) 
{ 
  int tmp ;

  {
  {
#line 583
  tmp = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring->number, (void *)endp,
                                  urb, (int )address, (int )endp->usb_endp, (int )toggle_bits,
                                  callback);
  }
#line 583
  return (tmp);
}
}
#line 587 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static int edset_setup(struct u132 *u132 , struct u132_ring *ring , struct u132_endp *endp ,
                                struct urb *urb , u8 address , u8 toggle_bits , void (*callback)(void * ,
                                                                                                 struct urb * ,
                                                                                                 u8 * ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ,
                                                                                                 int  ) ) 
{ 
  int tmp ;

  {
  {
#line 593
  tmp = usb_ftdi_elan_edset_setup(u132->platform_dev, (int )ring->number, (void *)endp,
                                  urb, (int )address, (int )endp->usb_endp, (int )toggle_bits,
                                  callback);
  }
#line 593
  return (tmp);
}
}
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static int edset_single(struct u132 *u132 , struct u132_ring *ring , struct u132_endp *endp ,
                                 struct urb *urb , u8 address , u8 toggle_bits , void (*callback)(void * ,
                                                                                                  struct urb * ,
                                                                                                  u8 * ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ) ) 
{ 
  int tmp ;

  {
  {
#line 603
  tmp = usb_ftdi_elan_edset_single(u132->platform_dev, (int )ring->number, (void *)endp,
                                   urb, (int )address, (int )endp->usb_endp, (int )toggle_bits,
                                   callback);
  }
#line 603
  return (tmp);
}
}
#line 607 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
__inline static int edset_output(struct u132 *u132 , struct u132_ring *ring , struct u132_endp *endp ,
                                 struct urb *urb , u8 address , u8 toggle_bits , void (*callback)(void * ,
                                                                                                  struct urb * ,
                                                                                                  u8 * ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ,
                                                                                                  int  ) ) 
{ 
  int tmp ;

  {
  {
#line 613
  tmp = usb_ftdi_elan_edset_output(u132->platform_dev, (int )ring->number, (void *)endp,
                                   urb, (int )address, (int )endp->usb_endp, (int )toggle_bits,
                                   callback);
  }
#line 613
  return (tmp);
}
}
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_interrupt_recv(void *data , struct urb *urb , u8 *buf , int len ,
                                    int toggle_bits , int error_count , int condition_code ,
                                    int repeat_number , int halted , int skipped ,
                                    int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  struct u132_udev *udev ;
  struct u132_ring *ring ;
  u8 *u ;
  u8 *b ;
  int L ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int tmp___1 ;
  int retval ;
  unsigned long tmp___2 ;

  {
  {
#line 626
  endp = (struct u132_endp *)data;
#line 627
  u132 = endp->u132;
#line 628
  address = u132->addr[(int )endp->usb_addr].address;
#line 629
  udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 630
  ldv_mutex_lock_107(& u132->scheduler_lock);
  }
#line 631
  if (u132->going > 1) {
    {
#line 632
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 634
    ldv_mutex_unlock_108(& u132->scheduler_lock);
#line 635
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 636
    return;
  } else
#line 637
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 638
    endp->dequeueing = 0U;
#line 639
    ldv_mutex_unlock_109(& u132->scheduler_lock);
#line 640
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 641
    return;
  } else
#line 642
  if (u132->going > 0) {
    {
#line 643
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 645
    ldv_mutex_unlock_110(& u132->scheduler_lock);
#line 646
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 647
    return;
  } else
#line 648
  if (urb->unlinked == 0) {
#line 649
    ring = endp->ring;
#line 650
    u = (u8 *)urb->transfer_buffer + (unsigned long )urb->actual_length;
#line 651
    b = buf;
#line 652
    L = len;
#line 654
    goto ldv_30680;
    ldv_30679: 
#line 655
    tmp = u;
#line 655
    u = u + 1;
#line 655
    tmp___0 = b;
#line 655
    b = b + 1;
#line 655
    *tmp = *tmp___0;
    ldv_30680: 
#line 654
    tmp___1 = L;
#line 654
    L = L - 1;
#line 654
    if (tmp___1 > 0) {
#line 656
      goto ldv_30679;
    } else {

    }
#line 657
    urb->actual_length = urb->actual_length + (u32 )len;
#line 658
    if (condition_code == 0 && urb->transfer_buffer_length > urb->actual_length) {
#line 660
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 661
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 663
      if (urb->actual_length != 0U) {
        {
#line 665
        ldv_mutex_unlock_111(& u132->scheduler_lock);
#line 666
        retval = edset_single(u132, ring, endp, urb, (int )address, (int )endp->toggle_bits,
                              & u132_hcd_interrupt_recv);
        }
#line 669
        if (retval != 0) {
          {
#line 670
          u132_hcd_giveback_urb(u132, endp, urb, retval);
          }
        } else {

        }
      } else {
        {
#line 673
        ring->in_use = 0U;
#line 674
        endp->active = 0U;
#line 675
        tmp___2 = msecs_to_jiffies((unsigned int const   )urb->interval);
#line 675
        endp->jiffies = (unsigned long )jiffies + tmp___2;
#line 677
        u132_ring_cancel_work(u132, ring);
#line 678
        u132_ring_queue_work(u132, ring, 0U);
#line 679
        ldv_mutex_unlock_112(& u132->scheduler_lock);
#line 680
        u132_endp_put_kref(u132, endp);
        }
      }
#line 682
      return;
    } else
#line 683
    if (condition_code == 9 && (urb->transfer_flags & 1U) == 0U) {
      {
#line 685
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 686
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 688
      ldv_mutex_unlock_113(& u132->scheduler_lock);
#line 689
      u132_hcd_giveback_urb(u132, endp, urb, 0);
      }
#line 690
      return;
    } else {
#line 692
      if (condition_code == 0) {
#line 693
        endp->toggle_bits = (unsigned char )toggle_bits;
#line 694
        (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
      } else
#line 696
      if (condition_code == 4) {
#line 697
        endp->toggle_bits = 2U;
#line 698
        (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp));
      } else {
        {
#line 701
        endp->toggle_bits = 2U;
#line 702
        (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp));
#line 704
        dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p giving back INTERRUPT %s\n",
                urb, cc_to_text[condition_code]);
        }
      }
      {
#line 708
      ldv_mutex_unlock_114(& u132->scheduler_lock);
#line 709
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 711
      return;
    }
  } else {
    {
#line 714
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 716
    ldv_mutex_unlock_115(& u132->scheduler_lock);
#line 717
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 718
    return;
  }
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_bulk_output_sent(void *data , struct urb *urb , u8 *buf , int len ,
                                      int toggle_bits , int error_count , int condition_code ,
                                      int repeat_number , int halted , int skipped ,
                                      int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  struct u132_ring *ring ;
  int retval ;

  {
  {
#line 726
  endp = (struct u132_endp *)data;
#line 727
  u132 = endp->u132;
#line 728
  address = u132->addr[(int )endp->usb_addr].address;
#line 729
  ldv_mutex_lock_116(& u132->scheduler_lock);
  }
#line 730
  if (u132->going > 1) {
    {
#line 731
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 733
    ldv_mutex_unlock_117(& u132->scheduler_lock);
#line 734
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 735
    return;
  } else
#line 736
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 737
    endp->dequeueing = 0U;
#line 738
    ldv_mutex_unlock_118(& u132->scheduler_lock);
#line 739
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 740
    return;
  } else
#line 741
  if (u132->going > 0) {
    {
#line 742
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 744
    ldv_mutex_unlock_119(& u132->scheduler_lock);
#line 745
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 746
    return;
  } else
#line 747
  if (urb->unlinked == 0) {
#line 748
    ring = endp->ring;
#line 749
    urb->actual_length = urb->actual_length + (u32 )len;
#line 750
    endp->toggle_bits = (unsigned char )toggle_bits;
#line 751
    if (urb->transfer_buffer_length > urb->actual_length) {
      {
#line 753
      ldv_mutex_unlock_120(& u132->scheduler_lock);
#line 754
      retval = edset_output(u132, ring, endp, urb, (int )address, (int )endp->toggle_bits,
                            & u132_hcd_bulk_output_sent);
      }
#line 756
      if (retval != 0) {
        {
#line 757
        u132_hcd_giveback_urb(u132, endp, urb, retval);
        }
      } else {

      }
#line 758
      return;
    } else {
      {
#line 760
      ldv_mutex_unlock_121(& u132->scheduler_lock);
#line 761
      u132_hcd_giveback_urb(u132, endp, urb, 0);
      }
#line 762
      return;
    }
  } else {
    {
#line 765
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 767
    ldv_mutex_unlock_122(& u132->scheduler_lock);
#line 768
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 769
    return;
  }
}
}
#line 773 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_bulk_input_recv(void *data , struct urb *urb , u8 *buf , int len ,
                                     int toggle_bits , int error_count , int condition_code ,
                                     int repeat_number , int halted , int skipped ,
                                     int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  struct u132_udev *udev ;
  struct u132_ring *ring ;
  u8 *u ;
  u8 *b ;
  int L ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int tmp___1 ;
  int retval ;

  {
  {
#line 777
  endp = (struct u132_endp *)data;
#line 778
  u132 = endp->u132;
#line 779
  address = u132->addr[(int )endp->usb_addr].address;
#line 780
  udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 781
  ldv_mutex_lock_123(& u132->scheduler_lock);
  }
#line 782
  if (u132->going > 1) {
    {
#line 783
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 785
    ldv_mutex_unlock_124(& u132->scheduler_lock);
#line 786
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 787
    return;
  } else
#line 788
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 789
    endp->dequeueing = 0U;
#line 790
    ldv_mutex_unlock_125(& u132->scheduler_lock);
#line 791
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 792
    return;
  } else
#line 793
  if (u132->going > 0) {
    {
#line 794
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 796
    ldv_mutex_unlock_126(& u132->scheduler_lock);
#line 797
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 798
    return;
  } else
#line 799
  if (urb->unlinked == 0) {
#line 800
    ring = endp->ring;
#line 801
    u = (u8 *)urb->transfer_buffer + (unsigned long )urb->actual_length;
#line 802
    b = buf;
#line 803
    L = len;
#line 805
    goto ldv_30725;
    ldv_30724: 
#line 806
    tmp = u;
#line 806
    u = u + 1;
#line 806
    tmp___0 = b;
#line 806
    b = b + 1;
#line 806
    *tmp = *tmp___0;
    ldv_30725: 
#line 805
    tmp___1 = L;
#line 805
    L = L - 1;
#line 805
    if (tmp___1 > 0) {
#line 807
      goto ldv_30724;
    } else {

    }
#line 808
    urb->actual_length = urb->actual_length + (u32 )len;
#line 809
    if (condition_code == 0 && urb->transfer_buffer_length > urb->actual_length) {
      {
#line 812
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 813
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 815
      ldv_mutex_unlock_127(& u132->scheduler_lock);
#line 816
      retval = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring->number, (void *)endp,
                                         urb, (int )address, (int )endp->usb_endp,
                                         (int )endp->toggle_bits, & u132_hcd_bulk_input_recv);
      }
#line 820
      if (retval != 0) {
        {
#line 821
        u132_hcd_giveback_urb(u132, endp, urb, retval);
        }
      } else {

      }
#line 822
      return;
    } else
#line 823
    if (condition_code == 0) {
      {
#line 824
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 825
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 827
      ldv_mutex_unlock_128(& u132->scheduler_lock);
#line 828
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 830
      return;
    } else
#line 831
    if (condition_code == 9 && (urb->transfer_flags & 1U) == 0U) {
      {
#line 833
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 834
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 836
      ldv_mutex_unlock_129(& u132->scheduler_lock);
#line 837
      u132_hcd_giveback_urb(u132, endp, urb, 0);
      }
#line 838
      return;
    } else
#line 839
    if (condition_code == 9) {
      {
#line 840
      endp->toggle_bits = (unsigned char )toggle_bits;
#line 841
      (udev->usb_device)->toggle[0] = ((udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp))) | (unsigned int )((toggle_bits & 1) << (int )endp->usb_endp);
#line 843
      dev_warn((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p(SHORT NOT OK) giving back BULK IN %s\n",
               urb, cc_to_text[condition_code]);
#line 846
      ldv_mutex_unlock_130(& u132->scheduler_lock);
#line 847
      u132_hcd_giveback_urb(u132, endp, urb, 0);
      }
#line 848
      return;
    } else
#line 849
    if (condition_code == 4) {
      {
#line 850
      endp->toggle_bits = 2U;
#line 851
      (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp));
#line 852
      ldv_mutex_unlock_131(& u132->scheduler_lock);
#line 853
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 855
      return;
    } else {
      {
#line 857
      endp->toggle_bits = 2U;
#line 858
      (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )endp->usb_endp));
#line 859
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p giving back BULK IN code=%d %s\n",
              urb, condition_code, cc_to_text[condition_code]);
#line 862
      ldv_mutex_unlock_132(& u132->scheduler_lock);
#line 863
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 865
      return;
    }
  } else {
    {
#line 868
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 870
    ldv_mutex_unlock_133(& u132->scheduler_lock);
#line 871
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 872
    return;
  }
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_configure_empty_sent(void *data , struct urb *urb , u8 *buf ,
                                          int len , int toggle_bits , int error_count ,
                                          int condition_code , int repeat_number ,
                                          int halted , int skipped , int actual ,
                                          int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;

  {
  {
#line 880
  endp = (struct u132_endp *)data;
#line 881
  u132 = endp->u132;
#line 882
  ldv_mutex_lock_134(& u132->scheduler_lock);
  }
#line 883
  if (u132->going > 1) {
    {
#line 884
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 886
    ldv_mutex_unlock_135(& u132->scheduler_lock);
#line 887
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 888
    return;
  } else
#line 889
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 890
    endp->dequeueing = 0U;
#line 891
    ldv_mutex_unlock_136(& u132->scheduler_lock);
#line 892
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 893
    return;
  } else
#line 894
  if (u132->going > 0) {
    {
#line 895
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 897
    ldv_mutex_unlock_137(& u132->scheduler_lock);
#line 898
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 899
    return;
  } else
#line 900
  if (urb->unlinked == 0) {
    {
#line 901
    ldv_mutex_unlock_138(& u132->scheduler_lock);
#line 902
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 903
    return;
  } else {
    {
#line 905
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 907
    ldv_mutex_unlock_139(& u132->scheduler_lock);
#line 908
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 909
    return;
  }
}
}
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_configure_input_recv(void *data , struct urb *urb , u8 *buf ,
                                          int len , int toggle_bits , int error_count ,
                                          int condition_code , int repeat_number ,
                                          int halted , int skipped , int actual ,
                                          int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  struct u132_ring *ring ;
  u8 *u ;
  u8 *b ;
  int L ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int tmp___1 ;
  int retval ;

  {
  {
#line 917
  endp = (struct u132_endp *)data;
#line 918
  u132 = endp->u132;
#line 919
  address = u132->addr[(int )endp->usb_addr].address;
#line 920
  ldv_mutex_lock_140(& u132->scheduler_lock);
  }
#line 921
  if (u132->going > 1) {
    {
#line 922
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 924
    ldv_mutex_unlock_141(& u132->scheduler_lock);
#line 925
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 926
    return;
  } else
#line 927
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 928
    endp->dequeueing = 0U;
#line 929
    ldv_mutex_unlock_142(& u132->scheduler_lock);
#line 930
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 931
    return;
  } else
#line 932
  if (u132->going > 0) {
    {
#line 933
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 935
    ldv_mutex_unlock_143(& u132->scheduler_lock);
#line 936
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 937
    return;
  } else
#line 938
  if (urb->unlinked == 0) {
#line 939
    ring = endp->ring;
#line 940
    u = (u8 *)urb->transfer_buffer;
#line 941
    b = buf;
#line 942
    L = len;
#line 944
    goto ldv_30766;
    ldv_30765: 
#line 945
    tmp = u;
#line 945
    u = u + 1;
#line 945
    tmp___0 = b;
#line 945
    b = b + 1;
#line 945
    *tmp = *tmp___0;
    ldv_30766: 
#line 944
    tmp___1 = L;
#line 944
    L = L - 1;
#line 944
    if (tmp___1 > 0) {
#line 946
      goto ldv_30765;
    } else {

    }
#line 947
    urb->actual_length = (u32 )len;
#line 948
    if (condition_code == 0 || (condition_code == 9 && (urb->transfer_flags & 1U) == 0U)) {
      {
#line 952
      ldv_mutex_unlock_144(& u132->scheduler_lock);
#line 953
      retval = usb_ftdi_elan_edset_empty(u132->platform_dev, (int )ring->number, (void *)endp,
                                         urb, (int )address, (int )endp->usb_endp,
                                         3, & u132_hcd_configure_empty_sent);
      }
#line 957
      if (retval != 0) {
        {
#line 958
        u132_hcd_giveback_urb(u132, endp, urb, retval);
        }
      } else {

      }
#line 959
      return;
    } else
#line 960
    if (condition_code == 4) {
      {
#line 961
      ldv_mutex_unlock_145(& u132->scheduler_lock);
#line 962
      dev_warn((struct device  const  *)(& (u132->platform_dev)->dev), "giving back SETUP INPUT STALL urb %p\n",
               urb);
#line 964
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 966
      return;
    } else {
      {
#line 968
      ldv_mutex_unlock_146(& u132->scheduler_lock);
#line 969
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "giving back SETUP INPUT %s urb %p\n",
              cc_to_text[condition_code], urb);
#line 972
      u132_hcd_giveback_urb(u132, endp, urb, cc_to_error[condition_code]);
      }
#line 974
      return;
    }
  } else {
    {
#line 977
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 979
    ldv_mutex_unlock_147(& u132->scheduler_lock);
#line 980
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 981
    return;
  }
}
}
#line 985 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_configure_empty_recv(void *data , struct urb *urb , u8 *buf ,
                                          int len , int toggle_bits , int error_count ,
                                          int condition_code , int repeat_number ,
                                          int halted , int skipped , int actual ,
                                          int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;

  {
  {
#line 989
  endp = (struct u132_endp *)data;
#line 990
  u132 = endp->u132;
#line 991
  ldv_mutex_lock_148(& u132->scheduler_lock);
  }
#line 992
  if (u132->going > 1) {
    {
#line 993
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 995
    ldv_mutex_unlock_149(& u132->scheduler_lock);
#line 996
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 997
    return;
  } else
#line 998
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 999
    endp->dequeueing = 0U;
#line 1000
    ldv_mutex_unlock_150(& u132->scheduler_lock);
#line 1001
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1002
    return;
  } else
#line 1003
  if (u132->going > 0) {
    {
#line 1004
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1006
    ldv_mutex_unlock_151(& u132->scheduler_lock);
#line 1007
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1008
    return;
  } else
#line 1009
  if (urb->unlinked == 0) {
    {
#line 1010
    ldv_mutex_unlock_152(& u132->scheduler_lock);
#line 1011
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1012
    return;
  } else {
    {
#line 1014
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1016
    ldv_mutex_unlock_153(& u132->scheduler_lock);
#line 1017
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1018
    return;
  }
}
}
#line 1022 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_configure_setup_sent(void *data , struct urb *urb , u8 *buf ,
                                          int len , int toggle_bits , int error_count ,
                                          int condition_code , int repeat_number ,
                                          int halted , int skipped , int actual ,
                                          int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  int retval ;
  struct u132_ring *ring ;
  int retval___0 ;
  struct u132_ring *ring___0 ;

  {
  {
#line 1026
  endp = (struct u132_endp *)data;
#line 1027
  u132 = endp->u132;
#line 1028
  address = u132->addr[(int )endp->usb_addr].address;
#line 1029
  ldv_mutex_lock_154(& u132->scheduler_lock);
  }
#line 1030
  if (u132->going > 1) {
    {
#line 1031
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1033
    ldv_mutex_unlock_155(& u132->scheduler_lock);
#line 1034
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1035
    return;
  } else
#line 1036
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1037
    endp->dequeueing = 0U;
#line 1038
    ldv_mutex_unlock_156(& u132->scheduler_lock);
#line 1039
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1040
    return;
  } else
#line 1041
  if (u132->going > 0) {
    {
#line 1042
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1044
    ldv_mutex_unlock_157(& u132->scheduler_lock);
#line 1045
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1046
    return;
  } else
#line 1047
  if (urb->unlinked == 0) {
#line 1048
    if ((urb->pipe & 128U) != 0U) {
      {
#line 1050
      ring = endp->ring;
#line 1051
      ldv_mutex_unlock_158(& u132->scheduler_lock);
#line 1052
      retval = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring->number, (void *)endp,
                                         urb, (int )address, (int )endp->usb_endp,
                                         0, & u132_hcd_configure_input_recv);
      }
#line 1056
      if (retval != 0) {
        {
#line 1057
        u132_hcd_giveback_urb(u132, endp, urb, retval);
        }
      } else {

      }
#line 1058
      return;
    } else {
      {
#line 1061
      ring___0 = endp->ring;
#line 1062
      ldv_mutex_unlock_159(& u132->scheduler_lock);
#line 1063
      retval___0 = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring___0->number,
                                             (void *)endp, urb, (int )address, (int )endp->usb_endp,
                                             0, & u132_hcd_configure_empty_recv);
      }
#line 1067
      if (retval___0 != 0) {
        {
#line 1068
        u132_hcd_giveback_urb(u132, endp, urb, retval___0);
        }
      } else {

      }
#line 1069
      return;
    }
  } else {
    {
#line 1072
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1074
    ldv_mutex_unlock_160(& u132->scheduler_lock);
#line 1075
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1076
    return;
  }
}
}
#line 1080 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_enumeration_empty_recv(void *data , struct urb *urb , u8 *buf ,
                                            int len , int toggle_bits , int error_count ,
                                            int condition_code , int repeat_number ,
                                            int halted , int skipped , int actual ,
                                            int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  struct u132_udev *udev ;

  {
  {
#line 1084
  endp = (struct u132_endp *)data;
#line 1085
  u132 = endp->u132;
#line 1086
  address = u132->addr[(int )endp->usb_addr].address;
#line 1087
  udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 1088
  ldv_mutex_lock_161(& u132->scheduler_lock);
  }
#line 1089
  if (u132->going > 1) {
    {
#line 1090
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1092
    ldv_mutex_unlock_162(& u132->scheduler_lock);
#line 1093
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1094
    return;
  } else
#line 1095
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1096
    endp->dequeueing = 0U;
#line 1097
    ldv_mutex_unlock_163(& u132->scheduler_lock);
#line 1098
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1099
    return;
  } else
#line 1100
  if (u132->going > 0) {
    {
#line 1101
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1103
    ldv_mutex_unlock_164(& u132->scheduler_lock);
#line 1104
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1105
    return;
  } else
#line 1106
  if (urb->unlinked == 0) {
    {
#line 1107
    u132->addr[0].address = 0U;
#line 1108
    endp->usb_addr = udev->usb_addr;
#line 1109
    ldv_mutex_unlock_165(& u132->scheduler_lock);
#line 1110
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1111
    return;
  } else {
    {
#line 1113
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1115
    ldv_mutex_unlock_166(& u132->scheduler_lock);
#line 1116
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1117
    return;
  }
}
}
#line 1121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_enumeration_address_sent(void *data , struct urb *urb , u8 *buf ,
                                              int len , int toggle_bits , int error_count ,
                                              int condition_code , int repeat_number ,
                                              int halted , int skipped , int actual ,
                                              int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  int retval ;
  struct u132_ring *ring ;

  {
  {
#line 1125
  endp = (struct u132_endp *)data;
#line 1126
  u132 = endp->u132;
#line 1127
  ldv_mutex_lock_167(& u132->scheduler_lock);
  }
#line 1128
  if (u132->going > 1) {
    {
#line 1129
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1131
    ldv_mutex_unlock_168(& u132->scheduler_lock);
#line 1132
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1133
    return;
  } else
#line 1134
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1135
    endp->dequeueing = 0U;
#line 1136
    ldv_mutex_unlock_169(& u132->scheduler_lock);
#line 1137
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1138
    return;
  } else
#line 1139
  if (u132->going > 0) {
    {
#line 1140
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1142
    ldv_mutex_unlock_170(& u132->scheduler_lock);
#line 1143
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1144
    return;
  } else
#line 1145
  if (urb->unlinked == 0) {
    {
#line 1147
    ring = endp->ring;
#line 1148
    ldv_mutex_unlock_171(& u132->scheduler_lock);
#line 1149
    retval = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring->number, (void *)endp,
                                       urb, 0, (int )endp->usb_endp, 0, & u132_hcd_enumeration_empty_recv);
    }
#line 1152
    if (retval != 0) {
      {
#line 1153
      u132_hcd_giveback_urb(u132, endp, urb, retval);
      }
    } else {

    }
#line 1154
    return;
  } else {
    {
#line 1156
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1158
    ldv_mutex_unlock_172(& u132->scheduler_lock);
#line 1159
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1160
    return;
  }
}
}
#line 1164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_initial_empty_sent(void *data , struct urb *urb , u8 *buf , int len ,
                                        int toggle_bits , int error_count , int condition_code ,
                                        int repeat_number , int halted , int skipped ,
                                        int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;

  {
  {
#line 1168
  endp = (struct u132_endp *)data;
#line 1169
  u132 = endp->u132;
#line 1170
  ldv_mutex_lock_173(& u132->scheduler_lock);
  }
#line 1171
  if (u132->going > 1) {
    {
#line 1172
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1174
    ldv_mutex_unlock_174(& u132->scheduler_lock);
#line 1175
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1176
    return;
  } else
#line 1177
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1178
    endp->dequeueing = 0U;
#line 1179
    ldv_mutex_unlock_175(& u132->scheduler_lock);
#line 1180
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1181
    return;
  } else
#line 1182
  if (u132->going > 0) {
    {
#line 1183
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1185
    ldv_mutex_unlock_176(& u132->scheduler_lock);
#line 1186
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1187
    return;
  } else
#line 1188
  if (urb->unlinked == 0) {
    {
#line 1189
    ldv_mutex_unlock_177(& u132->scheduler_lock);
#line 1190
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1191
    return;
  } else {
    {
#line 1193
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1195
    ldv_mutex_unlock_178(& u132->scheduler_lock);
#line 1196
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1197
    return;
  }
}
}
#line 1201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_initial_input_recv(void *data , struct urb *urb , u8 *buf , int len ,
                                        int toggle_bits , int error_count , int condition_code ,
                                        int repeat_number , int halted , int skipped ,
                                        int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  int retval ;
  struct u132_ring *ring ;
  u8 *u ;
  u8 *b ;
  int L ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1205
  endp = (struct u132_endp *)data;
#line 1206
  u132 = endp->u132;
#line 1207
  address = u132->addr[(int )endp->usb_addr].address;
#line 1208
  ldv_mutex_lock_179(& u132->scheduler_lock);
  }
#line 1209
  if (u132->going > 1) {
    {
#line 1210
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1212
    ldv_mutex_unlock_180(& u132->scheduler_lock);
#line 1213
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1214
    return;
  } else
#line 1215
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1216
    endp->dequeueing = 0U;
#line 1217
    ldv_mutex_unlock_181(& u132->scheduler_lock);
#line 1218
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1219
    return;
  } else
#line 1220
  if (u132->going > 0) {
    {
#line 1221
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1223
    ldv_mutex_unlock_182(& u132->scheduler_lock);
#line 1224
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1225
    return;
  } else
#line 1226
  if (urb->unlinked == 0) {
#line 1228
    ring = endp->ring;
#line 1229
    u = (u8 *)urb->transfer_buffer;
#line 1230
    b = buf;
#line 1231
    L = len;
#line 1233
    goto ldv_30881;
    ldv_30880: 
#line 1234
    tmp = u;
#line 1234
    u = u + 1;
#line 1234
    tmp___0 = b;
#line 1234
    b = b + 1;
#line 1234
    *tmp = *tmp___0;
    ldv_30881: 
#line 1233
    tmp___1 = L;
#line 1233
    L = L - 1;
#line 1233
    if (tmp___1 > 0) {
#line 1235
      goto ldv_30880;
    } else {

    }
    {
#line 1236
    urb->actual_length = (u32 )len;
#line 1237
    ldv_mutex_unlock_183(& u132->scheduler_lock);
#line 1238
    retval = usb_ftdi_elan_edset_empty(u132->platform_dev, (int )ring->number, (void *)endp,
                                       urb, (int )address, (int )endp->usb_endp, 3,
                                       & u132_hcd_initial_empty_sent);
    }
#line 1241
    if (retval != 0) {
      {
#line 1242
      u132_hcd_giveback_urb(u132, endp, urb, retval);
      }
    } else {

    }
#line 1243
    return;
  } else {
    {
#line 1245
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1247
    ldv_mutex_unlock_184(& u132->scheduler_lock);
#line 1248
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1249
    return;
  }
}
}
#line 1253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_initial_setup_sent(void *data , struct urb *urb , u8 *buf , int len ,
                                        int toggle_bits , int error_count , int condition_code ,
                                        int repeat_number , int halted , int skipped ,
                                        int actual , int non_null ) 
{ 
  struct u132_endp *endp ;
  struct u132 *u132 ;
  u8 address ;
  int retval ;
  struct u132_ring *ring ;

  {
  {
#line 1257
  endp = (struct u132_endp *)data;
#line 1258
  u132 = endp->u132;
#line 1259
  address = u132->addr[(int )endp->usb_addr].address;
#line 1260
  ldv_mutex_lock_185(& u132->scheduler_lock);
  }
#line 1261
  if (u132->going > 1) {
    {
#line 1262
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
#line 1264
    ldv_mutex_unlock_186(& u132->scheduler_lock);
#line 1265
    u132_hcd_forget_urb(u132, endp, urb, -19);
    }
#line 1266
    return;
  } else
#line 1267
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
    {
#line 1268
    endp->dequeueing = 0U;
#line 1269
    ldv_mutex_unlock_187(& u132->scheduler_lock);
#line 1270
    u132_hcd_giveback_urb(u132, endp, urb, -4);
    }
#line 1271
    return;
  } else
#line 1272
  if (u132->going > 0) {
    {
#line 1273
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
#line 1275
    ldv_mutex_unlock_188(& u132->scheduler_lock);
#line 1276
    u132_hcd_giveback_urb(u132, endp, urb, -19);
    }
#line 1277
    return;
  } else
#line 1278
  if (urb->unlinked == 0) {
    {
#line 1280
    ring = endp->ring;
#line 1281
    ldv_mutex_unlock_189(& u132->scheduler_lock);
#line 1282
    retval = usb_ftdi_elan_edset_input(u132->platform_dev, (int )ring->number, (void *)endp,
                                       urb, (int )address, (int )endp->usb_endp, 0,
                                       & u132_hcd_initial_input_recv);
    }
#line 1285
    if (retval != 0) {
      {
#line 1286
      u132_hcd_giveback_urb(u132, endp, urb, retval);
      }
    } else {

    }
#line 1287
    return;
  } else {
    {
#line 1289
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "CALLBACK called urb=%p unlinked=%d\n",
            urb, urb->unlinked);
#line 1291
    ldv_mutex_unlock_190(& u132->scheduler_lock);
#line 1292
    u132_hcd_giveback_urb(u132, endp, urb, 0);
    }
#line 1293
    return;
  }
}
}
#line 1301 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_ring_work_scheduler(struct work_struct *work ) 
{ 
  struct u132_ring *ring ;
  struct work_struct  const  *__mptr ;
  struct u132 *u132 ;
  struct u132_endp *last_endp ;
  struct list_head *scan ;
  struct list_head *head ;
  unsigned long wakeup ;
  struct u132_endp *endp ;
  struct list_head  const  *__mptr___0 ;
  unsigned long delta ;
  unsigned long delta___0 ;

  {
  {
#line 1304
  __mptr = (struct work_struct  const  *)work;
#line 1304
  ring = (struct u132_ring *)__mptr + 0xffffffffffffffe8UL;
#line 1305
  u132 = ring->u132;
#line 1306
  ldv_mutex_lock_191(& u132->scheduler_lock);
  }
#line 1307
  if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
    {
#line 1308
    ldv_mutex_unlock_192(& u132->scheduler_lock);
#line 1309
    u132_ring_put_kref(u132, ring);
    }
#line 1310
    return;
  } else
#line 1311
  if ((unsigned long )ring->curr_endp != (unsigned long )((struct u132_endp *)0)) {
#line 1312
    last_endp = ring->curr_endp;
#line 1314
    head = & last_endp->endp_ring;
#line 1315
    wakeup = 0UL;
#line 1316
    scan = head->next;
#line 1316
    goto ldv_30924;
    ldv_30923: 
#line 1317
    __mptr___0 = (struct list_head  const  *)scan;
#line 1317
    endp = (struct u132_endp *)__mptr___0 + 0xfffffffffffffff0UL;
#line 1319
    if ((int )endp->queue_next == (int )endp->queue_last) {

    } else
#line 1321
    if ((unsigned int )*((unsigned char *)endp + 40UL) == 0U || (long )((unsigned long )jiffies - endp->jiffies) >= 0L) {
      {
#line 1322
      ring->curr_endp = endp;
#line 1323
      u132_endp_cancel_work(u132, last_endp);
#line 1324
      u132_endp_queue_work(u132, last_endp, 0U);
#line 1325
      ldv_mutex_unlock_193(& u132->scheduler_lock);
#line 1326
      u132_ring_put_kref(u132, ring);
      }
#line 1327
      return;
    } else {
#line 1329
      delta = endp->jiffies - (unsigned long )jiffies;
#line 1330
      if (delta > wakeup) {
#line 1331
        wakeup = delta;
      } else {

      }
    }
#line 1316
    scan = scan->next;
    ldv_30924: ;
#line 1316
    if ((unsigned long )scan != (unsigned long )head) {
#line 1318
      goto ldv_30923;
    } else {

    }

#line 1334
    if ((int )last_endp->queue_next == (int )last_endp->queue_last) {

    } else
#line 1335
    if ((unsigned int )*((unsigned char *)last_endp + 40UL) == 0U || (long )((unsigned long )jiffies - last_endp->jiffies) >= 0L) {
      {
#line 1337
      u132_endp_cancel_work(u132, last_endp);
#line 1338
      u132_endp_queue_work(u132, last_endp, 0U);
#line 1339
      ldv_mutex_unlock_194(& u132->scheduler_lock);
#line 1340
      u132_ring_put_kref(u132, ring);
      }
#line 1341
      return;
    } else {
#line 1343
      delta___0 = last_endp->jiffies - (unsigned long )jiffies;
#line 1344
      if (delta___0 > wakeup) {
#line 1345
        wakeup = delta___0;
      } else {

      }
    }
#line 1347
    if (wakeup != 0UL) {
      {
#line 1348
      u132_ring_requeue_work(u132, ring, (unsigned int )wakeup);
#line 1349
      ldv_mutex_unlock_195(& u132->scheduler_lock);
      }
#line 1350
      return;
    } else {
      {
#line 1352
      ldv_mutex_unlock_196(& u132->scheduler_lock);
#line 1353
      u132_ring_put_kref(u132, ring);
      }
#line 1354
      return;
    }
  } else {
    {
#line 1357
    ldv_mutex_unlock_197(& u132->scheduler_lock);
#line 1358
    u132_ring_put_kref(u132, ring);
    }
#line 1359
    return;
  }
}
}
#line 1363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_endp_work_scheduler(struct work_struct *work ) 
{ 
  struct u132_ring *ring ;
  struct u132_endp *endp ;
  struct work_struct  const  *__mptr ;
  struct u132 *u132 ;
  u8 address ;
  int retval ;
  struct urb *urb ;
  u8 address___0 ;
  int retval___0 ;
  struct urb *urb___0 ;
  int retval___1 ;
  struct urb *urb___1 ;
  int retval___2 ;
  struct urb *urb___2 ;
  u8 address___1 ;
  int retval___3 ;
  struct urb *urb___3 ;
  u8 address___2 ;
  int retval___4 ;
  struct urb *urb___4 ;

  {
  {
#line 1367
  __mptr = (struct work_struct  const  *)work;
#line 1367
  endp = (struct u132_endp *)__mptr + 0xffffffffffffff20UL;
#line 1368
  u132 = endp->u132;
#line 1369
  ldv_mutex_lock_198(& u132->scheduler_lock);
#line 1370
  ring = endp->ring;
  }
#line 1371
  if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
#line 1372
    endp->edset_flush = 0U;
#line 1373
    if ((unsigned int )*((unsigned char *)endp + 41UL) != 0U) {
      {
#line 1374
      usb_ftdi_elan_edset_flush(u132->platform_dev, (int )ring->number, (void *)endp);
      }
    } else {

    }
    {
#line 1376
    ldv_mutex_unlock_199(& u132->scheduler_lock);
#line 1377
    u132_endp_put_kref(u132, endp);
    }
#line 1378
    return;
  } else
#line 1379
  if ((unsigned int )*((unsigned char *)endp + 40UL) != 0U) {
    {
#line 1380
    ldv_mutex_unlock_200(& u132->scheduler_lock);
#line 1381
    u132_endp_put_kref(u132, endp);
    }
#line 1382
    return;
  } else
#line 1383
  if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
    {
#line 1384
    ldv_mutex_unlock_201(& u132->scheduler_lock);
#line 1385
    u132_endp_put_kref(u132, endp);
    }
#line 1386
    return;
  } else
#line 1387
  if ((int )endp->queue_next == (int )endp->queue_last) {
    {
#line 1388
    ldv_mutex_unlock_202(& u132->scheduler_lock);
#line 1389
    u132_endp_put_kref(u132, endp);
    }
#line 1390
    return;
  } else
#line 1391
  if ((unsigned int )*((unsigned char *)endp + 40UL) == 64U) {
#line 1392
    address = u132->addr[(int )endp->usb_addr].address;
#line 1393
    if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
      {
#line 1394
      ldv_mutex_unlock_203(& u132->scheduler_lock);
#line 1395
      u132_endp_put_kref(u132, endp);
      }
#line 1396
      return;
    } else {
      {
#line 1399
      urb = endp->urb_list[(int )endp->queue_next & 7];
#line 1401
      endp->active = 1U;
#line 1402
      ring->curr_endp = endp;
#line 1403
      ring->in_use = 1U;
#line 1404
      ldv_mutex_unlock_204(& u132->scheduler_lock);
#line 1405
      retval = edset_single(u132, ring, endp, urb, (int )address, (int )endp->toggle_bits,
                            & u132_hcd_interrupt_recv);
      }
#line 1407
      if (retval != 0) {
        {
#line 1408
        u132_hcd_giveback_urb(u132, endp, urb, retval);
        }
      } else {

      }
#line 1409
      return;
    }
  } else
#line 1411
  if ((unsigned int )*((unsigned char *)endp + 40UL) == 128U) {
#line 1412
    address___0 = u132->addr[(int )endp->usb_addr].address;
#line 1413
    if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
      {
#line 1414
      ldv_mutex_unlock_205(& u132->scheduler_lock);
#line 1415
      u132_endp_put_kref(u132, endp);
      }
#line 1416
      return;
    } else
#line 1417
    if ((unsigned int )address___0 == 0U) {
      {
#line 1419
      urb___0 = endp->urb_list[(int )endp->queue_next & 7];
#line 1421
      endp->active = 1U;
#line 1422
      ring->curr_endp = endp;
#line 1423
      ring->in_use = 1U;
#line 1424
      ldv_mutex_unlock_206(& u132->scheduler_lock);
#line 1425
      retval___0 = edset_setup(u132, ring, endp, urb___0, (int )address___0, 2, & u132_hcd_initial_setup_sent);
      }
#line 1427
      if (retval___0 != 0) {
        {
#line 1428
        u132_hcd_giveback_urb(u132, endp, urb___0, retval___0);
        }
      } else {

      }
#line 1429
      return;
    } else
#line 1430
    if ((unsigned int )endp->usb_addr == 0U) {
      {
#line 1432
      urb___1 = endp->urb_list[(int )endp->queue_next & 7];
#line 1434
      endp->active = 1U;
#line 1435
      ring->curr_endp = endp;
#line 1436
      ring->in_use = 1U;
#line 1437
      ldv_mutex_unlock_207(& u132->scheduler_lock);
#line 1438
      retval___1 = edset_setup(u132, ring, endp, urb___1, 0, 2, & u132_hcd_enumeration_address_sent);
      }
#line 1440
      if (retval___1 != 0) {
        {
#line 1441
        u132_hcd_giveback_urb(u132, endp, urb___1, retval___1);
        }
      } else {

      }
#line 1442
      return;
    } else {
      {
#line 1445
      urb___2 = endp->urb_list[(int )endp->queue_next & 7];
#line 1447
      address___0 = u132->addr[(int )endp->usb_addr].address;
#line 1448
      endp->active = 1U;
#line 1449
      ring->curr_endp = endp;
#line 1450
      ring->in_use = 1U;
#line 1451
      ldv_mutex_unlock_208(& u132->scheduler_lock);
#line 1452
      retval___2 = edset_setup(u132, ring, endp, urb___2, (int )address___0, 2, & u132_hcd_configure_setup_sent);
      }
#line 1454
      if (retval___2 != 0) {
        {
#line 1455
        u132_hcd_giveback_urb(u132, endp, urb___2, retval___2);
        }
      } else {

      }
#line 1456
      return;
    }
  } else
#line 1459
  if ((unsigned int )*((unsigned char *)endp + 40UL) != 0U) {
#line 1460
    address___1 = u132->addr[(int )endp->usb_addr].address;
#line 1461
    if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
      {
#line 1462
      ldv_mutex_unlock_209(& u132->scheduler_lock);
#line 1463
      u132_endp_put_kref(u132, endp);
      }
#line 1464
      return;
    } else {
      {
#line 1467
      urb___3 = endp->urb_list[(int )endp->queue_next & 7];
#line 1469
      endp->active = 1U;
#line 1470
      ring->curr_endp = endp;
#line 1471
      ring->in_use = 1U;
#line 1472
      ldv_mutex_unlock_210(& u132->scheduler_lock);
#line 1473
      retval___3 = edset_input(u132, ring, endp, urb___3, (int )address___1, (int )endp->toggle_bits,
                               & u132_hcd_bulk_input_recv);
      }
#line 1476
      if (retval___3 == 0) {

      } else {
        {
#line 1478
        u132_hcd_giveback_urb(u132, endp, urb___3, retval___3);
        }
      }
#line 1480
      return;
    }
  } else {
#line 1483
    address___2 = u132->addr[(int )endp->usb_addr].address;
#line 1484
    if ((unsigned int )*((unsigned char *)ring + 0UL) != 0U) {
      {
#line 1485
      ldv_mutex_unlock_211(& u132->scheduler_lock);
#line 1486
      u132_endp_put_kref(u132, endp);
      }
#line 1487
      return;
    } else {
      {
#line 1490
      urb___4 = endp->urb_list[(int )endp->queue_next & 7];
#line 1492
      endp->active = 1U;
#line 1493
      ring->curr_endp = endp;
#line 1494
      ring->in_use = 1U;
#line 1495
      ldv_mutex_unlock_212(& u132->scheduler_lock);
#line 1496
      retval___4 = edset_output(u132, ring, endp, urb___4, (int )address___2, (int )endp->toggle_bits,
                                & u132_hcd_bulk_output_sent);
      }
#line 1499
      if (retval___4 == 0) {

      } else {
        {
#line 1501
        u132_hcd_giveback_urb(u132, endp, urb___4, retval___4);
        }
      }
#line 1503
      return;
    }
  }
}
}
#line 1510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void port_power(struct u132 *u132 , int pn , int is_on ) 
{ 


  {
#line 1512
  u132->port[pn].power = is_on;
#line 1513
  return;
}
}
#line 1517 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_power(struct u132 *u132 , int is_on ) 
{ 
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
  {
#line 1519
  tmp = u132_to_hcd(u132);
#line 1519
  hcd = tmp;
  }
#line 1521
  if (is_on != 0) {
#line 1522
    if (u132->power != 0) {
#line 1523
      return;
    } else {

    }
#line 1524
    u132->power = 1;
  } else {
#line 1526
    u132->power = 0;
#line 1527
    hcd->state = 0;
  }
#line 1529
  return;
}
}
#line 1531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_periodic_reinit(struct u132 *u132 ) 
{ 
  int retval ;
  u32 fi ;
  u32 fit ;
  u32 fminterval ;

  {
  {
#line 1534
  fi = u132->hc_fminterval & 16383U;
#line 1537
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 52, 0, & fminterval);
  }
#line 1538
  if (retval != 0) {
#line 1539
    return (retval);
  } else {

  }
  {
#line 1540
  fit = fminterval & 2147483648U;
#line 1541
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 52, 0, (fit ^ 2147483648U) | u132->hc_fminterval);
  }
#line 1543
  if (retval != 0) {
#line 1544
    return (retval);
  } else {

  }
  {
#line 1545
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 64, 0, (fi * 9U) / 10U & 16383U);
  }
#line 1547
  if (retval != 0) {
#line 1548
    return (retval);
  } else {

  }
#line 1549
  return (0);
}
}
#line 1552 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static char *hcfs2string(int state ) 
{ 


  {
  {
#line 1555
  if (state == 0) {
#line 1555
    goto case_0;
  } else {

  }
#line 1557
  if (state == 64) {
#line 1557
    goto case_64;
  } else {

  }
#line 1559
  if (state == 128) {
#line 1559
    goto case_128;
  } else {

  }
#line 1561
  if (state == 192) {
#line 1561
    goto case_192;
  } else {

  }
#line 1554
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 1556
  return ((char *)"reset");
  case_64: /* CIL Label */ ;
#line 1558
  return ((char *)"resume");
  case_128: /* CIL Label */ ;
#line 1560
  return ((char *)"operational");
  case_192: /* CIL Label */ ;
#line 1562
  return ((char *)"suspend");
  switch_break: /* CIL Label */ ;
  }
#line 1564
  return ((char *)"?");
}
}
#line 1567 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_init(struct u132 *u132 ) 
{ 
  int retval ;
  u32 control ;
  u32 rh_a ;

  {
  {
#line 1571
  u132_disable(u132);
#line 1572
  u132->next_statechange = jiffies;
#line 1573
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 20, 0, 2147483648U);
  }
#line 1574
  if (retval != 0) {
#line 1575
    return (retval);
  } else {

  }
  {
#line 1576
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
  }
#line 1577
  if (retval != 0) {
#line 1578
    return (retval);
  } else {

  }
#line 1579
  if (u132->num_ports == 0) {
    {
#line 1580
    rh_a = 4294967295U;
#line 1581
    retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 72, 0, & rh_a);
    }
#line 1582
    if (retval != 0) {
#line 1583
      return (retval);
    } else {

    }
    {
#line 1584
    u132->num_ports = (int )rh_a & 255;
#line 1585
    retval = read_roothub_info(u132);
    }
#line 1586
    if (retval != 0) {
#line 1587
      return (retval);
    } else {

    }
  } else {

  }
#line 1589
  if (u132->num_ports > 7) {
#line 1590
    return (-22);
  } else {

  }
#line 1592
  return (0);
}
}
#line 1600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_run(struct u132 *u132 ) 
{ 
  int retval ;
  u32 control ;
  u32 status ;
  u32 fminterval ;
  u32 periodicstart ;
  u32 cmdstatus ;
  u32 roothub_a___0 ;
  int mask ;
  int first ;
  int sleep_time ;
  int reset_timeout ;
  u32 temp ;
  char *tmp ;
  int temp___0 ;
  struct usb_hcd *tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  struct usb_hcd *tmp___2 ;

  {
  {
#line 1609
  mask = -2147483622;
#line 1610
  first = u132->hc_fminterval == 0U;
#line 1611
  sleep_time = 0;
#line 1612
  reset_timeout = 30;
#line 1613
  u132_disable(u132);
  }
#line 1614
  if (first != 0) {
    {
#line 1616
    retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 52, 0, & temp);
    }
#line 1617
    if (retval != 0) {
#line 1618
      return (retval);
    } else {

    }
#line 1619
    u132->hc_fminterval = temp & 16383U;
#line 1620
    u132->hc_fminterval = u132->hc_fminterval | (((u132->hc_fminterval * 6U + 4294966036U) / 7U & 32767U) << 16);
  } else {

  }
  {
#line 1622
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & u132->hc_control);
  }
#line 1623
  if (retval != 0) {
#line 1624
    return (retval);
  } else {

  }
  {
#line 1625
  tmp = hcfs2string((int )u132->hc_control & 192);
#line 1625
  _dev_info((struct device  const  *)(& (u132->platform_dev)->dev), "resetting from state \'%s\', control = %08X\n",
            tmp, u132->hc_control);
  }
  {
#line 1629
  if ((u132->hc_control & 192U) == 128U) {
#line 1629
    goto case_128;
  } else {

  }
#line 1632
  if ((u132->hc_control & 192U) == 192U) {
#line 1632
    goto case_192;
  } else {

  }
#line 1633
  if ((u132->hc_control & 192U) == 64U) {
#line 1633
    goto case_64;
  } else {

  }
#line 1638
  goto switch_default;
  case_128: /* CIL Label */ 
#line 1630
  sleep_time = 0;
#line 1631
  goto ldv_31003;
  case_192: /* CIL Label */ ;
  case_64: /* CIL Label */ 
#line 1634
  u132->hc_control = u132->hc_control & 512U;
#line 1635
  u132->hc_control = u132->hc_control | 64U;
#line 1636
  sleep_time = 10;
#line 1637
  goto ldv_31003;
  switch_default: /* CIL Label */ 
#line 1639
  u132->hc_control = u132->hc_control & 512U;
#line 1640
  u132->hc_control = u132->hc_control;
#line 1641
  sleep_time = 50;
#line 1642
  goto ldv_31003;
  switch_break: /* CIL Label */ ;
  }
  ldv_31003: 
  {
#line 1644
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 4, 0, u132->hc_control);
  }
#line 1645
  if (retval != 0) {
#line 1646
    return (retval);
  } else {

  }
  {
#line 1647
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
  }
#line 1648
  if (retval != 0) {
#line 1649
    return (retval);
  } else {

  }
  {
#line 1650
  msleep((unsigned int )sleep_time);
#line 1651
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 72, 0, & roothub_a___0);
  }
#line 1652
  if (retval != 0) {
#line 1653
    return (retval);
  } else {

  }
#line 1654
  if ((roothub_a___0 & 512U) == 0U) {
#line 1656
    temp___0 = 0;
#line 1656
    goto ldv_31009;
    ldv_31008: 
    {
#line 1657
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )temp___0 + 21UL) * 4U),
                                        0, 512U);
    }
#line 1659
    if (retval != 0) {
#line 1660
      return (retval);
    } else {

    }
#line 1656
    temp___0 = temp___0 + 1;
    ldv_31009: ;
#line 1656
    if (temp___0 < u132->num_ports) {
#line 1658
      goto ldv_31008;
    } else {

    }

  } else {

  }
  {
#line 1663
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
  }
#line 1664
  if (retval != 0) {
#line 1665
    return (retval);
  } else {

  }
  retry: 
  {
#line 1667
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 8, 0, & status);
  }
#line 1668
  if (retval != 0) {
#line 1669
    return (retval);
  } else {

  }
  {
#line 1670
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 8, 0, 1U);
  }
#line 1671
  if (retval != 0) {
#line 1672
    return (retval);
  } else {

  }
  extra: 
  {
#line 1674
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 8, 0, & status);
  }
#line 1675
  if (retval != 0) {
#line 1676
    return (retval);
  } else {

  }
#line 1677
  if ((int )status & 1) {
#line 1678
    reset_timeout = reset_timeout - 1;
#line 1678
    if (reset_timeout == 0) {
      {
#line 1679
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "USB HC reset timed out!\n");
      }
#line 1681
      return (-19);
    } else {
      {
#line 1683
      msleep(5U);
      }
#line 1684
      goto extra;
    }
  } else {

  }
#line 1688
  if ((u132->flags & 4) != 0) {
    {
#line 1689
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 4, 0, u132->hc_control);
    }
#line 1690
    if (retval != 0) {
#line 1691
      return (retval);
    } else {

    }
    {
#line 1692
    retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
    }
#line 1693
    if (retval != 0) {
#line 1694
      return (retval);
    } else {

    }
  } else {

  }
  {
#line 1696
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 32, 0, 0U);
  }
#line 1697
  if (retval != 0) {
#line 1698
    return (retval);
  } else {

  }
  {
#line 1699
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 40, 0, 285212672U);
  }
#line 1700
  if (retval != 0) {
#line 1701
    return (retval);
  } else {

  }
  {
#line 1702
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 24, 0, 0U);
  }
#line 1703
  if (retval != 0) {
#line 1704
    return (retval);
  } else {

  }
  {
#line 1705
  retval = u132_periodic_reinit(u132);
  }
#line 1706
  if (retval != 0) {
#line 1707
    return (retval);
  } else {

  }
  {
#line 1708
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 52, 0, & fminterval);
  }
#line 1709
  if (retval != 0) {
#line 1710
    return (retval);
  } else {

  }
  {
#line 1711
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 64, 0, & periodicstart);
  }
#line 1712
  if (retval != 0) {
#line 1713
    return (retval);
  } else {

  }
#line 1714
  if ((fminterval & 1073676288U) == 0U || periodicstart == 0U) {
#line 1715
    if ((u132->flags & 4) == 0) {
#line 1716
      u132->flags = u132->flags | 4;
#line 1717
      goto retry;
    } else {
      {
#line 1719
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "init err(%08x %04x)\n",
              fminterval, periodicstart);
      }
    }
  } else {

  }
  {
#line 1722
  u132->hc_control = u132->hc_control & 512U;
#line 1723
  u132->hc_control = u132->hc_control | 163U;
#line 1724
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 4, 0, u132->hc_control);
  }
#line 1725
  if (retval != 0) {
#line 1726
    return (retval);
  } else {

  }
  {
#line 1727
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 8, 0, 4U);
  }
#line 1728
  if (retval != 0) {
#line 1729
    return (retval);
  } else {

  }
  {
#line 1730
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 8, 0, & cmdstatus);
  }
#line 1731
  if (retval != 0) {
#line 1732
    return (retval);
  } else {

  }
  {
#line 1733
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
  }
#line 1734
  if (retval != 0) {
#line 1735
    return (retval);
  } else {

  }
  {
#line 1736
  tmp___0 = u132_to_hcd(u132);
#line 1736
  tmp___0->state = 1;
#line 1737
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 80, 0, 32768U);
  }
#line 1738
  if (retval != 0) {
#line 1739
    return (retval);
  } else {

  }
  {
#line 1740
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 12, 0, (u32 )mask);
  }
#line 1741
  if (retval != 0) {
#line 1742
    return (retval);
  } else {

  }
  {
#line 1743
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 20, 0, 3221225599U);
  }
#line 1747
  if (retval != 0) {
#line 1748
    return (retval);
  } else {

  }
  {
#line 1749
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 72, 0, & roothub_a___0);
  }
#line 1750
  if (retval != 0) {
#line 1751
    return (retval);
  } else {

  }
#line 1752
  roothub_a___0 = roothub_a___0 & 4294964991U;
#line 1753
  if ((u132->flags & 2) != 0) {
    {
#line 1754
    roothub_a___0 = roothub_a___0 | 4096U;
#line 1755
    roothub_a___0 = roothub_a___0 & 16776703U;
#line 1756
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 72, 0, roothub_a___0);
    }
#line 1757
    if (retval != 0) {
#line 1758
      return (retval);
    } else {

    }
  } else
#line 1759
  if (u132->flags & 1 || (int )distrust_firmware) {
    {
#line 1760
    roothub_a___0 = roothub_a___0 | 512U;
#line 1761
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 72, 0, roothub_a___0);
    }
#line 1762
    if (retval != 0) {
#line 1763
      return (retval);
    } else {

    }
  } else {

  }
  {
#line 1765
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 80, 0, 65536U);
  }
#line 1766
  if (retval != 0) {
#line 1767
    return (retval);
  } else {

  }
  {
#line 1768
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, 76, 0, (roothub_a___0 & 512U) != 0U ? 0U : 4294901760U);
  }
#line 1770
  if (retval != 0) {
#line 1771
    return (retval);
  } else {

  }
  {
#line 1772
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 4, 0, & control);
  }
#line 1773
  if (retval != 0) {
#line 1774
    return (retval);
  } else {

  }
#line 1775
  __ms = (unsigned long )(roothub_a___0 >> 23) & 510UL;
#line 1775
  goto ldv_31015;
  ldv_31014: 
  {
#line 1775
  __const_udelay(4295000UL);
  }
  ldv_31015: 
#line 1775
  tmp___1 = __ms;
#line 1775
  __ms = __ms - 1UL;
#line 1775
  if (tmp___1 != 0UL) {
#line 1777
    goto ldv_31014;
  } else {

  }
  {
#line 1776
  tmp___2 = u132_to_hcd(u132);
#line 1776
  tmp___2->state = 1;
  }
#line 1777
  return (0);
}
}
#line 1780 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_stop(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;

  {
  {
#line 1782
  tmp = hcd_to_u132(hcd);
#line 1782
  u132 = tmp;
  }
#line 1783
  if (u132->going > 1) {
    {
#line 1784
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "u132 device %p(hcd=%p) has been removed %d\n",
            u132, hcd, u132->going);
    }
  } else
#line 1786
  if (u132->going > 0) {
    {
#line 1787
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device hcd=%p is being removed\n",
            hcd);
    }
  } else {
    {
#line 1790
    ldv_mutex_lock_213(& u132->sw_lock);
#line 1791
    msleep(100U);
#line 1792
    u132_power(u132, 0);
#line 1793
    ldv_mutex_unlock_214(& u132->sw_lock);
    }
  }
#line 1795
  return;
}
}
#line 1797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_hcd_start(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  int retval ;
  struct platform_device *pdev ;
  struct device  const  *__mptr ;
  u16 vendor ;
  void *tmp___0 ;
  u16 device ;
  void *tmp___1 ;

  {
  {
#line 1799
  tmp = hcd_to_u132(hcd);
#line 1799
  u132 = tmp;
  }
#line 1800
  if (u132->going > 1) {
    {
#line 1801
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 1803
    return (-19);
  } else
#line 1804
  if (u132->going > 0) {
    {
#line 1805
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 1806
    return (-108);
  } else
#line 1807
  if ((unsigned long )hcd->self.controller != (unsigned long )((struct device *)0)) {
    {
#line 1810
    __mptr = (struct device  const  *)hcd->self.controller;
#line 1810
    pdev = (struct platform_device *)__mptr + 0xfffffffffffffff0UL;
#line 1811
    tmp___0 = dev_get_platdata((struct device  const  *)(& pdev->dev));
#line 1811
    vendor = ((struct u132_platform_data *)tmp___0)->vendor;
#line 1813
    tmp___1 = dev_get_platdata((struct device  const  *)(& pdev->dev));
#line 1813
    device = ((struct u132_platform_data *)tmp___1)->device;
#line 1815
    ldv_mutex_lock_215(& u132->sw_lock);
#line 1816
    msleep(10U);
    }
#line 1817
    if ((unsigned int )vendor == 4130U && (unsigned int )device == 29708U) {
#line 1818
      u132->flags = 1;
    } else
#line 1819
    if ((unsigned int )vendor == 4165U && (unsigned int )device == 51297U) {
      {
#line 1820
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "WARNING: OPTi workarounds unavailable\n");
      }
    } else
#line 1822
    if ((unsigned int )vendor == 3601U && (unsigned int )device == 41208U) {
#line 1823
      u132->flags = u132->flags | 32;
    } else {

    }
    {
#line 1824
    retval = u132_run(u132);
    }
#line 1825
    if (retval != 0) {
      {
#line 1826
      u132_disable(u132);
#line 1827
      u132->going = 1;
      }
    } else {

    }
    {
#line 1829
    msleep(100U);
#line 1830
    ldv_mutex_unlock_216(& u132->sw_lock);
    }
#line 1831
    return (retval);
  } else {
    {
#line 1833
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "platform_device missing\n");
    }
#line 1834
    return (-19);
  }
}
}
#line 1838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_hcd_reset(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  int retval ;

  {
  {
#line 1840
  tmp = hcd_to_u132(hcd);
#line 1840
  u132 = tmp;
  }
#line 1841
  if (u132->going > 1) {
    {
#line 1842
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 1844
    return (-19);
  } else
#line 1845
  if (u132->going > 0) {
    {
#line 1846
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 1847
    return (-108);
  } else {
    {
#line 1850
    ldv_mutex_lock_217(& u132->sw_lock);
#line 1851
    retval = u132_init(u132);
    }
#line 1852
    if (retval != 0) {
      {
#line 1853
      u132_disable(u132);
#line 1854
      u132->going = 1;
      }
    } else {

    }
    {
#line 1856
    ldv_mutex_unlock_218(& u132->sw_lock);
    }
#line 1857
    return (retval);
  }
}
}
#line 1861 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int create_endpoint_and_queue_int(struct u132 *u132 , struct u132_udev *udev ,
                                         struct urb *urb , struct usb_device *usb_dev ,
                                         u8 usb_addr , u8 usb_endp , u8 address ,
                                         gfp_t mem_flags ) 
{ 
  struct u132_ring *ring ;
  unsigned long irqs ;
  int rc ;
  u8 endp_number ;
  struct u132_endp *endp ;
  void *tmp ;
  struct lock_class_key __key ;
  struct usb_hcd *tmp___0 ;
  struct u132_endp *tmp___1 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct u132_ring *tmp___2 ;
  unsigned long tmp___3 ;
  u16 tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 1870
  tmp = kmalloc(448UL, mem_flags);
#line 1870
  endp = (struct u132_endp *)tmp;
  }
#line 1872
  if ((unsigned long )endp == (unsigned long )((struct u132_endp *)0)) {
#line 1873
    return (-12);
  } else {

  }
  {
#line 1875
  spinlock_check(& endp->queue_lock.slock);
#line 1875
  __raw_spin_lock_init(& endp->queue_lock.slock.__annonCompField18.rlock, "&(&endp->queue_lock.slock)->rlock",
                       & __key);
#line 1876
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_219(& endp->queue_lock.slock);
#line 1877
  tmp___0 = u132_to_hcd(u132);
#line 1877
  rc = usb_hcd_link_urb_to_ep(tmp___0, urb);
  }
#line 1878
  if (rc != 0) {
    {
#line 1879
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 1880
    kfree((void const   *)endp);
    }
#line 1881
    return (rc);
  } else {

  }
  {
#line 1884
  u132->num_endpoints = u132->num_endpoints + 1;
#line 1884
  endp_number = (u8 )u132->num_endpoints;
#line 1885
  tmp___1 = endp;
#line 1885
  u132->endp[(int )endp_number + -1] = tmp___1;
#line 1885
  (urb->ep)->hcpriv = (void *)tmp___1;
#line 1886
  __init_work(& endp->scheduler.work, 0);
#line 1886
  __constr_expr_0.counter = 137438953408L;
#line 1886
  endp->scheduler.work.data = __constr_expr_0;
#line 1886
  lockdep_init_map(& endp->scheduler.work.lockdep_map, "(&(&endp->scheduler)->work)",
                   & __key___0, 0);
#line 1886
  INIT_LIST_HEAD(& endp->scheduler.work.entry);
#line 1886
  endp->scheduler.work.func = & u132_hcd_endp_work_scheduler;
#line 1886
  init_timer_key(& endp->scheduler.timer, 2U, "(&(&endp->scheduler)->timer)", & __key___1);
#line 1886
  endp->scheduler.timer.function = & delayed_work_timer_fn;
#line 1886
  endp->scheduler.timer.data = (unsigned long )(& endp->scheduler);
#line 1887
  INIT_LIST_HEAD(& endp->urb_more);
#line 1888
  tmp___2 = (struct u132_ring *)(& u132->ring);
#line 1888
  endp->ring = tmp___2;
#line 1888
  ring = tmp___2;
  }
#line 1889
  if ((unsigned long )ring->curr_endp != (unsigned long )((struct u132_endp *)0)) {
    {
#line 1890
    list_add_tail(& endp->endp_ring, & (ring->curr_endp)->endp_ring);
    }
  } else {
    {
#line 1892
    INIT_LIST_HEAD(& endp->endp_ring);
#line 1893
    ring->curr_endp = endp;
    }
  }
  {
#line 1895
  ring->length = (unsigned char )((unsigned int )ring->length + 1U);
#line 1896
  endp->dequeueing = 0U;
#line 1897
  endp->edset_flush = 0U;
#line 1898
  endp->active = 0U;
#line 1899
  endp->delayed = 0U;
#line 1900
  endp->endp_number = endp_number;
#line 1901
  endp->u132 = u132;
#line 1902
  endp->hep = urb->ep;
#line 1903
  endp->pipetype = (unsigned char )(urb->pipe >> 30);
#line 1904
  u132_endp_init_kref(u132, endp);
  }
#line 1905
  if ((urb->pipe & 128U) != 0U) {
    {
#line 1906
    endp->toggle_bits = 2U;
#line 1907
    (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )usb_endp));
#line 1908
    endp->input = 1U;
#line 1909
    endp->output = 0U;
#line 1910
    udev->endp_number_in[(int )usb_endp] = endp_number;
#line 1911
    u132_udev_get_kref(u132, udev);
    }
  } else {
    {
#line 1913
    endp->toggle_bits = 2U;
#line 1914
    (udev->usb_device)->toggle[1] = (udev->usb_device)->toggle[1] & (unsigned int )(~ (1 << (int )usb_endp));
#line 1915
    endp->input = 0U;
#line 1916
    endp->output = 1U;
#line 1917
    udev->endp_number_out[(int )usb_endp] = endp_number;
#line 1918
    u132_udev_get_kref(u132, udev);
    }
  }
  {
#line 1920
  urb->hcpriv = (void *)u132;
#line 1921
  endp->delayed = 1U;
#line 1922
  tmp___3 = msecs_to_jiffies((unsigned int const   )urb->interval);
#line 1922
  endp->jiffies = (unsigned long )jiffies + tmp___3;
#line 1923
  endp->udev_number = address;
#line 1924
  endp->usb_addr = usb_addr;
#line 1925
  endp->usb_endp = usb_endp;
#line 1926
  endp->queue_size = 1U;
#line 1927
  endp->queue_last = 0U;
#line 1928
  endp->queue_next = 0U;
#line 1929
  tmp___4 = endp->queue_last;
#line 1929
  endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 1929
  endp->urb_list[(int )tmp___4 & 7] = urb;
#line 1930
  ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 1931
  tmp___5 = msecs_to_jiffies((unsigned int const   )urb->interval);
#line 1931
  u132_endp_queue_work(u132, endp, (unsigned int )tmp___5);
  }
#line 1932
  return (0);
}
}
#line 1935 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int queue_int_on_old_endpoint(struct u132 *u132 , struct u132_udev *udev ,
                                     struct urb *urb , struct usb_device *usb_dev ,
                                     struct u132_endp *endp , u8 usb_addr , u8 usb_endp ,
                                     u8 address ) 
{ 
  unsigned long tmp ;
  u16 tmp___0 ;
  struct u132_urbq *urbq ;
  void *tmp___1 ;
  u16 tmp___2 ;

  {
  {
#line 1940
  urb->hcpriv = (void *)u132;
#line 1941
  endp->delayed = 1U;
#line 1942
  tmp = msecs_to_jiffies((unsigned int const   )urb->interval);
#line 1942
  endp->jiffies = (unsigned long )jiffies + tmp;
#line 1943
  tmp___2 = endp->queue_size;
#line 1943
  endp->queue_size = (u16 )((int )endp->queue_size + 1);
  }
#line 1943
  if ((unsigned int )tmp___2 <= 7U) {
#line 1944
    tmp___0 = endp->queue_last;
#line 1944
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 1944
    endp->urb_list[(int )tmp___0 & 7] = urb;
  } else {
    {
#line 1946
    tmp___1 = kmalloc(24UL, 32U);
#line 1946
    urbq = (struct u132_urbq *)tmp___1;
    }
#line 1948
    if ((unsigned long )urbq == (unsigned long )((struct u132_urbq *)0)) {
#line 1949
      endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 1950
      return (-12);
    } else {
      {
#line 1952
      list_add_tail(& urbq->urb_more, & endp->urb_more);
#line 1953
      urbq->urb = urb;
      }
    }
  }
#line 1956
  return (0);
}
}
#line 1959 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int create_endpoint_and_queue_bulk(struct u132 *u132 , struct u132_udev *udev ,
                                          struct urb *urb , struct usb_device *usb_dev ,
                                          u8 usb_addr , u8 usb_endp , u8 address ,
                                          gfp_t mem_flags ) 
{ 
  int ring_number ;
  struct u132_ring *ring ;
  unsigned long irqs ;
  int rc ;
  u8 endp_number ;
  struct u132_endp *endp ;
  void *tmp ;
  struct lock_class_key __key ;
  struct usb_hcd *tmp___0 ;
  struct u132_endp *tmp___1 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct u132_ring *tmp___2 ;
  u16 tmp___3 ;

  {
  {
#line 1969
  tmp = kmalloc(448UL, mem_flags);
#line 1969
  endp = (struct u132_endp *)tmp;
  }
#line 1971
  if ((unsigned long )endp == (unsigned long )((struct u132_endp *)0)) {
#line 1972
    return (-12);
  } else {

  }
  {
#line 1974
  spinlock_check(& endp->queue_lock.slock);
#line 1974
  __raw_spin_lock_init(& endp->queue_lock.slock.__annonCompField18.rlock, "&(&endp->queue_lock.slock)->rlock",
                       & __key);
#line 1975
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_222(& endp->queue_lock.slock);
#line 1976
  tmp___0 = u132_to_hcd(u132);
#line 1976
  rc = usb_hcd_link_urb_to_ep(tmp___0, urb);
  }
#line 1977
  if (rc != 0) {
    {
#line 1978
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 1979
    kfree((void const   *)endp);
    }
#line 1980
    return (rc);
  } else {

  }
  {
#line 1983
  u132->num_endpoints = u132->num_endpoints + 1;
#line 1983
  endp_number = (u8 )u132->num_endpoints;
#line 1984
  tmp___1 = endp;
#line 1984
  u132->endp[(int )endp_number + -1] = tmp___1;
#line 1984
  (urb->ep)->hcpriv = (void *)tmp___1;
#line 1985
  __init_work(& endp->scheduler.work, 0);
#line 1985
  __constr_expr_0.counter = 137438953408L;
#line 1985
  endp->scheduler.work.data = __constr_expr_0;
#line 1985
  lockdep_init_map(& endp->scheduler.work.lockdep_map, "(&(&endp->scheduler)->work)",
                   & __key___0, 0);
#line 1985
  INIT_LIST_HEAD(& endp->scheduler.work.entry);
#line 1985
  endp->scheduler.work.func = & u132_hcd_endp_work_scheduler;
#line 1985
  init_timer_key(& endp->scheduler.timer, 2U, "(&(&endp->scheduler)->timer)", & __key___1);
#line 1985
  endp->scheduler.timer.function = & delayed_work_timer_fn;
#line 1985
  endp->scheduler.timer.data = (unsigned long )(& endp->scheduler);
#line 1986
  INIT_LIST_HEAD(& endp->urb_more);
#line 1987
  endp->dequeueing = 0U;
#line 1988
  endp->edset_flush = 0U;
#line 1989
  endp->active = 0U;
#line 1990
  endp->delayed = 0U;
#line 1991
  endp->endp_number = endp_number;
#line 1992
  endp->u132 = u132;
#line 1993
  endp->hep = urb->ep;
#line 1994
  endp->pipetype = (unsigned char )(urb->pipe >> 30);
#line 1995
  u132_endp_init_kref(u132, endp);
  }
#line 1996
  if ((urb->pipe & 128U) != 0U) {
    {
#line 1997
    endp->toggle_bits = 2U;
#line 1998
    (udev->usb_device)->toggle[0] = (udev->usb_device)->toggle[0] & (unsigned int )(~ (1 << (int )usb_endp));
#line 1999
    ring_number = 3;
#line 2000
    endp->input = 1U;
#line 2001
    endp->output = 0U;
#line 2002
    udev->endp_number_in[(int )usb_endp] = endp_number;
#line 2003
    u132_udev_get_kref(u132, udev);
    }
  } else {
    {
#line 2005
    endp->toggle_bits = 2U;
#line 2006
    (udev->usb_device)->toggle[1] = (udev->usb_device)->toggle[1] & (unsigned int )(~ (1 << (int )usb_endp));
#line 2007
    ring_number = 2;
#line 2008
    endp->input = 0U;
#line 2009
    endp->output = 1U;
#line 2010
    udev->endp_number_out[(int )usb_endp] = endp_number;
#line 2011
    u132_udev_get_kref(u132, udev);
    }
  }
#line 2013
  tmp___2 = (struct u132_ring *)(& u132->ring) + ((unsigned long )ring_number + 0xffffffffffffffffUL);
#line 2013
  endp->ring = tmp___2;
#line 2013
  ring = tmp___2;
#line 2014
  if ((unsigned long )ring->curr_endp != (unsigned long )((struct u132_endp *)0)) {
    {
#line 2015
    list_add_tail(& endp->endp_ring, & (ring->curr_endp)->endp_ring);
    }
  } else {
    {
#line 2017
    INIT_LIST_HEAD(& endp->endp_ring);
#line 2018
    ring->curr_endp = endp;
    }
  }
  {
#line 2020
  ring->length = (unsigned char )((unsigned int )ring->length + 1U);
#line 2021
  urb->hcpriv = (void *)u132;
#line 2022
  endp->udev_number = address;
#line 2023
  endp->usb_addr = usb_addr;
#line 2024
  endp->usb_endp = usb_endp;
#line 2025
  endp->queue_size = 1U;
#line 2026
  endp->queue_last = 0U;
#line 2027
  endp->queue_next = 0U;
#line 2028
  tmp___3 = endp->queue_last;
#line 2028
  endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2028
  endp->urb_list[(int )tmp___3 & 7] = urb;
#line 2029
  ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2030
  u132_endp_queue_work(u132, endp, 0U);
  }
#line 2031
  return (0);
}
}
#line 2034 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int queue_bulk_on_old_endpoint(struct u132 *u132 , struct u132_udev *udev ,
                                      struct urb *urb , struct usb_device *usb_dev ,
                                      struct u132_endp *endp , u8 usb_addr , u8 usb_endp ,
                                      u8 address ) 
{ 
  u16 tmp ;
  struct u132_urbq *urbq ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
#line 2039
  urb->hcpriv = (void *)u132;
#line 2040
  tmp___1 = endp->queue_size;
#line 2040
  endp->queue_size = (u16 )((int )endp->queue_size + 1);
#line 2040
  if ((unsigned int )tmp___1 <= 7U) {
#line 2041
    tmp = endp->queue_last;
#line 2041
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2041
    endp->urb_list[(int )tmp & 7] = urb;
  } else {
    {
#line 2043
    tmp___0 = kmalloc(24UL, 32U);
#line 2043
    urbq = (struct u132_urbq *)tmp___0;
    }
#line 2045
    if ((unsigned long )urbq == (unsigned long )((struct u132_urbq *)0)) {
#line 2046
      endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2047
      return (-12);
    } else {
      {
#line 2049
      list_add_tail(& urbq->urb_more, & endp->urb_more);
#line 2050
      urbq->urb = urb;
      }
    }
  }
#line 2053
  return (0);
}
}
#line 2056 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int create_endpoint_and_queue_control(struct u132 *u132 , struct urb *urb ,
                                             struct usb_device *usb_dev , u8 usb_addr ,
                                             u8 usb_endp , gfp_t mem_flags ) 
{ 
  struct u132_ring *ring ;
  unsigned long irqs ;
  int rc ;
  u8 endp_number ;
  struct u132_endp *endp ;
  void *tmp ;
  struct lock_class_key __key ;
  struct usb_hcd *tmp___0 ;
  struct u132_endp *tmp___1 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  struct u132_ring *tmp___2 ;
  u8 address ;
  struct u132_udev *udev ;
  u16 tmp___3 ;
  u8 address___0 ;
  struct u132_udev *udev___0 ;
  u16 tmp___4 ;

  {
  {
#line 2065
  tmp = kmalloc(448UL, mem_flags);
#line 2065
  endp = (struct u132_endp *)tmp;
  }
#line 2067
  if ((unsigned long )endp == (unsigned long )((struct u132_endp *)0)) {
#line 2068
    return (-12);
  } else {

  }
  {
#line 2070
  spinlock_check(& endp->queue_lock.slock);
#line 2070
  __raw_spin_lock_init(& endp->queue_lock.slock.__annonCompField18.rlock, "&(&endp->queue_lock.slock)->rlock",
                       & __key);
#line 2071
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_225(& endp->queue_lock.slock);
#line 2072
  tmp___0 = u132_to_hcd(u132);
#line 2072
  rc = usb_hcd_link_urb_to_ep(tmp___0, urb);
  }
#line 2073
  if (rc != 0) {
    {
#line 2074
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2075
    kfree((void const   *)endp);
    }
#line 2076
    return (rc);
  } else {

  }
  {
#line 2079
  u132->num_endpoints = u132->num_endpoints + 1;
#line 2079
  endp_number = (u8 )u132->num_endpoints;
#line 2080
  tmp___1 = endp;
#line 2080
  u132->endp[(int )endp_number + -1] = tmp___1;
#line 2080
  (urb->ep)->hcpriv = (void *)tmp___1;
#line 2081
  __init_work(& endp->scheduler.work, 0);
#line 2081
  __constr_expr_0.counter = 137438953408L;
#line 2081
  endp->scheduler.work.data = __constr_expr_0;
#line 2081
  lockdep_init_map(& endp->scheduler.work.lockdep_map, "(&(&endp->scheduler)->work)",
                   & __key___0, 0);
#line 2081
  INIT_LIST_HEAD(& endp->scheduler.work.entry);
#line 2081
  endp->scheduler.work.func = & u132_hcd_endp_work_scheduler;
#line 2081
  init_timer_key(& endp->scheduler.timer, 2U, "(&(&endp->scheduler)->timer)", & __key___1);
#line 2081
  endp->scheduler.timer.function = & delayed_work_timer_fn;
#line 2081
  endp->scheduler.timer.data = (unsigned long )(& endp->scheduler);
#line 2082
  INIT_LIST_HEAD(& endp->urb_more);
#line 2083
  tmp___2 = (struct u132_ring *)(& u132->ring);
#line 2083
  endp->ring = tmp___2;
#line 2083
  ring = tmp___2;
  }
#line 2084
  if ((unsigned long )ring->curr_endp != (unsigned long )((struct u132_endp *)0)) {
    {
#line 2085
    list_add_tail(& endp->endp_ring, & (ring->curr_endp)->endp_ring);
    }
  } else {
    {
#line 2087
    INIT_LIST_HEAD(& endp->endp_ring);
#line 2088
    ring->curr_endp = endp;
    }
  }
  {
#line 2090
  ring->length = (unsigned char )((unsigned int )ring->length + 1U);
#line 2091
  endp->dequeueing = 0U;
#line 2092
  endp->edset_flush = 0U;
#line 2093
  endp->active = 0U;
#line 2094
  endp->delayed = 0U;
#line 2095
  endp->endp_number = endp_number;
#line 2096
  endp->u132 = u132;
#line 2097
  endp->hep = urb->ep;
#line 2098
  u132_endp_init_kref(u132, endp);
#line 2099
  u132_endp_get_kref(u132, endp);
  }
#line 2100
  if ((unsigned int )usb_addr == 0U) {
    {
#line 2101
    address = u132->addr[(int )usb_addr].address;
#line 2102
    udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 2103
    endp->udev_number = address;
#line 2104
    endp->usb_addr = usb_addr;
#line 2105
    endp->usb_endp = usb_endp;
#line 2106
    endp->input = 1U;
#line 2107
    endp->output = 1U;
#line 2108
    endp->pipetype = (unsigned char )(urb->pipe >> 30);
#line 2109
    u132_udev_init_kref(u132, udev);
#line 2110
    u132_udev_get_kref(u132, udev);
#line 2111
    udev->endp_number_in[(int )usb_endp] = endp_number;
#line 2112
    udev->endp_number_out[(int )usb_endp] = endp_number;
#line 2113
    urb->hcpriv = (void *)u132;
#line 2114
    endp->queue_size = 1U;
#line 2115
    endp->queue_last = 0U;
#line 2116
    endp->queue_next = 0U;
#line 2117
    tmp___3 = endp->queue_last;
#line 2117
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2117
    endp->urb_list[(int )tmp___3 & 7] = urb;
#line 2118
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2119
    u132_endp_queue_work(u132, endp, 0U);
    }
#line 2120
    return (0);
  } else {
    {
#line 2122
    address___0 = u132->addr[(int )usb_addr].address;
#line 2123
    udev___0 = (struct u132_udev *)(& u132->udev) + (unsigned long )address___0;
#line 2124
    endp->udev_number = address___0;
#line 2125
    endp->usb_addr = usb_addr;
#line 2126
    endp->usb_endp = usb_endp;
#line 2127
    endp->input = 1U;
#line 2128
    endp->output = 1U;
#line 2129
    endp->pipetype = (unsigned char )(urb->pipe >> 30);
#line 2130
    u132_udev_get_kref(u132, udev___0);
#line 2131
    udev___0->enumeration = 2U;
#line 2132
    udev___0->endp_number_in[(int )usb_endp] = endp_number;
#line 2133
    udev___0->endp_number_out[(int )usb_endp] = endp_number;
#line 2134
    urb->hcpriv = (void *)u132;
#line 2135
    endp->queue_size = 1U;
#line 2136
    endp->queue_last = 0U;
#line 2137
    endp->queue_next = 0U;
#line 2138
    tmp___4 = endp->queue_last;
#line 2138
    endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2138
    endp->urb_list[(int )tmp___4 & 7] = urb;
#line 2139
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2140
    u132_endp_queue_work(u132, endp, 0U);
    }
#line 2141
    return (0);
  }
}
}
#line 2145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int queue_control_on_old_endpoint(struct u132 *u132 , struct urb *urb , struct usb_device *usb_dev ,
                                         struct u132_endp *endp , u8 usb_addr , u8 usb_endp ) 
{ 
  u16 tmp ;
  struct u132_urbq *urbq ;
  void *tmp___0 ;
  u16 tmp___1 ;
  struct u132_addr *addr ;
  int I ;
  int i ;
  struct u132_udev *udev ;
  u8 tmp___2 ;
  u16 tmp___3 ;
  struct u132_urbq *urbq___0 ;
  void *tmp___4 ;
  u16 tmp___5 ;
  u8 address ;
  struct u132_udev *udev___0 ;
  u16 tmp___6 ;
  struct u132_urbq *urbq___1 ;
  void *tmp___7 ;
  u16 tmp___8 ;

  {
#line 2150
  if ((unsigned int )usb_addr == 0U) {
#line 2151
    if ((urb->pipe & 128U) != 0U) {
#line 2152
      urb->hcpriv = (void *)u132;
#line 2153
      tmp___1 = endp->queue_size;
#line 2153
      endp->queue_size = (u16 )((int )endp->queue_size + 1);
#line 2153
      if ((unsigned int )tmp___1 <= 7U) {
#line 2154
        tmp = endp->queue_last;
#line 2154
        endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2154
        endp->urb_list[(int )tmp & 7] = urb;
      } else {
        {
#line 2157
        tmp___0 = kmalloc(24UL, 32U);
#line 2157
        urbq = (struct u132_urbq *)tmp___0;
        }
#line 2160
        if ((unsigned long )urbq == (unsigned long )((struct u132_urbq *)0)) {
#line 2161
          endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2162
          return (-12);
        } else {
          {
#line 2164
          list_add_tail(& urbq->urb_more, & endp->urb_more);
#line 2166
          urbq->urb = urb;
          }
        }
      }
#line 2169
      return (0);
    } else {
#line 2171
      addr = (struct u132_addr *)(& u132->addr) + (unsigned long )usb_dev->devnum;
#line 2172
      I = 4;
#line 2173
      i = 0;
#line 2174
      goto ldv_31131;
      ldv_31133: 
#line 2175
      i = i + 1;
#line 2175
      udev = (struct u132_udev *)(& u132->udev) + (unsigned long )i;
#line 2176
      if ((unsigned long )udev->usb_device != (unsigned long )((struct usb_device *)0)) {

      } else {
        {
#line 2179
        udev->enumeration = 1U;
#line 2180
        u132->addr[0].address = (u8 )i;
#line 2181
        endp->udev_number = (u8 )i;
#line 2182
        udev->udev_number = (u8 )i;
#line 2183
        udev->usb_addr = (u8 )usb_dev->devnum;
#line 2184
        u132_udev_init_kref(u132, udev);
#line 2185
        udev->endp_number_in[(int )usb_endp] = endp->endp_number;
#line 2187
        u132_udev_get_kref(u132, udev);
#line 2188
        udev->endp_number_out[(int )usb_endp] = endp->endp_number;
#line 2190
        udev->usb_device = usb_dev;
#line 2191
        tmp___2 = (u8 )i;
#line 2191
        addr->address = tmp___2;
#line 2191
        *(urb->setup_packet + 2UL) = tmp___2;
#line 2193
        u132_udev_get_kref(u132, udev);
        }
#line 2194
        goto ldv_31132;
      }
      ldv_31131: 
#line 2174
      I = I - 1;
#line 2174
      if (I > 0) {
#line 2176
        goto ldv_31133;
      } else {

      }
      ldv_31132: ;
#line 2197
      if (I == 0) {
        {
#line 2198
        dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "run out of device space\n");
        }
#line 2200
        return (-22);
      } else {

      }
#line 2202
      urb->hcpriv = (void *)u132;
#line 2203
      tmp___5 = endp->queue_size;
#line 2203
      endp->queue_size = (u16 )((int )endp->queue_size + 1);
#line 2203
      if ((unsigned int )tmp___5 <= 7U) {
#line 2204
        tmp___3 = endp->queue_last;
#line 2204
        endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2204
        endp->urb_list[(int )tmp___3 & 7] = urb;
      } else {
        {
#line 2207
        tmp___4 = kmalloc(24UL, 32U);
#line 2207
        urbq___0 = (struct u132_urbq *)tmp___4;
        }
#line 2210
        if ((unsigned long )urbq___0 == (unsigned long )((struct u132_urbq *)0)) {
#line 2211
          endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2212
          return (-12);
        } else {
          {
#line 2214
          list_add_tail(& urbq___0->urb_more, & endp->urb_more);
#line 2216
          urbq___0->urb = urb;
          }
        }
      }
#line 2219
      return (0);
    }
  } else {
#line 2222
    address = u132->addr[(int )usb_addr].address;
#line 2223
    udev___0 = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 2224
    urb->hcpriv = (void *)u132;
#line 2225
    if ((unsigned int )udev___0->enumeration != 2U) {
#line 2226
      udev___0->enumeration = 2U;
    } else {

    }
#line 2227
    tmp___8 = endp->queue_size;
#line 2227
    endp->queue_size = (u16 )((int )endp->queue_size + 1);
#line 2227
    if ((unsigned int )tmp___8 <= 7U) {
#line 2228
      tmp___6 = endp->queue_last;
#line 2228
      endp->queue_last = (u16 )((int )endp->queue_last + 1);
#line 2228
      endp->urb_list[(int )tmp___6 & 7] = urb;
    } else {
      {
#line 2231
      tmp___7 = kmalloc(24UL, 32U);
#line 2231
      urbq___1 = (struct u132_urbq *)tmp___7;
      }
#line 2233
      if ((unsigned long )urbq___1 == (unsigned long )((struct u132_urbq *)0)) {
#line 2234
        endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2235
        return (-12);
      } else {
        {
#line 2237
        list_add_tail(& urbq___1->urb_more, & endp->urb_more);
#line 2238
        urbq___1->urb = urb;
        }
      }
    }
#line 2241
    return (0);
  }
}
}
#line 2245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_urb_enqueue(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  unsigned long _flags ;
  int tmp___0 ;
  u8 usb_addr ;
  u8 usb_endp ;
  struct usb_device *usb_dev ;
  u8 address ;
  struct u132_udev *udev ;
  struct u132_endp *endp ;
  unsigned long irqs ;
  int retval ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  u8 address___0 ;
  struct u132_udev *udev___0 ;
  struct u132_endp *endp___0 ;
  unsigned long irqs___0 ;
  int retval___0 ;
  int tmp___3 ;
  struct u132_endp *endp___1 ;
  u16 urb_size ;
  u8 *b ;
  int i ;
  char data[94U] ;
  char *d ;
  int m ;
  int l ;
  int w ;
  u8 *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u16 tmp___8 ;
  unsigned long irqs___1 ;
  int retval___1 ;
  int tmp___9 ;

  {
  {
#line 2248
  tmp = hcd_to_u132(hcd);
#line 2248
  u132 = tmp;
#line 2249
  _flags = arch_local_save_flags();
#line 2249
  tmp___0 = arch_irqs_disabled_flags(_flags);
  }
#line 2249
  if (tmp___0 != 0) {
#line 2250
    if ((mem_flags & 16U) != 0U) {
      {
#line 2251
      printk("\vinvalid context for function that might sleep\n");
      }
#line 2253
      return (-22);
    } else {

    }
  } else {

  }
#line 2256
  if (u132->going > 1) {
    {
#line 2257
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2259
    return (-19);
  } else
#line 2260
  if (u132->going > 0) {
    {
#line 2261
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed urb=%p\n",
            urb);
    }
#line 2263
    return (-108);
  } else {
#line 2265
    usb_addr = (unsigned int )((u8 )(urb->pipe >> 8)) & 127U;
#line 2266
    usb_endp = (unsigned int )((u8 )(urb->pipe >> 15)) & 15U;
#line 2267
    usb_dev = urb->dev;
#line 2268
    if (urb->pipe >> 30 == 1U) {
#line 2269
      address = u132->addr[(int )usb_addr].address;
#line 2270
      udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 2271
      endp = (struct u132_endp *)(urb->ep)->hcpriv;
#line 2272
      urb->actual_length = 0U;
#line 2273
      if ((unsigned long )endp != (unsigned long )((struct u132_endp *)0)) {
        {
#line 2276
        ldv___ldv_linux_kernel_locking_spinlock_spin_lock_229(& endp->queue_lock.slock);
#line 2278
        retval = usb_hcd_link_urb_to_ep(hcd, urb);
        }
#line 2279
        if (retval == 0) {
          {
#line 2280
          retval = queue_int_on_old_endpoint(u132, udev, urb, usb_dev, endp, (int )usb_addr,
                                             (int )usb_endp, (int )address);
          }
#line 2285
          if (retval != 0) {
            {
#line 2286
            usb_hcd_unlink_urb_from_ep(hcd, urb);
            }
          } else {

          }
        } else {

        }
        {
#line 2289
        ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
        }
#line 2291
        if (retval != 0) {
#line 2292
          return (retval);
        } else {
          {
#line 2294
          tmp___1 = msecs_to_jiffies((unsigned int const   )urb->interval);
#line 2294
          u132_endp_queue_work(u132, endp, (unsigned int )tmp___1);
          }
#line 2297
          return (0);
        }
      } else
#line 2299
      if (u132->num_endpoints == 100) {
#line 2300
        return (-22);
      } else {
        {
#line 2302
        tmp___2 = create_endpoint_and_queue_int(u132, udev, urb, usb_dev, (int )usb_addr,
                                                (int )usb_endp, (int )address, mem_flags);
        }
#line 2302
        return (tmp___2);
      }
    } else
#line 2306
    if (urb->pipe >> 30 == 0U) {
      {
#line 2307
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "the hardware does not support PIPE_ISOCHRONOUS\n");
      }
#line 2309
      return (-22);
    } else
#line 2310
    if (urb->pipe >> 30 == 3U) {
#line 2311
      address___0 = u132->addr[(int )usb_addr].address;
#line 2312
      udev___0 = (struct u132_udev *)(& u132->udev) + (unsigned long )address___0;
#line 2313
      endp___0 = (struct u132_endp *)(urb->ep)->hcpriv;
#line 2314
      urb->actual_length = 0U;
#line 2315
      if ((unsigned long )endp___0 != (unsigned long )((struct u132_endp *)0)) {
        {
#line 2318
        ldv___ldv_linux_kernel_locking_spinlock_spin_lock_231(& endp___0->queue_lock.slock);
#line 2320
        retval___0 = usb_hcd_link_urb_to_ep(hcd, urb);
        }
#line 2321
        if (retval___0 == 0) {
          {
#line 2322
          retval___0 = queue_bulk_on_old_endpoint(u132, udev___0, urb, usb_dev, endp___0,
                                                  (int )usb_addr, (int )usb_endp,
                                                  (int )address___0);
          }
#line 2327
          if (retval___0 != 0) {
            {
#line 2328
            usb_hcd_unlink_urb_from_ep(hcd, urb);
            }
          } else {

          }
        } else {

        }
        {
#line 2331
        ldv_spin_unlock_irqrestore_100(& endp___0->queue_lock.slock, irqs___0);
        }
#line 2333
        if (retval___0 != 0) {
#line 2334
          return (retval___0);
        } else {
          {
#line 2336
          u132_endp_queue_work(u132, endp___0, 0U);
          }
#line 2337
          return (0);
        }
      } else
#line 2339
      if (u132->num_endpoints == 100) {
#line 2340
        return (-22);
      } else {
        {
#line 2342
        tmp___3 = create_endpoint_and_queue_bulk(u132, udev___0, urb, usb_dev, (int )usb_addr,
                                                 (int )usb_endp, (int )address___0,
                                                 mem_flags);
        }
#line 2342
        return (tmp___3);
      }
    } else {
#line 2346
      endp___1 = (struct u132_endp *)(urb->ep)->hcpriv;
#line 2347
      urb_size = 8U;
#line 2348
      b = urb->setup_packet;
#line 2349
      i = 0;
#line 2351
      d = (char *)(& data);
#line 2352
      m = 31;
#line 2353
      l = 0;
#line 2354
      data[0] = 0;
#line 2355
      goto ldv_31176;
      ldv_31175: ;
#line 2356
      if (i > m) {

      } else {
#line 2357
        tmp___7 = i;
#line 2357
        i = i + 1;
#line 2357
        if (tmp___7 < m) {
          {
#line 2358
          tmp___4 = b;
#line 2358
          b = b + 1;
#line 2358
          tmp___5 = sprintf(d, " %02X", (int )*tmp___4);
#line 2358
          w = tmp___5;
#line 2359
          d = d + (unsigned long )w;
#line 2360
          l = l + w;
          }
        } else {
          {
#line 2362
          tmp___6 = sprintf(d, " ..");
#line 2362
          d = d + (unsigned long )tmp___6;
          }
        }
      }
      ldv_31176: 
#line 2355
      tmp___8 = urb_size;
#line 2355
      urb_size = (u16 )((int )urb_size - 1);
#line 2355
      if ((unsigned int )tmp___8 != 0U) {
#line 2357
        goto ldv_31175;
      } else {

      }

#line 2364
      if ((unsigned long )endp___1 != (unsigned long )((struct u132_endp *)0)) {
        {
#line 2367
        ldv___ldv_linux_kernel_locking_spinlock_spin_lock_233(& endp___1->queue_lock.slock);
#line 2369
        retval___1 = usb_hcd_link_urb_to_ep(hcd, urb);
        }
#line 2370
        if (retval___1 == 0) {
          {
#line 2371
          retval___1 = queue_control_on_old_endpoint(u132, urb, usb_dev, endp___1,
                                                     (int )usb_addr, (int )usb_endp);
          }
#line 2375
          if (retval___1 != 0) {
            {
#line 2376
            usb_hcd_unlink_urb_from_ep(hcd, urb);
            }
          } else {

          }
        } else {

        }
        {
#line 2379
        ldv_spin_unlock_irqrestore_100(& endp___1->queue_lock.slock, irqs___1);
        }
#line 2381
        if (retval___1 != 0) {
#line 2382
          return (retval___1);
        } else {
          {
#line 2384
          u132_endp_queue_work(u132, endp___1, 0U);
          }
#line 2385
          return (0);
        }
      } else
#line 2387
      if (u132->num_endpoints == 100) {
#line 2388
        return (-22);
      } else {
        {
#line 2390
        tmp___9 = create_endpoint_and_queue_control(u132, urb, usb_dev, (int )usb_addr,
                                                    (int )usb_endp, mem_flags);
        }
#line 2390
        return (tmp___9);
      }
    }
  }
}
}
#line 2397 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int dequeue_from_overflow_chain(struct u132 *u132 , struct u132_endp *endp ,
                                       struct urb *urb ) 
{ 
  struct list_head *scan ;
  struct list_head *head ;
  struct u132_urbq *urbq ;
  struct list_head  const  *__mptr ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
#line 2401
  head = & endp->urb_more;
#line 2402
  scan = head->next;
#line 2402
  goto ldv_31193;
  ldv_31192: 
#line 2403
  __mptr = (struct list_head  const  *)scan;
#line 2403
  urbq = (struct u132_urbq *)__mptr;
#line 2405
  if ((unsigned long )urbq->urb == (unsigned long )urb) {
    {
#line 2406
    tmp = u132_to_hcd(u132);
#line 2406
    hcd = tmp;
#line 2407
    list_del(scan);
#line 2408
    endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2409
    urb->error_count = 0;
#line 2410
    usb_hcd_giveback_urb(hcd, urb, 0);
    }
#line 2411
    return (0);
  } else {

  }
#line 2402
  scan = scan->next;
  ldv_31193: ;
#line 2402
  if ((unsigned long )scan != (unsigned long )head) {
#line 2404
    goto ldv_31192;
  } else {

  }
  {
#line 2415
  dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p not found in endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X\n",
          urb, (int )endp->endp_number, endp, (int )(endp->ring)->number, (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 73 : 32,
          (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 79 : 32, (int )endp->usb_endp,
          (int )endp->usb_addr, (int )endp->queue_size, (int )endp->queue_next, (int )endp->queue_last);
  }
#line 2421
  return (-22);
}
}
#line 2424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_endp_urb_dequeue(struct u132 *u132 , struct u132_endp *endp , struct urb *urb ,
                                 int status ) 
{ 
  unsigned long irqs ;
  int rc ;
  struct usb_hcd *tmp ;
  u16 queue_list ;
  u16 queue_size ;
  u16 queue_scan ;
  struct urb **urb_slot ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp___0 ;
  struct list_head *next ;
  struct u132_urbq *urbq ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  int retval ;
  struct usb_hcd *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2430
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_235(& endp->queue_lock.slock);
#line 2431
  tmp = u132_to_hcd(u132);
#line 2431
  rc = usb_hcd_check_unlink_urb(tmp, urb, status);
  }
#line 2432
  if (rc != 0) {
    {
#line 2433
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
    }
#line 2434
    return (rc);
  } else {

  }
#line 2436
  if ((unsigned int )endp->queue_size == 0U) {
    {
#line 2437
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p not found in endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n",
            urb, (int )endp->endp_number, endp, (int )(endp->ring)->number, (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 73 : 32,
            (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 79 : 32, (int )endp->usb_endp,
            (int )endp->usb_addr);
#line 2442
    ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
    }
#line 2443
    return (-22);
  } else {

  }
#line 2445
  if ((unsigned long )urb == (unsigned long )endp->urb_list[(int )endp->queue_next & 7]) {
#line 2446
    if ((unsigned int )*((unsigned char *)endp + 40UL) != 0U) {
      {
#line 2447
      endp->dequeueing = 1U;
#line 2448
      endp->edset_flush = 1U;
#line 2449
      u132_endp_queue_work(u132, endp, 0U);
#line 2450
      ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
      }
#line 2451
      return (0);
    } else {
      {
#line 2453
      ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2454
      u132_hcd_abandon_urb(u132, endp, urb, status);
      }
#line 2455
      return (0);
    }
  } else {
#line 2458
    queue_list = 0U;
#line 2459
    queue_size = endp->queue_size;
#line 2460
    queue_scan = endp->queue_next;
#line 2461
    urb_slot = (struct urb **)0;
#line 2462
    goto ldv_31208;
    ldv_31209: 
#line 2463
    queue_scan = (u16 )((int )queue_scan + 1);
#line 2463
    if ((unsigned long )urb == (unsigned long )endp->urb_list[(int )queue_scan & 7]) {
#line 2465
      urb_slot = (struct urb **)(& endp->urb_list) + ((unsigned long )queue_scan & 7UL);
#line 2467
      goto ldv_31207;
    } else {

    }
    ldv_31208: 
#line 2462
    queue_list = (u16 )((int )queue_list + 1);
#line 2462
    if ((unsigned int )queue_list <= 7U) {
#line 2462
      queue_size = (u16 )((int )queue_size - 1);
#line 2462
      if ((unsigned int )queue_size != 0U) {
#line 2464
        goto ldv_31209;
      } else {
#line 2467
        goto ldv_31207;
      }
    } else {

    }
    ldv_31207: ;
#line 2471
    goto ldv_31211;
    ldv_31210: 
#line 2472
    queue_scan = (u16 )((int )queue_scan + 1);
#line 2472
    *urb_slot = endp->urb_list[(int )queue_scan & 7];
#line 2474
    urb_slot = (struct urb **)(& endp->urb_list) + ((unsigned long )queue_scan & 7UL);
    ldv_31211: 
#line 2471
    queue_list = (u16 )((int )queue_list + 1);
#line 2471
    if ((unsigned int )queue_list <= 7U) {
#line 2471
      queue_size = (u16 )((int )queue_size - 1);
#line 2471
      if ((unsigned int )queue_size != 0U) {
#line 2473
        goto ldv_31210;
      } else {
#line 2476
        goto ldv_31212;
      }
    } else {

    }
    ldv_31212: ;
#line 2477
    if ((unsigned long )urb_slot != (unsigned long )((struct urb **)0)) {
      {
#line 2478
      tmp___0 = u132_to_hcd(u132);
#line 2478
      hcd = tmp___0;
#line 2480
      usb_hcd_unlink_urb_from_ep(hcd, urb);
#line 2481
      endp->queue_size = (unsigned int )endp->queue_size + 65535U;
#line 2482
      tmp___1 = list_empty((struct list_head  const  *)(& endp->urb_more));
      }
#line 2482
      if (tmp___1 != 0) {
        {
#line 2483
        ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
        }
      } else {
        {
#line 2486
        next = endp->urb_more.next;
#line 2487
        __mptr = (struct list_head  const  *)next;
#line 2487
        urbq = (struct u132_urbq *)__mptr;
#line 2489
        list_del(next);
#line 2490
        *urb_slot = urbq->urb;
#line 2491
        ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
#line 2493
        kfree((void const   *)urbq);
        }
      }
      {
#line 2494
      urb->error_count = 0;
#line 2495
      usb_hcd_giveback_urb(hcd, urb, status);
      }
#line 2496
      return (0);
    } else {
      {
#line 2497
      tmp___3 = list_empty((struct list_head  const  *)(& endp->urb_more));
      }
#line 2497
      if (tmp___3 != 0) {
        {
#line 2498
        dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "urb=%p not found in endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X\n",
                urb, (int )endp->endp_number, endp, (int )(endp->ring)->number, (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 73 : 32,
                (unsigned int )*((unsigned char *)endp + 40UL) != 0U ? 79 : 32, (int )endp->usb_endp,
                (int )endp->usb_addr, (int )endp->queue_size, (int )endp->queue_next,
                (int )endp->queue_last);
#line 2506
        ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
        }
#line 2507
        return (-22);
      } else {
        {
#line 2511
        tmp___2 = u132_to_hcd(u132);
#line 2511
        usb_hcd_unlink_urb_from_ep(tmp___2, urb);
#line 2512
        retval = dequeue_from_overflow_chain(u132, endp, urb);
#line 2514
        ldv_spin_unlock_irqrestore_100(& endp->queue_lock.slock, irqs);
        }
#line 2515
        return (retval);
      }
    }
  }
}
}
#line 2520 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_urb_dequeue(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  u8 usb_addr ;
  u8 usb_endp ;
  u8 address ;
  struct u132_udev *udev ;
  u8 endp_number ;
  struct u132_endp *endp ;
  int tmp___0 ;
  u8 endp_number___0 ;
  struct u132_endp *endp___0 ;
  int tmp___1 ;

  {
  {
#line 2522
  tmp = hcd_to_u132(hcd);
#line 2522
  u132 = tmp;
  }
#line 2523
  if (u132->going > 2) {
    {
#line 2524
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2526
    return (-19);
  } else {
#line 2528
    usb_addr = (unsigned int )((u8 )(urb->pipe >> 8)) & 127U;
#line 2529
    usb_endp = (unsigned int )((u8 )(urb->pipe >> 15)) & 15U;
#line 2530
    address = u132->addr[(int )usb_addr].address;
#line 2531
    udev = (struct u132_udev *)(& u132->udev) + (unsigned long )address;
#line 2532
    if ((urb->pipe & 128U) != 0U) {
      {
#line 2533
      endp_number = udev->endp_number_in[(int )usb_endp];
#line 2534
      endp = u132->endp[(int )endp_number + -1];
#line 2535
      tmp___0 = u132_endp_urb_dequeue(u132, endp, urb, status);
      }
#line 2535
      return (tmp___0);
    } else {
      {
#line 2537
      endp_number___0 = udev->endp_number_out[(int )usb_endp];
#line 2538
      endp___0 = u132->endp[(int )endp_number___0 + -1];
#line 2539
      tmp___1 = u132_endp_urb_dequeue(u132, endp___0, urb, status);
      }
#line 2539
      return (tmp___1);
    }
  }
}
}
#line 2544 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_endpoint_disable(struct usb_hcd *hcd , struct usb_host_endpoint *hep ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  struct u132_endp *endp ;

  {
  {
#line 2547
  tmp = hcd_to_u132(hcd);
#line 2547
  u132 = tmp;
  }
#line 2548
  if (u132->going > 2) {
    {
#line 2549
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "u132 device %p(hcd=%p hep=%p) has been removed %d\n",
            u132, hcd, hep, u132->going);
    }
  } else {
#line 2553
    endp = (struct u132_endp *)hep->hcpriv;
#line 2554
    if ((unsigned long )endp != (unsigned long )((struct u132_endp *)0)) {
      {
#line 2555
      u132_endp_put_kref(u132, endp);
      }
    } else {

    }
  }
#line 2557
  return;
}
}
#line 2559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_get_frame(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  int frame ;

  {
  {
#line 2561
  tmp = hcd_to_u132(hcd);
#line 2561
  u132 = tmp;
  }
#line 2562
  if (u132->going > 1) {
    {
#line 2563
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2565
    return (-19);
  } else
#line 2566
  if (u132->going > 0) {
    {
#line 2567
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 2568
    return (-108);
  } else {
    {
#line 2570
    frame = 0;
#line 2571
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "TODO: u132_get_frame\n");
#line 2572
    msleep(100U);
    }
#line 2573
    return (frame);
  }
}
}
#line 2577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_descriptor(struct u132 *u132 , struct usb_hub_descriptor *desc ) 
{ 
  int retval ;
  u16 temp ;
  u32 rh_a ;
  u32 rh_b ;

  {
  {
#line 2582
  rh_a = 4294967295U;
#line 2583
  rh_b = 4294967295U;
#line 2584
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 72, 0, & rh_a);
  }
#line 2585
  if (retval != 0) {
#line 2586
    return (retval);
  } else {

  }
#line 2587
  desc->bDescriptorType = 41U;
#line 2588
  desc->bPwrOn2PwrGood = (__u8 )(rh_a >> 24);
#line 2589
  desc->bHubContrCurrent = 0U;
#line 2590
  desc->bNbrPorts = (__u8 )u132->num_ports;
#line 2591
  temp = (unsigned int )((u16 )(u132->num_ports / 8)) + 1U;
#line 2592
  desc->bDescLength = (unsigned int )((__u8 )temp) * 2U + 7U;
#line 2593
  temp = 0U;
#line 2594
  if ((rh_a & 512U) != 0U) {
#line 2595
    temp = (u16 )((unsigned int )temp | 2U);
  } else {

  }
#line 2596
  if ((rh_a & 256U) != 0U) {
#line 2597
    temp = (u16 )((unsigned int )temp | 1U);
  } else {

  }
#line 2598
  if ((rh_a & 4096U) != 0U) {
#line 2599
    temp = (u16 )((unsigned int )temp | 16U);
  } else
#line 2600
  if ((rh_a & 2048U) != 0U) {
#line 2601
    temp = (u16 )((unsigned int )temp | 8U);
  } else {

  }
  {
#line 2602
  desc->wHubCharacteristics = temp;
#line 2603
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 76, 0, & rh_b);
  }
#line 2604
  if (retval != 0) {
#line 2605
    return (retval);
  } else {

  }
  {
#line 2606
  __memset((void *)(& desc->u.hs.DeviceRemovable), 255, 4UL);
#line 2608
  desc->u.hs.DeviceRemovable[0] = (__u8 )rh_b;
  }
#line 2609
  if (u132->num_ports > 7) {
#line 2610
    desc->u.hs.DeviceRemovable[1] = (__u8 )((rh_b & 65535U) >> 8);
#line 2611
    desc->u.hs.DeviceRemovable[2] = 255U;
  } else {
#line 2613
    desc->u.hs.DeviceRemovable[1] = 255U;
  }
#line 2614
  return (0);
}
}
#line 2617 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_status(struct u132 *u132 , __le32 *desc ) 
{ 
  u32 rh_status ;
  int ret_status ;
  int tmp ;

  {
  {
#line 2619
  rh_status = 4294967295U;
#line 2620
  tmp = usb_ftdi_elan_read_pcimem(u132->platform_dev, 80, 0, & rh_status);
#line 2620
  ret_status = tmp;
#line 2621
  *desc = rh_status;
  }
#line 2622
  return (ret_status);
}
}
#line 2625 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_portstatus(struct u132 *u132 , __le32 *desc , u16 wIndex ) 
{ 
  int port ;
  u32 rh_portstatus ;
  int ret_portstatus ;
  int tmp ;

  {
#line 2627
  if ((unsigned int )wIndex == 0U || (int )wIndex > u132->num_ports) {
#line 2628
    return (-22);
  } else {
    {
#line 2630
    port = (int )wIndex + -1;
#line 2631
    rh_portstatus = 4294967295U;
#line 2632
    tmp = usb_ftdi_elan_read_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port + 21UL) * 4U),
                                    0, & rh_portstatus);
#line 2632
    ret_portstatus = tmp;
#line 2634
    *desc = rh_portstatus;
    }
#line 2635
    if ((unsigned int )*((u16 *)desc + 2U) != 0U) {
      {
#line 2636
      _dev_info((struct device  const  *)(& (u132->platform_dev)->dev), "Port %d Status Change = %08X\n",
                port, *desc);
      }
    } else {

    }
#line 2639
    return (ret_portstatus);
  }
}
}
#line 2649 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_portreset(struct u132 *u132 , int port_index ) 
{ 
  int retval ;
  u32 fmnumber ;
  u16 now ;
  u16 reset_done ;
  u32 portstat ;

  {
  {
#line 2655
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 60, 0, & fmnumber);
  }
#line 2656
  if (retval != 0) {
#line 2657
    return (retval);
  } else {

  }
#line 2658
  now = (u16 )fmnumber;
#line 2659
  reset_done = (unsigned int )now + 10U;
  ldv_31279: ;
  ldv_31277: 
  {
#line 2663
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                     0, & portstat);
  }
#line 2665
  if (retval != 0) {
#line 2666
    return (retval);
  } else {

  }
#line 2667
  if ((portstat & 16U) != 0U) {
#line 2668
    goto ldv_31275;
  } else {
#line 2670
    goto ldv_31276;
  }
  ldv_31275: ;
#line 2671
  if ((int )((short )((int )now - (int )reset_done)) < 0) {
#line 2673
    goto ldv_31277;
  } else {

  }
  ldv_31276: ;
#line 2672
  if ((portstat & 16U) != 0U) {
#line 2673
    return (-19);
  } else {

  }
#line 2674
  if ((int )portstat & 1) {
#line 2675
    if ((portstat & 1048576U) != 0U) {
      {
#line 2676
      retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                          0, 1048576U);
      }
#line 2679
      if (retval != 0) {
#line 2680
        return (retval);
      } else {

      }
    } else {

    }
  } else {
#line 2683
    goto ldv_31278;
  }
  {
#line 2685
  retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                      0, 16U);
  }
#line 2687
  if (retval != 0) {
#line 2688
    return (retval);
  } else {

  }
  {
#line 2689
  msleep(10U);
#line 2690
  retval = usb_ftdi_elan_read_pcimem(u132->platform_dev, 60, 0, & fmnumber);
  }
#line 2691
  if (retval != 0) {
#line 2692
    return (retval);
  } else {

  }
#line 2693
  now = (u16 )fmnumber;
#line 2694
  if ((int )((short )((int )now - (int )reset_done)) < 0) {
#line 2696
    goto ldv_31279;
  } else {

  }
  ldv_31278: ;
#line 2695
  return (0);
}
}
#line 2698 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_setportfeature(struct u132 *u132 , u16 wValue , u16 wIndex ) 
{ 
  int retval ;
  int port_index ;
  struct u132_port *port ;

  {
#line 2701
  if ((unsigned int )wIndex == 0U || (int )wIndex > u132->num_ports) {
#line 2702
    return (-22);
  } else {
#line 2705
    port_index = (int )wIndex + -1;
#line 2706
    port = (struct u132_port *)(& u132->port) + (unsigned long )port_index;
#line 2707
    port->Status = port->Status & ~ (1 << (int )wValue);
    {
#line 2709
    if ((int )wValue == 2) {
#line 2709
      goto case_2;
    } else {

    }
#line 2715
    if ((int )wValue == 8) {
#line 2715
      goto case_8;
    } else {

    }
#line 2721
    if ((int )wValue == 4) {
#line 2721
      goto case_4;
    } else {

    }
#line 2726
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 2710
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                        0, 4U);
    }
#line 2712
    if (retval != 0) {
#line 2713
      return (retval);
    } else {

    }
#line 2714
    return (0);
    case_8: /* CIL Label */ 
    {
#line 2716
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                        0, 256U);
    }
#line 2718
    if (retval != 0) {
#line 2719
      return (retval);
    } else {

    }
#line 2720
    return (0);
    case_4: /* CIL Label */ 
    {
#line 2722
    retval = u132_roothub_portreset(u132, port_index);
    }
#line 2723
    if (retval != 0) {
#line 2724
      return (retval);
    } else {

    }
#line 2725
    return (0);
    switch_default: /* CIL Label */ ;
#line 2727
    return (-32);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 2732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_roothub_clearportfeature(struct u132 *u132 , u16 wValue , u16 wIndex ) 
{ 
  int port_index ;
  u32 temp ;
  int retval ;
  struct u132_port *port ;

  {
#line 2735
  if ((unsigned int )wIndex == 0U || (int )wIndex > u132->num_ports) {
#line 2736
    return (-22);
  } else {
#line 2738
    port_index = (int )wIndex + -1;
#line 2741
    port = (struct u132_port *)(& u132->port) + (unsigned long )port_index;
#line 2742
    port->Status = port->Status & ~ (1 << (int )wValue);
    {
#line 2744
    if ((int )wValue == 1) {
#line 2744
      goto case_1;
    } else {

    }
#line 2747
    if ((int )wValue == 17) {
#line 2747
      goto case_17;
    } else {

    }
#line 2750
    if ((int )wValue == 2) {
#line 2750
      goto case_2;
    } else {

    }
#line 2758
    if ((int )wValue == 18) {
#line 2758
      goto case_18;
    } else {

    }
#line 2761
    if ((int )wValue == 8) {
#line 2761
      goto case_8;
    } else {

    }
#line 2764
    if ((int )wValue == 16) {
#line 2764
      goto case_16;
    } else {

    }
#line 2767
    if ((int )wValue == 19) {
#line 2767
      goto case_19;
    } else {

    }
#line 2770
    if ((int )wValue == 20) {
#line 2770
      goto case_20;
    } else {

    }
#line 2773
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2745
    temp = 1U;
#line 2746
    goto ldv_31302;
    case_17: /* CIL Label */ 
#line 2748
    temp = 131072U;
#line 2749
    goto ldv_31302;
    case_2: /* CIL Label */ 
#line 2751
    temp = 8U;
#line 2752
    if ((u132->hc_control & 192U) != 128U) {
      {
#line 2754
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "TODO resume_root_hub\n");
      }
    } else {

    }
#line 2757
    goto ldv_31302;
    case_18: /* CIL Label */ 
#line 2759
    temp = 262144U;
#line 2760
    goto ldv_31302;
    case_8: /* CIL Label */ 
#line 2762
    temp = 512U;
#line 2763
    goto ldv_31302;
    case_16: /* CIL Label */ 
#line 2765
    temp = 65536U;
#line 2766
    goto ldv_31302;
    case_19: /* CIL Label */ 
#line 2768
    temp = 524288U;
#line 2769
    goto ldv_31302;
    case_20: /* CIL Label */ 
#line 2771
    temp = 1048576U;
#line 2772
    goto ldv_31302;
    switch_default: /* CIL Label */ ;
#line 2774
    return (-32);
    switch_break: /* CIL Label */ ;
    }
    ldv_31302: 
    {
#line 2776
    retval = usb_ftdi_elan_write_pcimem(u132->platform_dev, (int )((unsigned int )((unsigned long )port_index + 21UL) * 4U),
                                        0, temp);
    }
#line 2778
    if (retval != 0) {
#line 2779
      return (retval);
    } else {

    }
#line 2780
    return (0);
  }
}
}
#line 2786 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_hub_status_data(struct usb_hcd *hcd , char *buf ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  int i ;
  int changed ;
  int length ;

  {
  {
#line 2788
  tmp = hcd_to_u132(hcd);
#line 2788
  u132 = tmp;
  }
#line 2789
  if (u132->going > 1) {
    {
#line 2790
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device hcd=%p has been removed %d\n",
            hcd, u132->going);
    }
#line 2792
    return (-19);
  } else
#line 2793
  if (u132->going > 0) {
    {
#line 2794
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device hcd=%p is being removed\n",
            hcd);
    }
#line 2796
    return (-108);
  } else {
#line 2798
    changed = 0;
#line 2798
    length = 1;
#line 2799
    if (u132->flags & 1) {
#line 2800
      if ((u132->hc_roothub_a & 255U) > 15U) {
        {
#line 2801
        dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "bogus NDP, rereads as NDP=%d\n",
                u132->hc_roothub_a & 255U);
        }
#line 2804
        goto done;
      } else {

      }
    } else {

    }
#line 2807
    if ((u132->hc_roothub_status & 196608U) != 0U) {
#line 2808
      changed = 1;
#line 2808
      *buf = 1;
    } else {
#line 2810
      *buf = 0;
    }
#line 2811
    if (u132->num_ports > 7) {
#line 2812
      *(buf + 1UL) = 0;
#line 2813
      length = length + 1;
    } else {

    }
#line 2815
    i = 0;
#line 2815
    goto ldv_31322;
    ldv_31321: ;
#line 2816
    if ((u132->hc_roothub_portstatus[i] & 2031616U) != 0U) {
#line 2819
      changed = 1;
#line 2820
      if (i <= 6) {
#line 2821
        *buf = (int )*buf | (int )((char )(1 << (i + 1)));
      } else {
#line 2823
        *(buf + 1UL) = (int )*(buf + 1UL) | (int )((char )(1 << (i + -7)));
      }
#line 2824
      goto ldv_31320;
    } else {

    }
#line 2826
    if ((u132->hc_roothub_portstatus[i] & 1U) == 0U) {
#line 2827
      goto ldv_31320;
    } else {

    }
#line 2829
    if ((u132->hc_roothub_portstatus[i] & 4U) != 0U) {

    } else {

    }
    ldv_31320: 
#line 2815
    i = i + 1;
    ldv_31322: ;
#line 2815
    if (i < u132->num_ports) {
#line 2817
      goto ldv_31321;
    } else {

    }

    done: ;
#line 2833
    return (changed != 0 ? length : 0);
  }
}
}
#line 2837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_hub_control(struct usb_hcd *hcd , u16 typeReq , u16 wValue , u16 wIndex ,
                            char *buf , u16 wLength ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;
  int retval ;

  {
  {
#line 2840
  tmp = hcd_to_u132(hcd);
#line 2840
  u132 = tmp;
  }
#line 2841
  if (u132->going > 1) {
    {
#line 2842
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2844
    return (-19);
  } else
#line 2845
  if (u132->going > 0) {
    {
#line 2846
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 2847
    return (-108);
  } else {
    {
#line 2849
    retval = 0;
#line 2850
    ldv_mutex_lock_244(& u132->sw_lock);
    }
    {
#line 2852
    if ((int )typeReq == 8193) {
#line 2852
      goto case_8193;
    } else {

    }
#line 2861
    if ((int )typeReq == 8195) {
#line 2861
      goto case_8195;
    } else {

    }
#line 2870
    if ((int )typeReq == 8961) {
#line 2870
      goto case_8961;
    } else {

    }
#line 2877
    if ((int )typeReq == 40966) {
#line 2877
      goto case_40966;
    } else {

    }
#line 2884
    if ((int )typeReq == 40960) {
#line 2884
      goto case_40960;
    } else {

    }
#line 2891
    if ((int )typeReq == 41728) {
#line 2891
      goto case_41728;
    } else {

    }
#line 2898
    if ((int )typeReq == 8963) {
#line 2898
      goto case_8963;
    } else {

    }
#line 2905
    goto switch_default___1;
    case_8193: /* CIL Label */ ;
    {
#line 2854
    if ((int )wValue == 1) {
#line 2854
      goto case_1;
    } else {

    }
#line 2855
    if ((int )wValue == 0) {
#line 2855
      goto case_0;
    } else {

    }
#line 2857
    goto switch_default;
    case_1: /* CIL Label */ ;
    case_0: /* CIL Label */ ;
#line 2856
    goto ldv_31337;
    switch_default: /* CIL Label */ ;
#line 2858
    goto stall;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_31337: ;
#line 2860
    goto ldv_31340;
    case_8195: /* CIL Label */ ;
    {
#line 2863
    if ((int )wValue == 1) {
#line 2863
      goto case_1___0;
    } else {

    }
#line 2864
    if ((int )wValue == 0) {
#line 2864
      goto case_0___0;
    } else {

    }
#line 2866
    goto switch_default___0;
    case_1___0: /* CIL Label */ ;
    case_0___0: /* CIL Label */ ;
#line 2865
    goto ldv_31344;
    switch_default___0: /* CIL Label */ ;
#line 2867
    goto stall;
    switch_break___1: /* CIL Label */ ;
    }
    ldv_31344: ;
#line 2869
    goto ldv_31340;
    case_8961: /* CIL Label */ 
    {
#line 2871
    retval = u132_roothub_clearportfeature(u132, (int )wValue, (int )wIndex);
    }
#line 2873
    if (retval != 0) {
#line 2874
      goto error;
    } else {

    }
#line 2875
    goto ldv_31340;
    case_40966: /* CIL Label */ 
    {
#line 2878
    retval = u132_roothub_descriptor(u132, (struct usb_hub_descriptor *)buf);
    }
#line 2880
    if (retval != 0) {
#line 2881
      goto error;
    } else {

    }
#line 2882
    goto ldv_31340;
    case_40960: /* CIL Label */ 
    {
#line 2885
    retval = u132_roothub_status(u132, (__le32 *)buf);
    }
#line 2887
    if (retval != 0) {
#line 2888
      goto error;
    } else {

    }
#line 2889
    goto ldv_31340;
    case_41728: /* CIL Label */ 
    {
#line 2892
    retval = u132_roothub_portstatus(u132, (__le32 *)buf, (int )wIndex);
    }
#line 2894
    if (retval != 0) {
#line 2895
      goto error;
    } else {

    }
#line 2896
    goto ldv_31340;
    case_8963: /* CIL Label */ 
    {
#line 2899
    retval = u132_roothub_setportfeature(u132, (int )wValue, (int )wIndex);
    }
#line 2901
    if (retval != 0) {
#line 2902
      goto error;
    } else {

    }
#line 2903
    goto ldv_31340;
    switch_default___1: /* CIL Label */ ;
#line 2906
    goto stall;
    error: 
    {
#line 2908
    u132_disable(u132);
#line 2909
    u132->going = 1;
    }
#line 2910
    goto ldv_31340;
    stall: 
#line 2912
    retval = -32;
#line 2913
    goto ldv_31340;
    switch_break: /* CIL Label */ ;
    }
    ldv_31340: 
    {
#line 2915
    ldv_mutex_unlock_245(& u132->sw_lock);
    }
#line 2916
    return (retval);
  }
}
}
#line 2920 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_start_port_reset(struct usb_hcd *hcd , unsigned int port_num ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;

  {
  {
#line 2922
  tmp = hcd_to_u132(hcd);
#line 2922
  u132 = tmp;
  }
#line 2923
  if (u132->going > 1) {
    {
#line 2924
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2926
    return (-19);
  } else
#line 2927
  if (u132->going > 0) {
    {
#line 2928
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 2929
    return (-108);
  } else {
#line 2931
    return (0);
  }
}
}
#line 2936 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_bus_suspend(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;

  {
  {
#line 2938
  tmp = hcd_to_u132(hcd);
#line 2938
  u132 = tmp;
  }
#line 2939
  if (u132->going > 1) {
    {
#line 2940
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2942
    return (-19);
  } else
#line 2943
  if (u132->going > 0) {
    {
#line 2944
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 2945
    return (-108);
  } else {
#line 2947
    return (0);
  }
}
}
#line 2950 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_bus_resume(struct usb_hcd *hcd ) 
{ 
  struct u132 *u132 ;
  struct u132 *tmp ;

  {
  {
#line 2952
  tmp = hcd_to_u132(hcd);
#line 2952
  u132 = tmp;
  }
#line 2953
  if (u132->going > 1) {
    {
#line 2954
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 2956
    return (-19);
  } else
#line 2957
  if (u132->going > 0) {
    {
#line 2958
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 2959
    return (-108);
  } else {
#line 2961
    return (0);
  }
}
}
#line 2968 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static struct hc_driver u132_hc_driver  = 
#line 2968
     {(char const   *)(& hcd_name), 0, 3016UL, (irqreturn_t (*)(struct usb_hcd * ))0,
    17, & u132_hcd_reset, & u132_hcd_start, 0, 0, & u132_hcd_stop, 0, & u132_get_frame,
    & u132_urb_enqueue, & u132_urb_dequeue, 0, 0, & u132_endpoint_disable, 0, & u132_hub_status_data,
    & u132_hub_control, & u132_bus_suspend, & u132_bus_resume, & u132_start_port_reset,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2993 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_remove(struct platform_device *pdev ) 
{ 
  struct usb_hcd *hcd ;
  void *tmp ;
  struct u132 *u132 ;
  struct u132 *tmp___0 ;
  int rings ;
  int endps ;
  struct u132_ring *ring ;
  int tmp___1 ;
  struct u132_endp *endp ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2995
  tmp = platform_get_drvdata((struct platform_device  const  *)pdev);
#line 2995
  hcd = (struct usb_hcd *)tmp;
  }
#line 2996
  if ((unsigned long )hcd != (unsigned long )((struct usb_hcd *)0)) {
    {
#line 2997
    tmp___0 = hcd_to_u132(hcd);
#line 2997
    u132 = tmp___0;
#line 2998
    tmp___3 = u132->going;
#line 2998
    u132->going = u132->going + 1;
    }
#line 2998
    if (tmp___3 > 1) {
      {
#line 2999
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "already being removed\n");
      }
#line 3001
      return (-19);
    } else {
      {
#line 3003
      rings = 4;
#line 3004
      endps = 100;
#line 3005
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "removing device u132.%d\n",
              u132->sequence_num);
#line 3007
      msleep(100U);
#line 3008
      ldv_mutex_lock_246(& u132->sw_lock);
#line 3009
      u132_monitor_cancel_work(u132);
      }
#line 3010
      goto ldv_31376;
      ldv_31375: 
      {
#line 3011
      ring = (struct u132_ring *)(& u132->ring) + (unsigned long )rings;
#line 3012
      u132_ring_cancel_work(u132, ring);
      }
      ldv_31376: 
#line 3010
      tmp___1 = rings;
#line 3010
      rings = rings - 1;
#line 3010
      if (tmp___1 > 0) {
#line 3012
        goto ldv_31375;
      } else {

      }

#line 3013
      goto ldv_31380;
      ldv_31379: 
#line 3014
      endp = u132->endp[endps];
#line 3015
      if ((unsigned long )endp != (unsigned long )((struct u132_endp *)0)) {
        {
#line 3016
        u132_endp_cancel_work(u132, endp);
        }
      } else {

      }
      ldv_31380: 
#line 3013
      tmp___2 = endps;
#line 3013
      endps = endps - 1;
#line 3013
      if (tmp___2 > 0) {
#line 3015
        goto ldv_31379;
      } else {

      }
      {
#line 3018
      u132->going = u132->going + 1;
#line 3019
      printk("\016removing device u132.%d\n", u132->sequence_num);
#line 3021
      ldv_mutex_unlock_247(& u132->sw_lock);
#line 3022
      usb_remove_hcd(hcd);
#line 3023
      u132_u132_put_kref(u132);
      }
#line 3024
      return (0);
    }
  } else {
#line 3027
    return (0);
  }
}
}
#line 3030 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_initialise(struct u132 *u132 , struct platform_device *pdev ) 
{ 
  int rings ;
  int ports ;
  int addrs ;
  int udevs ;
  int endps ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct u132_ring *ring ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___2 ;
  int tmp___0 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___4 ;
  struct u132_port *port ;
  int tmp___1 ;
  struct u132_addr *addr ;
  int tmp___2 ;
  struct u132_udev *udev ;
  int i ;
  int o ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3032
  rings = 4;
#line 3033
  ports = 7;
#line 3034
  addrs = 128;
#line 3035
  udevs = 4;
#line 3036
  endps = 100;
#line 3037
  tmp = dev_get_platdata((struct device  const  *)(& pdev->dev));
#line 3037
  u132->board = (struct u132_platform_data *)tmp;
#line 3038
  u132->platform_dev = pdev;
#line 3039
  u132->power = 0;
#line 3040
  u132->reset = 0;
#line 3041
  __mutex_init(& u132->sw_lock, "&u132->sw_lock", & __key);
#line 3042
  __mutex_init(& u132->scheduler_lock, "&u132->scheduler_lock", & __key___0);
  }
#line 3043
  goto ldv_31398;
  ldv_31397: 
  {
#line 3044
  ring = (struct u132_ring *)(& u132->ring) + (unsigned long )rings;
#line 3045
  ring->u132 = u132;
#line 3046
  ring->number = (unsigned int )((u8 )rings) + 1U;
#line 3047
  ring->length = 0U;
#line 3048
  ring->curr_endp = (struct u132_endp *)0;
#line 3049
  __init_work(& ring->scheduler.work, 0);
#line 3049
  __constr_expr_0.counter = 137438953408L;
#line 3049
  ring->scheduler.work.data = __constr_expr_0;
#line 3049
  lockdep_init_map(& ring->scheduler.work.lockdep_map, "(&(&ring->scheduler)->work)",
                   & __key___1, 0);
#line 3049
  INIT_LIST_HEAD(& ring->scheduler.work.entry);
#line 3049
  ring->scheduler.work.func = & u132_hcd_ring_work_scheduler;
#line 3049
  init_timer_key(& ring->scheduler.timer, 2U, "(&(&ring->scheduler)->timer)", & __key___2);
#line 3049
  ring->scheduler.timer.function = & delayed_work_timer_fn;
#line 3049
  ring->scheduler.timer.data = (unsigned long )(& ring->scheduler);
  }
  ldv_31398: 
#line 3043
  tmp___0 = rings;
#line 3043
  rings = rings - 1;
#line 3043
  if (tmp___0 > 0) {
#line 3045
    goto ldv_31397;
  } else {

  }
  {
#line 3052
  ldv_mutex_lock_248(& u132->sw_lock);
#line 3053
  __init_work(& u132->monitor.work, 0);
#line 3053
  __constr_expr_1.counter = 137438953408L;
#line 3053
  u132->monitor.work.data = __constr_expr_1;
#line 3053
  lockdep_init_map(& u132->monitor.work.lockdep_map, "(&(&u132->monitor)->work)",
                   & __key___3, 0);
#line 3053
  INIT_LIST_HEAD(& u132->monitor.work.entry);
#line 3053
  u132->monitor.work.func = & u132_hcd_monitor_work;
#line 3053
  init_timer_key(& u132->monitor.timer, 2U, "(&(&u132->monitor)->timer)", & __key___4);
#line 3053
  u132->monitor.timer.function = & delayed_work_timer_fn;
#line 3053
  u132->monitor.timer.data = (unsigned long )(& u132->monitor);
  }
#line 3054
  goto ldv_31405;
  ldv_31404: 
#line 3055
  port = (struct u132_port *)(& u132->port) + (unsigned long )ports;
#line 3056
  port->u132 = u132;
#line 3057
  port->reset = 0;
#line 3058
  port->enable = 0;
#line 3059
  port->power = 0;
#line 3060
  port->Status = 0;
  ldv_31405: 
#line 3054
  tmp___1 = ports;
#line 3054
  ports = ports - 1;
#line 3054
  if (tmp___1 > 0) {
#line 3056
    goto ldv_31404;
  } else {

  }

#line 3062
  goto ldv_31409;
  ldv_31408: 
#line 3063
  addr = (struct u132_addr *)(& u132->addr) + (unsigned long )addrs;
#line 3064
  addr->address = 0U;
  ldv_31409: 
#line 3062
  tmp___2 = addrs;
#line 3062
  addrs = addrs - 1;
#line 3062
  if (tmp___2 > 0) {
#line 3064
    goto ldv_31408;
  } else {

  }

#line 3066
  goto ldv_31425;
  ldv_31424: 
#line 3067
  udev = (struct u132_udev *)(& u132->udev) + (unsigned long )udevs;
#line 3068
  i = 16;
#line 3069
  o = 16;
#line 3070
  udev->usb_device = (struct usb_device *)0;
#line 3071
  udev->udev_number = 0U;
#line 3072
  udev->usb_addr = 0U;
#line 3073
  udev->portnumber = 0U;
#line 3074
  goto ldv_31419;
  ldv_31418: 
#line 3075
  udev->endp_number_in[i] = 0U;
  ldv_31419: 
#line 3074
  tmp___3 = i;
#line 3074
  i = i - 1;
#line 3074
  if (tmp___3 > 0) {
#line 3076
    goto ldv_31418;
  } else {

  }

#line 3077
  goto ldv_31422;
  ldv_31421: 
#line 3078
  udev->endp_number_out[o] = 0U;
  ldv_31422: 
#line 3077
  tmp___4 = o;
#line 3077
  o = o - 1;
#line 3077
  if (tmp___4 > 0) {
#line 3079
    goto ldv_31421;
  } else {

  }

  ldv_31425: 
#line 3066
  tmp___5 = udevs;
#line 3066
  udevs = udevs - 1;
#line 3066
  if (tmp___5 > 0) {
#line 3068
    goto ldv_31424;
  } else {

  }

#line 3081
  goto ldv_31428;
  ldv_31427: 
#line 3082
  u132->endp[endps] = (struct u132_endp *)0;
  ldv_31428: 
#line 3081
  tmp___6 = endps;
#line 3081
  endps = endps - 1;
#line 3081
  if (tmp___6 > 0) {
#line 3083
    goto ldv_31427;
  } else {

  }
  {
#line 3084
  ldv_mutex_unlock_249(& u132->sw_lock);
  }
#line 3085
  return;
}
}
#line 3087 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_probe(struct platform_device *pdev ) 
{ 
  struct usb_hcd *hcd ;
  int retval ;
  u32 control ;
  u32 rh_a ;
  u32 num_ports ;
  char const   *tmp ;
  struct u132 *u132 ;
  struct u132 *tmp___0 ;

  {
  {
#line 3092
  rh_a = 4294967295U;
#line 3095
  msleep(100U);
  }
#line 3096
  if (u132_exiting > 0) {
#line 3097
    return (-19);
  } else {

  }
  {
#line 3099
  retval = usb_ftdi_elan_write_pcimem(pdev, 20, 0, 2147483648U);
  }
#line 3100
  if (retval != 0) {
#line 3101
    return (retval);
  } else {

  }
  {
#line 3102
  retval = usb_ftdi_elan_read_pcimem(pdev, 4, 0, & control);
  }
#line 3103
  if (retval != 0) {
#line 3104
    return (retval);
  } else {

  }
  {
#line 3105
  retval = usb_ftdi_elan_read_pcimem(pdev, 72, 0, & rh_a);
  }
#line 3106
  if (retval != 0) {
#line 3107
    return (retval);
  } else {

  }
#line 3108
  num_ports = rh_a & 255U;
#line 3109
  if ((unsigned long )pdev->dev.dma_mask != (unsigned long )((u64 *)0ULL)) {
#line 3110
    return (-22);
  } else {

  }
  {
#line 3112
  tmp = dev_name((struct device  const  *)(& pdev->dev));
#line 3112
  hcd = usb_create_hcd((struct hc_driver  const  *)(& u132_hc_driver), & pdev->dev,
                       tmp);
  }
#line 3113
  if ((unsigned long )hcd == (unsigned long )((struct usb_hcd *)0)) {
    {
#line 3114
    printk("\vfailed to create the usb hcd struct for U132\n");
#line 3116
    ftdi_elan_gone_away(pdev);
    }
#line 3117
    return (-12);
  } else {
    {
#line 3119
    tmp___0 = hcd_to_u132(hcd);
#line 3119
    u132 = tmp___0;
#line 3120
    retval = 0;
#line 3121
    hcd->rsrc_start = 0ULL;
#line 3122
    ldv_mutex_lock_250(& u132_module_lock);
#line 3123
    list_add_tail(& u132->u132_list, & u132_static_list);
#line 3124
    u132_instances = u132_instances + 1;
#line 3124
    u132->sequence_num = u132_instances;
#line 3125
    ldv_mutex_unlock_251(& u132_module_lock);
#line 3126
    u132_u132_init_kref(u132);
#line 3127
    u132_initialise(u132, pdev);
#line 3128
    hcd->product_desc = "ELAN U132 Host Controller";
#line 3129
    retval = usb_add_hcd(hcd, 0U, 0UL);
    }
#line 3130
    if (retval != 0) {
      {
#line 3131
      dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "init error %d\n",
              retval);
#line 3133
      u132_u132_put_kref(u132);
      }
#line 3134
      return (retval);
    } else {
      {
#line 3136
      device_wakeup_enable(hcd->self.controller);
#line 3137
      u132_monitor_queue_work(u132, 100U);
      }
#line 3138
      return (0);
    }
  }
}
}
#line 3149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_suspend(struct platform_device *pdev , pm_message_t state ) 
{ 
  struct usb_hcd *hcd ;
  void *tmp ;
  struct u132 *u132 ;
  struct u132 *tmp___0 ;
  int retval ;
  int ports ;
  int tmp___1 ;

  {
  {
#line 3151
  tmp = platform_get_drvdata((struct platform_device  const  *)pdev);
#line 3151
  hcd = (struct usb_hcd *)tmp;
#line 3152
  tmp___0 = hcd_to_u132(hcd);
#line 3152
  u132 = tmp___0;
  }
#line 3153
  if (u132->going > 1) {
    {
#line 3154
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 3156
    return (-19);
  } else
#line 3157
  if (u132->going > 0) {
    {
#line 3158
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 3159
    return (-108);
  } else {
#line 3161
    retval = 0;
    {
#line 3164
    if (state.event == 1) {
#line 3164
      goto case_1;
    } else {

    }
#line 3167
    if (state.event == 2) {
#line 3167
      goto case_2;
    } else {

    }
#line 3168
    if (state.event == 4) {
#line 3168
      goto case_4;
    } else {

    }
#line 3163
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3165
    retval = u132_bus_suspend(hcd);
    }
#line 3166
    goto ldv_31448;
    case_2: /* CIL Label */ ;
    case_4: /* CIL Label */ 
#line 3169
    ports = 7;
#line 3170
    goto ldv_31452;
    ldv_31451: 
    {
#line 3171
    port_power(u132, ports, 0);
    }
    ldv_31452: 
#line 3170
    tmp___1 = ports;
#line 3170
    ports = ports - 1;
#line 3170
    if (tmp___1 > 0) {
#line 3172
      goto ldv_31451;
    } else {

    }

#line 3173
    goto ldv_31448;
    switch_break: /* CIL Label */ ;
    }
    ldv_31448: ;
#line 3175
    return (retval);
  }
}
}
#line 3179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_resume(struct platform_device *pdev ) 
{ 
  struct usb_hcd *hcd ;
  void *tmp ;
  struct u132 *u132 ;
  struct u132 *tmp___0 ;
  int retval ;
  int ports ;
  int tmp___1 ;

  {
  {
#line 3181
  tmp = platform_get_drvdata((struct platform_device  const  *)pdev);
#line 3181
  hcd = (struct usb_hcd *)tmp;
#line 3182
  tmp___0 = hcd_to_u132(hcd);
#line 3182
  u132 = tmp___0;
  }
#line 3183
  if (u132->going > 1) {
    {
#line 3184
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device has been removed %d\n",
            u132->going);
    }
#line 3186
    return (-19);
  } else
#line 3187
  if (u132->going > 0) {
    {
#line 3188
    dev_err((struct device  const  *)(& (u132->platform_dev)->dev), "device is being removed\n");
    }
#line 3189
    return (-108);
  } else {
#line 3191
    retval = 0;
#line 3192
    if (u132->port[0].power == 0) {
#line 3193
      ports = 7;
#line 3194
      goto ldv_31462;
      ldv_31461: 
      {
#line 3195
      port_power(u132, ports, 1);
      }
      ldv_31462: 
#line 3194
      tmp___1 = ports;
#line 3194
      ports = ports - 1;
#line 3194
      if (tmp___1 > 0) {
#line 3196
        goto ldv_31461;
      } else {

      }
#line 3197
      retval = 0;
    } else {
      {
#line 3199
      retval = u132_bus_resume(hcd);
      }
    }
#line 3201
    return (retval);
  }
}
}
#line 3214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static struct platform_driver u132_platform_driver  = 
#line 3214
     {& u132_probe, & u132_remove, 0, & u132_suspend, & u132_resume, {(char const   *)(& hcd_name),
                                                                    0, 0, 0, (_Bool)0,
                                                                    0, 0, 0, 0, 0,
                                                                    0, 0, 0, 0, 0},
    0, (_Bool)0};
#line 3223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static int u132_hcd_init(void) 
{ 
  int retval ;
  struct lock_class_key __key ;
  int tmp ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___0 ;

  {
  {
#line 3226
  INIT_LIST_HEAD(& u132_static_list);
#line 3227
  u132_instances = 0;
#line 3228
  u132_exiting = 0;
#line 3229
  __mutex_init(& u132_module_lock, "&u132_module_lock", & __key);
#line 3230
  tmp = usb_disabled();
  }
#line 3230
  if (tmp != 0) {
#line 3231
    return (-19);
  } else {

  }
  {
#line 3232
  printk("\016driver %s\n", (char const   *)(& hcd_name));
#line 3233
  __lock_name = "\"%s\"\"u132\"";
#line 3233
  tmp___0 = __alloc_workqueue_key("%s", 131082U, 1, & __key___0, __lock_name, (char *)"u132");
#line 3233
  workqueue = tmp___0;
#line 3234
  retval = ldv___platform_driver_register_252(& u132_platform_driver, & __this_module);
  }
#line 3235
  return (retval);
}
}
#line 3240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/usb/host/u132-hcd.c"
static void u132_hcd_exit(void) 
{ 
  struct u132 *u132 ;
  struct u132 *temp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp ;

  {
  {
#line 3244
  ldv_mutex_lock_253(& u132_module_lock);
#line 3245
  u132_exiting = u132_exiting + 1;
#line 3246
  ldv_mutex_unlock_254(& u132_module_lock);
#line 3247
  __mptr = (struct list_head  const  *)u132_static_list.next;
#line 3247
  u132 = (struct u132 *)__mptr + 0xfffffffffffffff8UL;
#line 3247
  __mptr___0 = (struct list_head  const  *)u132->u132_list.next;
#line 3247
  temp = (struct u132 *)__mptr___0 + 0xfffffffffffffff8UL;
  }
#line 3247
  goto ldv_31490;
  ldv_31489: 
  {
#line 3248
  platform_device_unregister(u132->platform_dev);
#line 3247
  u132 = temp;
#line 3247
  __mptr___1 = (struct list_head  const  *)temp->u132_list.next;
#line 3247
  temp = (struct u132 *)__mptr___1 + 0xfffffffffffffff8UL;
  }
  ldv_31490: ;
#line 3247
  if ((unsigned long )(& u132->u132_list) != (unsigned long )(& u132_static_list)) {
#line 3249
    goto ldv_31489;
  } else {

  }
  {
#line 3250
  ldv_platform_driver_unregister_255(& u132_platform_driver);
#line 3251
  printk("\016u132-hcd driver deregistered\n");
#line 3252
  __might_sleep("drivers/usb/host/u132-hcd.c", 3252, 0);
  }
#line 3252
  if (u132_instances == 0) {
#line 3252
    goto ldv_31492;
  } else {

  }
  {
#line 3252
  __ret = 0L;
#line 3252
  INIT_LIST_HEAD(& __wait.task_list);
#line 3252
  __wait.flags = 0U;
  }
  ldv_31498: 
  {
#line 3252
  tmp = prepare_to_wait_event(& u132_hcd_wait, & __wait, 2);
#line 3252
  __int = tmp;
  }
#line 3252
  if (u132_instances == 0) {
#line 3252
    goto ldv_31497;
  } else {

  }
  {
#line 3252
  schedule();
  }
#line 3252
  goto ldv_31498;
  ldv_31497: 
  {
#line 3252
  finish_wait(& u132_hcd_wait, & __wait);
  }

  ldv_31492: 
  {
#line 3253
  flush_workqueue(workqueue);
#line 3254
  destroy_workqueue(workqueue);
  }
#line 3255
  return;
}
}
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_EMGentry_exit_u132_hcd_exit_7_2(void (*arg0)(void) ) ;
#line 602
int ldv_EMGentry_init_u132_hcd_init_7_11(int (*arg0)(void) ) ;
#line 603
int ldv___platform_driver_register(int arg0 , struct platform_driver *arg1 , struct module *arg2 ) ;
#line 604
void ldv_dispatch_deregister_6_1(struct platform_driver *arg0 ) ;
#line 605
void ldv_dispatch_deregister_dummy_factory_7_7_4(void) ;
#line 606
void ldv_dispatch_deregister_io_instance_5_7_5(void) ;
#line 607
void ldv_dispatch_instance_deregister_4_2(struct timer_list *arg0 ) ;
#line 608
void ldv_dispatch_instance_register_4_3(struct timer_list *arg0 ) ;
#line 609
void ldv_dispatch_pm_deregister_0_5(void) ;
#line 610
void ldv_dispatch_pm_register_0_6(void) ;
#line 611
void ldv_dispatch_register_5_2(struct platform_driver *arg0 ) ;
#line 612
void ldv_dispatch_register_dummy_factory_7_7_6(void) ;
#line 613
void ldv_dispatch_register_io_instance_5_7_7(void) ;
#line 614
void ldv_entry_EMGentry_7(void *arg0 ) ;
#line 615
void main(void) ;
#line 616
void ldv_io_instance_callback_2_17(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 617
void ldv_io_instance_callback_2_18(void (*arg0)(struct usb_hcd * , struct usb_host_endpoint * ) ,
                                   struct usb_hcd *arg1 , struct usb_host_endpoint *arg2 ) ;
#line 618
void ldv_io_instance_callback_2_19(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 619
void ldv_io_instance_callback_2_20(int (*arg0)(struct usb_hcd * , unsigned short  ,
                                               unsigned short  , unsigned short  ,
                                               char * , unsigned short  ) , struct usb_hcd *arg1 ,
                                   unsigned short arg2 , unsigned short arg3 , unsigned short arg4 ,
                                   char *arg5 , unsigned short arg6 ) ;
#line 620
void ldv_io_instance_callback_2_23(int (*arg0)(struct usb_hcd * , char * ) , struct usb_hcd *arg1 ,
                                   char *arg2 ) ;
#line 621
void ldv_io_instance_callback_2_26(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 622
void ldv_io_instance_callback_2_27(int (*arg0)(struct usb_hcd * , unsigned int  ) ,
                                   struct usb_hcd *arg1 , unsigned int arg2 ) ;
#line 623
void ldv_io_instance_callback_2_30(int (*arg0)(struct usb_hcd * , struct urb * , int  ) ,
                                   struct usb_hcd *arg1 , struct urb *arg2 , int arg3 ) ;
#line 624
void ldv_io_instance_callback_2_33(int (*arg0)(struct usb_hcd * , struct urb * , unsigned int  ) ,
                                   struct usb_hcd *arg1 , struct urb *arg2 , unsigned int arg3 ) ;
#line 625
void ldv_io_instance_callback_2_4(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 626
int ldv_io_instance_probe_2_11(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 627
void ldv_io_instance_release_2_2(void (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) ;
#line 628
void ldv_platform_driver_unregister(void *arg0 , struct platform_driver *arg1 ) ;
#line 629
void ldv_platform_instance_callback_0_20(int (*arg0)(struct platform_device * , struct pm_message  ) ,
                                         struct platform_device *arg1 , struct pm_message arg2 ) ;
#line 630
void ldv_platform_instance_callback_0_7(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) ;
#line 631
int ldv_platform_instance_probe_0_14(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) ;
#line 632
void ldv_platform_instance_release_0_3(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) ;
#line 633
void ldv_platform_platform_instance_0(void *arg0 ) ;
#line 634
void ldv_platform_pm_ops_instance_1(void *arg0 ) ;
#line 635
void ldv_pm_ops_instance_complete_1_3(void (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 636
void ldv_pm_ops_instance_freeze_1_15(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 637
void ldv_pm_ops_instance_freeze_late_1_14(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 638
void ldv_pm_ops_instance_freeze_noirq_1_12(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 639
void ldv_pm_ops_instance_poweroff_1_9(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 640
void ldv_pm_ops_instance_poweroff_late_1_8(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 641
void ldv_pm_ops_instance_poweroff_noirq_1_6(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 642
void ldv_pm_ops_instance_prepare_1_22(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 643
void ldv_pm_ops_instance_restore_1_4(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 644
void ldv_pm_ops_instance_restore_early_1_7(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 645
void ldv_pm_ops_instance_restore_noirq_1_5(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 646
void ldv_pm_ops_instance_resume_1_16(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 647
void ldv_pm_ops_instance_resume_early_1_17(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 648
void ldv_pm_ops_instance_resume_noirq_1_19(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 649
void ldv_pm_ops_instance_runtime_idle_1_27(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 650
void ldv_pm_ops_instance_runtime_resume_1_24(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 651
void ldv_pm_ops_instance_runtime_suspend_1_25(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 652
void ldv_pm_ops_instance_suspend_1_21(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 653
void ldv_pm_ops_instance_suspend_late_1_18(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 654
void ldv_pm_ops_instance_suspend_noirq_1_20(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 655
void ldv_pm_ops_instance_thaw_1_10(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 656
void ldv_pm_ops_instance_thaw_early_1_13(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 657
void ldv_pm_ops_instance_thaw_noirq_1_11(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 658
void ldv_struct_hc_driver_io_instance_2(void *arg0 ) ;
#line 659
void ldv_timer_dummy_factory_4(void *arg0 ) ;
#line 660
void ldv_timer_instance_callback_3_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 661
void ldv_timer_timer_instance_3(void *arg0 ) ;
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 668 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 669 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 675 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_EMGentry_exit_u132_hcd_exit_7_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 676
  u132_hcd_exit();
  }
#line 677
  return;
}
}
#line 680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
int ldv_EMGentry_init_u132_hcd_init_7_11(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 681
  tmp = u132_hcd_init();
  }
#line 681
  return (tmp);
}
}
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
int ldv___platform_driver_register(int arg0 , struct platform_driver *arg1 , struct module *arg2 ) 
{ 
  struct platform_driver *ldv_5_platform_driver_platform_driver ;
  int tmp ;

  {
  {
#line 692
  tmp = ldv_undef_int();
  }
#line 692
  if (tmp != 0) {
    {
#line 694
    ldv_assume(arg0 == 0);
#line 695
    ldv_5_platform_driver_platform_driver = arg1;
#line 699
    ldv_dispatch_register_5_2(ldv_5_platform_driver_platform_driver);
    }
#line 703
    return (arg0);
  } else {
    {
#line 707
    ldv_assume(arg0 != 0);
    }
#line 711
    return (arg0);
  }
#line 714
  return (arg0);
}
}
#line 719 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_deregister_6_1(struct platform_driver *arg0 ) 
{ 


  {
#line 723
  return;
}
}
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_deregister_dummy_factory_7_7_4(void) 
{ 


  {
#line 731
  return;
}
}
#line 735 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_deregister_io_instance_5_7_5(void) 
{ 


  {
#line 739
  return;
}
}
#line 743 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_instance_deregister_4_2(struct timer_list *arg0 ) 
{ 


  {
#line 747
  return;
}
}
#line 751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_instance_register_4_3(struct timer_list *arg0 ) 
{ 
  struct ldv_struct_timer_instance_3 *cf_arg_3 ;
  void *tmp ;

  {
  {
#line 754
  tmp = ldv_xmalloc(16UL);
#line 754
  cf_arg_3 = (struct ldv_struct_timer_instance_3 *)tmp;
#line 755
  cf_arg_3->arg0 = arg0;
#line 756
  ldv_timer_timer_instance_3((void *)cf_arg_3);
  }
#line 757
  return;
}
}
#line 761 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_pm_deregister_0_5(void) 
{ 


  {
#line 765
  return;
}
}
#line 769 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_pm_register_0_6(void) 
{ 
  struct ldv_struct_platform_instance_0 *cf_arg_1 ;
  void *tmp ;

  {
  {
#line 772
  tmp = ldv_xmalloc(16UL);
#line 772
  cf_arg_1 = (struct ldv_struct_platform_instance_0 *)tmp;
#line 773
  ldv_platform_pm_ops_instance_1((void *)cf_arg_1);
  }
#line 774
  return;
}
}
#line 778 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_register_5_2(struct platform_driver *arg0 ) 
{ 
  struct ldv_struct_platform_instance_0 *cf_arg_0 ;
  void *tmp ;

  {
  {
#line 781
  tmp = ldv_xmalloc(16UL);
#line 781
  cf_arg_0 = (struct ldv_struct_platform_instance_0 *)tmp;
#line 782
  cf_arg_0->arg0 = arg0;
#line 783
  ldv_platform_platform_instance_0((void *)cf_arg_0);
  }
#line 784
  return;
}
}
#line 788 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_register_dummy_factory_7_7_6(void) 
{ 
  struct ldv_struct_platform_instance_0 *cf_arg_4 ;
  void *tmp ;

  {
  {
#line 791
  tmp = ldv_xmalloc(16UL);
#line 791
  cf_arg_4 = (struct ldv_struct_platform_instance_0 *)tmp;
#line 792
  ldv_timer_dummy_factory_4((void *)cf_arg_4);
  }
#line 793
  return;
}
}
#line 797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_dispatch_register_io_instance_5_7_7(void) 
{ 
  struct ldv_struct_platform_instance_0 *cf_arg_2 ;
  void *tmp ;

  {
  {
#line 800
  tmp = ldv_xmalloc(16UL);
#line 800
  cf_arg_2 = (struct ldv_struct_platform_instance_0 *)tmp;
#line 801
  ldv_struct_hc_driver_io_instance_2((void *)cf_arg_2);
  }
#line 802
  return;
}
}
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_entry_EMGentry_7(void *arg0 ) 
{ 
  void (*ldv_7_exit_u132_hcd_exit_default)(void) ;
  int (*ldv_7_init_u132_hcd_init_default)(void) ;
  int ldv_7_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 815
  ldv_7_ret_default = ldv_EMGentry_init_u132_hcd_init_7_11(ldv_7_init_u132_hcd_init_default);
#line 817
  ldv_7_ret_default = ldv_ldv_post_init_256(ldv_7_ret_default);
#line 820
  tmp___0 = ldv_undef_int();
  }
#line 820
  if (tmp___0 != 0) {
    {
#line 822
    ldv_assume(ldv_7_ret_default != 0);
#line 826
    ldv_ldv_check_final_state_257();
#line 827
    ldv_stop();
    }
#line 831
    return;
  } else {
    {
#line 835
    ldv_assume(ldv_7_ret_default == 0);
#line 838
    tmp = ldv_undef_int();
    }
#line 838
    if (tmp != 0) {
      {
#line 840
      ldv_dispatch_register_io_instance_5_7_7();
#line 844
      ldv_dispatch_register_dummy_factory_7_7_6();
#line 848
      ldv_dispatch_deregister_io_instance_5_7_5();
#line 852
      ldv_dispatch_deregister_dummy_factory_7_7_4();
      }
    } else {

    }
    {
#line 863
    ldv_EMGentry_exit_u132_hcd_exit_7_2(ldv_7_exit_u132_hcd_exit_default);
#line 867
    ldv_ldv_check_final_state_258();
#line 868
    ldv_stop();
    }
#line 872
    return;
  }
#line 875
  return;
}
}
#line 880 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void main(void) 
{ 


  {
  {
#line 881
  ldv_ldv_initialize_259();
#line 882
  ldv_entry_EMGentry_7((void *)0);
  }
#line 883
  return;
}
}
#line 887 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_17(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 


  {
  {
#line 888
  u132_bus_suspend(arg1);
  }
#line 889
  return;
}
}
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_18(void (*arg0)(struct usb_hcd * , struct usb_host_endpoint * ) ,
                                   struct usb_hcd *arg1 , struct usb_host_endpoint *arg2 ) 
{ 


  {
  {
#line 893
  u132_endpoint_disable(arg1, arg2);
  }
#line 894
  return;
}
}
#line 897 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_19(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 


  {
  {
#line 898
  u132_get_frame(arg1);
  }
#line 899
  return;
}
}
#line 902 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_20(int (*arg0)(struct usb_hcd * , unsigned short  ,
                                               unsigned short  , unsigned short  ,
                                               char * , unsigned short  ) , struct usb_hcd *arg1 ,
                                   unsigned short arg2 , unsigned short arg3 , unsigned short arg4 ,
                                   char *arg5 , unsigned short arg6 ) 
{ 


  {
  {
#line 903
  u132_hub_control(arg1, (int )arg2, (int )arg3, (int )arg4, arg5, (int )arg6);
  }
#line 904
  return;
}
}
#line 907 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_23(int (*arg0)(struct usb_hcd * , char * ) , struct usb_hcd *arg1 ,
                                   char *arg2 ) 
{ 


  {
  {
#line 908
  u132_hub_status_data(arg1, arg2);
  }
#line 909
  return;
}
}
#line 912 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_26(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 


  {
  {
#line 913
  u132_hcd_reset(arg1);
  }
#line 914
  return;
}
}
#line 917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_27(int (*arg0)(struct usb_hcd * , unsigned int  ) ,
                                   struct usb_hcd *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 918
  u132_start_port_reset(arg1, arg2);
  }
#line 919
  return;
}
}
#line 922 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_30(int (*arg0)(struct usb_hcd * , struct urb * , int  ) ,
                                   struct usb_hcd *arg1 , struct urb *arg2 , int arg3 ) 
{ 


  {
  {
#line 923
  u132_urb_dequeue(arg1, arg2, arg3);
  }
#line 924
  return;
}
}
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_33(int (*arg0)(struct usb_hcd * , struct urb * , unsigned int  ) ,
                                   struct usb_hcd *arg1 , struct urb *arg2 , unsigned int arg3 ) 
{ 


  {
  {
#line 928
  u132_urb_enqueue(arg1, arg2, arg3);
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_callback_2_4(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 


  {
  {
#line 933
  u132_bus_resume(arg1);
  }
#line 934
  return;
}
}
#line 937 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
int ldv_io_instance_probe_2_11(int (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 938
  tmp = u132_hcd_start(arg1);
  }
#line 938
  return (tmp);
}
}
#line 942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_io_instance_release_2_2(void (*arg0)(struct usb_hcd * ) , struct usb_hcd *arg1 ) 
{ 


  {
  {
#line 943
  u132_hcd_stop(arg1);
  }
#line 944
  return;
}
}
#line 947 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_driver_unregister(void *arg0 , struct platform_driver *arg1 ) 
{ 
  struct platform_driver *ldv_6_platform_driver_platform_driver ;

  {
  {
#line 953
  ldv_6_platform_driver_platform_driver = arg1;
#line 957
  ldv_dispatch_deregister_6_1(ldv_6_platform_driver_platform_driver);
  }
#line 961
  return;
#line 963
  return;
}
}
#line 968 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_instance_callback_0_20(int (*arg0)(struct platform_device * , struct pm_message  ) ,
                                         struct platform_device *arg1 , struct pm_message arg2 ) 
{ 


  {
  {
#line 969
  u132_suspend(arg1, arg2);
  }
#line 970
  return;
}
}
#line 973 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_instance_callback_0_7(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) 
{ 


  {
  {
#line 974
  u132_resume(arg1);
  }
#line 975
  return;
}
}
#line 978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
int ldv_platform_instance_probe_0_14(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 979
  tmp = u132_probe(arg1);
  }
#line 979
  return (tmp);
}
}
#line 983 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_instance_release_0_3(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) 
{ 


  {
  {
#line 984
  u132_remove(arg1);
  }
#line 985
  return;
}
}
#line 988 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_platform_instance_0(void *arg0 ) 
{ 
  int (*ldv_0_callback_resume)(struct platform_device * ) ;
  int (*ldv_0_callback_suspend)(struct platform_device * , struct pm_message  ) ;
  struct platform_driver *ldv_0_container_platform_driver ;
  int ldv_0_probed_default ;
  struct platform_device *ldv_0_resource_platform_device ;
  struct pm_message ldv_0_resource_struct_pm_message ;
  struct ldv_struct_platform_instance_0 *data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 998
  data = (struct ldv_struct_platform_instance_0 *)arg0;
#line 1002
  ldv_0_probed_default = 1;
#line 1005
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_platform_instance_0 *)0)) {
    {
#line 1006
    ldv_0_container_platform_driver = data->arg0;
#line 1007
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1012
  tmp = ldv_xmalloc(1464UL);
#line 1012
  ldv_0_resource_platform_device = (struct platform_device *)tmp;
  }
#line 1019
  goto ldv_main_0;
#line 1021
  return;
  ldv_main_0: 
  {
#line 1027
  tmp___1 = ldv_undef_int();
  }
#line 1027
  if (tmp___1 != 0) {
    {
#line 1030
    ldv_ldv_pre_probe_260();
#line 1032
    ldv_0_probed_default = ldv_platform_instance_probe_0_14(ldv_0_container_platform_driver->probe,
                                                            ldv_0_resource_platform_device);
#line 1034
    ldv_0_probed_default = ldv_ldv_post_probe_261(ldv_0_probed_default);
#line 1037
    tmp___0 = ldv_undef_int();
    }
#line 1037
    if (tmp___0 != 0) {
      {
#line 1039
      ldv_assume(ldv_0_probed_default == 0);
      }
#line 1046
      goto ldv_call_0;
    } else {
      {
#line 1050
      ldv_assume(ldv_0_probed_default != 0);
      }
#line 1057
      goto ldv_main_0;
    }
  } else {
    {
#line 1062
    ldv_free((void *)ldv_0_resource_platform_device);
    }
#line 1070
    return;
  }
#line 1073
  return;
  ldv_call_0: 
  {
#line 1079
  tmp___2 = ldv_undef_int();
  }
  {
#line 1080
  if (tmp___2 == 1) {
#line 1080
    goto case_1;
  } else {

  }
#line 1093
  if (tmp___2 == 2) {
#line 1093
    goto case_2;
  } else {

  }
#line 1108
  if (tmp___2 == 3) {
#line 1108
    goto case_3;
  } else {

  }
#line 1128
  if (tmp___2 == 4) {
#line 1128
    goto case_4;
  } else {

  }
#line 1145
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1083
  ldv_platform_instance_callback_0_20(ldv_0_callback_suspend, ldv_0_resource_platform_device,
                                      ldv_0_resource_struct_pm_message);
  }
#line 1090
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 1096
  ldv_platform_instance_callback_0_7(ldv_0_callback_resume, ldv_0_resource_platform_device);
  }
#line 1103
  goto ldv_call_0;
#line 1105
  goto ldv_call_0;
  case_3: /* CIL Label */ 
  {
#line 1110
  ldv_dispatch_pm_register_0_6();
#line 1114
  ldv_dispatch_pm_deregister_0_5();
  }
#line 1121
  goto ldv_call_0;
#line 1123
  goto ldv_call_0;
#line 1125
  goto ldv_call_0;
  case_4: /* CIL Label */ 
  {
#line 1131
  ldv_platform_instance_release_0_3(ldv_0_container_platform_driver->remove, ldv_0_resource_platform_device);
#line 1135
  ldv_0_probed_default = 1;
  }
#line 1142
  goto ldv_main_0;
  switch_default: /* CIL Label */ 
  {
#line 1145
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1148
  return;
}
}
#line 1153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_platform_pm_ops_instance_1(void *arg0 ) 
{ 
  struct device *ldv_1_device_device ;
  struct dev_pm_ops *ldv_1_pm_ops_dev_pm_ops ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1166
  goto ldv_do_1;
#line 1168
  return;
  ldv_do_1: 
  {
#line 1174
  tmp = ldv_undef_int();
  }
  {
#line 1175
  if (tmp == 1) {
#line 1175
    goto case_1;
  } else {

  }
#line 1190
  if (tmp == 2) {
#line 1190
    goto case_2;
  } else {

  }
#line 1212
  if (tmp == 3) {
#line 1212
    goto case_3;
  } else {

  }
#line 1384
  if (tmp == 4) {
#line 1384
    goto case_4;
  } else {

  }
#line 1393
  goto switch_default___0;
  case_1: /* CIL Label */ ;
#line 1177
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->runtime_idle != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1179
    ldv_pm_ops_instance_runtime_idle_1_27(ldv_1_pm_ops_dev_pm_ops->runtime_idle, ldv_1_device_device);
    }
  } else {

  }
#line 1187
  goto ldv_do_1;
  case_2: /* CIL Label */ ;
#line 1192
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->runtime_suspend != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1194
    ldv_pm_ops_instance_runtime_suspend_1_25(ldv_1_pm_ops_dev_pm_ops->runtime_suspend,
                                             ldv_1_device_device);
    }
  } else {

  }
#line 1199
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->runtime_resume != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1201
    ldv_pm_ops_instance_runtime_resume_1_24(ldv_1_pm_ops_dev_pm_ops->runtime_resume,
                                            ldv_1_device_device);
    }
  } else {

  }
#line 1209
  goto ldv_do_1;
  case_3: /* CIL Label */ ;
#line 1214
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->prepare != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1216
    ldv_pm_ops_instance_prepare_1_22(ldv_1_pm_ops_dev_pm_ops->prepare, ldv_1_device_device);
    }
  } else {

  }
  {
#line 1220
  tmp___0 = ldv_undef_int();
  }
  {
#line 1221
  if (tmp___0 == 1) {
#line 1221
    goto case_1___0;
  } else {

  }
#line 1270
  if (tmp___0 == 2) {
#line 1270
    goto case_2___0;
  } else {

  }
#line 1319
  if (tmp___0 == 3) {
#line 1319
    goto case_3___0;
  } else {

  }
#line 1368
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 1223
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->suspend != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1225
    ldv_pm_ops_instance_suspend_1_21(ldv_1_pm_ops_dev_pm_ops->suspend, ldv_1_device_device);
    }
  } else {

  }
  {
#line 1229
  tmp___1 = ldv_undef_int();
  }
#line 1229
  if (tmp___1 != 0) {
#line 1231
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->suspend_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1233
      ldv_pm_ops_instance_suspend_noirq_1_20(ldv_1_pm_ops_dev_pm_ops->suspend_noirq,
                                             ldv_1_device_device);
      }
    } else {

    }
#line 1238
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->resume_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1240
      ldv_pm_ops_instance_resume_noirq_1_19(ldv_1_pm_ops_dev_pm_ops->resume_noirq,
                                            ldv_1_device_device);
      }
    } else {

    }
  } else {
#line 1247
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->suspend_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1249
      ldv_pm_ops_instance_suspend_late_1_18(ldv_1_pm_ops_dev_pm_ops->suspend_late,
                                            ldv_1_device_device);
      }
    } else {

    }
#line 1254
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->resume_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1256
      ldv_pm_ops_instance_resume_early_1_17(ldv_1_pm_ops_dev_pm_ops->resume_early,
                                            ldv_1_device_device);
      }
    } else {

    }
  }
#line 1262
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->resume != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1264
    ldv_pm_ops_instance_resume_1_16(ldv_1_pm_ops_dev_pm_ops->resume, ldv_1_device_device);
    }
  } else {

  }
#line 1268
  goto ldv_31961;
  case_2___0: /* CIL Label */ ;
#line 1272
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->freeze != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1274
    ldv_pm_ops_instance_freeze_1_15(ldv_1_pm_ops_dev_pm_ops->freeze, ldv_1_device_device);
    }
  } else {

  }
  {
#line 1278
  tmp___2 = ldv_undef_int();
  }
#line 1278
  if (tmp___2 != 0) {
#line 1280
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->freeze_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1282
      ldv_pm_ops_instance_freeze_late_1_14(ldv_1_pm_ops_dev_pm_ops->freeze_late, ldv_1_device_device);
      }
    } else {

    }
#line 1287
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->thaw_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1289
      ldv_pm_ops_instance_thaw_early_1_13(ldv_1_pm_ops_dev_pm_ops->thaw_early, ldv_1_device_device);
      }
    } else {

    }
  } else {
#line 1296
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->freeze_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1298
      ldv_pm_ops_instance_freeze_noirq_1_12(ldv_1_pm_ops_dev_pm_ops->freeze_noirq,
                                            ldv_1_device_device);
      }
    } else {

    }
#line 1303
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->thaw_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1305
      ldv_pm_ops_instance_thaw_noirq_1_11(ldv_1_pm_ops_dev_pm_ops->thaw_noirq, ldv_1_device_device);
      }
    } else {

    }
  }
#line 1311
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->thaw != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1313
    ldv_pm_ops_instance_thaw_1_10(ldv_1_pm_ops_dev_pm_ops->thaw, ldv_1_device_device);
    }
  } else {

  }
#line 1317
  goto ldv_31961;
  case_3___0: /* CIL Label */ ;
#line 1321
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->poweroff != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1323
    ldv_pm_ops_instance_poweroff_1_9(ldv_1_pm_ops_dev_pm_ops->poweroff, ldv_1_device_device);
    }
  } else {

  }
  {
#line 1327
  tmp___3 = ldv_undef_int();
  }
#line 1327
  if (tmp___3 != 0) {
#line 1329
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->poweroff_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1331
      ldv_pm_ops_instance_poweroff_late_1_8(ldv_1_pm_ops_dev_pm_ops->poweroff_late,
                                            ldv_1_device_device);
      }
    } else {

    }
#line 1336
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->restore_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1338
      ldv_pm_ops_instance_restore_early_1_7(ldv_1_pm_ops_dev_pm_ops->restore_early,
                                            ldv_1_device_device);
      }
    } else {

    }
  } else {
#line 1345
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->poweroff_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1347
      ldv_pm_ops_instance_poweroff_noirq_1_6(ldv_1_pm_ops_dev_pm_ops->poweroff_noirq,
                                             ldv_1_device_device);
      }
    } else {

    }
#line 1352
    if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->restore_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1354
      ldv_pm_ops_instance_restore_noirq_1_5(ldv_1_pm_ops_dev_pm_ops->restore_noirq,
                                            ldv_1_device_device);
      }
    } else {

    }
  }
#line 1360
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->restore != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1362
    ldv_pm_ops_instance_restore_1_4(ldv_1_pm_ops_dev_pm_ops->restore, ldv_1_device_device);
    }
  } else {

  }
#line 1366
  goto ldv_31961;
  switch_default: /* CIL Label */ 
  {
#line 1368
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_31961: ;
#line 1371
  if ((unsigned long )ldv_1_pm_ops_dev_pm_ops->complete != (unsigned long )((void (*)(struct device * ))0)) {
    {
#line 1373
    ldv_pm_ops_instance_complete_1_3(ldv_1_pm_ops_dev_pm_ops->complete, ldv_1_device_device);
    }
  } else {

  }
#line 1381
  goto ldv_do_1;
  case_4: /* CIL Label */ ;
#line 1390
  return;
  switch_default___0: /* CIL Label */ 
  {
#line 1393
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1396
  return;
}
}
#line 1401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_complete_1_3(void (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1402
  (*arg0)(arg1);
  }
#line 1403
  return;
}
}
#line 1406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_freeze_1_15(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1407
  (*arg0)(arg1);
  }
#line 1408
  return;
}
}
#line 1411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_freeze_late_1_14(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1412
  (*arg0)(arg1);
  }
#line 1413
  return;
}
}
#line 1416 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_freeze_noirq_1_12(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1417
  (*arg0)(arg1);
  }
#line 1418
  return;
}
}
#line 1421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_poweroff_1_9(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1422
  (*arg0)(arg1);
  }
#line 1423
  return;
}
}
#line 1426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_poweroff_late_1_8(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1427
  (*arg0)(arg1);
  }
#line 1428
  return;
}
}
#line 1431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_poweroff_noirq_1_6(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1432
  (*arg0)(arg1);
  }
#line 1433
  return;
}
}
#line 1436 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_prepare_1_22(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1437
  (*arg0)(arg1);
  }
#line 1438
  return;
}
}
#line 1441 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_restore_1_4(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1442
  (*arg0)(arg1);
  }
#line 1443
  return;
}
}
#line 1446 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_restore_early_1_7(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1447
  (*arg0)(arg1);
  }
#line 1448
  return;
}
}
#line 1451 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_restore_noirq_1_5(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1452
  (*arg0)(arg1);
  }
#line 1453
  return;
}
}
#line 1456 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_resume_1_16(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1457
  (*arg0)(arg1);
  }
#line 1458
  return;
}
}
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_resume_early_1_17(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1462
  (*arg0)(arg1);
  }
#line 1463
  return;
}
}
#line 1466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_resume_noirq_1_19(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1467
  (*arg0)(arg1);
  }
#line 1468
  return;
}
}
#line 1471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_runtime_idle_1_27(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1472
  (*arg0)(arg1);
  }
#line 1473
  return;
}
}
#line 1476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_runtime_resume_1_24(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1477
  (*arg0)(arg1);
  }
#line 1478
  return;
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_runtime_suspend_1_25(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1482
  (*arg0)(arg1);
  }
#line 1483
  return;
}
}
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_suspend_1_21(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1487
  (*arg0)(arg1);
  }
#line 1488
  return;
}
}
#line 1491 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_suspend_late_1_18(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1492
  (*arg0)(arg1);
  }
#line 1493
  return;
}
}
#line 1496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_suspend_noirq_1_20(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1497
  (*arg0)(arg1);
  }
#line 1498
  return;
}
}
#line 1501 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_thaw_1_10(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1502
  (*arg0)(arg1);
  }
#line 1503
  return;
}
}
#line 1506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_thaw_early_1_13(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1507
  (*arg0)(arg1);
  }
#line 1508
  return;
}
}
#line 1511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_pm_ops_instance_thaw_noirq_1_11(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1512
  (*arg0)(arg1);
  }
#line 1513
  return;
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_struct_hc_driver_io_instance_2(void *arg0 ) 
{ 
  int (*ldv_2_callback_bus_resume)(struct usb_hcd * ) ;
  int (*ldv_2_callback_bus_suspend)(struct usb_hcd * ) ;
  void (*ldv_2_callback_endpoint_disable)(struct usb_hcd * , struct usb_host_endpoint * ) ;
  int (*ldv_2_callback_get_frame_number)(struct usb_hcd * ) ;
  int (*ldv_2_callback_hub_control)(struct usb_hcd * , unsigned short  , unsigned short  ,
                                    unsigned short  , char * , unsigned short  ) ;
  int (*ldv_2_callback_hub_status_data)(struct usb_hcd * , char * ) ;
  int (*ldv_2_callback_reset)(struct usb_hcd * ) ;
  int (*ldv_2_callback_start_port_reset)(struct usb_hcd * , unsigned int  ) ;
  int (*ldv_2_callback_urb_dequeue)(struct usb_hcd * , struct urb * , int  ) ;
  int (*ldv_2_callback_urb_enqueue)(struct usb_hcd * , struct urb * , unsigned int  ) ;
  struct hc_driver *ldv_2_container_struct_hc_driver ;
  unsigned short ldv_2_ldv_param_20_1_default ;
  unsigned short ldv_2_ldv_param_20_2_default ;
  unsigned short ldv_2_ldv_param_20_3_default ;
  char *ldv_2_ldv_param_20_4_default ;
  unsigned short ldv_2_ldv_param_20_5_default ;
  char *ldv_2_ldv_param_23_1_default ;
  unsigned int ldv_2_ldv_param_27_1_default ;
  int ldv_2_ldv_param_30_2_default ;
  unsigned int ldv_2_ldv_param_33_2_default ;
  struct urb *ldv_2_resource_struct_urb_ptr ;
  struct usb_hcd *ldv_2_resource_struct_usb_hcd_ptr ;
  struct usb_host_endpoint *ldv_2_resource_struct_usb_host_endpoint_ptr ;
  int ldv_2_ret_default ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1545
  ldv_2_ret_default = 1;
#line 1550
  tmp = ldv_xmalloc(192UL);
#line 1550
  ldv_2_resource_struct_urb_ptr = (struct urb *)tmp;
#line 1551
  tmp___0 = ldv_xmalloc(968UL);
#line 1551
  ldv_2_resource_struct_usb_hcd_ptr = (struct usb_hcd *)tmp___0;
#line 1552
  tmp___1 = ldv_xmalloc(72UL);
#line 1552
  ldv_2_resource_struct_usb_host_endpoint_ptr = (struct usb_host_endpoint *)tmp___1;
  }
#line 1559
  goto ldv_main_2;
#line 1561
  return;
  ldv_main_2: 
  {
#line 1567
  tmp___3 = ldv_undef_int();
  }
#line 1567
  if (tmp___3 != 0) {
    {
#line 1570
    ldv_2_ret_default = ldv_io_instance_probe_2_11(ldv_2_container_struct_hc_driver->start,
                                                   ldv_2_resource_struct_usb_hcd_ptr);
#line 1572
    ldv_2_ret_default = ldv_filter_err_code(ldv_2_ret_default);
#line 1575
    tmp___2 = ldv_undef_int();
    }
#line 1575
    if (tmp___2 != 0) {
      {
#line 1577
      ldv_assume(ldv_2_ret_default == 0);
      }
#line 1584
      goto ldv_call_2;
    } else {
      {
#line 1588
      ldv_assume(ldv_2_ret_default != 0);
      }
#line 1595
      goto ldv_main_2;
    }
  } else {
    {
#line 1600
    ldv_free((void *)ldv_2_resource_struct_urb_ptr);
#line 1601
    ldv_free((void *)ldv_2_resource_struct_usb_hcd_ptr);
#line 1602
    ldv_free((void *)ldv_2_resource_struct_usb_host_endpoint_ptr);
    }
#line 1610
    return;
  }
#line 1613
  return;
  ldv_call_2: 
  {
#line 1619
  tmp___4 = ldv_undef_int();
  }
  {
#line 1620
  if (tmp___4 == 1) {
#line 1620
    goto case_1;
  } else {

  }
#line 1639
  if (tmp___4 == 2) {
#line 1639
    goto case_2;
  } else {

  }
#line 1660
  if (tmp___4 == 3) {
#line 1660
    goto case_3;
  } else {

  }
#line 1683
  if (tmp___4 == 4) {
#line 1683
    goto case_4;
  } else {

  }
#line 1702
  if (tmp___4 == 5) {
#line 1702
    goto case_5;
  } else {

  }
#line 1731
  if (tmp___4 == 6) {
#line 1731
    goto case_6;
  } else {

  }
#line 1762
  if (tmp___4 == 7) {
#line 1762
    goto case_7;
  } else {

  }
#line 1787
  if (tmp___4 == 8) {
#line 1787
    goto case_8;
  } else {

  }
#line 1814
  if (tmp___4 == 9) {
#line 1814
    goto case_9;
  } else {

  }
#line 1843
  if (tmp___4 == 10) {
#line 1843
    goto case_10;
  } else {

  }
#line 1874
  if (tmp___4 == 11) {
#line 1874
    goto case_11;
  } else {

  }
#line 1887
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1626
  ldv_io_instance_callback_2_33(ldv_2_callback_urb_enqueue, ldv_2_resource_struct_usb_hcd_ptr,
                                ldv_2_resource_struct_urb_ptr, ldv_2_ldv_param_33_2_default);
  }
#line 1636
  goto ldv_call_2;
  case_2: /* CIL Label */ 
  {
#line 1645
  ldv_io_instance_callback_2_30(ldv_2_callback_urb_dequeue, ldv_2_resource_struct_usb_hcd_ptr,
                                ldv_2_resource_struct_urb_ptr, ldv_2_ldv_param_30_2_default);
  }
#line 1655
  goto ldv_call_2;
#line 1657
  goto ldv_call_2;
  case_3: /* CIL Label */ 
  {
#line 1666
  ldv_io_instance_callback_2_27(ldv_2_callback_start_port_reset, ldv_2_resource_struct_usb_hcd_ptr,
                                ldv_2_ldv_param_27_1_default);
  }
#line 1676
  goto ldv_call_2;
#line 1678
  goto ldv_call_2;
#line 1680
  goto ldv_call_2;
  case_4: /* CIL Label */ 
  {
#line 1686
  ldv_io_instance_callback_2_26(ldv_2_callback_reset, ldv_2_resource_struct_usb_hcd_ptr);
  }
#line 1693
  goto ldv_call_2;
#line 1695
  goto ldv_call_2;
#line 1697
  goto ldv_call_2;
#line 1699
  goto ldv_call_2;
  case_5: /* CIL Label */ 
  {
#line 1704
  tmp___5 = ldv_xmalloc(1UL);
#line 1704
  ldv_2_ldv_param_23_1_default = (char *)tmp___5;
#line 1709
  ldv_io_instance_callback_2_23(ldv_2_callback_hub_status_data, ldv_2_resource_struct_usb_hcd_ptr,
                                ldv_2_ldv_param_23_1_default);
#line 1713
  ldv_free((void *)ldv_2_ldv_param_23_1_default);
  }
#line 1720
  goto ldv_call_2;
#line 1722
  goto ldv_call_2;
#line 1724
  goto ldv_call_2;
#line 1726
  goto ldv_call_2;
#line 1728
  goto ldv_call_2;
  case_6: /* CIL Label */ 
  {
#line 1733
  tmp___6 = ldv_xmalloc(1UL);
#line 1733
  ldv_2_ldv_param_20_4_default = (char *)tmp___6;
#line 1738
  ldv_io_instance_callback_2_20(ldv_2_callback_hub_control, ldv_2_resource_struct_usb_hcd_ptr,
                                (int )ldv_2_ldv_param_20_1_default, (int )ldv_2_ldv_param_20_2_default,
                                (int )ldv_2_ldv_param_20_3_default, ldv_2_ldv_param_20_4_default,
                                (int )ldv_2_ldv_param_20_5_default);
#line 1742
  ldv_free((void *)ldv_2_ldv_param_20_4_default);
  }
#line 1749
  goto ldv_call_2;
#line 1751
  goto ldv_call_2;
#line 1753
  goto ldv_call_2;
#line 1755
  goto ldv_call_2;
#line 1757
  goto ldv_call_2;
#line 1759
  goto ldv_call_2;
  case_7: /* CIL Label */ 
  {
#line 1765
  ldv_io_instance_callback_2_19(ldv_2_callback_get_frame_number, ldv_2_resource_struct_usb_hcd_ptr);
  }
#line 1772
  goto ldv_call_2;
#line 1774
  goto ldv_call_2;
#line 1776
  goto ldv_call_2;
#line 1778
  goto ldv_call_2;
#line 1780
  goto ldv_call_2;
#line 1782
  goto ldv_call_2;
#line 1784
  goto ldv_call_2;
  case_8: /* CIL Label */ 
  {
#line 1790
  ldv_io_instance_callback_2_18(ldv_2_callback_endpoint_disable, ldv_2_resource_struct_usb_hcd_ptr,
                                ldv_2_resource_struct_usb_host_endpoint_ptr);
  }
#line 1797
  goto ldv_call_2;
#line 1799
  goto ldv_call_2;
#line 1801
  goto ldv_call_2;
#line 1803
  goto ldv_call_2;
#line 1805
  goto ldv_call_2;
#line 1807
  goto ldv_call_2;
#line 1809
  goto ldv_call_2;
#line 1811
  goto ldv_call_2;
  case_9: /* CIL Label */ 
  {
#line 1817
  ldv_io_instance_callback_2_17(ldv_2_callback_bus_suspend, ldv_2_resource_struct_usb_hcd_ptr);
  }
#line 1824
  goto ldv_call_2;
#line 1826
  goto ldv_call_2;
#line 1828
  goto ldv_call_2;
#line 1830
  goto ldv_call_2;
#line 1832
  goto ldv_call_2;
#line 1834
  goto ldv_call_2;
#line 1836
  goto ldv_call_2;
#line 1838
  goto ldv_call_2;
#line 1840
  goto ldv_call_2;
  case_10: /* CIL Label */ 
  {
#line 1846
  ldv_io_instance_callback_2_4(ldv_2_callback_bus_resume, ldv_2_resource_struct_usb_hcd_ptr);
  }
#line 1853
  goto ldv_call_2;
#line 1855
  goto ldv_call_2;
#line 1857
  goto ldv_call_2;
#line 1859
  goto ldv_call_2;
#line 1861
  goto ldv_call_2;
#line 1863
  goto ldv_call_2;
#line 1865
  goto ldv_call_2;
#line 1867
  goto ldv_call_2;
#line 1869
  goto ldv_call_2;
#line 1871
  goto ldv_call_2;
  case_11: /* CIL Label */ 
  {
#line 1877
  ldv_io_instance_release_2_2(ldv_2_container_struct_hc_driver->stop, ldv_2_resource_struct_usb_hcd_ptr);
  }
#line 1884
  goto ldv_main_2;
  switch_default: /* CIL Label */ 
  {
#line 1887
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1890
  return;
}
}
#line 1895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_timer_dummy_factory_4(void *arg0 ) 
{ 
  struct timer_list *ldv_4_container_timer_list ;

  {
  {
#line 1904
  ldv_dispatch_instance_register_4_3(ldv_4_container_timer_list);
#line 1908
  ldv_dispatch_instance_deregister_4_2(ldv_4_container_timer_list);
  }
#line 1916
  return;
#line 1918
  return;
}
}
#line 1923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_timer_instance_callback_3_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 1924
  (*arg0)(arg1);
  }
#line 1925
  return;
}
}
#line 1928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
void ldv_timer_timer_instance_3(void *arg0 ) 
{ 
  struct timer_list *ldv_3_container_timer_list ;
  struct ldv_struct_timer_instance_3 *data ;

  {
#line 1933
  data = (struct ldv_struct_timer_instance_3 *)arg0;
#line 1938
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_timer_instance_3 *)0)) {
    {
#line 1939
    ldv_3_container_timer_list = data->arg0;
#line 1940
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1946
  ldv_switch_to_interrupt_context();
  }
#line 1947
  if ((unsigned long )ldv_3_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 1949
    ldv_timer_instance_callback_3_2(ldv_3_container_timer_list->function, ldv_3_container_timer_list->data);
    }
  } else {

  }
  {
#line 1952
  ldv_switch_to_process_context();
  }
#line 1960
  return;
#line 1962
  return;
}
}
#line 2027 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 2030
  tmp = ldv_linux_usb_dev_atomic_sub_and_test(i, v);
  }
#line 2030
  return (tmp);
}
}
#line 2063 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 2066
  tmp = ldv_linux_usb_dev_atomic_add_return(i, v);
  }
#line 2066
  return (tmp);
}
}
#line 2462 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 2466
  ldv_check_alloc_flags(flags);
#line 2467
  res = ldv_malloc_unknown_size();
#line 2468
  ldv_after_alloc(res);
  }
#line 2469
  return (res);
}
}
#line 2641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2645
  ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(ldv_func_arg1);
  }
#line 2646
  return;
}
}
#line 2648 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2652
  ldv_linux_kernel_locking_mutex_mutex_unlock_u132_module_lock(ldv_func_arg1);
  }
#line 2653
  return;
}
}
#line 2655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2659
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 2660
  return;
}
}
#line 2662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2666
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 2667
  return;
}
}
#line 2669 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2673
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 2674
  return;
}
}
#line 2676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 2679
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 2681
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 2682
  return;
}
}
#line 2684 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
__inline static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 2687
  ldv_linux_kernel_locking_spinlock_spin_unlock_slock_of_u132_spin();
#line 2689
  spin_unlock_irqrestore(lock, flags);
  }
#line 2690
  return;
}
}
#line 2700 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2704
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2705
  return;
}
}
#line 2707 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2711
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2712
  return;
}
}
#line 2714 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_104(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 2717
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 2719
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 2720
  return;
}
}
#line 2738 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2742
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2743
  return;
}
}
#line 2745 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2749
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2750
  return;
}
}
#line 2752 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2756
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2757
  return;
}
}
#line 2759 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2763
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2764
  return;
}
}
#line 2766 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2770
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2771
  return;
}
}
#line 2773 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2777
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2778
  return;
}
}
#line 2780 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2784
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2785
  return;
}
}
#line 2787 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2791
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2792
  return;
}
}
#line 2794 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2798
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2799
  return;
}
}
#line 2801 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2805
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2806
  return;
}
}
#line 2808 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2812
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2813
  return;
}
}
#line 2815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2819
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2820
  return;
}
}
#line 2822 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2826
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2827
  return;
}
}
#line 2829 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2833
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2834
  return;
}
}
#line 2836 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2840
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2841
  return;
}
}
#line 2843 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2847
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2848
  return;
}
}
#line 2850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2854
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2855
  return;
}
}
#line 2857 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2861
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2862
  return;
}
}
#line 2864 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2868
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2869
  return;
}
}
#line 2871 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2875
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2876
  return;
}
}
#line 2878 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_127(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2882
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2883
  return;
}
}
#line 2885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2889
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2890
  return;
}
}
#line 2892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2896
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2897
  return;
}
}
#line 2899 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2903
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2904
  return;
}
}
#line 2906 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2910
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2911
  return;
}
}
#line 2913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2917
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2918
  return;
}
}
#line 2920 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2924
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2925
  return;
}
}
#line 2927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2931
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2932
  return;
}
}
#line 2934 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2938
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2939
  return;
}
}
#line 2941 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2945
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2946
  return;
}
}
#line 2948 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2952
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2953
  return;
}
}
#line 2955 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2959
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2960
  return;
}
}
#line 2962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2966
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2967
  return;
}
}
#line 2969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2973
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2974
  return;
}
}
#line 2976 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2980
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2981
  return;
}
}
#line 2983 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2987
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2988
  return;
}
}
#line 2990 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2994
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 2995
  return;
}
}
#line 2997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3001
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3002
  return;
}
}
#line 3004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3008
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3009
  return;
}
}
#line 3011 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3015
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3016
  return;
}
}
#line 3018 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3022
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3023
  return;
}
}
#line 3025 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3029
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3030
  return;
}
}
#line 3032 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3036
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3037
  return;
}
}
#line 3039 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3043
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3044
  return;
}
}
#line 3046 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3050
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3051
  return;
}
}
#line 3053 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3057
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3058
  return;
}
}
#line 3060 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3064
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3065
  return;
}
}
#line 3067 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3071
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3072
  return;
}
}
#line 3074 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3078
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3079
  return;
}
}
#line 3081 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3085
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3086
  return;
}
}
#line 3088 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3092
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3093
  return;
}
}
#line 3095 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3099
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3100
  return;
}
}
#line 3102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3106
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3107
  return;
}
}
#line 3109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3113
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3114
  return;
}
}
#line 3116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3120
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3121
  return;
}
}
#line 3123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3127
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3128
  return;
}
}
#line 3130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3134
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3135
  return;
}
}
#line 3137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3141
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3142
  return;
}
}
#line 3144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_165(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3148
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3149
  return;
}
}
#line 3151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3155
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3156
  return;
}
}
#line 3158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_167(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3162
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3163
  return;
}
}
#line 3165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_168(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3169
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3170
  return;
}
}
#line 3172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3176
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3177
  return;
}
}
#line 3179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3183
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3184
  return;
}
}
#line 3186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3190
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3191
  return;
}
}
#line 3193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3197
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3198
  return;
}
}
#line 3200 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3204
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3205
  return;
}
}
#line 3207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3211
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3212
  return;
}
}
#line 3214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3218
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3219
  return;
}
}
#line 3221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3225
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3226
  return;
}
}
#line 3228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_177(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3232
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3233
  return;
}
}
#line 3235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3239
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3240
  return;
}
}
#line 3242 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3246
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3247
  return;
}
}
#line 3249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3253
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3254
  return;
}
}
#line 3256 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3260
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3261
  return;
}
}
#line 3263 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3267
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3268
  return;
}
}
#line 3270 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3274
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3275
  return;
}
}
#line 3277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3281
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3282
  return;
}
}
#line 3284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3288
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3289
  return;
}
}
#line 3291 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3295
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3296
  return;
}
}
#line 3298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_187(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3302
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3303
  return;
}
}
#line 3305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3309
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3310
  return;
}
}
#line 3312 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3316
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3317
  return;
}
}
#line 3319 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3323
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3324
  return;
}
}
#line 3326 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3330
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3331
  return;
}
}
#line 3333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3337
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3338
  return;
}
}
#line 3340 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3344
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3345
  return;
}
}
#line 3347 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_194(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3351
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3352
  return;
}
}
#line 3354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_195(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3358
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3359
  return;
}
}
#line 3361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3365
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3366
  return;
}
}
#line 3368 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3372
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3373
  return;
}
}
#line 3375 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3379
  ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3380
  return;
}
}
#line 3382 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3386
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3387
  return;
}
}
#line 3389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_200(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3393
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3394
  return;
}
}
#line 3396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3400
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3401
  return;
}
}
#line 3403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3407
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3408
  return;
}
}
#line 3410 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3414
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3415
  return;
}
}
#line 3417 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3421
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3422
  return;
}
}
#line 3424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3428
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3429
  return;
}
}
#line 3431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3435
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3436
  return;
}
}
#line 3438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3442
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3443
  return;
}
}
#line 3445 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3449
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3450
  return;
}
}
#line 3452 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3456
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3457
  return;
}
}
#line 3459 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3463
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3464
  return;
}
}
#line 3466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3470
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3471
  return;
}
}
#line 3473 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3477
  ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(ldv_func_arg1);
  }
#line 3478
  return;
}
}
#line 3480 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_213(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3484
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3485
  return;
}
}
#line 3487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3491
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3492
  return;
}
}
#line 3494 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_215(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3498
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3499
  return;
}
}
#line 3501 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3505
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3506
  return;
}
}
#line 3508 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_217(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3512
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3513
  return;
}
}
#line 3515 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_218(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3519
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3520
  return;
}
}
#line 3522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_219(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3525
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3527
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3528
  return;
}
}
#line 3546 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_222(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3549
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3551
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3552
  return;
}
}
#line 3570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_225(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3573
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3575
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3576
  return;
}
}
#line 3602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_229(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3605
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3607
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3608
  return;
}
}
#line 3618 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_231(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3621
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3623
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3624
  return;
}
}
#line 3634 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_233(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3637
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3639
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3640
  return;
}
}
#line 3650 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_235(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 3653
  ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin();
#line 3655
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 3656
  return;
}
}
#line 3722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3726
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3727
  return;
}
}
#line 3729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_245(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3733
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3734
  return;
}
}
#line 3736 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_246(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3740
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3741
  return;
}
}
#line 3743 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3747
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3748
  return;
}
}
#line 3750 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3754
  ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3755
  return;
}
}
#line 3757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3761
  ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(ldv_func_arg1);
  }
#line 3762
  return;
}
}
#line 3764 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3768
  ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(ldv_func_arg1);
  }
#line 3769
  return;
}
}
#line 3771 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3775
  ldv_linux_kernel_locking_mutex_mutex_unlock_u132_module_lock(ldv_func_arg1);
  }
#line 3776
  return;
}
}
#line 3778 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static int ldv___platform_driver_register_252(struct platform_driver *ldv_func_arg1 ,
                                              struct module *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3782
  tmp = __platform_driver_register(ldv_func_arg1, ldv_func_arg2);
#line 3782
  ldv_func_res = tmp;
#line 3785
  tmp___0 = ldv___platform_driver_register(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 3785
  return (tmp___0);
#line 3787
  return (ldv_func_res);
}
}
#line 3790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_lock_253(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3794
  ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(ldv_func_arg1);
  }
#line 3795
  return;
}
}
#line 3797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3801
  ldv_linux_kernel_locking_mutex_mutex_unlock_u132_module_lock(ldv_func_arg1);
  }
#line 3802
  return;
}
}
#line 3804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_platform_driver_unregister_255(struct platform_driver *ldv_func_arg1 ) 
{ 


  {
  {
#line 3807
  platform_driver_unregister(ldv_func_arg1);
#line 3810
  ldv_platform_driver_unregister((void *)0, ldv_func_arg1);
  }
#line 3811
  return;
}
}
#line 3813 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static int ldv_ldv_post_init_256(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3817
  ldv_linux_net_register_reset_error_counter();
#line 3821
  ldv_linux_usb_register_reset_error_counter();
#line 3824
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 3824
  return (tmp);
}
}
#line 3827 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_ldv_check_final_state_257(void) 
{ 


  {
  {
#line 3831
  ldv_linux_arch_io_check_final_state();
#line 3835
  ldv_linux_block_genhd_check_final_state();
#line 3839
  ldv_linux_block_queue_check_final_state();
#line 3843
  ldv_linux_block_request_check_final_state();
#line 3847
  ldv_linux_drivers_base_class_check_final_state();
#line 3855
  ldv_linux_fs_char_dev_check_final_state();
#line 3859
  ldv_linux_fs_sysfs_check_final_state();
#line 3863
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 3867
  ldv_linux_kernel_module_check_final_state();
#line 3871
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 3875
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 3879
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 3883
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 3887
  ldv_linux_lib_idr_check_final_state();
#line 3891
  ldv_linux_mmc_sdio_func_check_final_state();
#line 3895
  ldv_linux_net_rtnetlink_check_final_state();
#line 3899
  ldv_linux_net_sock_check_final_state();
#line 3903
  ldv_linux_usb_coherent_check_final_state();
#line 3907
  ldv_linux_usb_gadget_check_final_state();
#line 3911
  ldv_linux_usb_urb_check_final_state();
  }
#line 3912
  return;
}
}
#line 3915 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_ldv_check_final_state_258(void) 
{ 


  {
  {
#line 3919
  ldv_linux_arch_io_check_final_state();
#line 3923
  ldv_linux_block_genhd_check_final_state();
#line 3927
  ldv_linux_block_queue_check_final_state();
#line 3931
  ldv_linux_block_request_check_final_state();
#line 3935
  ldv_linux_drivers_base_class_check_final_state();
#line 3943
  ldv_linux_fs_char_dev_check_final_state();
#line 3947
  ldv_linux_fs_sysfs_check_final_state();
#line 3951
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 3955
  ldv_linux_kernel_module_check_final_state();
#line 3959
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 3963
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 3967
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 3971
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 3975
  ldv_linux_lib_idr_check_final_state();
#line 3979
  ldv_linux_mmc_sdio_func_check_final_state();
#line 3983
  ldv_linux_net_rtnetlink_check_final_state();
#line 3987
  ldv_linux_net_sock_check_final_state();
#line 3991
  ldv_linux_usb_coherent_check_final_state();
#line 3995
  ldv_linux_usb_gadget_check_final_state();
#line 3999
  ldv_linux_usb_urb_check_final_state();
  }
#line 4000
  return;
}
}
#line 4003 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_ldv_initialize_259(void) 
{ 


  {
  {
#line 4007
  ldv_linux_lib_find_bit_initialize();
  }
#line 4008
  return;
}
}
#line 4011 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static void ldv_ldv_pre_probe_260(void) 
{ 


  {
  {
#line 4015
  ldv_linux_net_register_reset_error_counter();
#line 4019
  ldv_linux_usb_register_reset_error_counter();
#line 4022
  ldv_pre_probe();
  }
#line 4023
  return;
}
}
#line 4025 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/weaver/.tmp_u132-hcd.c.aux"
static int ldv_ldv_post_probe_261(int retval ) 
{ 
  int tmp ;

  {
  {
#line 4029
  ldv_linux_net_register_check_return_value_probe(retval);
#line 4033
  ldv_linux_usb_register_check_return_value_probe(retval);
#line 4036
  tmp = ldv_post_probe(retval);
  }
#line 4036
  return (tmp);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132  ;
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(struct mutex *lock ) 
{ 


  {
  {
#line 312
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132);
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132 = 1;
  }
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_scheduler_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132);
#line 323
  tmp = ldv_undef_int();
  }
#line 323
  if (tmp != 0) {
#line 325
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132 = 1;
#line 327
    return (0);
  } else {
#line 331
    return (-4);
  }
}
}
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_scheduler_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132) {
#line 341
    return (1);
  } else {
    {
#line 344
    tmp = ldv_undef_int();
    }
#line 344
    if (tmp != 0) {
#line 346
      return (1);
    } else {
#line 350
      return (0);
    }
  }
}
}
#line 355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_scheduler_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 358
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132);
#line 361
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_scheduler_lock_of_u132(lock);
  }
#line 361
  if (tmp != 0) {
#line 363
    return (0);
  } else {
#line 367
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132 = 1;
#line 369
    return (1);
  }
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_scheduler_lock_of_u132(atomic_t *cnt ,
                                                                                    struct mutex *lock ) 
{ 


  {
#line 377
  cnt->counter = cnt->counter - 1;
#line 380
  if (cnt->counter != 0) {
#line 382
    return (0);
  } else {
    {
#line 385
    ldv_linux_kernel_locking_mutex_mutex_lock_scheduler_lock_of_u132(lock);
    }
#line 387
    return (1);
  }
}
}
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_scheduler_lock_of_u132(struct mutex *lock ) 
{ 


  {
  {
#line 395
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132);
#line 397
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132 = 0;
  }
#line 398
  return;
}
}
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132  ;
#line 402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(struct mutex *lock ) 
{ 


  {
  {
#line 405
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132);
#line 407
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132 = 1;
  }
#line 408
  return;
}
}
#line 411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_sw_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 414
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132);
#line 416
  tmp = ldv_undef_int();
  }
#line 416
  if (tmp != 0) {
#line 418
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132 = 1;
#line 420
    return (0);
  } else {
#line 424
    return (-4);
  }
}
}
#line 429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_sw_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 432
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132) {
#line 434
    return (1);
  } else {
    {
#line 437
    tmp = ldv_undef_int();
    }
#line 437
    if (tmp != 0) {
#line 439
      return (1);
    } else {
#line 443
      return (0);
    }
  }
}
}
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_sw_lock_of_u132(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 451
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132);
#line 454
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_sw_lock_of_u132(lock);
  }
#line 454
  if (tmp != 0) {
#line 456
    return (0);
  } else {
#line 460
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132 = 1;
#line 462
    return (1);
  }
}
}
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_sw_lock_of_u132(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 470
  cnt->counter = cnt->counter - 1;
#line 473
  if (cnt->counter != 0) {
#line 475
    return (0);
  } else {
    {
#line 478
    ldv_linux_kernel_locking_mutex_mutex_lock_sw_lock_of_u132(lock);
    }
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_sw_lock_of_u132(struct mutex *lock ) 
{ 


  {
  {
#line 488
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132);
#line 490
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132 = 0;
  }
#line 491
  return;
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock  ;
#line 495 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(struct mutex *lock ) 
{ 


  {
  {
#line 498
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock);
#line 500
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock = 1;
  }
#line 501
  return;
}
}
#line 504 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_u132_module_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 507
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock);
#line 509
  tmp = ldv_undef_int();
  }
#line 509
  if (tmp != 0) {
#line 511
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock = 1;
#line 513
    return (0);
  } else {
#line 517
    return (-4);
  }
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_u132_module_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 525
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock) {
#line 527
    return (1);
  } else {
    {
#line 530
    tmp = ldv_undef_int();
    }
#line 530
    if (tmp != 0) {
#line 532
      return (1);
    } else {
#line 536
      return (0);
    }
  }
}
}
#line 541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_u132_module_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 544
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock);
#line 547
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_u132_module_lock(lock);
  }
#line 547
  if (tmp != 0) {
#line 549
    return (0);
  } else {
#line 553
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock = 1;
#line 555
    return (1);
  }
}
}
#line 560 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_u132_module_lock(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 563
  cnt->counter = cnt->counter - 1;
#line 566
  if (cnt->counter != 0) {
#line 568
    return (0);
  } else {
    {
#line 571
    ldv_linux_kernel_locking_mutex_mutex_lock_u132_module_lock(lock);
    }
#line 573
    return (1);
  }
}
}
#line 578 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_u132_module_lock(struct mutex *lock ) 
{ 


  {
  {
#line 581
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock);
#line 583
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock = 0;
  }
#line 584
  return;
}
}
#line 586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 589
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 591
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 593
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 595
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132 = 0;
#line 597
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132 = 0;
#line 599
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock = 0;
#line 600
  return;
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 606
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 608
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 610
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 612
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_scheduler_lock_of_u132);
#line 614
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_sw_lock_of_u132);
#line 616
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_u132_module_lock);
  }
#line 617
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_slock_of_u132_spin(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_slock_of_u132_spin(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_slock_of_u132_spin(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_slock_of_u132_spin(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_slock_of_u132_spin(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_slock_of_u132_spin(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_slock_of_u132_spin();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_slock_of_u132_spin(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_slock_of_u132_spin(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 919 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 922
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 926
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 928
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 930
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 932
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 934
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 1);
  }
#line 935
  return;
}
}
#line 938 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 941
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 943
    return (1);
  } else {

  }
#line 946
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 948
    return (1);
  } else {

  }
#line 951
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 953
    return (1);
  } else {

  }
#line 956
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 958
    return (1);
  } else {

  }
#line 961
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 963
    return (1);
  } else {

  }
#line 966
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 968
    return (1);
  } else {

  }
#line 971
  if (ldv_linux_kernel_locking_spinlock_spin_slock_of_u132_spin == 2) {
#line 973
    return (1);
  } else {

  }
#line 976
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion = 2;
  }
#line 52
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/usb/host/u132-hcd.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/usb/host/u132-hcd.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error();
    }
  } else {

  }
#line 383
  return;
}
}
