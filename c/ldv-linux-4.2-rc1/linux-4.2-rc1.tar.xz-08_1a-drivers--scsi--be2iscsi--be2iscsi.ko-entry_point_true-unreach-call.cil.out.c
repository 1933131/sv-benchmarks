extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 141 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
struct iscsi_cls_conn;
#line 25
struct iscsi_task;
#line 30
struct scsi_device;
#line 58
struct device_attribute;
#line 70
struct scsi_cmnd;
#line 75
struct iscsi_cls_session;
#line 93
struct Scsi_Host;
#line 107
struct iscsi_endpoint;
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 380 "include/linux/scatterlist.h"
struct __kfifo {
   unsigned int in ;
   unsigned int out ;
   unsigned int mask ;
   unsigned int esize ;
   void *data ;
};
#line 65 "include/linux/kfifo.h"
union __anonunion____missing_field_name_217 {
   struct __kfifo kfifo ;
   unsigned char *type ;
   unsigned char const   *const_type ;
   char (*rectype)[0U] ;
   void *ptr ;
   void const   *ptr_const ;
};
#line 65 "include/linux/kfifo.h"
struct kfifo {
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned char buf[0U] ;
};
#line 190 "include/scsi/scsi_proto.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 32 "include/scsi/scsi_common.h"
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
#line 77 "include/scsi/iscsi_proto.h"
typedef uint32_t itt_t;
#line 78 "include/scsi/iscsi_proto.h"
struct iscsi_hdr {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t rsvd2[2U] ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 ttt ;
   __be32 statsn ;
   __be32 exp_statsn ;
   __be32 max_statsn ;
   uint8_t other[12U] ;
};
#line 143 "include/scsi/iscsi_proto.h"
struct iscsi_scsi_req {
   uint8_t opcode ;
   uint8_t flags ;
   __be16 rsvd2 ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 data_length ;
   __be32 cmdsn ;
   __be32 exp_statsn ;
   uint8_t cdb[16U] ;
};
#line 282 "include/scsi/iscsi_proto.h"
struct iscsi_tm {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t rsvd1[2U] ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   itt_t rtt ;
   __be32 cmdsn ;
   __be32 exp_statsn ;
   __be32 refcmdsn ;
   __be32 exp_datasn ;
   uint8_t rsvd2[8U] ;
};
#line 627 "include/scsi/iscsi_proto.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_220 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_220 __annonCompField61 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 369 "include/linux/socket.h"
struct in_addr {
   __be32 s_addr ;
};
#line 104 "include/linux/in.h"
union __anonunion_in6_u_221 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 104 "include/linux/in.h"
struct in6_addr {
   union __anonunion_in6_u_221 in6_u ;
};
#line 93 "include/linux/in6.h"
enum iscsi_tgt_dscvr {
    ISCSI_TGT_DSCVR_SEND_TARGETS = 1,
    ISCSI_TGT_DSCVR_ISNS = 2,
    ISCSI_TGT_DSCVR_SLP = 3
} ;
#line 311 "include/scsi/iscsi_if.h"
enum iscsi_param_type {
    ISCSI_PARAM = 0,
    ISCSI_HOST_PARAM = 1,
    ISCSI_NET_PARAM = 2,
    ISCSI_FLASHNODE_PARAM = 3,
    ISCSI_CHAP_PARAM = 4,
    ISCSI_IFACE_PARAM = 5
} ;
#line 327 "include/scsi/iscsi_if.h"
struct iscsi_iface_param_info {
   uint32_t iface_num ;
   uint32_t len ;
   uint16_t param ;
   uint8_t iface_type ;
   uint8_t param_type ;
   uint8_t value[0U] ;
};
#line 336 "include/scsi/iscsi_if.h"
union __anonunion_src_224 {
   struct in_addr v4_addr ;
   struct in6_addr v6_addr ;
};
#line 336 "include/scsi/iscsi_if.h"
union __anonunion_dst_225 {
   struct in_addr v4_addr ;
   struct in6_addr v6_addr ;
};
#line 336 "include/scsi/iscsi_if.h"
struct iscsi_path {
   uint64_t handle ;
   uint8_t mac_addr[6U] ;
   uint8_t mac_addr_old[6U] ;
   uint32_t ip_addr_len ;
   union __anonunion_src_224 src ;
   union __anonunion_dst_225 dst ;
   uint16_t vlan_id ;
   uint16_t pmtu ;
};
#line 491
enum iscsi_param {
    ISCSI_PARAM_MAX_RECV_DLENGTH = 0,
    ISCSI_PARAM_MAX_XMIT_DLENGTH = 1,
    ISCSI_PARAM_HDRDGST_EN = 2,
    ISCSI_PARAM_DATADGST_EN = 3,
    ISCSI_PARAM_INITIAL_R2T_EN = 4,
    ISCSI_PARAM_MAX_R2T = 5,
    ISCSI_PARAM_IMM_DATA_EN = 6,
    ISCSI_PARAM_FIRST_BURST = 7,
    ISCSI_PARAM_MAX_BURST = 8,
    ISCSI_PARAM_PDU_INORDER_EN = 9,
    ISCSI_PARAM_DATASEQ_INORDER_EN = 10,
    ISCSI_PARAM_ERL = 11,
    ISCSI_PARAM_IFMARKER_EN = 12,
    ISCSI_PARAM_OFMARKER_EN = 13,
    ISCSI_PARAM_EXP_STATSN = 14,
    ISCSI_PARAM_TARGET_NAME = 15,
    ISCSI_PARAM_TPGT = 16,
    ISCSI_PARAM_PERSISTENT_ADDRESS = 17,
    ISCSI_PARAM_PERSISTENT_PORT = 18,
    ISCSI_PARAM_SESS_RECOVERY_TMO = 19,
    ISCSI_PARAM_CONN_PORT = 20,
    ISCSI_PARAM_CONN_ADDRESS = 21,
    ISCSI_PARAM_USERNAME = 22,
    ISCSI_PARAM_USERNAME_IN = 23,
    ISCSI_PARAM_PASSWORD = 24,
    ISCSI_PARAM_PASSWORD_IN = 25,
    ISCSI_PARAM_FAST_ABORT = 26,
    ISCSI_PARAM_ABORT_TMO = 27,
    ISCSI_PARAM_LU_RESET_TMO = 28,
    ISCSI_PARAM_HOST_RESET_TMO = 29,
    ISCSI_PARAM_PING_TMO = 30,
    ISCSI_PARAM_RECV_TMO = 31,
    ISCSI_PARAM_IFACE_NAME = 32,
    ISCSI_PARAM_ISID = 33,
    ISCSI_PARAM_INITIATOR_NAME = 34,
    ISCSI_PARAM_TGT_RESET_TMO = 35,
    ISCSI_PARAM_TARGET_ALIAS = 36,
    ISCSI_PARAM_CHAP_IN_IDX = 37,
    ISCSI_PARAM_CHAP_OUT_IDX = 38,
    ISCSI_PARAM_BOOT_ROOT = 39,
    ISCSI_PARAM_BOOT_NIC = 40,
    ISCSI_PARAM_BOOT_TARGET = 41,
    ISCSI_PARAM_AUTO_SND_TGT_DISABLE = 42,
    ISCSI_PARAM_DISCOVERY_SESS = 43,
    ISCSI_PARAM_PORTAL_TYPE = 44,
    ISCSI_PARAM_CHAP_AUTH_EN = 45,
    ISCSI_PARAM_DISCOVERY_LOGOUT_EN = 46,
    ISCSI_PARAM_BIDI_CHAP_EN = 47,
    ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL = 48,
    ISCSI_PARAM_DEF_TIME2WAIT = 49,
    ISCSI_PARAM_DEF_TIME2RETAIN = 50,
    ISCSI_PARAM_MAX_SEGMENT_SIZE = 51,
    ISCSI_PARAM_STATSN = 52,
    ISCSI_PARAM_KEEPALIVE_TMO = 53,
    ISCSI_PARAM_LOCAL_PORT = 54,
    ISCSI_PARAM_TSID = 55,
    ISCSI_PARAM_DEF_TASKMGMT_TMO = 56,
    ISCSI_PARAM_TCP_TIMESTAMP_STAT = 57,
    ISCSI_PARAM_TCP_WSF_DISABLE = 58,
    ISCSI_PARAM_TCP_NAGLE_DISABLE = 59,
    ISCSI_PARAM_TCP_TIMER_SCALE = 60,
    ISCSI_PARAM_TCP_TIMESTAMP_EN = 61,
    ISCSI_PARAM_TCP_XMIT_WSF = 62,
    ISCSI_PARAM_TCP_RECV_WSF = 63,
    ISCSI_PARAM_IP_FRAGMENT_DISABLE = 64,
    ISCSI_PARAM_IPV4_TOS = 65,
    ISCSI_PARAM_IPV6_TC = 66,
    ISCSI_PARAM_IPV6_FLOW_LABEL = 67,
    ISCSI_PARAM_IS_FW_ASSIGNED_IPV6 = 68,
    ISCSI_PARAM_DISCOVERY_PARENT_IDX = 69,
    ISCSI_PARAM_DISCOVERY_PARENT_TYPE = 70,
    ISCSI_PARAM_LOCAL_IPADDR = 71,
    ISCSI_PARAM_MAX = 72
} ;
#line 567
enum iscsi_host_param {
    ISCSI_HOST_PARAM_HWADDRESS = 0,
    ISCSI_HOST_PARAM_INITIATOR_NAME = 1,
    ISCSI_HOST_PARAM_NETDEV_NAME = 2,
    ISCSI_HOST_PARAM_IPADDRESS = 3,
    ISCSI_HOST_PARAM_PORT_STATE = 4,
    ISCSI_HOST_PARAM_PORT_SPEED = 5,
    ISCSI_HOST_PARAM_MAX = 6
} ;
#line 745 "include/scsi/iscsi_if.h"
struct iscsi_stats_custom {
   char desc[64U] ;
   uint64_t value ;
};
#line 785 "include/scsi/iscsi_if.h"
struct iscsi_stats {
   uint64_t txdata_octets ;
   uint64_t rxdata_octets ;
   uint32_t noptx_pdus ;
   uint32_t scsicmd_pdus ;
   uint32_t tmfcmd_pdus ;
   uint32_t login_pdus ;
   uint32_t text_pdus ;
   uint32_t dataout_pdus ;
   uint32_t logout_pdus ;
   uint32_t snack_pdus ;
   uint32_t noprx_pdus ;
   uint32_t scsirsp_pdus ;
   uint32_t tmfrsp_pdus ;
   uint32_t textrsp_pdus ;
   uint32_t datain_pdus ;
   uint32_t logoutrsp_pdus ;
   uint32_t r2t_pdus ;
   uint32_t async_pdus ;
   uint32_t rjt_pdus ;
   uint32_t digest_err ;
   uint32_t timeout_err ;
   uint32_t custom_length ;
   struct iscsi_stats_custom custom[0U] ;
};
#line 960
struct klist_node;
#line 961 "include/scsi/iscsi_if.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273
struct scsi_transport_template;
#line 1274
struct iscsi_transport;
#line 1275
struct iscsi_conn;
#line 1276
struct iscsi_iface;
#line 1277
struct bsg_job;
#line 1278
struct iscsi_bus_flash_session;
#line 1279
struct iscsi_bus_flash_conn;
#line 1280 "include/linux/device.h"
struct iscsi_transport {
   struct module *owner ;
   char *name ;
   unsigned int caps ;
   struct iscsi_cls_session *(*create_session)(struct iscsi_endpoint * , uint16_t  ,
                                               uint16_t  , uint32_t  ) ;
   void (*destroy_session)(struct iscsi_cls_session * ) ;
   struct iscsi_cls_conn *(*create_conn)(struct iscsi_cls_session * , uint32_t  ) ;
   int (*bind_conn)(struct iscsi_cls_session * , struct iscsi_cls_conn * , uint64_t  ,
                    int  ) ;
   int (*start_conn)(struct iscsi_cls_conn * ) ;
   void (*stop_conn)(struct iscsi_cls_conn * , int  ) ;
   void (*destroy_conn)(struct iscsi_cls_conn * ) ;
   int (*set_param)(struct iscsi_cls_conn * , enum iscsi_param  , char * , int  ) ;
   int (*get_ep_param)(struct iscsi_endpoint * , enum iscsi_param  , char * ) ;
   int (*get_conn_param)(struct iscsi_cls_conn * , enum iscsi_param  , char * ) ;
   int (*get_session_param)(struct iscsi_cls_session * , enum iscsi_param  , char * ) ;
   int (*get_host_param)(struct Scsi_Host * , enum iscsi_host_param  , char * ) ;
   int (*set_host_param)(struct Scsi_Host * , enum iscsi_host_param  , char * , int  ) ;
   int (*send_pdu)(struct iscsi_cls_conn * , struct iscsi_hdr * , char * , uint32_t  ) ;
   void (*get_stats)(struct iscsi_cls_conn * , struct iscsi_stats * ) ;
   int (*init_task)(struct iscsi_task * ) ;
   int (*xmit_task)(struct iscsi_task * ) ;
   void (*cleanup_task)(struct iscsi_task * ) ;
   int (*alloc_pdu)(struct iscsi_task * , uint8_t  ) ;
   int (*xmit_pdu)(struct iscsi_task * ) ;
   int (*init_pdu)(struct iscsi_task * , unsigned int  , unsigned int  ) ;
   void (*parse_pdu_itt)(struct iscsi_conn * , itt_t  , int * , int * ) ;
   void (*session_recovery_timedout)(struct iscsi_cls_session * ) ;
   struct iscsi_endpoint *(*ep_connect)(struct Scsi_Host * , struct sockaddr * , int  ) ;
   int (*ep_poll)(struct iscsi_endpoint * , int  ) ;
   void (*ep_disconnect)(struct iscsi_endpoint * ) ;
   int (*tgt_dscvr)(struct Scsi_Host * , enum iscsi_tgt_dscvr  , uint32_t  , struct sockaddr * ) ;
   int (*set_path)(struct Scsi_Host * , struct iscsi_path * ) ;
   int (*set_iface_param)(struct Scsi_Host * , void * , uint32_t  ) ;
   int (*get_iface_param)(struct iscsi_iface * , enum iscsi_param_type  , int  , char * ) ;
   umode_t (*attr_is_visible)(int  , int  ) ;
   int (*bsg_request)(struct bsg_job * ) ;
   int (*send_ping)(struct Scsi_Host * , uint32_t  , uint32_t  , uint32_t  , uint32_t  ,
                    struct sockaddr * ) ;
   int (*get_chap)(struct Scsi_Host * , uint16_t  , uint32_t * , char * ) ;
   int (*delete_chap)(struct Scsi_Host * , uint16_t  ) ;
   int (*set_chap)(struct Scsi_Host * , void * , int  ) ;
   int (*get_flashnode_param)(struct iscsi_bus_flash_session * , int  , char * ) ;
   int (*set_flashnode_param)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ,
                              void * , int  ) ;
   int (*new_flashnode)(struct Scsi_Host * , char const   * , int  ) ;
   int (*del_flashnode)(struct iscsi_bus_flash_session * ) ;
   int (*login_flashnode)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ) ;
   int (*logout_flashnode)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ) ;
   int (*logout_flashnode_sid)(struct iscsi_cls_session * ) ;
   int (*get_host_stats)(struct Scsi_Host * , char * , int  ) ;
   u8 (*check_protection)(struct iscsi_task * , sector_t * ) ;
};
#line 200 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_conn {
   struct list_head conn_list ;
   void *dd_data ;
   struct iscsi_transport *transport ;
   uint32_t cid ;
   struct mutex ep_mutex ;
   struct iscsi_endpoint *ep ;
   struct device dev ;
};
#line 220 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_session {
   struct list_head sess_list ;
   struct iscsi_transport *transport ;
   spinlock_t lock ;
   struct work_struct block_work ;
   struct work_struct unblock_work ;
   struct work_struct scan_work ;
   struct work_struct unbind_work ;
   int recovery_tmo ;
   struct delayed_work recovery_work ;
   unsigned int target_id ;
   bool ida_used ;
   pid_t creator ;
   int state ;
   int sid ;
   void *dd_data ;
   struct device dev ;
};
#line 259
struct request_queue;
#line 259 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_host {
   atomic_t nr_scans ;
   struct mutex mutex ;
   struct request_queue *bsg_q ;
   uint32_t port_speed ;
   uint32_t port_state ;
};
#line 284 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_endpoint {
   void *dd_data ;
   struct device dev ;
   uint64_t id ;
   struct iscsi_cls_conn *conn ;
};
#line 292 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_iface {
   struct device dev ;
   struct iscsi_transport *transport ;
   uint32_t iface_type ;
   uint32_t iface_num ;
   void *dd_data ;
};
#line 300 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_bus_flash_conn {
   struct list_head conn_list ;
   void *dd_data ;
   struct iscsi_transport *transport ;
   struct device dev ;
   uint32_t exp_statsn ;
   uint32_t statsn ;
   unsigned int max_recv_dlength ;
   unsigned int max_xmit_dlength ;
   unsigned int max_segment_size ;
   unsigned int tcp_xmit_wsf ;
   unsigned int tcp_recv_wsf ;
   int hdrdgst_en ;
   int datadgst_en ;
   int port ;
   char *ipaddress ;
   char *link_local_ipv6_addr ;
   char *redirect_ipaddr ;
   uint16_t keepalive_timeout ;
   uint16_t local_port ;
   uint8_t snack_req_en ;
   uint8_t tcp_timestamp_stat ;
   uint8_t tcp_nagle_disable ;
   uint8_t tcp_wsf_disable ;
   uint8_t tcp_timer_scale ;
   uint8_t tcp_timestamp_en ;
   uint8_t ipv4_tos ;
   uint8_t ipv6_traffic_class ;
   uint8_t ipv6_flow_label ;
   uint8_t fragment_disable ;
   uint8_t is_fw_assigned_ipv6 ;
};
#line 344 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_bus_flash_session {
   struct list_head sess_list ;
   struct iscsi_transport *transport ;
   unsigned int target_id ;
   int flash_state ;
   void *dd_data ;
   struct device dev ;
   unsigned int first_burst ;
   unsigned int max_burst ;
   unsigned short max_r2t ;
   int default_taskmgmt_timeout ;
   int initial_r2t_en ;
   int imm_data_en ;
   int time2wait ;
   int time2retain ;
   int pdu_inorder_en ;
   int dataseq_inorder_en ;
   int erl ;
   int tpgt ;
   char *username ;
   char *username_in ;
   char *password ;
   char *password_in ;
   char *targetname ;
   char *targetalias ;
   char *portal_type ;
   uint16_t tsid ;
   uint16_t chap_in_idx ;
   uint16_t chap_out_idx ;
   uint16_t discovery_parent_idx ;
   uint16_t discovery_parent_type ;
   uint8_t auto_snd_tgt_disable ;
   uint8_t discovery_sess ;
   uint8_t entry_state ;
   uint8_t chap_auth_en ;
   uint8_t discovery_logout_en ;
   uint8_t bidi_chap_en ;
   uint8_t discovery_auth_optional ;
   uint8_t isid[6U] ;
   uint8_t is_boot_target ;
};
#line 486
struct scsi_host_template;
#line 487
struct scsi_target;
#line 489
struct iscsi_session;
#line 514 "include/scsi/scsi_transport_iscsi.h"
struct iscsi_r2t_info {
   __be32 ttt ;
   __be32 exp_statsn ;
   uint32_t data_length ;
   uint32_t data_offset ;
   int data_count ;
   int datasn ;
   int sent ;
};
#line 107 "include/scsi/libiscsi.h"
struct iscsi_task {
   struct iscsi_hdr *hdr ;
   unsigned short hdr_max ;
   unsigned short hdr_len ;
   itt_t hdr_itt ;
   __be32 cmdsn ;
   struct scsi_lun lun ;
   int itt ;
   unsigned int imm_count ;
   struct iscsi_r2t_info unsol_r2t ;
   char *data ;
   unsigned int data_count ;
   struct scsi_cmnd *sc ;
   struct iscsi_conn *conn ;
   unsigned long last_xfer ;
   unsigned long last_timeout ;
   bool have_checked_conn ;
   bool protected ;
   int state ;
   atomic_t refcount ;
   struct list_head running ;
   void *dd_data ;
};
#line 163 "include/scsi/libiscsi.h"
struct iscsi_conn {
   struct iscsi_cls_conn *cls_conn ;
   void *dd_data ;
   struct iscsi_session *session ;
   int stop_stage ;
   struct timer_list transport_timer ;
   unsigned long last_recv ;
   unsigned long last_ping ;
   int ping_timeout ;
   int recv_timeout ;
   struct iscsi_task *ping_task ;
   uint32_t exp_statsn ;
   uint32_t statsn ;
   int id ;
   int c_stage ;
   char *data ;
   struct iscsi_task *login_task ;
   struct iscsi_task *task ;
   struct list_head mgmtqueue ;
   struct list_head cmdqueue ;
   struct list_head requeue ;
   struct work_struct xmitwork ;
   unsigned long suspend_tx ;
   unsigned long suspend_rx ;
   wait_queue_head_t ehwait ;
   struct iscsi_tm tmhdr ;
   struct timer_list tmf_timer ;
   int tmf_state ;
   unsigned int max_recv_dlength ;
   unsigned int max_xmit_dlength ;
   int hdrdgst_en ;
   int datadgst_en ;
   int ifmarker_en ;
   int ofmarker_en ;
   int persistent_port ;
   char *persistent_address ;
   unsigned int max_segment_size ;
   unsigned int tcp_xmit_wsf ;
   unsigned int tcp_recv_wsf ;
   uint16_t keepalive_tmo ;
   uint16_t local_port ;
   uint8_t tcp_timestamp_stat ;
   uint8_t tcp_nagle_disable ;
   uint8_t tcp_wsf_disable ;
   uint8_t tcp_timer_scale ;
   uint8_t tcp_timestamp_en ;
   uint8_t fragment_disable ;
   uint8_t ipv4_tos ;
   uint8_t ipv6_traffic_class ;
   uint8_t ipv6_flow_label ;
   uint8_t is_fw_assigned_ipv6 ;
   char *local_ipaddr ;
   uint64_t txdata_octets ;
   uint64_t rxdata_octets ;
   uint32_t scsicmd_pdus_cnt ;
   uint32_t dataout_pdus_cnt ;
   uint32_t scsirsp_pdus_cnt ;
   uint32_t datain_pdus_cnt ;
   uint32_t r2t_pdus_cnt ;
   uint32_t tmfcmd_pdus_cnt ;
   int32_t tmfrsp_pdus_cnt ;
   uint32_t eh_abort_cnt ;
   uint32_t fmr_unalign_cnt ;
};
#line 255 "include/scsi/libiscsi.h"
struct iscsi_pool {
   struct kfifo queue ;
   void **pool ;
   int max ;
};
#line 271 "include/scsi/libiscsi.h"
struct iscsi_session {
   struct iscsi_cls_session *cls_session ;
   struct mutex eh_mutex ;
   uint32_t cmdsn ;
   uint32_t exp_cmdsn ;
   uint32_t max_cmdsn ;
   uint32_t queued_cmdsn ;
   int abort_timeout ;
   int lu_reset_timeout ;
   int tgt_reset_timeout ;
   int initial_r2t_en ;
   unsigned short max_r2t ;
   int imm_data_en ;
   unsigned int first_burst ;
   unsigned int max_burst ;
   int time2wait ;
   int time2retain ;
   int pdu_inorder_en ;
   int dataseq_inorder_en ;
   int erl ;
   int fast_abort ;
   int tpgt ;
   char *username ;
   char *username_in ;
   char *password ;
   char *password_in ;
   char *targetname ;
   char *targetalias ;
   char *ifacename ;
   char *initiatorname ;
   char *boot_root ;
   char *boot_nic ;
   char *boot_target ;
   char *portal_type ;
   char *discovery_parent_type ;
   uint16_t discovery_parent_idx ;
   uint16_t def_taskmgmt_tmo ;
   uint16_t tsid ;
   uint8_t auto_snd_tgt_disable ;
   uint8_t discovery_sess ;
   uint8_t chap_auth_en ;
   uint8_t discovery_logout_en ;
   uint8_t bidi_chap_en ;
   uint8_t discovery_auth_optional ;
   uint8_t isid[6U] ;
   struct iscsi_transport *tt ;
   struct Scsi_Host *host ;
   struct iscsi_conn *leadconn ;
   spinlock_t frwd_lock ;
   spinlock_t back_lock ;
   int state ;
   int age ;
   int scsi_cmds_max ;
   int cmds_max ;
   struct iscsi_task **cmds ;
   struct iscsi_pool cmdpool ;
   void *dd_data ;
};
#line 494 "include/scsi/libiscsi.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "include/linux/attribute_container.h"
struct transport_container;
#line 43 "include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 50 "include/linux/genhd.h"
struct hlist_bl_node;
#line 50 "include/linux/genhd.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_229 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_228 {
   struct __anonstruct____missing_field_name_229 __annonCompField62 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_228 __annonCompField63 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_231 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_230 {
   struct __anonstruct____missing_field_name_231 __annonCompField64 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_230 __annonCompField65 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_232 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_232 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_236 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_235 {
   struct __anonstruct____missing_field_name_236 __annonCompField66 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_235 __annonCompField67 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 47
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_239 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_239 __annonCompField68 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_240 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_240 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_241 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_241 __annonCompField69 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct hd_struct;
#line 442
struct gendisk;
#line 442 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_244 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_245 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_246 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_244 __annonCompField70 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_245 __annonCompField71 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_246 __annonCompField72 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_247 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_247 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_249 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_248 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_249 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_248 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1555
struct block_device_operations;
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 398 "include/linux/irq.h"
struct proc_dir_entry;
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_258 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_258 __annonCompField80 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_259 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_260 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 78 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_259 __annonCompField81 ;
   union __anonunion____missing_field_name_260 __annonCompField82 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 23
struct blk_trace;
#line 24
struct request;
#line 26
struct blkcg_gq;
#line 27
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_261 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_262 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_263 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_265 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_266 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_264 {
   struct __anonstruct_elv_265 elv ;
   struct __anonstruct_flush_266 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_261 __annonCompField83 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_262 __annonCompField84 ;
   union __anonunion____missing_field_name_263 __annonCompField85 ;
   union __anonunion____missing_field_name_264 __annonCompField86 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1578
struct blk_mq_tags;
#line 1579 "include/linux/blkdev.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_268 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_268 __annonCompField87 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 247
struct scsi_host_cmd_pool;
#line 249 "include/linux/blk-mq.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   int tag_alloc_policy ;
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
#line 507 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 517 "include/scsi/scsi_host.h"
union __anonunion____missing_field_name_269 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
#line 517 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_269 __annonCompField88 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int eh_deadline ;
   unsigned long last_reset ;
   unsigned int max_channel ;
   unsigned int max_id ;
   u64 max_lun ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int channel ;
   u64 lun ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 204 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 219 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
#line 249
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 255 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 532 "include/scsi/scsi_device.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 132 "include/scsi/scsi_transport.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 300 "include/linux/dma-mapping.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 39 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 55 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned char prot_flags ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   int flags ;
   unsigned char tag ;
};
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_276 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_277 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_276 __annonCompField92 ;
   union __anonunion____missing_field_name_277 __annonCompField93 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_280 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_279 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_280 __annonCompField94 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_279 __annonCompField95 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_283 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_282 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_283 __annonCompField96 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_281 {
   struct __anonstruct____missing_field_name_282 __annonCompField97 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_285 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_284 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_285 __annonCompField99 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_286 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_287 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_288 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_281 __annonCompField98 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_284 __annonCompField100 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_286 __annonCompField101 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_287 __annonCompField102 ;
   union __anonunion____missing_field_name_288 __annonCompField103 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_292 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_292 __annonCompField104 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 19 "include/linux/dmapool.h"
struct dma_pool;
#line 35 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 90 "include/linux/aer.h"
struct be_bus_address32 {
   unsigned int address_lo ;
   unsigned int address_hi ;
};
#line 218 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_bus_address64 {
   unsigned long long address ;
};
#line 222 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
union __anonunion_u_293 {
   struct be_bus_address32 a32 ;
   struct be_bus_address64 a64 ;
};
#line 222 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_bus_address {
   union __anonunion_u_293 u ;
};
#line 229 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct mem_array {
   struct be_bus_address bus_address ;
   void *virtual_address ;
   unsigned int size ;
};
#line 235 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_mem_descriptor {
   unsigned int index ;
   unsigned int category ;
   unsigned int num_elements ;
   unsigned int alignment_mask ;
   unsigned int size_in_bytes ;
   struct mem_array *mem_array ;
};
#line 246
struct iscsi_sge;
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct sgl_handle {
   unsigned int sgl_index ;
   unsigned int type ;
   unsigned int cid ;
   struct iscsi_task *task ;
   struct iscsi_sge *pfrag ;
};
#line 254 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hba_parameters {
   unsigned int ios_per_ctrl ;
   unsigned int cxns_per_ctrl ;
   unsigned int asyncpdus_per_ctrl ;
   unsigned int icds_per_ctrl ;
   unsigned int num_sge_per_io ;
   unsigned int defpdu_hdr_sz ;
   unsigned int defpdu_data_sz ;
   unsigned int num_cq_entries ;
   unsigned int num_eq_entries ;
   unsigned int wrbs_per_cxn ;
   unsigned int crashmode ;
   unsigned int hba_num ;
   unsigned int mgmt_ws_sz ;
   unsigned int hwi_ws_sz ;
   unsigned int eto ;
   unsigned int ldto ;
   unsigned int dbg_flags ;
   unsigned int num_cxn ;
   unsigned int eq_timer ;
   unsigned int num_mcc_pages ;
   unsigned int num_mcc_cq_pages ;
   unsigned int num_cq_pages ;
   unsigned int num_eq_pages ;
   unsigned int num_async_pdu_buf_pages ;
   unsigned int num_async_pdu_buf_sgl_pages ;
   unsigned int num_async_pdu_buf_cq_pages ;
   unsigned int num_async_pdu_hdr_pages ;
   unsigned int num_async_pdu_hdr_sgl_pages ;
   unsigned int num_async_pdu_hdr_cq_pages ;
   unsigned int num_sge ;
};
#line 298 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct invalidate_command_table {
   unsigned short icd ;
   unsigned short cid ;
};
#line 303
struct wrb_handle;
#line 303
struct iscsi_wrb;
#line 303 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hwi_wrb_context {
   struct list_head wrb_handle_list ;
   struct list_head wrb_handle_drvr_list ;
   struct wrb_handle **pwrb_handle_base ;
   struct wrb_handle **pwrb_handle_basestd ;
   struct iscsi_wrb *plast_wrb ;
   unsigned short alloc_index ;
   unsigned short free_index ;
   unsigned short wrb_handles_available ;
   unsigned short cid ;
   uint8_t ulp_num ;
   uint16_t register_set ;
   uint16_t doorbell_format ;
   uint32_t doorbell_offset ;
};
#line 321 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct ulp_cid_info {
   unsigned short *cid_array ;
   unsigned short avlbl_cids ;
   unsigned short cid_alloc ;
   unsigned short cid_free ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_295 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_295 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_296 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_296 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_297 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_297 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_298 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_298 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_299 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_299 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_300 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_300 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_301 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_301 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_302 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_302 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_303 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_304 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_303 ifr_ifrn ;
   union __anonunion_ifr_ifru_304 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 715 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_328 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_328 possible_net_t;
#line 376
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 383 "include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_32175 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_32175 phy_interface_t;
#line 126
enum ldv_32229 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_32229 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 41 "include/net/netprio_cgroup.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_338 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_339 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_340 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_338 adj_list ;
   struct __anonstruct_all_adj_list_339 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_340 __annonCompField107 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 646 "include/linux/if_vlan.h"
struct blk_iopoll;
#line 5 "include/linux/blk-iopoll.h"
typedef int blk_iopoll_fn(struct blk_iopoll * , int  );
#line 6 "include/linux/blk-iopoll.h"
struct blk_iopoll {
   struct list_head list ;
   unsigned long state ;
   unsigned long data ;
   int weight ;
   int max ;
   blk_iopoll_fn *poll ;
};
#line 45 "include/linux/blk-iopoll.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 83 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_aic_obj {
   bool enable ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 prev_eqd ;
   u32 et_eqd ;
   ulong jiffs ;
   u64 eq_prev ;
};
#line 95
struct beiscsi_hba;
#line 95 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_eq_obj {
   bool todo_mcc_cq ;
   bool todo_cq ;
   u32 cq_count ;
   struct be_queue_info q ;
   struct beiscsi_hba *phba ;
   struct be_queue_info *cq ;
   struct work_struct work_cqs ;
   struct blk_iopoll iopoll ;
};
#line 106 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
};
#line 111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct beiscsi_mcc_tag_state {
   uint8_t tag_state ;
   struct be_dma_mem tag_mem_state ;
};
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_ctrl_info {
   u8 *csr ;
   u8 *db ;
   u8 *pcicfg ;
   struct pci_dev *pdev ;
   spinlock_t mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   wait_queue_head_t mcc_wait[17U] ;
   unsigned int mcc_tag[16U] ;
   unsigned int mcc_numtag[17U] ;
   unsigned short mcc_alloc_index ;
   unsigned short mcc_free_index ;
   unsigned int mcc_tag_available ;
   struct beiscsi_mcc_tag_state ptag_state[17U] ;
};
#line 147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct be_sge {
   __le32 pa_lo ;
   __le32 pa_hi ;
   __le32 len ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
union __anonunion_payload_353 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_353 payload ;
};
#line 160 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd0[3U] ;
};
#line 219 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_hdr {
   u32 info ;
   u32 status ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_chap_format {
   u32 flags ;
   u8 intr_chap_name[256U] ;
   u8 intr_secret[16U] ;
   u8 target_chap_name[256U] ;
   u8 target_secret[16U] ;
   u16 intr_chap_name_length ;
   u16 intr_secret_length ;
   u16 target_chap_name_length ;
   u16 target_secret_length ;
};
#line 300 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_auth_method_format {
   u8 auth_method_type ;
   u8 padding[3U] ;
   struct mgmt_chap_format chap ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_conn_login_options {
   u8 flags ;
   u8 header_digest ;
   u8 data_digest ;
   u8 rsvd0 ;
   u32 max_recv_datasegment_len_ini ;
   u32 max_recv_datasegment_len_tgt ;
   u32 tcp_mss ;
   u32 tcp_window_size ;
   struct mgmt_auth_method_format auth_data ;
};
#line 329 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct ip_addr_format {
   u16 size_of_structure ;
   u8 reserved ;
   u8 ip_type ;
   u8 addr[16U] ;
   u32 rsvd0 ;
};
#line 337 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_conn_info {
   u32 connection_handle ;
   u32 connection_status ;
   u16 src_port ;
   u16 dest_port ;
   u16 dest_port_redirected ;
   u16 cid ;
   u32 estimated_throughput ;
   struct ip_addr_format src_ipaddr ;
   struct ip_addr_format dest_ipaddr ;
   struct ip_addr_format dest_ipaddr_redirected ;
   struct mgmt_conn_login_options negotiated_login_options ;
};
#line 351 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_session_login_options {
   u8 flags ;
   u8 error_recovery_level ;
   u16 rsvd0 ;
   u32 first_burst_length ;
   u32 max_burst_length ;
   u16 max_connections ;
   u16 max_outstanding_r2t ;
   u16 default_time2wait ;
   u16 default_time2retain ;
};
#line 363 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_session_info {
   u32 session_handle ;
   u32 status ;
   u8 isid[6U] ;
   u16 tsih ;
   u32 session_flags ;
   u16 conn_count ;
   u16 pad ;
   u8 target_name[224U] ;
   u8 initiator_iscsiname[224U] ;
   struct mgmt_session_login_options negotiated_login_options ;
   struct mgmt_conn_info conn_list[1U] ;
};
#line 431 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_subnet_format {
   u16 size_of_structure ;
   u8 ip_type ;
   u8 ipv6_prefix_length ;
   u8 addr[16U] ;
   u8 subnet_mask[16U] ;
   u32 rsvd0 ;
};
#line 446 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_if_info_resp {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 vlan_priority ;
   u32 ip_addr_count ;
   u32 dhcp_state ;
   struct be_ip_addr_subnet_format ip_addr ;
};
#line 498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_def_gateway_resp {
   struct be_cmd_req_hdr hdr ;
   struct ip_addr_format ip_addr ;
};
#line 669 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_nic_conf_resp {
   struct be_cmd_resp_hdr hdr ;
   u32 nic_port_count ;
   u32 speed ;
   u32 max_speed ;
   u32 link_state ;
   u32 max_frame_size ;
   u16 size_of_structure ;
   u8 mac_address[6U] ;
   u32 rsvd[23U] ;
};
#line 681 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_hba_name {
   struct be_cmd_req_hdr hdr ;
   u16 flags ;
   u16 rsvd0 ;
   u8 initiator_name[224U] ;
   u8 initiator_alias[32U] ;
};
#line 696 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_ntwk_link_status_resp {
   struct be_cmd_resp_hdr hdr ;
   u8 phys_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 qos_link_speed ;
   u32 logical_link_speed ;
};
#line 1055 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_connect_and_offload_out {
   struct be_cmd_resp_hdr hdr ;
   u32 connection_handle ;
   u16 cid ;
   u16 rsvd0 ;
};
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct hwi_controller;
#line 202
struct beiscsi_conn;
#line 202
struct iscsi_boot_kset;
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct __anonstruct_fw_config_355 {
   unsigned int phys_port ;
   unsigned int eqid_count ;
   unsigned int cqid_count ;
   unsigned int iscsi_cid_start[2U] ;
   unsigned int iscsi_cid_count[2U] ;
   unsigned int iscsi_icd_count[2U] ;
   unsigned int iscsi_icd_start[2U] ;
   unsigned int iscsi_chain_start[2U] ;
   unsigned int iscsi_chain_count[2U] ;
   unsigned short iscsi_features ;
   uint16_t dual_ulp_aware ;
   unsigned long ulp_supported ;
};
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
struct beiscsi_hba {
   struct hba_parameters params ;
   struct hwi_controller *phwi_ctrlr ;
   unsigned int mem_req[22U] ;
   u8 *csr_va ;
   u8 *db_va ;
   u8 *pci_va ;
   struct be_bus_address csr_pa ;
   struct be_bus_address db_pa ;
   struct be_bus_address pci_pa ;
   struct pci_dev *pcidev ;
   unsigned short asic_revision ;
   unsigned int num_cpus ;
   unsigned int nxt_cqid ;
   struct msix_entry msix_entries[64U] ;
   char *msi_name[64U] ;
   bool msix_enabled ;
   struct be_mem_descriptor *init_mem ;
   unsigned short io_sgl_alloc_index ;
   unsigned short io_sgl_free_index ;
   unsigned short io_sgl_hndl_avbl ;
   struct sgl_handle **io_sgl_hndl_base ;
   struct sgl_handle **sgl_hndl_array ;
   unsigned short eh_sgl_alloc_index ;
   unsigned short eh_sgl_free_index ;
   unsigned short eh_sgl_hndl_avbl ;
   struct sgl_handle **eh_sgl_hndl_base ;
   spinlock_t io_sgl_lock ;
   spinlock_t mgmt_sgl_lock ;
   spinlock_t isr_lock ;
   spinlock_t async_pdu_lock ;
   unsigned int age ;
   struct list_head hba_queue ;
   unsigned short cid_to_cri_map[2048U] ;
   struct ulp_cid_info *cid_array_info[2U] ;
   struct iscsi_endpoint **ep_array ;
   struct beiscsi_conn **conn_table ;
   struct iscsi_boot_kset *boot_kset ;
   struct Scsi_Host *shost ;
   struct iscsi_iface *ipv4_iface ;
   struct iscsi_iface *ipv6_iface ;
   struct __anonstruct_fw_config_355 fw_config ;
   unsigned int state ;
   int get_boot ;
   bool fw_timeout ;
   bool ue_detected ;
   struct delayed_work beiscsi_hw_check_task ;
   bool mac_addr_set ;
   u8 mac_address[6U] ;
   char fw_ver_str[32U] ;
   char wq_name[20U] ;
   struct workqueue_struct *wq ;
   struct be_ctrl_info ctrl ;
   unsigned int generation ;
   unsigned int interface_handle ;
   struct mgmt_session_info boot_sess ;
   struct invalidate_command_table inv_tbl[128U] ;
   struct be_aic_obj aic_obj[64U] ;
   unsigned int attr_log_enable ;
   int (*iotask_fn)(struct iscsi_task * , struct scatterlist * , uint32_t  , uint32_t  ,
                    uint32_t  ) ;
};
#line 439 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_session {
   struct dma_pool *bhs_pool ;
};
#line 446
struct beiscsi_endpoint;
#line 446 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_conn {
   struct iscsi_conn *conn ;
   struct beiscsi_hba *phba ;
   u32 exp_statsn ;
   u32 doorbell_offset ;
   u32 beiscsi_conn_cid ;
   struct beiscsi_endpoint *ep ;
   unsigned short login_in_progress ;
   struct wrb_handle *plogin_wrb_handle ;
   struct sgl_handle *plogin_sgl_handle ;
   struct beiscsi_session *beiscsi_sess ;
   struct iscsi_task *task ;
};
#line 463 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct pdu_data_out {
   u32 dw[12U] ;
};
#line 491 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_cmd_bhs {
   struct iscsi_scsi_req iscsi_hdr ;
   unsigned char pad1[16U] ;
   struct pdu_data_out iscsi_data_pdu ;
   unsigned char pad2[210U] ;
};
#line 498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_io_task {
   struct wrb_handle *pwrb_handle ;
   struct sgl_handle *psgl_handle ;
   struct beiscsi_conn *conn ;
   struct scsi_cmnd *scsi_cmnd ;
   unsigned int cmd_sn ;
   unsigned int flags ;
   unsigned short cid ;
   unsigned short header_len ;
   itt_t libiscsi_itt ;
   struct be_cmd_bhs *cmd_bhs ;
   struct be_bus_address bhs_pa ;
   unsigned short bhs_len ;
   dma_addr_t mtask_addr ;
   uint32_t mtask_data_count ;
   uint8_t wrb_type ;
};
#line 535 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct iscsi_sge {
   u32 dw[4U] ;
};
#line 553 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_offload_params {
   u32 dw[6U] ;
};
#line 587 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct async_pdu_handle {
   struct list_head link ;
   struct be_bus_address pa ;
   void *pbuffer ;
   unsigned int consumed ;
   unsigned char index ;
   unsigned char is_header ;
   unsigned short cri ;
   unsigned long buffer_len ;
};
#line 601 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_wait_queue_356 {
   unsigned char hdr_received ;
   unsigned char hdr_len ;
   unsigned short bytes_received ;
   unsigned int bytes_needed ;
   struct list_head list ;
};
#line 601 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hwi_async_entry {
   struct __anonstruct_wait_queue_356 wait_queue ;
   struct list_head header_busy_list ;
   struct list_head data_busy_list ;
};
#line 614 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_async_header_357 {
   struct be_bus_address pa_base ;
   void *va_base ;
   void *ring_base ;
   struct async_pdu_handle *handle_base ;
   unsigned int host_write_ptr ;
   unsigned int ep_read_ptr ;
   unsigned int writables ;
   unsigned int free_entries ;
   unsigned int busy_entries ;
   struct list_head free_list ;
};
#line 614 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_async_data_358 {
   struct be_bus_address pa_base ;
   void *va_base ;
   void *ring_base ;
   struct async_pdu_handle *handle_base ;
   unsigned int host_write_ptr ;
   unsigned int ep_read_ptr ;
   unsigned int writables ;
   unsigned int free_entries ;
   unsigned int busy_entries ;
   struct list_head free_list ;
};
#line 614 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hwi_async_pdu_context {
   struct __anonstruct_async_header_357 async_header ;
   struct __anonstruct_async_data_358 async_data ;
   unsigned int buffer_size ;
   unsigned int num_entries ;
   unsigned short cid_to_async_cri_map[2048U] ;
   struct hwi_async_entry *async_entry ;
};
#line 739 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct iscsi_wrb {
   u32 dw[16U] ;
};
#line 1001 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_ring {
   u32 pages ;
   u32 id ;
   u32 num ;
   u32 cidx ;
   u32 pidx ;
   u32 item_size ;
   u8 ulp_num ;
   u16 register_set ;
   u16 doorbell_format ;
   u32 doorbell_offset ;
   void *va ;
};
#line 1017
struct mcc_wrb;
#line 1017
struct hwi_context_memory;
#line 1017 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hwi_controller {
   struct list_head io_sgl_list ;
   struct list_head eh_sgl_list ;
   struct sgl_handle *psgl_handle_base ;
   unsigned int wrb_mem_index ;
   struct hwi_wrb_context *wrb_context ;
   struct mcc_wrb *pmcc_wrb_base ;
   struct be_ring default_pdu_hdr[2U] ;
   struct be_ring default_pdu_data[2U] ;
   struct hwi_context_memory *phwi_ctxt ;
};
#line 1033
enum hwh_type_enum {
    HWH_TYPE_IO = 1,
    HWH_TYPE_LOGOUT = 2,
    HWH_TYPE_TMF = 3,
    HWH_TYPE_NOP = 4,
    HWH_TYPE_IO_RD = 5,
    HWH_TYPE_LOGIN = 11,
    HWH_TYPE_INVALID = 4294967295U
} ;
#line 1043 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct wrb_handle {
   enum hwh_type_enum type ;
   unsigned short wrb_index ;
   unsigned short nxt_wrb_index ;
   struct iscsi_task *pio_handle ;
   struct iscsi_wrb *pwrb ;
};
#line 1052 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct hwi_context_memory {
   u16 min_eqd ;
   u16 max_eqd ;
   u16 cur_eqd ;
   struct be_eq_obj be_eq[64U] ;
   struct be_queue_info be_cq[63U] ;
   struct be_queue_info *be_wrbq ;
   struct be_queue_info be_def_hdrq[2U] ;
   struct be_queue_info be_def_dataq[2U] ;
   struct hwi_async_pdu_context *pasync_ctx[2U] ;
};
#line 75 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 length ;
};
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
union __anonunion_u_362 {
   struct mcc_sge sgl[19U] ;
   u32 embedded[59U] ;
};
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_wrb_payload {
   union __anonunion_u_362 u ;
};
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_wrb {
   u32 dw[0U] ;
   u32 payload_length ;
   u32 tag[2U] ;
   u32 rsvd2[1U] ;
   struct mcc_wrb_payload payload ;
};
#line 230
struct beiscsi_sess;
#line 230 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct beiscsi_endpoint {
   struct beiscsi_hba *phba ;
   struct beiscsi_sess *sess ;
   struct beiscsi_conn *conn ;
   struct iscsi_endpoint *openiscsi_ep ;
   unsigned short ip_type ;
   char dst6_addr[64U] ;
   unsigned long dst_addr ;
   unsigned short ep_cid ;
   unsigned int fw_handle ;
   u16 dst_tcpport ;
   u16 cid_vld ;
};
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 1951 "include/linux/pci.h"
struct iscsi_boot_kobj {
   struct kobject kobj ;
   struct attribute_group *attr_group ;
   struct list_head list ;
   void *data ;
   ssize_t (*show)(void * , int  , char * ) ;
   umode_t (*is_visible)(void * , int  ) ;
   void (*release)(void * ) ;
};
#line 103 "include/linux/iscsi_boot_sysfs.h"
struct iscsi_boot_kset {
   struct list_head kobj_list ;
   struct kset *kset ;
};
#line 132 "include/linux/iscsi_boot_sysfs.h"
struct bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 38 "include/linux/bsg-lib.h"
struct bsg_job {
   struct device *dev ;
   struct request *req ;
   void *request ;
   void *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct bsg_buffer request_payload ;
   struct bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 266 "include/scsi/iscsi_proto.h"
struct iscsi_nopin {
   uint8_t opcode ;
   uint8_t flags ;
   __be16 rsvd2 ;
   uint8_t rsvd3 ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 ttt ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   uint8_t rsvd4[12U] ;
};
#line 299 "include/scsi/iscsi_proto.h"
struct iscsi_tm_rsp {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t response ;
   uint8_t qualifier ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   uint8_t rsvd2[8U] ;
   itt_t itt ;
   itt_t rtt ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   uint8_t rsvd3[12U] ;
};
#line 547 "include/scsi/iscsi_proto.h"
struct iscsi_logout_rsp {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t response ;
   uint8_t rsvd2 ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   uint8_t rsvd3[8U] ;
   itt_t itt ;
   __be32 rsvd4 ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   __be32 rsvd5 ;
   __be16 t2wait ;
   __be16 t2retain ;
   __be32 rsvd6 ;
};
#line 465 "include/scsi/iscsi_if.h"
enum iscsi_err {
    ISCSI_OK = 0,
    ISCSI_ERR_DATASN = 1001,
    ISCSI_ERR_DATA_OFFSET = 1002,
    ISCSI_ERR_MAX_CMDSN = 1003,
    ISCSI_ERR_EXP_CMDSN = 1004,
    ISCSI_ERR_BAD_OPCODE = 1005,
    ISCSI_ERR_DATALEN = 1006,
    ISCSI_ERR_AHSLEN = 1007,
    ISCSI_ERR_PROTO = 1008,
    ISCSI_ERR_LUN = 1009,
    ISCSI_ERR_BAD_ITT = 1010,
    ISCSI_ERR_CONN_FAILED = 1011,
    ISCSI_ERR_R2TSN = 1012,
    ISCSI_ERR_SESSION_FAILED = 1013,
    ISCSI_ERR_HDR_DGST = 1014,
    ISCSI_ERR_DATA_DGST = 1015,
    ISCSI_ERR_PARAM_NOT_FOUND = 1016,
    ISCSI_ERR_NO_SCSI_CMD = 1017,
    ISCSI_ERR_INVALID_HOST = 1018,
    ISCSI_ERR_XMIT_FAILED = 1019,
    ISCSI_ERR_TCP_CONN_CLOSE = 1020,
    ISCSI_ERR_SCSI_EH_SESSION_RST = 1021,
    ISCSI_ERR_NOP_TIMEDOUT = 1022
} ;
#line 494 "include/scsi/libiscsi.h"
struct iscsi_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 71 "include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 78 "include/scsi/scsi_bsg_iscsi.h"
union __anonunion_rqst_data_272 {
   struct iscsi_bsg_host_vendor h_vendor ;
};
#line 78 "include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_272 rqst_data ;
};
#line 87 "include/scsi/scsi_bsg_iscsi.h"
union __anonunion_reply_data_273 {
   struct iscsi_bsg_host_vendor_reply vendor_reply ;
};
#line 87 "include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_273 reply_data ;
};
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 83 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_async_event_trailer {
   u32 code ;
};
#line 138 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   struct be_async_event_trailer trailer ;
};
#line 226 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 282 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_set_eqd {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 382 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_session_resp {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_session_info session_info ;
};
#line 883 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct sol_cqe {
   u32 dw[4U] ;
};
#line 947 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct common_sol_cqe {
   u32 exp_cmdsn ;
   u32 res_cnt ;
   u16 wrb_index ;
   u16 cid ;
   u8 hw_sts ;
   u8 cmd_wnd ;
   u8 res_flag ;
   u8 i_resp ;
   u8 i_flags ;
   u8 i_sts ;
};
#line 1068 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct dmsg_cqe {
   u32 dw[4U] ;
};
#line 524 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_status_bhs {
   struct iscsi_scsi_req iscsi_hdr ;
   unsigned char pad1[16U] ;
   unsigned char sense_info[258U] ;
};
#line 657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct i_t_dpdu_cqe {
   u32 dw[4U] ;
};
#line 696 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct be_eq_entry {
   u32 dw[1U] ;
};
#line 854 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct pdu_nop_out {
   u32 dw[12U] ;
};
#line 880 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct pdu_base {
   u32 dw[16U] ;
};
#line 2060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 2086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 2123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 2150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 225 "include/uapi/linux/in.h"
struct sockaddr_in {
   __kernel_sa_family_t sin_family ;
   __be16 sin_port ;
   struct in_addr sin_addr ;
   unsigned char __pad[8U] ;
};
#line 41 "include/uapi/linux/in6.h"
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __be16 sin6_port ;
   __be32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
#line 306 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_logout_fw_sess {
   struct be_cmd_req_hdr hdr ;
   uint32_t session_handle ;
};
#line 311 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_logout_fw_sess {
   struct be_cmd_resp_hdr hdr ;
   uint32_t session_status ;
};
#line 377 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_session_req {
   struct be_cmd_req_hdr hdr ;
   u32 session_handle ;
};
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_boot_target_req {
   struct be_cmd_req_hdr hdr ;
};
#line 396 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_boot_target_resp {
   struct be_cmd_resp_hdr hdr ;
   u32 boot_session_count ;
   int boot_session_handle ;
};
#line 402 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_reopen_session_req {
   struct be_cmd_req_hdr hdr ;
   u16 reopen_type ;
   u16 rsvd ;
   u32 session_handle ;
};
#line 440 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_if_info_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
};
#line 455 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_record {
   u32 action ;
   u32 interface_hndl ;
   struct be_ip_addr_subnet_format ip_addr ;
   u32 status ;
};
#line 462 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_record_params {
   u32 record_entry_count ;
   struct be_ip_addr_record ip_record ;
};
#line 467 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_ip_addr_req {
   struct be_cmd_req_hdr hdr ;
   struct be_ip_addr_record_params ip_params ;
};
#line 472 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_dhcp_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
   u32 flags ;
   u32 retry_count ;
};
#line 481 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_rel_dhcp_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
};
#line 487 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_def_gateway_req {
   struct be_cmd_req_hdr hdr ;
   u32 action ;
   struct ip_addr_format ip_addr ;
};
#line 493 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_def_gateway_req {
   struct be_cmd_req_hdr hdr ;
   u32 ip_type ;
};
#line 642 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct __anonstruct_delay_356 {
   __le32 eq_id ;
   __le32 phase ;
   __le32 delay_multiplier ;
};
#line 642 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   __le32 num_eq ;
   struct __anonstruct_delay_356 delay[64U] ;
};
#line 691 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_ntwk_link_status_req {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 1001 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct iscsi_cleanup_req {
   struct be_cmd_req_hdr hdr ;
   u16 chute ;
   u8 hdr_ring_id ;
   u8 data_ring_id ;
};
#line 1035 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_connect_and_offload_in_v1 {
   struct be_cmd_req_hdr hdr ;
   struct ip_addr_format ip_address ;
   u16 tcp_port ;
   u16 cid ;
   u16 cq_id ;
   u16 defq_id ;
   struct phys_addr dataout_template_pa ;
   u16 hdr_ring_id ;
   u16 data_ring_id ;
   u8 do_offload ;
   u8 ifd_state ;
   u8 rsvd0[2U] ;
   u16 tcp_window_size ;
   u8 tcp_window_scale_count ;
   u8 rsvd1 ;
   unsigned int tcp_mss : 24 ;
   u8 rsvd2 ;
};
#line 1078 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_upload_params_in {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 upload_type ;
   u32 reset_seq ;
};
#line 1094 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ulp_fw_cfg {
   u32 ulp_mode ;
   u32 etx_base ;
   u32 etx_count ;
   u32 sq_base ;
   u32 sq_count ;
   u32 rq_base ;
   u32 rq_count ;
   u32 dq_base ;
   u32 dq_count ;
   u32 lro_base ;
   u32 lro_count ;
   u32 icd_base ;
   u32 icd_count ;
};
#line 1111 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ulp_chain_icd {
   u32 chain_base ;
   u32 chain_count ;
};
#line 1116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   struct be_ulp_fw_cfg ulp[2U] ;
   u32 function_caps ;
   u32 cqid_base ;
   u32 cqid_count ;
   u32 eqid_base ;
   u32 eqid_count ;
   struct be_ulp_chain_icd chain_icd[2U] ;
};
#line 1133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_all_if_id_req {
   struct be_cmd_req_hdr hdr ;
   u32 if_count ;
   u32 if_hndl_list[1U] ;
};
#line 113 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct iscsi_invalidate_connection_params_in {
   struct be_cmd_req_hdr hdr ;
   unsigned int session_handle ;
   unsigned short cid ;
   unsigned short unused ;
   unsigned short cleanup_type ;
   unsigned short save_cfg ;
};
#line 137 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct invalidate_commands_params_in {
   struct be_cmd_req_hdr hdr ;
   unsigned int ref_handle ;
   unsigned int icd_count ;
   struct invalidate_command_table table[128U] ;
   unsigned short cleanup_type ;
   unsigned short unused ;
};
#line 157 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct mgmt_hba_attributes {
   u8 flashrom_version_string[32U] ;
   u8 manufacturer_name[32U] ;
   u32 supported_modes ;
   u8 seeprom_version_lo ;
   u8 seeprom_version_hi ;
   u8 rsvd0[2U] ;
   u32 fw_cmd_data_struct_version ;
   u32 ep_fw_data_struct_version ;
   u8 ncsi_version_string[12U] ;
   u32 default_extended_timeout ;
   u8 controller_model_number[32U] ;
   u8 controller_description[64U] ;
   u8 controller_serial_number[32U] ;
   u8 ip_version_string[32U] ;
   u8 firmware_version_string[32U] ;
   u8 bios_version_string[32U] ;
   u8 redboot_version_string[32U] ;
   u8 driver_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
   u32 functionalities_supported ;
   u16 max_cdblength ;
   u8 asic_revision ;
   u8 generational_guid[16U] ;
   u8 hba_port_count ;
   u16 default_link_down_timeout ;
   u8 iscsi_ver_min_max ;
   u8 multifunction_device ;
   u8 cache_valid ;
   u8 hba_status ;
   u8 max_domains_supported ;
   u8 phy_port ;
   u32 firmware_post_status ;
   u32 hba_mtu[8U] ;
   u8 iscsi_features ;
   u8 asic_generation ;
   u8 future_u8[2U] ;
   u32 future_u32[3U] ;
};
#line 197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct mgmt_controller_attributes {
   struct mgmt_hba_attributes hba_attribs ;
   u16 pci_vendor_id ;
   u16 pci_device_id ;
   u16 pci_sub_vendor_id ;
   u16 pci_sub_system_id ;
   u8 pci_bus_number ;
   u8 pci_device_number ;
   u8 pci_function_number ;
   u8 interface_type ;
   u64 unique_identifier ;
   u8 netfilters ;
   u8 rsvd0[3U] ;
   u32 future_u32[4U] ;
};
#line 213 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_mgmt_controller_attributes {
   struct be_cmd_req_hdr hdr ;
   struct mgmt_controller_attributes params ;
};
#line 218 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_mgmt_controller_attributes_resp {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attributes params ;
};
#line 223 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_bsg_vendor_cmd {
   struct be_cmd_req_hdr hdr ;
   unsigned short region ;
   unsigned short offset ;
   unsigned short sector ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct virt_addr {
   u32 lo ;
   u32 hi ;
};
#line 268 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 rsvd0 ;
};
#line 503 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_vlan_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 vlan_priority ;
};
#line 554 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[4U] ;
};
#line 563 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 589 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 597 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 612 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 784 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_default_pdu_context {
   u32 dw[4U] ;
};
#line 818 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_defq_create_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 ulp_num ;
   u8 dua_feature ;
   struct be_default_pdu_context context ;
   struct phys_addr pages[8U] ;
};
#line 829 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_defq_create_resp {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u8 rsvd0 ;
   u8 ulp_num ;
   u32 doorbell_offset ;
   u16 register_set ;
   u16 doorbell_format ;
};
#line 839 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_post_template_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 type ;
   struct phys_addr scratch_pa ;
   struct virt_addr scratch_va ;
   struct virt_addr pages_va ;
   struct phys_addr pages[16U] ;
};
#line 850 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_remove_template_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 type ;
   u16 rsvd0 ;
};
#line 856 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_post_sgl_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 page_offset ;
   u32 rsvd0 ;
   struct phys_addr pages[26U] ;
   u32 rsvd1 ;
};
#line 865 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_wrbq_create_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 ulp_num ;
   u8 dua_feature ;
   struct phys_addr pages[8U] ;
};
#line 873 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
struct be_wrbq_create_resp {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 cid ;
   u8 rsvd0 ;
   u8 ulp_num ;
   u32 doorbell_offset ;
   u16 register_set ;
   u16 doorbell_format ;
};
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 402 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 5 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
void *ldv_err_ptr(long error ) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_2_0  =    0;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_3_2  =    0;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_3_0  =    0;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_2_1  =    0;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_3_1  =    0;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_2_2  =    0;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_2_3  =    0;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
int ldv_irq_3_3  =    0;
#line 122
void call_and_disable_all_6(int state ) ;
#line 129
void activate_work_6(struct work_struct *work , int state ) ;
#line 1075 "include/linux/device.h"
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 443 "include/scsi/scsi_transport_iscsi.h"
extern struct iscsi_endpoint *iscsi_create_endpoint(int  ) ;
#line 444
extern void iscsi_destroy_endpoint(struct iscsi_endpoint * ) ;
#line 445
extern struct iscsi_endpoint *iscsi_lookup_endpoint(u64  ) ;
#line 447
extern struct iscsi_iface *iscsi_create_iface(struct Scsi_Host * , struct iscsi_transport * ,
                                              uint32_t  , uint32_t  , int  ) ;
#line 451
extern void iscsi_destroy_iface(struct iscsi_iface * ) ;
#line 453
extern char *iscsi_get_port_speed_name(struct Scsi_Host * ) ;
#line 454
extern char *iscsi_get_port_state_name(struct Scsi_Host * ) ;
#line 396 "include/scsi/libiscsi.h"
extern int iscsi_host_get_param(struct Scsi_Host * , enum iscsi_host_param  , char * ) ;
#line 410
extern struct iscsi_cls_session *iscsi_session_setup(struct iscsi_transport * , struct Scsi_Host * ,
                                                     uint16_t  , int  , int  , uint32_t  ,
                                                     unsigned int  ) ;
#line 412
extern void iscsi_session_teardown(struct iscsi_cls_session * ) ;
#line 414
extern int iscsi_set_param(struct iscsi_cls_conn * , enum iscsi_param  , char * ,
                           int  ) ;
#line 425
extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session * , int  ,
                                               uint32_t  ) ;
#line 428
extern int iscsi_conn_start(struct iscsi_cls_conn * ) ;
#line 430
extern int iscsi_conn_bind(struct iscsi_cls_session * , struct iscsi_cls_conn * ,
                           int  ) ;
#line 440
extern void iscsi_suspend_queue(struct iscsi_conn * ) ;
#line 754 "include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 756
  return ((void *)(& shost->hostdata));
}
}
#line 759
extern int scsi_is_host_device(struct device  const  * ) ;
#line 761 "include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_35565;
  ldv_35564: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_35565: 
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_35564;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 131 "./arch/x86/include/asm/dma-mapping.h"
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 241 "include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 669 "include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 671
  return ((void *)nla + 4U);
}
}
#line 688 "include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 690
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 703 "include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 705
  totlen = ((int )nla->nla_len + 3) & -4;
#line 707
  *remaining = *remaining - totlen;
#line 708
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 19 "include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 22
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                        size, dma_handle, 32U, (struct dma_attrs *)0);
#line 19
  return (tmp);
}
}
#line 31 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 34
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
#line 35
  return;
}
}
#line 33 "include/linux/if_ether.h"
extern ssize_t sysfs_format_mac(char * , unsigned char const   * , int  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 43 "include/linux/blk-iopoll.h"
extern void blk_iopoll_enable(struct blk_iopoll * ) ;
#line 44
extern void blk_iopoll_disable(struct blk_iopoll * ) ;
#line 633 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 635
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 732
unsigned int be_cmd_get_initname(struct beiscsi_hba *phba ) ;
#line 733
unsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba ) ;
#line 739
int beiscsi_mccq_compl(struct beiscsi_hba *phba , uint32_t tag , struct be_mcc_wrb **wrb ,
                       struct be_dma_mem *mbx_cmd_mem ) ;
#line 165 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 167
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 170 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 173
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 174
  *dw = *dw & ~ (mask << (int )offset);
#line 175
  *dw = *dw | ((mask & value) << (int )offset);
#line 176
  return;
}
}
#line 841 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ) ;
#line 848
unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq ) ;
#line 850 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
__inline static bool beiscsi_error(struct beiscsi_hba *phba ) 
{ 


  {
#line 852
  return ((bool )((int )phba->ue_detected || (int )phba->fw_timeout));
}
}
#line 100 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
int mgmt_open_connection(struct beiscsi_hba *phba , struct sockaddr *dst_addr , struct beiscsi_endpoint *beiscsi_ep ,
                         struct be_dma_mem *nonemb_cmd ) ;
#line 105
unsigned int mgmt_upload_connection(struct beiscsi_hba *phba , unsigned short cid ,
                                    unsigned int upload_flag ) ;
#line 272
unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba , struct beiscsi_endpoint *beiscsi_ep ,
                                        unsigned short cid , unsigned short issue_reset ,
                                        unsigned short savecfg_flag ) ;
#line 278
int mgmt_set_ip(struct beiscsi_hba *phba , struct iscsi_iface_param_info *ip_param ,
                struct iscsi_iface_param_info *subnet_param , uint32_t boot_proto ) ;
#line 293
int mgmt_get_nic_conf(struct beiscsi_hba *phba , struct be_cmd_get_nic_conf_resp *nic ) ;
#line 296
int mgmt_get_if_info(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_if_info_resp **if_info ) ;
#line 299
int mgmt_get_gateway(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_def_gateway_resp *gateway ) ;
#line 302
int mgmt_set_gateway(struct beiscsi_hba *phba , struct iscsi_iface_param_info *gateway_param ) ;
#line 308
unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba ) ;
#line 310
int mgmt_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) ;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_iscsi.h"
void beiscsi_create_def_ifaces(struct beiscsi_hba *phba ) ;
#line 35
void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba ) ;
#line 37
int be2iscsi_iface_get_param(struct iscsi_iface *iface , enum iscsi_param_type param_type ,
                             int param , char *buf ) ;
#line 41
int be2iscsi_iface_set_param(struct Scsi_Host *shost , void *data , uint32_t dt_len ) ;
#line 44
umode_t be2iscsi_attr_is_visible(int param_type , int param ) ;
#line 46
void beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) ;
#line 53
struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep , unsigned short cmds_max ,
                                                 unsigned short qdepth , unsigned int initial_cmdsn ) ;
#line 58
void beiscsi_session_destroy(struct iscsi_cls_session *cls_session ) ;
#line 60
struct iscsi_cls_conn *beiscsi_conn_create(struct iscsi_cls_session *cls_session ,
                                           unsigned int cid ) ;
#line 63
int beiscsi_conn_bind(struct iscsi_cls_session *cls_session , struct iscsi_cls_conn *cls_conn ,
                      unsigned long long transport_fd , int is_leading ) ;
#line 67
int beiscsi_ep_get_param(struct iscsi_endpoint *ep , enum iscsi_param param , char *buf ) ;
#line 70
int beiscsi_get_host_param(struct Scsi_Host *shost , enum iscsi_host_param param ,
                           char *buf ) ;
#line 73
int beiscsi_get_macaddr(char *buf , struct beiscsi_hba *phba ) ;
#line 75
int beiscsi_set_param(struct iscsi_cls_conn *cls_conn , enum iscsi_param param , char *buf ,
                      int buflen ) ;
#line 78
int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn ) ;
#line 80
struct iscsi_endpoint *beiscsi_ep_connect(struct Scsi_Host *shost , struct sockaddr *dst_addr ,
                                          int non_blocking ) ;
#line 84
int beiscsi_ep_poll(struct iscsi_endpoint *ep , int timeout_ms ) ;
#line 86
void beiscsi_ep_disconnect(struct iscsi_endpoint *ep ) ;
#line 88
void beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn , struct iscsi_stats *stats ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_transport beiscsi_iscsi_transport ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep , unsigned short cmds_max ,
                                                 unsigned short qdepth , unsigned int initial_cmdsn ) 
{ 
  struct Scsi_Host *shost ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_cls_session *cls_session ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 54
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 55
    printk("\vbeiscsi_session_create: invalid ep\n");
#line 57
    return ((struct iscsi_cls_session *)0);
  } else {

  }
#line 59
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 60
  phba = beiscsi_ep->phba;
#line 62
  if ((phba->state & 4U) != 0U) {
#line 63
    log_value = phba->attr_log_enable;
#line 63
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 63
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : PCI_ERROR Recovery\n",
                 64);
    } else {

    }
#line 65
    return ((struct iscsi_cls_session *)0);
  } else {
#line 67
    log_value___0 = phba->attr_log_enable;
#line 67
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 67
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : In beiscsi_session_create\n", 68);
    } else {

    }
  }
#line 71
  if ((unsigned int )cmds_max > (beiscsi_ep->phba)->params.wrbs_per_cxn) {
#line 72
    log_value___1 = phba->attr_log_enable;
#line 72
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 72
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Cannot handle %d cmds.Max cmds per session supported is %d. Using %d.\n",
                 77, (int )cmds_max, (beiscsi_ep->phba)->params.wrbs_per_cxn, (beiscsi_ep->phba)->params.wrbs_per_cxn);
    } else {

    }
#line 79
    cmds_max = (u16 )(beiscsi_ep->phba)->params.wrbs_per_cxn;
  } else {

  }
#line 82
  shost = phba->shost;
#line 83
  cls_session = iscsi_session_setup(& beiscsi_iscsi_transport, shost, (int )cmds_max,
                                    8, 88, initial_cmdsn, 4294967295U);
#line 88
  if ((unsigned long )cls_session == (unsigned long )((struct iscsi_cls_session *)0)) {
#line 89
    return ((struct iscsi_cls_session *)0);
  } else {

  }
#line 90
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 91
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 92
  beiscsi_sess->bhs_pool = dma_pool_create("beiscsi_bhs_pool", & (phba->pcidev)->dev,
                                           324UL, 64UL, 0UL);
#line 96
  if ((unsigned long )beiscsi_sess->bhs_pool == (unsigned long )((struct dma_pool *)0)) {
#line 97
    goto destroy_sess;
  } else {

  }
#line 99
  return (cls_session);
  destroy_sess: 
#line 101
  iscsi_session_teardown(cls_session);
#line 102
  return ((struct iscsi_cls_session *)0);
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_session_destroy(struct iscsi_cls_session *cls_session ) 
{ 
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;

  {
#line 114
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 115
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 117
  printk("\016In beiscsi_session_destroy\n");
#line 118
  dma_pool_destroy(beiscsi_sess->bhs_pool);
#line 119
  iscsi_session_teardown(cls_session);
#line 120
  return;
}
}
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_cls_conn *beiscsi_conn_create(struct iscsi_cls_session *cls_session ,
                                           unsigned int cid ) 
{ 
  struct beiscsi_hba *phba ;
  struct Scsi_Host *shost ;
  struct iscsi_cls_conn *cls_conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct iscsi_conn *conn ;
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;
  void *tmp ;
  uint32_t log_value ;

  {
#line 138
  shost = dev_to_shost(cls_session->dev.parent);
#line 139
  tmp = shost_priv(shost);
#line 139
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 141
  log_value = phba->attr_log_enable;
#line 141
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 141
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_create ,cidfrom iscsi layer=%d\n",
               143, cid);
  } else {

  }
#line 145
  cls_conn = iscsi_conn_setup(cls_session, 80, cid);
#line 146
  if ((unsigned long )cls_conn == (unsigned long )((struct iscsi_cls_conn *)0)) {
#line 147
    return ((struct iscsi_cls_conn *)0);
  } else {

  }
#line 149
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 150
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 151
  beiscsi_conn->ep = (struct beiscsi_endpoint *)0;
#line 152
  beiscsi_conn->phba = phba;
#line 153
  beiscsi_conn->conn = conn;
#line 154
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 155
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 156
  beiscsi_conn->beiscsi_sess = beiscsi_sess;
#line 157
  return (cls_conn);
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_bindconn_cid(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                unsigned int cid ) 
{ 
  uint16_t cri_index ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 170
  cri_index = phba->cid_to_cri_map[cid];
#line 172
  if ((unsigned long )*(phba->conn_table + (unsigned long )cri_index) != (unsigned long )((struct beiscsi_conn *)0)) {
#line 173
    log_value = phba->attr_log_enable;
#line 173
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 173
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Connection table already occupied. Detected clash\n",
                 174);
    } else {

    }
#line 176
    return (-22);
  } else {
#line 178
    log_value___0 = phba->attr_log_enable;
#line 178
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 178
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : phba->conn_table[%d]=%p(beiscsi_conn)\n", 180, (int )cri_index,
                 beiscsi_conn);
    } else {

    }
#line 182
    *(phba->conn_table + (unsigned long )cri_index) = beiscsi_conn;
  }
#line 184
  return (0);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_conn_bind(struct iscsi_cls_session *cls_session , struct iscsi_cls_conn *cls_conn ,
                      unsigned long long transport_fd , int is_leading ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  int tmp___1 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___2 ;

  {
#line 199
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 200
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 201
  tmp = dev_to_shost(cls_session->dev.parent);
#line 201
  shost = tmp;
#line 202
  tmp___0 = shost_priv(shost);
#line 202
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
#line 203
  phwi_ctrlr = phba->phwi_ctrlr;
#line 208
  ep = iscsi_lookup_endpoint(transport_fd);
#line 209
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 210
    return (-22);
  } else {

  }
#line 212
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 214
  tmp___1 = iscsi_conn_bind(cls_session, cls_conn, is_leading);
#line 214
  if (tmp___1 != 0) {
#line 215
    return (-22);
  } else {

  }
#line 217
  if ((unsigned long )beiscsi_ep->phba != (unsigned long )phba) {
#line 218
    log_value = phba->attr_log_enable;
#line 218
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 218
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_ep->hba=%p not equal to phba=%p\n",
                 220, beiscsi_ep->phba, phba);
    } else {

    }
#line 222
    return (-17);
  } else {

  }
#line 225
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid];
#line 228
  beiscsi_conn->beiscsi_conn_cid = (u32 )beiscsi_ep->ep_cid;
#line 229
  beiscsi_conn->ep = beiscsi_ep;
#line 230
  beiscsi_ep->conn = beiscsi_conn;
#line 231
  beiscsi_conn->doorbell_offset = pwrb_context->doorbell_offset;
#line 233
  log_value___0 = phba->attr_log_enable;
#line 233
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 233
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_conn=%p conn=%p ep_cid=%d\n",
               235, beiscsi_conn, conn, (int )beiscsi_ep->ep_cid);
  } else {

  }
#line 237
  tmp___2 = beiscsi_bindconn_cid(phba, beiscsi_conn, (unsigned int )beiscsi_ep->ep_cid);
#line 237
  return (tmp___2);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_create_ipv4_iface(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;

  {
#line 242
  if ((unsigned long )phba->ipv4_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 243
    return (0);
  } else {

  }
#line 245
  phba->ipv4_iface = iscsi_create_iface(phba->shost, & beiscsi_iscsi_transport, 1U,
                                        0U, 0);
#line 249
  if ((unsigned long )phba->ipv4_iface == (unsigned long )((struct iscsi_iface *)0)) {
#line 250
    log_value = phba->attr_log_enable;
#line 250
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 250
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Could not create default IPv4 address.\n",
                 252);
    } else {

    }
#line 253
    return (-19);
  } else {

  }
#line 256
  return (0);
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_create_ipv6_iface(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;

  {
#line 261
  if ((unsigned long )phba->ipv6_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 262
    return (0);
  } else {

  }
#line 264
  phba->ipv6_iface = iscsi_create_iface(phba->shost, & beiscsi_iscsi_transport, 2U,
                                        0U, 0);
#line 268
  if ((unsigned long )phba->ipv6_iface == (unsigned long )((struct iscsi_iface *)0)) {
#line 269
    log_value = phba->attr_log_enable;
#line 269
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 269
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Could not create default IPv6 address.\n",
                 271);
    } else {

    }
#line 272
    return (-19);
  } else {

  }
#line 275
  return (0);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_create_def_ifaces(struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_if_info_resp *if_info ;
  int tmp ;
  int tmp___0 ;

  {
#line 282
  tmp = mgmt_get_if_info(phba, 1, & if_info);
#line 282
  if (tmp == 0) {
#line 283
    beiscsi_create_ipv4_iface(phba);
#line 284
    kfree((void const   *)if_info);
  } else {

  }
#line 287
  tmp___0 = mgmt_get_if_info(phba, 16, & if_info);
#line 287
  if (tmp___0 == 0) {
#line 288
    beiscsi_create_ipv6_iface(phba);
#line 289
    kfree((void const   *)if_info);
  } else {

  }
#line 291
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba ) 
{ 


  {
#line 295
  if ((unsigned long )phba->ipv6_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 296
    iscsi_destroy_iface(phba->ipv6_iface);
  } else {

  }
#line 297
  if ((unsigned long )phba->ipv4_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 298
    iscsi_destroy_iface(phba->ipv4_iface);
  } else {

  }
#line 299
  return;
}
}
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_static_ip(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                                 void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_iface_param_info *iface_ip ;
  struct iscsi_iface_param_info *iface_subnet ;
  struct nlattr *nla ;
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 306
  tmp = shost_priv(shost);
#line 306
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 307
  iface_ip = (struct iscsi_iface_param_info *)0;
#line 308
  iface_subnet = (struct iscsi_iface_param_info *)0;
#line 313
  switch ((int )iface_param->param) {
  case 4: 
#line 315
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 1);
#line 316
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
#line 317
    tmp___0 = nla_data((struct nlattr  const  *)nla);
#line 317
    iface_ip = (struct iscsi_iface_param_info *)tmp___0;
  } else {

  }
#line 319
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 2);
#line 320
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
#line 321
    tmp___1 = nla_data((struct nlattr  const  *)nla);
#line 321
    iface_subnet = (struct iscsi_iface_param_info *)tmp___1;
  } else {

  }
#line 322
  goto ldv_54867;
  case 1: 
#line 324
  iface_ip = iface_param;
#line 325
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 2);
#line 326
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
#line 327
    tmp___2 = nla_data((struct nlattr  const  *)nla);
#line 327
    iface_subnet = (struct iscsi_iface_param_info *)tmp___2;
  } else {

  }
#line 328
  goto ldv_54867;
  case 2: 
#line 330
  iface_subnet = iface_param;
#line 331
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 1);
#line 332
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
#line 333
    tmp___3 = nla_data((struct nlattr  const  *)nla);
#line 333
    iface_ip = (struct iscsi_iface_param_info *)tmp___3;
  } else {

  }
#line 334
  goto ldv_54867;
  default: 
#line 336
  log_value = phba->attr_log_enable;
#line 336
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 336
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Unsupported param %d\n",
               338, (int )iface_param->param);
  } else {

  }
  }
  ldv_54867: ;
#line 341
  if ((unsigned long )iface_ip == (unsigned long )((struct iscsi_iface_param_info *)0) || (unsigned long )iface_subnet == (unsigned long )((struct iscsi_iface_param_info *)0)) {
#line 342
    log_value___0 = phba->attr_log_enable;
#line 342
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 342
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : IP and Subnet Mask required\n",
                 343);
    } else {

    }
#line 344
    return (-22);
  } else {

  }
#line 347
  ret = mgmt_set_ip(phba, iface_ip, iface_subnet, 1U);
#line 350
  return (ret);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_vlan_tag(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;
  unsigned int tmp___0 ;
  uint32_t log_value___0 ;

  {
#line 369
  tmp = shost_priv(shost);
#line 369
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 370
  ret = 0;
#line 373
  tmp___0 = mgmt_get_all_if_id(phba);
#line 373
  if (tmp___0 != 0U) {
#line 374
    log_value = phba->attr_log_enable;
#line 374
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 374
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Interface Handle Failed\n",
                 375);
    } else {

    }
#line 376
    return (-5);
  } else {

  }
#line 379
  switch ((int )iface_param->param) {
  case 15: ;
#line 381
  if ((unsigned int )iface_param->value[0] != 2U) {
#line 382
    ret = mgmt_set_vlan(phba, 65535);
  } else {

  }
#line 383
  goto ldv_54881;
  case 16: 
#line 385
  ret = mgmt_set_vlan(phba, (int )*((uint16_t *)(& iface_param->value)));
#line 387
  goto ldv_54881;
  default: 
#line 389
  log_value___0 = phba->attr_log_enable;
#line 389
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 389
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Unknown Param Type : %d\n",
               391, (int )iface_param->param);
  } else {

  }
#line 392
  return (-38);
  }
  ldv_54881: ;
#line 394
  return (ret);
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_ipv4(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                            void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 403
  tmp = shost_priv(shost);
#line 403
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 404
  ret = 0;
#line 407
  switch ((int )iface_param->param) {
  case 3: 
#line 409
  ret = mgmt_set_gateway(phba, iface_param);
#line 410
  goto ldv_54894;
  case 4: ;
#line 412
  if ((unsigned int )iface_param->value[0] == 2U) {
#line 413
    ret = mgmt_set_ip(phba, iface_param, (struct iscsi_iface_param_info *)0, 2U);
  } else
#line 415
  if ((unsigned int )iface_param->value[0] == 1U) {
#line 416
    ret = beiscsi_set_static_ip(shost, iface_param, data, dt_len);
  } else {
#line 419
    log_value = phba->attr_log_enable;
#line 419
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 419
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid BOOTPROTO: %d\n",
                 421, (int )iface_param->value[0]);
    } else {

    }
  }
#line 422
  goto ldv_54894;
  case 12: ;
#line 424
  if ((unsigned int )iface_param->value[0] == 2U) {
#line 425
    ret = beiscsi_create_ipv4_iface(phba);
  } else {
#line 427
    iscsi_destroy_iface(phba->ipv4_iface);
  }
#line 428
  goto ldv_54894;
  case 2: ;
  case 1: 
#line 431
  ret = beiscsi_set_static_ip(shost, iface_param, data, dt_len);
#line 433
  goto ldv_54894;
  case 15: ;
  case 16: 
#line 436
  ret = beiscsi_set_vlan_tag(shost, iface_param);
#line 437
  goto ldv_54894;
  default: 
#line 439
  log_value___0 = phba->attr_log_enable;
#line 439
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 439
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Param %d not supported\n",
               441, (int )iface_param->param);
  } else {

  }
  }
  ldv_54894: ;
#line 444
  return (ret);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_ipv6(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                            void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;

  {
#line 452
  tmp = shost_priv(shost);
#line 452
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 453
  ret = 0;
#line 455
  switch ((int )iface_param->param) {
  case 12: ;
#line 457
  if ((unsigned int )iface_param->value[0] == 2U) {
#line 458
    ret = beiscsi_create_ipv6_iface(phba);
  } else {
#line 460
    iscsi_destroy_iface(phba->ipv6_iface);
#line 461
    ret = 0;
  }
#line 463
  goto ldv_54913;
  case 7: 
#line 465
  ret = mgmt_set_ip(phba, iface_param, (struct iscsi_iface_param_info *)0, 1U);
#line 467
  goto ldv_54913;
  default: 
#line 469
  log_value = phba->attr_log_enable;
#line 469
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 469
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Param %d not supported\n",
               471, (int )iface_param->param);
  } else {

  }
  }
  ldv_54913: ;
#line 474
  return (ret);
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int be2iscsi_iface_set_param(struct Scsi_Host *shost , void *data , uint32_t dt_len ) 
{ 
  struct iscsi_iface_param_info *iface_param ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct nlattr *attrib ;
  uint32_t rm_len ;
  int ret ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  int tmp___1 ;

  {
#line 480
  iface_param = (struct iscsi_iface_param_info *)0;
#line 481
  tmp = shost_priv(shost);
#line 481
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 483
  rm_len = dt_len;
#line 484
  ret = 0;
#line 486
  if ((phba->state & 4U) != 0U) {
#line 487
    log_value = phba->attr_log_enable;
#line 487
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 487
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 488);
    } else {

    }
#line 489
    return (-16);
  } else {

  }
#line 492
  attrib = (struct nlattr *)data;
#line 492
  rm_len = dt_len;
#line 492
  goto ldv_54936;
  ldv_54935: 
#line 493
  tmp___0 = nla_data((struct nlattr  const  *)attrib);
#line 493
  iface_param = (struct iscsi_iface_param_info *)tmp___0;
#line 495
  if ((unsigned int )iface_param->param_type != 2U) {
#line 496
    goto ldv_54928;
  } else {

  }
#line 501
  if (iface_param->iface_num != 0U) {
#line 502
    log_value___0 = phba->attr_log_enable;
#line 502
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 502
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid iface_num %d.Only iface_num 0 is supported.\n",
                 505, iface_param->iface_num);
    } else {

    }
#line 507
    return (-22);
  } else {

  }
#line 510
  switch ((int )iface_param->iface_type) {
  case 1: 
#line 512
  ret = beiscsi_set_ipv4(shost, iface_param, data, dt_len);
#line 514
  goto ldv_54931;
  case 2: 
#line 516
  ret = beiscsi_set_ipv6(shost, iface_param, data, dt_len);
#line 518
  goto ldv_54931;
  default: 
#line 520
  log_value___1 = phba->attr_log_enable;
#line 520
  if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 520
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid iface type :%d passed\n",
               522, (int )iface_param->iface_type);
  } else {

  }
#line 523
  goto ldv_54931;
  }
  ldv_54931: ;
#line 526
  if (ret != 0) {
#line 527
    return (ret);
  } else {

  }
  ldv_54928: 
#line 492
  attrib = nla_next((struct nlattr  const  *)attrib, (int *)(& rm_len));
  ldv_54936: 
#line 492
  tmp___1 = nla_ok((struct nlattr  const  *)attrib, (int )rm_len);
#line 492
  if (tmp___1 != 0) {
#line 494
    goto ldv_54935;
  } else {

  }

#line 530
  return (ret);
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int be2iscsi_get_if_param(struct beiscsi_hba *phba , struct iscsi_iface *iface ,
                                 int param , char *buf ) 
{ 
  struct be_cmd_get_if_info_resp *if_info ;
  int len ;
  int ip_type ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 538
  ip_type = 1;
#line 540
  if (iface->iface_type == 2U) {
#line 541
    ip_type = 16;
  } else {

  }
#line 543
  len = mgmt_get_if_info(phba, ip_type, & if_info);
#line 544
  if (len != 0) {
#line 545
    return (len);
  } else {

  }
#line 547
  switch (param) {
  case 1: 
#line 549
  len = sprintf(buf, "%pI4\n", (u8 *)(& if_info->ip_addr.addr));
#line 550
  goto ldv_54948;
  case 7: 
#line 552
  len = sprintf(buf, "%pI6\n", (u8 *)(& if_info->ip_addr.addr));
#line 553
  goto ldv_54948;
  case 4: ;
#line 555
  if (if_info->dhcp_state == 0U) {
#line 556
    len = sprintf(buf, "static\n");
  } else {
#line 558
    len = sprintf(buf, "dhcp\n");
  }
#line 559
  goto ldv_54948;
  case 2: 
#line 561
  len = sprintf(buf, "%pI4\n", (u8 *)(& if_info->ip_addr.subnet_mask));
#line 562
  goto ldv_54948;
  case 15: 
#line 564
  len = sprintf(buf, "%s\n", if_info->vlan_priority == 65535U ? (char *)"Disabled\n" : (char *)"Enabled\n");
#line 567
  goto ldv_54948;
  case 13: ;
#line 569
  if (if_info->vlan_priority == 65535U) {
#line 570
    len = -22;
  } else {
#line 572
    len = sprintf(buf, "%d\n", if_info->vlan_priority & 4095U);
  }
#line 575
  goto ldv_54948;
  case 14: ;
#line 577
  if (if_info->vlan_priority == 65535U) {
#line 578
    len = -22;
  } else {
#line 580
    len = sprintf(buf, "%d\n", (if_info->vlan_priority >> 13) & 7U);
  }
#line 583
  goto ldv_54948;
  default: 
#line 585
  __ret_warn_on = 1;
#line 585
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 585
  if (tmp != 0L) {
#line 585
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c",
                       585);
  } else {

  }
#line 585
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_54948: 
#line 588
  kfree((void const   *)if_info);
#line 589
  return (len);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int be2iscsi_iface_get_param(struct iscsi_iface *iface , enum iscsi_param_type param_type ,
                             int param , char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct be_cmd_get_def_gateway_resp gateway ;
  int len ;
  uint32_t log_value ;

  {
#line 596
  tmp = dev_to_shost(iface->dev.parent);
#line 596
  shost = tmp;
#line 597
  tmp___0 = shost_priv(shost);
#line 597
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
#line 599
  len = -38;
#line 601
  if ((phba->state & 4U) != 0U) {
#line 602
    log_value = phba->attr_log_enable;
#line 602
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 602
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 603);
    } else {

    }
#line 604
    return (-16);
  } else {

  }
#line 607
  switch (param) {
  case 1: ;
  case 2: ;
  case 4: ;
  case 7: ;
  case 15: ;
  case 13: ;
  case 14: 
#line 615
  len = be2iscsi_get_if_param(phba, iface, param, buf);
#line 616
  goto ldv_54976;
  case 12: 
#line 618
  len = sprintf(buf, "enabled\n");
#line 619
  goto ldv_54976;
  case 3: 
#line 621
  memset((void *)(& gateway), 0, 40UL);
#line 622
  len = mgmt_get_gateway(phba, 1, & gateway);
#line 623
  if (len == 0) {
#line 624
    len = sprintf(buf, "%pI4\n", & gateway.ip_addr.addr);
  } else {

  }
#line 625
  goto ldv_54976;
  default: 
#line 627
  len = -38;
  }
  ldv_54976: ;
#line 630
  return (len);
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_ep_get_param(struct iscsi_endpoint *ep , enum iscsi_param param , char *buf ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  int len ;
  uint32_t log_value ;

  {
#line 644
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 645
  len = 0;
#line 647
  log_value = (beiscsi_ep->phba)->attr_log_enable;
#line 647
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 647
    dev_printk("\016", (struct device  const  *)(& ((beiscsi_ep->phba)->shost)->shost_gendev),
               "BS_%d : In beiscsi_ep_get_param, param= %d\n", 650, (unsigned int )param);
  } else {

  }
#line 652
  switch ((unsigned int )param) {
  case 20U: 
#line 654
  len = sprintf(buf, "%hu\n", (int )beiscsi_ep->dst_tcpport);
#line 655
  goto ldv_54989;
  case 21U: ;
#line 657
  if ((unsigned int )beiscsi_ep->ip_type == 1U) {
#line 658
    len = sprintf(buf, "%pI4\n", & beiscsi_ep->dst_addr);
  } else {
#line 660
    len = sprintf(buf, "%pI6\n", & beiscsi_ep->dst6_addr);
  }
#line 661
  goto ldv_54989;
  default: ;
#line 663
  return (-38);
  }
  ldv_54989: ;
#line 665
  return (len);
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_set_param(struct iscsi_cls_conn *cls_conn , enum iscsi_param param , char *buf ,
                      int buflen ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct beiscsi_hba *phba ;
  int ret ;
  uint32_t log_value ;

  {
#line 671
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 672
  session = conn->session;
#line 673
  phba = (struct beiscsi_hba *)0;
#line 676
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 677
  log_value = phba->attr_log_enable;
#line 677
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 677
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_set_param, param= %d\n",
               679, (unsigned int )param);
  } else {

  }
#line 681
  ret = iscsi_set_param(cls_conn, param, buf, buflen);
#line 682
  if (ret != 0) {
#line 683
    return (ret);
  } else {

  }
#line 688
  switch ((unsigned int )param) {
  case 7U: ;
#line 690
  if (session->first_burst > 8192U) {
#line 691
    session->first_burst = 8192U;
  } else {

  }
#line 692
  goto ldv_55004;
  case 0U: ;
#line 694
  if (conn->max_recv_dlength > 65536U) {
#line 695
    conn->max_recv_dlength = 65536U;
  } else {

  }
#line 696
  goto ldv_55004;
  case 8U: ;
#line 698
  if (session->max_burst > 262144U) {
#line 699
    session->max_burst = 262144U;
  } else {

  }
#line 700
  goto ldv_55004;
  case 1U: ;
#line 702
  if (conn->max_xmit_dlength > 65536U) {
#line 703
    conn->max_xmit_dlength = 65536U;
  } else {

  }
  default: ;
#line 705
  return (0);
  }
  ldv_55004: ;
#line 708
  return (0);
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_initname(char *buf , struct beiscsi_hba *phba ) 
{ 
  int rc ;
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_hba_name *resp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp ;

  {
#line 725
  tag = be_cmd_get_initname(phba);
#line 726
  if (tag == 0U) {
#line 727
    log_value = phba->attr_log_enable;
#line 727
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 727
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Initiator Name Failed\n",
                 728);
    } else {

    }
#line 730
    return (-16);
  } else {

  }
#line 733
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
#line 734
  if (rc != 0) {
#line 735
    log_value___0 = phba->attr_log_enable;
#line 735
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 735
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Initiator Name MBX Failed\n",
                 737);
    } else {

    }
#line 738
    return (rc);
  } else {

  }
#line 741
  tmp = embedded_payload(wrb);
#line 741
  resp = (struct be_cmd_hba_name *)tmp;
#line 742
  rc = sprintf(buf, "%s\n", (u8 *)(& resp->initiator_name));
#line 743
  return (rc);
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_get_port_state(struct Scsi_Host *shost ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_cls_host *ihost ;

  {
#line 753
  tmp = shost_priv(shost);
#line 753
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 754
  ihost = (struct iscsi_cls_host *)shost->shost_data;
#line 756
  ihost->port_state = phba->state == 1U ? 2U : 1U;
#line 757
  return;
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_port_speed(struct Scsi_Host *shost ) 
{ 
  int rc ;
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_ntwk_link_status_resp *resp ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_cls_host *ihost ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp___0 ;

  {
#line 772
  tmp = shost_priv(shost);
#line 772
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 773
  ihost = (struct iscsi_cls_host *)shost->shost_data;
#line 775
  tag = be_cmd_get_port_speed(phba);
#line 776
  if (tag == 0U) {
#line 777
    log_value = phba->attr_log_enable;
#line 777
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 777
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Port Speed Failed\n",
                 778);
    } else {

    }
#line 780
    return (-16);
  } else {

  }
#line 782
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
#line 783
  if (rc != 0) {
#line 784
    log_value___0 = phba->attr_log_enable;
#line 784
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 784
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Port Speed MBX Failed\n",
                 786);
    } else {

    }
#line 787
    return (rc);
  } else {

  }
#line 789
  tmp___0 = embedded_payload(wrb);
#line 789
  resp = (struct be_cmd_ntwk_link_status_resp *)tmp___0;
#line 791
  switch ((int )resp->mac_speed) {
  case 1: 
#line 793
  ihost->port_speed = 2U;
#line 794
  goto ldv_55036;
  case 2: 
#line 796
  ihost->port_speed = 4U;
#line 797
  goto ldv_55036;
  case 3: 
#line 799
  ihost->port_speed = 8U;
#line 800
  goto ldv_55036;
  case 4: 
#line 802
  ihost->port_speed = 16U;
#line 803
  goto ldv_55036;
  default: 
#line 805
  ihost->port_speed = 1U;
  }
  ldv_55036: ;
#line 807
  return (0);
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_get_host_param(struct Scsi_Host *shost , enum iscsi_host_param param ,
                           char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int status ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  char *tmp___0 ;
  uint32_t log_value___3 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 821
  tmp = shost_priv(shost);
#line 821
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 822
  status = 0;
#line 825
  if ((phba->state & 4U) != 0U) {
#line 826
    log_value = phba->attr_log_enable;
#line 826
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 826
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 827);
    } else {

    }
#line 828
    return (-16);
  } else {
#line 830
    log_value___0 = phba->attr_log_enable;
#line 830
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 830
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : In beiscsi_get_host_param, param = %d\n", 832, (unsigned int )param);
    } else {

    }
  }
#line 835
  switch ((unsigned int )param) {
  case 0U: 
#line 837
  status = beiscsi_get_macaddr(buf, phba);
#line 838
  if (status < 0) {
#line 839
    log_value___1 = phba->attr_log_enable;
#line 839
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 839
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_get_macaddr Failed\n",
                 840);
    } else {

    }
#line 841
    return (status);
  } else {

  }
#line 843
  goto ldv_55052;
  case 1U: 
#line 845
  status = beiscsi_get_initname(buf, phba);
#line 846
  if (status < 0) {
#line 847
    log_value___2 = phba->attr_log_enable;
#line 847
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 847
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Retreiving Initiator Name Failed\n",
                 848);
    } else {

    }
#line 849
    return (status);
  } else {

  }
#line 851
  goto ldv_55052;
  case 4U: 
#line 853
  beiscsi_get_port_state(shost);
#line 854
  tmp___0 = iscsi_get_port_state_name(shost);
#line 854
  status = sprintf(buf, "%s\n", tmp___0);
#line 855
  goto ldv_55052;
  case 5U: 
#line 857
  status = beiscsi_get_port_speed(shost);
#line 858
  if (status != 0) {
#line 859
    log_value___3 = phba->attr_log_enable;
#line 859
    if ((log_value___3 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 859
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Retreiving Port Speed Failed\n",
                 860);
    } else {

    }
#line 861
    return (status);
  } else {

  }
#line 863
  tmp___1 = iscsi_get_port_speed_name(shost);
#line 863
  status = sprintf(buf, "%s\n", tmp___1);
#line 864
  goto ldv_55052;
  default: 
#line 866
  tmp___2 = iscsi_host_get_param(shost, param, buf);
#line 866
  return (tmp___2);
  }
  ldv_55052: ;
#line 868
  return (status);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_get_macaddr(char *buf , struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_nic_conf_resp resp ;
  int rc ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 876
  if ((int )phba->mac_addr_set) {
#line 877
    tmp = sysfs_format_mac(buf, (unsigned char const   *)(& phba->mac_address), 6);
#line 877
    return ((int )tmp);
  } else {

  }
#line 879
  memset((void *)(& resp), 0, 136UL);
#line 880
  rc = mgmt_get_nic_conf(phba, & resp);
#line 881
  if (rc != 0) {
#line 882
    return (rc);
  } else {

  }
#line 884
  phba->mac_addr_set = 1;
#line 885
  memcpy((void *)(& phba->mac_address), (void const   *)(& resp.mac_address), 6UL);
#line 886
  tmp___0 = sysfs_format_mac(buf, (unsigned char const   *)(& phba->mac_address),
                             6);
#line 886
  return ((int )tmp___0);
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn , struct iscsi_stats *stats ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;

  {
#line 899
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 900
  phba = (struct beiscsi_hba *)0;
#line 902
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 903
  log_value = phba->attr_log_enable;
#line 903
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 903
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_get_stats\n",
               904);
  } else {

  }
#line 906
  stats->txdata_octets = conn->txdata_octets;
#line 907
  stats->rxdata_octets = conn->rxdata_octets;
#line 908
  stats->dataout_pdus = conn->dataout_pdus_cnt;
#line 909
  stats->scsirsp_pdus = conn->scsirsp_pdus_cnt;
#line 910
  stats->scsicmd_pdus = conn->scsicmd_pdus_cnt;
#line 911
  stats->datain_pdus = conn->datain_pdus_cnt;
#line 912
  stats->tmfrsp_pdus = (uint32_t )conn->tmfrsp_pdus_cnt;
#line 913
  stats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;
#line 914
  stats->r2t_pdus = conn->r2t_pdus_cnt;
#line 915
  stats->digest_err = 0U;
#line 916
  stats->timeout_err = 0U;
#line 917
  stats->custom_length = 1U;
#line 918
  strcpy((char *)(& stats->custom[0].desc), "eh_abort_cnt");
#line 919
  stats->custom[0].value = (uint64_t )conn->eh_abort_cnt;
#line 920
  return;
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_set_params_for_offld(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;

  {
#line 930
  conn = beiscsi_conn->conn;
#line 931
  session = conn->session;
#line 933
  tmp = amap_mask(32U);
#line 933
  amap_set((void *)params, 0U, tmp, 0U, session->max_burst);
#line 935
  tmp___0 = amap_mask(32U);
#line 935
  amap_set((void *)params, 1U, tmp___0, 0U, conn->max_xmit_dlength);
#line 938
  tmp___1 = amap_mask(32U);
#line 938
  amap_set((void *)params, 2U, tmp___1, 0U, session->first_burst);
#line 940
  tmp___2 = amap_mask(2U);
#line 940
  amap_set((void *)params, 3U, tmp___2, 0U, (u32 )session->erl);
#line 942
  tmp___3 = amap_mask(1U);
#line 942
  amap_set((void *)params, 3U, tmp___3, 2U, (u32 )conn->datadgst_en);
#line 944
  tmp___4 = amap_mask(1U);
#line 944
  amap_set((void *)params, 3U, tmp___4, 3U, (u32 )conn->hdrdgst_en);
#line 946
  tmp___5 = amap_mask(1U);
#line 946
  amap_set((void *)params, 3U, tmp___5, 4U, (u32 )session->initial_r2t_en);
#line 948
  tmp___6 = amap_mask(1U);
#line 948
  amap_set((void *)params, 3U, tmp___6, 5U, (u32 )session->imm_data_en);
#line 950
  tmp___7 = amap_mask(1U);
#line 950
  amap_set((void *)params, 3U, tmp___7, 6U, (u32 )session->dataseq_inorder_en);
#line 953
  tmp___8 = amap_mask(1U);
#line 953
  amap_set((void *)params, 3U, tmp___8, 7U, (u32 )session->pdu_inorder_en);
#line 956
  tmp___9 = amap_mask(16U);
#line 956
  amap_set((void *)params, 3U, tmp___9, 8U, (u32 )session->max_r2t);
#line 958
  tmp___10 = amap_mask(32U);
#line 958
  amap_set((void *)params, 4U, tmp___10, 0U, conn->exp_statsn - 1U);
#line 960
  tmp___11 = amap_mask(32U);
#line 960
  amap_set((void *)params, 5U, tmp___11, 0U, conn->max_recv_dlength);
#line 961
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_offload_params params ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 972
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 973
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 978
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 980
  if ((phba->state & 4U) != 0U) {
#line 981
    log_value = phba->attr_log_enable;
#line 981
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 981
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 982);
    } else {

    }
#line 983
    return (-16);
  } else {
#line 985
    log_value___0 = (beiscsi_conn->phba)->attr_log_enable;
#line 985
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 985
      dev_printk("\016", (struct device  const  *)(& ((beiscsi_conn->phba)->shost)->shost_gendev),
                 "BS_%d : In beiscsi_conn_start\n", 987);
    } else {

    }
  }
#line 990
  memset((void *)(& params), 0, 24UL);
#line 991
  beiscsi_ep = beiscsi_conn->ep;
#line 992
  if ((unsigned long )beiscsi_ep == (unsigned long )((struct beiscsi_endpoint *)0)) {
#line 993
    log_value___1 = (beiscsi_conn->phba)->attr_log_enable;
#line 993
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 993
      dev_printk("\v", (struct device  const  *)(& ((beiscsi_conn->phba)->shost)->shost_gendev),
                 "BS_%d : In beiscsi_conn_start , no beiscsi_ep\n", 995);
    } else {

    }
  } else {

  }
#line 997
  beiscsi_conn->login_in_progress = 0U;
#line 998
  beiscsi_set_params_for_offld(beiscsi_conn, & params);
#line 999
  beiscsi_offload_connection(beiscsi_conn, & params);
#line 1000
  iscsi_conn_start(cls_conn);
#line 1001
  return (0);
}
}
#line 1008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_cid(struct beiscsi_hba *phba ) 
{ 
  unsigned short cid ;
  unsigned short cid_from_ulp ;
  struct ulp_cid_info *cid_info ;
  uint16_t cid_avlbl_ulp0 ;
  uint16_t cid_avlbl_ulp1 ;
  unsigned short tmp ;
  int tmp___0 ;

  {
#line 1010
  cid = 65535U;
#line 1011
  cid_info = (struct ulp_cid_info *)0;
#line 1015
  cid_avlbl_ulp0 = (unsigned long )phba->cid_array_info[0] != (unsigned long )((struct ulp_cid_info *)0) ? (phba->cid_array_info[0])->avlbl_cids : 0U;
#line 1017
  cid_avlbl_ulp1 = (unsigned long )phba->cid_array_info[1] != (unsigned long )((struct ulp_cid_info *)0) ? (phba->cid_array_info[1])->avlbl_cids : 0U;
#line 1019
  cid_from_ulp = (int )cid_avlbl_ulp0 <= (int )cid_avlbl_ulp1;
#line 1022
  tmp___0 = variable_test_bit((long )cid_from_ulp, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 1022
  if (tmp___0 != 0) {
#line 1023
    cid_info = phba->cid_array_info[(int )cid_from_ulp];
#line 1024
    if ((unsigned int )cid_info->avlbl_cids == 0U) {
#line 1025
      return ((int )cid);
    } else {

    }
#line 1027
    tmp = cid_info->cid_alloc;
#line 1027
    cid_info->cid_alloc = (unsigned short )((int )cid_info->cid_alloc + 1);
#line 1027
    cid = *(cid_info->cid_array + (unsigned long )tmp);
#line 1029
    if ((unsigned int )cid_info->cid_alloc == phba->fw_config.iscsi_cid_count[(int )cid_from_ulp]) {
#line 1031
      cid_info->cid_alloc = 0U;
    } else {

    }
#line 1033
    cid_info->avlbl_cids = (unsigned short )((int )cid_info->avlbl_cids - 1);
  } else {

  }
#line 1035
  return ((int )cid);
}
}
#line 1043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_put_cid(struct beiscsi_hba *phba , unsigned short cid ) 
{ 
  uint16_t cid_post_ulp ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct ulp_cid_info *cid_info ;
  uint16_t cri_index ;
  unsigned short tmp ;

  {
#line 1048
  cid_info = (struct ulp_cid_info *)0;
#line 1049
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 1051
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1052
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1053
  cid_post_ulp = (uint16_t )pwrb_context->ulp_num;
#line 1055
  cid_info = phba->cid_array_info[(int )cid_post_ulp];
#line 1056
  cid_info->avlbl_cids = (unsigned short )((int )cid_info->avlbl_cids + 1);
#line 1058
  tmp = cid_info->cid_free;
#line 1058
  cid_info->cid_free = (unsigned short )((int )cid_info->cid_free + 1);
#line 1058
  *(cid_info->cid_array + (unsigned long )tmp) = cid;
#line 1059
  if ((unsigned int )cid_info->cid_free == phba->fw_config.iscsi_cid_count[(int )cid_post_ulp]) {
#line 1060
    cid_info->cid_free = 0U;
  } else {

  }
#line 1061
  return;
}
}
#line 1067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep ) 
{ 
  struct beiscsi_hba *phba ;
  struct beiscsi_conn *beiscsi_conn ;

  {
#line 1069
  phba = beiscsi_ep->phba;
#line 1072
  beiscsi_put_cid(phba, (int )beiscsi_ep->ep_cid);
#line 1073
  beiscsi_ep->phba = (struct beiscsi_hba *)0;
#line 1074
  *(phba->ep_array + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid]) = (struct iscsi_endpoint *)0;
#line 1082
  if ((unsigned long )beiscsi_ep->conn == (unsigned long )((struct beiscsi_conn *)0)) {
#line 1083
    return;
  } else {

  }
#line 1085
  beiscsi_conn = beiscsi_ep->conn;
#line 1086
  if ((unsigned int )beiscsi_conn->login_in_progress != 0U) {
#line 1087
    beiscsi_free_mgmt_task_handles(beiscsi_conn, beiscsi_conn->task);
#line 1089
    beiscsi_conn->login_in_progress = 0U;
  } else {

  }
#line 1091
  return;
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_open_conn(struct iscsi_endpoint *ep , struct sockaddr *src_addr ,
                             struct sockaddr *dst_addr , int non_blocking ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_hba *phba ;
  struct tcp_connect_and_offload_out *ptcpcnct_out ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int tag ;
  unsigned int req_memsize ;
  int ret ;
  uint32_t log_value ;
  int tmp ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  int tmp___0 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;

  {
#line 1105
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1106
  phba = beiscsi_ep->phba;
#line 1110
  ret = -12;
#line 1112
  log_value = phba->attr_log_enable;
#line 1112
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1112
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_open_conn\n",
               1113);
  } else {

  }
#line 1115
  tmp = beiscsi_get_cid(phba);
#line 1115
  beiscsi_ep->ep_cid = (unsigned short )tmp;
#line 1116
  if ((unsigned int )beiscsi_ep->ep_cid == 65535U) {
#line 1117
    log_value___0 = phba->attr_log_enable;
#line 1117
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1117
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : No free cid available\n",
                 1118);
    } else {

    }
#line 1119
    return (ret);
  } else {

  }
#line 1122
  log_value___1 = phba->attr_log_enable;
#line 1122
  if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1122
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_open_conn, ep_cid=%d\n",
               1124, (int )beiscsi_ep->ep_cid);
  } else {

  }
#line 1126
  *(phba->ep_array + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid]) = ep;
#line 1129
  beiscsi_ep->cid_vld = 0U;
#line 1131
  if (phba->generation == 3U || phba->generation == 2U) {
#line 1132
    req_memsize = 64U;
  } else {
#line 1134
    req_memsize = 72U;
  }
#line 1136
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, (size_t )req_memsize, & nonemb_cmd.dma);
#line 1139
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 1141
    log_value___2 = phba->attr_log_enable;
#line 1141
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1141
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Failed to allocate memory for mgmt_open_connection\n",
                 1143);
    } else {

    }
#line 1145
    beiscsi_free_ep(beiscsi_ep);
#line 1146
    return (-12);
  } else {

  }
#line 1148
  nonemb_cmd.size = req_memsize;
#line 1149
  memset(nonemb_cmd.va, 0, (size_t )nonemb_cmd.size);
#line 1150
  tmp___0 = mgmt_open_connection(phba, dst_addr, beiscsi_ep, & nonemb_cmd);
#line 1150
  tag = (unsigned int )tmp___0;
#line 1151
  if (tag == 0U) {
#line 1152
    log_value___3 = phba->attr_log_enable;
#line 1152
    if ((log_value___3 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1152
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Failed for cid=%d\n",
                 1154, (int )beiscsi_ep->ep_cid);
    } else {

    }
#line 1156
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 1158
    beiscsi_free_ep(beiscsi_ep);
#line 1159
    return (-11);
  } else {

  }
#line 1162
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
#line 1163
  if (ret != 0) {
#line 1164
    log_value___4 = phba->attr_log_enable;
#line 1164
    if ((log_value___4 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1164
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Failed",
                 1166);
    } else {

    }
#line 1168
    if (ret != -16) {
#line 1169
      pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                          nonemb_cmd.dma);
    } else {

    }
#line 1172
    beiscsi_free_ep(beiscsi_ep);
#line 1173
    return (ret);
  } else {

  }
#line 1176
  ptcpcnct_out = (struct tcp_connect_and_offload_out *)nonemb_cmd.va;
#line 1177
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1178
  beiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;
#line 1179
  beiscsi_ep->cid_vld = 1U;
#line 1180
  log_value___5 = phba->attr_log_enable;
#line 1180
  if ((log_value___5 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1180
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Success\n",
               1181);
  } else {

  }
#line 1183
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
#line 1185
  return (0);
}
}
#line 1197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_endpoint *beiscsi_ep_connect(struct Scsi_Host *shost , struct sockaddr *dst_addr ,
                                          int non_blocking ) 
{ 
  struct beiscsi_hba *phba ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t log_value ;
  void *tmp___1 ;
  bool tmp___2 ;
  uint32_t log_value___0 ;
  void *tmp___3 ;
  uint32_t log_value___1 ;
  void *tmp___4 ;
  void *tmp___5 ;
  uint32_t log_value___2 ;
  void *tmp___6 ;

  {
#line 1205
  if ((unsigned long )shost != (unsigned long )((struct Scsi_Host *)0)) {
#line 1206
    tmp = shost_priv(shost);
#line 1206
    phba = (struct beiscsi_hba *)tmp + 224U;
  } else {
#line 1208
    ret = -6;
#line 1209
    printk("\vbeiscsi_ep_connect shost is NULL\n");
#line 1211
    tmp___0 = ERR_PTR((long )ret);
#line 1211
    return ((struct iscsi_endpoint *)tmp___0);
  }
#line 1214
  tmp___2 = beiscsi_error(phba);
#line 1214
  if ((int )tmp___2) {
#line 1215
    ret = -5;
#line 1216
    log_value = phba->attr_log_enable;
#line 1216
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1216
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : The FW state Not Stable!!!\n",
                 1217);
    } else {

    }
#line 1218
    tmp___1 = ERR_PTR((long )ret);
#line 1218
    return ((struct iscsi_endpoint *)tmp___1);
  } else {

  }
#line 1221
  if ((phba->state & 4U) != 0U) {
#line 1222
    ret = -16;
#line 1223
    log_value___0 = phba->attr_log_enable;
#line 1223
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1223
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 1224);
    } else {

    }
#line 1225
    tmp___3 = ERR_PTR((long )ret);
#line 1225
    return ((struct iscsi_endpoint *)tmp___3);
  } else
#line 1226
  if ((phba->state & 2U) != 0U) {
#line 1227
    ret = -16;
#line 1228
    log_value___1 = phba->attr_log_enable;
#line 1228
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1228
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : The Adapter Port state is Down!!!\n",
                 1229);
    } else {

    }
#line 1230
    tmp___4 = ERR_PTR((long )ret);
#line 1230
    return ((struct iscsi_endpoint *)tmp___4);
  } else {

  }
#line 1233
  ep = iscsi_create_endpoint(128);
#line 1234
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 1235
    ret = -12;
#line 1236
    tmp___5 = ERR_PTR((long )ret);
#line 1236
    return ((struct iscsi_endpoint *)tmp___5);
  } else {

  }
#line 1239
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1240
  beiscsi_ep->phba = phba;
#line 1241
  beiscsi_ep->openiscsi_ep = ep;
#line 1242
  ret = beiscsi_open_conn(ep, (struct sockaddr *)0, dst_addr, non_blocking);
#line 1243
  if (ret != 0) {
#line 1244
    log_value___2 = phba->attr_log_enable;
#line 1244
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1244
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Failed in beiscsi_open_conn\n",
                 1245);
    } else {

    }
#line 1246
    goto free_ep;
  } else {

  }
#line 1249
  return (ep);
  free_ep: 
#line 1252
  iscsi_destroy_endpoint(ep);
#line 1253
  tmp___6 = ERR_PTR((long )ret);
#line 1253
  return ((struct iscsi_endpoint *)tmp___6);
}
}
#line 1263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_ep_poll(struct iscsi_endpoint *ep , int timeout_ms ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  uint32_t log_value ;

  {
#line 1265
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1267
  log_value = (beiscsi_ep->phba)->attr_log_enable;
#line 1267
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1267
    dev_printk("\016", (struct device  const  *)(& ((beiscsi_ep->phba)->shost)->shost_gendev),
               "BS_%d : In  beiscsi_ep_poll\n", 1268);
  } else {

  }
#line 1270
  if ((unsigned int )beiscsi_ep->cid_vld == 1U) {
#line 1271
    return (1);
  } else {
#line 1273
    return (0);
  }
}
}
#line 1283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_flush_cq(struct beiscsi_hba *phba ) 
{ 
  uint16_t i ;
  struct be_eq_obj *pbe_eq ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;

  {
#line 1290
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1291
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 1293
  i = 0U;
#line 1293
  goto ldv_55159;
  ldv_55158: 
#line 1294
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 1295
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 1296
  beiscsi_process_cq(pbe_eq);
#line 1297
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 1293
  i = (uint16_t )((int )i + 1);
  ldv_55159: ;
#line 1293
  if ((unsigned int )i < phba->num_cpus) {
#line 1295
    goto ldv_55158;
  } else {

  }

#line 1300
  return;
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_close_conn(struct beiscsi_endpoint *beiscsi_ep , int flag ) 
{ 
  int ret ;
  unsigned int tag ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;

  {
#line 1308
  ret = 0;
#line 1310
  phba = beiscsi_ep->phba;
#line 1312
  tag = mgmt_upload_connection(phba, (int )beiscsi_ep->ep_cid, (unsigned int )flag);
#line 1313
  if (tag == 0U) {
#line 1314
    log_value = phba->attr_log_enable;
#line 1314
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1314
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : upload failed for cid 0x%x\n", 1316, (int )beiscsi_ep->ep_cid);
    } else {

    }
#line 1318
    ret = -11;
  } else {

  }
#line 1321
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1324
  beiscsi_flush_cq(phba);
#line 1326
  return (ret);
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba , unsigned int cid ) 
{ 
  uint16_t cri_index ;
  uint32_t log_value ;

  {
#line 1337
  cri_index = phba->cid_to_cri_map[cid];
#line 1339
  if ((unsigned long )*(phba->conn_table + (unsigned long )cri_index) != (unsigned long )((struct beiscsi_conn *)0)) {
#line 1340
    *(phba->conn_table + (unsigned long )cri_index) = (struct beiscsi_conn *)0;
  } else {
#line 1342
    log_value = phba->attr_log_enable;
#line 1342
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1342
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : Connection table Not occupied.\n", 1343);
    } else {

    }
#line 1344
    return (-22);
  }
#line 1346
  return (0);
}
}
#line 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_ep_disconnect(struct iscsi_endpoint *ep ) 
{ 
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_hba *phba ;
  unsigned int tag ;
  uint8_t mgmt_invalidate_flag ;
  uint8_t tcp_upload_flag ;
  unsigned short savecfg_flag ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 1362
  savecfg_flag = 1U;
#line 1364
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1365
  phba = beiscsi_ep->phba;
#line 1366
  log_value = phba->attr_log_enable;
#line 1366
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1366
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_ep_disconnect for ep_cid = %d\n",
               1368, (int )beiscsi_ep->ep_cid);
  } else {

  }
#line 1370
  if ((unsigned long )beiscsi_ep->conn != (unsigned long )((struct beiscsi_conn *)0)) {
#line 1371
    beiscsi_conn = beiscsi_ep->conn;
#line 1372
    iscsi_suspend_queue(beiscsi_conn->conn);
#line 1373
    mgmt_invalidate_flag = 255U;
#line 1374
    tcp_upload_flag = 1U;
  } else {
#line 1376
    mgmt_invalidate_flag = 0U;
#line 1377
    tcp_upload_flag = 3U;
  }
#line 1380
  if ((phba->state & 4U) != 0U) {
#line 1381
    log_value___0 = phba->attr_log_enable;
#line 1381
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1381
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : PCI_ERROR Recovery\n",
                 1382);
    } else {

    }
#line 1383
    goto free_ep;
  } else {

  }
#line 1386
  tag = mgmt_invalidate_connection(phba, beiscsi_ep, (int )beiscsi_ep->ep_cid, (int )mgmt_invalidate_flag,
                                   (int )savecfg_flag);
#line 1390
  if (tag == 0U) {
#line 1391
    log_value___1 = phba->attr_log_enable;
#line 1391
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1391
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_invalidate_connection Failed for cid=%d\n",
                 1393, (int )beiscsi_ep->ep_cid);
    } else {

    }
  } else {

  }
#line 1396
  beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1397
  beiscsi_close_conn(beiscsi_ep, (int )tcp_upload_flag);
  free_ep: 
#line 1399
  msleep(250U);
#line 1400
  beiscsi_free_ep(beiscsi_ep);
#line 1401
  beiscsi_unbind_conn_to_cid(phba, (unsigned int )beiscsi_ep->ep_cid);
#line 1402
  iscsi_destroy_endpoint(beiscsi_ep->openiscsi_ep);
#line 1403
  return;
}
}
#line 1405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.c"
umode_t be2iscsi_attr_is_visible(int param_type , int param ) 
{ 


  {
#line 1407
  switch (param_type) {
  case 2: ;
#line 1409
  switch (param) {
  case 12: ;
  case 1: ;
  case 2: ;
  case 4: ;
  case 3: ;
  case 7: ;
  case 13: ;
  case 14: ;
  case 15: ;
#line 1419
  return (292U);
  default: ;
#line 1421
  return (0U);
  }
  case 1: ;
#line 1424
  switch (param) {
  case 0: ;
  case 1: ;
  case 4: ;
  case 5: ;
#line 1429
  return (292U);
  default: ;
#line 1431
  return (0U);
  }
  case 0: ;
#line 1434
  switch (param) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 21: ;
  case 20: ;
  case 14: ;
  case 17: ;
  case 18: ;
  case 30: ;
  case 31: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 15: ;
  case 16: ;
  case 22: ;
  case 24: ;
  case 23: ;
  case 25: ;
  case 26: ;
  case 27: ;
  case 28: ;
  case 32: ;
  case 34: ;
#line 1465
  return (292U);
  default: ;
#line 1467
  return (0U);
  }
  }
#line 1471
  return (0U);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 155
  tmp = ldv_err_ptr(error);
#line 155
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 180
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 180
  ldv_func_res = tmp;
#line 182
  activate_work_6(ldv_func_arg3, 2);
#line 184
  return (ldv_func_res);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 191
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 191
  ldv_func_res = tmp;
#line 193
  activate_work_6(& ldv_func_arg3->work, 2);
#line 195
  return (ldv_func_res);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 202
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 202
  ldv_func_res = tmp;
#line 204
  activate_work_6(ldv_func_arg3, 2);
#line 206
  return (ldv_func_res);
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 212
  flush_workqueue(ldv_func_arg1);
#line 214
  call_and_disable_all_6(2);
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_iscsi.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 221
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 221
  ldv_func_res = tmp;
#line 223
  activate_work_6(& ldv_func_arg3->work, 2);
#line 225
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 174 "include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp___0 ;

  {
#line 178
  tmp___0 = fls64((__u64 )l);
#line 178
  return ((unsigned int )tmp___0);
}
}
#line 61 "include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
#line 63
  tmp = fls_long(n - 1UL);
#line 63
  return (1UL << (int )tmp);
}
}
#line 70 "include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
#line 72
  tmp = fls_long(n);
#line 72
  return (1UL << (int )(tmp - 1U));
}
}
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 154 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 156
  __list_del_entry(list);
#line 157
  list_add(list, head);
#line 158
  return;
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 30
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 34
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
#line 318
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
#line 363
  return;
}
}
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 181
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_31(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_32(struct workqueue_struct *ldv_func_arg1 ) ;
#line 441
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 451
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 463
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) ;
#line 476
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 479
bool ldv_cancel_delayed_work_sync_30(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_19(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_20(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 181 "./arch/x86/include/asm/io.h"
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 195
extern void iounmap(void volatile   * ) ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 289 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct iscsi_cls_conn *beiscsi_iscsi_transport_group2  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int pci_counter  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_12  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct iscsi_task *beiscsi_iscsi_transport_group3  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_14  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_17  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_2_3  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct scsi_device *beiscsi_sht_group1  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_9  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_6_0  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct pci_dev *beiscsi_eeh_handlers_group0  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_1  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ref_cnt  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_2_2  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_7  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_2_1  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_2_2  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_4_0  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_3_0  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_5_0  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_3_1  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct device_attribute *dev_attr_beiscsi_log_enable_group0  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_5_2  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_3_2  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_6_2  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_3_3  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_8  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_15  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_3  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct scsi_cmnd *beiscsi_sht_group0  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_13  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct iscsi_cls_session *beiscsi_iscsi_transport_group1  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_2_0  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_3_0  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_5_3  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct pci_dev *beiscsi_pci_driver_group1  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_2_3  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_6_1  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_3_3  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_3_2  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_2  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_10  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_3_1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_4_1  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct Scsi_Host *beiscsi_iscsi_transport_group0  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_4_3  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_16  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_2_1  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_5_1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_6_3  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void *ldv_irq_data_2_0  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_work_4_2  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_state_variable_11  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct iscsi_endpoint *beiscsi_iscsi_transport_group4  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct device *dev_attr_beiscsi_log_enable_group1  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 113
int ldv_irq_3(int state , int line , void *data ) ;
#line 114
void activate_work_5(struct work_struct *work , int state ) ;
#line 115
void disable_suitable_irq_2(int line , void *data ) ;
#line 116
void invoke_work_6(void) ;
#line 117
void activate_suitable_irq_3(int line , void *data ) ;
#line 118
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 119
void work_init_5(void) ;
#line 120
void call_and_disable_all_4(int state ) ;
#line 121
void disable_work_5(struct work_struct *work ) ;
#line 122
void ldv_initialize_pci_error_handlers_9(void) ;
#line 124
void disable_suitable_irq_1(int line , void *data ) ;
#line 125
void activate_suitable_irq_1(int line , void *data ) ;
#line 126
void invoke_work_4(void) ;
#line 127
void call_and_disable_work_5(struct work_struct *work ) ;
#line 128
int ldv_irq_2(int state , int line , void *data ) ;
#line 129
void ldv_initialize_iscsi_transport_8(void) ;
#line 131
void choose_interrupt_2(void) ;
#line 132
void activate_work_4(struct work_struct *work , int state ) ;
#line 133
void call_and_disable_all_5(int state ) ;
#line 134
void activate_suitable_irq_2(int line , void *data ) ;
#line 135
void ldv_initialize_device_attribute_17(void) ;
#line 136
void ldv_initialize_scsi_host_template_10(void) ;
#line 137
void work_init_6(void) ;
#line 138
void disable_work_6(struct work_struct *work ) ;
#line 139
void choose_interrupt_1(void) ;
#line 140
void invoke_work_5(void) ;
#line 141
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
#line 142
void disable_suitable_irq_3(int line , void *data ) ;
#line 143
int reg_check_3(irqreturn_t (*handler)(int  , void * ) ) ;
#line 144
void disable_work_4(struct work_struct *work ) ;
#line 145
void work_init_4(void) ;
#line 146
int ldv_irq_1(int state , int line , void *data ) ;
#line 148
void call_and_disable_work_6(struct work_struct *work ) ;
#line 149
void choose_interrupt_3(void) ;
#line 150
void call_and_disable_work_4(struct work_struct *work ) ;
#line 151
void ldv_pci_driver_7(void) ;
#line 50 "include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
#line 52
  msleep(seconds * 1000U);
#line 53
  return;
}
}
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_24(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_25(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 149
__inline static int ldv_request_irq_26(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 158
extern void free_irq(unsigned int  , void * ) ;
#line 161
void ldv_free_irq_27(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 165
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 169
void ldv_free_irq_29(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 250 "include/linux/scatterlist.h"
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 271
extern size_t sg_copy_from_buffer(struct scatterlist * , unsigned int  , void const   * ,
                                  size_t  ) ;
#line 960 "include/linux/blkdev.h"
extern void blk_queue_max_segment_size(struct request_queue * , unsigned int  ) ;
#line 811 "include/linux/pci.h"
extern struct pci_dev *pci_dev_get(struct pci_dev * ) ;
#line 812
extern void pci_dev_put(struct pci_dev * ) ;
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 1024
extern int pci_save_state(struct pci_dev * ) ;
#line 1025
extern void pci_restore_state(struct pci_dev * ) ;
#line 1038
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1092
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1094
extern void pci_release_regions(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_33(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_34(struct pci_driver *ldv_func_arg1 ) ;
#line 24 "include/linux/dmapool.h"
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 27
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 1213 "include/linux/pci.h"
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1224
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_35195: ;
#line 19
    goto ldv_35195;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_35204: ;
#line 36
    goto ldv_35204;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 60 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 101 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 103
  tmp = dma_supported(dev, mask);
#line 103
  if (tmp == 0) {
#line 104
    return (-5);
  } else {

  }
#line 105
  dev->coherent_dma_mask = mask;
#line 106
  return (0);
}
}
#line 183 "include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 186
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
#line 186
  ret = tmp;
#line 188
  return (ret);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_zalloc_consistent(struct pci_dev *hwdev , size_t size ,
                                            dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 26
  tmp = dma_zalloc_coherent((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                            size, dma_handle, 32U);
#line 26
  return (tmp);
}
}
#line 38 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 40
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 40
  return (tmp);
}
}
#line 44 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
#line 47
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 48
  return;
}
}
#line 113 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
#line 115
  return (tmp);
}
}
#line 118 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 120
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 120
  return (tmp);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 110 "include/linux/iscsi_boot_sysfs.h"
extern struct iscsi_boot_kobj *iscsi_boot_create_initiator(struct iscsi_boot_kset * ,
                                                           int  , void * , ssize_t (*)(void * ,
                                                                                       int  ,
                                                                                       char * ) ,
                                                           umode_t (*)(void * , int  ) ,
                                                           void (*)(void * ) ) ;
#line 117
extern struct iscsi_boot_kobj *iscsi_boot_create_ethernet(struct iscsi_boot_kset * ,
                                                          int  , void * , ssize_t (*)(void * ,
                                                                                      int  ,
                                                                                      char * ) ,
                                                          umode_t (*)(void * , int  ) ,
                                                          void (*)(void * ) ) ;
#line 123
extern struct iscsi_boot_kobj *iscsi_boot_create_target(struct iscsi_boot_kset * ,
                                                        int  , void * , ssize_t (*)(void * ,
                                                                                    int  ,
                                                                                    char * ) ,
                                                        umode_t (*)(void * , int  ) ,
                                                        void (*)(void * ) ) ;
#line 130
extern struct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int  ) ;
#line 131
extern void iscsi_boot_destroy_kset(struct iscsi_boot_kset * ) ;
#line 65 "include/linux/bsg-lib.h"
extern void bsg_job_done(struct bsg_job * , int  , unsigned int  ) ;
#line 176 "include/scsi/scsi_transport_iscsi.h"
extern struct scsi_transport_template *iscsi_register_transport(struct iscsi_transport * ) ;
#line 177
extern int iscsi_unregister_transport(struct iscsi_transport * ) ;
#line 283
extern void iscsi_host_for_each_session(struct Scsi_Host * , void (*)(struct iscsi_cls_session * ) ) ;
#line 381 "include/scsi/libiscsi.h"
extern int iscsi_eh_abort(struct scsi_cmnd * ) ;
#line 383
extern int iscsi_eh_session_reset(struct scsi_cmnd * ) ;
#line 384
extern int iscsi_eh_device_reset(struct scsi_cmnd * ) ;
#line 385
extern int iscsi_queuecommand(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 398
extern int iscsi_host_add(struct Scsi_Host * , struct device * ) ;
#line 399
extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template * , int  , bool  ) ;
#line 402
extern void iscsi_host_remove(struct Scsi_Host * ) ;
#line 403
extern void iscsi_host_free(struct Scsi_Host * ) ;
#line 404
extern int iscsi_target_alloc(struct scsi_target * ) ;
#line 413
extern void iscsi_session_recovery_timedout(struct iscsi_cls_session * ) ;
#line 416
extern int iscsi_session_get_param(struct iscsi_cls_session * , enum iscsi_param  ,
                                   char * ) ;
#line 427
extern void iscsi_conn_teardown(struct iscsi_cls_conn * ) ;
#line 429
extern void iscsi_conn_stop(struct iscsi_cls_conn * , int  ) ;
#line 432
extern void iscsi_conn_failure(struct iscsi_conn * , enum iscsi_err  ) ;
#line 435
extern int iscsi_conn_get_param(struct iscsi_cls_conn * , enum iscsi_param  , char * ) ;
#line 454
extern int iscsi_conn_send_pdu(struct iscsi_cls_conn * , struct iscsi_hdr * , char * ,
                               uint32_t  ) ;
#line 458
extern int __iscsi_complete_pdu(struct iscsi_conn * , struct iscsi_hdr * , char * ,
                                int  ) ;
#line 464
extern void iscsi_put_task(struct iscsi_task * ) ;
#line 467
extern void iscsi_complete_scsi_task(struct iscsi_task * , uint32_t  , uint32_t  ) ;
#line 761 "include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost___0(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_42385;
  ldv_42384: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_42385: 
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_42384;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 796
extern struct Scsi_Host *scsi_host_get(struct Scsi_Host * ) ;
#line 797
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 310 "include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 312
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 312
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 379
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
#line 168 "include/scsi/scsi_cmnd.h"
extern int scsi_dma_map(struct scsi_cmnd * ) ;
#line 169
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 176 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 178
  return (cmd->sdb.table.sgl);
}
}
#line 181 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 183
  return (cmd->sdb.length);
}
}
#line 186 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 188
  cmd->sdb.resid = resid;
#line 189
  return;
}
}
#line 18 "include/linux/ctype.h"
extern unsigned char const   _ctype[] ;
#line 42 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 43
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 44
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 26 "include/linux/blk-iopoll.h"
__inline static int blk_iopoll_sched_prep(struct blk_iopoll *iop ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 28
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& iop->state));
#line 28
  if (tmp___0 == 0) {
#line 29
    tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& iop->state));
#line 29
    return (tmp);
  } else {

  }
#line 31
  return (1);
}
}
#line 39
extern void blk_iopoll_sched(struct blk_iopoll * ) ;
#line 40
extern void blk_iopoll_init(struct blk_iopoll * , int  , blk_iopoll_fn * ) ;
#line 41
extern void blk_iopoll_complete(struct blk_iopoll * ) ;
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 50
  __ret_warn_on = ((int )limit & ((int )limit + -1)) != 0;
#line 50
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 50
  if (tmp != 0L) {
#line 50
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h",
                       50);
  } else {

  }
#line 50
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 51
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 54 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 56
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 56
  *index = (u16 )tmp;
#line 57
  return;
}
}
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 71
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
#line 81
  index_inc(& q->tail, (int )q->len);
#line 82
  return;
}
}
#line 715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl , struct be_queue_info *eq , int eq_delay ) ;
#line 718
int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl , struct be_queue_info *cq , struct be_queue_info *eq ,
                          bool sol_evts , bool no_delay , int coalesce_wm ) ;
#line 723
int beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl , struct be_queue_info *q , int queue_type ) ;
#line 725
int beiscsi_cmd_mccq_create(struct beiscsi_hba *phba , struct be_queue_info *mccq ,
                            struct be_queue_info *cq ) ;
#line 730
int mgmt_check_supported_fw(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) ;
#line 735
void free_mcc_tag(struct be_ctrl_info *ctrl , unsigned int tag ) ;
#line 737
int be_cmd_modify_eq_delay(struct beiscsi_hba *phba , struct be_set_eqd *set_eqd ,
                           int num ) ;
#line 743
int be_cmd_fw_initialize(struct be_ctrl_info *ctrl ) ;
#line 744
int be_cmd_fw_uninit(struct be_ctrl_info *ctrl ) ;
#line 751
void beiscsi_async_link_state_process(struct beiscsi_hba *phba , struct be_async_event_link_state *evt ) ;
#line 753
int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) ;
#line 758
int be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl , struct be_queue_info *cq ,
                                    struct be_queue_info *dq , int length , int entry_size ,
                                    uint8_t is_header , uint8_t ulp_num ) ;
#line 764
int be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ) ;
#line 767
int be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl ) ;
#line 769
int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ,
                                u32 page_offset___0 , u32 num_pages ) ;
#line 773
int beiscsi_cmd_reset_function(struct beiscsi_hba *phba ) ;
#line 775
int be_cmd_wrbq_create(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem , struct be_queue_info *wrbq ,
                       struct hwi_wrb_context *pwrb_context , uint8_t ulp_num ) ;
#line 780
bool is_link_state_evt(u32 trailer ) ;
#line 1362
int be_chk_reset_complete(struct beiscsi_hba *phba ) ;
#line 1370
void be2iscsi_fail_session(struct iscsi_cls_session *cls_session ) ;
#line 185 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 187
  dw = (u32 *)ptr;
#line 188
  return ((*(dw + (unsigned long )dw_offset) >> (int )offset) & mask);
}
}
#line 199 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 201
  return;
}
}
#line 836 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_main.h"
struct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba , unsigned int cid ) ;
#line 838
void free_mgmt_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) ;
#line 840
void beiscsi_process_all_cqs(struct work_struct *work ) ;
#line 844
void hwi_ring_cq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int num_processed ,
                    unsigned char rearm , unsigned char event ) ;
#line 99 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
int mgmt_epfw_cleanup(struct beiscsi_hba *phba , unsigned short ulp_num ) ;
#line 108
unsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba , struct invalidate_command_table *inv_tbl ,
                                  unsigned int num_invalidate , unsigned int cid ,
                                  struct be_dma_mem *nonemb_cmd ) ;
#line 112
unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ,
                                         struct bsg_job *job , struct be_dma_mem *nonemb_cmd ) ;
#line 269
int mgmt_get_fw_config(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) ;
#line 289
unsigned int mgmt_get_session_info(struct beiscsi_hba *phba , u32 boot_session_handle ,
                                   struct be_dma_mem *nonemb_cmd ) ;
#line 305
int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba , unsigned int *s_handle ) ;
#line 312
ssize_t beiscsi_drvr_ver_disp(struct device *dev , struct device_attribute *attr ,
                              char *buf ) ;
#line 315
ssize_t beiscsi_fw_ver_disp(struct device *dev , struct device_attribute *attr , char *buf ) ;
#line 318
ssize_t beiscsi_active_session_disp(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) ;
#line 321
ssize_t beiscsi_adap_family_disp(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) ;
#line 325
ssize_t beiscsi_free_session_disp(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) ;
#line 328
ssize_t beiscsi_phys_port_disp(struct device *dev , struct device_attribute *attr ,
                               char *buf ) ;
#line 331
void beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ,
                            struct be_mem_descriptor *mem_descr ) ;
#line 335
void beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ) ;
#line 337
void beiscsi_ue_detect(struct beiscsi_hba *phba ) ;
#line 341
int beiscsi_logout_fw_sess(struct beiscsi_hba *phba , uint32_t fw_sess_handle ) ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int be_iopoll_budget  =    10U;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int be_max_phys_size  =    64U;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int enable_msix  =    1U;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static uint beiscsi_log_enable  =    0U;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
ssize_t beiscsi_log_enable_disp(struct device *dev , struct device_attribute *attrib ,
                                char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t param_val ;
  int tmp___0 ;

  {
#line 152
  __mptr = (struct device  const  *)dev;
#line 152
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 152
  tmp = shost_priv(shost);
#line 152
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 152
  param_val = 0U;
#line 152
  param_val = phba->attr_log_enable;
#line 152
  tmp___0 = snprintf(buf, 4096UL, "%d\n", phba->attr_log_enable);
#line 152
  return ((ssize_t )tmp___0);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_log_enable_change(struct beiscsi_hba *phba , uint32_t val ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 152
  if (val <= 255U) {
#line 152
    log_value = phba->attr_log_enable;
#line 152
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 152
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d : beiscsi_log_enable updated from 0x%x ==> 0x%x\n",
                 152, phba->attr_log_enable, val);
    } else {

    }
#line 152
    phba->attr_log_enable = val;
#line 152
    return (0);
  } else {

  }
#line 152
  log_value___0 = phba->attr_log_enable;
#line 152
  if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 152
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d beiscsi_log_enable attribute cannot be updated to 0x%x, range allowed is [0x00 - 0xFF]\n",
               152, val);
  } else {

  }
#line 152
  return (-22);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
ssize_t beiscsi_log_enable_store(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t param_val ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 152
  __mptr = (struct device  const  *)dev;
#line 152
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 152
  tmp = shost_priv(shost);
#line 152
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 152
  param_val = 0U;
#line 152
  if (((int )_ctype[(int )((unsigned char )*buf)] & 4) == 0) {
#line 152
    return (-22L);
  } else {

  }
#line 152
  tmp___0 = sscanf(buf, "%i", & param_val);
#line 152
  if (tmp___0 != 1) {
#line 152
    return (-22L);
  } else {

  }
#line 152
  tmp___2 = beiscsi_log_enable_change(phba, param_val);
#line 152
  if (tmp___2 == 0) {
#line 152
    tmp___1 = strlen(buf);
#line 152
    return ((ssize_t )tmp___1);
  } else {
#line 152
    return (-22L);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_log_enable_init(struct beiscsi_hba *phba , uint32_t val ) 
{ 
  uint32_t log_value ;

  {
#line 152
  if (val <= 255U) {
#line 152
    phba->attr_log_enable = val;
#line 152
    return (0);
  } else {

  }
#line 152
  log_value = phba->attr_log_enable;
#line 152
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 152
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d beiscsi_log_enable attribute cannot be updated to 0x%x, range allowed is [0x00 - 0xFF]\n",
               152, val);
  } else {

  }
#line 152
  phba->attr_log_enable = 0U;
#line 152
  return (-22);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_log_enable  =    {{"beiscsi_log_enable", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_log_enable_disp, & beiscsi_log_enable_store};
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_drvr_ver  =    {{"beiscsi_drvr_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_drvr_ver_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_adapter_family  =    {{"beiscsi_adapter_family", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}}}}, & beiscsi_adap_family_disp,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_fw_ver  =    {{"beiscsi_fw_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_fw_ver_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                        char const   * , size_t  ))0};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_phys_port  =    {{"beiscsi_phys_port", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_phys_port_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                           char const   * , size_t  ))0};
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_active_session_count  =    {{"beiscsi_active_session_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                          {(char)0}, {(char)0}, {(char)0},
                                                          {(char)0}, {(char)0}}}},
    & beiscsi_active_session_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                char const   * , size_t  ))0};
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_free_session_count  =    {{"beiscsi_free_session_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}}}}, & beiscsi_free_session_disp,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute *beiscsi_attrs[8U]  = 
#line 162
  {      & dev_attr_beiscsi_log_enable,      & dev_attr_beiscsi_drvr_ver,      & dev_attr_beiscsi_adapter_family,      & dev_attr_beiscsi_fw_ver, 
        & dev_attr_beiscsi_active_session_count,      & dev_attr_beiscsi_free_session_count,      & dev_attr_beiscsi_phys_port,      (struct device_attribute *)0};
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static char const   *cqe_desc[36U]  = 
#line 173
  {      "RESERVED_DESC",      "SOL_CMD_COMPLETE",      "SOL_CMD_KILLED_DATA_DIGEST_ERR",      "CXN_KILLED_PDU_SIZE_EXCEEDS_DSL", 
        "CXN_KILLED_BURST_LEN_MISMATCH",      "CXN_KILLED_AHS_RCVD",      "CXN_KILLED_HDR_DIGEST_ERR",      "CXN_KILLED_UNKNOWN_HDR", 
        "CXN_KILLED_STALE_ITT_TTT_RCVD",      "CXN_KILLED_INVALID_ITT_TTT_RCVD",      "CXN_KILLED_RST_RCVD",      "CXN_KILLED_TIMED_OUT", 
        "CXN_KILLED_RST_SENT",      "CXN_KILLED_FIN_RCVD",      "CXN_KILLED_BAD_UNSOL_PDU_RCVD",      "CXN_KILLED_BAD_WRB_INDEX_ERROR", 
        "CXN_KILLED_OVER_RUN_RESIDUAL",      "CXN_KILLED_UNDER_RUN_RESIDUAL",      "CMD_KILLED_INVALID_STATSN_RCVD",      "CMD_KILLED_INVALID_R2T_RCVD", 
        "CMD_CXN_KILLED_LUN_INVALID",      "CMD_CXN_KILLED_ICD_INVALID",      "CMD_CXN_KILLED_ITT_INVALID",      "CMD_CXN_KILLED_SEQ_OUTOFORDER", 
        "CMD_CXN_KILLED_INVALID_DATASN_RCVD",      "CXN_INVALIDATE_NOTIFY",      "CXN_INVALIDATE_INDEX_NOTIFY",      "CMD_INVALIDATED_NOTIFY", 
        "UNSOL_HDR_NOTIFY",      "UNSOL_DATA_NOTIFY",      "UNSOL_DATA_DIGEST_ERROR_NOTIFY",      "DRIVERMSG_NOTIFY", 
        "CXN_KILLED_CMND_DATA_NOT_ON_SAME_CONN",      "SOL_CMD_KILLED_DIF_ERR",      "CXN_KILLED_SYN_RCVD",      "CXN_KILLED_IMM_DATA_RCVD"};
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_slave_configure(struct scsi_device *sdev ) 
{ 


  {
#line 214
  blk_queue_max_segment_size(sdev->request_queue, 65536U);
#line 215
  return (0);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_eh_abort(struct scsi_cmnd *sc ) 
{ 
  struct iscsi_cls_session *cls_session ;
  struct iscsi_task *aborted_task ;
  struct beiscsi_io_task *aborted_io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *session ;
  struct invalidate_command_table *inv_tbl ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int cid ;
  unsigned int tag ;
  unsigned int num_invalidate ;
  int rc ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp ;
  u32 tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___1 ;

  {
#line 221
  aborted_task = (struct iscsi_task *)sc->SCp.ptr;
#line 232
  tmp = scsi_target(sc->device);
#line 232
  __mptr = (struct device  const  *)tmp->dev.parent;
#line 232
  cls_session = (struct iscsi_cls_session *)__mptr + 0xfffffffffffffd58UL;
#line 233
  session = (struct iscsi_session *)cls_session->dd_data;
#line 235
  spin_lock_bh(& session->frwd_lock);
#line 236
  if ((unsigned long )aborted_task == (unsigned long )((struct iscsi_task *)0) || (unsigned long )aborted_task->sc == (unsigned long )((struct scsi_cmnd *)0)) {
#line 238
    spin_unlock_bh(& session->frwd_lock);
#line 239
    return (8194);
  } else {

  }
#line 242
  aborted_io_task = (struct beiscsi_io_task *)aborted_task->dd_data;
#line 243
  if ((unsigned long )aborted_io_task->scsi_cmnd == (unsigned long )((struct scsi_cmnd *)0)) {
#line 245
    spin_unlock_bh(& session->frwd_lock);
#line 246
    return (8194);
  } else {

  }
#line 248
  spin_unlock_bh(& session->frwd_lock);
#line 250
  tmp___0 = amap_mask(1U);
#line 250
  amap_set((void *)(aborted_io_task->pwrb_handle)->pwrb, 0U, tmp___0, 15U, 1U);
#line 254
  conn = aborted_task->conn;
#line 255
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 256
  phba = beiscsi_conn->phba;
#line 259
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 260
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 261
  memset((void *)inv_tbl, 0, 4UL);
#line 262
  inv_tbl->cid = (unsigned short )cid;
#line 263
  inv_tbl->icd = (unsigned short )(aborted_io_task->psgl_handle)->sgl_index;
#line 264
  num_invalidate = 1U;
#line 265
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, 540UL, & nonemb_cmd.dma);
#line 268
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 269
    log_value = phba->attr_log_enable;
#line 269
    if ((log_value & 8U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 269
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory formgmt_invalidate_icds\n",
                 271);
    } else {

    }
#line 272
    return (8195);
  } else {

  }
#line 274
  nonemb_cmd.size = 540U;
#line 276
  tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate, cid, & nonemb_cmd);
#line 278
  if (tag == 0U) {
#line 279
    log_value___0 = phba->attr_log_enable;
#line 279
    if ((log_value___0 & 8U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 279
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : mgmt_invalidate_icds could not besubmitted\n",
                 281);
    } else {

    }
#line 282
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 285
    return (8195);
  } else {

  }
#line 288
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
#line 289
  if (rc != -16) {
#line 290
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
  } else {

  }
#line 293
  tmp___1 = iscsi_eh_abort(sc);
#line 293
  return (tmp___1);
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_eh_device_reset(struct scsi_cmnd *sc ) 
{ 
  struct iscsi_task *abrt_task ;
  struct beiscsi_io_task *abrt_io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *session ;
  struct iscsi_cls_session *cls_session ;
  struct invalidate_command_table *inv_tbl ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int cid ;
  unsigned int tag ;
  unsigned int i ;
  unsigned int num_invalidate ;
  int rc ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp ;
  u32 tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___1 ;

  {
#line 311
  tmp = scsi_target(sc->device);
#line 311
  __mptr = (struct device  const  *)tmp->dev.parent;
#line 311
  cls_session = (struct iscsi_cls_session *)__mptr + 0xfffffffffffffd58UL;
#line 312
  session = (struct iscsi_session *)cls_session->dd_data;
#line 313
  spin_lock_bh(& session->frwd_lock);
#line 314
  if ((unsigned long )session->leadconn == (unsigned long )((struct iscsi_conn *)0) || session->state != 2) {
#line 315
    spin_unlock_bh(& session->frwd_lock);
#line 316
    return (8195);
  } else {

  }
#line 318
  conn = session->leadconn;
#line 319
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 320
  phba = beiscsi_conn->phba;
#line 321
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 322
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 323
  memset((void *)inv_tbl, 0, 512UL);
#line 324
  num_invalidate = 0U;
#line 325
  i = 0U;
#line 325
  goto ldv_54884;
  ldv_54883: 
#line 326
  abrt_task = *((conn->session)->cmds + (unsigned long )i);
#line 327
  abrt_io_task = (struct beiscsi_io_task *)abrt_task->dd_data;
#line 328
  if ((unsigned long )abrt_task->sc == (unsigned long )((struct scsi_cmnd *)0) || abrt_task->state == 0) {
#line 329
    goto ldv_54882;
  } else {

  }
#line 331
  if ((sc->device)->lun != ((abrt_task->sc)->device)->lun) {
#line 332
    goto ldv_54882;
  } else {

  }
#line 335
  tmp___0 = amap_mask(1U);
#line 335
  amap_set((void *)(abrt_io_task->pwrb_handle)->pwrb, 0U, tmp___0, 15U, 1U);
#line 339
  inv_tbl->cid = (unsigned short )cid;
#line 340
  inv_tbl->icd = (unsigned short )(abrt_io_task->psgl_handle)->sgl_index;
#line 341
  num_invalidate = num_invalidate + 1U;
#line 342
  inv_tbl = inv_tbl + 1;
  ldv_54882: 
#line 325
  i = i + 1U;
  ldv_54884: ;
#line 325
  if ((unsigned int )(conn->session)->cmds_max > i) {
#line 327
    goto ldv_54883;
  } else {

  }
#line 344
  spin_unlock_bh(& session->frwd_lock);
#line 345
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 347
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, 540UL, & nonemb_cmd.dma);
#line 350
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 351
    log_value = phba->attr_log_enable;
#line 351
    if ((log_value & 8U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 351
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory formgmt_invalidate_icds\n",
                 353);
    } else {

    }
#line 354
    return (8195);
  } else {

  }
#line 356
  nonemb_cmd.size = 540U;
#line 357
  memset(nonemb_cmd.va, 0, (size_t )nonemb_cmd.size);
#line 358
  tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate, cid, & nonemb_cmd);
#line 360
  if (tag == 0U) {
#line 361
    log_value___0 = phba->attr_log_enable;
#line 361
    if ((log_value___0 & 8U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 361
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : mgmt_invalidate_icds could not be submitted\n",
                 363);
    } else {

    }
#line 364
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 366
    return (8195);
  } else {

  }
#line 369
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
#line 370
  if (rc != -16) {
#line 371
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
  } else {

  }
#line 373
  tmp___1 = iscsi_eh_device_reset(sc);
#line 373
  return (tmp___1);
}
}
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_tgt_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  struct mgmt_session_info *boot_sess ;
  struct mgmt_conn_info *boot_conn ;
  char *str ;
  int rc ;
  size_t tmp ;

  {
#line 378
  phba = (struct beiscsi_hba *)data;
#line 379
  boot_sess = & phba->boot_sess;
#line 380
  boot_conn = (struct mgmt_conn_info *)(& boot_sess->conn_list);
#line 381
  str = buf;
#line 384
  switch (type) {
  case 7: 
#line 386
  tmp = strlen((char const   *)(& boot_sess->target_name));
#line 386
  rc = sprintf(buf, "%.*s\n", (int )tmp, (char *)(& boot_sess->target_name));
#line 389
  goto ldv_54899;
  case 2: ;
#line 391
  if ((unsigned int )boot_conn->dest_ipaddr.ip_type == 1U) {
#line 392
    rc = sprintf(buf, "%pI4\n", (char *)(& boot_conn->dest_ipaddr.addr));
  } else {
#line 395
    rc = sprintf(str, "%pI6\n", (char *)(& boot_conn->dest_ipaddr.addr));
  }
#line 397
  goto ldv_54899;
  case 3: 
#line 399
  rc = sprintf(str, "%d\n", (int )boot_conn->dest_port);
#line 400
  goto ldv_54899;
  case 8: 
#line 403
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.target_chap_name_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.target_chap_name));
#line 408
  goto ldv_54899;
  case 9: 
#line 410
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.target_secret_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.target_secret));
#line 415
  goto ldv_54899;
  case 10: 
#line 417
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.intr_chap_name_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.intr_chap_name));
#line 422
  goto ldv_54899;
  case 11: 
#line 424
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.intr_secret_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.intr_secret));
#line 429
  goto ldv_54899;
  case 1: 
#line 431
  rc = sprintf(str, "2\n");
#line 432
  goto ldv_54899;
  case 6: 
#line 434
  rc = sprintf(str, "0\n");
#line 435
  goto ldv_54899;
  default: 
#line 437
  rc = -38;
#line 438
  goto ldv_54899;
  }
  ldv_54899: ;
#line 440
  return ((ssize_t )rc);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_ini_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  char *str ;
  int rc ;

  {
#line 445
  phba = (struct beiscsi_hba *)data;
#line 446
  str = buf;
#line 449
  switch (type) {
  case 6: 
#line 451
  rc = sprintf(str, "%s\n", (u8 *)(& phba->boot_sess.initiator_iscsiname));
#line 452
  goto ldv_54918;
  default: 
#line 454
  rc = -38;
#line 455
  goto ldv_54918;
  }
  ldv_54918: ;
#line 457
  return ((ssize_t )rc);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_eth_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  char *str ;
  int rc ;

  {
#line 462
  phba = (struct beiscsi_hba *)data;
#line 463
  str = buf;
#line 466
  switch (type) {
  case 1: 
#line 468
  rc = sprintf(str, "2\n");
#line 469
  goto ldv_54929;
  case 0: 
#line 471
  rc = sprintf(str, "0\n");
#line 472
  goto ldv_54929;
  case 10: 
#line 474
  rc = beiscsi_get_macaddr(str, phba);
#line 475
  goto ldv_54929;
  default: 
#line 477
  rc = -38;
#line 478
  goto ldv_54929;
  }
  ldv_54929: ;
#line 480
  return ((ssize_t )rc);
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_tgt_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
#line 488
  switch (type) {
  case 7: ;
  case 2: ;
  case 3: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 6: ;
  case 1: 
#line 498
  rc = 292U;
#line 499
  goto ldv_54947;
  default: 
#line 501
  rc = 0U;
#line 502
  goto ldv_54947;
  }
  ldv_54947: ;
#line 504
  return (rc);
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_ini_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
#line 511
  switch (type) {
  case 6: 
#line 513
  rc = 292U;
#line 514
  goto ldv_54955;
  default: 
#line 516
  rc = 0U;
#line 517
  goto ldv_54955;
  }
  ldv_54955: ;
#line 519
  return (rc);
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_eth_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
#line 527
  switch (type) {
  case 1: ;
  case 10: ;
  case 0: 
#line 531
  rc = 292U;
#line 532
  goto ldv_54965;
  default: 
#line 534
  rc = 0U;
#line 535
  goto ldv_54965;
  }
  ldv_54965: ;
#line 537
  return (rc);
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct pci_device_id  const  beiscsi_pci_id_table[7U]  = {      {6562U, 530U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 546U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1794U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1795U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1810U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1826U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct pci_device_id  const  __mod_pci__beiscsi_pci_id_table_device_table[7U]  ;
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct scsi_host_template beiscsi_sht  = 
#line 553
     {& __this_module, "Avago Technologies 10Gbe open-iscsi Initiator Driver", 0, 0,
    0, 0, 0, & iscsi_queuecommand, & beiscsi_eh_abort, & beiscsi_eh_device_reset,
    & iscsi_eh_session_reset, 0, 0, 0, & beiscsi_slave_configure, 0, & iscsi_target_alloc,
    0, 0, 0, & scsi_change_queue_depth, 0, 0, 0, 0, 0, 0, "be2iscsi", 0, 1024, -1,
    30U, (unsigned short)0, 1024U, 0UL, 128, (unsigned char)0, 0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, 0U, (struct device_attribute **)(& beiscsi_attrs),
    0, {0, 0}, 72057594037934498ULL, 0U, 0, (_Bool)0};
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct scsi_transport_template *beiscsi_scsi_transport  ;
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  struct Scsi_Host *shost ;
  void *tmp ;

  {
#line 582
  shost = iscsi_host_alloc(& beiscsi_sht, 13048, 0);
#line 583
  if ((unsigned long )shost == (unsigned long )((struct Scsi_Host *)0)) {
#line 584
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_hba_alloc - iscsi_host_alloc failed\n");
#line 586
    return ((struct beiscsi_hba *)0);
  } else {

  }
#line 588
  shost->max_id = 256U;
#line 589
  shost->max_channel = 0U;
#line 590
  shost->max_cmd_len = 16U;
#line 591
  shost->max_lun = 256ULL;
#line 592
  shost->transportt = beiscsi_scsi_transport;
#line 593
  tmp = shost_priv(shost);
#line 593
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 594
  memset((void *)phba, 0, 13048UL);
#line 595
  phba->shost = shost;
#line 596
  phba->pcidev = pci_dev_get(pcidev);
#line 597
  pci_set_drvdata(pcidev, (void *)phba);
#line 598
  phba->interface_handle = 4294967295U;
#line 600
  return (phba);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_unmap_pci_function(struct beiscsi_hba *phba ) 
{ 


  {
#line 605
  if ((unsigned long )phba->csr_va != (unsigned long )((u8 *)0U)) {
#line 606
    iounmap((void volatile   *)phba->csr_va);
#line 607
    phba->csr_va = (u8 *)0U;
  } else {

  }
#line 609
  if ((unsigned long )phba->db_va != (unsigned long )((u8 *)0U)) {
#line 610
    iounmap((void volatile   *)phba->db_va);
#line 611
    phba->db_va = (u8 *)0U;
  } else {

  }
#line 613
  if ((unsigned long )phba->pci_va != (unsigned long )((u8 *)0U)) {
#line 614
    iounmap((void volatile   *)phba->pci_va);
#line 615
    phba->pci_va = (u8 *)0U;
  } else {

  }
#line 617
  return;
}
}
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_map_pci_bars(struct beiscsi_hba *phba , struct pci_dev *pcidev ) 
{ 
  u8 *addr ;
  int pcicfg_reg ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 625
  tmp = ioremap_nocache(pcidev->resource[2].start, pcidev->resource[2].start != 0ULL || pcidev->resource[2].end != pcidev->resource[2].start ? (unsigned long )((pcidev->resource[2].end - pcidev->resource[2].start) + 1ULL) : 0UL);
#line 625
  addr = (u8 *)tmp;
#line 627
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 628
    return (-12);
  } else {

  }
#line 629
  phba->ctrl.csr = addr;
#line 630
  phba->csr_va = addr;
#line 631
  phba->csr_pa.u.a64.address = pcidev->resource[2].start;
#line 633
  tmp___0 = ioremap_nocache(pcidev->resource[4].start, 131072UL);
#line 633
  addr = (u8 *)tmp___0;
#line 634
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 635
    goto pci_map_err;
  } else {

  }
#line 636
  phba->ctrl.db = addr;
#line 637
  phba->db_va = addr;
#line 638
  phba->db_pa.u.a64.address = pcidev->resource[4].start;
#line 640
  if (phba->generation == 2U) {
#line 641
    pcicfg_reg = 1;
  } else {
#line 643
    pcicfg_reg = 0;
  }
#line 645
  tmp___1 = ioremap_nocache(pcidev->resource[pcicfg_reg].start, pcidev->resource[pcicfg_reg].start != 0ULL || pcidev->resource[pcicfg_reg].end != pcidev->resource[pcicfg_reg].start ? (unsigned long )((pcidev->resource[pcicfg_reg].end - pcidev->resource[pcicfg_reg].start) + 1ULL) : 0UL);
#line 645
  addr = (u8 *)tmp___1;
#line 648
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 649
    goto pci_map_err;
  } else {

  }
#line 650
  phba->ctrl.pcicfg = addr;
#line 651
  phba->pci_va = addr;
#line 652
  phba->pci_pa.u.a64.address = pcidev->resource[pcicfg_reg].start;
#line 653
  return (0);
  pci_map_err: 
#line 656
  beiscsi_unmap_pci_function(phba);
#line 657
  return (-12);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_enable_pci(struct pci_dev *pcidev ) 
{ 
  int ret ;

  {
#line 664
  ret = pci_enable_device(pcidev);
#line 665
  if (ret != 0) {
#line 666
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_enable_pci - enable device failed\n");
#line 668
    return (ret);
  } else {

  }
#line 671
  ret = pci_request_regions(pcidev, "be2iscsi");
#line 672
  if (ret != 0) {
#line 673
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_enable_pci - request region failed\n");
#line 675
    goto pci_dev_disable;
  } else {

  }
#line 678
  pci_set_master(pcidev);
#line 679
  ret = pci_set_dma_mask(pcidev, 0xffffffffffffffffULL);
#line 680
  if (ret != 0) {
#line 681
    ret = pci_set_dma_mask(pcidev, 4294967295ULL);
#line 682
    if (ret != 0) {
#line 683
      dev_err((struct device  const  *)(& pcidev->dev), "Could not set PCI DMA Mask\n");
#line 684
      goto pci_region_release;
    } else {
#line 686
      ret = pci_set_consistent_dma_mask(pcidev, 4294967295ULL);
    }
  } else {
#line 690
    ret = pci_set_consistent_dma_mask(pcidev, 0xffffffffffffffffULL);
#line 691
    if (ret != 0) {
#line 692
      dev_err((struct device  const  *)(& pcidev->dev), "Could not set PCI DMA Mask\n");
#line 693
      goto pci_region_release;
    } else {

    }
  }
#line 696
  return (0);
  pci_region_release: 
#line 699
  pci_release_regions(pcidev);
  pci_dev_disable: 
#line 701
  pci_disable_device(pcidev);
#line 703
  return (ret);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_ctrl_init(struct beiscsi_hba *phba , struct pci_dev *pdev ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 708
  ctrl = & phba->ctrl;
#line 709
  mbox_mem_alloc = & ctrl->mbox_mem_alloced;
#line 710
  mbox_mem_align = & ctrl->mbox_mem;
#line 711
  status = 0;
#line 713
  ctrl->pdev = pdev;
#line 714
  status = beiscsi_map_pci_bars(phba, pdev);
#line 715
  if (status != 0) {
#line 716
    return (status);
  } else {

  }
#line 717
  mbox_mem_alloc->size = 288U;
#line 718
  mbox_mem_alloc->va = pci_alloc_consistent(pdev, (size_t )mbox_mem_alloc->size, & mbox_mem_alloc->dma);
#line 721
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
#line 722
    beiscsi_unmap_pci_function(phba);
#line 723
    return (-12);
  } else {

  }
#line 726
  mbox_mem_align->size = 272U;
#line 727
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 728
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 729
  memset(mbox_mem_align->va, 0, 272UL);
#line 730
  spinlock_check(& ctrl->mbox_lock);
#line 730
  __raw_spin_lock_init(& ctrl->mbox_lock.__annonCompField18.rlock, "&(&ctrl->mbox_lock)->rlock",
                       & __key);
#line 731
  spinlock_check(& phba->ctrl.mcc_lock);
#line 731
  __raw_spin_lock_init(& phba->ctrl.mcc_lock.__annonCompField18.rlock, "&(&phba->ctrl.mcc_lock)->rlock",
                       & __key___0);
#line 732
  spinlock_check(& phba->ctrl.mcc_cq_lock);
#line 732
  __raw_spin_lock_init(& phba->ctrl.mcc_cq_lock.__annonCompField18.rlock, "&(&phba->ctrl.mcc_cq_lock)->rlock",
                       & __key___1);
#line 734
  return (status);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_get_params(struct beiscsi_hba *phba ) 
{ 
  uint32_t total_cid_count ;
  uint32_t total_icd_count ;
  uint8_t ulp_num ;
  uint32_t align_mask ;
  uint32_t icd_post_per_page ;
  uint32_t icd_count_unavailable ;
  uint32_t icd_start ;
  uint32_t icd_count ;
  uint32_t icd_start_align ;
  uint32_t icd_count_align ;
  uint32_t log_value ;
  int tmp ;

  {
#line 743
  total_cid_count = 0U;
#line 744
  total_icd_count = 0U;
#line 745
  ulp_num = 0U;
#line 747
  total_cid_count = phba->fw_config.iscsi_cid_count[0] + phba->fw_config.iscsi_cid_count[1];
#line 750
  ulp_num = 0U;
#line 750
  goto ldv_55019;
  ldv_55018: 
#line 751
  align_mask = 0U;
#line 752
  icd_post_per_page = 0U;
#line 753
  icd_count_unavailable = 0U;
#line 754
  icd_start = 0U;
#line 754
  icd_count = 0U;
#line 755
  icd_start_align = 0U;
#line 755
  icd_count_align = 0U;
#line 757
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 757
  if (tmp != 0) {
#line 758
    icd_start = phba->fw_config.iscsi_icd_start[(int )ulp_num];
#line 759
    icd_count = phba->fw_config.iscsi_icd_count[(int )ulp_num];
#line 762
    icd_post_per_page = 8U;
#line 764
    align_mask = icd_post_per_page - 1U;
#line 767
    if (icd_start % icd_post_per_page != 0U) {
#line 768
      icd_start_align = (icd_start + icd_post_per_page) & ~ align_mask;
#line 771
      phba->fw_config.iscsi_icd_start[(int )ulp_num] = icd_start_align;
    } else {

    }
#line 776
    icd_count_align = ~ align_mask & icd_count;
#line 779
    if (icd_start_align != 0U) {
#line 780
      icd_count_unavailable = (icd_start_align - icd_start) + (icd_count - icd_count_align);
    } else {

    }
#line 786
    phba->fw_config.iscsi_icd_count[(int )ulp_num] = icd_count - icd_count_unavailable;
#line 789
    log_value = phba->attr_log_enable;
#line 789
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 789
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Aligned ICD values\n\t ICD Start : %d\n\t ICD Count : %d\n\t ICD Discarded : %d\n",
                 798, phba->fw_config.iscsi_icd_start[(int )ulp_num], phba->fw_config.iscsi_icd_count[(int )ulp_num],
                 icd_count_unavailable);
    } else {

    }
#line 799
    goto ldv_55017;
  } else {

  }
#line 750
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_55019: ;
#line 750
  if ((unsigned int )ulp_num <= 1U) {
#line 752
    goto ldv_55018;
  } else {

  }
  ldv_55017: 
#line 803
  total_icd_count = phba->fw_config.iscsi_icd_count[(int )ulp_num];
#line 804
  phba->params.ios_per_ctrl = (total_icd_count - total_cid_count) - 32U;
#line 807
  phba->params.cxns_per_ctrl = total_cid_count;
#line 808
  phba->params.asyncpdus_per_ctrl = total_cid_count;
#line 809
  phba->params.icds_per_ctrl = total_icd_count;
#line 810
  phba->params.num_sge_per_io = 32U;
#line 811
  phba->params.defpdu_hdr_sz = 64U;
#line 812
  phba->params.defpdu_data_sz = 8192U;
#line 813
  phba->params.eq_timer = 64U;
#line 814
  phba->params.num_eq_entries = 1024U;
#line 815
  phba->params.num_cq_entries = 1024U;
#line 816
  phba->params.wrbs_per_cxn = 256U;
#line 817
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_ring_eq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int clr_interrupt ,
                           unsigned int num_processed , unsigned char rearm , unsigned char event ) 
{ 
  u32 val ;

  {
#line 824
  val = 0U;
#line 826
  if ((unsigned int )rearm != 0U) {
#line 827
    val = val | 536870912U;
  } else {

  }
#line 828
  if (clr_interrupt != 0U) {
#line 829
    val = val | 512U;
  } else {

  }
#line 830
  if ((unsigned int )event != 0U) {
#line 831
    val = val | 1024U;
  } else {

  }
#line 833
  val = (num_processed << 16) | val;
#line 835
  val = (id & 511U) | val;
#line 838
  val = (((id >> 9) << 11) & 65535U) | val;
#line 842
  iowrite32(val, (void *)phba->db_va + 288U);
#line 843
  return;
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr_mcc(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *mcc ;
  unsigned int num_eq_processed ;
  struct be_eq_obj *pbe_eq ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  u32 tmp___1 ;
  void *tmp___2 ;

  {
#line 853
  eqe = (struct be_eq_entry *)0;
#line 860
  pbe_eq = (struct be_eq_obj *)dev_id;
#line 861
  eq = & pbe_eq->q;
#line 862
  phba = pbe_eq->phba;
#line 863
  mcc = & phba->ctrl.mcc_obj.cq;
#line 864
  tmp = queue_tail_node(eq);
#line 864
  eqe = (struct be_eq_entry *)tmp;
#line 866
  num_eq_processed = 0U;
#line 868
  goto ldv_55044;
  ldv_55043: ;
#line 870
  if (eqe->dw[0UL] >> 16 == (u32 )mcc->id) {
#line 873
    tmp___0 = spinlock_check(& phba->isr_lock);
#line 873
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 874
    pbe_eq->todo_mcc_cq = 1;
#line 875
    spin_unlock_irqrestore(& phba->isr_lock, flags);
  } else {

  }
#line 877
  tmp___1 = amap_mask(1U);
#line 877
  amap_set((void *)eqe, 0U, tmp___1, 0U, 0U);
#line 878
  queue_tail_inc(eq);
#line 879
  tmp___2 = queue_tail_node(eq);
#line 879
  eqe = (struct be_eq_entry *)tmp___2;
#line 880
  num_eq_processed = num_eq_processed + 1U;
  ldv_55044: ;
#line 868
  if ((int )eqe->dw[0UL] & 1) {
#line 870
    goto ldv_55043;
  } else {

  }

#line 882
  if ((int )pbe_eq->todo_mcc_cq) {
#line 883
    queue_work(phba->wq, & pbe_eq->work_cqs);
  } else {

  }
#line 884
  if (num_eq_processed != 0U) {
#line 885
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_eq_processed, 1, 1);
  } else {

  }
#line 887
  return (1);
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr_msix(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  unsigned int num_eq_processed ;
  struct be_eq_obj *pbe_eq ;
  void *tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  void *tmp___2 ;

  {
#line 898
  eqe = (struct be_eq_entry *)0;
#line 904
  pbe_eq = (struct be_eq_obj *)dev_id;
#line 905
  eq = & pbe_eq->q;
#line 906
  cq = pbe_eq->cq;
#line 907
  tmp = queue_tail_node(eq);
#line 907
  eqe = (struct be_eq_entry *)tmp;
#line 909
  phba = pbe_eq->phba;
#line 910
  num_eq_processed = 0U;
#line 911
  goto ldv_55057;
  ldv_55056: 
#line 913
  tmp___0 = blk_iopoll_sched_prep(& pbe_eq->iopoll);
#line 913
  if (tmp___0 == 0) {
#line 914
    blk_iopoll_sched(& pbe_eq->iopoll);
  } else {

  }
#line 916
  tmp___1 = amap_mask(1U);
#line 916
  amap_set((void *)eqe, 0U, tmp___1, 0U, 0U);
#line 917
  queue_tail_inc(eq);
#line 918
  tmp___2 = queue_tail_node(eq);
#line 918
  eqe = (struct be_eq_entry *)tmp___2;
#line 919
  num_eq_processed = num_eq_processed + 1U;
  ldv_55057: ;
#line 911
  if ((int )eqe->dw[0UL] & 1) {
#line 913
    goto ldv_55056;
  } else {

  }

#line 922
  if (num_eq_processed != 0U) {
#line 923
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_eq_processed, 0, 1);
  } else {

  }
#line 925
  return (1);
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *mcc ;
  unsigned long flags ;
  unsigned long index ;
  unsigned int num_mcceq_processed ;
  unsigned int num_ioeq_processed ;
  struct be_ctrl_info *ctrl ;
  struct be_eq_obj *pbe_eq ;
  int isr ;
  unsigned int tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;
  void *tmp___4 ;

  {
#line 938
  eqe = (struct be_eq_entry *)0;
#line 947
  phba = (struct beiscsi_hba *)dev_id;
#line 948
  ctrl = & phba->ctrl;
#line 949
  tmp = ioread32((void *)(ctrl->csr + ((unsigned long )(((ctrl->pdev)->devfn & 7U) * 4U) + 3096UL)));
#line 949
  isr = (int )tmp;
#line 951
  if (isr == 0) {
#line 952
    return (0);
  } else {

  }
#line 954
  phwi_ctrlr = phba->phwi_ctrlr;
#line 955
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 956
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq);
#line 958
  eq = & phwi_context->be_eq[0].q;
#line 959
  mcc = & phba->ctrl.mcc_obj.cq;
#line 960
  index = 0UL;
#line 961
  tmp___0 = queue_tail_node(eq);
#line 961
  eqe = (struct be_eq_entry *)tmp___0;
#line 963
  num_ioeq_processed = 0U;
#line 964
  num_mcceq_processed = 0U;
#line 965
  goto ldv_55080;
  ldv_55079: ;
#line 967
  if (eqe->dw[0UL] >> 16 == (u32 )mcc->id) {
#line 970
    tmp___1 = spinlock_check(& phba->isr_lock);
#line 970
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 971
    pbe_eq->todo_mcc_cq = 1;
#line 972
    spin_unlock_irqrestore(& phba->isr_lock, flags);
#line 973
    num_mcceq_processed = num_mcceq_processed + 1U;
  } else {
#line 975
    tmp___2 = blk_iopoll_sched_prep(& pbe_eq->iopoll);
#line 975
    if (tmp___2 == 0) {
#line 976
      blk_iopoll_sched(& pbe_eq->iopoll);
    } else {

    }
#line 977
    num_ioeq_processed = num_ioeq_processed + 1U;
  }
#line 979
  tmp___3 = amap_mask(1U);
#line 979
  amap_set((void *)eqe, 0U, tmp___3, 0U, 0U);
#line 980
  queue_tail_inc(eq);
#line 981
  tmp___4 = queue_tail_node(eq);
#line 981
  eqe = (struct be_eq_entry *)tmp___4;
  ldv_55080: ;
#line 965
  if ((int )eqe->dw[0UL] & 1) {
#line 967
    goto ldv_55079;
  } else {

  }

#line 983
  if (num_ioeq_processed != 0U || num_mcceq_processed != 0U) {
#line 984
    if ((int )pbe_eq->todo_mcc_cq) {
#line 985
      queue_work(phba->wq, & pbe_eq->work_cqs);
    } else {

    }
#line 987
    if (num_mcceq_processed != 0U && num_ioeq_processed == 0U) {
#line 988
      hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, num_ioeq_processed + num_mcceq_processed,
                     1, 1);
    } else {
#line 992
      hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, num_ioeq_processed + num_mcceq_processed,
                     0, 1);
    }
#line 996
    return (1);
  } else {
#line 998
    return (0);
  }
}
}
#line 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_irqs(struct beiscsi_hba *phba ) 
{ 
  struct pci_dev *pcidev ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  int ret ;
  int msix_vec ;
  int i ;
  int j ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 1003
  pcidev = phba->pcidev;
#line 1008
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1009
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 1011
  if ((int )phba->msix_enabled) {
#line 1012
    i = 0;
#line 1012
    goto ldv_55095;
    ldv_55094: 
#line 1013
    tmp = kzalloc(20UL, 208U);
#line 1013
    phba->msi_name[i] = (char *)tmp;
#line 1015
    if ((unsigned long )phba->msi_name[i] == (unsigned long )((char *)0)) {
#line 1016
      ret = -12;
#line 1017
      goto free_msix_irqs;
    } else {

    }
#line 1020
    sprintf(phba->msi_name[i], "beiscsi_%02x_%02x", (phba->shost)->host_no, i);
#line 1022
    msix_vec = (int )phba->msix_entries[i].vector;
#line 1023
    ret = ldv_request_irq_24((unsigned int )msix_vec, & be_isr_msix, 0UL, (char const   *)phba->msi_name[i],
                             (void *)(& phwi_context->be_eq) + (unsigned long )i);
#line 1026
    if (ret != 0) {
#line 1027
      log_value = phba->attr_log_enable;
#line 1027
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1027
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed toregister msix for i = %d\n",
                   1030, i);
      } else {

      }
#line 1031
      kfree((void const   *)phba->msi_name[i]);
#line 1032
      goto free_msix_irqs;
    } else {

    }
#line 1012
    i = i + 1;
    ldv_55095: ;
#line 1012
    if ((unsigned int )i < phba->num_cpus) {
#line 1014
      goto ldv_55094;
    } else {

    }
#line 1035
    tmp___0 = kzalloc(20UL, 208U);
#line 1035
    phba->msi_name[i] = (char *)tmp___0;
#line 1036
    if ((unsigned long )phba->msi_name[i] == (unsigned long )((char *)0)) {
#line 1037
      ret = -12;
#line 1038
      goto free_msix_irqs;
    } else {

    }
#line 1040
    sprintf(phba->msi_name[i], "beiscsi_mcc_%02x", (phba->shost)->host_no);
#line 1042
    msix_vec = (int )phba->msix_entries[i].vector;
#line 1043
    ret = ldv_request_irq_25((unsigned int )msix_vec, & be_isr_mcc, 0UL, (char const   *)phba->msi_name[i],
                             (void *)(& phwi_context->be_eq) + (unsigned long )i);
#line 1045
    if (ret != 0) {
#line 1046
      log_value___0 = phba->attr_log_enable;
#line 1046
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1046
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed to register beiscsi_msix_mcc\n",
                   1048);
      } else {

      }
#line 1049
      kfree((void const   *)phba->msi_name[i]);
#line 1050
      goto free_msix_irqs;
    } else {

    }
  } else {
#line 1054
    ret = ldv_request_irq_26(pcidev->irq, & be_isr, 128UL, "beiscsi", (void *)phba);
#line 1056
    if (ret != 0) {
#line 1057
      log_value___1 = phba->attr_log_enable;
#line 1057
      if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1057
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed to register irq\\n", 1059);
      } else {

      }
#line 1060
      return (ret);
    } else {

    }
  }
#line 1063
  return (0);
  free_msix_irqs: 
#line 1065
  j = i + -1;
#line 1065
  goto ldv_55100;
  ldv_55099: 
#line 1066
  kfree((void const   *)phba->msi_name[j]);
#line 1067
  msix_vec = (int )phba->msix_entries[j].vector;
#line 1068
  ldv_free_irq_27((unsigned int )msix_vec, (void *)(& phwi_context->be_eq) + (unsigned long )j);
#line 1065
  j = j - 1;
  ldv_55100: ;
#line 1065
  if (j >= 0) {
#line 1067
    goto ldv_55099;
  } else {

  }

#line 1070
  return (ret);
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void hwi_ring_cq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int num_processed ,
                    unsigned char rearm , unsigned char event ) 
{ 
  u32 val ;

  {
#line 1077
  val = 0U;
#line 1079
  if ((unsigned int )rearm != 0U) {
#line 1080
    val = val | 536870912U;
  } else {

  }
#line 1082
  val = (num_processed << 16) | val;
#line 1085
  val = (id & 1023U) | val;
#line 1088
  val = (((id >> 10) << 11) & 65535U) | val;
#line 1092
  iowrite32(val, (void *)phba->db_va + 288U);
#line 1093
  return;
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int beiscsi_process_async_pdu(struct beiscsi_conn *beiscsi_conn ,
                                              struct beiscsi_hba *phba , struct pdu_base *ppdu ,
                                              unsigned long pdu_len , void *pbuffer ,
                                              unsigned long buf_len ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct iscsi_task *task ;
  struct beiscsi_io_task *io_task ;
  struct iscsi_hdr *login_hdr ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1102
  conn = beiscsi_conn->conn;
#line 1103
  session = conn->session;
#line 1108
  switch (ppdu->dw[0UL] & 63U) {
  case 32U: 
#line 1111
  pbuffer = (void *)0;
#line 1112
  buf_len = 0UL;
#line 1113
  goto ldv_55124;
  case 50U: ;
#line 1115
  goto ldv_55124;
  case 63U: 
#line 1117
  __ret_warn_on = (unsigned long )pbuffer == (unsigned long )((void *)0);
#line 1117
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1117
  if (tmp != 0L) {
#line 1117
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       1117);
  } else {

  }
#line 1117
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1118
  __ret_warn_on___0 = buf_len != 48UL;
#line 1118
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1118
  if (tmp___0 != 0L) {
#line 1118
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       1118);
  } else {

  }
#line 1118
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1119
  log_value = phba->attr_log_enable;
#line 1119
  if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1119
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In ISCSI_OP_REJECT\n",
               1121);
  } else {

  }
#line 1122
  goto ldv_55124;
  case 35U: ;
  case 36U: 
#line 1125
  task = conn->login_task;
#line 1126
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1127
  login_hdr = (struct iscsi_hdr *)ppdu;
#line 1128
  login_hdr->itt = io_task->libiscsi_itt;
#line 1129
  goto ldv_55124;
  default: 
#line 1131
  log_value___0 = phba->attr_log_enable;
#line 1131
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1131
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unrecognized opcode 0x%x in async msg\n",
               1136, ppdu->dw[0UL] & 63U);
  } else {

  }
#line 1137
  return (1U);
  }
  ldv_55124: 
#line 1140
  spin_lock_bh(& session->back_lock);
#line 1141
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)ppdu, (char *)pbuffer, (int )buf_len);
#line 1142
  spin_unlock_bh(& session->back_lock);
#line 1143
  return (0U);
}
}
#line 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct sgl_handle *psgl_handle ;
  uint32_t log_value ;

  {
#line 1150
  if ((unsigned int )phba->io_sgl_hndl_avbl != 0U) {
#line 1151
    log_value = phba->attr_log_enable;
#line 1151
    if ((log_value & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1151
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : In alloc_io_sgl_handle, io_sgl_alloc_index=%d\n", 1154,
                 (int )phba->io_sgl_alloc_index);
    } else {

    }
#line 1156
    psgl_handle = *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_alloc_index);
#line 1158
    *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_alloc_index) = (struct sgl_handle *)0;
#line 1159
    phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl - 1);
#line 1160
    if ((unsigned int )phba->io_sgl_alloc_index == phba->params.ios_per_ctrl - 1U) {
#line 1162
      phba->io_sgl_alloc_index = 0U;
    } else {
#line 1164
      phba->io_sgl_alloc_index = (unsigned short )((int )phba->io_sgl_alloc_index + 1);
    }
  } else {
#line 1166
    psgl_handle = (struct sgl_handle *)0;
  }
#line 1167
  return (psgl_handle);
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void free_io_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1173
  log_value = phba->attr_log_enable;
#line 1173
  if ((log_value & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1173
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In free_,io_sgl_free_index=%d\n",
               1175, (int )phba->io_sgl_free_index);
  } else {

  }
#line 1177
  if ((unsigned long )*(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index) != (unsigned long )((struct sgl_handle *)0)) {
#line 1182
    log_value___0 = phba->attr_log_enable;
#line 1182
    if ((log_value___0 & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1182
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Double Free in IO SGL io_sgl_free_index=%d,value there=%p\n",
                 1186, (int )phba->io_sgl_free_index, *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index));
    } else {

    }
#line 1187
    return;
  } else {

  }
#line 1189
  *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index) = psgl_handle;
#line 1190
  phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl + 1);
#line 1191
  if ((unsigned int )phba->io_sgl_free_index == phba->params.ios_per_ctrl - 1U) {
#line 1192
    phba->io_sgl_free_index = 0U;
  } else {
#line 1194
    phba->io_sgl_free_index = (unsigned short )((int )phba->io_sgl_free_index + 1);
  }
#line 1195
  return;
}
}
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba , unsigned int cid ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  struct wrb_handle *pwrb_handle ;
  struct wrb_handle *pwrb_handle_tmp ;
  uint16_t cri_index ;

  {
#line 1209
  cri_index = phba->cid_to_cri_map[cid];
#line 1211
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1212
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1213
  if ((unsigned int )pwrb_context->wrb_handles_available > 1U) {
#line 1214
    pwrb_handle = *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->alloc_index);
#line 1216
    pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available - 1);
#line 1217
    if ((unsigned int )pwrb_context->alloc_index == phba->params.wrbs_per_cxn - 1U) {
#line 1219
      pwrb_context->alloc_index = 0U;
    } else {
#line 1221
      pwrb_context->alloc_index = (unsigned short )((int )pwrb_context->alloc_index + 1);
    }
#line 1222
    pwrb_handle_tmp = *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->alloc_index);
#line 1224
    pwrb_handle->nxt_wrb_index = pwrb_handle_tmp->wrb_index;
  } else {
#line 1226
    pwrb_handle = (struct wrb_handle *)0;
  }
#line 1227
  return (pwrb_handle);
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void free_wrb_handle(struct beiscsi_hba *phba , struct hwi_wrb_context *pwrb_context ,
                            struct wrb_handle *pwrb_handle ) 
{ 
  uint32_t log_value ;

  {
#line 1242
  *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->free_index) = pwrb_handle;
#line 1243
  pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available + 1);
#line 1244
  if ((unsigned int )pwrb_context->free_index == phba->params.wrbs_per_cxn - 1U) {
#line 1245
    pwrb_context->free_index = 0U;
  } else {
#line 1247
    pwrb_context->free_index = (unsigned short )((int )pwrb_context->free_index + 1);
  }
#line 1249
  log_value = phba->attr_log_enable;
#line 1249
  if ((log_value & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1249
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : FREE WRB: pwrb_handle=%p free_index=0x%xwrb_handles_available=%d\n",
               1254, pwrb_handle, (int )pwrb_context->free_index, (int )pwrb_context->wrb_handles_available);
  } else {

  }
#line 1251
  return;
}
}
#line 1257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct sgl_handle *psgl_handle ;
  uint32_t log_value ;

  {
#line 1261
  if ((unsigned int )phba->eh_sgl_hndl_avbl != 0U) {
#line 1262
    psgl_handle = *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_alloc_index);
#line 1263
    *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_alloc_index) = (struct sgl_handle *)0;
#line 1264
    log_value = phba->attr_log_enable;
#line 1264
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1264
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : mgmt_sgl_alloc_index=%d=0x%x\n", 1267, (int )phba->eh_sgl_alloc_index,
                 (int )phba->eh_sgl_alloc_index);
    } else {

    }
#line 1269
    phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl - 1);
#line 1270
    if ((unsigned int )phba->eh_sgl_alloc_index == (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) - 1U) {
#line 1273
      phba->eh_sgl_alloc_index = 0U;
    } else {
#line 1275
      phba->eh_sgl_alloc_index = (unsigned short )((int )phba->eh_sgl_alloc_index + 1);
    }
  } else {
#line 1277
    psgl_handle = (struct sgl_handle *)0;
  }
#line 1278
  return (psgl_handle);
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void free_mgmt_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1285
  log_value = phba->attr_log_enable;
#line 1285
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1285
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In  free_mgmt_sgl_handle,eh_sgl_free_index=%d\n",
               1288, (int )phba->eh_sgl_free_index);
  } else {

  }
#line 1290
  if ((unsigned long )*(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_free_index) != (unsigned long )((struct sgl_handle *)0)) {
#line 1295
    log_value___0 = phba->attr_log_enable;
#line 1295
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1295
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Double Free in eh SGL ,eh_sgl_free_index=%d\n",
                 1298, (int )phba->eh_sgl_free_index);
    } else {

    }
#line 1299
    return;
  } else {

  }
#line 1301
  *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_free_index) = psgl_handle;
#line 1302
  phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl + 1);
#line 1303
  if ((unsigned int )phba->eh_sgl_free_index == (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) - 1U) {
#line 1305
    phba->eh_sgl_free_index = 0U;
  } else {
#line 1307
    phba->eh_sgl_free_index = (unsigned short )((int )phba->eh_sgl_free_index + 1);
  }
#line 1308
  return;
}
}
#line 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_io(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                           struct common_sol_cqe *csol_cqe ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct be_status_bhs *sts_bhs ;
  struct iscsi_conn *conn ;
  unsigned char *sense ;
  u32 resid ;
  u32 exp_cmdsn ;
  u32 max_cmdsn ;
  u8 rsp ;
  u8 status ;
  u8 flags ;
  unsigned int tmp ;
  u16 sense_len ;
  unsigned short *slen ;
  __u16 tmp___0 ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 1315
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1316
  sts_bhs = (struct be_status_bhs *)io_task->cmd_bhs;
#line 1318
  conn = beiscsi_conn->conn;
#line 1320
  resid = 0U;
#line 1323
  exp_cmdsn = csol_cqe->exp_cmdsn;
#line 1324
  max_cmdsn = (csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U;
#line 1326
  rsp = csol_cqe->i_resp;
#line 1327
  status = csol_cqe->i_sts;
#line 1328
  flags = csol_cqe->i_flags;
#line 1329
  resid = csol_cqe->res_cnt;
#line 1331
  if ((unsigned long )task->sc == (unsigned long )((struct scsi_cmnd *)0)) {
#line 1332
    if ((unsigned long )io_task->scsi_cmnd != (unsigned long )((struct scsi_cmnd *)0)) {
#line 1333
      scsi_dma_unmap(io_task->scsi_cmnd);
#line 1334
      io_task->scsi_cmnd = (struct scsi_cmnd *)0;
    } else {

    }
#line 1337
    return;
  } else {

  }
#line 1339
  (task->sc)->result = (int )status;
#line 1340
  if ((unsigned int )rsp != 0U) {
#line 1341
    (task->sc)->result = 458752;
#line 1342
    goto unmap;
  } else {

  }
#line 1346
  if (((int )flags & 6) != 0) {
#line 1347
    if ((unsigned int )status == 0U && ((int )flags & 4) != 0) {
#line 1348
      (task->sc)->result = 458752;
    } else {

    }
#line 1350
    if (((int )flags & 2) != 0) {
#line 1351
      scsi_set_resid(task->sc, (int )resid);
#line 1352
      if ((unsigned int )status == 0U) {
#line 1352
        tmp = scsi_bufflen(task->sc);
#line 1352
        if (tmp - resid < (task->sc)->underflow) {
#line 1354
          (task->sc)->result = 458752;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1358
  if ((unsigned int )status == 2U) {
#line 1360
    slen = (unsigned short *)(& sts_bhs->sense_info);
#line 1362
    sense = (unsigned char *)(& sts_bhs->sense_info) + 2UL;
#line 1363
    tmp___0 = __fswab16((int )*slen);
#line 1363
    sense_len = tmp___0;
#line 1364
    __min1 = sense_len;
#line 1364
    __min2 = 96U;
#line 1364
    memcpy((void *)(task->sc)->sense_buffer, (void const   *)sense, (size_t )((int )__min1 < (int )__min2 ? __min1 : __min2));
  } else {

  }
#line 1368
  if (((int )(io_task->cmd_bhs)->iscsi_hdr.flags & 64) != 0) {
#line 1369
    conn->rxdata_octets = conn->rxdata_octets + (uint64_t )resid;
  } else {

  }
  unmap: ;
#line 1371
  if ((unsigned long )io_task->scsi_cmnd != (unsigned long )((struct scsi_cmnd *)0)) {
#line 1372
    scsi_dma_unmap(io_task->scsi_cmnd);
#line 1373
    io_task->scsi_cmnd = (struct scsi_cmnd *)0;
  } else {

  }
#line 1375
  iscsi_complete_scsi_task(task, exp_cmdsn, max_cmdsn);
#line 1376
  return;
}
}
#line 1379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_logout(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                               struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_logout_rsp *hdr ;
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 1384
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1385
  conn = beiscsi_conn->conn;
#line 1387
  hdr = (struct iscsi_logout_rsp *)task->hdr;
#line 1388
  hdr->opcode = 38U;
#line 1389
  hdr->t2wait = 5U;
#line 1390
  hdr->t2retain = 0U;
#line 1391
  hdr->flags = csol_cqe->i_flags;
#line 1392
  hdr->response = csol_cqe->i_resp;
#line 1393
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1393
  hdr->exp_cmdsn = tmp;
#line 1394
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1394
  hdr->max_cmdsn = tmp___0;
#line 1397
  hdr->dlength[0] = 0U;
#line 1398
  hdr->dlength[1] = 0U;
#line 1399
  hdr->dlength[2] = 0U;
#line 1400
  hdr->hlength = 0U;
#line 1401
  hdr->itt = io_task->libiscsi_itt;
#line 1402
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
#line 1403
  return;
}
}
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_tmf(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                            struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_tm_rsp *hdr ;
  struct iscsi_conn *conn ;
  struct beiscsi_io_task *io_task ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 1411
  conn = beiscsi_conn->conn;
#line 1412
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1414
  hdr = (struct iscsi_tm_rsp *)task->hdr;
#line 1415
  hdr->opcode = 34U;
#line 1416
  hdr->flags = csol_cqe->i_flags;
#line 1417
  hdr->response = csol_cqe->i_resp;
#line 1418
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1418
  hdr->exp_cmdsn = tmp;
#line 1419
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1419
  hdr->max_cmdsn = tmp___0;
#line 1422
  hdr->itt = io_task->libiscsi_itt;
#line 1423
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
#line 1424
  return;
}
}
#line 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_complete_drvr_msgs(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                   struct sol_cqe *psol ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct wrb_handle *pwrb_handle ;
  struct hwi_controller *phwi_ctrlr ;
  struct iscsi_task *task ;
  struct beiscsi_io_task *io_task ;
  uint16_t wrb_index ;
  uint16_t cid ;
  uint16_t cri_index ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;

  {
#line 1431
  pwrb_handle = (struct wrb_handle *)0;
#line 1437
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1438
  if (phba->generation == 3U || phba->generation == 2U) {
#line 1439
    tmp = amap_mask(8U);
#line 1439
    tmp___0 = amap_get((void *)psol, 2U, tmp, 16U);
#line 1439
    wrb_index = (uint16_t )tmp___0;
#line 1441
    tmp___1 = amap_mask(10U);
#line 1441
    tmp___2 = amap_get((void *)psol, 2U, tmp___1, 6U);
#line 1441
    cid = (uint16_t )tmp___2;
  } else {
#line 1444
    tmp___3 = amap_mask(16U);
#line 1444
    tmp___4 = amap_get((void *)psol, 2U, tmp___3, 16U);
#line 1444
    wrb_index = (uint16_t )tmp___4;
#line 1446
    tmp___5 = amap_mask(13U);
#line 1446
    tmp___6 = amap_get((void *)psol, 3U, tmp___5, 16U);
#line 1446
    cid = (uint16_t )tmp___6;
  }
#line 1450
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 1451
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1452
  pwrb_handle = *(pwrb_context->pwrb_handle_basestd + (unsigned long )wrb_index);
#line 1453
  task = pwrb_handle->pio_handle;
#line 1455
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1456
  memset((void *)(io_task->pwrb_handle)->pwrb, 0, 64UL);
#line 1457
  iscsi_put_task(task);
#line 1458
  return;
}
}
#line 1461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_nopin_resp(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                                   struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_nopin *hdr ;
  struct iscsi_conn *conn ;
  struct beiscsi_io_task *io_task ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
#line 1466
  conn = beiscsi_conn->conn;
#line 1467
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1469
  hdr = (struct iscsi_nopin *)task->hdr;
#line 1470
  hdr->flags = csol_cqe->i_flags;
#line 1471
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1471
  hdr->exp_cmdsn = tmp;
#line 1472
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1472
  hdr->max_cmdsn = tmp___0;
#line 1475
  hdr->opcode = 32U;
#line 1476
  hdr->itt = io_task->libiscsi_itt;
#line 1477
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
#line 1478
  return;
}
}
#line 1480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void adapter_get_sol_cqe(struct beiscsi_hba *phba , struct sol_cqe *psol ,
                                struct common_sol_cqe *csol_cqe ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;
  u32 tmp___28 ;
  u32 tmp___29 ;
  u32 tmp___30 ;
  u32 tmp___31 ;
  u32 tmp___32 ;
  u32 tmp___33 ;
  u32 tmp___34 ;

  {
#line 1484
  if (phba->generation == 3U || phba->generation == 2U) {
#line 1485
    tmp = amap_mask(32U);
#line 1485
    csol_cqe->exp_cmdsn = amap_get((void *)psol, 1U, tmp, 0U);
#line 1487
    tmp___0 = amap_mask(31U);
#line 1487
    csol_cqe->res_cnt = amap_get((void *)psol, 3U, tmp___0, 0U);
#line 1489
    tmp___1 = amap_mask(8U);
#line 1489
    tmp___2 = amap_get((void *)psol, 2U, tmp___1, 24U);
#line 1489
    csol_cqe->cmd_wnd = (u8 )tmp___2;
#line 1491
    tmp___3 = amap_mask(8U);
#line 1491
    tmp___4 = amap_get((void *)psol, 2U, tmp___3, 16U);
#line 1491
    csol_cqe->wrb_index = (u16 )tmp___4;
#line 1493
    tmp___5 = amap_mask(10U);
#line 1493
    tmp___6 = amap_get((void *)psol, 2U, tmp___5, 6U);
#line 1493
    csol_cqe->cid = (u16 )tmp___6;
#line 1495
    tmp___7 = amap_mask(8U);
#line 1495
    tmp___8 = amap_get((void *)psol, 0U, tmp___7, 0U);
#line 1495
    csol_cqe->hw_sts = (u8 )tmp___8;
#line 1497
    tmp___9 = amap_mask(8U);
#line 1497
    tmp___10 = amap_get((void *)psol, 0U, tmp___9, 16U);
#line 1497
    csol_cqe->i_resp = (u8 )tmp___10;
#line 1499
    tmp___11 = amap_mask(8U);
#line 1499
    tmp___12 = amap_get((void *)psol, 0U, tmp___11, 8U);
#line 1499
    csol_cqe->i_sts = (u8 )tmp___12;
#line 1501
    tmp___13 = amap_mask(7U);
#line 1501
    tmp___14 = amap_get((void *)psol, 0U, tmp___13, 24U);
#line 1501
    csol_cqe->i_flags = (u8 )tmp___14;
  } else {
#line 1504
    tmp___15 = amap_mask(32U);
#line 1504
    csol_cqe->exp_cmdsn = amap_get((void *)psol, 1U, tmp___15, 0U);
#line 1506
    tmp___16 = amap_mask(31U);
#line 1506
    csol_cqe->res_cnt = amap_get((void *)psol, 3U, tmp___16, 0U);
#line 1508
    tmp___17 = amap_mask(16U);
#line 1508
    tmp___18 = amap_get((void *)psol, 0U, tmp___17, 16U);
#line 1508
    csol_cqe->wrb_index = (u16 )tmp___18;
#line 1510
    tmp___19 = amap_mask(13U);
#line 1510
    tmp___20 = amap_get((void *)psol, 2U, tmp___19, 16U);
#line 1510
    csol_cqe->cid = (u16 )tmp___20;
#line 1512
    tmp___21 = amap_mask(8U);
#line 1512
    tmp___22 = amap_get((void *)psol, 0U, tmp___21, 0U);
#line 1512
    csol_cqe->hw_sts = (u8 )tmp___22;
#line 1514
    tmp___23 = amap_mask(8U);
#line 1514
    tmp___24 = amap_get((void *)psol, 2U, tmp___23, 8U);
#line 1514
    csol_cqe->cmd_wnd = (u8 )tmp___24;
#line 1516
    tmp___29 = amap_mask(1U);
#line 1516
    tmp___30 = amap_get((void *)psol, 2U, tmp___29, 6U);
#line 1516
    if (tmp___30 != 0U) {
#line 1518
      tmp___25 = amap_mask(8U);
#line 1518
      tmp___26 = amap_get((void *)psol, 0U, tmp___25, 8U);
#line 1518
      csol_cqe->i_sts = (u8 )tmp___26;
    } else {
#line 1521
      tmp___27 = amap_mask(8U);
#line 1521
      tmp___28 = amap_get((void *)psol, 0U, tmp___27, 8U);
#line 1521
      csol_cqe->i_resp = (u8 )tmp___28;
    }
#line 1523
    tmp___31 = amap_mask(1U);
#line 1523
    tmp___32 = amap_get((void *)psol, 2U, tmp___31, 29U);
#line 1523
    if (tmp___32 != 0U) {
#line 1525
      csol_cqe->i_flags = 2U;
    } else {

    }
#line 1527
    tmp___33 = amap_mask(1U);
#line 1527
    tmp___34 = amap_get((void *)psol, 2U, tmp___33, 30U);
#line 1527
    if (tmp___34 != 0U) {
#line 1529
      csol_cqe->i_flags = (u8 )((unsigned int )csol_cqe->i_flags | 4U);
    } else {

    }
  }
#line 1531
  return;
}
}
#line 1534 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                             struct sol_cqe *psol ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct wrb_handle *pwrb_handle ;
  struct iscsi_wrb *pwrb ;
  struct hwi_controller *phwi_ctrlr ;
  struct iscsi_task *task ;
  unsigned int type ;
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct common_sol_cqe csol_cqe ;
  uint16_t cri_index ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1539
  pwrb = (struct iscsi_wrb *)0;
#line 1543
  conn = beiscsi_conn->conn;
#line 1544
  session = conn->session;
#line 1545
  csol_cqe.exp_cmdsn = 0U;
#line 1545
  csol_cqe.res_cnt = 0U;
#line 1545
  csol_cqe.wrb_index = (unsigned short)0;
#line 1545
  csol_cqe.cid = (unsigned short)0;
#line 1545
  csol_cqe.hw_sts = (unsigned char)0;
#line 1545
  csol_cqe.cmd_wnd = (unsigned char)0;
#line 1545
  csol_cqe.res_flag = (unsigned char)0;
#line 1545
  csol_cqe.i_resp = (unsigned char)0;
#line 1545
  csol_cqe.i_flags = (unsigned char)0;
#line 1545
  csol_cqe.i_sts = (unsigned char)0;
#line 1546
  cri_index = 0U;
#line 1548
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1551
  adapter_get_sol_cqe(phba, psol, & csol_cqe);
#line 1553
  cri_index = phba->cid_to_cri_map[(int )csol_cqe.cid];
#line 1554
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1556
  pwrb_handle = *(pwrb_context->pwrb_handle_basestd + (unsigned long )csol_cqe.wrb_index);
#line 1559
  task = pwrb_handle->pio_handle;
#line 1560
  pwrb = pwrb_handle->pwrb;
#line 1561
  type = (unsigned int )((struct beiscsi_io_task *)task->dd_data)->wrb_type;
#line 1563
  spin_lock_bh(& session->back_lock);
#line 1564
  switch (type) {
  case 1U: ;
  case 5U: ;
#line 1567
  if (((int )(task->hdr)->opcode & 63) == 0) {
#line 1569
    be_complete_nopin_resp(beiscsi_conn, task, & csol_cqe);
  } else {
#line 1571
    be_complete_io(beiscsi_conn, task, & csol_cqe);
  }
#line 1572
  goto ldv_55253;
  case 2U: ;
#line 1575
  if (((int )(task->hdr)->opcode & 63) == 6) {
#line 1576
    be_complete_logout(beiscsi_conn, task, & csol_cqe);
  } else {
#line 1578
    be_complete_tmf(beiscsi_conn, task, & csol_cqe);
  }
#line 1579
  goto ldv_55253;
  case 11U: 
#line 1582
  log_value = phba->attr_log_enable;
#line 1582
  if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1582
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d :\t\t No HWH_TYPE_LOGIN Expected in hwi_complete_cmd- Solicited path\n",
               1585);
  } else {

  }
#line 1586
  goto ldv_55253;
  case 4U: 
#line 1589
  be_complete_nopin_resp(beiscsi_conn, task, & csol_cqe);
#line 1590
  goto ldv_55253;
  default: 
#line 1593
  log_value___0 = phba->attr_log_enable;
#line 1593
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1593
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In hwi_complete_cmd, unknown type = %dwrb_index 0x%x CID 0x%x\n",
               1598, type, (int )csol_cqe.wrb_index, (int )csol_cqe.cid);
  } else {

  }
#line 1599
  goto ldv_55253;
  }
  ldv_55253: 
#line 1602
  spin_unlock_bh(& session->back_lock);
#line 1603
  return;
}
}
#line 1605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct list_head *hwi_get_async_busy_list(struct hwi_async_pdu_context *pasync_ctx ,
                                                 unsigned int is_header , unsigned int host_write_ptr ) 
{ 


  {
#line 1609
  if (is_header != 0U) {
#line 1610
    return (& (pasync_ctx->async_entry + (unsigned long )host_write_ptr)->header_busy_list);
  } else {
#line 1613
    return (& (pasync_ctx->async_entry + (unsigned long )host_write_ptr)->data_busy_list);
  }
}
}
#line 1617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct async_pdu_handle *hwi_get_async_handle(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                                     struct hwi_async_pdu_context *pasync_ctx ,
                                                     struct i_t_dpdu_cqe *pdpdu_cqe ,
                                                     unsigned int *pcq_index ) 
{ 
  struct be_bus_address phys_addr ;
  struct list_head *pbusy_list ;
  struct async_pdu_handle *pasync_handle ;
  unsigned char is_header ;
  unsigned int index ;
  unsigned int dpl ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  uint32_t log_value ;
  int __ret_warn_on ;
  int tmp___3 ;
  long tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int __ret_warn_on___0 ;
  long tmp___5 ;

  {
#line 1624
  pasync_handle = (struct async_pdu_handle *)0;
#line 1625
  is_header = 0U;
#line 1628
  if (phba->generation == 3U || phba->generation == 2U) {
#line 1629
    tmp = amap_mask(16U);
#line 1629
    dpl = amap_get((void *)pdpdu_cqe, 2U, tmp, 16U);
#line 1631
    tmp___0 = amap_mask(16U);
#line 1631
    index = amap_get((void *)pdpdu_cqe, 3U, tmp___0, 0U);
  } else {
#line 1634
    tmp___1 = amap_mask(17U);
#line 1634
    dpl = amap_get((void *)pdpdu_cqe, 2U, tmp___1, 15U);
#line 1636
    tmp___2 = amap_mask(16U);
#line 1636
    index = amap_get((void *)pdpdu_cqe, 3U, tmp___2, 0U);
  }
#line 1640
  phys_addr.u.a32.address_lo = pdpdu_cqe->dw[1UL] - dpl;
#line 1643
  phys_addr.u.a32.address_hi = pdpdu_cqe->dw[0UL];
#line 1647
  phys_addr.u.a64.address = phys_addr.u.a64.address;
#line 1650
  switch (pdpdu_cqe->dw[2UL] & 63U) {
  case 28U: 
#line 1653
  is_header = 1U;
#line 1655
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, (unsigned int )is_header, index);
#line 1657
  goto ldv_55279;
  case 29U: 
#line 1659
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, (unsigned int )is_header, index);
#line 1661
  goto ldv_55279;
  default: 
#line 1663
  pbusy_list = (struct list_head *)0;
#line 1664
  log_value = phba->attr_log_enable;
#line 1664
  if ((log_value & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1664
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unexpected code=%d\n",
               1668, pdpdu_cqe->dw[2UL] & 63U);
  } else {

  }
#line 1669
  return ((struct async_pdu_handle *)0);
  }
  ldv_55279: 
#line 1672
  tmp___3 = list_empty((struct list_head  const  *)pbusy_list);
#line 1672
  __ret_warn_on = tmp___3 != 0;
#line 1672
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1672
  if (tmp___4 != 0L) {
#line 1672
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       1672);
  } else {

  }
#line 1672
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1673
  __mptr = (struct list_head  const  *)pbusy_list->next;
#line 1673
  pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1673
  goto ldv_55291;
  ldv_55290: ;
#line 1674
  if (pasync_handle->pa.u.a64.address == phys_addr.u.a64.address) {
#line 1675
    goto ldv_55289;
  } else {

  }
#line 1673
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1673
  pasync_handle = (struct async_pdu_handle *)__mptr___0;
  ldv_55291: ;
#line 1673
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )pbusy_list) {
#line 1675
    goto ldv_55290;
  } else {

  }
  ldv_55289: 
#line 1678
  __ret_warn_on___0 = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1678
  tmp___5 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1678
  if (tmp___5 != 0L) {
#line 1678
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       1678);
  } else {

  }
#line 1678
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1680
  pasync_handle->cri = pasync_ctx->cid_to_async_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 1682
  pasync_handle->is_header = is_header;
#line 1683
  pasync_handle->buffer_len = (unsigned long )dpl;
#line 1684
  *pcq_index = index;
#line 1686
  return (pasync_handle);
}
}
#line 1690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_update_async_writables(struct beiscsi_hba *phba , struct hwi_async_pdu_context *pasync_ctx ,
                                               unsigned int is_header , unsigned int cq_index ) 
{ 
  struct list_head *pbusy_list ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int num_entries ;
  unsigned int writables ;
  unsigned int *pep_read_ptr ;
  unsigned int *pwritables ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  int tmp___2 ;
  uint32_t log_value ;
  int __ret_warn_on___1 ;
  long tmp___3 ;

  {
#line 1696
  writables = 0U;
#line 1699
  num_entries = pasync_ctx->num_entries;
#line 1700
  if (is_header != 0U) {
#line 1701
    pep_read_ptr = & pasync_ctx->async_header.ep_read_ptr;
#line 1702
    pwritables = & pasync_ctx->async_header.writables;
  } else {
#line 1704
    pep_read_ptr = & pasync_ctx->async_data.ep_read_ptr;
#line 1705
    pwritables = & pasync_ctx->async_data.writables;
  }
#line 1708
  goto ldv_55313;
  ldv_55312: 
#line 1709
  *pep_read_ptr = *pep_read_ptr + 1U;
#line 1710
  *pep_read_ptr = *pep_read_ptr % num_entries;
#line 1712
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, is_header, *pep_read_ptr);
#line 1714
  if (writables == 0U) {
#line 1715
    tmp = list_empty((struct list_head  const  *)pbusy_list);
#line 1715
    __ret_warn_on = tmp != 0;
#line 1715
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1715
    if (tmp___0 != 0L) {
#line 1715
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                         1715);
    } else {

    }
#line 1715
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {

  }
#line 1717
  tmp___2 = list_empty((struct list_head  const  *)pbusy_list);
#line 1717
  if (tmp___2 == 0) {
#line 1718
    __mptr = (struct list_head  const  *)pbusy_list->next;
#line 1718
    pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1721
    __ret_warn_on___0 = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1721
    tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1721
    if (tmp___1 != 0L) {
#line 1721
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                         1721);
    } else {

    }
#line 1721
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1722
    pasync_handle->consumed = 1U;
  } else {

  }
#line 1725
  writables = writables + 1U;
  ldv_55313: ;
#line 1708
  if (*pep_read_ptr != cq_index) {
#line 1710
    goto ldv_55312;
  } else {

  }

#line 1728
  if (writables == 0U) {
#line 1729
    log_value = phba->attr_log_enable;
#line 1729
    if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1729
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Duplicate notification received - index 0x%x!!\n",
                 1732, cq_index);
    } else {

    }
#line 1733
    __ret_warn_on___1 = 1;
#line 1733
    tmp___3 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 1733
    if (tmp___3 != 0L) {
#line 1733
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                         1733);
    } else {

    }
#line 1733
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  } else {

  }
#line 1736
  *pwritables = *pwritables + writables;
#line 1737
  return (0U);
}
}
#line 1740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_free_async_msg(struct beiscsi_hba *phba , struct hwi_async_pdu_context *pasync_ctx ,
                               unsigned int cri ) 
{ 
  struct async_pdu_handle *pasync_handle ;
  struct async_pdu_handle *tmp_handle ;
  struct list_head *plist ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1747
  plist = & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list;
#line 1748
  __mptr = (struct list_head  const  *)plist->next;
#line 1748
  pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1748
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1748
  tmp_handle = (struct async_pdu_handle *)__mptr___0;
#line 1748
  goto ldv_55333;
  ldv_55332: 
#line 1749
  list_del(& pasync_handle->link);
#line 1751
  if ((unsigned int )pasync_handle->is_header != 0U) {
#line 1752
    list_add_tail(& pasync_handle->link, & pasync_ctx->async_header.free_list);
#line 1754
    pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries + 1U;
  } else {
#line 1756
    list_add_tail(& pasync_handle->link, & pasync_ctx->async_data.free_list);
#line 1758
    pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries + 1U;
  }
#line 1748
  pasync_handle = tmp_handle;
#line 1748
  __mptr___1 = (struct list_head  const  *)tmp_handle->link.next;
#line 1748
  tmp_handle = (struct async_pdu_handle *)__mptr___1;
  ldv_55333: ;
#line 1748
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )plist) {
#line 1750
    goto ldv_55332;
  } else {

  }
#line 1762
  INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1763
  (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received = 0U;
#line 1764
  (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = 0U;
#line 1765
  return;
}
}
#line 1768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct phys_addr *hwi_get_ring_address(struct hwi_async_pdu_context *pasync_ctx ,
                                              unsigned int is_header , unsigned int host_write_ptr ) 
{ 
  struct phys_addr *pasync_sge ;

  {
#line 1771
  pasync_sge = (struct phys_addr *)0;
#line 1773
  if (is_header != 0U) {
#line 1774
    pasync_sge = (struct phys_addr *)pasync_ctx->async_header.ring_base;
  } else {
#line 1776
    pasync_sge = (struct phys_addr *)pasync_ctx->async_data.ring_base;
  }
#line 1778
  return (pasync_sge + (unsigned long )host_write_ptr);
}
}
#line 1781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_post_async_buffers(struct beiscsi_hba *phba , unsigned int is_header ,
                                   uint8_t ulp_num ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  struct list_head *pfree_link ;
  struct list_head *pbusy_list ;
  struct phys_addr *pasync_sge ;
  unsigned int ring_id ;
  unsigned int num_entries ;
  unsigned int host_write_num ;
  unsigned int doorbell_offset ;
  unsigned int writables ;
  unsigned int i ;
  u32 doorbell ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 1792
  i = 0U;
#line 1793
  doorbell = 0U;
#line 1795
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1796
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num];
#line 1797
  num_entries = pasync_ctx->num_entries;
#line 1799
  if (is_header != 0U) {
#line 1800
    _min1 = pasync_ctx->async_header.writables;
#line 1800
    _min2 = pasync_ctx->async_header.free_entries;
#line 1800
    writables = _min1 < _min2 ? _min1 : _min2;
#line 1802
    pfree_link = pasync_ctx->async_header.free_list.next;
#line 1803
    host_write_num = pasync_ctx->async_header.host_write_ptr;
#line 1804
    ring_id = phwi_ctrlr->default_pdu_hdr[(int )ulp_num].id;
#line 1805
    doorbell_offset = phwi_ctrlr->default_pdu_hdr[(int )ulp_num].doorbell_offset;
  } else {
#line 1808
    _min1___0 = pasync_ctx->async_data.writables;
#line 1808
    _min2___0 = pasync_ctx->async_data.free_entries;
#line 1808
    writables = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 1810
    pfree_link = pasync_ctx->async_data.free_list.next;
#line 1811
    host_write_num = pasync_ctx->async_data.host_write_ptr;
#line 1812
    ring_id = phwi_ctrlr->default_pdu_data[(int )ulp_num].id;
#line 1813
    doorbell_offset = phwi_ctrlr->default_pdu_data[(int )ulp_num].doorbell_offset;
  }
#line 1817
  writables = (writables / 8U) * 8U;
#line 1818
  if (writables != 0U) {
#line 1819
    i = 0U;
#line 1819
    goto ldv_55370;
    ldv_55369: 
#line 1820
    pbusy_list = hwi_get_async_busy_list(pasync_ctx, is_header, host_write_num);
#line 1824
    __mptr = (struct list_head  const  *)pfree_link;
#line 1824
    pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1826
    __ret_warn_on = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1826
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1826
    if (tmp != 0L) {
#line 1826
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                         1826);
    } else {

    }
#line 1826
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1827
    pasync_handle->consumed = 0U;
#line 1829
    pfree_link = pfree_link->next;
#line 1831
    pasync_sge = hwi_get_ring_address(pasync_ctx, is_header, host_write_num);
#line 1834
    pasync_sge->hi = pasync_handle->pa.u.a32.address_lo;
#line 1835
    pasync_sge->lo = pasync_handle->pa.u.a32.address_hi;
#line 1837
    list_move(& pasync_handle->link, pbusy_list);
#line 1839
    host_write_num = host_write_num + 1U;
#line 1840
    host_write_num = host_write_num % num_entries;
#line 1819
    i = i + 1U;
    ldv_55370: ;
#line 1819
    if (i < writables) {
#line 1821
      goto ldv_55369;
    } else {

    }

#line 1843
    if (is_header != 0U) {
#line 1844
      pasync_ctx->async_header.host_write_ptr = host_write_num;
#line 1846
      pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries - writables;
#line 1847
      pasync_ctx->async_header.writables = pasync_ctx->async_header.writables - writables;
#line 1848
      pasync_ctx->async_header.busy_entries = pasync_ctx->async_header.busy_entries + writables;
    } else {
#line 1850
      pasync_ctx->async_data.host_write_ptr = host_write_num;
#line 1851
      pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries - writables;
#line 1852
      pasync_ctx->async_data.writables = pasync_ctx->async_data.writables - writables;
#line 1853
      pasync_ctx->async_data.busy_entries = pasync_ctx->async_data.busy_entries + writables;
    }
#line 1856
    doorbell = (ring_id & 16383U) | doorbell;
#line 1857
    doorbell = doorbell | 16384U;
#line 1858
    doorbell = doorbell;
#line 1859
    doorbell = ((writables & 16383U) << 16) | doorbell;
#line 1862
    iowrite32(doorbell, (void *)phba->db_va + (unsigned long )doorbell_offset);
  } else {

  }
#line 1864
  return;
}
}
#line 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_flush_default_pdu_buffer(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                         struct i_t_dpdu_cqe *pdpdu_cqe ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int cq_index ;
  uint16_t cri_index ;
  long tmp ;

  {
#line 1872
  pasync_handle = (struct async_pdu_handle *)0;
#line 1873
  cq_index = 4294967295U;
#line 1874
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 1877
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1878
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num];
#line 1882
  pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx, pdpdu_cqe,
                                       & cq_index);
#line 1884
  tmp = ldv__builtin_expect((unsigned int )pasync_handle->is_header != 0U, 0L);
#line 1884
  if (tmp != 0L) {
#line 1884
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"),
                         "i" (1884), "i" (12UL));
    ldv_55382: ;
#line 1884
    goto ldv_55382;
  } else {

  }
#line 1885
  if (pasync_handle->consumed == 0U) {
#line 1886
    hwi_update_async_writables(phba, pasync_ctx, (unsigned int )pasync_handle->is_header,
                               cq_index);
  } else {

  }
#line 1889
  hwi_free_async_msg(phba, pasync_ctx, (unsigned int )pasync_handle->cri);
#line 1890
  hwi_post_async_buffers(phba, (unsigned int )pasync_handle->is_header, (int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num);
#line 1892
  return;
}
}
#line 1896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_fwd_async_msg(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                      struct hwi_async_pdu_context *pasync_ctx , unsigned short cri ) 
{ 
  struct list_head *plist ;
  struct async_pdu_handle *pasync_handle ;
  void *phdr ;
  unsigned int hdr_len ;
  unsigned int buf_len ;
  unsigned int status ;
  unsigned int index ;
  unsigned int offset ;
  void *pfirst_buffer ;
  unsigned int num_buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1902
  phdr = (void *)0;
#line 1903
  hdr_len = 0U;
#line 1903
  buf_len = 0U;
#line 1904
  index = 0U;
#line 1904
  offset = 0U;
#line 1905
  pfirst_buffer = (void *)0;
#line 1906
  num_buf = 0U;
#line 1908
  plist = & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list;
#line 1910
  __mptr = (struct list_head  const  *)plist->next;
#line 1910
  pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1910
  goto ldv_55404;
  ldv_55403: ;
#line 1911
  if (index == 0U) {
#line 1912
    phdr = pasync_handle->pbuffer;
#line 1913
    hdr_len = (unsigned int )pasync_handle->buffer_len;
  } else {
#line 1915
    buf_len = (unsigned int )pasync_handle->buffer_len;
#line 1916
    if (num_buf == 0U) {
#line 1917
      pfirst_buffer = pasync_handle->pbuffer;
#line 1918
      num_buf = num_buf + 1U;
    } else {

    }
#line 1920
    memcpy(pfirst_buffer + (unsigned long )offset, (void const   *)pasync_handle->pbuffer,
             (size_t )buf_len);
#line 1922
    offset = offset + buf_len;
  }
#line 1924
  index = index + 1U;
#line 1910
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1910
  pasync_handle = (struct async_pdu_handle *)__mptr___0;
  ldv_55404: ;
#line 1910
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )plist) {
#line 1912
    goto ldv_55403;
  } else {

  }
#line 1927
  status = beiscsi_process_async_pdu(beiscsi_conn, phba, (struct pdu_base *)phdr,
                                     (unsigned long )hdr_len, pfirst_buffer, (unsigned long )offset);
#line 1931
  hwi_free_async_msg(phba, pasync_ctx, (unsigned int )cri);
#line 1932
  return (0U);
}
}
#line 1936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_gather_async_pdu(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                         struct async_pdu_handle *pasync_handle ) 
{ 
  struct hwi_async_pdu_context *pasync_ctx ;
  struct hwi_controller *phwi_ctrlr ;
  unsigned int bytes_needed ;
  unsigned int status ;
  unsigned short cri ;
  struct pdu_base *ppdu ;
  __u16 tmp ;

  {
#line 1942
  bytes_needed = 0U;
#line 1942
  status = 0U;
#line 1943
  cri = pasync_handle->cri;
#line 1946
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1947
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid])->ulp_num];
#line 1952
  list_del(& pasync_handle->link);
#line 1953
  if ((unsigned int )pasync_handle->is_header != 0U) {
#line 1954
    pasync_ctx->async_header.busy_entries = pasync_ctx->async_header.busy_entries - 1U;
#line 1955
    if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received != 0U) {
#line 1956
      hwi_free_async_msg(phba, pasync_ctx, (unsigned int )cri);
#line 1957
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"),
                           "i" (1957), "i" (12UL));
      ldv_55417: ;
#line 1957
      goto ldv_55417;
    } else {

    }
#line 1960
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = 0U;
#line 1961
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received = 1U;
#line 1962
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_len = (unsigned char )pasync_handle->buffer_len;
#line 1964
    list_add_tail(& pasync_handle->link, & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1967
    ppdu = (struct pdu_base *)pasync_handle->pbuffer;
#line 1968
    tmp = __fswab16((int )((unsigned short )(ppdu->dw[1UL] >> 16)));
#line 1968
    bytes_needed = (((ppdu->dw[1UL] & 65280U) << 8) & 4294901760U) | (u32 )tmp;
#line 1974
    if (status == 0U) {
#line 1975
      (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_needed = bytes_needed;
#line 1978
      if (bytes_needed == 0U) {
#line 1979
        status = hwi_fwd_async_msg(beiscsi_conn, phba, pasync_ctx, (int )cri);
      } else {

      }
    } else {

    }
  } else {
#line 1983
    pasync_ctx->async_data.busy_entries = pasync_ctx->async_data.busy_entries - 1U;
#line 1984
    if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received != 0U) {
#line 1985
      list_add_tail(& pasync_handle->link, & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1989
      (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = (int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received + (int )((unsigned short )pasync_handle->buffer_len);
#line 1992
      if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received >= (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_needed) {
#line 1996
        status = hwi_fwd_async_msg(beiscsi_conn, phba, pasync_ctx, (int )cri);
      } else {

      }
    } else {

    }
  }
#line 2000
  return (status);
}
}
#line 2003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_process_default_pdu_ring(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                         struct i_t_dpdu_cqe *pdpdu_cqe ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int cq_index ;
  uint16_t cri_index ;

  {
#line 2009
  pasync_handle = (struct async_pdu_handle *)0;
#line 2010
  cq_index = 4294967295U;
#line 2011
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 2014
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2015
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num];
#line 2019
  pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx, pdpdu_cqe,
                                       & cq_index);
#line 2022
  if (pasync_handle->consumed == 0U) {
#line 2023
    hwi_update_async_writables(phba, pasync_ctx, (unsigned int )pasync_handle->is_header,
                               cq_index);
  } else {

  }
#line 2026
  hwi_gather_async_pdu(beiscsi_conn, phba, pasync_handle);
#line 2027
  hwi_post_async_buffers(phba, (unsigned int )pasync_handle->is_header, (int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num);
#line 2029
  return;
}
}
#line 2032 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_process_mcc_isr(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *mcc_compl ;
  unsigned int num_processed ;
  void *tmp ;
  uint32_t log_value ;
  bool tmp___0 ;
  void *tmp___1 ;

  {
#line 2036
  num_processed = 0U;
#line 2038
  mcc_cq = & phba->ctrl.mcc_obj.cq;
#line 2039
  tmp = queue_tail_node(mcc_cq);
#line 2039
  mcc_compl = (struct be_mcc_compl *)tmp;
#line 2040
  mcc_compl->flags = mcc_compl->flags;
#line 2041
  goto ldv_55436;
  ldv_55435: ;
#line 2043
  if (num_processed > 31U) {
#line 2044
    hwi_ring_cq_db(phba, (unsigned int )mcc_cq->id, num_processed, 0, 0);
#line 2046
    num_processed = 0U;
  } else {

  }
#line 2048
  if ((mcc_compl->flags & 1073741824U) != 0U) {
#line 2050
    tmp___0 = is_link_state_evt(mcc_compl->flags);
#line 2050
    if ((int )tmp___0) {
#line 2052
      beiscsi_async_link_state_process(phba, (struct be_async_event_link_state *)mcc_compl);
    } else {
#line 2055
      log_value = phba->attr_log_enable;
#line 2055
      if ((log_value & 2U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2055
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d :  Unsupported Async Event, flags = 0x%08x\n", 2058, mcc_compl->flags);
      } else {

      }
#line 2059
      if ((int )phba->state & 1) {
#line 2060
        phba->state = phba->state | 16U;
#line 2061
        phba->get_boot = 45;
      } else {

      }
    }
  } else
#line 2064
  if ((mcc_compl->flags & 268435456U) != 0U) {
#line 2065
    be_mcc_compl_process_isr(& phba->ctrl, mcc_compl);
#line 2066
    atomic_dec(& phba->ctrl.mcc_obj.q.used);
  } else {

  }
#line 2069
  mcc_compl->flags = 0U;
#line 2070
  queue_tail_inc(mcc_cq);
#line 2071
  tmp___1 = queue_tail_node(mcc_cq);
#line 2071
  mcc_compl = (struct be_mcc_compl *)tmp___1;
#line 2072
  mcc_compl->flags = mcc_compl->flags;
#line 2073
  num_processed = num_processed + 1U;
  ldv_55436: ;
#line 2041
  if ((int )mcc_compl->flags < 0) {
#line 2043
    goto ldv_55435;
  } else {

  }

#line 2076
  if (num_processed != 0U) {
#line 2077
    hwi_ring_cq_db(phba, (unsigned int )mcc_cq->id, num_processed, 1, 0);
  } else {

  }
#line 2078
  return;
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq ) 
{ 
  struct be_queue_info *cq ;
  struct sol_cqe *sol ;
  struct dmsg_cqe *dmsg ;
  unsigned int num_processed ;
  unsigned int tot_nump ;
  unsigned short code ;
  unsigned short cid ;
  uint16_t cri_index ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint32_t log_value___7 ;
  u32 tmp___6 ;
  void *tmp___7 ;

  {
#line 2093
  num_processed = 0U;
#line 2094
  tot_nump = 0U;
#line 2095
  code = 0U;
#line 2095
  cid = 0U;
#line 2096
  cri_index = 0U;
#line 2102
  cq = pbe_eq->cq;
#line 2103
  tmp = queue_tail_node(cq);
#line 2103
  sol = (struct sol_cqe *)tmp;
#line 2104
  phba = pbe_eq->phba;
#line 2106
  goto ldv_55498;
  ldv_55497: 
#line 2108
  swap_dws((void *)sol, 16);
#line 2110
  code = (unsigned int )((unsigned short )sol->dw[2UL]) & 63U;
#line 2114
  if (phba->generation == 3U || phba->generation == 2U) {
#line 2115
    tmp___0 = amap_mask(10U);
#line 2115
    tmp___1 = amap_get((void *)sol, 2U, tmp___0, 6U);
#line 2115
    cid = (unsigned short )tmp___1;
  } else
#line 2117
  if (((unsigned int )code == 31U || (unsigned int )code == 28U) || (unsigned int )code == 29U) {
#line 2120
    tmp___2 = amap_mask(13U);
#line 2120
    tmp___3 = amap_get((void *)sol, 3U, tmp___2, 16U);
#line 2120
    cid = (unsigned short )tmp___3;
  } else {
#line 2124
    tmp___4 = amap_mask(13U);
#line 2124
    tmp___5 = amap_get((void *)sol, 2U, tmp___4, 16U);
#line 2124
    cid = (unsigned short )tmp___5;
  }
#line 2128
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 2129
  ep = *(phba->ep_array + (unsigned long )cri_index);
#line 2131
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 2135
    log_value = phba->attr_log_enable;
#line 2135
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 2135
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : proc cqe of disconn ep: cid %d\n",
                 2138, (int )cid);
    } else {

    }
#line 2139
    goto proc_next_cqe;
  } else {

  }
#line 2142
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 2143
  beiscsi_conn = beiscsi_ep->conn;
#line 2145
  if (num_processed > 31U) {
#line 2146
    hwi_ring_cq_db(phba, (unsigned int )cq->id, num_processed, 0, 0);
#line 2148
    tot_nump = tot_nump + num_processed;
#line 2149
    num_processed = 0U;
  } else {

  }
#line 2152
  switch ((int )code) {
  case 1: 
#line 2154
  hwi_complete_cmd(beiscsi_conn, phba, sol);
#line 2155
  goto ldv_55456;
  case 31: 
#line 2157
  log_value___0 = phba->attr_log_enable;
#line 2157
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2157
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2160, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2162
  dmsg = (struct dmsg_cqe *)sol;
#line 2163
  hwi_complete_drvr_msgs(beiscsi_conn, phba, sol);
#line 2164
  goto ldv_55456;
  case 28: 
#line 2166
  log_value___1 = phba->attr_log_enable;
#line 2166
  if ((log_value___1 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2166
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2169, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2171
  spin_lock_bh(& phba->async_pdu_lock);
#line 2172
  hwi_process_default_pdu_ring(beiscsi_conn, phba, (struct i_t_dpdu_cqe *)sol);
#line 2174
  spin_unlock_bh(& phba->async_pdu_lock);
#line 2175
  goto ldv_55456;
  case 29: 
#line 2177
  log_value___2 = phba->attr_log_enable;
#line 2177
  if ((log_value___2 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2177
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2180, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2182
  spin_lock_bh(& phba->async_pdu_lock);
#line 2183
  hwi_process_default_pdu_ring(beiscsi_conn, phba, (struct i_t_dpdu_cqe *)sol);
#line 2185
  spin_unlock_bh(& phba->async_pdu_lock);
#line 2186
  goto ldv_55456;
  case 26: ;
  case 27: ;
  case 25: 
#line 2190
  log_value___3 = phba->attr_log_enable;
#line 2190
  if ((log_value___3 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2190
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Ignoring %s[%d] on CID : %d\n",
               2193, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2194
  goto ldv_55456;
  case 2: ;
  case 18: ;
  case 19: ;
  case 20: ;
  case 21: ;
  case 22: ;
  case 23: ;
  case 24: 
#line 2203
  log_value___4 = phba->attr_log_enable;
#line 2203
  if ((log_value___4 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2203
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Cmd Notification %s[%d] on CID : %d\n",
               2206, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2207
  goto ldv_55456;
  case 30: 
#line 2209
  log_value___5 = phba->attr_log_enable;
#line 2209
  if ((log_value___5 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2209
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d :  Dropping %s[%d] on DPDU ring on CID : %d\n",
               2212, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2213
  spin_lock_bh(& phba->async_pdu_lock);
#line 2214
  hwi_flush_default_pdu_buffer(phba, beiscsi_conn, (struct i_t_dpdu_cqe *)sol);
#line 2216
  spin_unlock_bh(& phba->async_pdu_lock);
#line 2217
  goto ldv_55456;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 11: ;
  case 13: ;
  case 12: ;
  case 10: ;
  case 14: ;
  case 15: ;
  case 16: ;
  case 17: ;
  case 32: 
#line 2234
  log_value___6 = phba->attr_log_enable;
#line 2234
  if ((log_value___6 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2234
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Event %s[%d] received on CID : %d\n",
               2237, cqe_desc[(int )code], (int )code, (int )cid);
  } else {

  }
#line 2238
  if ((unsigned long )beiscsi_conn != (unsigned long )((struct beiscsi_conn *)0)) {
#line 2239
    iscsi_conn_failure(beiscsi_conn->conn, 1011);
  } else {

  }
#line 2241
  goto ldv_55456;
  default: 
#line 2243
  log_value___7 = phba->attr_log_enable;
#line 2243
  if ((log_value___7 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2243
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Invalid CQE Event Received Code : %dCID 0x%x...\n",
               2247, (int )code, (int )cid);
  } else {

  }
#line 2248
  goto ldv_55456;
  }
  ldv_55456: ;
  proc_next_cqe: 
#line 2252
  tmp___6 = amap_mask(1U);
#line 2252
  amap_set((void *)sol, 3U, tmp___6, 31U, 0U);
#line 2253
  queue_tail_inc(cq);
#line 2254
  tmp___7 = queue_tail_node(cq);
#line 2254
  sol = (struct sol_cqe *)tmp___7;
#line 2255
  num_processed = num_processed + 1U;
  ldv_55498: ;
#line 2106
  if ((int )sol->dw[3UL] < 0) {
#line 2108
    goto ldv_55497;
  } else {

  }

#line 2258
  if (num_processed != 0U) {
#line 2259
    tot_nump = tot_nump + num_processed;
#line 2260
    hwi_ring_cq_db(phba, (unsigned int )cq->id, num_processed, 1, 0);
  } else {

  }
#line 2262
  return (tot_nump);
}
}
#line 2265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_process_all_cqs(struct work_struct *work ) 
{ 
  unsigned long flags ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct beiscsi_hba *phba ;
  struct be_eq_obj *pbe_eq ;
  struct work_struct  const  *__mptr ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 2272
  __mptr = (struct work_struct  const  *)work;
#line 2272
  pbe_eq = (struct be_eq_obj *)__mptr + 0xffffffffffffffc0UL;
#line 2274
  phba = pbe_eq->phba;
#line 2275
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2276
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 2278
  if ((int )pbe_eq->todo_mcc_cq) {
#line 2279
    tmp = spinlock_check(& phba->isr_lock);
#line 2279
    flags = _raw_spin_lock_irqsave(tmp);
#line 2280
    pbe_eq->todo_mcc_cq = 0;
#line 2281
    spin_unlock_irqrestore(& phba->isr_lock, flags);
#line 2282
    beiscsi_process_mcc_isr(phba);
  } else {

  }
#line 2285
  if ((int )pbe_eq->todo_cq) {
#line 2286
    tmp___0 = spinlock_check(& phba->isr_lock);
#line 2286
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 2287
    pbe_eq->todo_cq = 0;
#line 2288
    spin_unlock_irqrestore(& phba->isr_lock, flags);
#line 2289
    beiscsi_process_cq(pbe_eq);
  } else {

  }
#line 2293
  hwi_ring_eq_db(phba, (unsigned int )pbe_eq->q.id, 0U, 0U, 1, 1);
#line 2294
  return;
}
}
#line 2296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_iopoll(struct blk_iopoll *iop , int budget ) 
{ 
  unsigned int ret ;
  struct beiscsi_hba *phba ;
  struct be_eq_obj *pbe_eq ;
  struct blk_iopoll  const  *__mptr ;
  uint32_t log_value ;

  {
#line 2302
  __mptr = (struct blk_iopoll  const  *)iop;
#line 2302
  pbe_eq = (struct be_eq_obj *)__mptr + 0xffffffffffffff70UL;
#line 2303
  ret = beiscsi_process_cq(pbe_eq);
#line 2304
  pbe_eq->cq_count = pbe_eq->cq_count + ret;
#line 2305
  if ((unsigned int )budget > ret) {
#line 2306
    phba = pbe_eq->phba;
#line 2307
    blk_iopoll_complete(iop);
#line 2308
    log_value = phba->attr_log_enable;
#line 2308
    if ((log_value & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2308
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : rearm pbe_eq->q.id =%d\n", 2311, (int )pbe_eq->q.id);
    } else {

    }
#line 2312
    hwi_ring_eq_db(phba, (unsigned int )pbe_eq->q.id, 0U, 0U, 1, 1);
  } else {

  }
#line 2314
  return ((int )ret);
}
}
#line 2318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_sgl_v2(struct iscsi_wrb *pwrb , struct scatterlist *sg , unsigned int num_sg ,
                             struct beiscsi_io_task *io_task ) 
{ 
  struct iscsi_sge *psgl ;
  unsigned int sg_len ;
  unsigned int index ;
  unsigned int sge_len ;
  unsigned long long addr ;
  struct scatterlist *l_sg ;
  unsigned int offset ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;

  {
#line 2323
  sge_len = 0U;
#line 2328
  tmp = amap_mask(32U);
#line 2328
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2330
  tmp___0 = amap_mask(32U);
#line 2330
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2333
  l_sg = sg;
#line 2334
  index = 0U;
#line 2334
  goto ldv_55540;
  ldv_55539: ;
#line 2336
  if (index == 0U) {
#line 2337
    sg_len = sg->dma_length;
#line 2338
    addr = sg->dma_address;
#line 2339
    tmp___1 = amap_mask(32U);
#line 2339
    amap_set((void *)pwrb, 9U, tmp___1, 0U, (unsigned int )addr);
#line 2342
    tmp___2 = amap_mask(32U);
#line 2342
    amap_set((void *)pwrb, 8U, tmp___2, 0U, (unsigned int )(addr >> 32ULL));
#line 2345
    tmp___3 = amap_mask(17U);
#line 2345
    amap_set((void *)pwrb, 11U, tmp___3, 0U, sg_len);
#line 2348
    sge_len = sg_len;
  } else {
#line 2350
    tmp___4 = amap_mask(24U);
#line 2350
    amap_set((void *)pwrb, 14U, tmp___4, 0U, sge_len);
#line 2352
    sg_len = sg->dma_length;
#line 2353
    addr = sg->dma_address;
#line 2354
    tmp___5 = amap_mask(32U);
#line 2354
    amap_set((void *)pwrb, 13U, tmp___5, 0U, (unsigned int )addr);
#line 2357
    tmp___6 = amap_mask(32U);
#line 2357
    amap_set((void *)pwrb, 12U, tmp___6, 0U, (unsigned int )(addr >> 32ULL));
#line 2360
    tmp___7 = amap_mask(17U);
#line 2360
    amap_set((void *)pwrb, 15U, tmp___7, 0U, sg_len);
  }
#line 2334
  index = index + 1U;
#line 2334
  sg = sg_next(sg);
  ldv_55540: ;
#line 2334
  if (index < num_sg && index <= 1U) {
#line 2336
    goto ldv_55539;
  } else {

  }
#line 2365
  psgl = (io_task->psgl_handle)->pfrag;
#line 2366
  memset((void *)psgl, 0, 512UL);
#line 2368
  tmp___8 = amap_mask(17U);
#line 2368
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )((int )io_task->bhs_len + -2));
#line 2370
  tmp___9 = amap_mask(32U);
#line 2370
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2372
  tmp___10 = amap_mask(32U);
#line 2372
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2375
  if (num_sg == 1U) {
#line 2376
    tmp___11 = amap_mask(1U);
#line 2376
    amap_set((void *)pwrb, 10U, tmp___11, 31U, 1U);
#line 2378
    tmp___12 = amap_mask(1U);
#line 2378
    amap_set((void *)pwrb, 14U, tmp___12, 31U, 0U);
  } else
#line 2380
  if (num_sg == 2U) {
#line 2381
    tmp___13 = amap_mask(1U);
#line 2381
    amap_set((void *)pwrb, 10U, tmp___13, 31U, 0U);
#line 2383
    tmp___14 = amap_mask(1U);
#line 2383
    amap_set((void *)pwrb, 14U, tmp___14, 31U, 1U);
  } else {
#line 2386
    tmp___15 = amap_mask(1U);
#line 2386
    amap_set((void *)pwrb, 10U, tmp___15, 31U, 0U);
#line 2388
    tmp___16 = amap_mask(1U);
#line 2388
    amap_set((void *)pwrb, 14U, tmp___16, 31U, 0U);
  }
#line 2392
  sg = l_sg;
#line 2393
  psgl = psgl + 1;
#line 2394
  psgl = psgl + 1;
#line 2395
  offset = 0U;
#line 2396
  index = 0U;
#line 2396
  goto ldv_55543;
  ldv_55542: 
#line 2397
  sg_len = sg->dma_length;
#line 2398
  addr = sg->dma_address;
#line 2399
  tmp___17 = amap_mask(32U);
#line 2399
  amap_set((void *)psgl, 1U, tmp___17, 0U, (unsigned int )addr);
#line 2401
  tmp___18 = amap_mask(32U);
#line 2401
  amap_set((void *)psgl, 0U, tmp___18, 0U, (unsigned int )(addr >> 32ULL));
#line 2403
  tmp___19 = amap_mask(17U);
#line 2403
  amap_set((void *)psgl, 3U, tmp___19, 0U, sg_len);
#line 2404
  tmp___20 = amap_mask(22U);
#line 2404
  amap_set((void *)psgl, 2U, tmp___20, 0U, offset);
#line 2405
  tmp___21 = amap_mask(1U);
#line 2405
  amap_set((void *)psgl, 2U, tmp___21, 31U, 0U);
#line 2406
  offset = offset + sg_len;
#line 2396
  index = index + 1U;
#line 2396
  sg = sg_next(sg);
#line 2396
  psgl = psgl + 1;
  ldv_55543: ;
#line 2396
  if (index < num_sg) {
#line 2398
    goto ldv_55542;
  } else {

  }
#line 2408
  psgl = psgl - 1;
#line 2409
  tmp___22 = amap_mask(1U);
#line 2409
  amap_set((void *)psgl, 2U, tmp___22, 31U, 1U);
#line 2410
  return;
}
}
#line 2413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_sgl(struct iscsi_wrb *pwrb , struct scatterlist *sg , unsigned int num_sg ,
                          struct beiscsi_io_task *io_task ) 
{ 
  struct iscsi_sge *psgl ;
  unsigned int sg_len ;
  unsigned int index ;
  unsigned int sge_len ;
  unsigned long long addr ;
  struct scatterlist *l_sg ;
  unsigned int offset ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;

  {
#line 2418
  sge_len = 0U;
#line 2423
  tmp = amap_mask(32U);
#line 2423
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2425
  tmp___0 = amap_mask(32U);
#line 2425
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2428
  l_sg = sg;
#line 2429
  index = 0U;
#line 2429
  goto ldv_55559;
  ldv_55558: ;
#line 2431
  if (index == 0U) {
#line 2432
    sg_len = sg->dma_length;
#line 2433
    addr = sg->dma_address;
#line 2434
    tmp___1 = amap_mask(32U);
#line 2434
    amap_set((void *)pwrb, 9U, tmp___1, 0U, (unsigned int )addr);
#line 2436
    tmp___2 = amap_mask(32U);
#line 2436
    amap_set((void *)pwrb, 8U, tmp___2, 0U, (unsigned int )(addr >> 32));
#line 2438
    tmp___3 = amap_mask(17U);
#line 2438
    amap_set((void *)pwrb, 11U, tmp___3, 0U, sg_len);
#line 2440
    sge_len = sg_len;
  } else {
#line 2442
    tmp___4 = amap_mask(22U);
#line 2442
    amap_set((void *)pwrb, 14U, tmp___4, 0U, sge_len);
#line 2444
    sg_len = sg->dma_length;
#line 2445
    addr = sg->dma_address;
#line 2446
    tmp___5 = amap_mask(32U);
#line 2446
    amap_set((void *)pwrb, 13U, tmp___5, 0U, (unsigned int )addr);
#line 2448
    tmp___6 = amap_mask(32U);
#line 2448
    amap_set((void *)pwrb, 12U, tmp___6, 0U, (unsigned int )(addr >> 32));
#line 2450
    tmp___7 = amap_mask(17U);
#line 2450
    amap_set((void *)pwrb, 15U, tmp___7, 0U, sg_len);
  }
#line 2429
  index = index + 1U;
#line 2429
  sg = sg_next(sg);
  ldv_55559: ;
#line 2429
  if (index < num_sg && index <= 1U) {
#line 2431
    goto ldv_55558;
  } else {

  }
#line 2454
  psgl = (io_task->psgl_handle)->pfrag;
#line 2455
  memset((void *)psgl, 0, 512UL);
#line 2457
  tmp___8 = amap_mask(17U);
#line 2457
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )((int )io_task->bhs_len + -2));
#line 2459
  tmp___9 = amap_mask(32U);
#line 2459
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2461
  tmp___10 = amap_mask(32U);
#line 2461
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2464
  if (num_sg == 1U) {
#line 2465
    tmp___11 = amap_mask(1U);
#line 2465
    amap_set((void *)pwrb, 10U, tmp___11, 31U, 1U);
#line 2467
    tmp___12 = amap_mask(1U);
#line 2467
    amap_set((void *)pwrb, 14U, tmp___12, 31U, 0U);
  } else
#line 2469
  if (num_sg == 2U) {
#line 2470
    tmp___13 = amap_mask(1U);
#line 2470
    amap_set((void *)pwrb, 10U, tmp___13, 31U, 0U);
#line 2472
    tmp___14 = amap_mask(1U);
#line 2472
    amap_set((void *)pwrb, 14U, tmp___14, 31U, 1U);
  } else {
#line 2475
    tmp___15 = amap_mask(1U);
#line 2475
    amap_set((void *)pwrb, 10U, tmp___15, 31U, 0U);
#line 2477
    tmp___16 = amap_mask(1U);
#line 2477
    amap_set((void *)pwrb, 14U, tmp___16, 31U, 0U);
  }
#line 2480
  sg = l_sg;
#line 2481
  psgl = psgl + 1;
#line 2482
  psgl = psgl + 1;
#line 2483
  offset = 0U;
#line 2484
  index = 0U;
#line 2484
  goto ldv_55562;
  ldv_55561: 
#line 2485
  sg_len = sg->dma_length;
#line 2486
  addr = sg->dma_address;
#line 2487
  tmp___17 = amap_mask(32U);
#line 2487
  amap_set((void *)psgl, 1U, tmp___17, 0U, (u32 )addr);
#line 2489
  tmp___18 = amap_mask(32U);
#line 2489
  amap_set((void *)psgl, 0U, tmp___18, 0U, (u32 )(addr >> 32));
#line 2491
  tmp___19 = amap_mask(17U);
#line 2491
  amap_set((void *)psgl, 3U, tmp___19, 0U, sg_len);
#line 2492
  tmp___20 = amap_mask(22U);
#line 2492
  amap_set((void *)psgl, 2U, tmp___20, 0U, offset);
#line 2493
  tmp___21 = amap_mask(1U);
#line 2493
  amap_set((void *)psgl, 2U, tmp___21, 31U, 0U);
#line 2494
  offset = offset + sg_len;
#line 2484
  index = index + 1U;
#line 2484
  sg = sg_next(sg);
#line 2484
  psgl = psgl + 1;
  ldv_55562: ;
#line 2484
  if (index < num_sg) {
#line 2486
    goto ldv_55561;
  } else {

  }
#line 2496
  psgl = psgl - 1;
#line 2497
  tmp___22 = amap_mask(1U);
#line 2497
  amap_set((void *)psgl, 2U, tmp___22, 31U, 1U);
#line 2498
  return;
}
}
#line 2505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_buffer(struct iscsi_wrb *pwrb , struct iscsi_task *task ) 
{ 
  struct iscsi_sge *psgl ;
  struct beiscsi_io_task *io_task ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  uint8_t dsp_value ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;

  {
#line 2508
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 2509
  beiscsi_conn = io_task->conn;
#line 2510
  phba = beiscsi_conn->phba;
#line 2511
  dsp_value = 0U;
#line 2513
  io_task->bhs_len = 322U;
#line 2514
  tmp = amap_mask(32U);
#line 2514
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2516
  tmp___0 = amap_mask(32U);
#line 2516
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2519
  if ((unsigned long )task->data != (unsigned long )((char *)0)) {
#line 2522
    dsp_value = task->data_count != 0U;
#line 2524
    if (phba->generation == 3U || phba->generation == 2U) {
#line 2525
      tmp___1 = amap_mask(1U);
#line 2525
      amap_set((void *)pwrb, 0U, tmp___1, 24U, (u32 )dsp_value);
    } else {
#line 2528
      tmp___2 = amap_mask(1U);
#line 2528
      amap_set((void *)pwrb, 11U, tmp___2, 28U, (u32 )dsp_value);
    }
#line 2532
    if ((unsigned int )dsp_value != 0U) {
#line 2533
      io_task->mtask_addr = pci_map_single(phba->pcidev, (void *)task->data, (size_t )task->data_count,
                                           1);
#line 2537
      io_task->mtask_data_count = task->data_count;
    } else {
#line 2539
      io_task->mtask_addr = 0ULL;
    }
#line 2541
    tmp___3 = amap_mask(32U);
#line 2541
    amap_set((void *)pwrb, 9U, tmp___3, 0U, (unsigned int )io_task->mtask_addr);
#line 2543
    tmp___4 = amap_mask(32U);
#line 2543
    amap_set((void *)pwrb, 8U, tmp___4, 0U, (unsigned int )(io_task->mtask_addr >> 32ULL));
#line 2545
    tmp___5 = amap_mask(17U);
#line 2545
    amap_set((void *)pwrb, 11U, tmp___5, 0U, task->data_count);
#line 2548
    tmp___6 = amap_mask(1U);
#line 2548
    amap_set((void *)pwrb, 10U, tmp___6, 31U, 1U);
  } else {
#line 2550
    tmp___7 = amap_mask(1U);
#line 2550
    amap_set((void *)pwrb, 0U, tmp___7, 24U, 0U);
#line 2551
    io_task->mtask_addr = 0ULL;
  }
#line 2554
  psgl = (io_task->psgl_handle)->pfrag;
#line 2556
  tmp___8 = amap_mask(17U);
#line 2556
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )io_task->bhs_len);
#line 2558
  tmp___9 = amap_mask(32U);
#line 2558
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2560
  tmp___10 = amap_mask(32U);
#line 2560
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2562
  if ((unsigned long )task->data != (unsigned long )((char *)0)) {
#line 2563
    psgl = psgl + 1;
#line 2564
    tmp___11 = amap_mask(32U);
#line 2564
    amap_set((void *)psgl, 0U, tmp___11, 0U, 0U);
#line 2565
    tmp___12 = amap_mask(32U);
#line 2565
    amap_set((void *)psgl, 1U, tmp___12, 0U, 0U);
#line 2566
    tmp___13 = amap_mask(17U);
#line 2566
    amap_set((void *)psgl, 3U, tmp___13, 0U, 0U);
#line 2567
    tmp___14 = amap_mask(22U);
#line 2567
    amap_set((void *)psgl, 2U, tmp___14, 0U, 0U);
#line 2568
    tmp___15 = amap_mask(9U);
#line 2568
    amap_set((void *)psgl, 2U, tmp___15, 22U, 0U);
#line 2569
    tmp___16 = amap_mask(1U);
#line 2569
    amap_set((void *)psgl, 2U, tmp___16, 31U, 0U);
#line 2571
    psgl = psgl + 1;
#line 2572
    if ((unsigned long )task->data != (unsigned long )((char *)0)) {
#line 2573
      tmp___17 = amap_mask(32U);
#line 2573
      amap_set((void *)psgl, 1U, tmp___17, 0U, (unsigned int )io_task->mtask_addr);
#line 2575
      tmp___18 = amap_mask(32U);
#line 2575
      amap_set((void *)psgl, 0U, tmp___18, 0U, (unsigned int )(io_task->mtask_addr >> 32ULL));
    } else {

    }
#line 2578
    tmp___19 = amap_mask(17U);
#line 2578
    amap_set((void *)psgl, 3U, tmp___19, 0U, 262U);
  } else {

  }
#line 2580
  tmp___20 = amap_mask(1U);
#line 2580
  amap_set((void *)psgl, 2U, tmp___20, 31U, 1U);
#line 2581
  return;
}
}
#line 2587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_find_mem_req(struct beiscsi_hba *phba ) 
{ 
  uint8_t mem_descr_index ;
  uint8_t ulp_num ;
  unsigned int num_cq_pages ;
  unsigned int num_async_pdu_buf_pages ;
  unsigned int num_async_pdu_data_pages ;
  unsigned int wrb_sz_per_cxn ;
  unsigned int num_async_pdu_buf_sgl_pages ;
  unsigned int num_async_pdu_data_sgl_pages ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2594
  num_cq_pages = (unsigned long )phba->params.num_cq_entries * 16UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_cq_entries + 256UL) * 16UL - 1UL) / 4096UL) : 1U;
#line 2597
  phba->params.hwi_ws_sz = 264U;
#line 2599
  phba->mem_req[21] = 128U;
#line 2601
  phba->mem_req[0] = 15000U;
#line 2605
  phba->mem_req[1] = (phba->params.wrbs_per_cxn * phba->params.cxns_per_ctrl) * 64U;
#line 2608
  wrb_sz_per_cxn = phba->params.wrbs_per_cxn * 24U;
#line 2610
  tmp = __roundup_pow_of_two((unsigned long )(phba->params.cxns_per_ctrl * wrb_sz_per_cxn));
#line 2610
  phba->mem_req[2] = (unsigned int )tmp;
#line 2613
  phba->mem_req[3] = phba->params.icds_per_ctrl * 32U;
#line 2615
  phba->mem_req[4] = (phba->params.num_sge_per_io * phba->params.icds_per_ctrl) * 16U;
#line 2617
  ulp_num = 0U;
#line 2617
  goto ldv_55585;
  ldv_55584: 
#line 2618
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 2618
  if (tmp___0 != 0) {
#line 2620
    num_async_pdu_buf_sgl_pages = (unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL > 4095UL ? (unsigned int )((((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] + 512UL) * 8UL - 1UL) / 4096UL) : 1U;
#line 2625
    num_async_pdu_buf_pages = phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_hdr_sz > 4095U ? (unsigned int )(((unsigned long )(phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_hdr_sz) + 4095UL) / 4096UL) : 1U;
#line 2630
    num_async_pdu_data_pages = phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_data_sz > 4095U ? (unsigned int )(((unsigned long )(phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_data_sz) + 4095UL) / 4096UL) : 1U;
#line 2635
    num_async_pdu_data_sgl_pages = (unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL > 4095UL ? (unsigned int )((((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] + 512UL) * 8UL - 1UL) / 4096UL) : 1U;
#line 2640
    mem_descr_index = (unsigned int )ulp_num * 8U + 5U;
#line 2642
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 128U;
#line 2646
    mem_descr_index = (unsigned int )ulp_num * 8U + 6U;
#line 2648
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_buf_pages * 4096U;
#line 2652
    mem_descr_index = (unsigned int )ulp_num * 8U + 7U;
#line 2654
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_data_pages * 4096U;
#line 2658
    mem_descr_index = (unsigned int )((uint8_t )((int )ulp_num + 1)) * 8U;
#line 2660
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_buf_sgl_pages * 4096U;
#line 2664
    mem_descr_index = (unsigned int )ulp_num * 8U + 9U;
#line 2666
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_data_sgl_pages * 4096U;
#line 2670
    mem_descr_index = (unsigned int )ulp_num * 8U + 10U;
#line 2672
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 48U;
#line 2676
    mem_descr_index = (unsigned int )ulp_num * 8U + 11U;
#line 2678
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 48U;
#line 2682
    mem_descr_index = (unsigned int )ulp_num * 8U + 12U;
#line 2684
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 56U + 4256U;
  } else {

  }
#line 2617
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_55585: ;
#line 2617
  if ((unsigned int )ulp_num <= 1U) {
#line 2619
    goto ldv_55584;
  } else {

  }

#line 2624
  return;
}
}
#line 2692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_alloc_mem(struct beiscsi_hba *phba ) 
{ 
  dma_addr_t bus_add ;
  struct hwi_controller *phwi_ctrlr ;
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *mem_arr ;
  struct mem_array *mem_arr_orig ;
  unsigned int i ;
  unsigned int j ;
  unsigned int alloc_size ;
  unsigned int curr_alloc_size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;
  void *tmp___5 ;

  {
#line 2700
  tmp = kzalloc((size_t )phba->params.hwi_ws_sz, 208U);
#line 2700
  phba->phwi_ctrlr = (struct hwi_controller *)tmp;
#line 2701
  if ((unsigned long )phba->phwi_ctrlr == (unsigned long )((struct hwi_controller *)0)) {
#line 2702
    return (-12);
  } else {

  }
#line 2705
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2706
  tmp___0 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 80UL, 208U);
#line 2706
  phwi_ctrlr->wrb_context = (struct hwi_wrb_context *)tmp___0;
#line 2709
  if ((unsigned long )phwi_ctrlr->wrb_context == (unsigned long )((struct hwi_wrb_context *)0)) {
#line 2710
    return (-12);
  } else {

  }
#line 2712
  tmp___1 = kcalloc(22UL, 32UL, 208U);
#line 2712
  phba->init_mem = (struct be_mem_descriptor *)tmp___1;
#line 2714
  if ((unsigned long )phba->init_mem == (unsigned long )((struct be_mem_descriptor *)0)) {
#line 2715
    kfree((void const   *)phwi_ctrlr->wrb_context);
#line 2716
    kfree((void const   *)phba->phwi_ctrlr);
#line 2717
    return (-12);
  } else {

  }
#line 2720
  tmp___2 = kmalloc(4608UL, 208U);
#line 2720
  mem_arr_orig = (struct mem_array *)tmp___2;
#line 2722
  if ((unsigned long )mem_arr_orig == (unsigned long )((struct mem_array *)0)) {
#line 2723
    kfree((void const   *)phba->init_mem);
#line 2724
    kfree((void const   *)phwi_ctrlr->wrb_context);
#line 2725
    kfree((void const   *)phba->phwi_ctrlr);
#line 2726
    return (-12);
  } else {

  }
#line 2729
  mem_descr = phba->init_mem;
#line 2730
  i = 0U;
#line 2730
  goto ldv_55610;
  ldv_55609: ;
#line 2731
  if (phba->mem_req[i] == 0U) {
#line 2732
    mem_descr->mem_array = (struct mem_array *)0;
#line 2733
    mem_descr = mem_descr + 1;
#line 2734
    goto ldv_55599;
  } else {

  }
#line 2737
  j = 0U;
#line 2738
  mem_arr = mem_arr_orig;
#line 2739
  alloc_size = phba->mem_req[i];
#line 2740
  memset((void *)mem_arr, 0, 4608UL);
#line 2742
  _min1 = be_max_phys_size * 1024U;
#line 2742
  _min2 = alloc_size;
#line 2742
  curr_alloc_size = _min1 < _min2 ? _min1 : _min2;
  ldv_55607: 
#line 2744
  mem_arr->virtual_address = pci_alloc_consistent(phba->pcidev, (size_t )curr_alloc_size,
                                                  & bus_add);
#line 2748
  if ((unsigned long )mem_arr->virtual_address == (unsigned long )((void *)0)) {
#line 2749
    if (curr_alloc_size <= 16384U) {
#line 2750
      goto free_mem;
    } else {

    }
#line 2751
    tmp___4 = __rounddown_pow_of_two((unsigned long )curr_alloc_size);
#line 2751
    if ((unsigned long )curr_alloc_size != tmp___4) {
#line 2753
      tmp___3 = __rounddown_pow_of_two((unsigned long )curr_alloc_size);
#line 2753
      curr_alloc_size = (unsigned int )tmp___3;
    } else {
#line 2756
      curr_alloc_size = curr_alloc_size / 2U;
    }
  } else {
#line 2758
    mem_arr->bus_address.u.a64.address = bus_add;
#line 2760
    mem_arr->size = curr_alloc_size;
#line 2761
    alloc_size = alloc_size - curr_alloc_size;
#line 2762
    _min1___0 = be_max_phys_size * 1024U;
#line 2762
    _min2___0 = alloc_size;
#line 2762
    curr_alloc_size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 2764
    j = j + 1U;
#line 2765
    mem_arr = mem_arr + 1;
  }
#line 2767
  if (alloc_size != 0U) {
#line 2769
    goto ldv_55607;
  } else {

  }
#line 2768
  mem_descr->num_elements = j;
#line 2769
  mem_descr->size_in_bytes = phba->mem_req[i];
#line 2770
  tmp___5 = kmalloc((unsigned long )j * 24UL, 208U);
#line 2770
  mem_descr->mem_array = (struct mem_array *)tmp___5;
#line 2772
  if ((unsigned long )mem_descr->mem_array == (unsigned long )((struct mem_array *)0)) {
#line 2773
    goto free_mem;
  } else {

  }
#line 2775
  memcpy((void *)mem_descr->mem_array, (void const   *)mem_arr_orig, (unsigned long )j * 24UL);
#line 2777
  mem_descr = mem_descr + 1;
  ldv_55599: 
#line 2730
  i = i + 1U;
  ldv_55610: ;
#line 2730
  if (i <= 21U) {
#line 2732
    goto ldv_55609;
  } else {

  }
#line 2779
  kfree((void const   *)mem_arr_orig);
#line 2780
  return (0);
  free_mem: 
#line 2782
  mem_descr->num_elements = j;
#line 2783
  goto ldv_55616;
  ldv_55615: 
#line 2784
  j = mem_descr->num_elements;
#line 2784
  goto ldv_55613;
  ldv_55612: 
#line 2785
  pci_free_consistent(phba->pcidev, (size_t )(mem_descr->mem_array + (unsigned long )(j - 1U))->size,
                      (mem_descr->mem_array + (unsigned long )(j - 1U))->virtual_address,
                      (mem_descr->mem_array + (unsigned long )(j - 1U))->bus_address.u.a64.address);
#line 2784
  j = j - 1U;
  ldv_55613: ;
#line 2784
  if (j != 0U) {
#line 2786
    goto ldv_55612;
  } else {

  }

#line 2793
  if (i != 0U) {
#line 2794
    i = i - 1U;
#line 2795
    kfree((void const   *)mem_descr->mem_array);
#line 2796
    mem_descr = mem_descr - 1;
  } else {

  }
  ldv_55616: ;
#line 2783
  if (i != 0U || j != 0U) {
#line 2785
    goto ldv_55615;
  } else {

  }
#line 2799
  kfree((void const   *)mem_arr_orig);
#line 2800
  kfree((void const   *)phba->init_mem);
#line 2801
  kfree((void const   *)(phba->phwi_ctrlr)->wrb_context);
#line 2802
  kfree((void const   *)phba->phwi_ctrlr);
#line 2803
  return (-12);
}
}
#line 2806 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_get_memory(struct beiscsi_hba *phba ) 
{ 
  int tmp ;

  {
#line 2808
  beiscsi_find_mem_req(phba);
#line 2809
  tmp = beiscsi_alloc_mem(phba);
#line 2809
  return (tmp);
}
}
#line 2812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void iscsi_init_global_templates(struct beiscsi_hba *phba ) 
{ 
  struct pdu_data_out *pdata_out ;
  struct pdu_nop_out *pnop_out ;
  struct be_mem_descriptor *mem_descr ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 2818
  mem_descr = phba->init_mem;
#line 2819
  mem_descr = mem_descr + 21UL;
#line 2820
  pdata_out = (struct pdu_data_out *)(mem_descr->mem_array)->virtual_address;
#line 2822
  memset((void *)pdata_out, 0, 64UL);
#line 2824
  tmp = amap_mask(6U);
#line 2824
  amap_set((void *)pdata_out, 0U, tmp, 0U, 5U);
#line 2827
  pnop_out = (struct pdu_nop_out *)(mem_descr->mem_array)->virtual_address + 64U;
#line 2831
  memset((void *)pnop_out, 0, 64UL);
#line 2832
  tmp___0 = amap_mask(32U);
#line 2832
  amap_set((void *)pnop_out, 5U, tmp___0, 0U, 4294967295U);
#line 2833
  tmp___1 = amap_mask(1U);
#line 2833
  amap_set((void *)pnop_out, 0U, tmp___1, 15U, 1U);
#line 2834
  tmp___2 = amap_mask(1U);
#line 2834
  amap_set((void *)pnop_out, 0U, tmp___2, 6U, 0U);
#line 2835
  return;
}
}
#line 2837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_wrb_handle(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr_wrbh ;
  struct be_mem_descriptor *mem_descr_wrb ;
  struct hwi_context_memory *phwi_ctxt ;
  struct wrb_handle *pwrb_handle ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct iscsi_wrb *pwrb ;
  unsigned int num_cxn_wrbh ;
  unsigned int num_cxn_wrb ;
  unsigned int j ;
  unsigned int idx ;
  unsigned int index ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  void *tmp___1 ;
  uint32_t log_value___1 ;

  {
#line 2841
  pwrb_handle = (struct wrb_handle *)0;
#line 2844
  pwrb = (struct iscsi_wrb *)0;
#line 2845
  num_cxn_wrbh = 0U;
#line 2846
  num_cxn_wrb = 0U;
#line 2846
  idx = 0U;
#line 2848
  mem_descr_wrbh = phba->init_mem;
#line 2849
  mem_descr_wrbh = mem_descr_wrbh + 2UL;
#line 2851
  mem_descr_wrb = phba->init_mem;
#line 2852
  mem_descr_wrb = mem_descr_wrb + 1UL;
#line 2853
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2856
  phwi_ctxt = phwi_ctrlr->phwi_ctxt;
#line 2857
  tmp = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 40UL, 208U);
#line 2857
  phwi_ctxt->be_wrbq = (struct be_queue_info *)tmp;
#line 2860
  if ((unsigned long )phwi_ctxt->be_wrbq == (unsigned long )((struct be_queue_info *)0)) {
#line 2861
    log_value = phba->attr_log_enable;
#line 2861
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2861
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : WRBQ Mem Alloc Failed\n",
                 2862);
    } else {

    }
#line 2863
    return (-12);
  } else {

  }
#line 2866
  index = 0U;
#line 2866
  goto ldv_55650;
  ldv_55649: 
#line 2867
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 2868
  tmp___0 = kzalloc((unsigned long )phba->params.wrbs_per_cxn * 8UL, 208U);
#line 2868
  pwrb_context->pwrb_handle_base = (struct wrb_handle **)tmp___0;
#line 2871
  if ((unsigned long )pwrb_context->pwrb_handle_base == (unsigned long )((struct wrb_handle **)0)) {
#line 2872
    log_value___0 = phba->attr_log_enable;
#line 2872
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2872
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Mem Alloc Failed. Failing to load\n",
                 2873);
    } else {

    }
#line 2874
    goto init_wrb_hndl_failed;
  } else {

  }
#line 2876
  tmp___1 = kzalloc((unsigned long )phba->params.wrbs_per_cxn * 8UL, 208U);
#line 2876
  pwrb_context->pwrb_handle_basestd = (struct wrb_handle **)tmp___1;
#line 2879
  if ((unsigned long )pwrb_context->pwrb_handle_basestd == (unsigned long )((struct wrb_handle **)0)) {
#line 2880
    log_value___1 = phba->attr_log_enable;
#line 2880
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 2880
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Mem Alloc Failed. Failing to load\n",
                 2881);
    } else {

    }
#line 2882
    goto init_wrb_hndl_failed;
  } else {

  }
#line 2884
  if (num_cxn_wrbh == 0U) {
#line 2885
    pwrb_handle = (struct wrb_handle *)(mem_descr_wrbh->mem_array + (unsigned long )idx)->virtual_address;
#line 2887
    num_cxn_wrbh = (unsigned int )((unsigned long )(mem_descr_wrbh->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 24UL));
#line 2890
    idx = idx + 1U;
  } else {

  }
#line 2892
  pwrb_context->alloc_index = 0U;
#line 2893
  pwrb_context->wrb_handles_available = 0U;
#line 2894
  pwrb_context->free_index = 0U;
#line 2896
  if (num_cxn_wrbh != 0U) {
#line 2897
    j = 0U;
#line 2897
    goto ldv_55647;
    ldv_55646: 
#line 2898
    *(pwrb_context->pwrb_handle_base + (unsigned long )j) = pwrb_handle;
#line 2899
    *(pwrb_context->pwrb_handle_basestd + (unsigned long )j) = pwrb_handle;
#line 2901
    pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available + 1);
#line 2902
    pwrb_handle->wrb_index = (unsigned short )j;
#line 2903
    pwrb_handle = pwrb_handle + 1;
#line 2897
    j = j + 1U;
    ldv_55647: ;
#line 2897
    if (phba->params.wrbs_per_cxn > j) {
#line 2899
      goto ldv_55646;
    } else {

    }
#line 2905
    num_cxn_wrbh = num_cxn_wrbh - 1U;
  } else {

  }
#line 2866
  index = index + 1U;
  ldv_55650: ;
#line 2866
  if (phba->params.cxns_per_ctrl > index) {
#line 2868
    goto ldv_55649;
  } else {

  }
#line 2908
  idx = 0U;
#line 2909
  index = 0U;
#line 2909
  goto ldv_55656;
  ldv_55655: 
#line 2910
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 2911
  if (num_cxn_wrb == 0U) {
#line 2912
    pwrb = (struct iscsi_wrb *)(mem_descr_wrb->mem_array + (unsigned long )idx)->virtual_address;
#line 2913
    num_cxn_wrb = (unsigned int )((unsigned long )(mem_descr_wrb->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 2916
    idx = idx + 1U;
  } else {

  }
#line 2919
  if (num_cxn_wrb != 0U) {
#line 2920
    j = 0U;
#line 2920
    goto ldv_55653;
    ldv_55652: 
#line 2921
    pwrb_handle = *(pwrb_context->pwrb_handle_base + (unsigned long )j);
#line 2922
    pwrb_handle->pwrb = pwrb;
#line 2923
    pwrb = pwrb + 1;
#line 2920
    j = j + 1U;
    ldv_55653: ;
#line 2920
    if (phba->params.wrbs_per_cxn > j) {
#line 2922
      goto ldv_55652;
    } else {

    }
#line 2925
    num_cxn_wrb = num_cxn_wrb - 1U;
  } else {

  }
#line 2909
  index = index + 1U;
  ldv_55656: ;
#line 2909
  if (phba->params.cxns_per_ctrl > index) {
#line 2911
    goto ldv_55655;
  } else {

  }

#line 2928
  return (0);
  init_wrb_hndl_failed: 
#line 2930
  j = index;
#line 2930
  goto ldv_55659;
  ldv_55658: 
#line 2931
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )j;
#line 2932
  kfree((void const   *)pwrb_context->pwrb_handle_base);
#line 2933
  kfree((void const   *)pwrb_context->pwrb_handle_basestd);
#line 2930
  j = j - 1U;
  ldv_55659: ;
#line 2930
  if (j != 0U) {
#line 2932
    goto ldv_55658;
  } else {

  }

#line 2935
  return (-12);
}
}
#line 2938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_async_pdu_ctx(struct beiscsi_hba *phba ) 
{ 
  uint8_t ulp_num ;
  struct hwi_controller *phwi_ctrlr ;
  struct hba_parameters *p ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_header_h ;
  struct async_pdu_handle *pasync_data_h ;
  unsigned int index ;
  unsigned int idx ;
  unsigned int num_per_mem ;
  unsigned int num_async_data ;
  struct be_mem_descriptor *mem_descr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint32_t log_value___7 ;
  uint32_t log_value___8 ;
  uint32_t log_value___9 ;
  int tmp ;

  {
#line 2942
  p = & phba->params;
#line 2948
  ulp_num = 0U;
#line 2948
  goto ldv_55690;
  ldv_55689: 
#line 2949
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 2949
  if (tmp != 0) {
#line 2951
    mem_descr = phba->init_mem;
#line 2952
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 12);
#line 2955
    phwi_ctrlr = phba->phwi_ctrlr;
#line 2956
    (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num] = (struct hwi_async_pdu_context *)(mem_descr->mem_array)->virtual_address;
#line 2960
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num];
#line 2961
    memset((void *)pasync_ctx, 0, 4256UL);
#line 2963
    pasync_ctx->async_entry = (struct hwi_async_entry *)((unsigned long )pasync_ctx + 4256UL);
#line 2968
    pasync_ctx->num_entries = phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 2970
    pasync_ctx->buffer_size = p->defpdu_hdr_sz;
#line 2972
    mem_descr = phba->init_mem;
#line 2973
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 6);
#line 2975
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 2976
      log_value = phba->attr_log_enable;
#line 2976
      if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2976
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_BUF_ULP%d va=%p\n",
                   2981, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
      } else {

      }
    } else {
#line 2983
      log_value___0 = phba->attr_log_enable;
#line 2983
      if ((int )log_value___0 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 2983
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 2986, (int )ulp_num);
      } else {

      }
    }
#line 2988
    pasync_ctx->async_header.va_base = (mem_descr->mem_array)->virtual_address;
#line 2991
    pasync_ctx->async_header.pa_base.u.a64.address = (mem_descr->mem_array)->bus_address.u.a64.address;
#line 2995
    mem_descr = phba->init_mem;
#line 2996
    mem_descr = mem_descr + (unsigned long )(((int )ulp_num + 1) * 8);
#line 2998
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 2999
      log_value___1 = phba->attr_log_enable;
#line 2999
      if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 2999
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_RING_ULP%d va=%p\n",
                   3004, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
      } else {

      }
    } else {
#line 3006
      log_value___2 = phba->attr_log_enable;
#line 3006
      if ((int )log_value___2 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 3006
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3009, (int )ulp_num);
      } else {

      }
    }
#line 3011
    pasync_ctx->async_header.ring_base = (mem_descr->mem_array)->virtual_address;
#line 3014
    mem_descr = phba->init_mem;
#line 3015
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 10);
#line 3017
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 3018
      log_value___3 = phba->attr_log_enable;
#line 3018
      if ((int )log_value___3 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3018
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_HANDLE_ULP%d va=%p\n",
                   3023, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
      } else {

      }
    } else {
#line 3025
      log_value___4 = phba->attr_log_enable;
#line 3025
      if ((int )log_value___4 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 3025
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3028, (int )ulp_num);
      } else {

      }
    }
#line 3030
    pasync_ctx->async_header.handle_base = (struct async_pdu_handle *)(mem_descr->mem_array)->virtual_address;
#line 3032
    pasync_ctx->async_header.writables = 0U;
#line 3033
    INIT_LIST_HEAD(& pasync_ctx->async_header.free_list);
#line 3035
    mem_descr = phba->init_mem;
#line 3036
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 9);
#line 3038
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 3039
      log_value___5 = phba->attr_log_enable;
#line 3039
      if ((int )log_value___5 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3039
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_RING_ULP%d va=%p\n",
                   3044, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
      } else {

      }
    } else {
#line 3046
      log_value___6 = phba->attr_log_enable;
#line 3046
      if ((int )log_value___6 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 3046
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3049, (int )ulp_num);
      } else {

      }
    }
#line 3051
    pasync_ctx->async_data.ring_base = (mem_descr->mem_array)->virtual_address;
#line 3054
    mem_descr = phba->init_mem;
#line 3055
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 11);
#line 3057
    if ((unsigned long )(mem_descr->mem_array)->virtual_address == (unsigned long )((void *)0)) {
#line 3058
      log_value___7 = phba->attr_log_enable;
#line 3058
      if ((int )log_value___7 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 3058
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3061, (int )ulp_num);
      } else {

      }
    } else {

    }
#line 3063
    pasync_ctx->async_data.handle_base = (struct async_pdu_handle *)(mem_descr->mem_array)->virtual_address;
#line 3065
    pasync_ctx->async_data.writables = 0U;
#line 3066
    INIT_LIST_HEAD(& pasync_ctx->async_data.free_list);
#line 3068
    pasync_header_h = pasync_ctx->async_header.handle_base;
#line 3071
    pasync_data_h = pasync_ctx->async_data.handle_base;
#line 3075
    mem_descr = phba->init_mem;
#line 3076
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 7);
#line 3078
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 3079
      log_value___8 = phba->attr_log_enable;
#line 3079
      if ((int )log_value___8 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3079
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_BUF_ULP%d va=%p\n",
                   3084, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
      } else {

      }
    } else {
#line 3086
      log_value___9 = phba->attr_log_enable;
#line 3086
      if ((int )log_value___9 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 3086
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3089, (int )ulp_num);
      } else {

      }
    }
#line 3091
    idx = 0U;
#line 3092
    pasync_ctx->async_data.va_base = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3094
    pasync_ctx->async_data.pa_base.u.a64.address = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3098
    num_async_data = (mem_descr->mem_array + (unsigned long )idx)->size / phba->params.defpdu_data_sz;
#line 3100
    num_per_mem = 0U;
#line 3102
    index = 0U;
#line 3102
    goto ldv_55687;
    ldv_55686: 
#line 3104
    pasync_header_h->cri = 65535U;
#line 3105
    pasync_header_h->index = (unsigned char )index;
#line 3106
    INIT_LIST_HEAD(& pasync_header_h->link);
#line 3107
    pasync_header_h->pbuffer = (void *)((unsigned long )pasync_ctx->async_header.va_base + (unsigned long )(p->defpdu_hdr_sz * index));
#line 3113
    pasync_header_h->pa.u.a64.address = pasync_ctx->async_header.pa_base.u.a64.address + (unsigned long long )(p->defpdu_hdr_sz * index);
#line 3117
    list_add_tail(& pasync_header_h->link, & pasync_ctx->async_header.free_list);
#line 3120
    pasync_header_h = pasync_header_h + 1;
#line 3121
    pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries + 1U;
#line 3122
    pasync_ctx->async_header.writables = pasync_ctx->async_header.writables + 1U;
#line 3124
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->wait_queue.list);
#line 3126
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->header_busy_list);
#line 3128
    pasync_data_h->cri = 65535U;
#line 3129
    pasync_data_h->index = (unsigned char )index;
#line 3130
    INIT_LIST_HEAD(& pasync_data_h->link);
#line 3132
    if (num_async_data == 0U) {
#line 3133
      num_per_mem = 0U;
#line 3134
      idx = idx + 1U;
#line 3135
      pasync_ctx->async_data.va_base = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3138
      pasync_ctx->async_data.pa_base.u.a64.address = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3142
      num_async_data = (mem_descr->mem_array + (unsigned long )idx)->size / phba->params.defpdu_data_sz;
    } else {

    }
#line 3147
    pasync_data_h->pbuffer = (void *)((unsigned long )pasync_ctx->async_data.va_base + (unsigned long )(p->defpdu_data_sz * num_per_mem));
#line 3152
    pasync_data_h->pa.u.a64.address = pasync_ctx->async_data.pa_base.u.a64.address + (unsigned long long )(p->defpdu_data_sz * num_per_mem);
#line 3156
    num_per_mem = num_per_mem + 1U;
#line 3157
    num_async_data = num_async_data - 1U;
#line 3159
    list_add_tail(& pasync_data_h->link, & pasync_ctx->async_data.free_list);
#line 3162
    pasync_data_h = pasync_data_h + 1;
#line 3163
    pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries + 1U;
#line 3164
    pasync_ctx->async_data.writables = pasync_ctx->async_data.writables + 1U;
#line 3166
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->data_busy_list);
#line 3103
    index = index + 1U;
    ldv_55687: ;
#line 3102
    if (phba->fw_config.iscsi_cid_count[(int )ulp_num] > index) {
#line 3104
      goto ldv_55686;
    } else {

    }
#line 3170
    pasync_ctx->async_header.host_write_ptr = 0U;
#line 3171
    pasync_ctx->async_header.ep_read_ptr = 4294967295U;
#line 3172
    pasync_ctx->async_data.host_write_ptr = 0U;
#line 3173
    pasync_ctx->async_data.ep_read_ptr = 4294967295U;
  } else {

  }
#line 2948
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_55690: ;
#line 2948
  if ((unsigned int )ulp_num <= 1U) {
#line 2950
    goto ldv_55689;
  } else {

  }

#line 3177
  return (0);
}
}
#line 3181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_sgl_create_contiguous(void *virtual_address , u64 physical_address ,
                                    u32 length , struct be_dma_mem *sgl ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  int __ret_warn_on___2 ;
  long tmp___2 ;

  {
#line 3185
  __ret_warn_on = (unsigned long )virtual_address == (unsigned long )((void *)0);
#line 3185
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 3185
  if (tmp != 0L) {
#line 3185
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       3185);
  } else {

  }
#line 3185
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 3186
  __ret_warn_on___0 = physical_address == 0ULL;
#line 3186
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 3186
  if (tmp___0 != 0L) {
#line 3186
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       3186);
  } else {

  }
#line 3186
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 3187
  __ret_warn_on___1 = length == 0U;
#line 3187
  tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 3187
  if (tmp___1 != 0L) {
#line 3187
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       3187);
  } else {

  }
#line 3187
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 3188
  __ret_warn_on___2 = (unsigned long )sgl == (unsigned long )((struct be_dma_mem *)0);
#line 3188
  tmp___2 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 3188
  if (tmp___2 != 0L) {
#line 3188
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                       3188);
  } else {

  }
#line 3188
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 3190
  sgl->va = virtual_address;
#line 3191
  sgl->dma = physical_address;
#line 3192
  sgl->size = length;
#line 3194
  return (0);
}
}
#line 3197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_sgl_destroy_contiguous(struct be_dma_mem *sgl ) 
{ 


  {
#line 3199
  memset((void *)sgl, 0, 24UL);
#line 3200
  return;
}
}
#line 3203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_build_be_sgl_arr(struct beiscsi_hba *phba , struct mem_array *pmem ,
                                 struct be_dma_mem *sgl ) 
{ 


  {
#line 3206
  if ((unsigned long )sgl->va != (unsigned long )((void *)0)) {
#line 3207
    be_sgl_destroy_contiguous(sgl);
  } else {

  }
#line 3209
  be_sgl_create_contiguous(pmem->virtual_address, pmem->bus_address.u.a64.address,
                           pmem->size, sgl);
#line 3212
  return;
}
}
#line 3215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_build_be_sgl_by_offset(struct beiscsi_hba *phba , struct mem_array *pmem ,
                                       struct be_dma_mem *sgl ) 
{ 


  {
#line 3218
  if ((unsigned long )sgl->va != (unsigned long )((void *)0)) {
#line 3219
    be_sgl_destroy_contiguous(sgl);
  } else {

  }
#line 3221
  be_sgl_create_contiguous(pmem->virtual_address, pmem->bus_address.u.a64.address,
                           pmem->size, sgl);
#line 3224
  return;
}
}
#line 3226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_fill_queue(struct be_queue_info *q , u16 len , u16 entry_size , void *vaddress ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 3229
  mem = & q->dma_mem;
#line 3231
  memset((void *)q, 0, 40UL);
#line 3232
  q->len = len;
#line 3233
  q->entry_size = entry_size;
#line 3234
  mem->size = (u32 )((int )len * (int )entry_size);
#line 3235
  mem->va = vaddress;
#line 3236
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 3237
    return (-12);
  } else {

  }
#line 3238
  memset(mem->va, 0, (size_t )mem->size);
#line 3239
  return (0);
}
}
#line 3242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_eqs(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  unsigned int i ;
  unsigned int num_eq_pages ;
  int ret ;
  int eq_for_mcc ;
  struct be_queue_info *eq ;
  struct be_dma_mem *mem ;
  void *eq_vaddress ;
  dma_addr_t paddr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 3246
  ret = 0;
#line 3252
  num_eq_pages = (unsigned long )phba->params.num_eq_entries * 4UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_eq_entries + 1024UL) * 4UL - 1UL) / 4096UL) : 1U;
#line 3255
  if ((int )phba->msix_enabled) {
#line 3256
    eq_for_mcc = 1;
  } else {
#line 3258
    eq_for_mcc = 0;
  }
#line 3259
  i = 0U;
#line 3259
  goto ldv_55743;
  ldv_55742: 
#line 3260
  eq = & phwi_context->be_eq[i].q;
#line 3261
  mem = & eq->dma_mem;
#line 3262
  phwi_context->be_eq[i].phba = phba;
#line 3263
  eq_vaddress = pci_alloc_consistent(phba->pcidev, (unsigned long )num_eq_pages * 4096UL,
                                     & paddr);
#line 3266
  if ((unsigned long )eq_vaddress == (unsigned long )((void *)0)) {
#line 3267
    goto create_eq_error;
  } else {

  }
#line 3269
  mem->va = eq_vaddress;
#line 3270
  ret = be_fill_queue(eq, (int )((u16 )phba->params.num_eq_entries), 4, eq_vaddress);
#line 3272
  if (ret != 0) {
#line 3273
    log_value = phba->attr_log_enable;
#line 3273
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3273
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for EQ\n",
                 3274);
    } else {

    }
#line 3275
    goto create_eq_error;
  } else {

  }
#line 3278
  mem->dma = paddr;
#line 3279
  ret = beiscsi_cmd_eq_create(& phba->ctrl, eq, (int )phwi_context->cur_eqd);
#line 3281
  if (ret != 0) {
#line 3282
    log_value___0 = phba->attr_log_enable;
#line 3282
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3282
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_cmd_eq_createFailed for EQ\n",
                 3284);
    } else {

    }
#line 3285
    goto create_eq_error;
  } else {

  }
#line 3288
  log_value___1 = phba->attr_log_enable;
#line 3288
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3288
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : eqid = %d\n",
               3290, (int )phwi_context->be_eq[i].q.id);
  } else {

  }
#line 3259
  i = i + 1U;
  ldv_55743: ;
#line 3259
  if (phba->num_cpus + (unsigned int )eq_for_mcc > i) {
#line 3261
    goto ldv_55742;
  } else {

  }

#line 3292
  return (0);
  create_eq_error: 
#line 3294
  i = 0U;
#line 3294
  goto ldv_55746;
  ldv_55745: 
#line 3295
  eq = & phwi_context->be_eq[i].q;
#line 3296
  mem = & eq->dma_mem;
#line 3297
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 3298
    pci_free_consistent(phba->pcidev, (unsigned long )num_eq_pages * 4096UL, mem->va,
                        mem->dma);
  } else {

  }
#line 3294
  i = i + 1U;
  ldv_55746: ;
#line 3294
  if (phba->num_cpus + (unsigned int )eq_for_mcc > i) {
#line 3296
    goto ldv_55745;
  } else {

  }

#line 3302
  return (ret);
}
}
#line 3305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_cqs(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  unsigned int i ;
  unsigned int num_cq_pages ;
  int ret ;
  struct be_queue_info *cq ;
  struct be_queue_info *eq ;
  struct be_dma_mem *mem ;
  struct be_eq_obj *pbe_eq ;
  void *cq_vaddress ;
  dma_addr_t paddr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 3309
  ret = 0;
#line 3316
  num_cq_pages = (unsigned long )phba->params.num_cq_entries * 16UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_cq_entries + 256UL) * 16UL - 1UL) / 4096UL) : 1U;
#line 3319
  i = 0U;
#line 3319
  goto ldv_55766;
  ldv_55765: 
#line 3320
  cq = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3321
  eq = & phwi_context->be_eq[i].q;
#line 3322
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 3323
  pbe_eq->cq = cq;
#line 3324
  pbe_eq->phba = phba;
#line 3325
  mem = & cq->dma_mem;
#line 3326
  cq_vaddress = pci_alloc_consistent(phba->pcidev, (unsigned long )num_cq_pages * 4096UL,
                                     & paddr);
#line 3329
  if ((unsigned long )cq_vaddress == (unsigned long )((void *)0)) {
#line 3330
    goto create_cq_error;
  } else {

  }
#line 3331
  ret = be_fill_queue(cq, (int )((u16 )phba->params.num_cq_entries), 16, cq_vaddress);
#line 3333
  if (ret != 0) {
#line 3334
    log_value = phba->attr_log_enable;
#line 3334
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3334
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for ISCSI CQ\n",
                 3336);
    } else {

    }
#line 3337
    goto create_cq_error;
  } else {

  }
#line 3340
  mem->dma = paddr;
#line 3341
  ret = beiscsi_cmd_cq_create(& phba->ctrl, cq, eq, 0, 0, 0);
#line 3343
  if (ret != 0) {
#line 3344
    log_value___0 = phba->attr_log_enable;
#line 3344
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3344
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_cmd_eq_createFailed for ISCSI CQ\n",
                 3346);
    } else {

    }
#line 3347
    goto create_cq_error;
  } else {

  }
#line 3349
  log_value___1 = phba->attr_log_enable;
#line 3349
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3349
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi cq_id is %d for eq_id %d\niSCSI CQ CREATED\n",
               3351, (int )cq->id, (int )eq->id);
  } else {

  }
#line 3319
  i = i + 1U;
  ldv_55766: ;
#line 3319
  if (phba->num_cpus > i) {
#line 3321
    goto ldv_55765;
  } else {

  }

#line 3353
  return (0);
  create_cq_error: 
#line 3356
  i = 0U;
#line 3356
  goto ldv_55769;
  ldv_55768: 
#line 3357
  cq = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3358
  mem = & cq->dma_mem;
#line 3359
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 3360
    pci_free_consistent(phba->pcidev, (unsigned long )num_cq_pages * 4096UL, mem->va,
                        mem->dma);
  } else {

  }
#line 3356
  i = i + 1U;
  ldv_55769: ;
#line 3356
  if (phba->num_cpus > i) {
#line 3358
    goto ldv_55768;
  } else {

  }

#line 3364
  return (ret);
}
}
#line 3369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_def_hdr(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                  struct hwi_controller *phwi_ctrlr , unsigned int def_pdu_ring_sz ,
                                  uint8_t ulp_num ) 
{ 
  unsigned int idx ;
  int ret ;
  struct be_queue_info *dq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *mem ;
  struct be_mem_descriptor *mem_descr ;
  void *dq_vaddress ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 3381
  idx = 0U;
#line 3382
  dq = (struct be_queue_info *)(& phwi_context->be_def_hdrq) + (unsigned long )ulp_num;
#line 3383
  cq = (struct be_queue_info *)(& phwi_context->be_cq);
#line 3384
  mem = & dq->dma_mem;
#line 3385
  mem_descr = phba->init_mem;
#line 3386
  mem_descr = mem_descr + (unsigned long )(((int )ulp_num + 1) * 8);
#line 3388
  dq_vaddress = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3389
  ret = be_fill_queue(dq, (int )((u16 )((mem_descr->mem_array)->size / 8U)), 8, dq_vaddress);
#line 3392
  if (ret != 0) {
#line 3393
    log_value = phba->attr_log_enable;
#line 3393
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3393
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for DEF PDU HDR on ULP : %d\n",
                 3395, (int )ulp_num);
    } else {

    }
#line 3397
    return (ret);
  } else {

  }
#line 3399
  mem->dma = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3401
  ret = be_cmd_create_default_pdu_queue(& phba->ctrl, cq, dq, (int )def_pdu_ring_sz,
                                        (int )phba->params.defpdu_hdr_sz, 1, (int )ulp_num);
#line 3405
  if (ret != 0) {
#line 3406
    log_value___0 = phba->attr_log_enable;
#line 3406
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3406
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_cmd_create_default_pdu_queue Failed DEFHDR on ULP : %d\n",
                 3408, (int )ulp_num);
    } else {

    }
#line 3410
    return (ret);
  } else {

  }
#line 3413
  log_value___1 = phba->attr_log_enable;
#line 3413
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3413
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi hdr def pdu id for ULP : %d is %d\n",
               3416, (int )ulp_num, (int )phwi_context->be_def_hdrq[(int )ulp_num].id);
  } else {

  }
#line 3417
  hwi_post_async_buffers(phba, 1U, (int )ulp_num);
#line 3418
  return (0);
}
}
#line 3422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_def_data(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                   struct hwi_controller *phwi_ctrlr , unsigned int def_pdu_ring_sz ,
                                   uint8_t ulp_num ) 
{ 
  unsigned int idx ;
  int ret ;
  struct be_queue_info *dataq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *mem ;
  struct be_mem_descriptor *mem_descr ;
  void *dq_vaddress ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 3434
  idx = 0U;
#line 3435
  dataq = (struct be_queue_info *)(& phwi_context->be_def_dataq) + (unsigned long )ulp_num;
#line 3436
  cq = (struct be_queue_info *)(& phwi_context->be_cq);
#line 3437
  mem = & dataq->dma_mem;
#line 3438
  mem_descr = phba->init_mem;
#line 3439
  mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 9);
#line 3441
  dq_vaddress = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3442
  ret = be_fill_queue(dataq, (int )((u16 )((mem_descr->mem_array)->size / 8U)), 8,
                      dq_vaddress);
#line 3445
  if (ret != 0) {
#line 3446
    log_value = phba->attr_log_enable;
#line 3446
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3446
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for DEF PDU DATA on ULP : %d\n",
                 3449, (int )ulp_num);
    } else {

    }
#line 3451
    return (ret);
  } else {

  }
#line 3453
  mem->dma = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3455
  ret = be_cmd_create_default_pdu_queue(& phba->ctrl, cq, dataq, (int )def_pdu_ring_sz,
                                        (int )phba->params.defpdu_data_sz, 0, (int )ulp_num);
#line 3459
  if (ret != 0) {
#line 3460
    log_value___0 = phba->attr_log_enable;
#line 3460
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3460
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d be_cmd_create_default_pdu_queue Failed for DEF PDU DATA on ULP : %d\n",
                 3463, (int )ulp_num);
    } else {

    }
#line 3464
    return (ret);
  } else {

  }
#line 3467
  log_value___1 = phba->attr_log_enable;
#line 3467
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3467
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi def data id on ULP : %d is  %d\n",
               3470, (int )ulp_num, (int )phwi_context->be_def_dataq[(int )ulp_num].id);
  } else {

  }
#line 3472
  hwi_post_async_buffers(phba, 0U, (int )ulp_num);
#line 3473
  log_value___2 = phba->attr_log_enable;
#line 3473
  if ((int )log_value___2 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3473
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : DEFAULT PDU DATA RING CREATEDon ULP : %d\n",
               3475, (int )ulp_num);
  } else {

  }
#line 3477
  return (0);
}
}
#line 3482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_post_template_hdr(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *pm_arr ;
  struct be_dma_mem sgl ;
  int status ;
  int ulp_num ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp ;

  {
#line 3489
  ulp_num = 0;
#line 3489
  goto ldv_55817;
  ldv_55816: 
#line 3490
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3490
  if (tmp != 0) {
#line 3491
    mem_descr = phba->init_mem;
#line 3492
    mem_descr = mem_descr + (unsigned long )(ulp_num * 8 + 5);
#line 3494
    pm_arr = mem_descr->mem_array;
#line 3496
    hwi_build_be_sgl_arr(phba, pm_arr, & sgl);
#line 3497
    status = be_cmd_iscsi_post_template_hdr(& phba->ctrl, & sgl);
#line 3500
    if (status != 0) {
#line 3501
      log_value = phba->attr_log_enable;
#line 3501
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3501
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Post Template HDR Failed forULP_%d\n", 3503, ulp_num);
      } else {

      }
#line 3504
      return (status);
    } else {

    }
#line 3507
    log_value___0 = phba->attr_log_enable;
#line 3507
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3507
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Template HDR Pages Posted forULP_%d\n", 3509, ulp_num);
    } else {

    }
  } else {

  }
#line 3489
  ulp_num = ulp_num + 1;
  ldv_55817: ;
#line 3489
  if (ulp_num <= 1) {
#line 3491
    goto ldv_55816;
  } else {

  }

#line 3512
  return (0);
}
}
#line 3516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_post_pages(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *pm_arr ;
  unsigned int page_offset___0 ;
  unsigned int i ;
  struct be_dma_mem sgl ;
  int status ;
  int ulp_num ;
  int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 3522
  ulp_num = 0;
#line 3524
  mem_descr = phba->init_mem;
#line 3525
  mem_descr = mem_descr + 4UL;
#line 3526
  pm_arr = mem_descr->mem_array;
#line 3528
  ulp_num = 0;
#line 3528
  goto ldv_55831;
  ldv_55830: 
#line 3529
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3529
  if (tmp != 0) {
#line 3530
    goto ldv_55829;
  } else {

  }
#line 3528
  ulp_num = ulp_num + 1;
  ldv_55831: ;
#line 3528
  if (ulp_num <= 1) {
#line 3530
    goto ldv_55830;
  } else {

  }
  ldv_55829: 
#line 3532
  page_offset___0 = (unsigned int )((((unsigned long )phba->params.num_sge_per_io * (unsigned long )phba->fw_config.iscsi_icd_start[ulp_num]) * 16UL) / 4096UL);
#line 3534
  i = 0U;
#line 3534
  goto ldv_55834;
  ldv_55833: 
#line 3535
  hwi_build_be_sgl_arr(phba, pm_arr, & sgl);
#line 3536
  status = be_cmd_iscsi_post_sgl_pages(& phba->ctrl, & sgl, page_offset___0, pm_arr->size / 4096U);
#line 3539
  page_offset___0 = pm_arr->size / 4096U + page_offset___0;
#line 3540
  if (status != 0) {
#line 3541
    log_value = phba->attr_log_enable;
#line 3541
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3541
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : post sgl failed.\n",
                 3542);
    } else {

    }
#line 3543
    return (status);
  } else {

  }
#line 3545
  pm_arr = pm_arr + 1;
#line 3534
  i = i + 1U;
  ldv_55834: ;
#line 3534
  if (mem_descr->num_elements > i) {
#line 3536
    goto ldv_55833;
  } else {

  }
#line 3547
  log_value___0 = phba->attr_log_enable;
#line 3547
  if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3547
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : POSTED PAGES\n",
               3548);
  } else {

  }
#line 3549
  return (0);
}
}
#line 3552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_queue_free(struct beiscsi_hba *phba , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 3554
  mem = & q->dma_mem;
#line 3555
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 3556
    pci_free_consistent(phba->pcidev, (size_t )mem->size, mem->va, mem->dma);
#line 3558
    mem->va = (void *)0;
  } else {

  }
#line 3560
  return;
}
}
#line 3562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_queue_alloc(struct beiscsi_hba *phba , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 3565
  mem = & q->dma_mem;
#line 3567
  memset((void *)q, 0, 40UL);
#line 3568
  q->len = len;
#line 3569
  q->entry_size = entry_size;
#line 3570
  mem->size = (u32 )((int )len * (int )entry_size);
#line 3571
  mem->va = pci_zalloc_consistent(phba->pcidev, (size_t )mem->size, & mem->dma);
#line 3572
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 3573
    return (-12);
  } else {

  }
#line 3574
  return (0);
}
}
#line 3578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_wrb_rings(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                    struct hwi_controller *phwi_ctrlr ) 
{ 
  unsigned int wrb_mem_index ;
  unsigned int offset ;
  unsigned int size ;
  unsigned int num_wrb_rings ;
  u64 pa_addr_lo ;
  unsigned int idx ;
  unsigned int num ;
  unsigned int i ;
  unsigned int ulp_num ;
  struct mem_array *pwrb_arr ;
  void *wrb_vaddr ;
  struct be_dma_mem sgl ;
  struct be_mem_descriptor *mem_descr ;
  struct hwi_wrb_context *pwrb_context ;
  int status ;
  uint8_t ulp_count ;
  uint8_t ulp_base_num ;
  uint16_t cid_count_ulp[2U] ;
  unsigned int tmp ;
  void *tmp___0 ;
  uint32_t log_value ;
  int tmp___1 ;
  uint32_t log_value___0 ;

  {
#line 3591
  ulp_count = 0U;
#line 3591
  ulp_base_num = 0U;
#line 3592
  cid_count_ulp[0] = 0U;
#line 3592
  tmp = 1U;
#line 3592
  while (1) {
#line 3592
    if (tmp >= 2U) {
#line 3592
      break;
    } else {

    }
#line 3592
    cid_count_ulp[tmp] = (unsigned short)0;
#line 3592
    tmp = tmp + 1U;
  }
#line 3594
  idx = 0U;
#line 3595
  mem_descr = phba->init_mem;
#line 3596
  mem_descr = mem_descr + 1UL;
#line 3597
  tmp___0 = kmalloc((unsigned long )phba->params.cxns_per_ctrl * 24UL, 208U);
#line 3597
  pwrb_arr = (struct mem_array *)tmp___0;
#line 3599
  if ((unsigned long )pwrb_arr == (unsigned long )((struct mem_array *)0)) {
#line 3600
    log_value = phba->attr_log_enable;
#line 3600
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3600
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Memory alloc failed in create wrb ring.\n",
                 3601);
    } else {

    }
#line 3602
    return (-12);
  } else {

  }
#line 3604
  wrb_vaddr = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3605
  pa_addr_lo = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3606
  num_wrb_rings = (unsigned int )((unsigned long )(mem_descr->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 3609
  num = 0U;
#line 3609
  goto ldv_55874;
  ldv_55873: ;
#line 3610
  if (num_wrb_rings != 0U) {
#line 3611
    (pwrb_arr + (unsigned long )num)->virtual_address = wrb_vaddr;
#line 3612
    (pwrb_arr + (unsigned long )num)->bus_address.u.a64.address = pa_addr_lo;
#line 3613
    (pwrb_arr + (unsigned long )num)->size = phba->params.wrbs_per_cxn * 64U;
#line 3615
    wrb_vaddr = wrb_vaddr + (unsigned long )(pwrb_arr + (unsigned long )num)->size;
#line 3616
    pa_addr_lo = (u64 )(pwrb_arr + (unsigned long )num)->size + pa_addr_lo;
#line 3617
    num_wrb_rings = num_wrb_rings - 1U;
  } else {
#line 3619
    idx = idx + 1U;
#line 3620
    wrb_vaddr = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3621
    pa_addr_lo = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3623
    num_wrb_rings = (unsigned int )((unsigned long )(mem_descr->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 3626
    (pwrb_arr + (unsigned long )num)->virtual_address = wrb_vaddr;
#line 3627
    (pwrb_arr + (unsigned long )num)->bus_address.u.a64.address = pa_addr_lo;
#line 3629
    (pwrb_arr + (unsigned long )num)->size = phba->params.wrbs_per_cxn * 64U;
#line 3631
    wrb_vaddr = wrb_vaddr + (unsigned long )(pwrb_arr + (unsigned long )num)->size;
#line 3632
    pa_addr_lo = (u64 )(pwrb_arr + (unsigned long )num)->size + pa_addr_lo;
#line 3633
    num_wrb_rings = num_wrb_rings - 1U;
  }
#line 3609
  num = num + 1U;
  ldv_55874: ;
#line 3609
  if (phba->params.cxns_per_ctrl > num) {
#line 3611
    goto ldv_55873;
  } else {

  }
#line 3638
  ulp_num = 0U;
#line 3638
  goto ldv_55877;
  ldv_55876: 
#line 3639
  tmp___1 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3639
  if (tmp___1 != 0) {
#line 3640
    ulp_count = (uint8_t )((int )ulp_count + 1);
#line 3641
    ulp_base_num = (uint8_t )ulp_num;
#line 3642
    cid_count_ulp[ulp_num] = (uint16_t )phba->fw_config.iscsi_cid_count[ulp_num];
  } else {

  }
#line 3638
  ulp_num = ulp_num + 1U;
  ldv_55877: ;
#line 3638
  if (ulp_num <= 1U) {
#line 3640
    goto ldv_55876;
  } else {

  }
#line 3646
  i = 0U;
#line 3646
  goto ldv_55881;
  ldv_55880: 
#line 3647
  wrb_mem_index = 0U;
#line 3648
  offset = 0U;
#line 3649
  size = 0U;
#line 3651
  if ((unsigned int )ulp_count > 1U) {
#line 3652
    ulp_base_num = (uint8_t )(((int )ulp_base_num + 1) % 2);
#line 3654
    if ((unsigned int )cid_count_ulp[(int )ulp_base_num] == 0U) {
#line 3655
      ulp_base_num = (uint8_t )(((int )ulp_base_num + 1) % 2);
    } else {

    }
#line 3658
    cid_count_ulp[(int )ulp_base_num] = (uint16_t )((int )cid_count_ulp[(int )ulp_base_num] - 1);
  } else {

  }
#line 3662
  hwi_build_be_sgl_by_offset(phba, pwrb_arr + (unsigned long )i, & sgl);
#line 3663
  status = be_cmd_wrbq_create(& phba->ctrl, & sgl, phwi_context->be_wrbq + (unsigned long )i,
                              phwi_ctrlr->wrb_context + (unsigned long )i, (int )ulp_base_num);
#line 3667
  if (status != 0) {
#line 3668
    log_value___0 = phba->attr_log_enable;
#line 3668
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3668
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : wrbq create failed.",
                 3669);
    } else {

    }
#line 3670
    kfree((void const   *)pwrb_arr);
#line 3671
    return (status);
  } else {

  }
#line 3673
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )i;
#line 3674
  phba->cid_to_cri_map[(int )pwrb_context->cid] = (unsigned short )i;
#line 3646
  i = i + 1U;
  ldv_55881: ;
#line 3646
  if (phba->params.cxns_per_ctrl > i) {
#line 3648
    goto ldv_55880;
  } else {

  }
#line 3676
  kfree((void const   *)pwrb_arr);
#line 3677
  return (0);
}
}
#line 3680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void free_wrb_handles(struct beiscsi_hba *phba ) 
{ 
  unsigned int index ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;

  {
#line 3686
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3687
  index = 0U;
#line 3687
  goto ldv_55890;
  ldv_55889: 
#line 3688
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 3689
  kfree((void const   *)pwrb_context->pwrb_handle_base);
#line 3690
  kfree((void const   *)pwrb_context->pwrb_handle_basestd);
#line 3687
  index = index + 1U;
  ldv_55890: ;
#line 3687
  if (phba->params.cxns_per_ctrl > index) {
#line 3689
    goto ldv_55889;
  } else {

  }

#line 3694
  return;
}
}
#line 3694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_mcc_queues_destroy(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *q ;
  struct be_ctrl_info *ctrl ;

  {
#line 3697
  ctrl = & phba->ctrl;
#line 3699
  q = & phba->ctrl.mcc_obj.q;
#line 3700
  if ((int )q->created) {
#line 3701
    beiscsi_cmd_q_destroy(ctrl, q, 3);
#line 3702
    be_queue_free(phba, q);
  } else {

  }
#line 3705
  q = & phba->ctrl.mcc_obj.cq;
#line 3706
  if ((int )q->created) {
#line 3707
    beiscsi_cmd_q_destroy(ctrl, q, 2);
#line 3708
    be_queue_free(phba, q);
  } else {

  }
#line 3710
  return;
}
}
#line 3712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_cleanup(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *q ;
  struct be_ctrl_info *ctrl ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct hwi_async_pdu_context *pasync_ctx ;
  int i ;
  int eq_for_mcc ;
  int ulp_num ;
  int tmp ;

  {
#line 3715
  ctrl = & phba->ctrl;
#line 3721
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3722
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 3724
  be_cmd_iscsi_remove_template_hdr(ctrl);
#line 3726
  i = 0;
#line 3726
  goto ldv_55909;
  ldv_55908: 
#line 3727
  q = phwi_context->be_wrbq + (unsigned long )i;
#line 3728
  if ((int )q->created) {
#line 3729
    beiscsi_cmd_q_destroy(ctrl, q, 4);
  } else {

  }
#line 3726
  i = i + 1;
  ldv_55909: ;
#line 3726
  if ((unsigned int )i < phba->params.cxns_per_ctrl) {
#line 3728
    goto ldv_55908;
  } else {

  }
#line 3731
  kfree((void const   *)phwi_context->be_wrbq);
#line 3732
  free_wrb_handles(phba);
#line 3734
  ulp_num = 0;
#line 3734
  goto ldv_55912;
  ldv_55911: 
#line 3735
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3735
  if (tmp != 0) {
#line 3737
    q = (struct be_queue_info *)(& phwi_context->be_def_hdrq) + (unsigned long )ulp_num;
#line 3738
    if ((int )q->created) {
#line 3739
      beiscsi_cmd_q_destroy(ctrl, q, 5);
    } else {

    }
#line 3741
    q = (struct be_queue_info *)(& phwi_context->be_def_dataq) + (unsigned long )ulp_num;
#line 3742
    if ((int )q->created) {
#line 3743
      beiscsi_cmd_q_destroy(ctrl, q, 5);
    } else {

    }
#line 3745
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[ulp_num];
  } else {

  }
#line 3734
  ulp_num = ulp_num + 1;
  ldv_55912: ;
#line 3734
  if (ulp_num <= 1) {
#line 3736
    goto ldv_55911;
  } else {

  }
#line 3749
  beiscsi_cmd_q_destroy(ctrl, (struct be_queue_info *)0, 6);
#line 3751
  i = 0;
#line 3751
  goto ldv_55915;
  ldv_55914: 
#line 3752
  q = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3753
  if ((int )q->created) {
#line 3754
    be_queue_free(phba, q);
#line 3755
    beiscsi_cmd_q_destroy(ctrl, q, 2);
  } else {

  }
#line 3751
  i = i + 1;
  ldv_55915: ;
#line 3751
  if ((unsigned int )i < phba->num_cpus) {
#line 3753
    goto ldv_55914;
  } else {

  }
#line 3759
  be_mcc_queues_destroy(phba);
#line 3760
  if ((int )phba->msix_enabled) {
#line 3761
    eq_for_mcc = 1;
  } else {
#line 3763
    eq_for_mcc = 0;
  }
#line 3764
  i = 0;
#line 3764
  goto ldv_55918;
  ldv_55917: 
#line 3765
  q = & phwi_context->be_eq[i].q;
#line 3766
  if ((int )q->created) {
#line 3767
    be_queue_free(phba, q);
#line 3768
    beiscsi_cmd_q_destroy(ctrl, q, 1);
  } else {

  }
#line 3764
  i = i + 1;
  ldv_55918: ;
#line 3764
  if ((unsigned int )i < phba->num_cpus + (unsigned int )eq_for_mcc) {
#line 3766
    goto ldv_55917;
  } else {

  }
#line 3771
  be_cmd_fw_uninit(ctrl);
#line 3772
  return;
}
}
#line 3774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int be_mcc_queues_create(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  struct be_ctrl_info *ctrl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3778
  ctrl = & phba->ctrl;
#line 3781
  cq = & phba->ctrl.mcc_obj.cq;
#line 3782
  tmp = be_queue_alloc(phba, cq, 256, 16);
#line 3782
  if (tmp != 0) {
#line 3784
    goto err;
  } else {

  }
#line 3786
  if ((int )phba->msix_enabled) {
#line 3787
    tmp___0 = beiscsi_cmd_cq_create(ctrl, cq, & phwi_context->be_eq[phba->num_cpus].q,
                                    0, 1, 0);
#line 3787
    if (tmp___0 != 0) {
#line 3789
      goto mcc_cq_free;
    } else {

    }
  } else {
#line 3791
    tmp___1 = beiscsi_cmd_cq_create(ctrl, cq, & phwi_context->be_eq[0].q, 0, 1, 0);
#line 3791
    if (tmp___1 != 0) {
#line 3793
      goto mcc_cq_free;
    } else {

    }
  }
#line 3797
  q = & phba->ctrl.mcc_obj.q;
#line 3798
  tmp___2 = be_queue_alloc(phba, q, 128, 256);
#line 3798
  if (tmp___2 != 0) {
#line 3799
    goto mcc_cq_destroy;
  } else {

  }
#line 3802
  tmp___3 = beiscsi_cmd_mccq_create(phba, q, cq);
#line 3802
  if (tmp___3 != 0) {
#line 3803
    goto mcc_q_free;
  } else {

  }
#line 3805
  return (0);
  mcc_q_free: 
#line 3808
  be_queue_free(phba, q);
  mcc_cq_destroy: 
#line 3810
  beiscsi_cmd_q_destroy(ctrl, cq, 2);
  mcc_cq_free: 
#line 3812
  be_queue_free(phba, cq);
  err: ;
#line 3814
  return (-12);
}
}
#line 3823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void find_num_cpus(struct beiscsi_hba *phba ) 
{ 
  int num_cpus ;
  unsigned int tmp ;

  {
#line 3825
  num_cpus = 0;
#line 3827
  tmp = cpumask_weight(cpu_online_mask);
#line 3827
  num_cpus = (int )tmp;
#line 3829
  switch (phba->generation) {
  case 2U: ;
  case 3U: 
#line 3832
  phba->num_cpus = (unsigned int )(7 < num_cpus ? 7 : num_cpus);
#line 3834
  goto ldv_55937;
  case 4U: ;
#line 3840
  if (phba->fw_config.eqid_count == 1U) {
#line 3841
    enable_msix = 0U;
#line 3842
    phba->num_cpus = 1U;
#line 3843
    return;
  } else {

  }
#line 3846
  phba->num_cpus = phba->fw_config.eqid_count - 1U < (unsigned int )num_cpus ? phba->fw_config.eqid_count - 1U : (unsigned int )num_cpus;
#line 3849
  goto ldv_55937;
  default: 
#line 3851
  phba->num_cpus = 1U;
  }
  ldv_55937: ;
#line 3854
  return;
}
}
#line 3855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_port(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  unsigned int def_pdu_ring_sz ;
  struct be_ctrl_info *ctrl ;
  int status ;
  int ulp_num ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  int tmp ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint16_t async_arr_idx ;
  uint16_t cri ;
  struct hwi_async_pdu_context *pasync_ctx ;
  uint16_t tmp___0 ;
  int tmp___1 ;
  uint32_t log_value___7 ;
  uint32_t log_value___8 ;

  {
#line 3860
  ctrl = & phba->ctrl;
#line 3863
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3864
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 3865
  phwi_context->max_eqd = 128U;
#line 3866
  phwi_context->min_eqd = 0U;
#line 3867
  phwi_context->cur_eqd = 0U;
#line 3868
  be_cmd_fw_initialize(& phba->ctrl);
#line 3870
  status = beiscsi_create_eqs(phba, phwi_context);
#line 3871
  if (status != 0) {
#line 3872
    log_value = phba->attr_log_enable;
#line 3872
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3872
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EQ not created\n",
                 3873);
    } else {

    }
#line 3874
    goto error;
  } else {

  }
#line 3877
  status = be_mcc_queues_create(phba, phwi_context);
#line 3878
  if (status != 0) {
#line 3879
    goto error;
  } else {

  }
#line 3881
  status = mgmt_check_supported_fw(ctrl, phba);
#line 3882
  if (status != 0) {
#line 3883
    log_value___0 = phba->attr_log_enable;
#line 3883
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3883
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unsupported fw version\n",
                 3884);
    } else {

    }
#line 3885
    goto error;
  } else {

  }
#line 3888
  status = beiscsi_create_cqs(phba, phwi_context);
#line 3889
  if (status != 0) {
#line 3890
    log_value___1 = phba->attr_log_enable;
#line 3890
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3890
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : CQ not created\n",
                 3891);
    } else {

    }
#line 3892
    goto error;
  } else {

  }
#line 3895
  ulp_num = 0;
#line 3895
  goto ldv_55956;
  ldv_55955: 
#line 3896
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3896
  if (tmp != 0) {
#line 3898
    def_pdu_ring_sz = phba->fw_config.iscsi_cid_count[ulp_num] * 8U;
#line 3902
    status = beiscsi_create_def_hdr(phba, phwi_context, phwi_ctrlr, def_pdu_ring_sz,
                                    (int )((uint8_t )ulp_num));
#line 3906
    if (status != 0) {
#line 3907
      log_value___2 = phba->attr_log_enable;
#line 3907
      if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3907
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Default Header not created for ULP : %d\n", 3909, ulp_num);
      } else {

      }
#line 3910
      goto error;
    } else {

    }
#line 3913
    status = beiscsi_create_def_data(phba, phwi_context, phwi_ctrlr, def_pdu_ring_sz,
                                     (int )((uint8_t )ulp_num));
#line 3917
    if (status != 0) {
#line 3918
      log_value___3 = phba->attr_log_enable;
#line 3918
      if ((int )log_value___3 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3918
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Default Data not created for ULP : %d\n", 3920, ulp_num);
      } else {

      }
#line 3921
      goto error;
    } else {

    }
  } else {

  }
#line 3895
  ulp_num = ulp_num + 1;
  ldv_55956: ;
#line 3895
  if (ulp_num <= 1) {
#line 3897
    goto ldv_55955;
  } else {

  }
#line 3926
  status = beiscsi_post_pages(phba);
#line 3927
  if (status != 0) {
#line 3928
    log_value___4 = phba->attr_log_enable;
#line 3928
    if ((int )log_value___4 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3928
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Post SGL Pages Failed\n",
                 3929);
    } else {

    }
#line 3930
    goto error;
  } else {

  }
#line 3933
  status = beiscsi_post_template_hdr(phba);
#line 3934
  if (status != 0) {
#line 3935
    log_value___5 = phba->attr_log_enable;
#line 3935
    if ((int )log_value___5 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3935
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Template HDR Posting for CXN Failed\n",
                 3936);
    } else {

    }
  } else {

  }
#line 3939
  status = beiscsi_create_wrb_rings(phba, phwi_context, phwi_ctrlr);
#line 3940
  if (status != 0) {
#line 3941
    log_value___6 = phba->attr_log_enable;
#line 3941
    if ((int )log_value___6 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3941
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : WRB Rings not created\n",
                 3942);
    } else {

    }
#line 3943
    goto error;
  } else {

  }
#line 3946
  ulp_num = 0;
#line 3946
  goto ldv_55968;
  ldv_55967: 
#line 3947
  async_arr_idx = 0U;
#line 3949
  tmp___1 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 3949
  if (tmp___1 != 0) {
#line 3950
    cri = 0U;
#line 3953
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[ulp_num];
#line 3955
    cri = 0U;
#line 3955
    goto ldv_55965;
    ldv_55964: ;
#line 3957
    if ((int )(phwi_ctrlr->wrb_context + (unsigned long )cri)->ulp_num == ulp_num) {
#line 3959
      tmp___0 = async_arr_idx;
#line 3959
      async_arr_idx = (uint16_t )((int )async_arr_idx + 1);
#line 3959
      pasync_ctx->cid_to_async_cri_map[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri)->cid] = tmp___0;
    } else {

    }
#line 3956
    cri = (uint16_t )((int )cri + 1);
    ldv_55965: ;
#line 3955
    if ((unsigned int )cri < phba->params.cxns_per_ctrl) {
#line 3958
      goto ldv_55964;
    } else {

    }

  } else {

  }
#line 3946
  ulp_num = ulp_num + 1;
  ldv_55968: ;
#line 3946
  if (ulp_num <= 1) {
#line 3948
    goto ldv_55967;
  } else {

  }
#line 3966
  log_value___7 = phba->attr_log_enable;
#line 3966
  if ((int )log_value___7 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3966
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_port success\n",
               3967);
  } else {

  }
#line 3968
  return (0);
  error: 
#line 3971
  log_value___8 = phba->attr_log_enable;
#line 3971
  if ((int )log_value___8 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3971
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_port failed",
               3972);
  } else {

  }
#line 3973
  hwi_cleanup(phba);
#line 3974
  return (status);
}
}
#line 3977 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_controller(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp ;
  uint32_t log_value___1 ;
  int tmp___0 ;
  uint32_t log_value___2 ;
  int tmp___1 ;

  {
#line 3981
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3982
  if ((phba->init_mem)->num_elements == 1U) {
#line 3983
    phwi_ctrlr->phwi_ctxt = (struct hwi_context_memory *)((phba->init_mem)->mem_array)->virtual_address;
#line 3985
    log_value = phba->attr_log_enable;
#line 3985
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 3985
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d :  phwi_ctrlr->phwi_ctxt=%p\n", 3987, phwi_ctrlr->phwi_ctxt);
    } else {

    }
  } else {
#line 3989
    log_value___0 = phba->attr_log_enable;
#line 3989
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 3989
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : HWI_MEM_ADDN_CONTEXT is more than one element.Failing to load\n",
                 3991);
    } else {

    }
#line 3992
    return (-12);
  }
#line 3995
  iscsi_init_global_templates(phba);
#line 3996
  tmp = beiscsi_init_wrb_handle(phba);
#line 3996
  if (tmp != 0) {
#line 3997
    return (-12);
  } else {

  }
#line 3999
  tmp___0 = hwi_init_async_pdu_ctx(phba);
#line 3999
  if (tmp___0 != 0) {
#line 4000
    log_value___1 = phba->attr_log_enable;
#line 4000
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4000
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_async_pdu_ctx failed\n",
                 4001);
    } else {

    }
#line 4002
    return (-12);
  } else {

  }
#line 4005
  tmp___1 = hwi_init_port(phba);
#line 4005
  if (tmp___1 != 0) {
#line 4006
    log_value___2 = phba->attr_log_enable;
#line 4006
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4006
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_controller failed\n",
                 4007);
    } else {

    }
#line 4009
    return (-12);
  } else {

  }
#line 4011
  return (0);
}
}
#line 4014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_free_mem(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  int i ;
  int j ;

  {
#line 4019
  mem_descr = phba->init_mem;
#line 4020
  i = 0;
#line 4021
  j = 0;
#line 4022
  i = 0;
#line 4022
  goto ldv_55990;
  ldv_55989: 
#line 4023
  j = (int )mem_descr->num_elements;
#line 4023
  goto ldv_55987;
  ldv_55986: 
#line 4024
  pci_free_consistent(phba->pcidev, (size_t )(mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->size,
                      (mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->virtual_address,
                      (mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->bus_address.u.a64.address);
#line 4023
  j = j - 1;
  ldv_55987: ;
#line 4023
  if (j > 0) {
#line 4025
    goto ldv_55986;
  } else {

  }
#line 4031
  kfree((void const   *)mem_descr->mem_array);
#line 4032
  mem_descr = mem_descr + 1;
#line 4022
  i = i + 1;
  ldv_55990: ;
#line 4022
  if (i <= 21) {
#line 4024
    goto ldv_55989;
  } else {

  }
#line 4034
  kfree((void const   *)phba->init_mem);
#line 4035
  kfree((void const   *)(phba->phwi_ctrlr)->wrb_context);
#line 4036
  kfree((void const   *)phba->phwi_ctrlr);
#line 4037
  return;
}
}
#line 4039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_controller(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 4041
  ret = -12;
#line 4043
  ret = beiscsi_get_memory(phba);
#line 4044
  if (ret < 0) {
#line 4045
    log_value = phba->attr_log_enable;
#line 4045
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4045
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe -Failed in beiscsi_alloc_memory\n",
                 4047);
    } else {

    }
#line 4048
    return (ret);
  } else {

  }
#line 4051
  ret = hwi_init_controller(phba);
#line 4052
  if (ret != 0) {
#line 4053
    goto free_init;
  } else {

  }
#line 4054
  log_value___0 = phba->attr_log_enable;
#line 4054
  if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4054
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Return success from beiscsi_init_controller",
               4055);
  } else {

  }
#line 4057
  return (0);
  free_init: 
#line 4060
  beiscsi_free_mem(phba);
#line 4061
  return (ret);
}
}
#line 4064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr_sglh ;
  struct be_mem_descriptor *mem_descr_sg ;
  struct sgl_handle *psgl_handle ;
  struct iscsi_sge *pfrag ;
  unsigned int arr_index ;
  unsigned int i ;
  unsigned int idx ;
  unsigned int ulp_icd_start ;
  unsigned int ulp_num ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 4070
  ulp_num = 0U;
#line 4072
  phba->io_sgl_hndl_avbl = 0U;
#line 4073
  phba->eh_sgl_hndl_avbl = 0U;
#line 4075
  mem_descr_sglh = phba->init_mem;
#line 4076
  mem_descr_sglh = mem_descr_sglh + 3UL;
#line 4077
  if (mem_descr_sglh->num_elements == 1U) {
#line 4078
    tmp = kzalloc((unsigned long )phba->params.ios_per_ctrl * 8UL, 208U);
#line 4078
    phba->io_sgl_hndl_base = (struct sgl_handle **)tmp;
#line 4081
    if ((unsigned long )phba->io_sgl_hndl_base == (unsigned long )((struct sgl_handle **)0)) {
#line 4082
      log_value = phba->attr_log_enable;
#line 4082
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4082
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Mem Alloc Failed. Failing to load\n", 4083);
      } else {

      }
#line 4084
      return (-12);
    } else {

    }
#line 4086
    tmp___0 = kzalloc((unsigned long )(phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) * 8UL,
                      208U);
#line 4086
    phba->eh_sgl_hndl_base = (struct sgl_handle **)tmp___0;
#line 4090
    if ((unsigned long )phba->eh_sgl_hndl_base == (unsigned long )((struct sgl_handle **)0)) {
#line 4091
      kfree((void const   *)phba->io_sgl_hndl_base);
#line 4092
      log_value___0 = phba->attr_log_enable;
#line 4092
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4092
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Mem Alloc Failed. Failing to load\n", 4093);
      } else {

      }
#line 4094
      return (-12);
    } else {

    }
  } else {
#line 4097
    log_value___1 = phba->attr_log_enable;
#line 4097
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4097
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : HWI_MEM_SGLH is more than one element.Failing to load\n",
                 4099);
    } else {

    }
#line 4100
    return (-12);
  }
#line 4103
  arr_index = 0U;
#line 4104
  idx = 0U;
#line 4105
  goto ldv_56018;
  ldv_56017: 
#line 4106
  psgl_handle = (struct sgl_handle *)(mem_descr_sglh->mem_array + (unsigned long )idx)->virtual_address;
#line 4108
  i = 0U;
#line 4108
  goto ldv_56015;
  ldv_56014: ;
#line 4110
  if (phba->params.ios_per_ctrl > arr_index) {
#line 4111
    *(phba->io_sgl_hndl_base + (unsigned long )arr_index) = psgl_handle;
#line 4112
    phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl + 1);
#line 4113
    arr_index = arr_index + 1U;
  } else {
#line 4115
    *(phba->eh_sgl_hndl_base + (unsigned long )(arr_index - phba->params.ios_per_ctrl)) = psgl_handle;
#line 4118
    arr_index = arr_index + 1U;
#line 4119
    phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl + 1);
  }
#line 4121
  psgl_handle = psgl_handle + 1;
#line 4109
  i = i + 1U;
  ldv_56015: ;
#line 4108
  if ((mem_descr_sglh->mem_array + (unsigned long )idx)->size / 32U > i) {
#line 4110
    goto ldv_56014;
  } else {

  }
#line 4123
  idx = idx + 1U;
  ldv_56018: ;
#line 4105
  if (mem_descr_sglh->num_elements > idx) {
#line 4107
    goto ldv_56017;
  } else {

  }
#line 4125
  log_value___2 = phba->attr_log_enable;
#line 4125
  if ((int )log_value___2 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4125
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : phba->io_sgl_hndl_avbl=%dphba->eh_sgl_hndl_avbl=%d\n",
               4129, (int )phba->io_sgl_hndl_avbl, (int )phba->eh_sgl_hndl_avbl);
  } else {

  }
#line 4131
  mem_descr_sg = phba->init_mem;
#line 4132
  mem_descr_sg = mem_descr_sg + 4UL;
#line 4133
  log_value___3 = phba->attr_log_enable;
#line 4133
  if ((int )log_value___3 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4133
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "\n BM_%d : mem_descr_sg->num_elements=%d\n",
               4135, mem_descr_sg->num_elements);
  } else {

  }
#line 4137
  ulp_num = 0U;
#line 4137
  goto ldv_56024;
  ldv_56023: 
#line 4138
  tmp___1 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4138
  if (tmp___1 != 0) {
#line 4139
    goto ldv_56022;
  } else {

  }
#line 4137
  ulp_num = ulp_num + 1U;
  ldv_56024: ;
#line 4137
  if (ulp_num <= 1U) {
#line 4139
    goto ldv_56023;
  } else {

  }
  ldv_56022: 
#line 4141
  ulp_icd_start = phba->fw_config.iscsi_icd_start[ulp_num];
#line 4143
  arr_index = 0U;
#line 4144
  idx = 0U;
#line 4145
  goto ldv_56029;
  ldv_56028: 
#line 4146
  pfrag = (struct iscsi_sge *)(mem_descr_sg->mem_array + (unsigned long )idx)->virtual_address;
#line 4148
  i = 0U;
#line 4148
  goto ldv_56026;
  ldv_56025: ;
#line 4152
  if (phba->params.ios_per_ctrl > arr_index) {
#line 4153
    psgl_handle = *(phba->io_sgl_hndl_base + (unsigned long )arr_index);
  } else {
#line 4155
    psgl_handle = *(phba->eh_sgl_hndl_base + (unsigned long )(arr_index - phba->params.ios_per_ctrl));
  }
#line 4157
  psgl_handle->pfrag = pfrag;
#line 4158
  tmp___2 = amap_mask(32U);
#line 4158
  amap_set((void *)pfrag, 0U, tmp___2, 0U, 0U);
#line 4159
  tmp___3 = amap_mask(32U);
#line 4159
  amap_set((void *)pfrag, 1U, tmp___3, 0U, 0U);
#line 4160
  pfrag = pfrag + (unsigned long )phba->params.num_sge_per_io;
#line 4161
  tmp___4 = arr_index;
#line 4161
  arr_index = arr_index + 1U;
#line 4161
  psgl_handle->sgl_index = tmp___4 + ulp_icd_start;
#line 4151
  i = i + 1U;
  ldv_56026: ;
#line 4148
  if ((unsigned long )i < (unsigned long )(mem_descr_sg->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.num_sge_per_io * 16UL)) {
#line 4152
    goto ldv_56025;
  } else {

  }
#line 4163
  idx = idx + 1U;
  ldv_56029: ;
#line 4145
  if (mem_descr_sg->num_elements > idx) {
#line 4147
    goto ldv_56028;
  } else {

  }
#line 4165
  phba->io_sgl_free_index = 0U;
#line 4166
  phba->io_sgl_alloc_index = 0U;
#line 4167
  phba->eh_sgl_free_index = 0U;
#line 4168
  phba->eh_sgl_alloc_index = 0U;
#line 4169
  return (0);
}
}
#line 4172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int hba_setup_cid_tbls(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint16_t i ;
  uint16_t ulp_num ;
  struct ulp_cid_info *ptr_cid_info ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  uint32_t log_value___1 ;
  void *tmp___3 ;
  uint32_t log_value___2 ;
  unsigned short tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 4176
  ptr_cid_info = (struct ulp_cid_info *)0;
#line 4178
  ulp_num = 0U;
#line 4178
  goto ldv_56042;
  ldv_56041: 
#line 4179
  tmp___1 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4179
  if (tmp___1 != 0) {
#line 4180
    tmp = kzalloc(16UL, 208U);
#line 4180
    ptr_cid_info = (struct ulp_cid_info *)tmp;
#line 4183
    if ((unsigned long )ptr_cid_info == (unsigned long )((struct ulp_cid_info *)0)) {
#line 4184
      log_value = phba->attr_log_enable;
#line 4184
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4184
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Failed to allocate memoryfor ULP_CID_INFO for ULP : %d\n",
                   4187, (int )ulp_num);
      } else {

      }
#line 4188
      ret = -12;
#line 4189
      goto free_memory;
    } else {

    }
#line 4194
    tmp___0 = kzalloc((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL,
                      208U);
#line 4194
    ptr_cid_info->cid_array = (unsigned short *)tmp___0;
#line 4197
    if ((unsigned long )ptr_cid_info->cid_array == (unsigned long )((unsigned short *)0U)) {
#line 4198
      log_value___0 = phba->attr_log_enable;
#line 4198
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4198
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Failed to allocate memoryfor CID_ARRAY for ULP : %d\n",
                   4201, (int )ulp_num);
      } else {

      }
#line 4202
      kfree((void const   *)ptr_cid_info);
#line 4203
      ptr_cid_info = (struct ulp_cid_info *)0;
#line 4204
      ret = -12;
#line 4206
      goto free_memory;
    } else {

    }
#line 4208
    ptr_cid_info->avlbl_cids = (unsigned short )phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 4212
    phba->cid_array_info[(int )ulp_num] = ptr_cid_info;
  } else {

  }
#line 4178
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_56042: ;
#line 4178
  if ((unsigned int )ulp_num <= 1U) {
#line 4180
    goto ldv_56041;
  } else {

  }
#line 4215
  tmp___2 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 8UL, 208U);
#line 4215
  phba->ep_array = (struct iscsi_endpoint **)tmp___2;
#line 4217
  if ((unsigned long )phba->ep_array == (unsigned long )((struct iscsi_endpoint **)0)) {
#line 4218
    log_value___1 = phba->attr_log_enable;
#line 4218
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4218
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory in hba_setup_cid_tbls\n",
                 4220);
    } else {

    }
#line 4221
    ret = -12;
#line 4223
    goto free_memory;
  } else {

  }
#line 4226
  tmp___3 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 8UL, 208U);
#line 4226
  phba->conn_table = (struct beiscsi_conn **)tmp___3;
#line 4228
  if ((unsigned long )phba->conn_table == (unsigned long )((struct beiscsi_conn **)0)) {
#line 4229
    log_value___2 = phba->attr_log_enable;
#line 4229
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4229
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory inhba_setup_cid_tbls\n",
                 4231);
    } else {

    }
#line 4233
    kfree((void const   *)phba->ep_array);
#line 4234
    phba->ep_array = (struct iscsi_endpoint **)0;
#line 4235
    ret = -12;
#line 4237
    goto free_memory;
  } else {

  }
#line 4240
  i = 0U;
#line 4240
  goto ldv_56047;
  ldv_56046: 
#line 4241
  ulp_num = (uint16_t )((phba->phwi_ctrlr)->wrb_context + (unsigned long )i)->ulp_num;
#line 4243
  ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4244
  tmp___4 = ptr_cid_info->cid_alloc;
#line 4244
  ptr_cid_info->cid_alloc = (unsigned short )((int )ptr_cid_info->cid_alloc + 1);
#line 4244
  *(ptr_cid_info->cid_array + (unsigned long )tmp___4) = ((phba->phwi_ctrlr)->wrb_context + (unsigned long )i)->cid;
#line 4240
  i = (uint16_t )((int )i + 1);
  ldv_56047: ;
#line 4240
  if ((unsigned int )i < phba->params.cxns_per_ctrl) {
#line 4242
    goto ldv_56046;
  } else {

  }
#line 4249
  ulp_num = 0U;
#line 4249
  goto ldv_56050;
  ldv_56049: 
#line 4250
  tmp___5 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4250
  if (tmp___5 != 0) {
#line 4251
    ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4253
    ptr_cid_info->cid_alloc = 0U;
#line 4254
    ptr_cid_info->cid_free = 0U;
  } else {

  }
#line 4249
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_56050: ;
#line 4249
  if ((unsigned int )ulp_num <= 1U) {
#line 4251
    goto ldv_56049;
  } else {

  }

#line 4257
  return (0);
  free_memory: 
#line 4260
  ulp_num = 0U;
#line 4260
  goto ldv_56053;
  ldv_56052: 
#line 4261
  tmp___6 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4261
  if (tmp___6 != 0) {
#line 4262
    ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4264
    if ((unsigned long )ptr_cid_info != (unsigned long )((struct ulp_cid_info *)0)) {
#line 4265
      kfree((void const   *)ptr_cid_info->cid_array);
#line 4266
      kfree((void const   *)ptr_cid_info);
#line 4267
      phba->cid_array_info[(int )ulp_num] = (struct ulp_cid_info *)0;
    } else {

    }
  } else {

  }
#line 4260
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_56053: ;
#line 4260
  if ((unsigned int )ulp_num <= 1U) {
#line 4262
    goto ldv_56052;
  } else {

  }

#line 4272
  return (ret);
}
}
#line 4275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_enable_intr(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_queue_info *eq ;
  u8 *addr ;
  u32 reg ;
  u32 i ;
  u32 enabled ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 4277
  ctrl = & phba->ctrl;
#line 4285
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4286
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 4288
  addr = ctrl->pcicfg + 252UL;
#line 4290
  reg = ioread32((void *)addr);
#line 4292
  enabled = reg & 536870912U;
#line 4293
  if (enabled == 0U) {
#line 4294
    reg = reg | 536870912U;
#line 4295
    log_value = phba->attr_log_enable;
#line 4295
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4295
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : reg =x%08x addr=%p\n", 4296, reg, addr);
    } else {

    }
#line 4297
    iowrite32(reg, (void *)addr);
  } else {

  }
#line 4300
  if (! phba->msix_enabled) {
#line 4301
    eq = & phwi_context->be_eq[0].q;
#line 4302
    log_value___0 = phba->attr_log_enable;
#line 4302
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4302
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : eq->id=%d\n", 4303, (int )eq->id);
    } else {

    }
#line 4305
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, 0U, 1, 1);
  } else {
#line 4307
    i = 0U;
#line 4307
    goto ldv_56070;
    ldv_56069: 
#line 4308
    eq = & phwi_context->be_eq[i].q;
#line 4309
    log_value___1 = phba->attr_log_enable;
#line 4309
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 4309
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : eq->id=%d\n", 4310, (int )eq->id);
    } else {

    }
#line 4311
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, 0U, 1, 1);
#line 4307
    i = i + 1U;
    ldv_56070: ;
#line 4307
    if (phba->num_cpus >= i) {
#line 4309
      goto ldv_56069;
    } else {

    }

  }
#line 4315
  return;
}
}
#line 4316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_disable_intr(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  u8 *addr ;
  u32 reg ;
  unsigned int tmp ;
  u32 enabled ;
  uint32_t log_value ;

  {
#line 4318
  ctrl = & phba->ctrl;
#line 4320
  addr = ctrl->pcicfg + 252UL;
#line 4321
  tmp = ioread32((void *)addr);
#line 4321
  reg = tmp;
#line 4323
  enabled = reg & 536870912U;
#line 4324
  if (enabled != 0U) {
#line 4325
    reg = reg & 3758096383U;
#line 4326
    iowrite32(reg, (void *)addr);
  } else {
#line 4328
    log_value = phba->attr_log_enable;
#line 4328
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 4328
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In hwi_disable_intr, Already Disabled\n",
                 4329);
    } else {

    }
  }
#line 4330
  return;
}
}
#line 4342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_get_boot_info(struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_session_resp *session_resp ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int tag ;
  unsigned int s_handle ;
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 4348
  ret = -12;
#line 4351
  ret = be_mgmt_get_boot_shandle(phba, & s_handle);
#line 4352
  if (ret != 0) {
#line 4353
    log_value = phba->attr_log_enable;
#line 4353
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4353
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : No boot session\n",
                 4355);
    } else {

    }
#line 4357
    if (ret == -6) {
#line 4358
      phba->get_boot = 0;
    } else {

    }
#line 4361
    return (ret);
  } else {

  }
#line 4363
  phba->get_boot = 0;
#line 4364
  nonemb_cmd.va = pci_zalloc_consistent(phba->ctrl.pdev, 1180UL, & nonemb_cmd.dma);
#line 4367
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 4368
    log_value___0 = phba->attr_log_enable;
#line 4368
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4368
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory forbeiscsi_get_session_info\n",
                 4371);
    } else {

    }
#line 4373
    return (-12);
  } else {

  }
#line 4376
  tag = mgmt_get_session_info(phba, s_handle, & nonemb_cmd);
#line 4378
  if (tag == 0U) {
#line 4379
    log_value___1 = phba->attr_log_enable;
#line 4379
    if ((log_value___1 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4379
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_get_session_info Failed\n",
                 4382);
    } else {

    }
#line 4384
    goto boot_freemem;
  } else {

  }
#line 4387
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
#line 4388
  if (ret != 0) {
#line 4389
    log_value___2 = phba->attr_log_enable;
#line 4389
    if ((log_value___2 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4389
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_get_session_info Failed",
                 4391);
    } else {

    }
#line 4393
    if (ret != -16) {
#line 4394
      goto boot_freemem;
    } else {
#line 4396
      return (ret);
    }
  } else {

  }
#line 4399
  session_resp = (struct be_cmd_get_session_resp *)nonemb_cmd.va;
#line 4401
  memcpy((void *)(& phba->boot_sess), (void const   *)(& session_resp->session_info),
           1164UL);
#line 4404
  beiscsi_logout_fw_sess(phba, phba->boot_sess.session_handle);
#line 4406
  ret = 0;
  boot_freemem: 
#line 4409
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
#line 4411
  return (ret);
}
}
#line 4414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_boot_release(void *data ) 
{ 
  struct beiscsi_hba *phba ;

  {
#line 4416
  phba = (struct beiscsi_hba *)data;
#line 4418
  scsi_host_put(phba->shost);
#line 4419
  return;
}
}
#line 4421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_setup_boot_info(struct beiscsi_hba *phba ) 
{ 
  struct iscsi_boot_kobj *boot_kobj ;
  int tmp ;
  struct Scsi_Host *tmp___0 ;
  struct Scsi_Host *tmp___1 ;
  struct Scsi_Host *tmp___2 ;

  {
#line 4426
  if ((unsigned long )phba->boot_kset != (unsigned long )((struct iscsi_boot_kset *)0)) {
#line 4427
    return (0);
  } else {

  }
#line 4430
  tmp = beiscsi_get_boot_info(phba);
#line 4430
  if (tmp != 0) {
#line 4432
    return (0);
  } else {

  }
#line 4434
  phba->boot_kset = iscsi_boot_create_host_kset((phba->shost)->host_no);
#line 4435
  if ((unsigned long )phba->boot_kset == (unsigned long )((struct iscsi_boot_kset *)0)) {
#line 4436
    return (-12);
  } else {

  }
#line 4439
  tmp___0 = scsi_host_get(phba->shost);
#line 4439
  if ((unsigned long )tmp___0 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4440
    goto free_kset;
  } else {

  }
#line 4441
  boot_kobj = iscsi_boot_create_target(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_tgt_info,
                                       & beiscsi_tgt_get_attr_visibility, & beiscsi_boot_release);
#line 4445
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4446
    goto put_shost;
  } else {

  }
#line 4448
  tmp___1 = scsi_host_get(phba->shost);
#line 4448
  if ((unsigned long )tmp___1 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4449
    goto free_kset;
  } else {

  }
#line 4450
  boot_kobj = iscsi_boot_create_initiator(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_ini_info,
                                          & beiscsi_ini_get_attr_visibility, & beiscsi_boot_release);
#line 4454
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4455
    goto put_shost;
  } else {

  }
#line 4457
  tmp___2 = scsi_host_get(phba->shost);
#line 4457
  if ((unsigned long )tmp___2 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4458
    goto free_kset;
  } else {

  }
#line 4459
  boot_kobj = iscsi_boot_create_ethernet(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_eth_info,
                                         & beiscsi_eth_get_attr_visibility, & beiscsi_boot_release);
#line 4463
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4464
    goto put_shost;
  } else {

  }
#line 4465
  return (0);
  put_shost: 
#line 4468
  scsi_host_put(phba->shost);
  free_kset: 
#line 4470
  iscsi_boot_destroy_kset(phba->boot_kset);
#line 4471
  return (-12);
}
}
#line 4474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_port(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  int tmp ;

  {
#line 4478
  ret = beiscsi_init_controller(phba);
#line 4479
  if (ret < 0) {
#line 4480
    log_value = phba->attr_log_enable;
#line 4480
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4480
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe - Failed inbeiscsi_init_controller\n",
                 4482);
    } else {

    }
#line 4483
    return (ret);
  } else {

  }
#line 4485
  ret = beiscsi_init_sgl_handle(phba);
#line 4486
  if (ret < 0) {
#line 4487
    log_value___0 = phba->attr_log_enable;
#line 4487
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4487
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe - Failed inbeiscsi_init_sgl_handle\n",
                 4489);
    } else {

    }
#line 4490
    goto do_cleanup_ctrlr;
  } else {

  }
#line 4493
  tmp = hba_setup_cid_tbls(phba);
#line 4493
  if (tmp != 0) {
#line 4494
    log_value___1 = phba->attr_log_enable;
#line 4494
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4494
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed in hba_setup_cid_tbls\n",
                 4495);
    } else {

    }
#line 4496
    kfree((void const   *)phba->io_sgl_hndl_base);
#line 4497
    kfree((void const   *)phba->eh_sgl_hndl_base);
#line 4498
    goto do_cleanup_ctrlr;
  } else {

  }
#line 4501
  return (ret);
  do_cleanup_ctrlr: 
#line 4504
  hwi_cleanup(phba);
#line 4505
  return (ret);
}
}
#line 4508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void hwi_purge_eq(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_queue_info *eq ;
  struct be_eq_entry *eqe ;
  int i ;
  int eq_msix ;
  unsigned int num_processed ;
  void *tmp ;
  u32 tmp___0 ;
  void *tmp___1 ;

  {
#line 4513
  eqe = (struct be_eq_entry *)0;
#line 4517
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4518
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 4519
  if ((int )phba->msix_enabled) {
#line 4520
    eq_msix = 1;
  } else {
#line 4522
    eq_msix = 0;
  }
#line 4524
  i = 0;
#line 4524
  goto ldv_56125;
  ldv_56124: 
#line 4525
  eq = & phwi_context->be_eq[i].q;
#line 4526
  tmp = queue_tail_node(eq);
#line 4526
  eqe = (struct be_eq_entry *)tmp;
#line 4527
  num_processed = 0U;
#line 4528
  goto ldv_56122;
  ldv_56121: 
#line 4530
  tmp___0 = amap_mask(1U);
#line 4530
  amap_set((void *)eqe, 0U, tmp___0, 0U, 0U);
#line 4531
  queue_tail_inc(eq);
#line 4532
  tmp___1 = queue_tail_node(eq);
#line 4532
  eqe = (struct be_eq_entry *)tmp___1;
#line 4533
  num_processed = num_processed + 1U;
  ldv_56122: ;
#line 4528
  if ((int )eqe->dw[0UL] & 1) {
#line 4530
    goto ldv_56121;
  } else {

  }

#line 4536
  if (num_processed != 0U) {
#line 4537
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_processed, 1, 1);
  } else {

  }
#line 4524
  i = i + 1;
  ldv_56125: ;
#line 4524
  if ((unsigned int )i < phba->num_cpus + (unsigned int )eq_msix) {
#line 4526
    goto ldv_56124;
  } else {

  }

#line 4531
  return;
}
}
#line 4541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_clean_port(struct beiscsi_hba *phba ) 
{ 
  int mgmt_status ;
  int ulp_num ;
  struct ulp_cid_info *ptr_cid_info ;
  uint32_t log_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 4544
  ptr_cid_info = (struct ulp_cid_info *)0;
#line 4546
  ulp_num = 0;
#line 4546
  goto ldv_56135;
  ldv_56134: 
#line 4547
  tmp = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4547
  if (tmp != 0) {
#line 4548
    mgmt_status = mgmt_epfw_cleanup(phba, (int )((unsigned short )ulp_num));
#line 4549
    if (mgmt_status != 0) {
#line 4550
      log_value = phba->attr_log_enable;
#line 4550
      if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 4550
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : mgmt_epfw_cleanup FAILED for ULP_%d\n", 4553, ulp_num);
      } else {

      }
    } else {

    }
  } else {

  }
#line 4546
  ulp_num = ulp_num + 1;
  ldv_56135: ;
#line 4546
  if (ulp_num <= 1) {
#line 4548
    goto ldv_56134;
  } else {

  }
#line 4557
  hwi_purge_eq(phba);
#line 4558
  hwi_cleanup(phba);
#line 4559
  kfree((void const   *)phba->io_sgl_hndl_base);
#line 4560
  kfree((void const   *)phba->eh_sgl_hndl_base);
#line 4561
  kfree((void const   *)phba->ep_array);
#line 4562
  kfree((void const   *)phba->conn_table);
#line 4564
  ulp_num = 0;
#line 4564
  goto ldv_56138;
  ldv_56137: 
#line 4565
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 4565
  if (tmp___0 != 0) {
#line 4566
    ptr_cid_info = phba->cid_array_info[ulp_num];
#line 4568
    if ((unsigned long )ptr_cid_info != (unsigned long )((struct ulp_cid_info *)0)) {
#line 4569
      kfree((void const   *)ptr_cid_info->cid_array);
#line 4570
      kfree((void const   *)ptr_cid_info);
#line 4571
      phba->cid_array_info[ulp_num] = (struct ulp_cid_info *)0;
    } else {

    }
  } else {

  }
#line 4564
  ulp_num = ulp_num + 1;
  ldv_56138: ;
#line 4564
  if (ulp_num <= 1) {
#line 4566
    goto ldv_56137;
  } else {

  }

#line 4571
  return;
}
}
#line 4586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct beiscsi_hba *phba ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  uint16_t cri_index ;

  {
#line 4590
  phba = beiscsi_conn->phba;
#line 4593
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4596
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4597
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4599
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4601
  if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
#line 4602
    memset((void *)(io_task->pwrb_handle)->pwrb, 0, 64UL);
#line 4604
    free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
#line 4606
    io_task->pwrb_handle = (struct wrb_handle *)0;
  } else {

  }
#line 4609
  if ((unsigned long )io_task->psgl_handle != (unsigned long )((struct sgl_handle *)0)) {
#line 4610
    spin_lock_bh(& phba->mgmt_sgl_lock);
#line 4611
    free_mgmt_sgl_handle(phba, io_task->psgl_handle);
#line 4613
    io_task->psgl_handle = (struct sgl_handle *)0;
#line 4614
    spin_unlock_bh(& phba->mgmt_sgl_lock);
  } else {

  }
#line 4617
  if (io_task->mtask_addr != 0ULL) {
#line 4618
    pci_unmap_single(phba->pcidev, io_task->mtask_addr, (size_t )io_task->mtask_data_count,
                     1);
#line 4622
    io_task->mtask_addr = 0ULL;
  } else {

  }
#line 4624
  return;
}
}
#line 4631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_cleanup_task(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct beiscsi_session *beiscsi_sess ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  uint16_t cri_index ;

  {
#line 4633
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4634
  conn = task->conn;
#line 4635
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4636
  phba = beiscsi_conn->phba;
#line 4637
  beiscsi_sess = beiscsi_conn->beiscsi_sess;
#line 4640
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4643
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4644
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4646
  if ((unsigned long )io_task->cmd_bhs != (unsigned long )((struct be_cmd_bhs *)0)) {
#line 4647
    dma_pool_free(beiscsi_sess->bhs_pool, (void *)io_task->cmd_bhs, io_task->bhs_pa.u.a64.address);
#line 4649
    io_task->cmd_bhs = (struct be_cmd_bhs *)0;
  } else {

  }
#line 4652
  if ((unsigned long )task->sc != (unsigned long )((struct scsi_cmnd *)0)) {
#line 4653
    if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
#line 4654
      free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
#line 4656
      io_task->pwrb_handle = (struct wrb_handle *)0;
    } else {

    }
#line 4659
    if ((unsigned long )io_task->psgl_handle != (unsigned long )((struct sgl_handle *)0)) {
#line 4660
      spin_lock(& phba->io_sgl_lock);
#line 4661
      free_io_sgl_handle(phba, io_task->psgl_handle);
#line 4662
      spin_unlock(& phba->io_sgl_lock);
#line 4663
      io_task->psgl_handle = (struct sgl_handle *)0;
    } else {

    }
#line 4666
    if ((unsigned long )io_task->scsi_cmnd != (unsigned long )((struct scsi_cmnd *)0)) {
#line 4667
      scsi_dma_unmap(io_task->scsi_cmnd);
#line 4668
      io_task->scsi_cmnd = (struct scsi_cmnd *)0;
    } else {

    }
  } else
#line 4671
  if ((unsigned int )beiscsi_conn->login_in_progress == 0U) {
#line 4672
    beiscsi_free_mgmt_task_handles(beiscsi_conn, task);
  } else {

  }
#line 4673
  return;
}
}
#line 4677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) 
{ 
  struct wrb_handle *pwrb_handle ;
  struct beiscsi_hba *phba ;
  struct iscsi_task *task ;
  struct iscsi_session *session ;
  u32 doorbell ;

  {
#line 4681
  phba = beiscsi_conn->phba;
#line 4682
  task = beiscsi_conn->task;
#line 4683
  session = (task->conn)->session;
#line 4684
  doorbell = 0U;
#line 4690
  beiscsi_conn->login_in_progress = 0U;
#line 4691
  spin_lock_bh(& session->back_lock);
#line 4692
  beiscsi_cleanup_task(task);
#line 4693
  spin_unlock_bh(& session->back_lock);
#line 4695
  pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
#line 4698
  if (phba->generation == 3U || phba->generation == 2U) {
#line 4699
    beiscsi_offload_cxn_v0(params, pwrb_handle, phba->init_mem);
  } else {
#line 4702
    beiscsi_offload_cxn_v2(params, pwrb_handle);
  }
#line 4704
  swap_dws((void *)pwrb_handle->pwrb, 64);
#line 4707
  doorbell = (beiscsi_conn->beiscsi_conn_cid & 65535U) | doorbell;
#line 4708
  doorbell = (u32 )(((int )pwrb_handle->wrb_index & 255) << 16) | doorbell;
#line 4710
  doorbell = doorbell | 16777216U;
#line 4711
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
#line 4713
  return;
}
}
#line 4715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_parse_pdu(struct iscsi_conn *conn , itt_t itt , int *index , int *age ) 
{ 


  {
#line 4718
  *index = (int )itt;
#line 4719
  if ((unsigned long )age != (unsigned long )((int *)0)) {
#line 4720
    *age = (conn->session)->age;
  } else {

  }
#line 4721
  return;
}
}
#line 4733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_alloc_pdu(struct iscsi_task *task , uint8_t opcode ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  itt_t itt ;
  uint16_t cri_index ;
  struct beiscsi_session *beiscsi_sess ;
  dma_addr_t paddr ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  __u32 tmp___0 ;

  {
#line 4735
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4736
  conn = task->conn;
#line 4737
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4738
  phba = beiscsi_conn->phba;
#line 4742
  cri_index = 0U;
#line 4743
  beiscsi_sess = beiscsi_conn->beiscsi_sess;
#line 4746
  tmp = dma_pool_alloc(beiscsi_sess->bhs_pool, 32U, & paddr);
#line 4746
  io_task->cmd_bhs = (struct be_cmd_bhs *)tmp;
#line 4748
  if ((unsigned long )io_task->cmd_bhs == (unsigned long )((struct be_cmd_bhs *)0)) {
#line 4749
    return (-12);
  } else {

  }
#line 4750
  io_task->bhs_pa.u.a64.address = paddr;
#line 4751
  io_task->libiscsi_itt = (unsigned int )task->itt;
#line 4752
  io_task->conn = beiscsi_conn;
#line 4754
  task->hdr = (struct iscsi_hdr *)(& (io_task->cmd_bhs)->iscsi_hdr);
#line 4755
  task->hdr_max = 324U;
#line 4756
  io_task->psgl_handle = (struct sgl_handle *)0;
#line 4757
  io_task->pwrb_handle = (struct wrb_handle *)0;
#line 4759
  if ((unsigned long )task->sc != (unsigned long )((struct scsi_cmnd *)0)) {
#line 4760
    spin_lock(& phba->io_sgl_lock);
#line 4761
    io_task->psgl_handle = alloc_io_sgl_handle(phba);
#line 4762
    spin_unlock(& phba->io_sgl_lock);
#line 4763
    if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4764
      log_value = phba->attr_log_enable;
#line 4764
      if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4764
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Alloc of IO_SGL_ICD Failedfor the CID : %d\n", 4768, beiscsi_conn->beiscsi_conn_cid);
      } else {

      }
#line 4769
      goto free_hndls;
    } else {

    }
#line 4771
    io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
#line 4773
    if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4774
      log_value___0 = phba->attr_log_enable;
#line 4774
      if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4774
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4778, beiscsi_conn->beiscsi_conn_cid);
      } else {

      }
#line 4779
      goto free_io_hndls;
    } else {

    }
  } else {
#line 4782
    io_task->scsi_cmnd = (struct scsi_cmnd *)0;
#line 4783
    if (((int )opcode & 63) == 3) {
#line 4784
      beiscsi_conn->task = task;
#line 4785
      if ((unsigned int )beiscsi_conn->login_in_progress == 0U) {
#line 4786
        spin_lock(& phba->mgmt_sgl_lock);
#line 4787
        io_task->psgl_handle = alloc_mgmt_sgl_handle(phba);
#line 4789
        spin_unlock(& phba->mgmt_sgl_lock);
#line 4790
        if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4791
          log_value___1 = phba->attr_log_enable;
#line 4791
          if ((log_value___1 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4791
            dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                       "BM_%d : Alloc of MGMT_SGL_ICD Failedfor the CID : %d\n", 4797,
                       beiscsi_conn->beiscsi_conn_cid);
          } else {

          }
#line 4798
          goto free_hndls;
        } else {

        }
#line 4801
        beiscsi_conn->login_in_progress = 1U;
#line 4802
        beiscsi_conn->plogin_sgl_handle = io_task->psgl_handle;
#line 4804
        io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
#line 4807
        if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4808
          log_value___2 = phba->attr_log_enable;
#line 4808
          if ((log_value___2 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4808
            dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                       "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4814,
                       beiscsi_conn->beiscsi_conn_cid);
          } else {

          }
#line 4815
          goto free_mgmt_hndls;
        } else {

        }
#line 4817
        beiscsi_conn->plogin_wrb_handle = io_task->pwrb_handle;
      } else {
#line 4821
        io_task->psgl_handle = beiscsi_conn->plogin_sgl_handle;
#line 4823
        io_task->pwrb_handle = beiscsi_conn->plogin_wrb_handle;
      }
    } else {
#line 4827
      spin_lock(& phba->mgmt_sgl_lock);
#line 4828
      io_task->psgl_handle = alloc_mgmt_sgl_handle(phba);
#line 4829
      spin_unlock(& phba->mgmt_sgl_lock);
#line 4830
      if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4831
        log_value___3 = phba->attr_log_enable;
#line 4831
        if ((log_value___3 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4831
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BM_%d : Alloc of MGMT_SGL_ICD Failedfor the CID : %d\n", 4837,
                     beiscsi_conn->beiscsi_conn_cid);
        } else {

        }
#line 4838
        goto free_hndls;
      } else {

      }
#line 4840
      io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
#line 4843
      if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4844
        log_value___4 = phba->attr_log_enable;
#line 4844
        if ((log_value___4 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 4844
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4848,
                     beiscsi_conn->beiscsi_conn_cid);
        } else {

        }
#line 4849
        goto free_mgmt_hndls;
      } else {

      }
    }
  }
#line 4854
  tmp___0 = __fswab32(((unsigned int )(io_task->pwrb_handle)->wrb_index << 16) | (io_task->psgl_handle)->sgl_index);
#line 4854
  itt = tmp___0;
#line 4857
  (io_task->pwrb_handle)->pio_handle = task;
#line 4859
  (io_task->cmd_bhs)->iscsi_hdr.itt = itt;
#line 4860
  return (0);
  free_io_hndls: 
#line 4863
  spin_lock(& phba->io_sgl_lock);
#line 4864
  free_io_sgl_handle(phba, io_task->psgl_handle);
#line 4865
  spin_unlock(& phba->io_sgl_lock);
#line 4866
  goto free_hndls;
  free_mgmt_hndls: 
#line 4868
  spin_lock(& phba->mgmt_sgl_lock);
#line 4869
  free_mgmt_sgl_handle(phba, io_task->psgl_handle);
#line 4870
  io_task->psgl_handle = (struct sgl_handle *)0;
#line 4871
  spin_unlock(& phba->mgmt_sgl_lock);
  free_hndls: 
#line 4873
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4874
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4876
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4877
  if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
#line 4878
    free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
  } else {

  }
#line 4879
  io_task->pwrb_handle = (struct wrb_handle *)0;
#line 4880
  dma_pool_free(beiscsi_sess->bhs_pool, (void *)io_task->cmd_bhs, io_task->bhs_pa.u.a64.address);
#line 4882
  io_task->cmd_bhs = (struct be_cmd_bhs *)0;
#line 4883
  return (-12);
}
}
#line 4885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_iotask_v2(struct iscsi_task *task , struct scatterlist *sg , unsigned int num_sg ,
                      unsigned int xferlen , unsigned int writedir ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u16 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  __u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;

  {
#line 4890
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4891
  conn = task->conn;
#line 4892
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4893
  phba = beiscsi_conn->phba;
#line 4894
  pwrb = (struct iscsi_wrb *)0;
#line 4895
  doorbell = 0U;
#line 4897
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 4899
  (io_task->cmd_bhs)->iscsi_hdr.exp_statsn = 0U;
#line 4900
  io_task->bhs_len = 324U;
#line 4902
  if (writedir != 0U) {
#line 4903
    tmp = amap_mask(5U);
#line 4903
    amap_set((void *)pwrb, 0U, tmp, 27U, 1U);
#line 4905
    tmp___0 = amap_mask(1U);
#line 4905
    amap_set((void *)pwrb, 11U, tmp___0, 28U, 1U);
  } else {
#line 4907
    tmp___1 = amap_mask(5U);
#line 4907
    amap_set((void *)pwrb, 0U, tmp___1, 27U, 5U);
#line 4909
    tmp___2 = amap_mask(1U);
#line 4909
    amap_set((void *)pwrb, 11U, tmp___2, 28U, 0U);
  }
#line 4912
  tmp___3 = amap_mask(5U);
#line 4912
  tmp___4 = amap_get((void *)pwrb, 0U, tmp___3, 27U);
#line 4912
  io_task->wrb_type = (uint8_t )tmp___4;
#line 4915
  tmp___5 = __fswab16((int )*((unsigned short *)(& (io_task->cmd_bhs)->iscsi_hdr.lun)));
#line 4915
  tmp___6 = amap_mask(16U);
#line 4915
  amap_set((void *)pwrb, 1U, tmp___6, 16U, (u32 )tmp___5);
#line 4918
  tmp___7 = amap_mask(25U);
#line 4918
  amap_set((void *)pwrb, 0U, tmp___7, 0U, xferlen);
#line 4919
  tmp___8 = amap_mask(8U);
#line 4919
  amap_set((void *)pwrb, 1U, tmp___8, 8U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4921
  tmp___9 = __fswab32(task->cmdsn);
#line 4921
  tmp___10 = amap_mask(32U);
#line 4921
  amap_set((void *)pwrb, 7U, tmp___10, 0U, tmp___9);
#line 4923
  tmp___11 = amap_mask(16U);
#line 4923
  amap_set((void *)pwrb, 2U, tmp___11, 0U, (io_task->psgl_handle)->sgl_index);
#line 4926
  hwi_write_sgl_v2(pwrb, sg, num_sg, io_task);
#line 4927
  tmp___12 = amap_mask(8U);
#line 4927
  amap_set((void *)pwrb, 1U, tmp___12, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 4930
  swap_dws((void *)pwrb, 64);
#line 4932
  doorbell = (beiscsi_conn->beiscsi_conn_cid & 65535U) | doorbell;
#line 4933
  doorbell = (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16) | doorbell;
#line 4936
  doorbell = doorbell | 16777216U;
#line 4937
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
#line 4939
  return (0);
}
}
#line 4942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_iotask(struct iscsi_task *task , struct scatterlist *sg , unsigned int num_sg ,
                          unsigned int xferlen , unsigned int writedir ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u16 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  __u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;

  {
#line 4947
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4948
  conn = task->conn;
#line 4949
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4950
  phba = beiscsi_conn->phba;
#line 4951
  pwrb = (struct iscsi_wrb *)0;
#line 4952
  doorbell = 0U;
#line 4954
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 4955
  (io_task->cmd_bhs)->iscsi_hdr.exp_statsn = 0U;
#line 4956
  io_task->bhs_len = 324U;
#line 4958
  if (writedir != 0U) {
#line 4959
    tmp = amap_mask(4U);
#line 4959
    amap_set((void *)pwrb, 0U, tmp, 28U, 1U);
#line 4961
    tmp___0 = amap_mask(1U);
#line 4961
    amap_set((void *)pwrb, 0U, tmp___0, 24U, 1U);
  } else {
#line 4963
    tmp___1 = amap_mask(4U);
#line 4963
    amap_set((void *)pwrb, 0U, tmp___1, 28U, 5U);
#line 4965
    tmp___2 = amap_mask(1U);
#line 4965
    amap_set((void *)pwrb, 0U, tmp___2, 24U, 0U);
  }
#line 4968
  tmp___3 = amap_mask(4U);
#line 4968
  tmp___4 = amap_get((void *)pwrb, 0U, tmp___3, 28U);
#line 4968
  io_task->wrb_type = (uint8_t )tmp___4;
#line 4971
  tmp___5 = __fswab16((int )*((unsigned short *)(& (io_task->cmd_bhs)->iscsi_hdr.lun)));
#line 4971
  tmp___6 = amap_mask(14U);
#line 4971
  amap_set((void *)pwrb, 0U, tmp___6, 0U, (u32 )tmp___5);
#line 4974
  tmp___7 = amap_mask(24U);
#line 4974
  amap_set((void *)pwrb, 1U, tmp___7, 8U, xferlen);
#line 4975
  tmp___8 = amap_mask(8U);
#line 4975
  amap_set((void *)pwrb, 0U, tmp___8, 16U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4977
  tmp___9 = __fswab32(task->cmdsn);
#line 4977
  tmp___10 = amap_mask(32U);
#line 4977
  amap_set((void *)pwrb, 6U, tmp___10, 0U, tmp___9);
#line 4979
  tmp___11 = amap_mask(12U);
#line 4979
  amap_set((void *)pwrb, 2U, tmp___11, 0U, (io_task->psgl_handle)->sgl_index);
#line 4982
  hwi_write_sgl(pwrb, sg, num_sg, io_task);
#line 4984
  tmp___12 = amap_mask(8U);
#line 4984
  amap_set((void *)pwrb, 1U, tmp___12, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 4986
  swap_dws((void *)pwrb, 64);
#line 4988
  doorbell = (beiscsi_conn->beiscsi_conn_cid & 65535U) | doorbell;
#line 4989
  doorbell = (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16) | doorbell;
#line 4991
  doorbell = doorbell | 16777216U;
#line 4993
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
#line 4995
  return (0);
}
}
#line 4998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_mtask(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  unsigned int cid ;
  unsigned int pwrb_typeoffset ;
  __u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  uint32_t log_value ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;

  {
#line 5000
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 5001
  conn = task->conn;
#line 5002
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 5003
  phba = beiscsi_conn->phba;
#line 5004
  pwrb = (struct iscsi_wrb *)0;
#line 5005
  doorbell = 0U;
#line 5007
  pwrb_typeoffset = 0U;
#line 5009
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 5010
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 5011
  memset((void *)pwrb, 0, 64UL);
#line 5013
  if (phba->generation == 3U || phba->generation == 2U) {
#line 5014
    tmp = __fswab32(task->cmdsn);
#line 5014
    tmp___0 = amap_mask(32U);
#line 5014
    amap_set((void *)pwrb, 6U, tmp___0, 0U, tmp);
#line 5016
    tmp___1 = amap_mask(8U);
#line 5016
    amap_set((void *)pwrb, 0U, tmp___1, 16U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 5018
    tmp___2 = amap_mask(12U);
#line 5018
    amap_set((void *)pwrb, 2U, tmp___2, 0U, (io_task->psgl_handle)->sgl_index);
#line 5020
    tmp___3 = amap_mask(24U);
#line 5020
    amap_set((void *)pwrb, 1U, tmp___3, 8U, task->data_count);
#line 5022
    tmp___4 = amap_mask(8U);
#line 5022
    amap_set((void *)pwrb, 1U, tmp___4, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 5024
    pwrb_typeoffset = 28U;
  } else {
#line 5026
    tmp___5 = __fswab32(task->cmdsn);
#line 5026
    tmp___6 = amap_mask(32U);
#line 5026
    amap_set((void *)pwrb, 7U, tmp___6, 0U, tmp___5);
#line 5028
    tmp___7 = amap_mask(8U);
#line 5028
    amap_set((void *)pwrb, 1U, tmp___7, 8U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 5030
    tmp___8 = amap_mask(16U);
#line 5030
    amap_set((void *)pwrb, 2U, tmp___8, 0U, (io_task->psgl_handle)->sgl_index);
#line 5032
    tmp___9 = amap_mask(25U);
#line 5032
    amap_set((void *)pwrb, 0U, tmp___9, 0U, task->data_count);
#line 5034
    tmp___10 = amap_mask(8U);
#line 5034
    amap_set((void *)pwrb, 1U, tmp___10, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 5036
    pwrb_typeoffset = 27U;
  }
#line 5040
  switch ((int )(task->hdr)->opcode & 63) {
  case 3: 
#line 5042
  tmp___11 = amap_mask(32U);
#line 5042
  amap_set((void *)pwrb, 6U, tmp___11, 0U, 1U);
#line 5043
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5044
  hwi_write_buffer(pwrb, task);
#line 5045
  goto ldv_56236;
  case 0: ;
#line 5047
  if ((task->hdr)->ttt != 4294967295U) {
#line 5048
    pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5049
    if (phba->generation == 3U || phba->generation == 2U) {
#line 5050
      tmp___12 = amap_mask(1U);
#line 5050
      amap_set((void *)pwrb, 0U, tmp___12, 25U, 1U);
    } else {
#line 5053
      tmp___13 = amap_mask(1U);
#line 5053
      amap_set((void *)pwrb, 11U, tmp___13, 29U, 1U);
    }
  } else {
#line 5056
    pwrb->dw[0] = pwrb->dw[0] | (u32 )(5 << (int )pwrb_typeoffset);
#line 5057
    if (phba->generation == 3U || phba->generation == 2U) {
#line 5058
      tmp___14 = amap_mask(1U);
#line 5058
      amap_set((void *)pwrb, 0U, tmp___14, 25U, 0U);
    } else {
#line 5061
      tmp___15 = amap_mask(1U);
#line 5061
      amap_set((void *)pwrb, 11U, tmp___15, 29U, 0U);
    }
  }
#line 5064
  hwi_write_buffer(pwrb, task);
#line 5065
  goto ldv_56236;
  case 4: 
#line 5067
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5068
  hwi_write_buffer(pwrb, task);
#line 5069
  goto ldv_56236;
  case 2: 
#line 5071
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(2 << (int )pwrb_typeoffset);
#line 5072
  hwi_write_buffer(pwrb, task);
#line 5073
  goto ldv_56236;
  case 6: 
#line 5075
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(2 << (int )pwrb_typeoffset);
#line 5076
  hwi_write_buffer(pwrb, task);
#line 5077
  goto ldv_56236;
  default: 
#line 5080
  log_value = phba->attr_log_enable;
#line 5080
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5080
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : opcode =%d Not supported\n",
               5082, (int )(task->hdr)->opcode & 63);
  } else {

  }
#line 5084
  return (-22);
  }
  ldv_56236: ;
#line 5088
  if (phba->generation == 3U || phba->generation == 2U) {
#line 5088
    tmp___16 = amap_mask(4U);
#line 5088
    tmp___17 = amap_get((void *)pwrb, 0U, tmp___16, 28U);
#line 5088
    io_task->wrb_type = (uint8_t )tmp___17;
  } else {
#line 5088
    tmp___18 = amap_mask(5U);
#line 5088
    tmp___19 = amap_get((void *)pwrb, 0U, tmp___18, 27U);
#line 5088
    io_task->wrb_type = (uint8_t )tmp___19;
  }
#line 5092
  doorbell = (cid & 65535U) | doorbell;
#line 5093
  doorbell = (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16) | doorbell;
#line 5095
  doorbell = doorbell | 16777216U;
#line 5096
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
#line 5098
  return (0);
}
}
#line 5101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_task_xmit(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct scsi_cmnd *sc ;
  struct beiscsi_hba *phba ;
  struct scatterlist *sg ;
  int num_sg ;
  unsigned int writedir ;
  unsigned int xferlen ;
  int tmp ;
  struct iscsi_conn *conn ;
  struct beiscsi_hba *phba___0 ;
  uint32_t log_value ;
  unsigned int tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;

  {
#line 5103
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 5104
  sc = task->sc;
#line 5105
  phba = (struct beiscsi_hba *)0;
#line 5108
  writedir = 0U;
#line 5108
  xferlen = 0U;
#line 5110
  phba = ((struct beiscsi_conn *)(task->conn)->dd_data)->phba;
#line 5112
  if ((unsigned long )sc == (unsigned long )((struct scsi_cmnd *)0)) {
#line 5113
    tmp = beiscsi_mtask(task);
#line 5113
    return (tmp);
  } else {

  }
#line 5115
  io_task->scsi_cmnd = sc;
#line 5116
  num_sg = scsi_dma_map(sc);
#line 5117
  if (num_sg < 0) {
#line 5118
    conn = task->conn;
#line 5119
    phba___0 = (struct beiscsi_hba *)0;
#line 5121
    phba___0 = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 5122
    log_value = phba___0->attr_log_enable;
#line 5122
    if ((log_value & 80U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5122
      tmp___0 = scsi_bufflen(sc);
#line 5122
      tmp___1 = __fswab32((io_task->cmd_bhs)->iscsi_hdr.itt);
#line 5122
      dev_printk("\v", (struct device  const  *)(& (phba___0->shost)->shost_gendev),
                 "BM_%d : scsi_dma_map Failed Driver_ITT : 0x%x ITT : 0x%x Xferlen : 0x%x\n",
                 5127, tmp___1, io_task->libiscsi_itt, tmp___0);
    } else {

    }
#line 5129
    return (num_sg);
  } else {

  }
#line 5131
  xferlen = scsi_bufflen(sc);
#line 5132
  sg = scsi_sglist(sc);
#line 5133
  if ((unsigned int )sc->sc_data_direction == 1U) {
#line 5134
    writedir = 1U;
  } else {
#line 5136
    writedir = 0U;
  }
#line 5138
  tmp___2 = (*(phba->iotask_fn))(task, sg, (uint32_t )num_sg, xferlen, writedir);
#line 5138
  return (tmp___2);
}
}
#line 5145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_bsg_request(struct bsg_job *job ) 
{ 
  struct Scsi_Host *shost ;
  struct beiscsi_hba *phba ;
  struct iscsi_bsg_request *bsg_req ;
  int rc ;
  unsigned int tag ;
  struct be_dma_mem nonemb_cmd ;
  struct be_cmd_resp_hdr *resp ;
  struct iscsi_bsg_reply *bsg_reply ;
  unsigned short status ;
  unsigned short extd_status ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  long __ret ;
  unsigned long tmp___0 ;
  wait_queue_t __wait ;
  long __ret___0 ;
  unsigned long tmp___1 ;
  long __int ;
  long tmp___2 ;
  bool __cond ;
  bool __cond___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 5149
  bsg_req = (struct iscsi_bsg_request *)job->request;
#line 5150
  rc = -22;
#line 5154
  bsg_reply = (struct iscsi_bsg_reply *)job->reply;
#line 5157
  shost = dev_to_shost___0(job->dev);
#line 5158
  tmp = shost_priv(shost);
#line 5158
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 5160
  switch (bsg_req->msgcode) {
  case 2147483903U: 
#line 5162
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, (size_t )job->request_payload.payload_len,
                                       & nonemb_cmd.dma);
#line 5165
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 5166
    log_value = phba->attr_log_enable;
#line 5166
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5166
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory for beiscsi_bsg_request\n",
                 5168);
    } else {

    }
#line 5169
    return (-12);
  } else {

  }
#line 5171
  tag = mgmt_vendor_specific_fw_cmd(& phba->ctrl, phba, job, & nonemb_cmd);
#line 5173
  if (tag == 0U) {
#line 5174
    log_value___0 = phba->attr_log_enable;
#line 5174
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5174
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : MBX Tag Allocation Failed\n",
                 5175);
    } else {

    }
#line 5177
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 5179
    return (-11);
  } else {

  }
#line 5182
  tmp___0 = msecs_to_jiffies(110000U);
#line 5182
  __ret = (long )tmp___0;
#line 5182
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c",
                5186, 0);
#line 5182
  __cond___0 = phba->ctrl.mcc_numtag[tag] != 0U;
#line 5182
  if ((int )__cond___0 && __ret == 0L) {
#line 5182
    __ret = 1L;
  } else {

  }
#line 5182
  if (((int )__cond___0 || __ret == 0L) == 0) {
#line 5182
    tmp___1 = msecs_to_jiffies(110000U);
#line 5182
    __ret___0 = (long )tmp___1;
#line 5182
    INIT_LIST_HEAD(& __wait.task_list);
#line 5182
    __wait.flags = 0U;
    ldv_56282: 
#line 5182
    tmp___2 = prepare_to_wait_event((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                                    & __wait, 1);
#line 5182
    __int = tmp___2;
#line 5182
    __cond = phba->ctrl.mcc_numtag[tag] != 0U;
#line 5182
    if ((int )__cond && __ret___0 == 0L) {
#line 5182
      __ret___0 = 1L;
    } else {

    }
#line 5182
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 5182
      goto ldv_56281;
    } else {

    }
#line 5182
    if (__int != 0L) {
#line 5182
      __ret___0 = __int;
#line 5182
      goto ldv_56281;
    } else {

    }
#line 5182
    __ret___0 = schedule_timeout(__ret___0);
#line 5182
    goto ldv_56282;
    ldv_56281: 
#line 5182
    finish_wait((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                & __wait);
#line 5182
    __ret = __ret___0;
  } else {

  }
#line 5182
  rc = (int )__ret;
#line 5187
  extd_status = (unsigned short )((phba->ctrl.mcc_numtag[tag] & 65280U) >> 8);
#line 5188
  status = (unsigned int )((unsigned short )phba->ctrl.mcc_numtag[tag]) & 255U;
#line 5189
  free_mcc_tag(& phba->ctrl, tag);
#line 5190
  resp = (struct be_cmd_resp_hdr *)nonemb_cmd.va;
#line 5191
  sg_copy_from_buffer(job->reply_payload.sg_list, (unsigned int )job->reply_payload.sg_cnt,
                      (void const   *)nonemb_cmd.va, (unsigned long )resp->response_length + 16UL);
#line 5195
  bsg_reply->reply_payload_rcv_len = resp->response_length;
#line 5196
  bsg_reply->result = (uint32_t )status;
#line 5197
  bsg_job_done(job, (int )bsg_reply->result, bsg_reply->reply_payload_rcv_len);
#line 5199
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
#line 5201
  if ((unsigned int )status != 0U || (unsigned int )extd_status != 0U) {
#line 5202
    log_value___1 = phba->attr_log_enable;
#line 5202
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5202
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : MBX Cmd Failed status = %d extd_status = %d\n",
                 5205, (int )status, (int )extd_status);
    } else {

    }
#line 5207
    return (-5);
  } else {
#line 5209
    rc = 0;
  }
#line 5211
  goto ldv_56286;
  default: 
#line 5214
  log_value___2 = phba->attr_log_enable;
#line 5214
  if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5214
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unsupported bsg command: 0x%x\n",
               5216, bsg_req->msgcode);
  } else {

  }
#line 5217
  goto ldv_56286;
  }
  ldv_56286: ;
#line 5220
  return (rc);
}
}
#line 5223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_hba_attrs_init(struct beiscsi_hba *phba ) 
{ 


  {
#line 5226
  beiscsi_log_enable_init(phba, beiscsi_log_enable);
#line 5227
  return;
}
}
#line 5236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_quiesce(struct beiscsi_hba *phba , uint32_t unload_state ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_obj *pbe_eq ;
  unsigned int i ;
  unsigned int msix_vec ;

  {
#line 5244
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5245
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5246
  hwi_disable_intr(phba);
#line 5247
  if ((int )phba->msix_enabled) {
#line 5248
    i = 0U;
#line 5248
    goto ldv_56302;
    ldv_56301: 
#line 5249
    msix_vec = phba->msix_entries[i].vector;
#line 5250
    synchronize_irq(msix_vec);
#line 5251
    ldv_free_irq_28(msix_vec, (void *)(& phwi_context->be_eq) + (unsigned long )i);
#line 5252
    kfree((void const   *)phba->msi_name[i]);
#line 5248
    i = i + 1U;
    ldv_56302: ;
#line 5248
    if (phba->num_cpus >= i) {
#line 5250
      goto ldv_56301;
    } else {

    }

  } else
#line 5255
  if ((phba->pcidev)->irq != 0U) {
#line 5256
    synchronize_irq((phba->pcidev)->irq);
#line 5257
    ldv_free_irq_29((phba->pcidev)->irq, (void *)phba);
  } else {

  }
#line 5259
  pci_disable_msix(phba->pcidev);
#line 5260
  ldv_cancel_delayed_work_sync_30(& phba->beiscsi_hw_check_task);
#line 5262
  i = 0U;
#line 5262
  goto ldv_56305;
  ldv_56304: 
#line 5263
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5264
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 5262
  i = i + 1U;
  ldv_56305: ;
#line 5262
  if (phba->num_cpus > i) {
#line 5264
    goto ldv_56304;
  } else {

  }

#line 5267
  if (unload_state == 1U) {
#line 5268
    ldv_destroy_workqueue_31(phba->wq);
#line 5269
    beiscsi_clean_port(phba);
#line 5270
    beiscsi_free_mem(phba);
#line 5272
    beiscsi_unmap_pci_function(phba);
#line 5273
    pci_free_consistent(phba->pcidev, (size_t )phba->ctrl.mbox_mem_alloced.size, phba->ctrl.mbox_mem_alloced.va,
                        phba->ctrl.mbox_mem_alloced.dma);
  } else {
#line 5278
    hwi_purge_eq(phba);
#line 5279
    hwi_cleanup(phba);
  }
#line 5281
  return;
}
}
#line 5284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_remove(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;

  {
#line 5287
  phba = (struct beiscsi_hba *)0;
#line 5289
  tmp = pci_get_drvdata(pcidev);
#line 5289
  phba = (struct beiscsi_hba *)tmp;
#line 5290
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
#line 5291
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_remove called with no phba\n");
#line 5292
    return;
  } else {

  }
#line 5295
  beiscsi_destroy_def_ifaces(phba);
#line 5296
  beiscsi_quiesce(phba, 1U);
#line 5297
  iscsi_boot_destroy_kset(phba->boot_kset);
#line 5298
  iscsi_host_remove(phba->shost);
#line 5299
  pci_dev_put(phba->pcidev);
#line 5300
  iscsi_host_free(phba->shost);
#line 5301
  pci_disable_pcie_error_reporting(pcidev);
#line 5302
  pci_set_drvdata(pcidev, (void *)0);
#line 5303
  pci_release_regions(pcidev);
#line 5304
  pci_disable_device(pcidev);
#line 5305
  return;
}
}
#line 5307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_shutdown(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;

  {
#line 5310
  phba = (struct beiscsi_hba *)0;
#line 5312
  tmp = pci_get_drvdata(pcidev);
#line 5312
  phba = (struct beiscsi_hba *)tmp;
#line 5313
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
#line 5314
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_shutdown called with no phba\n");
#line 5315
    return;
  } else {

  }
#line 5318
  phba->state = 8U;
#line 5319
  iscsi_host_for_each_session(phba->shost, & be2iscsi_fail_session);
#line 5320
  beiscsi_quiesce(phba, 1U);
#line 5321
  pci_disable_device(pcidev);
#line 5322
  return;
}
}
#line 5324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_msix_enable(struct beiscsi_hba *phba ) 
{ 
  int i ;
  int status ;

  {
#line 5328
  i = 0;
#line 5328
  goto ldv_56321;
  ldv_56320: 
#line 5329
  phba->msix_entries[i].entry = (u16 )i;
#line 5328
  i = i + 1;
  ldv_56321: ;
#line 5328
  if ((unsigned int )i <= phba->num_cpus) {
#line 5330
    goto ldv_56320;
  } else {

  }
#line 5331
  status = pci_enable_msix_range(phba->pcidev, (struct msix_entry *)(& phba->msix_entries),
                                 (int )(phba->num_cpus + 1U), (int )(phba->num_cpus + 1U));
#line 5333
  if (status > 0) {
#line 5334
    phba->msix_enabled = 1;
  } else {

  }
#line 5336
  return;
}
}
#line 5339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_eqd_update(struct beiscsi_hba *phba ) 
{ 
  struct be_set_eqd set_eqd[64U] ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *pbe_eq ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  int eqd ;
  int i ;
  int num ;
  ulong now ;
  u32 pps ;
  u32 delta ;
  unsigned int tag ;
  u32 __min1 ;
  u32 __min2 ;
  u32 __max1 ;
  u32 __max2 ;
  int tmp ;

  {
#line 5346
  num = 0;
#line 5351
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5352
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5354
  i = 0;
#line 5354
  goto ldv_56352;
  ldv_56351: 
#line 5355
  aic = (struct be_aic_obj *)(& phba->aic_obj) + (unsigned long )i;
#line 5356
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5357
  now = jiffies;
#line 5358
  if ((aic->jiffs == 0UL || (long )(now - aic->jiffs) < 0L) || (u64 )pbe_eq->cq_count < aic->eq_prev) {
#line 5360
    aic->jiffs = now;
#line 5361
    aic->eq_prev = (u64 )pbe_eq->cq_count;
#line 5362
    goto ldv_56344;
  } else {

  }
#line 5364
  delta = jiffies_to_msecs(now - aic->jiffs);
#line 5365
  pps = ((pbe_eq->cq_count - (unsigned int )aic->eq_prev) * 1000U) / delta;
#line 5366
  eqd = (int )(pps / 1500U << 2);
#line 5368
  if (eqd <= 7) {
#line 5369
    eqd = 0;
  } else {

  }
#line 5370
  __min1 = (u32 )eqd;
#line 5370
  __min2 = (u32 )phwi_context->max_eqd;
#line 5370
  eqd = (int )(__min1 < __min2 ? __min1 : __min2);
#line 5371
  __max1 = (u32 )eqd;
#line 5371
  __max2 = (u32 )phwi_context->min_eqd;
#line 5371
  eqd = (int )(__max1 > __max2 ? __max1 : __max2);
#line 5373
  aic->jiffs = now;
#line 5374
  aic->eq_prev = (u64 )pbe_eq->cq_count;
#line 5376
  if ((u32 )eqd != aic->prev_eqd) {
#line 5377
    set_eqd[num].delay_multiplier = (u32 )((eqd * 65) / 100);
#line 5378
    set_eqd[num].eq_id = (u32 )pbe_eq->q.id;
#line 5379
    aic->prev_eqd = (u32 )eqd;
#line 5380
    num = num + 1;
  } else {

  }
  ldv_56344: 
#line 5354
  i = i + 1;
  ldv_56352: ;
#line 5354
  if ((unsigned int )i <= phba->num_cpus) {
#line 5356
    goto ldv_56351;
  } else {

  }

#line 5383
  if (num != 0) {
#line 5384
    tmp = be_cmd_modify_eq_delay(phba, (struct be_set_eqd *)(& set_eqd), num);
#line 5384
    tag = (unsigned int )tmp;
#line 5385
    if (tag != 0U) {
#line 5386
      beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
    } else {

    }
  } else {

  }
#line 5388
  return;
}
}
#line 5390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void be_check_boot_session(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;
  int tmp ;

  {
#line 5392
  tmp = beiscsi_setup_boot_info(phba);
#line 5392
  if (tmp != 0) {
#line 5393
    log_value = phba->attr_log_enable;
#line 5393
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5393
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Could not set up iSCSI boot info on async event.\n",
                 5395);
    } else {

    }
  } else {

  }
#line 5395
  return;
}
}
#line 5405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_hw_health_check(struct work_struct *work ) 
{ 
  struct beiscsi_hba *phba ;
  struct work_struct  const  *__mptr ;
  unsigned long tmp ;

  {
#line 5408
  __mptr = (struct work_struct  const  *)work;
#line 5408
  phba = (struct beiscsi_hba *)__mptr + 0xffffffffffffe8d8UL;
#line 5411
  be_eqd_update(phba);
#line 5413
  if ((phba->state & 16U) != 0U) {
#line 5414
    if (phba->get_boot > 0 && (unsigned long )phba->boot_kset == (unsigned long )((struct iscsi_boot_kset *)0)) {
#line 5415
      phba->get_boot = phba->get_boot - 1;
#line 5416
      if (phba->get_boot % 20 == 0) {
#line 5417
        be_check_boot_session(phba);
      } else {

      }
    } else {
#line 5419
      phba->state = phba->state & 4294967279U;
#line 5420
      phba->get_boot = 0;
    }
  } else {

  }
#line 5424
  beiscsi_ue_detect(phba);
#line 5426
  tmp = msecs_to_jiffies(1000U);
#line 5426
  schedule_delayed_work(& phba->beiscsi_hw_check_task, tmp);
#line 5428
  return;
}
}
#line 5431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static pci_ers_result_t beiscsi_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 5434
  phba = (struct beiscsi_hba *)0;
#line 5436
  tmp = pci_get_drvdata(pdev);
#line 5436
  phba = (struct beiscsi_hba *)tmp;
#line 5437
  phba->state = phba->state | 4U;
#line 5439
  log_value = phba->attr_log_enable;
#line 5439
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5439
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH error detected\n",
               5440);
  } else {

  }
#line 5442
  beiscsi_quiesce(phba, 2U);
#line 5444
  if (state == 3U) {
#line 5445
    log_value___0 = phba->attr_log_enable;
#line 5445
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5445
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH : State PERM Failure",
                 5446);
    } else {

    }
#line 5447
    return (4U);
  } else {

  }
#line 5450
  pci_disable_device(pdev);
#line 5458
  if (pdev->devfn == 0U) {
#line 5459
    ssleep(30U);
  } else {

  }
#line 5461
  return (3U);
}
}
#line 5464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static pci_ers_result_t beiscsi_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct beiscsi_hba *phba ;
  int status ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 5466
  phba = (struct beiscsi_hba *)0;
#line 5467
  status = 0;
#line 5469
  tmp = pci_get_drvdata(pdev);
#line 5469
  phba = (struct beiscsi_hba *)tmp;
#line 5471
  log_value = phba->attr_log_enable;
#line 5471
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5471
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset\n",
               5472);
  } else {

  }
#line 5474
  status = pci_enable_device(pdev);
#line 5475
  if (status != 0) {
#line 5476
    return (4U);
  } else {

  }
#line 5478
  pci_set_master(pdev);
#line 5479
  pci_set_power_state(pdev, 0);
#line 5480
  pci_restore_state(pdev);
#line 5483
  status = be_chk_reset_complete(phba);
#line 5484
  if (status == 0) {
#line 5485
    log_value___0 = phba->attr_log_enable;
#line 5485
    if ((int )log_value___0 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 5485
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset Completed\n",
                 5486);
    } else {

    }
  } else {
#line 5488
    log_value___1 = phba->attr_log_enable;
#line 5488
    if ((int )log_value___1 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 5488
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset Completion Failure\n",
                 5489);
    } else {

    }
#line 5490
    return (4U);
  }
#line 5493
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 5494
  return (5U);
}
}
#line 5497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_eeh_resume(struct pci_dev *pdev ) 
{ 
  int ret ;
  int i ;
  struct be_eq_obj *pbe_eq ;
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 5499
  ret = 0;
#line 5501
  phba = (struct beiscsi_hba *)0;
#line 5505
  tmp = pci_get_drvdata(pdev);
#line 5505
  phba = (struct beiscsi_hba *)tmp;
#line 5506
  pci_save_state(pdev);
#line 5508
  if (enable_msix != 0U) {
#line 5509
    find_num_cpus(phba);
  } else {
#line 5511
    phba->num_cpus = 1U;
  }
#line 5513
  if (enable_msix != 0U) {
#line 5514
    beiscsi_msix_enable(phba);
#line 5515
    if (! phba->msix_enabled) {
#line 5516
      phba->num_cpus = 1U;
    } else {

    }
  } else {

  }
#line 5519
  ret = beiscsi_cmd_reset_function(phba);
#line 5520
  if (ret != 0) {
#line 5521
    log_value = phba->attr_log_enable;
#line 5521
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5521
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Reset Failed\n",
                 5522);
    } else {

    }
#line 5523
    goto ret_err;
  } else {

  }
#line 5526
  ret = be_chk_reset_complete(phba);
#line 5527
  if (ret != 0) {
#line 5528
    log_value___0 = phba->attr_log_enable;
#line 5528
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5528
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to get out of reset.\n",
                 5529);
    } else {

    }
#line 5530
    goto ret_err;
  } else {

  }
#line 5533
  beiscsi_get_params(phba);
#line 5534
  (phba->shost)->max_id = phba->params.cxns_per_ctrl;
#line 5535
  (phba->shost)->can_queue = (int )phba->params.ios_per_ctrl;
#line 5536
  ret = hwi_init_controller(phba);
#line 5538
  i = 0;
#line 5538
  goto ldv_56393;
  ldv_56392: 
#line 5539
  __init_waitqueue_head((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + ((unsigned long )i + 1UL),
                        "&phba->ctrl.mcc_wait[i + 1]", & __key);
#line 5540
  phba->ctrl.mcc_tag[i] = (unsigned int )(i + 1);
#line 5541
  phba->ctrl.mcc_numtag[i + 1] = 0U;
#line 5542
  phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available + 1U;
#line 5538
  i = i + 1;
  ldv_56393: ;
#line 5538
  if (i <= 15) {
#line 5540
    goto ldv_56392;
  } else {

  }
#line 5545
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5546
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5548
  i = 0;
#line 5548
  goto ldv_56396;
  ldv_56395: 
#line 5549
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5550
  blk_iopoll_init(& pbe_eq->iopoll, (int )be_iopoll_budget, & be_iopoll);
#line 5552
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 5548
  i = i + 1;
  ldv_56396: ;
#line 5548
  if ((unsigned int )i < phba->num_cpus) {
#line 5550
    goto ldv_56395;
  } else {

  }
#line 5555
  i = (int )phba->msix_enabled ? i : 0;
#line 5557
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5558
  __init_work(& pbe_eq->work_cqs, 0);
#line 5558
  __constr_expr_0.counter = 137438953408L;
#line 5558
  pbe_eq->work_cqs.data = __constr_expr_0;
#line 5558
  lockdep_init_map(& pbe_eq->work_cqs.lockdep_map, "(&pbe_eq->work_cqs)", & __key___0,
                   0);
#line 5558
  INIT_LIST_HEAD(& pbe_eq->work_cqs.entry);
#line 5558
  pbe_eq->work_cqs.func = & beiscsi_process_all_cqs;
#line 5560
  ret = beiscsi_init_irqs(phba);
#line 5561
  if (ret < 0) {
#line 5562
    log_value___1 = phba->attr_log_enable;
#line 5562
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5562
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_eeh_resume - Failed to beiscsi_init_irqs\n",
                 5564);
    } else {

    }
#line 5565
    goto ret_err;
  } else {

  }
#line 5568
  hwi_enable_intr(phba);
#line 5569
  phba->state = phba->state & 4294967291U;
#line 5571
  return;
  ret_err: 
#line 5573
  log_value___2 = phba->attr_log_enable;
#line 5573
  if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5573
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : AER EEH Resume Failed\n",
               5574);
  } else {

  }
#line 5575
  return;
}
}
#line 5577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_dev_probe(struct pci_dev *pcidev , struct pci_device_id  const  *id ) 
{ 
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_obj *pbe_eq ;
  int ret ;
  int i ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  struct lock_class_key __key___3 ;
  unsigned short tmp ;
  struct lock_class_key __key___4 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___0 ;
  uint32_t log_value___6 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___6 ;
  struct lock_class_key __key___7 ;
  atomic_long_t __constr_expr_1 ;
  uint32_t log_value___7 ;
  int tmp___1 ;
  uint32_t log_value___8 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  uint32_t log_value___9 ;

  {
#line 5580
  phba = (struct beiscsi_hba *)0;
#line 5584
  ret = 0;
#line 5586
  ret = beiscsi_enable_pci(pcidev);
#line 5587
  if (ret < 0) {
#line 5588
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_dev_probe - Failed to enable pci device\n");
#line 5590
    return (ret);
  } else {

  }
#line 5593
  phba = beiscsi_hba_alloc(pcidev);
#line 5594
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
#line 5595
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_dev_probe - Failed in beiscsi_hba_alloc\n");
#line 5597
    goto disable_pci;
  } else {

  }
#line 5601
  ret = pci_enable_pcie_error_reporting(pcidev);
#line 5602
  if (ret != 0) {
#line 5603
    log_value = phba->attr_log_enable;
#line 5603
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 5603
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : PCIe Error Reporting Enabling Failed\n",
                 5605);
    } else {

    }
  } else {

  }
#line 5607
  pci_save_state(pcidev);
#line 5610
  beiscsi_hba_attrs_init(phba);
#line 5612
  phba->fw_timeout = 0;
#line 5613
  phba->mac_addr_set = 0;
#line 5616
  switch ((int )pcidev->device) {
  case 530: ;
  case 1794: ;
  case 1795: 
#line 5620
  phba->generation = 2U;
#line 5621
  phba->iotask_fn = & beiscsi_iotask;
#line 5622
  goto ldv_56417;
  case 546: ;
  case 1810: 
#line 5625
  phba->generation = 3U;
#line 5626
  phba->iotask_fn = & beiscsi_iotask;
#line 5627
  goto ldv_56417;
  case 1826: 
#line 5629
  phba->generation = 4U;
#line 5630
  phba->iotask_fn = & beiscsi_iotask_v2;
#line 5631
  goto ldv_56417;
  default: 
#line 5633
  phba->generation = 0U;
  }
  ldv_56417: 
#line 5636
  ret = be_ctrl_init(phba, pcidev);
#line 5637
  if (ret != 0) {
#line 5638
    log_value___0 = phba->attr_log_enable;
#line 5638
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5638
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed in be_ctrl_init\n",
                 5640);
    } else {

    }
#line 5641
    goto hba_free;
  } else {

  }
#line 5644
  ret = beiscsi_cmd_reset_function(phba);
#line 5645
  if (ret != 0) {
#line 5646
    log_value___1 = phba->attr_log_enable;
#line 5646
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5646
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Reset Failed\n",
                 5647);
    } else {

    }
#line 5648
    goto hba_free;
  } else {

  }
#line 5650
  ret = be_chk_reset_complete(phba);
#line 5651
  if (ret != 0) {
#line 5652
    log_value___2 = phba->attr_log_enable;
#line 5652
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5652
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to get out of reset.\n",
                 5653);
    } else {

    }
#line 5654
    goto hba_free;
  } else {

  }
#line 5657
  spinlock_check(& phba->io_sgl_lock);
#line 5657
  __raw_spin_lock_init(& phba->io_sgl_lock.__annonCompField18.rlock, "&(&phba->io_sgl_lock)->rlock",
                       & __key);
#line 5658
  spinlock_check(& phba->mgmt_sgl_lock);
#line 5658
  __raw_spin_lock_init(& phba->mgmt_sgl_lock.__annonCompField18.rlock, "&(&phba->mgmt_sgl_lock)->rlock",
                       & __key___0);
#line 5659
  spinlock_check(& phba->isr_lock);
#line 5659
  __raw_spin_lock_init(& phba->isr_lock.__annonCompField18.rlock, "&(&phba->isr_lock)->rlock",
                       & __key___1);
#line 5660
  spinlock_check(& phba->async_pdu_lock);
#line 5660
  __raw_spin_lock_init(& phba->async_pdu_lock.__annonCompField18.rlock, "&(&phba->async_pdu_lock)->rlock",
                       & __key___2);
#line 5661
  ret = mgmt_get_fw_config(& phba->ctrl, phba);
#line 5662
  if (ret != 0) {
#line 5663
    log_value___3 = phba->attr_log_enable;
#line 5663
    if ((int )log_value___3 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5663
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Error getting fw config\n",
                 5664);
    } else {

    }
#line 5665
    goto free_port;
  } else {

  }
#line 5668
  if (enable_msix != 0U) {
#line 5669
    find_num_cpus(phba);
  } else {
#line 5671
    phba->num_cpus = 1U;
  }
#line 5673
  log_value___4 = phba->attr_log_enable;
#line 5673
  if ((int )log_value___4 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 5673
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : num_cpus = %d\n",
               5675, phba->num_cpus);
  } else {

  }
#line 5677
  if (enable_msix != 0U) {
#line 5678
    beiscsi_msix_enable(phba);
#line 5679
    if (! phba->msix_enabled) {
#line 5680
      phba->num_cpus = 1U;
    } else {

    }
  } else {

  }
#line 5683
  (phba->shost)->max_id = phba->params.cxns_per_ctrl;
#line 5684
  beiscsi_get_params(phba);
#line 5685
  (phba->shost)->can_queue = (int )phba->params.ios_per_ctrl;
#line 5686
  ret = beiscsi_init_port(phba);
#line 5687
  if (ret < 0) {
#line 5688
    log_value___5 = phba->attr_log_enable;
#line 5688
    if ((int )log_value___5 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5688
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed in beiscsi_init_port\n",
                 5690);
    } else {

    }
#line 5691
    goto free_port;
  } else {

  }
#line 5694
  i = 0;
#line 5694
  goto ldv_56436;
  ldv_56435: 
#line 5695
  __init_waitqueue_head((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + ((unsigned long )i + 1UL),
                        "&phba->ctrl.mcc_wait[i + 1]", & __key___3);
#line 5696
  phba->ctrl.mcc_tag[i] = (unsigned int )(i + 1);
#line 5697
  phba->ctrl.mcc_numtag[i + 1] = 0U;
#line 5698
  phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available + 1U;
#line 5699
  memset((void *)(& phba->ctrl.ptag_state[i].tag_mem_state), 0, 24UL);
#line 5694
  i = i + 1;
  ldv_56436: ;
#line 5694
  if (i <= 15) {
#line 5696
    goto ldv_56435;
  } else {

  }
#line 5703
  tmp = 0U;
#line 5703
  phba->ctrl.mcc_free_index = tmp;
#line 5703
  phba->ctrl.mcc_alloc_index = tmp;
#line 5705
  snprintf((char *)(& phba->wq_name), 20UL, "beiscsi_%02x_wq", (phba->shost)->host_no);
#line 5707
  __lock_name = "\"%s\"phba->wq_name";
#line 5707
  tmp___0 = __alloc_workqueue_key("%s", 8U, 1, & __key___4, __lock_name, (char *)(& phba->wq_name));
#line 5707
  phba->wq = tmp___0;
#line 5708
  if ((unsigned long )phba->wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 5709
    log_value___6 = phba->attr_log_enable;
#line 5709
    if ((int )log_value___6 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5709
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed to allocate work queue\n",
                 5711);
    } else {

    }
#line 5712
    goto free_twq;
  } else {

  }
#line 5715
  __init_work(& phba->beiscsi_hw_check_task.work, 0);
#line 5715
  __constr_expr_0.counter = 137438953408L;
#line 5715
  phba->beiscsi_hw_check_task.work.data = __constr_expr_0;
#line 5715
  lockdep_init_map(& phba->beiscsi_hw_check_task.work.lockdep_map, "(&(&phba->beiscsi_hw_check_task)->work)",
                   & __key___5, 0);
#line 5715
  INIT_LIST_HEAD(& phba->beiscsi_hw_check_task.work.entry);
#line 5715
  phba->beiscsi_hw_check_task.work.func = & beiscsi_hw_health_check;
#line 5715
  init_timer_key(& phba->beiscsi_hw_check_task.timer, 2097152U, "(&(&phba->beiscsi_hw_check_task)->timer)",
                 & __key___6);
#line 5715
  phba->beiscsi_hw_check_task.timer.function = & delayed_work_timer_fn;
#line 5715
  phba->beiscsi_hw_check_task.timer.data = (unsigned long )(& phba->beiscsi_hw_check_task);
#line 5718
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5719
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5721
  i = 0;
#line 5721
  goto ldv_56447;
  ldv_56446: 
#line 5722
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5723
  blk_iopoll_init(& pbe_eq->iopoll, (int )be_iopoll_budget, & be_iopoll);
#line 5725
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 5721
  i = i + 1;
  ldv_56447: ;
#line 5721
  if ((unsigned int )i < phba->num_cpus) {
#line 5723
    goto ldv_56446;
  } else {

  }
#line 5728
  i = (int )phba->msix_enabled ? i : 0;
#line 5730
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5731
  __init_work(& pbe_eq->work_cqs, 0);
#line 5731
  __constr_expr_1.counter = 137438953408L;
#line 5731
  pbe_eq->work_cqs.data = __constr_expr_1;
#line 5731
  lockdep_init_map(& pbe_eq->work_cqs.lockdep_map, "(&pbe_eq->work_cqs)", & __key___7,
                   0);
#line 5731
  INIT_LIST_HEAD(& pbe_eq->work_cqs.entry);
#line 5731
  pbe_eq->work_cqs.func = & beiscsi_process_all_cqs;
#line 5733
  ret = beiscsi_init_irqs(phba);
#line 5734
  if (ret < 0) {
#line 5735
    log_value___7 = phba->attr_log_enable;
#line 5735
    if ((int )log_value___7 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5735
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed to beiscsi_init_irqs\n",
                 5737);
    } else {

    }
#line 5738
    goto free_blkenbld;
  } else {

  }
#line 5740
  hwi_enable_intr(phba);
#line 5742
  tmp___1 = iscsi_host_add(phba->shost, & (phba->pcidev)->dev);
#line 5742
  if (tmp___1 != 0) {
#line 5743
    goto free_blkenbld;
  } else {

  }
#line 5745
  tmp___2 = beiscsi_setup_boot_info(phba);
#line 5745
  if (tmp___2 != 0) {
#line 5750
    log_value___8 = phba->attr_log_enable;
#line 5750
    if ((int )log_value___8 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 5750
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Could not set up iSCSI boot info.\n",
                 5752);
    } else {

    }
  } else {

  }
#line 5754
  beiscsi_create_def_ifaces(phba);
#line 5755
  tmp___3 = msecs_to_jiffies(1000U);
#line 5755
  schedule_delayed_work(& phba->beiscsi_hw_check_task, tmp___3);
#line 5758
  log_value___9 = phba->attr_log_enable;
#line 5758
  if ((int )log_value___9 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 5758
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "\n\n\n BM_%d : SUCCESS - DRIVER LOADED\n\n\n",
               5759);
  } else {

  }
#line 5760
  return (0);
  free_blkenbld: 
#line 5763
  ldv_destroy_workqueue_32(phba->wq);
#line 5764
  i = 0;
#line 5764
  goto ldv_56456;
  ldv_56455: 
#line 5765
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5766
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 5764
  i = i + 1;
  ldv_56456: ;
#line 5764
  if ((unsigned int )i < phba->num_cpus) {
#line 5766
    goto ldv_56455;
  } else {

  }

  free_twq: 
#line 5769
  beiscsi_clean_port(phba);
#line 5770
  beiscsi_free_mem(phba);
  free_port: 
#line 5772
  pci_free_consistent(phba->pcidev, (size_t )phba->ctrl.mbox_mem_alloced.size, phba->ctrl.mbox_mem_alloced.va,
                      phba->ctrl.mbox_mem_alloced.dma);
#line 5776
  beiscsi_unmap_pci_function(phba);
  hba_free: ;
#line 5778
  if ((int )phba->msix_enabled) {
#line 5779
    pci_disable_msix(phba->pcidev);
  } else {

  }
#line 5780
  pci_dev_put(phba->pcidev);
#line 5781
  iscsi_host_free(phba->shost);
#line 5782
  pci_set_drvdata(pcidev, (void *)0);
  disable_pci: 
#line 5784
  pci_release_regions(pcidev);
#line 5785
  pci_disable_device(pcidev);
#line 5786
  return (ret);
}
}
#line 5789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct pci_error_handlers beiscsi_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& beiscsi_eeh_err_detected),
    0, 0, & beiscsi_eeh_reset, 0, & beiscsi_eeh_resume};
#line 5795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
struct iscsi_transport beiscsi_iscsi_transport  = 
#line 5795
     {& __this_module, (char *)"be2iscsi", 2233U, & beiscsi_session_create, & beiscsi_session_destroy,
    & beiscsi_conn_create, & beiscsi_conn_bind, & beiscsi_conn_start, & iscsi_conn_stop,
    & iscsi_conn_teardown, & beiscsi_set_param, & beiscsi_ep_get_param, & iscsi_conn_get_param,
    & iscsi_session_get_param, & beiscsi_get_host_param, 0, & iscsi_conn_send_pdu,
    & beiscsi_conn_get_stats, 0, & beiscsi_task_xmit, & beiscsi_cleanup_task, & beiscsi_alloc_pdu,
    0, 0, & beiscsi_parse_pdu, & iscsi_session_recovery_timedout, & beiscsi_ep_connect,
    & beiscsi_ep_poll, & beiscsi_ep_disconnect, 0, 0, & be2iscsi_iface_set_param,
    & be2iscsi_iface_get_param, & be2iscsi_attr_is_visible, & beiscsi_bsg_request,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 5828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static struct pci_driver beiscsi_pci_driver  = 
#line 5828
     {{0, 0}, "be2iscsi", (struct pci_device_id  const  *)(& beiscsi_pci_id_table),
    & beiscsi_dev_probe, & beiscsi_remove, 0, 0, 0, 0, & beiscsi_shutdown, 0, (struct pci_error_handlers  const  *)(& beiscsi_eeh_handlers),
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
#line 5838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_module_init(void) 
{ 
  int ret ;

  {
#line 5842
  beiscsi_scsi_transport = iscsi_register_transport(& beiscsi_iscsi_transport);
#line 5844
  if ((unsigned long )beiscsi_scsi_transport == (unsigned long )((struct scsi_transport_template *)0)) {
#line 5845
    printk("\vbeiscsi_module_init - Unable to  register beiscsi transport.\n");
#line 5847
    return (-12);
  } else {

  }
#line 5849
  printk("\016In beiscsi_module_init, tt=%p\n", & beiscsi_iscsi_transport);
#line 5852
  ret = ldv___pci_register_driver_33(& beiscsi_pci_driver, & __this_module, "be2iscsi");
#line 5853
  if (ret != 0) {
#line 5854
    printk("\vbeiscsi_module_init - Unable to  register beiscsi pci driver.\n");
#line 5856
    goto unregister_iscsi_transport;
  } else {

  }
#line 5858
  return (0);
  unregister_iscsi_transport: 
#line 5861
  iscsi_unregister_transport(& beiscsi_iscsi_transport);
#line 5862
  return (ret);
}
}
#line 5865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_module_exit(void) 
{ 


  {
#line 5867
  ldv_pci_unregister_driver_34(& beiscsi_pci_driver);
#line 5868
  iscsi_unregister_transport(& beiscsi_iscsi_transport);
#line 5869
  return;
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
extern int ldv_suspend_9(void) ;
#line 154
extern int ldv_release_9(void) ;
#line 155
extern int ldv_probe_9(void) ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_retval_0  ;
#line 157
extern int ldv_probe_8(void) ;
#line 158
extern void ldv_initialize(void) ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_retval_1  ;
#line 160
void ldv_check_final_state(void) ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_3(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 165
  tmp = __VERIFIER_nondet_int();
#line 165
  irq_retval = (irqreturn_t )tmp;
#line 167
  if (state != 0) {
#line 168
    tmp___0 = __VERIFIER_nondet_int();
#line 168
    switch (tmp___0) {
    case 0: ;
#line 170
    if (state == 1) {
#line 171
      LDV_IN_INTERRUPT = 2;
#line 172
      irq_retval = be_isr(line, data);
#line 173
      LDV_IN_INTERRUPT = 1;
#line 174
      return (state);
    } else {

    }
#line 177
    goto ldv_56500;
    default: 
#line 178
    ldv_stop();
    }
    ldv_56500: ;
  } else {

  }
#line 181
  return (state);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 186
  if (ldv_work_5_0 == 0) {
#line 187
    ldv_work_struct_5_0 = work;
#line 188
    ldv_work_5_0 = state;
#line 189
    return;
  } else {

  }
#line 192
  if (ldv_work_5_1 == 0) {
#line 193
    ldv_work_struct_5_1 = work;
#line 194
    ldv_work_5_1 = state;
#line 195
    return;
  } else {

  }
#line 198
  if (ldv_work_5_2 == 0) {
#line 199
    ldv_work_struct_5_2 = work;
#line 200
    ldv_work_5_2 = state;
#line 201
    return;
  } else {

  }
#line 204
  if (ldv_work_5_3 == 0) {
#line 205
    ldv_work_struct_5_3 = work;
#line 206
    ldv_work_5_3 = state;
#line 207
    return;
  } else {

  }
#line 209
  return;
}
}
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 213
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
#line 214
    ldv_irq_2_0 = 0;
#line 215
    return;
  } else {

  }
#line 217
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
#line 218
    ldv_irq_2_1 = 0;
#line 219
    return;
  } else {

  }
#line 221
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
#line 222
    ldv_irq_2_2 = 0;
#line 223
    return;
  } else {

  }
#line 225
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
#line 226
    ldv_irq_2_3 = 0;
#line 227
    return;
  } else {

  }
#line 229
  return;
}
}
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void invoke_work_6(void) 
{ 
  int tmp ;

  {
#line 235
  tmp = __VERIFIER_nondet_int();
#line 235
  switch (tmp) {
  case 0: ;
#line 237
  if (ldv_work_6_0 == 2 || ldv_work_6_0 == 3) {
#line 238
    ldv_work_6_0 = 4;
#line 239
    beiscsi_process_all_cqs(ldv_work_struct_6_0);
#line 240
    ldv_work_6_0 = 1;
  } else {

  }
#line 243
  goto ldv_56516;
  case 1: ;
#line 245
  if (ldv_work_6_1 == 2 || ldv_work_6_1 == 3) {
#line 246
    ldv_work_6_1 = 4;
#line 247
    beiscsi_process_all_cqs(ldv_work_struct_6_0);
#line 248
    ldv_work_6_1 = 1;
  } else {

  }
#line 251
  goto ldv_56516;
  case 2: ;
#line 253
  if (ldv_work_6_2 == 2 || ldv_work_6_2 == 3) {
#line 254
    ldv_work_6_2 = 4;
#line 255
    beiscsi_process_all_cqs(ldv_work_struct_6_0);
#line 256
    ldv_work_6_2 = 1;
  } else {

  }
#line 259
  goto ldv_56516;
  case 3: ;
#line 261
  if (ldv_work_6_3 == 2 || ldv_work_6_3 == 3) {
#line 262
    ldv_work_6_3 = 4;
#line 263
    beiscsi_process_all_cqs(ldv_work_struct_6_0);
#line 264
    ldv_work_6_3 = 1;
  } else {

  }
#line 267
  goto ldv_56516;
  default: 
#line 268
  ldv_stop();
  }
  ldv_56516: ;
#line 270
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_suitable_irq_3(int line , void *data ) 
{ 


  {
#line 275
  if (ldv_irq_3_0 == 0) {
#line 276
    ldv_irq_line_3_0 = line;
#line 277
    ldv_irq_data_3_0 = data;
#line 278
    ldv_irq_3_0 = 1;
#line 279
    return;
  } else {

  }
#line 281
  if (ldv_irq_3_1 == 0) {
#line 282
    ldv_irq_line_3_1 = line;
#line 283
    ldv_irq_data_3_1 = data;
#line 284
    ldv_irq_3_1 = 1;
#line 285
    return;
  } else {

  }
#line 287
  if (ldv_irq_3_2 == 0) {
#line 288
    ldv_irq_line_3_2 = line;
#line 289
    ldv_irq_data_3_2 = data;
#line 290
    ldv_irq_3_2 = 1;
#line 291
    return;
  } else {

  }
#line 293
  if (ldv_irq_3_3 == 0) {
#line 294
    ldv_irq_line_3_3 = line;
#line 295
    ldv_irq_data_3_3 = data;
#line 296
    ldv_irq_3_3 = 1;
#line 297
    return;
  } else {

  }
#line 299
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 304
  if ((unsigned long )handler == (unsigned long )(& be_isr_msix)) {
#line 305
    return (1);
  } else {

  }
#line 307
  return (0);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 312
  ldv_work_5_0 = 0;
#line 313
  ldv_work_5_1 = 0;
#line 314
  ldv_work_5_2 = 0;
#line 315
  ldv_work_5_3 = 0;
#line 316
  return;
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 321
  if (ldv_work_4_0 == state) {
#line 322
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 323
  if (ldv_work_4_1 == state) {
#line 324
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 325
  if (ldv_work_4_2 == state) {
#line 326
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 327
  if (ldv_work_4_3 == state) {
#line 328
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 329
  return;
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 334
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 336
    ldv_work_5_0 = 1;
  } else {

  }
#line 338
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 340
    ldv_work_5_1 = 1;
  } else {

  }
#line 342
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 344
    ldv_work_5_2 = 1;
  } else {

  }
#line 346
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 348
    ldv_work_5_3 = 1;
  } else {

  }
#line 349
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_initialize_pci_error_handlers_9(void) 
{ 
  void *tmp ;

  {
#line 354
  tmp = __VERIFIER_nondet_pointer();
#line 354
  beiscsi_eeh_handlers_group0 = (struct pci_dev *)tmp;
#line 355
  return;
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_all_6(int state ) 
{ 


  {
#line 359
  if (ldv_work_6_0 == state) {
#line 360
    call_and_disable_work_6(ldv_work_struct_6_0);
  } else {

  }
#line 361
  if (ldv_work_6_1 == state) {
#line 362
    call_and_disable_work_6(ldv_work_struct_6_1);
  } else {

  }
#line 363
  if (ldv_work_6_2 == state) {
#line 364
    call_and_disable_work_6(ldv_work_struct_6_2);
  } else {

  }
#line 365
  if (ldv_work_6_3 == state) {
#line 366
    call_and_disable_work_6(ldv_work_struct_6_3);
  } else {

  }
#line 367
  return;
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 371
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 372
    ldv_irq_1_0 = 0;
#line 373
    return;
  } else {

  }
#line 375
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 376
    ldv_irq_1_1 = 0;
#line 377
    return;
  } else {

  }
#line 379
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 380
    ldv_irq_1_2 = 0;
#line 381
    return;
  } else {

  }
#line 383
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 384
    ldv_irq_1_3 = 0;
#line 385
    return;
  } else {

  }
#line 387
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 392
  if (ldv_irq_1_0 == 0) {
#line 393
    ldv_irq_line_1_0 = line;
#line 394
    ldv_irq_data_1_0 = data;
#line 395
    ldv_irq_1_0 = 1;
#line 396
    return;
  } else {

  }
#line 398
  if (ldv_irq_1_1 == 0) {
#line 399
    ldv_irq_line_1_1 = line;
#line 400
    ldv_irq_data_1_1 = data;
#line 401
    ldv_irq_1_1 = 1;
#line 402
    return;
  } else {

  }
#line 404
  if (ldv_irq_1_2 == 0) {
#line 405
    ldv_irq_line_1_2 = line;
#line 406
    ldv_irq_data_1_2 = data;
#line 407
    ldv_irq_1_2 = 1;
#line 408
    return;
  } else {

  }
#line 410
  if (ldv_irq_1_3 == 0) {
#line 411
    ldv_irq_line_1_3 = line;
#line 412
    ldv_irq_data_1_3 = data;
#line 413
    ldv_irq_1_3 = 1;
#line 414
    return;
  } else {

  }
#line 416
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 422
  tmp = __VERIFIER_nondet_int();
#line 422
  switch (tmp) {
  case 0: ;
#line 424
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 425
    ldv_work_4_0 = 4;
#line 426
    beiscsi_process_all_cqs(ldv_work_struct_4_0);
#line 427
    ldv_work_4_0 = 1;
  } else {

  }
#line 430
  goto ldv_56559;
  case 1: ;
#line 432
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 433
    ldv_work_4_1 = 4;
#line 434
    beiscsi_process_all_cqs(ldv_work_struct_4_0);
#line 435
    ldv_work_4_1 = 1;
  } else {

  }
#line 438
  goto ldv_56559;
  case 2: ;
#line 440
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 441
    ldv_work_4_2 = 4;
#line 442
    beiscsi_process_all_cqs(ldv_work_struct_4_0);
#line 443
    ldv_work_4_2 = 1;
  } else {

  }
#line 446
  goto ldv_56559;
  case 3: ;
#line 448
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 449
    ldv_work_4_3 = 4;
#line 450
    beiscsi_process_all_cqs(ldv_work_struct_4_0);
#line 451
    ldv_work_4_3 = 1;
  } else {

  }
#line 454
  goto ldv_56559;
  default: 
#line 455
  ldv_stop();
  }
  ldv_56559: ;
#line 457
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 464
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 466
    beiscsi_hw_health_check(work);
#line 467
    ldv_work_5_0 = 1;
#line 468
    return;
  } else {

  }
#line 470
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 472
    beiscsi_hw_health_check(work);
#line 473
    ldv_work_5_1 = 1;
#line 474
    return;
  } else {

  }
#line 476
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 478
    beiscsi_hw_health_check(work);
#line 479
    ldv_work_5_2 = 1;
#line 480
    return;
  } else {

  }
#line 482
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 484
    beiscsi_hw_health_check(work);
#line 485
    ldv_work_5_3 = 1;
#line 486
    return;
  } else {

  }
#line 488
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 493
  tmp = __VERIFIER_nondet_int();
#line 493
  irq_retval = (irqreturn_t )tmp;
#line 495
  if (state != 0) {
#line 496
    tmp___0 = __VERIFIER_nondet_int();
#line 496
    switch (tmp___0) {
    case 0: ;
#line 498
    if (state == 1) {
#line 499
      LDV_IN_INTERRUPT = 2;
#line 500
      irq_retval = be_isr_mcc(line, data);
#line 501
      LDV_IN_INTERRUPT = 1;
#line 502
      return (state);
    } else {

    }
#line 505
    goto ldv_56576;
    default: 
#line 506
    ldv_stop();
    }
    ldv_56576: ;
  } else {

  }
#line 509
  return (state);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_initialize_iscsi_transport_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 514
  tmp = ldv_init_zalloc(3816UL);
#line 514
  beiscsi_iscsi_transport_group0 = (struct Scsi_Host *)tmp;
#line 515
  tmp___0 = ldv_init_zalloc(2096UL);
#line 515
  beiscsi_iscsi_transport_group1 = (struct iscsi_cls_session *)tmp___0;
#line 516
  tmp___1 = ldv_init_zalloc(1624UL);
#line 516
  beiscsi_iscsi_transport_group2 = (struct iscsi_cls_conn *)tmp___1;
#line 517
  tmp___2 = ldv_init_zalloc(152UL);
#line 517
  beiscsi_iscsi_transport_group3 = (struct iscsi_task *)tmp___2;
#line 518
  tmp___3 = ldv_init_zalloc(1440UL);
#line 518
  beiscsi_iscsi_transport_group4 = (struct iscsi_endpoint *)tmp___3;
#line 519
  return;
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_work_6(struct work_struct *work , int state ) 
{ 


  {
#line 522
  if (ldv_work_6_0 == 0) {
#line 523
    ldv_work_struct_6_0 = work;
#line 524
    ldv_work_6_0 = state;
#line 525
    return;
  } else {

  }
#line 528
  if (ldv_work_6_1 == 0) {
#line 529
    ldv_work_struct_6_1 = work;
#line 530
    ldv_work_6_1 = state;
#line 531
    return;
  } else {

  }
#line 534
  if (ldv_work_6_2 == 0) {
#line 535
    ldv_work_struct_6_2 = work;
#line 536
    ldv_work_6_2 = state;
#line 537
    return;
  } else {

  }
#line 540
  if (ldv_work_6_3 == 0) {
#line 541
    ldv_work_struct_6_3 = work;
#line 542
    ldv_work_6_3 = state;
#line 543
    return;
  } else {

  }
#line 545
  return;
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
#line 549
  tmp = __VERIFIER_nondet_int();
#line 549
  switch (tmp) {
  case 0: 
#line 551
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
#line 553
  goto ldv_56589;
  case 1: 
#line 555
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
#line 557
  goto ldv_56589;
  case 2: 
#line 559
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
#line 561
  goto ldv_56589;
  case 3: 
#line 563
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
#line 565
  goto ldv_56589;
  default: 
#line 566
  ldv_stop();
  }
  ldv_56589: ;
#line 568
  return;
}
}
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 573
  if (ldv_work_4_0 == 0) {
#line 574
    ldv_work_struct_4_0 = work;
#line 575
    ldv_work_4_0 = state;
#line 576
    return;
  } else {

  }
#line 579
  if (ldv_work_4_1 == 0) {
#line 580
    ldv_work_struct_4_1 = work;
#line 581
    ldv_work_4_1 = state;
#line 582
    return;
  } else {

  }
#line 585
  if (ldv_work_4_2 == 0) {
#line 586
    ldv_work_struct_4_2 = work;
#line 587
    ldv_work_4_2 = state;
#line 588
    return;
  } else {

  }
#line 591
  if (ldv_work_4_3 == 0) {
#line 592
    ldv_work_struct_4_3 = work;
#line 593
    ldv_work_4_3 = state;
#line 594
    return;
  } else {

  }
#line 596
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 601
  if (ldv_work_5_0 == state) {
#line 602
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 603
  if (ldv_work_5_1 == state) {
#line 604
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 605
  if (ldv_work_5_2 == state) {
#line 606
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 607
  if (ldv_work_5_3 == state) {
#line 608
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 609
  return;
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 613
  if (ldv_irq_2_0 == 0) {
#line 614
    ldv_irq_line_2_0 = line;
#line 615
    ldv_irq_data_2_0 = data;
#line 616
    ldv_irq_2_0 = 1;
#line 617
    return;
  } else {

  }
#line 619
  if (ldv_irq_2_1 == 0) {
#line 620
    ldv_irq_line_2_1 = line;
#line 621
    ldv_irq_data_2_1 = data;
#line 622
    ldv_irq_2_1 = 1;
#line 623
    return;
  } else {

  }
#line 625
  if (ldv_irq_2_2 == 0) {
#line 626
    ldv_irq_line_2_2 = line;
#line 627
    ldv_irq_data_2_2 = data;
#line 628
    ldv_irq_2_2 = 1;
#line 629
    return;
  } else {

  }
#line 631
  if (ldv_irq_2_3 == 0) {
#line 632
    ldv_irq_line_2_3 = line;
#line 633
    ldv_irq_data_2_3 = data;
#line 634
    ldv_irq_2_3 = 1;
#line 635
    return;
  } else {

  }
#line 637
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_initialize_device_attribute_17(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 642
  tmp = ldv_init_zalloc(48UL);
#line 642
  dev_attr_beiscsi_log_enable_group0 = (struct device_attribute *)tmp;
#line 643
  tmp___0 = ldv_init_zalloc(1416UL);
#line 643
  dev_attr_beiscsi_log_enable_group1 = (struct device *)tmp___0;
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_initialize_scsi_host_template_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 647
  tmp = __VERIFIER_nondet_pointer();
#line 647
  beiscsi_sht_group0 = (struct scsi_cmnd *)tmp;
#line 648
  tmp___0 = __VERIFIER_nondet_pointer();
#line 648
  beiscsi_sht_group1 = (struct scsi_device *)tmp___0;
#line 649
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void work_init_6(void) 
{ 


  {
#line 652
  ldv_work_6_0 = 0;
#line 653
  ldv_work_6_1 = 0;
#line 654
  ldv_work_6_2 = 0;
#line 655
  ldv_work_6_3 = 0;
#line 656
  return;
}
}
#line 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_work_6(struct work_struct *work ) 
{ 


  {
#line 661
  if ((ldv_work_6_0 == 3 || ldv_work_6_0 == 2) && (unsigned long )ldv_work_struct_6_0 == (unsigned long )work) {
#line 663
    ldv_work_6_0 = 1;
  } else {

  }
#line 665
  if ((ldv_work_6_1 == 3 || ldv_work_6_1 == 2) && (unsigned long )ldv_work_struct_6_1 == (unsigned long )work) {
#line 667
    ldv_work_6_1 = 1;
  } else {

  }
#line 669
  if ((ldv_work_6_2 == 3 || ldv_work_6_2 == 2) && (unsigned long )ldv_work_struct_6_2 == (unsigned long )work) {
#line 671
    ldv_work_6_2 = 1;
  } else {

  }
#line 673
  if ((ldv_work_6_3 == 3 || ldv_work_6_3 == 2) && (unsigned long )ldv_work_struct_6_3 == (unsigned long )work) {
#line 675
    ldv_work_6_3 = 1;
  } else {

  }
#line 676
  return;
}
}
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 681
  tmp = __VERIFIER_nondet_int();
#line 681
  switch (tmp) {
  case 0: 
#line 683
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 685
  goto ldv_56621;
  case 1: 
#line 687
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 689
  goto ldv_56621;
  case 2: 
#line 691
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 693
  goto ldv_56621;
  case 3: 
#line 695
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 697
  goto ldv_56621;
  default: 
#line 698
  ldv_stop();
  }
  ldv_56621: ;
#line 700
  return;
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 706
  tmp = __VERIFIER_nondet_int();
#line 706
  switch (tmp) {
  case 0: ;
#line 708
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 709
    ldv_work_5_0 = 4;
#line 710
    beiscsi_hw_health_check(ldv_work_struct_5_0);
#line 711
    ldv_work_5_0 = 1;
  } else {

  }
#line 714
  goto ldv_56632;
  case 1: ;
#line 716
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 717
    ldv_work_5_1 = 4;
#line 718
    beiscsi_hw_health_check(ldv_work_struct_5_0);
#line 719
    ldv_work_5_1 = 1;
  } else {

  }
#line 722
  goto ldv_56632;
  case 2: ;
#line 724
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 725
    ldv_work_5_2 = 4;
#line 726
    beiscsi_hw_health_check(ldv_work_struct_5_0);
#line 727
    ldv_work_5_2 = 1;
  } else {

  }
#line 730
  goto ldv_56632;
  case 3: ;
#line 732
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 733
    ldv_work_5_3 = 4;
#line 734
    beiscsi_hw_health_check(ldv_work_struct_5_0);
#line 735
    ldv_work_5_3 = 1;
  } else {

  }
#line 738
  goto ldv_56632;
  default: 
#line 739
  ldv_stop();
  }
  ldv_56632: ;
#line 741
  return;
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 746
  if ((unsigned long )handler == (unsigned long )(& be_isr_mcc)) {
#line 747
    return (1);
  } else {

  }
#line 749
  return (0);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_suitable_irq_3(int line , void *data ) 
{ 


  {
#line 754
  if (ldv_irq_3_0 != 0 && line == ldv_irq_line_3_0) {
#line 755
    ldv_irq_3_0 = 0;
#line 756
    return;
  } else {

  }
#line 758
  if (ldv_irq_3_1 != 0 && line == ldv_irq_line_3_1) {
#line 759
    ldv_irq_3_1 = 0;
#line 760
    return;
  } else {

  }
#line 762
  if (ldv_irq_3_2 != 0 && line == ldv_irq_line_3_2) {
#line 763
    ldv_irq_3_2 = 0;
#line 764
    return;
  } else {

  }
#line 766
  if (ldv_irq_3_3 != 0 && line == ldv_irq_line_3_3) {
#line 767
    ldv_irq_3_3 = 0;
#line 768
    return;
  } else {

  }
#line 770
  return;
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int reg_check_3(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 775
  if ((unsigned long )handler == (unsigned long )(& be_isr)) {
#line 776
    return (1);
  } else {

  }
#line 778
  return (0);
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 784
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 786
    ldv_work_4_0 = 1;
  } else {

  }
#line 788
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 790
    ldv_work_4_1 = 1;
  } else {

  }
#line 792
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 794
    ldv_work_4_2 = 1;
  } else {

  }
#line 796
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 798
    ldv_work_4_3 = 1;
  } else {

  }
#line 799
  return;
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 804
  ldv_work_4_0 = 0;
#line 805
  ldv_work_4_1 = 0;
#line 806
  ldv_work_4_2 = 0;
#line 807
  ldv_work_4_3 = 0;
#line 808
  return;
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 813
  tmp = __VERIFIER_nondet_int();
#line 813
  irq_retval = (irqreturn_t )tmp;
#line 815
  if (state != 0) {
#line 816
    tmp___0 = __VERIFIER_nondet_int();
#line 816
    switch (tmp___0) {
    case 0: ;
#line 818
    if (state == 1) {
#line 819
      LDV_IN_INTERRUPT = 2;
#line 820
      irq_retval = be_isr_msix(line, data);
#line 821
      LDV_IN_INTERRUPT = 1;
#line 822
      return (state);
    } else {

    }
#line 825
    goto ldv_56664;
    default: 
#line 826
    ldv_stop();
    }
    ldv_56664: ;
  } else {

  }
#line 829
  return (state);
}
}
#line 834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_work_6(struct work_struct *work ) 
{ 


  {
#line 837
  if ((ldv_work_6_0 == 2 || ldv_work_6_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_0) {
#line 839
    beiscsi_process_all_cqs(work);
#line 840
    ldv_work_6_0 = 1;
#line 841
    return;
  } else {

  }
#line 843
  if ((ldv_work_6_1 == 2 || ldv_work_6_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_1) {
#line 845
    beiscsi_process_all_cqs(work);
#line 846
    ldv_work_6_1 = 1;
#line 847
    return;
  } else {

  }
#line 849
  if ((ldv_work_6_2 == 2 || ldv_work_6_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_2) {
#line 851
    beiscsi_process_all_cqs(work);
#line 852
    ldv_work_6_2 = 1;
#line 853
    return;
  } else {

  }
#line 855
  if ((ldv_work_6_3 == 2 || ldv_work_6_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_3) {
#line 857
    beiscsi_process_all_cqs(work);
#line 858
    ldv_work_6_3 = 1;
#line 859
    return;
  } else {

  }
#line 861
  return;
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void choose_interrupt_3(void) 
{ 
  int tmp ;

  {
#line 865
  tmp = __VERIFIER_nondet_int();
#line 865
  switch (tmp) {
  case 0: 
#line 867
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_0, ldv_irq_line_3_0, ldv_irq_data_3_0);
#line 869
  goto ldv_56677;
  case 1: 
#line 871
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_1, ldv_irq_line_3_1, ldv_irq_data_3_1);
#line 873
  goto ldv_56677;
  case 2: 
#line 875
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_2, ldv_irq_line_3_2, ldv_irq_data_3_2);
#line 877
  goto ldv_56677;
  case 3: 
#line 879
  ldv_irq_3_0 = ldv_irq_3(ldv_irq_3_3, ldv_irq_line_3_3, ldv_irq_data_3_3);
#line 881
  goto ldv_56677;
  default: 
#line 882
  ldv_stop();
  }
  ldv_56677: ;
#line 884
  return;
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 891
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 893
    beiscsi_process_all_cqs(work);
#line 894
    ldv_work_4_0 = 1;
#line 895
    return;
  } else {

  }
#line 897
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 899
    beiscsi_process_all_cqs(work);
#line 900
    ldv_work_4_1 = 1;
#line 901
    return;
  } else {

  }
#line 903
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 905
    beiscsi_process_all_cqs(work);
#line 906
    ldv_work_4_2 = 1;
#line 907
    return;
  } else {

  }
#line 909
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 911
    beiscsi_process_all_cqs(work);
#line 912
    ldv_work_4_3 = 1;
#line 913
    return;
  } else {

  }
#line 915
  return;
}
}
#line 918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_pci_driver_7(void) 
{ 
  void *tmp ;

  {
#line 919
  tmp = ldv_init_zalloc(2976UL);
#line 919
  beiscsi_pci_driver_group1 = (struct pci_dev *)tmp;
#line 920
  return;
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int main(void) 
{ 
  char *ldvarg1 ;
  void *tmp ;
  struct device *ldvarg0 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg2 ;
  void *tmp___1 ;
  struct pci_device_id *ldvarg3 ;
  void *tmp___2 ;
  char *ldvarg4 ;
  void *tmp___3 ;
  size_t ldvarg5 ;
  char *ldvarg6 ;
  void *tmp___4 ;
  char *ldvarg8 ;
  void *tmp___5 ;
  struct device *ldvarg7 ;
  void *tmp___6 ;
  struct device_attribute *ldvarg9 ;
  void *tmp___7 ;
  char *ldvarg11 ;
  void *tmp___8 ;
  struct device *ldvarg10 ;
  void *tmp___9 ;
  struct device_attribute *ldvarg12 ;
  void *tmp___10 ;
  enum pci_channel_state ldvarg13 ;
  struct device *ldvarg14 ;
  void *tmp___11 ;
  struct device_attribute *ldvarg16 ;
  void *tmp___12 ;
  char *ldvarg15 ;
  void *tmp___13 ;
  char *ldvarg18 ;
  void *tmp___14 ;
  struct device *ldvarg17 ;
  void *tmp___15 ;
  struct device_attribute *ldvarg19 ;
  void *tmp___16 ;
  char *ldvarg21 ;
  void *tmp___17 ;
  struct device *ldvarg20 ;
  void *tmp___18 ;
  struct device_attribute *ldvarg22 ;
  void *tmp___19 ;
  char *ldvarg51 ;
  void *tmp___20 ;
  struct iscsi_stats *ldvarg32 ;
  void *tmp___21 ;
  uint32_t ldvarg23 ;
  char *ldvarg43 ;
  void *tmp___22 ;
  int ldvarg42 ;
  int ldvarg56 ;
  int ldvarg50 ;
  int *ldvarg46 ;
  void *tmp___23 ;
  int ldvarg58 ;
  int ldvarg37 ;
  uint8_t ldvarg53 ;
  int ldvarg29 ;
  enum iscsi_param ldvarg44 ;
  char *ldvarg24 ;
  void *tmp___24 ;
  char *ldvarg35 ;
  void *tmp___25 ;
  enum iscsi_param_type ldvarg38 ;
  char *ldvarg33 ;
  void *tmp___26 ;
  int *ldvarg48 ;
  void *tmp___27 ;
  uint16_t ldvarg28 ;
  enum iscsi_host_param ldvarg34 ;
  struct iscsi_conn *ldvarg47 ;
  void *tmp___28 ;
  uint32_t ldvarg39 ;
  struct bsg_job *ldvarg31 ;
  void *tmp___29 ;
  char *ldvarg60 ;
  void *tmp___30 ;
  int ldvarg41 ;
  struct sockaddr *ldvarg59 ;
  void *tmp___31 ;
  itt_t ldvarg49 ;
  uint64_t ldvarg57 ;
  enum iscsi_param ldvarg55 ;
  struct iscsi_iface *ldvarg36 ;
  void *tmp___32 ;
  void *ldvarg40 ;
  void *tmp___33 ;
  uint32_t ldvarg45 ;
  uint16_t ldvarg27 ;
  uint32_t ldvarg26 ;
  int ldvarg30 ;
  char *ldvarg54 ;
  void *tmp___34 ;
  enum iscsi_param ldvarg61 ;
  struct iscsi_hdr *ldvarg25 ;
  void *tmp___35 ;
  enum iscsi_param ldvarg52 ;
  struct scsi_target *ldvarg63 ;
  void *tmp___36 ;
  int ldvarg64 ;
  struct Scsi_Host *ldvarg62 ;
  void *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;

  {
#line 942
  tmp = ldv_init_zalloc(1UL);
#line 942
  ldvarg1 = (char *)tmp;
#line 943
  tmp___0 = ldv_init_zalloc(1416UL);
#line 943
  ldvarg0 = (struct device *)tmp___0;
#line 944
  tmp___1 = ldv_init_zalloc(48UL);
#line 944
  ldvarg2 = (struct device_attribute *)tmp___1;
#line 945
  tmp___2 = ldv_init_zalloc(32UL);
#line 945
  ldvarg3 = (struct pci_device_id *)tmp___2;
#line 946
  tmp___3 = ldv_init_zalloc(1UL);
#line 946
  ldvarg4 = (char *)tmp___3;
#line 948
  tmp___4 = ldv_init_zalloc(1UL);
#line 948
  ldvarg6 = (char *)tmp___4;
#line 949
  tmp___5 = ldv_init_zalloc(1UL);
#line 949
  ldvarg8 = (char *)tmp___5;
#line 950
  tmp___6 = ldv_init_zalloc(1416UL);
#line 950
  ldvarg7 = (struct device *)tmp___6;
#line 951
  tmp___7 = ldv_init_zalloc(48UL);
#line 951
  ldvarg9 = (struct device_attribute *)tmp___7;
#line 952
  tmp___8 = ldv_init_zalloc(1UL);
#line 952
  ldvarg11 = (char *)tmp___8;
#line 953
  tmp___9 = ldv_init_zalloc(1416UL);
#line 953
  ldvarg10 = (struct device *)tmp___9;
#line 954
  tmp___10 = ldv_init_zalloc(48UL);
#line 954
  ldvarg12 = (struct device_attribute *)tmp___10;
#line 956
  tmp___11 = ldv_init_zalloc(1416UL);
#line 956
  ldvarg14 = (struct device *)tmp___11;
#line 957
  tmp___12 = ldv_init_zalloc(48UL);
#line 957
  ldvarg16 = (struct device_attribute *)tmp___12;
#line 958
  tmp___13 = ldv_init_zalloc(1UL);
#line 958
  ldvarg15 = (char *)tmp___13;
#line 959
  tmp___14 = ldv_init_zalloc(1UL);
#line 959
  ldvarg18 = (char *)tmp___14;
#line 960
  tmp___15 = ldv_init_zalloc(1416UL);
#line 960
  ldvarg17 = (struct device *)tmp___15;
#line 961
  tmp___16 = ldv_init_zalloc(48UL);
#line 961
  ldvarg19 = (struct device_attribute *)tmp___16;
#line 962
  tmp___17 = ldv_init_zalloc(1UL);
#line 962
  ldvarg21 = (char *)tmp___17;
#line 963
  tmp___18 = ldv_init_zalloc(1416UL);
#line 963
  ldvarg20 = (struct device *)tmp___18;
#line 964
  tmp___19 = ldv_init_zalloc(48UL);
#line 964
  ldvarg22 = (struct device_attribute *)tmp___19;
#line 965
  tmp___20 = ldv_init_zalloc(1UL);
#line 965
  ldvarg51 = (char *)tmp___20;
#line 966
  tmp___21 = ldv_init_zalloc(96UL);
#line 966
  ldvarg32 = (struct iscsi_stats *)tmp___21;
#line 968
  tmp___22 = ldv_init_zalloc(1UL);
#line 968
  ldvarg43 = (char *)tmp___22;
#line 972
  tmp___23 = ldv_init_zalloc(4UL);
#line 972
  ldvarg46 = (int *)tmp___23;
#line 978
  tmp___24 = ldv_init_zalloc(1UL);
#line 978
  ldvarg24 = (char *)tmp___24;
#line 979
  tmp___25 = ldv_init_zalloc(1UL);
#line 979
  ldvarg35 = (char *)tmp___25;
#line 981
  tmp___26 = ldv_init_zalloc(1UL);
#line 981
  ldvarg33 = (char *)tmp___26;
#line 982
  tmp___27 = ldv_init_zalloc(4UL);
#line 982
  ldvarg48 = (int *)tmp___27;
#line 985
  tmp___28 = ldv_init_zalloc(776UL);
#line 985
  ldvarg47 = (struct iscsi_conn *)tmp___28;
#line 987
  tmp___29 = ldv_init_zalloc(80UL);
#line 987
  ldvarg31 = (struct bsg_job *)tmp___29;
#line 988
  tmp___30 = ldv_init_zalloc(1UL);
#line 988
  ldvarg60 = (char *)tmp___30;
#line 990
  tmp___31 = ldv_init_zalloc(16UL);
#line 990
  ldvarg59 = (struct sockaddr *)tmp___31;
#line 994
  tmp___32 = ldv_init_zalloc(1440UL);
#line 994
  ldvarg36 = (struct iscsi_iface *)tmp___32;
#line 995
  tmp___33 = ldv_init_zalloc(1UL);
#line 995
  ldvarg40 = tmp___33;
#line 1000
  tmp___34 = ldv_init_zalloc(1UL);
#line 1000
  ldvarg54 = (char *)tmp___34;
#line 1002
  tmp___35 = ldv_init_zalloc(48UL);
#line 1002
  ldvarg25 = (struct iscsi_hdr *)tmp___35;
#line 1004
  tmp___36 = ldv_init_zalloc(1504UL);
#line 1004
  ldvarg63 = (struct scsi_target *)tmp___36;
#line 1006
  tmp___37 = ldv_init_zalloc(3816UL);
#line 1006
  ldvarg62 = (struct Scsi_Host *)tmp___37;
#line 940
  ldv_initialize();
#line 947
  ldv_memset((void *)(& ldvarg5), 0, 8UL);
#line 955
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 967
  ldv_memset((void *)(& ldvarg23), 0, 4UL);
#line 969
  ldv_memset((void *)(& ldvarg42), 0, 4UL);
#line 970
  ldv_memset((void *)(& ldvarg56), 0, 4UL);
#line 971
  ldv_memset((void *)(& ldvarg50), 0, 4UL);
#line 973
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 974
  ldv_memset((void *)(& ldvarg37), 0, 4UL);
#line 975
  ldv_memset((void *)(& ldvarg53), 0, 1UL);
#line 976
  ldv_memset((void *)(& ldvarg29), 0, 4UL);
#line 977
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
#line 980
  ldv_memset((void *)(& ldvarg38), 0, 4UL);
#line 983
  ldv_memset((void *)(& ldvarg28), 0, 2UL);
#line 984
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
#line 986
  ldv_memset((void *)(& ldvarg39), 0, 4UL);
#line 989
  ldv_memset((void *)(& ldvarg41), 0, 4UL);
#line 991
  ldv_memset((void *)(& ldvarg49), 0, 4UL);
#line 992
  ldv_memset((void *)(& ldvarg57), 0, 8UL);
#line 993
  ldv_memset((void *)(& ldvarg55), 0, 4UL);
#line 996
  ldv_memset((void *)(& ldvarg45), 0, 4UL);
#line 997
  ldv_memset((void *)(& ldvarg27), 0, 2UL);
#line 998
  ldv_memset((void *)(& ldvarg26), 0, 4UL);
#line 999
  ldv_memset((void *)(& ldvarg30), 0, 4UL);
#line 1001
  ldv_memset((void *)(& ldvarg61), 0, 4UL);
#line 1003
  ldv_memset((void *)(& ldvarg52), 0, 4UL);
#line 1005
  ldv_memset((void *)(& ldvarg64), 0, 4UL);
#line 1008
  ldv_state_variable_11 = 0;
#line 1009
  ldv_state_variable_7 = 0;
#line 1010
  ldv_state_variable_17 = 0;
#line 1012
  ldv_state_variable_2 = 1;
#line 1014
  ldv_state_variable_1 = 1;
#line 1015
  ref_cnt = 0;
#line 1016
  ldv_state_variable_0 = 1;
#line 1017
  ldv_state_variable_16 = 0;
#line 1018
  ldv_state_variable_13 = 0;
#line 1020
  work_init_6();
#line 1022
  ldv_state_variable_6 = 1;
#line 1024
  ldv_state_variable_3 = 1;
#line 1025
  ldv_state_variable_9 = 0;
#line 1026
  ldv_state_variable_12 = 0;
#line 1027
  ldv_state_variable_14 = 0;
#line 1028
  ldv_state_variable_15 = 0;
#line 1029
  ldv_state_variable_8 = 0;
#line 1031
  work_init_4();
#line 1033
  ldv_state_variable_4 = 1;
#line 1034
  ldv_state_variable_10 = 0;
#line 1036
  work_init_5();
#line 1038
  ldv_state_variable_5 = 1;
  ldv_56880: 
#line 1040
  tmp___38 = __VERIFIER_nondet_int();
#line 1040
  switch (tmp___38) {
  case 0: ;
#line 1044
  if (ldv_state_variable_11 != 0) {
#line 1045
    tmp___39 = __VERIFIER_nondet_int();
#line 1045
    switch (tmp___39) {
    case 0: ;
#line 1048
    if (ldv_state_variable_11 == 1) {
#line 1050
      beiscsi_free_session_disp(ldvarg0, ldvarg2, ldvarg1);
#line 1052
      ldv_state_variable_11 = 1;
    } else {

    }
#line 1055
    goto ldv_56784;
    default: 
#line 1056
    ldv_stop();
    }
    ldv_56784: ;
  } else {

  }
#line 1060
  goto ldv_56786;
  case 1: ;
#line 1064
  if (ldv_state_variable_7 != 0) {
#line 1065
    tmp___40 = __VERIFIER_nondet_int();
#line 1065
    switch (tmp___40) {
    case 0: ;
#line 1068
    if (ldv_state_variable_7 == 1) {
#line 1070
      ldv_retval_0 = beiscsi_dev_probe(beiscsi_pci_driver_group1, (struct pci_device_id  const  *)ldvarg3);
#line 1071
      if (ldv_retval_0 == 0) {
#line 1072
        ldv_state_variable_7 = 2;
#line 1073
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1077
    goto ldv_56789;
    case 1: ;
#line 1080
    if (ldv_state_variable_7 == 2) {
#line 1082
      beiscsi_shutdown(beiscsi_pci_driver_group1);
#line 1083
      ldv_state_variable_7 = 2;
    } else {

    }
#line 1086
    goto ldv_56789;
    case 2: ;
#line 1089
    if (ldv_state_variable_7 == 2) {
#line 1091
      beiscsi_remove(beiscsi_pci_driver_group1);
#line 1092
      ldv_state_variable_7 = 1;
    } else {

    }
#line 1095
    goto ldv_56789;
    default: 
#line 1096
    ldv_stop();
    }
    ldv_56789: ;
  } else {

  }
#line 1100
  goto ldv_56786;
  case 2: ;
#line 1104
  if (ldv_state_variable_17 != 0) {
#line 1105
    tmp___41 = __VERIFIER_nondet_int();
#line 1105
    switch (tmp___41) {
    case 0: ;
#line 1108
    if (ldv_state_variable_17 == 1) {
#line 1110
      beiscsi_log_enable_store(dev_attr_beiscsi_log_enable_group1, dev_attr_beiscsi_log_enable_group0,
                               (char const   *)ldvarg6, ldvarg5);
#line 1112
      ldv_state_variable_17 = 1;
    } else {

    }
#line 1115
    goto ldv_56795;
    case 1: ;
#line 1118
    if (ldv_state_variable_17 == 1) {
#line 1120
      beiscsi_log_enable_disp(dev_attr_beiscsi_log_enable_group1, dev_attr_beiscsi_log_enable_group0,
                              ldvarg4);
#line 1122
      ldv_state_variable_17 = 1;
    } else {

    }
#line 1125
    goto ldv_56795;
    default: 
#line 1126
    ldv_stop();
    }
    ldv_56795: ;
  } else {

  }
#line 1130
  goto ldv_56786;
  case 3: ;
#line 1134
  if (ldv_state_variable_2 != 0) {
#line 1135
    choose_interrupt_2();
  } else {

  }
#line 1138
  goto ldv_56786;
  case 4: ;
#line 1142
  if (ldv_state_variable_1 != 0) {
#line 1143
    choose_interrupt_1();
  } else {

  }
#line 1146
  goto ldv_56786;
  case 5: ;
#line 1150
  if (ldv_state_variable_0 != 0) {
#line 1151
    tmp___42 = __VERIFIER_nondet_int();
#line 1151
    switch (tmp___42) {
    case 0: ;
#line 1154
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1156
      beiscsi_module_exit();
#line 1157
      ldv_state_variable_0 = 2;
#line 1158
      goto ldv_final;
    } else {

    }
#line 1161
    goto ldv_56803;
    case 1: ;
#line 1164
    if (ldv_state_variable_0 == 1) {
#line 1166
      ldv_retval_1 = beiscsi_module_init();
#line 1168
      if (ldv_retval_1 == 0) {
#line 1169
        ldv_state_variable_0 = 3;
#line 1170
        ldv_state_variable_13 = 1;
#line 1171
        ldv_state_variable_10 = 1;
#line 1172
        ldv_initialize_scsi_host_template_10();
#line 1173
        ldv_state_variable_16 = 1;
#line 1174
        ldv_state_variable_8 = 1;
#line 1175
        ldv_initialize_iscsi_transport_8();
#line 1176
        ldv_state_variable_14 = 1;
#line 1177
        ldv_state_variable_15 = 1;
#line 1178
        ldv_state_variable_12 = 1;
#line 1179
        ldv_state_variable_17 = 1;
#line 1180
        ldv_initialize_device_attribute_17();
#line 1181
        ldv_state_variable_9 = 1;
#line 1182
        ldv_initialize_pci_error_handlers_9();
#line 1183
        ldv_state_variable_11 = 1;
      } else {

      }
#line 1185
      if (ldv_retval_1 != 0) {
#line 1186
        ldv_state_variable_0 = 2;
#line 1187
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1191
    goto ldv_56803;
    default: 
#line 1192
    ldv_stop();
    }
    ldv_56803: ;
  } else {

  }
#line 1196
  goto ldv_56786;
  case 6: ;
#line 1200
  if (ldv_state_variable_16 != 0) {
#line 1201
    tmp___43 = __VERIFIER_nondet_int();
#line 1201
    switch (tmp___43) {
    case 0: ;
#line 1204
    if (ldv_state_variable_16 == 1) {
#line 1206
      beiscsi_drvr_ver_disp(ldvarg7, ldvarg9, ldvarg8);
#line 1208
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1211
    goto ldv_56808;
    default: 
#line 1212
    ldv_stop();
    }
    ldv_56808: ;
  } else {

  }
#line 1216
  goto ldv_56786;
  case 7: ;
#line 1220
  if (ldv_state_variable_13 != 0) {
#line 1221
    tmp___44 = __VERIFIER_nondet_int();
#line 1221
    switch (tmp___44) {
    case 0: ;
#line 1224
    if (ldv_state_variable_13 == 1) {
#line 1226
      beiscsi_phys_port_disp(ldvarg10, ldvarg12, ldvarg11);
#line 1228
      ldv_state_variable_13 = 1;
    } else {

    }
#line 1231
    goto ldv_56812;
    default: 
#line 1232
    ldv_stop();
    }
    ldv_56812: ;
  } else {

  }
#line 1236
  goto ldv_56786;
  case 8: ;
#line 1240
  if (ldv_state_variable_6 != 0) {
#line 1241
    invoke_work_6();
  } else {

  }
#line 1244
  goto ldv_56786;
  case 9: ;
#line 1248
  if (ldv_state_variable_3 != 0) {
#line 1249
    choose_interrupt_3();
  } else {

  }
#line 1252
  goto ldv_56786;
  case 10: ;
#line 1256
  if (ldv_state_variable_9 != 0) {
#line 1257
    tmp___45 = __VERIFIER_nondet_int();
#line 1257
    switch (tmp___45) {
    case 0: ;
#line 1260
    if (ldv_state_variable_9 == 1) {
#line 1262
      beiscsi_eeh_reset(beiscsi_eeh_handlers_group0);
#line 1264
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1267
    if (ldv_state_variable_9 == 3) {
#line 1269
      beiscsi_eeh_reset(beiscsi_eeh_handlers_group0);
#line 1271
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1274
    if (ldv_state_variable_9 == 2) {
#line 1276
      beiscsi_eeh_reset(beiscsi_eeh_handlers_group0);
#line 1278
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1281
    goto ldv_56818;
    case 1: ;
#line 1284
    if (ldv_state_variable_9 == 1) {
#line 1286
      beiscsi_eeh_err_detected(beiscsi_eeh_handlers_group0, (pci_channel_state_t )ldvarg13);
#line 1288
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1291
    if (ldv_state_variable_9 == 3) {
#line 1293
      beiscsi_eeh_err_detected(beiscsi_eeh_handlers_group0, (pci_channel_state_t )ldvarg13);
#line 1295
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1298
    if (ldv_state_variable_9 == 2) {
#line 1300
      beiscsi_eeh_err_detected(beiscsi_eeh_handlers_group0, (pci_channel_state_t )ldvarg13);
#line 1302
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1305
    goto ldv_56818;
    case 2: ;
#line 1308
    if (ldv_state_variable_9 == 3) {
#line 1310
      beiscsi_eeh_resume(beiscsi_eeh_handlers_group0);
#line 1312
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1315
    goto ldv_56818;
    case 3: ;
#line 1318
    if (ldv_state_variable_9 == 2) {
#line 1320
      ldv_suspend_9();
#line 1322
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1325
    goto ldv_56818;
    case 4: ;
#line 1328
    if (ldv_state_variable_9 == 3) {
#line 1330
      ldv_release_9();
#line 1332
      ldv_state_variable_9 = 1;
#line 1333
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1336
    if (ldv_state_variable_9 == 2) {
#line 1338
      ldv_release_9();
#line 1340
      ldv_state_variable_9 = 1;
#line 1341
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1344
    goto ldv_56818;
    case 5: ;
#line 1347
    if (ldv_state_variable_9 == 1) {
#line 1349
      ldv_probe_9();
#line 1351
      ldv_state_variable_9 = 2;
#line 1352
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1355
    goto ldv_56818;
    default: 
#line 1356
    ldv_stop();
    }
    ldv_56818: ;
  } else {

  }
#line 1360
  goto ldv_56786;
  case 11: ;
#line 1364
  if (ldv_state_variable_12 != 0) {
#line 1365
    tmp___46 = __VERIFIER_nondet_int();
#line 1365
    switch (tmp___46) {
    case 0: ;
#line 1368
    if (ldv_state_variable_12 == 1) {
#line 1370
      beiscsi_active_session_disp(ldvarg14, ldvarg16, ldvarg15);
#line 1372
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1375
    goto ldv_56827;
    default: 
#line 1376
    ldv_stop();
    }
    ldv_56827: ;
  } else {

  }
#line 1380
  goto ldv_56786;
  case 12: ;
#line 1384
  if (ldv_state_variable_14 != 0) {
#line 1385
    tmp___47 = __VERIFIER_nondet_int();
#line 1385
    switch (tmp___47) {
    case 0: ;
#line 1388
    if (ldv_state_variable_14 == 1) {
#line 1390
      beiscsi_fw_ver_disp(ldvarg17, ldvarg19, ldvarg18);
#line 1392
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1395
    goto ldv_56831;
    default: 
#line 1396
    ldv_stop();
    }
    ldv_56831: ;
  } else {

  }
#line 1400
  goto ldv_56786;
  case 13: ;
#line 1404
  if (ldv_state_variable_15 != 0) {
#line 1405
    tmp___48 = __VERIFIER_nondet_int();
#line 1405
    switch (tmp___48) {
    case 0: ;
#line 1408
    if (ldv_state_variable_15 == 1) {
#line 1410
      beiscsi_adap_family_disp(ldvarg20, ldvarg22, ldvarg21);
#line 1412
      ldv_state_variable_15 = 1;
    } else {

    }
#line 1415
    goto ldv_56835;
    default: 
#line 1416
    ldv_stop();
    }
    ldv_56835: ;
  } else {

  }
#line 1420
  goto ldv_56786;
  case 14: ;
#line 1424
  if (ldv_state_variable_8 != 0) {
#line 1425
    tmp___49 = __VERIFIER_nondet_int();
#line 1425
    switch (tmp___49) {
    case 0: ;
#line 1428
    if (ldv_state_variable_8 == 1) {
#line 1430
      beiscsi_ep_get_param(beiscsi_iscsi_transport_group4, ldvarg61, ldvarg60);
#line 1432
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1435
    if (ldv_state_variable_8 == 2) {
#line 1437
      beiscsi_ep_get_param(beiscsi_iscsi_transport_group4, ldvarg61, ldvarg60);
#line 1439
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1442
    goto ldv_56839;
    case 1: ;
#line 1445
    if (ldv_state_variable_8 == 1) {
#line 1447
      beiscsi_ep_connect(beiscsi_iscsi_transport_group0, ldvarg59, ldvarg58);
#line 1449
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1452
    if (ldv_state_variable_8 == 2) {
#line 1454
      beiscsi_ep_connect(beiscsi_iscsi_transport_group0, ldvarg59, ldvarg58);
#line 1456
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1459
    goto ldv_56839;
    case 2: ;
#line 1462
    if (ldv_state_variable_8 == 1) {
#line 1464
      beiscsi_conn_bind(beiscsi_iscsi_transport_group1, beiscsi_iscsi_transport_group2,
                        ldvarg57, ldvarg56);
#line 1466
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1469
    if (ldv_state_variable_8 == 2) {
#line 1471
      beiscsi_conn_bind(beiscsi_iscsi_transport_group1, beiscsi_iscsi_transport_group2,
                        ldvarg57, ldvarg56);
#line 1473
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1476
    goto ldv_56839;
    case 3: ;
#line 1479
    if (ldv_state_variable_8 == 1) {
#line 1481
      iscsi_conn_get_param(beiscsi_iscsi_transport_group2, ldvarg55, ldvarg54);
#line 1483
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1486
    if (ldv_state_variable_8 == 2) {
#line 1488
      iscsi_conn_get_param(beiscsi_iscsi_transport_group2, ldvarg55, ldvarg54);
#line 1490
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1493
    goto ldv_56839;
    case 4: ;
#line 1496
    if (ldv_state_variable_8 == 1) {
#line 1498
      beiscsi_cleanup_task(beiscsi_iscsi_transport_group3);
#line 1500
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1503
    if (ldv_state_variable_8 == 2) {
#line 1505
      beiscsi_cleanup_task(beiscsi_iscsi_transport_group3);
#line 1507
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1510
    goto ldv_56839;
    case 5: ;
#line 1513
    if (ldv_state_variable_8 == 1) {
#line 1515
      beiscsi_alloc_pdu(beiscsi_iscsi_transport_group3, (int )ldvarg53);
#line 1517
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1520
    if (ldv_state_variable_8 == 2) {
#line 1522
      beiscsi_alloc_pdu(beiscsi_iscsi_transport_group3, (int )ldvarg53);
#line 1524
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1527
    goto ldv_56839;
    case 6: ;
#line 1530
    if (ldv_state_variable_8 == 1) {
#line 1532
      beiscsi_session_destroy(beiscsi_iscsi_transport_group1);
#line 1534
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1537
    if (ldv_state_variable_8 == 2) {
#line 1539
      beiscsi_session_destroy(beiscsi_iscsi_transport_group1);
#line 1541
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1544
    goto ldv_56839;
    case 7: ;
#line 1547
    if (ldv_state_variable_8 == 1) {
#line 1549
      beiscsi_set_param(beiscsi_iscsi_transport_group2, ldvarg52, ldvarg51, ldvarg50);
#line 1551
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1554
    if (ldv_state_variable_8 == 2) {
#line 1556
      beiscsi_set_param(beiscsi_iscsi_transport_group2, ldvarg52, ldvarg51, ldvarg50);
#line 1558
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1561
    goto ldv_56839;
    case 8: ;
#line 1564
    if (ldv_state_variable_8 == 1) {
#line 1566
      beiscsi_conn_start(beiscsi_iscsi_transport_group2);
#line 1568
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1571
    if (ldv_state_variable_8 == 2) {
#line 1573
      beiscsi_conn_start(beiscsi_iscsi_transport_group2);
#line 1575
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1578
    goto ldv_56839;
    case 9: ;
#line 1581
    if (ldv_state_variable_8 == 1) {
#line 1583
      beiscsi_parse_pdu(ldvarg47, ldvarg49, ldvarg48, ldvarg46);
#line 1585
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1588
    if (ldv_state_variable_8 == 2) {
#line 1590
      beiscsi_parse_pdu(ldvarg47, ldvarg49, ldvarg48, ldvarg46);
#line 1592
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1595
    goto ldv_56839;
    case 10: ;
#line 1598
    if (ldv_state_variable_8 == 1) {
#line 1600
      beiscsi_conn_create(beiscsi_iscsi_transport_group1, ldvarg45);
#line 1602
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1605
    if (ldv_state_variable_8 == 2) {
#line 1607
      beiscsi_conn_create(beiscsi_iscsi_transport_group1, ldvarg45);
#line 1609
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1612
    goto ldv_56839;
    case 11: ;
#line 1615
    if (ldv_state_variable_8 == 2) {
#line 1617
      beiscsi_ep_disconnect(beiscsi_iscsi_transport_group4);
#line 1619
      ldv_state_variable_8 = 1;
#line 1620
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1623
    goto ldv_56839;
    case 12: ;
#line 1626
    if (ldv_state_variable_8 == 1) {
#line 1628
      iscsi_session_get_param(beiscsi_iscsi_transport_group1, ldvarg44, ldvarg43);
#line 1630
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1633
    if (ldv_state_variable_8 == 2) {
#line 1635
      iscsi_session_get_param(beiscsi_iscsi_transport_group1, ldvarg44, ldvarg43);
#line 1637
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1640
    goto ldv_56839;
    case 13: ;
#line 1643
    if (ldv_state_variable_8 == 1) {
#line 1645
      be2iscsi_attr_is_visible(ldvarg41, ldvarg42);
#line 1647
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1650
    if (ldv_state_variable_8 == 2) {
#line 1652
      be2iscsi_attr_is_visible(ldvarg41, ldvarg42);
#line 1654
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1657
    goto ldv_56839;
    case 14: ;
#line 1660
    if (ldv_state_variable_8 == 1) {
#line 1662
      be2iscsi_iface_set_param(beiscsi_iscsi_transport_group0, ldvarg40, ldvarg39);
#line 1664
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1667
    if (ldv_state_variable_8 == 2) {
#line 1669
      be2iscsi_iface_set_param(beiscsi_iscsi_transport_group0, ldvarg40, ldvarg39);
#line 1671
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1674
    goto ldv_56839;
    case 15: ;
#line 1677
    if (ldv_state_variable_8 == 1) {
#line 1679
      be2iscsi_iface_get_param(ldvarg36, ldvarg38, ldvarg37, ldvarg35);
#line 1681
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1684
    if (ldv_state_variable_8 == 2) {
#line 1686
      be2iscsi_iface_get_param(ldvarg36, ldvarg38, ldvarg37, ldvarg35);
#line 1688
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1691
    goto ldv_56839;
    case 16: ;
#line 1694
    if (ldv_state_variable_8 == 1) {
#line 1696
      beiscsi_get_host_param(beiscsi_iscsi_transport_group0, ldvarg34, ldvarg33);
#line 1698
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1701
    if (ldv_state_variable_8 == 2) {
#line 1703
      beiscsi_get_host_param(beiscsi_iscsi_transport_group0, ldvarg34, ldvarg33);
#line 1705
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1708
    goto ldv_56839;
    case 17: ;
#line 1711
    if (ldv_state_variable_8 == 1) {
#line 1713
      beiscsi_conn_get_stats(beiscsi_iscsi_transport_group2, ldvarg32);
#line 1715
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1718
    if (ldv_state_variable_8 == 2) {
#line 1720
      beiscsi_conn_get_stats(beiscsi_iscsi_transport_group2, ldvarg32);
#line 1722
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1725
    goto ldv_56839;
    case 18: ;
#line 1728
    if (ldv_state_variable_8 == 1) {
#line 1730
      beiscsi_bsg_request(ldvarg31);
#line 1732
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1735
    if (ldv_state_variable_8 == 2) {
#line 1737
      beiscsi_bsg_request(ldvarg31);
#line 1739
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1742
    goto ldv_56839;
    case 19: ;
#line 1745
    if (ldv_state_variable_8 == 1) {
#line 1747
      beiscsi_ep_poll(beiscsi_iscsi_transport_group4, ldvarg30);
#line 1749
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1752
    if (ldv_state_variable_8 == 2) {
#line 1754
      beiscsi_ep_poll(beiscsi_iscsi_transport_group4, ldvarg30);
#line 1756
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1759
    goto ldv_56839;
    case 20: ;
#line 1762
    if (ldv_state_variable_8 == 1) {
#line 1764
      iscsi_conn_stop(beiscsi_iscsi_transport_group2, ldvarg29);
#line 1766
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1769
    if (ldv_state_variable_8 == 2) {
#line 1771
      iscsi_conn_stop(beiscsi_iscsi_transport_group2, ldvarg29);
#line 1773
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1776
    goto ldv_56839;
    case 21: ;
#line 1779
    if (ldv_state_variable_8 == 1) {
#line 1781
      iscsi_session_recovery_timedout(beiscsi_iscsi_transport_group1);
#line 1783
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1786
    if (ldv_state_variable_8 == 2) {
#line 1788
      iscsi_session_recovery_timedout(beiscsi_iscsi_transport_group1);
#line 1790
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1793
    goto ldv_56839;
    case 22: ;
#line 1796
    if (ldv_state_variable_8 == 1) {
#line 1798
      beiscsi_session_create(beiscsi_iscsi_transport_group4, (int )ldvarg28, (int )ldvarg27,
                             ldvarg26);
#line 1800
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1803
    if (ldv_state_variable_8 == 2) {
#line 1805
      beiscsi_session_create(beiscsi_iscsi_transport_group4, (int )ldvarg28, (int )ldvarg27,
                             ldvarg26);
#line 1807
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1810
    goto ldv_56839;
    case 23: ;
#line 1813
    if (ldv_state_variable_8 == 1) {
#line 1815
      iscsi_conn_send_pdu(beiscsi_iscsi_transport_group2, ldvarg25, ldvarg24, ldvarg23);
#line 1817
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1820
    if (ldv_state_variable_8 == 2) {
#line 1822
      iscsi_conn_send_pdu(beiscsi_iscsi_transport_group2, ldvarg25, ldvarg24, ldvarg23);
#line 1824
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1827
    goto ldv_56839;
    case 24: ;
#line 1830
    if (ldv_state_variable_8 == 1) {
#line 1832
      beiscsi_task_xmit(beiscsi_iscsi_transport_group3);
#line 1834
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1837
    if (ldv_state_variable_8 == 2) {
#line 1839
      beiscsi_task_xmit(beiscsi_iscsi_transport_group3);
#line 1841
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1844
    goto ldv_56839;
    case 25: ;
#line 1847
    if (ldv_state_variable_8 == 1) {
#line 1849
      iscsi_conn_teardown(beiscsi_iscsi_transport_group2);
#line 1851
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1854
    if (ldv_state_variable_8 == 2) {
#line 1856
      iscsi_conn_teardown(beiscsi_iscsi_transport_group2);
#line 1858
      ldv_state_variable_8 = 2;
    } else {

    }
#line 1861
    goto ldv_56839;
    case 26: ;
#line 1864
    if (ldv_state_variable_8 == 1) {
#line 1866
      ldv_probe_8();
#line 1868
      ldv_state_variable_8 = 2;
#line 1869
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1872
    goto ldv_56839;
    default: 
#line 1873
    ldv_stop();
    }
    ldv_56839: ;
  } else {

  }
#line 1877
  goto ldv_56786;
  case 15: ;
#line 1881
  if (ldv_state_variable_4 != 0) {
#line 1882
    invoke_work_4();
  } else {

  }
#line 1885
  goto ldv_56786;
  case 16: ;
#line 1889
  if (ldv_state_variable_10 != 0) {
#line 1890
    tmp___50 = __VERIFIER_nondet_int();
#line 1890
    switch (tmp___50) {
    case 0: ;
#line 1893
    if (ldv_state_variable_10 == 1) {
#line 1895
      beiscsi_slave_configure(beiscsi_sht_group1);
#line 1897
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1900
    goto ldv_56870;
    case 1: ;
#line 1903
    if (ldv_state_variable_10 == 1) {
#line 1905
      beiscsi_eh_abort(beiscsi_sht_group0);
#line 1907
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1910
    goto ldv_56870;
    case 2: ;
#line 1913
    if (ldv_state_variable_10 == 1) {
#line 1915
      scsi_change_queue_depth(beiscsi_sht_group1, ldvarg64);
#line 1917
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1920
    goto ldv_56870;
    case 3: ;
#line 1923
    if (ldv_state_variable_10 == 1) {
#line 1925
      iscsi_target_alloc(ldvarg63);
#line 1927
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1930
    goto ldv_56870;
    case 4: ;
#line 1933
    if (ldv_state_variable_10 == 1) {
#line 1935
      iscsi_queuecommand(ldvarg62, beiscsi_sht_group0);
#line 1937
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1940
    goto ldv_56870;
    case 5: ;
#line 1943
    if (ldv_state_variable_10 == 1) {
#line 1945
      iscsi_eh_session_reset(beiscsi_sht_group0);
#line 1947
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1950
    goto ldv_56870;
    case 6: ;
#line 1953
    if (ldv_state_variable_10 == 1) {
#line 1955
      beiscsi_eh_device_reset(beiscsi_sht_group0);
#line 1957
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1960
    goto ldv_56870;
    default: 
#line 1961
    ldv_stop();
    }
    ldv_56870: ;
  } else {

  }
#line 1965
  goto ldv_56786;
  case 17: ;
#line 1969
  if (ldv_state_variable_5 != 0) {
#line 1970
    invoke_work_5();
  } else {

  }
#line 1973
  goto ldv_56786;
  default: 
#line 1974
  ldv_stop();
  }
  ldv_56786: ;
#line 1976
  goto ldv_56880;
  ldv_final: 
#line 1978
  ldv_check_final_state();
#line 1979
  return 0;
}
}
#line 2006 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 2010
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2010
  ldv_func_res = tmp;
#line 2012
  activate_work_6(ldv_func_arg3, 2);
#line 2014
  return (ldv_func_res);
}
}
#line 2017 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 2021
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2021
  ldv_func_res = tmp;
#line 2023
  activate_work_6(& ldv_func_arg3->work, 2);
#line 2025
  return (ldv_func_res);
}
}
#line 2028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 2032
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2032
  ldv_func_res = tmp;
#line 2034
  activate_work_6(ldv_func_arg3, 2);
#line 2036
  return (ldv_func_res);
}
}
#line 2039 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2042
  flush_workqueue(ldv_func_arg1);
#line 2044
  call_and_disable_all_6(2);
#line 2045
  return;
}
}
#line 2047 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 2051
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2051
  ldv_func_res = tmp;
#line 2053
  activate_work_6(& ldv_func_arg3->work, 2);
#line 2055
  return (ldv_func_res);
}
}
#line 2058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
__inline static int ldv_request_irq_24(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2062
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2062
  ldv_func_res = tmp;
#line 2064
  tmp___0 = reg_check_2(handler);
#line 2064
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2065
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 2068
  return (ldv_func_res);
}
}
#line 2071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
__inline static int ldv_request_irq_25(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2075
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2075
  ldv_func_res = tmp;
#line 2077
  tmp___0 = reg_check_2(handler);
#line 2077
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2078
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 2081
  return (ldv_func_res);
}
}
#line 2084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
__inline static int ldv_request_irq_26(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2088
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2088
  ldv_func_res = tmp;
#line 2090
  tmp___0 = reg_check_2(handler);
#line 2090
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 2091
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 2094
  return (ldv_func_res);
}
}
#line 2097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_free_irq_27(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2100
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2102
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 2103
  return;
}
}
#line 2105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2108
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2110
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 2111
  return;
}
}
#line 2113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_free_irq_29(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 2116
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2118
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 2119
  return;
}
}
#line 2121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
bool ldv_cancel_delayed_work_sync_30(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 2125
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 2125
  ldv_func_res = tmp;
#line 2127
  disable_work_6(& ldv_func_arg1->work);
#line 2129
  return (ldv_func_res);
}
}
#line 2132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_destroy_workqueue_31(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2135
  destroy_workqueue(ldv_func_arg1);
#line 2137
  call_and_disable_all_6(2);
#line 2138
  return;
}
}
#line 2140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_destroy_workqueue_32(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2143
  destroy_workqueue(ldv_func_arg1);
#line 2145
  call_and_disable_all_6(2);
#line 2146
  return;
}
}
#line 2148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
int ldv___pci_register_driver_33(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 2152
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2152
  ldv_func_res = tmp;
#line 2154
  ldv_state_variable_7 = 1;
#line 2155
  ldv_pci_driver_7();
#line 2158
  return (ldv_func_res);
}
}
#line 2161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_main.o.c.prepared"
void ldv_pci_unregister_driver_34(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 2164
  pci_unregister_driver(ldv_func_arg1);
#line 2166
  ldv_state_variable_7 = 0;
#line 2167
  return;
}
}
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_57(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_56(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_59(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_58(struct workqueue_struct *ldv_func_arg1 ) ;
#line 273 "include/linux/scatterlist.h"
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
#line 861 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 640
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 746
struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem ) ;
#line 747
struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba ) ;
#line 748
int be_mcc_notify_wait(struct beiscsi_hba *phba ) ;
#line 749
void be_mcc_notify(struct beiscsi_hba *phba ) ;
#line 750
unsigned int alloc_mcc_tag(struct beiscsi_hba *phba ) ;
#line 756
int be_mbox_notify(struct be_ctrl_info *ctrl ) ;
#line 783
int be_cmd_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) ;
#line 1364
void be_wrb_hdr_prepare(struct be_mcc_wrb *wrb , int payload_len , bool embedded ,
                        u8 sge_cnt ) ;
#line 1367
void be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem , u8 opcode ,
                        int cmd_len ) ;
#line 283 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_mgmt.h"
unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba ) ;
#line 285
unsigned int mgmt_reopen_session(struct beiscsi_hba *phba , unsigned int reopen_type ,
                                 unsigned int sess_handle ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static char const   * const  desc_ue_status_low[32U]  = 
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "AXGMAC0",      "AXGMAC1",      "JTAG",      "MPU_INTPEND"};
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static char const   * const  desc_ue_status_hi[32U]  = 
#line 64
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "HOST8",      "HOST9",      "NETC", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_ue_detect(struct beiscsi_hba *phba ) 
{ 
  uint32_t ue_hi ;
  uint32_t ue_lo ;
  uint32_t ue_mask_hi ;
  uint32_t ue_mask_lo ;
  uint8_t i ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 107
  ue_hi = 0U;
#line 107
  ue_lo = 0U;
#line 108
  ue_mask_hi = 0U;
#line 108
  ue_mask_lo = 0U;
#line 109
  i = 0U;
#line 111
  if ((int )phba->ue_detected) {
#line 112
    return;
  } else {

  }
#line 114
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 160, & ue_lo);
#line 116
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 168, & ue_mask_lo);
#line 119
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 164, & ue_hi);
#line 122
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 172, & ue_mask_hi);
#line 126
  ue_lo = ~ ue_mask_lo & ue_lo;
#line 127
  ue_hi = ~ ue_mask_hi & ue_hi;
#line 130
  if (ue_lo != 0U || ue_hi != 0U) {
#line 131
    phba->ue_detected = 1;
#line 132
    log_value = phba->attr_log_enable;
#line 132
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 132
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Error detected on the adapter\n",
                 134);
    } else {

    }
  } else {

  }
#line 137
  if (ue_lo != 0U) {
#line 138
    i = 0U;
#line 138
    goto ldv_54205;
    ldv_54204: ;
#line 139
    if ((int )ue_lo & 1) {
#line 140
      log_value___0 = phba->attr_log_enable;
#line 140
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 140
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : UE_LOW %s bit set\n", 143, desc_ue_status_low[(int )i]);
      } else {

      }
    } else {

    }
#line 138
    ue_lo = ue_lo >> 1;
#line 138
    i = (uint8_t )((int )i + 1);
    ldv_54205: ;
#line 138
    if (ue_lo != 0U) {
#line 140
      goto ldv_54204;
    } else {

    }

  } else {

  }
#line 147
  if (ue_hi != 0U) {
#line 148
    i = 0U;
#line 148
    goto ldv_54209;
    ldv_54208: ;
#line 149
    if ((int )ue_hi & 1) {
#line 150
      log_value___1 = phba->attr_log_enable;
#line 150
      if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 150
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : UE_HIGH %s bit set\n", 153, desc_ue_status_hi[(int )i]);
      } else {

      }
    } else {

    }
#line 148
    ue_hi = ue_hi >> 1;
#line 148
    i = (uint8_t )((int )i + 1);
    ldv_54209: ;
#line 148
    if (ue_hi != 0U) {
#line 150
      goto ldv_54208;
    } else {

    }

  } else {

  }
#line 156
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int be_cmd_modify_eq_delay(struct beiscsi_hba *phba , struct be_set_eqd *set_eqd ,
                           int num ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  unsigned int tag ;
  int i ;
  void *tmp ;

  {
#line 161
  ctrl = & phba->ctrl;
#line 164
  tag = 0U;
#line 167
  spin_lock(& ctrl->mbox_lock);
#line 168
  tag = alloc_mcc_tag(phba);
#line 169
  if (tag == 0U) {
#line 170
    spin_unlock(& ctrl->mbox_lock);
#line 171
    return ((int )tag);
  } else {

  }
#line 174
  wrb = wrb_from_mccq(phba);
#line 175
  tmp = embedded_payload(wrb);
#line 175
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 177
  wrb->tag0 = wrb->tag0 | tag;
#line 178
  be_wrb_hdr_prepare(wrb, 788, 1, 0);
#line 179
  be_cmd_hdr_prepare(& req->hdr, 1, 41, 788);
#line 182
  req->num_eq = (unsigned int )num;
#line 183
  i = 0;
#line 183
  goto ldv_54222;
  ldv_54221: 
#line 184
  req->delay[i].eq_id = (set_eqd + (unsigned long )i)->eq_id;
#line 185
  req->delay[i].phase = 0U;
#line 186
  req->delay[i].delay_multiplier = (set_eqd + (unsigned long )i)->delay_multiplier;
#line 183
  i = i + 1;
  ldv_54222: ;
#line 183
  if (i < num) {
#line 185
    goto ldv_54221;
  } else {

  }
#line 190
  be_mcc_notify(phba);
#line 191
  spin_unlock(& ctrl->mbox_lock);
#line 192
  return ((int )tag);
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_reopen_session(struct beiscsi_hba *phba , unsigned int reopen_type ,
                                 unsigned int sess_handle ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_reopen_session_req *req ;
  unsigned int tag ;
  uint32_t log_value ;
  void *tmp ;

  {
#line 209
  ctrl = & phba->ctrl;
#line 212
  tag = 0U;
#line 214
  log_value = phba->attr_log_enable;
#line 214
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 214
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In bescsi_get_boot_target\n",
               216);
  } else {

  }
#line 218
  spin_lock(& ctrl->mbox_lock);
#line 219
  tag = alloc_mcc_tag(phba);
#line 220
  if (tag == 0U) {
#line 221
    spin_unlock(& ctrl->mbox_lock);
#line 222
    return (tag);
  } else {

  }
#line 225
  wrb = wrb_from_mccq(phba);
#line 226
  tmp = embedded_payload(wrb);
#line 226
  req = (struct be_cmd_reopen_session_req *)tmp;
#line 227
  wrb->tag0 = wrb->tag0 | tag;
#line 228
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 229
  be_cmd_hdr_prepare(& req->hdr, 6, 36, 24);
#line 234
  req->reopen_type = (u16 )reopen_type;
#line 235
  req->session_handle = sess_handle;
#line 237
  be_mcc_notify(phba);
#line 238
  spin_unlock(& ctrl->mbox_lock);
#line 239
  return (tag);
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_get_boot_target_req *req ;
  unsigned int tag ;
  uint32_t log_value ;
  void *tmp ;

  {
#line 244
  ctrl = & phba->ctrl;
#line 247
  tag = 0U;
#line 249
  log_value = phba->attr_log_enable;
#line 249
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 249
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In bescsi_get_boot_target\n",
               251);
  } else {

  }
#line 253
  spin_lock(& ctrl->mbox_lock);
#line 254
  tag = alloc_mcc_tag(phba);
#line 255
  if (tag == 0U) {
#line 256
    spin_unlock(& ctrl->mbox_lock);
#line 257
    return (tag);
  } else {

  }
#line 260
  wrb = wrb_from_mccq(phba);
#line 261
  tmp = embedded_payload(wrb);
#line 261
  req = (struct be_cmd_get_boot_target_req *)tmp;
#line 262
  wrb->tag0 = wrb->tag0 | tag;
#line 263
  be_wrb_hdr_prepare(wrb, 16, 1, 0);
#line 264
  be_cmd_hdr_prepare(& req->hdr, 6, 52, 24);
#line 268
  be_mcc_notify(phba);
#line 269
  spin_unlock(& ctrl->mbox_lock);
#line 270
  return (tag);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_session_info(struct beiscsi_hba *phba , u32 boot_session_handle ,
                                   struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  unsigned int tag ;
  struct be_cmd_get_session_req *req ;
  struct be_sge *sge ;
  uint32_t log_value ;

  {
#line 277
  ctrl = & phba->ctrl;
#line 279
  tag = 0U;
#line 284
  log_value = phba->attr_log_enable;
#line 284
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 284
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In beiscsi_get_session_info\n",
               286);
  } else {

  }
#line 288
  spin_lock(& ctrl->mbox_lock);
#line 289
  tag = alloc_mcc_tag(phba);
#line 290
  if (tag == 0U) {
#line 291
    spin_unlock(& ctrl->mbox_lock);
#line 292
    return (tag);
  } else {

  }
#line 295
  nonemb_cmd->size = 1180U;
#line 296
  req = (struct be_cmd_get_session_req *)nonemb_cmd->va;
#line 297
  memset((void *)req, 0, 20UL);
#line 298
  wrb = wrb_from_mccq(phba);
#line 299
  sge = nonembedded_sgl(wrb);
#line 300
  wrb->tag0 = wrb->tag0 | tag;
#line 303
  wrb->tag0 = wrb->tag0 | tag;
#line 304
  be_wrb_hdr_prepare(wrb, 20, 0, 1);
#line 305
  be_cmd_hdr_prepare(& req->hdr, 6, 14, 1180);
#line 308
  req->session_handle = boot_session_handle;
#line 309
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 310
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 311
  sge->len = nonemb_cmd->size;
#line 313
  be_mcc_notify(phba);
#line 314
  spin_unlock(& ctrl->mbox_lock);
#line 315
  return (tag);
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_fw_config(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_fw_cfg *req ;
  void *tmp___0 ;
  int status ;
  uint8_t ulp_num ;
  struct be_fw_cfg *pfw_cfg ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___1 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 333
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 333
  wrb = tmp;
#line 334
  tmp___0 = embedded_payload(wrb);
#line 334
  req = (struct be_fw_cfg *)tmp___0;
#line 335
  status = 0;
#line 337
  spin_lock(& ctrl->mbox_lock);
#line 338
  memset((void *)wrb, 0, 256UL);
#line 340
  be_wrb_hdr_prepare(wrb, 172, 1, 0);
#line 342
  be_cmd_hdr_prepare(& req->hdr, 1, 58, 220);
#line 345
  status = be_mbox_notify(ctrl);
#line 346
  if (status == 0) {
#line 347
    ulp_num = 0U;
#line 349
    pfw_cfg = req;
#line 351
    if (phba->generation != 3U && phba->generation != 2U) {
#line 352
      phba->fw_config.eqid_count = pfw_cfg->eqid_count;
#line 353
      phba->fw_config.cqid_count = pfw_cfg->cqid_count;
#line 355
      log_value = phba->attr_log_enable;
#line 355
      if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 355
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : EQ_Count : %d CQ_Count : %d\n", 359, phba->fw_config.eqid_count,
                   phba->fw_config.cqid_count);
      } else {

      }
    } else {

    }
#line 362
    ulp_num = 0U;
#line 362
    goto ldv_54265;
    ldv_54264: ;
#line 363
    if ((pfw_cfg->ulp[(int )ulp_num].ulp_mode & 16U) != 0U) {
#line 365
      set_bit((long )ulp_num, (unsigned long volatile   *)(& phba->fw_config.ulp_supported));
    } else {

    }
#line 362
    ulp_num = (uint8_t )((int )ulp_num + 1);
    ldv_54265: ;
#line 362
    if ((unsigned int )ulp_num <= 1U) {
#line 364
      goto ldv_54264;
    } else {

    }
#line 368
    phba->fw_config.phys_port = pfw_cfg->phys_port;
#line 369
    ulp_num = 0U;
#line 369
    goto ldv_54269;
    ldv_54268: 
#line 370
    tmp___1 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 370
    if (tmp___1 != 0) {
#line 372
      phba->fw_config.iscsi_cid_start[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].sq_base;
#line 374
      phba->fw_config.iscsi_cid_count[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].sq_count;
#line 377
      phba->fw_config.iscsi_icd_start[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].icd_base;
#line 379
      phba->fw_config.iscsi_icd_count[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].icd_count;
#line 382
      phba->fw_config.iscsi_chain_start[(int )ulp_num] = pfw_cfg->chain_icd[(int )ulp_num].chain_base;
#line 384
      phba->fw_config.iscsi_chain_count[(int )ulp_num] = pfw_cfg->chain_icd[(int )ulp_num].chain_count;
#line 387
      log_value___0 = phba->attr_log_enable;
#line 387
      if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 387
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Function loaded on ULP : %d\n\tiscsi_cid_count : %d\n\tiscsi_cid_start : %d\n\t iscsi_icd_count : %d\n\t iscsi_icd_start : %d\n",
                   401, (int )ulp_num, phba->fw_config.iscsi_cid_count[(int )ulp_num],
                   phba->fw_config.iscsi_cid_start[(int )ulp_num], phba->fw_config.iscsi_icd_count[(int )ulp_num],
                   phba->fw_config.iscsi_icd_start[(int )ulp_num]);
      } else {

      }
    } else {

    }
#line 369
    ulp_num = (uint8_t )((int )ulp_num + 1);
    ldv_54269: ;
#line 369
    if ((unsigned int )ulp_num <= 1U) {
#line 371
      goto ldv_54268;
    } else {

    }
#line 405
    phba->fw_config.dual_ulp_aware = (unsigned int )((uint16_t )pfw_cfg->function_mode) & 2048U;
#line 408
    log_value___1 = phba->attr_log_enable;
#line 408
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 408
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d : DUA Mode : 0x%x\n", 410, (int )phba->fw_config.dual_ulp_aware);
    } else {

    }
  } else {
#line 413
    log_value___2 = phba->attr_log_enable;
#line 413
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 413
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed in mgmt_get_fw_config\n",
                 414);
    } else {

    }
#line 415
    status = -22;
  }
#line 418
  spin_unlock(& ctrl->mbox_lock);
#line 419
  return (status);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_check_supported_fw(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) 
{ 
  struct be_dma_mem nonemb_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_mgmt_controller_attributes *req ;
  struct be_sge *sge ;
  struct be_sge *tmp___0 ;
  int status ;
  uint32_t log_value ;
  struct be_mgmt_controller_attributes_resp *resp ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 426
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 426
  wrb = tmp;
#line 428
  tmp___0 = nonembedded_sgl(wrb);
#line 428
  sge = tmp___0;
#line 429
  status = 0;
#line 431
  nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev, 556UL, & nonemb_cmd.dma);
#line 434
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 435
    log_value = phba->attr_log_enable;
#line 435
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 435
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to allocate memory for mgmt_check_supported_fw\n",
                 437);
    } else {

    }
#line 438
    return (-12);
  } else {

  }
#line 440
  nonemb_cmd.size = 556U;
#line 441
  req = (struct be_mgmt_controller_attributes *)nonemb_cmd.va;
#line 442
  memset((void *)req, 0, 556UL);
#line 443
  spin_lock(& ctrl->mbox_lock);
#line 444
  memset((void *)wrb, 0, 256UL);
#line 445
  be_wrb_hdr_prepare(wrb, 556, 0, 1);
#line 446
  be_cmd_hdr_prepare(& req->hdr, 1, 32, 556);
#line 448
  sge->pa_hi = (unsigned int )(nonemb_cmd.dma >> 32ULL);
#line 449
  sge->pa_lo = (unsigned int )nonemb_cmd.dma;
#line 450
  sge->len = nonemb_cmd.size;
#line 451
  status = be_mbox_notify(ctrl);
#line 452
  if (status == 0) {
#line 453
    resp = (struct be_mgmt_controller_attributes_resp *)nonemb_cmd.va;
#line 454
    log_value___0 = phba->attr_log_enable;
#line 454
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 454
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d : Firmware Version of CMD : %s\nFirmware Version is : %s\nDeveloper Build, not performing version check...\n",
                 461, (u8 *)(& resp->params.hba_attribs.flashrom_version_string),
                 (u8 *)(& resp->params.hba_attribs.firmware_version_string));
    } else {

    }
#line 463
    phba->fw_config.iscsi_features = (unsigned short )resp->params.hba_attribs.iscsi_features;
#line 465
    log_value___1 = phba->attr_log_enable;
#line 465
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 465
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : phba->fw_config.iscsi_features = %d\n", 467, (int )phba->fw_config.iscsi_features);
    } else {

    }
#line 468
    memcpy((void *)(& phba->fw_ver_str), (void const   *)(& resp->params.hba_attribs.firmware_version_string),
             32UL);
  } else {
#line 471
    log_value___2 = phba->attr_log_enable;
#line 471
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 471
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d :  Failed in mgmt_check_supported_fw\n",
                 472);
    } else {

    }
  }
#line 473
  spin_unlock(& ctrl->mbox_lock);
#line 474
  if ((unsigned long )nonemb_cmd.va != (unsigned long )((void *)0)) {
#line 475
    pci_free_consistent(ctrl->pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
  } else {

  }
#line 478
  return (status);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ,
                                         struct bsg_job *job , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_cmd_resp_hdr *resp ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *mcc_sge ;
  unsigned int tag ;
  struct iscsi_bsg_request *bsg_req ;
  struct be_bsg_vendor_cmd *req ;
  unsigned short region ;
  unsigned short sector_size ;
  unsigned short sector ;
  unsigned short offset ;
  uint32_t log_value ;

  {
#line 489
  tag = 0U;
#line 490
  bsg_req = (struct iscsi_bsg_request *)job->request;
#line 491
  req = (struct be_bsg_vendor_cmd *)nonemb_cmd->va;
#line 494
  nonemb_cmd->size = job->request_payload.payload_len;
#line 495
  memset(nonemb_cmd->va, 0, (size_t )nonemb_cmd->size);
#line 496
  resp = (struct be_cmd_resp_hdr *)nonemb_cmd->va;
#line 497
  region = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[1];
#line 498
  sector_size = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[2];
#line 499
  sector = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[3];
#line 500
  offset = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[4];
#line 501
  req->region = region;
#line 502
  req->sector = sector;
#line 503
  req->offset = offset;
#line 504
  spin_lock(& ctrl->mbox_lock);
#line 506
  switch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {
  case 0U: 
#line 508
  offset = (int )sector * (int )sector_size + (int )offset;
#line 509
  be_cmd_hdr_prepare(& req->hdr, 2, 96, 22);
#line 511
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    nonemb_cmd->va + (unsigned long )offset, (size_t )job->request_len);
#line 514
  goto ldv_54304;
  case 1U: 
#line 516
  be_cmd_hdr_prepare(& req->hdr, 2, 97, 22);
#line 518
  goto ldv_54304;
  default: 
#line 520
  log_value = phba->attr_log_enable;
#line 520
  if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 520
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Unsupported cmd = 0x%x\n\n",
               522, bsg_req->rqst_data.h_vendor.vendor_cmd[0]);
  } else {

  }
#line 524
  spin_unlock(& ctrl->mbox_lock);
#line 525
  return (4294967258U);
  }
  ldv_54304: 
#line 528
  tag = alloc_mcc_tag(phba);
#line 529
  if (tag == 0U) {
#line 530
    spin_unlock(& ctrl->mbox_lock);
#line 531
    return (tag);
  } else {

  }
#line 534
  wrb = wrb_from_mccq(phba);
#line 535
  mcc_sge = nonembedded_sgl(wrb);
#line 536
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, (int )((u8 )job->request_payload.sg_cnt));
#line 538
  mcc_sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 539
  mcc_sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 540
  mcc_sge->len = nonemb_cmd->size;
#line 541
  wrb->tag0 = wrb->tag0 | tag;
#line 543
  be_mcc_notify(phba);
#line 545
  spin_unlock(& ctrl->mbox_lock);
#line 546
  return (tag);
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_epfw_cleanup(struct beiscsi_hba *phba , unsigned short ulp_num ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct iscsi_cleanup_req *req ;
  void *tmp___0 ;
  int status ;
  uint32_t log_value ;

  {
#line 560
  ctrl = & phba->ctrl;
#line 561
  tmp = wrb_from_mccq(phba);
#line 561
  wrb = tmp;
#line 562
  tmp___0 = embedded_payload(wrb);
#line 562
  req = (struct iscsi_cleanup_req *)tmp___0;
#line 563
  status = 0;
#line 565
  spin_lock(& ctrl->mbox_lock);
#line 567
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 568
  be_cmd_hdr_prepare(& req->hdr, 2, 59, 20);
#line 571
  req->chute = (u16 )(1 << (int )ulp_num);
#line 572
  req->hdr_ring_id = (u8 )(phba->phwi_ctrlr)->default_pdu_hdr[(int )ulp_num].id;
#line 573
  req->data_ring_id = (u8 )(phba->phwi_ctrlr)->default_pdu_data[(int )ulp_num].id;
#line 575
  status = be_mcc_notify_wait(phba);
#line 576
  if (status != 0) {
#line 577
    log_value = phba->attr_log_enable;
#line 577
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
#line 577
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_epfw_cleanup , FAILED\n",
                 578);
    } else {

    }
  } else {

  }
#line 579
  spin_unlock(& ctrl->mbox_lock);
#line 580
  return (status);
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba , struct invalidate_command_table *inv_tbl ,
                                  unsigned int num_invalidate , unsigned int cid ,
                                  struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *sge ;
  struct invalidate_commands_params_in *req ;
  unsigned int i ;
  unsigned int tag ;

  {
#line 589
  ctrl = & phba->ctrl;
#line 593
  tag = 0U;
#line 595
  spin_lock(& ctrl->mbox_lock);
#line 596
  tag = alloc_mcc_tag(phba);
#line 597
  if (tag == 0U) {
#line 598
    spin_unlock(& ctrl->mbox_lock);
#line 599
    return (tag);
  } else {

  }
#line 602
  req = (struct invalidate_commands_params_in *)nonemb_cmd->va;
#line 603
  memset((void *)req, 0, 540UL);
#line 604
  wrb = wrb_from_mccq(phba);
#line 605
  sge = nonembedded_sgl(wrb);
#line 606
  wrb->tag0 = wrb->tag0 | tag;
#line 608
  be_wrb_hdr_prepare(wrb, 540, 0, 1);
#line 609
  be_cmd_hdr_prepare(& req->hdr, 2, 1, 540);
#line 612
  req->ref_handle = 0U;
#line 613
  req->cleanup_type = 1U;
#line 614
  i = 0U;
#line 614
  goto ldv_54331;
  ldv_54330: 
#line 615
  req->table[i].icd = inv_tbl->icd;
#line 616
  req->table[i].cid = inv_tbl->cid;
#line 617
  req->icd_count = req->icd_count + 1U;
#line 618
  inv_tbl = inv_tbl + 1;
#line 614
  i = i + 1U;
  ldv_54331: ;
#line 614
  if (i < num_invalidate) {
#line 616
    goto ldv_54330;
  } else {

  }
#line 620
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 621
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 622
  sge->len = nonemb_cmd->size;
#line 624
  be_mcc_notify(phba);
#line 625
  spin_unlock(& ctrl->mbox_lock);
#line 626
  return (tag);
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba , struct beiscsi_endpoint *beiscsi_ep ,
                                        unsigned short cid , unsigned short issue_reset ,
                                        unsigned short savecfg_flag ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct iscsi_invalidate_connection_params_in *req ;
  unsigned int tag ;
  void *tmp ;

  {
#line 635
  ctrl = & phba->ctrl;
#line 638
  tag = 0U;
#line 640
  spin_lock(& ctrl->mbox_lock);
#line 641
  tag = alloc_mcc_tag(phba);
#line 642
  if (tag == 0U) {
#line 643
    spin_unlock(& ctrl->mbox_lock);
#line 644
    return (tag);
  } else {

  }
#line 646
  wrb = wrb_from_mccq(phba);
#line 647
  wrb->tag0 = wrb->tag0 | tag;
#line 648
  tmp = embedded_payload(wrb);
#line 648
  req = (struct iscsi_invalidate_connection_params_in *)tmp;
#line 650
  be_wrb_hdr_prepare(wrb, 28, 1, 0);
#line 651
  be_cmd_hdr_prepare(& req->hdr, 6, 42, 28);
#line 654
  req->session_handle = beiscsi_ep->fw_handle;
#line 655
  req->cid = cid;
#line 656
  if ((unsigned int )issue_reset != 0U) {
#line 657
    req->cleanup_type = 32770U;
  } else {
#line 659
    req->cleanup_type = 32769U;
  }
#line 660
  req->save_cfg = savecfg_flag;
#line 661
  be_mcc_notify(phba);
#line 662
  spin_unlock(& ctrl->mbox_lock);
#line 663
  return (tag);
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_upload_connection(struct beiscsi_hba *phba , unsigned short cid ,
                                    unsigned int upload_flag ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct tcp_upload_params_in *req ;
  unsigned int tag ;
  void *tmp ;

  {
#line 669
  ctrl = & phba->ctrl;
#line 672
  tag = 0U;
#line 674
  spin_lock(& ctrl->mbox_lock);
#line 675
  tag = alloc_mcc_tag(phba);
#line 676
  if (tag == 0U) {
#line 677
    spin_unlock(& ctrl->mbox_lock);
#line 678
    return (tag);
  } else {

  }
#line 680
  wrb = wrb_from_mccq(phba);
#line 681
  tmp = embedded_payload(wrb);
#line 681
  req = (struct tcp_upload_params_in *)tmp;
#line 682
  wrb->tag0 = wrb->tag0 | tag;
#line 684
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 685
  be_cmd_hdr_prepare(& req->hdr, 1, 56, 24);
#line 687
  req->id = cid;
#line 688
  req->upload_type = (u16 )((unsigned char )upload_flag);
#line 689
  be_mcc_notify(phba);
#line 690
  spin_unlock(& ctrl->mbox_lock);
#line 691
  return (tag);
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_open_connection(struct beiscsi_hba *phba , struct sockaddr *dst_addr , struct beiscsi_endpoint *beiscsi_ep ,
                         struct be_dma_mem *nonemb_cmd ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct sockaddr_in *daddr_in ;
  struct sockaddr_in6 *daddr_in6 ;
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct tcp_connect_and_offload_in_v1 *req ;
  unsigned short def_hdr_id ;
  unsigned short def_data_id ;
  struct phys_addr template_address ;
  struct phys_addr *ptemplate_address ;
  unsigned int tag ;
  unsigned int i ;
  unsigned int ulp_num ;
  unsigned short cid ;
  struct be_sge *sge ;
  __be32 s_addr ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  uint32_t log_value ;
  unsigned int tmp___3 ;
  uint32_t log_value___0 ;

  {
#line 711
  daddr_in = (struct sockaddr_in *)dst_addr;
#line 712
  daddr_in6 = (struct sockaddr_in6 *)dst_addr;
#line 713
  ctrl = & phba->ctrl;
#line 718
  template_address.lo = 0U;
#line 718
  template_address.hi = 0U;
#line 720
  tag = 0U;
#line 722
  cid = beiscsi_ep->ep_cid;
#line 725
  phwi_ctrlr = phba->phwi_ctrlr;
#line 726
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 728
  ulp_num = (unsigned int )(phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[(int )cid])->ulp_num;
#line 730
  def_hdr_id = (unsigned short )(phba->phwi_ctrlr)->default_pdu_hdr[ulp_num].id;
#line 731
  def_data_id = (unsigned short )(phba->phwi_ctrlr)->default_pdu_data[ulp_num].id;
#line 733
  ptemplate_address = & template_address;
#line 734
  ptemplate_address->lo = ((phba->init_mem + 21UL)->mem_array)->bus_address.u.a32.address_lo;
#line 734
  ptemplate_address->hi = ((phba->init_mem + 21UL)->mem_array)->bus_address.u.a32.address_hi;
#line 735
  spin_lock(& ctrl->mbox_lock);
#line 736
  tag = alloc_mcc_tag(phba);
#line 737
  if (tag == 0U) {
#line 738
    spin_unlock(& ctrl->mbox_lock);
#line 739
    return ((int )tag);
  } else {

  }
#line 741
  wrb = wrb_from_mccq(phba);
#line 742
  sge = nonembedded_sgl(wrb);
#line 744
  req = (struct tcp_connect_and_offload_in_v1 *)nonemb_cmd->va;
#line 745
  memset((void *)req, 0, 72UL);
#line 746
  wrb->tag0 = wrb->tag0 | tag;
#line 748
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, 1);
#line 749
  be_cmd_hdr_prepare(& req->hdr, 2, 70, (int )nonemb_cmd->size);
#line 752
  if ((unsigned int )dst_addr->sa_family == 2U) {
#line 753
    s_addr = daddr_in->sin_addr.s_addr;
#line 754
    req->ip_address.ip_type = 1U;
#line 755
    req->ip_address.addr[0] = (u8 )s_addr;
#line 756
    req->ip_address.addr[1] = (u8 )((s_addr & 65280U) >> 8);
#line 757
    req->ip_address.addr[2] = (u8 )((s_addr & 16711680U) >> 16);
#line 758
    req->ip_address.addr[3] = (u8 )(s_addr >> 24);
#line 759
    tmp = __fswab16((int )daddr_in->sin_port);
#line 759
    req->tcp_port = tmp;
#line 760
    beiscsi_ep->dst_addr = (unsigned long )daddr_in->sin_addr.s_addr;
#line 761
    tmp___0 = __fswab16((int )daddr_in->sin_port);
#line 761
    beiscsi_ep->dst_tcpport = tmp___0;
#line 762
    beiscsi_ep->ip_type = 1U;
  } else
#line 763
  if ((unsigned int )dst_addr->sa_family == 10U) {
#line 764
    req->ip_address.ip_type = 16U;
#line 765
    memcpy((void *)(& req->ip_address.addr), (void const   *)(& daddr_in6->sin6_addr.in6_u.u6_addr8),
             16UL);
#line 767
    tmp___1 = __fswab16((int )daddr_in6->sin6_port);
#line 767
    req->tcp_port = tmp___1;
#line 768
    tmp___2 = __fswab16((int )daddr_in6->sin6_port);
#line 768
    beiscsi_ep->dst_tcpport = tmp___2;
#line 769
    memcpy((void *)(& beiscsi_ep->dst6_addr), (void const   *)(& daddr_in6->sin6_addr.in6_u.u6_addr8),
             16UL);
#line 771
    beiscsi_ep->ip_type = 16U;
  } else {
#line 773
    log_value = phba->attr_log_enable;
#line 773
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 773
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : unknown addr family %d\n",
                 775, (int )dst_addr->sa_family);
    } else {

    }
#line 776
    spin_unlock(& ctrl->mbox_lock);
#line 777
    free_mcc_tag(& phba->ctrl, tag);
#line 778
    return (-22);
  }
#line 781
  req->cid = cid;
#line 782
  tmp___3 = phba->nxt_cqid;
#line 782
  phba->nxt_cqid = phba->nxt_cqid + 1U;
#line 782
  i = tmp___3;
#line 783
  if (phba->nxt_cqid == phba->num_cpus) {
#line 784
    phba->nxt_cqid = 0U;
  } else {

  }
#line 785
  req->cq_id = phwi_context->be_cq[i].id;
#line 786
  log_value___0 = phba->attr_log_enable;
#line 786
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 786
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : i=%d cq_id=%d\n",
               787, i, (int )req->cq_id);
  } else {

  }
#line 788
  req->defq_id = def_hdr_id;
#line 789
  req->hdr_ring_id = def_hdr_id;
#line 790
  req->data_ring_id = def_data_id;
#line 791
  req->do_offload = 1U;
#line 792
  req->dataout_template_pa.lo = ptemplate_address->lo;
#line 793
  req->dataout_template_pa.hi = ptemplate_address->hi;
#line 794
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 795
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 796
  sge->len = nonemb_cmd->size;
#line 798
  if (phba->generation != 3U && phba->generation != 2U) {
#line 799
    req->hdr.version = 1U;
#line 800
    req->tcp_window_size = 0U;
#line 801
    req->tcp_window_scale_count = 2U;
  } else {

  }
#line 804
  be_mcc_notify(phba);
#line 805
  spin_unlock(& ctrl->mbox_lock);
#line 806
  return ((int )tag);
}
}
#line 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_get_all_if_id_req *req ;
  void *tmp___0 ;
  struct be_cmd_get_all_if_id_req *pbe_allid ;
  int status ;
  uint32_t log_value ;

  {
#line 811
  ctrl = & phba->ctrl;
#line 812
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 812
  wrb = tmp;
#line 813
  tmp___0 = embedded_payload(wrb);
#line 813
  req = (struct be_cmd_get_all_if_id_req *)tmp___0;
#line 814
  pbe_allid = req;
#line 815
  status = 0;
#line 817
  memset((void *)wrb, 0, 256UL);
#line 819
  spin_lock(& ctrl->mbox_lock);
#line 821
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 822
  be_cmd_hdr_prepare(& req->hdr, 2, 24, 24);
#line 825
  status = be_mbox_notify(ctrl);
#line 826
  if (status == 0) {
#line 827
    phba->interface_handle = pbe_allid->if_hndl_list[0];
  } else {
#line 829
    log_value = phba->attr_log_enable;
#line 829
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 829
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed in mgmt_get_all_if_id\n",
                 830);
    } else {

    }
  }
#line 832
  spin_unlock(& ctrl->mbox_lock);
#line 834
  return ((unsigned int )status);
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba , struct be_dma_mem *nonemb_cmd ,
                                void *resp_buf , int resp_buf_len ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *sge ;
  unsigned int tag ;
  int rc ;
  uint32_t log_value ;

  {
#line 849
  ctrl = & phba->ctrl;
#line 853
  rc = 0;
#line 855
  spin_lock(& ctrl->mbox_lock);
#line 856
  tag = alloc_mcc_tag(phba);
#line 857
  if (tag == 0U) {
#line 858
    spin_unlock(& ctrl->mbox_lock);
#line 859
    rc = -12;
#line 860
    goto free_cmd;
  } else {

  }
#line 863
  wrb = wrb_from_mccq(phba);
#line 864
  wrb->tag0 = wrb->tag0 | tag;
#line 865
  sge = nonembedded_sgl(wrb);
#line 867
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, 1);
#line 868
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 869
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 870
  sge->len = nonemb_cmd->size;
#line 872
  be_mcc_notify(phba);
#line 873
  spin_unlock(& ctrl->mbox_lock);
#line 875
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, nonemb_cmd);
#line 877
  if ((unsigned long )resp_buf != (unsigned long )((void *)0)) {
#line 878
    memcpy(resp_buf, (void const   *)nonemb_cmd->va, (size_t )resp_buf_len);
  } else {

  }
#line 880
  if (rc != 0) {
#line 882
    if (rc == -11) {
#line 883
      return (rc);
    } else {

    }
#line 885
    log_value = phba->attr_log_enable;
#line 885
    if ((log_value & 34U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 885
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_exec_nonemb_cmd Failed status\n",
                 887);
    } else {

    }
#line 889
    if (rc != -16) {
#line 890
      goto free_cmd;
    } else {
#line 892
      return (rc);
    }
  } else {

  }
  free_cmd: 
#line 895
  pci_free_consistent(ctrl->pdev, (size_t )nonemb_cmd->size, nonemb_cmd->va, nonemb_cmd->dma);
#line 897
  return (rc);
}
}
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_alloc_cmd_data(struct beiscsi_hba *phba , struct be_dma_mem *cmd ,
                               int iscsi_cmd , int size ) 
{ 
  uint32_t log_value ;

  {
#line 903
  cmd->va = pci_zalloc_consistent(phba->ctrl.pdev, (size_t )size, & cmd->dma);
#line 904
  if ((unsigned long )cmd->va == (unsigned long )((void *)0)) {
#line 905
    log_value = phba->attr_log_enable;
#line 905
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 905
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to allocate memory for if info\n",
                 906);
    } else {

    }
#line 907
    return (-12);
  } else {

  }
#line 909
  cmd->size = (u32 )size;
#line 910
  be_cmd_hdr_prepare((struct be_cmd_req_hdr *)cmd->va, 2, (int )((u8 )iscsi_cmd),
                     size);
#line 911
  return (0);
}
}
#line 915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_static_ip_modify(struct beiscsi_hba *phba , struct be_cmd_get_if_info_resp *if_info ,
                                 struct iscsi_iface_param_info *ip_param , struct iscsi_iface_param_info *subnet_param ,
                                 uint32_t ip_action ) 
{ 
  struct be_cmd_set_ip_addr_req *req ;
  struct be_dma_mem nonemb_cmd ;
  uint32_t ip_type ;
  int rc ;
  uint32_t log_value ;

  {
#line 926
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 21, 72);
#line 929
  if (rc != 0) {
#line 930
    return (rc);
  } else {

  }
#line 932
  ip_type = (unsigned int )ip_param->param == 7U ? 16U : 1U;
#line 935
  req = (struct be_cmd_set_ip_addr_req *)nonemb_cmd.va;
#line 936
  req->ip_params.record_entry_count = 1U;
#line 937
  req->ip_params.ip_record.action = ip_action;
#line 938
  req->ip_params.ip_record.interface_hndl = phba->interface_handle;
#line 940
  req->ip_params.ip_record.ip_addr.size_of_structure = 40U;
#line 942
  req->ip_params.ip_record.ip_addr.ip_type = (u8 )ip_type;
#line 944
  if (ip_action == 1U) {
#line 945
    memcpy((void *)(& req->ip_params.ip_record.ip_addr.addr), (void const   *)(& ip_param->value),
             16UL);
#line 948
    if ((unsigned long )subnet_param != (unsigned long )((struct iscsi_iface_param_info *)0)) {
#line 949
      memcpy((void *)(& req->ip_params.ip_record.ip_addr.subnet_mask), (void const   *)(& subnet_param->value),
               16UL);
    } else {

    }
  } else {
#line 953
    memcpy((void *)(& req->ip_params.ip_record.ip_addr.addr), (void const   *)(& if_info->ip_addr.addr),
             16UL);
#line 957
    memcpy((void *)(& req->ip_params.ip_record.ip_addr.subnet_mask), (void const   *)(& if_info->ip_addr.subnet_mask),
             16UL);
  }
#line 962
  rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
#line 963
  if (rc < 0) {
#line 964
    log_value = phba->attr_log_enable;
#line 964
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 964
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Modify existing IP Address\n",
                 965);
    } else {

    }
  } else {

  }
#line 966
  return (rc);
}
}
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_modify_gateway(struct beiscsi_hba *phba , uint8_t *gt_addr , uint32_t gtway_action ,
                               uint32_t param_len ) 
{ 
  struct be_cmd_set_def_gateway_req *req ;
  struct be_dma_mem nonemb_cmd ;
  int rt_val ;
  int tmp ;

  {
#line 977
  rt_val = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 23, 44);
#line 980
  if (rt_val != 0) {
#line 981
    return (rt_val);
  } else {

  }
#line 983
  req = (struct be_cmd_set_def_gateway_req *)nonemb_cmd.va;
#line 984
  req->action = gtway_action;
#line 985
  req->ip_addr.ip_type = 1U;
#line 987
  memcpy((void *)(& req->ip_addr.addr), (void const   *)gt_addr, 16UL);
#line 989
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
#line 989
  return (tmp);
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_ip(struct beiscsi_hba *phba , struct iscsi_iface_param_info *ip_param ,
                struct iscsi_iface_param_info *subnet_param , uint32_t boot_proto ) 
{ 
  struct be_cmd_get_def_gateway_resp gtway_addr_set ;
  struct be_cmd_get_if_info_resp *if_info ;
  struct be_cmd_set_dhcp_req *dhcpreq ;
  struct be_cmd_rel_dhcp_req *reldhcp ;
  struct be_dma_mem nonemb_cmd ;
  uint8_t *gtway_addr ;
  uint32_t ip_type ;
  int rc ;
  unsigned int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
#line 1006
  tmp = mgmt_get_all_if_id(phba);
#line 1006
  if (tmp != 0U) {
#line 1007
    return (-5);
  } else {

  }
#line 1009
  ip_type = (unsigned int )ip_param->param == 7U ? 16U : 1U;
#line 1012
  rc = mgmt_get_if_info(phba, (int )ip_type, & if_info);
#line 1013
  if (rc != 0) {
#line 1014
    return (rc);
  } else {

  }
#line 1016
  if (boot_proto == 2U) {
#line 1017
    if (if_info->dhcp_state != 0U) {
#line 1018
      log_value = phba->attr_log_enable;
#line 1018
      if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1018
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : DHCP Already Enabled\n", 1019);
      } else {

      }
#line 1020
      goto exit;
    } else {

    }
#line 1026
    ip_param->len = (unsigned int )ip_param->param == 7U ? 16U : 4U;
  } else
#line 1030
  if (if_info->dhcp_state != 0U) {
#line 1032
    memset((void *)if_info, 0, 72UL);
#line 1033
    rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 18, 24);
#line 1037
    if (rc != 0) {
#line 1038
      goto exit;
    } else {

    }
#line 1040
    reldhcp = (struct be_cmd_rel_dhcp_req *)nonemb_cmd.va;
#line 1041
    reldhcp->interface_hndl = phba->interface_handle;
#line 1042
    reldhcp->ip_type = ip_type;
#line 1044
    rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
#line 1045
    if (rc < 0) {
#line 1046
      log_value___0 = phba->attr_log_enable;
#line 1046
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1046
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to Delete existing dhcp\n", 1048);
      } else {

      }
#line 1049
      goto exit;
    } else {

    }
  } else {

  }
#line 1055
  if ((unsigned int )if_info->ip_addr.addr[0] != 0U) {
#line 1056
    rc = mgmt_static_ip_modify(phba, if_info, ip_param, (struct iscsi_iface_param_info *)0,
                               2U);
#line 1058
    if (rc != 0) {
#line 1059
      goto exit;
    } else {

    }
  } else {

  }
#line 1063
  if (boot_proto == 2U) {
#line 1064
    memset((void *)(& gtway_addr_set), 0, 40UL);
#line 1065
    rc = mgmt_get_gateway(phba, 1, & gtway_addr_set);
#line 1066
    if (rc != 0) {
#line 1067
      log_value___1 = phba->attr_log_enable;
#line 1067
      if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1067
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to Get Gateway Addr\n", 1068);
      } else {

      }
#line 1069
      goto exit;
    } else {

    }
#line 1072
    if ((unsigned int )gtway_addr_set.ip_addr.addr[0] != 0U) {
#line 1073
      gtway_addr = (uint8_t *)(& gtway_addr_set.ip_addr.addr);
#line 1074
      rc = mgmt_modify_gateway(phba, gtway_addr, 2U, 4U);
#line 1077
      if (rc != 0) {
#line 1078
        log_value___2 = phba->attr_log_enable;
#line 1078
        if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1078
          dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BG_%d : Failed to clear Gateway Addr Set\n", 1080);
        } else {

        }
#line 1081
        goto exit;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1087
  if (boot_proto == 2U) {
#line 1088
    rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 17, 32);
#line 1091
    if (rc != 0) {
#line 1092
      goto exit;
    } else {

    }
#line 1094
    dhcpreq = (struct be_cmd_set_dhcp_req *)nonemb_cmd.va;
#line 1095
    dhcpreq->flags = 1U;
#line 1096
    dhcpreq->retry_count = 1U;
#line 1097
    dhcpreq->interface_hndl = phba->interface_handle;
#line 1098
    dhcpreq->ip_type = 5U;
#line 1100
    rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
  } else {
#line 1102
    rc = mgmt_static_ip_modify(phba, if_info, ip_param, subnet_param, 1U);
  }
  exit: 
#line 1107
  kfree((void const   *)if_info);
#line 1108
  return (rc);
}
}
#line 1111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_gateway(struct beiscsi_hba *phba , struct iscsi_iface_param_info *gateway_param ) 
{ 
  struct be_cmd_get_def_gateway_resp gtway_addr_set ;
  uint8_t *gtway_addr ;
  int rt_val ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 1118
  memset((void *)(& gtway_addr_set), 0, 40UL);
#line 1119
  rt_val = mgmt_get_gateway(phba, 1, & gtway_addr_set);
#line 1120
  if (rt_val != 0) {
#line 1121
    log_value = phba->attr_log_enable;
#line 1121
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1121
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Get Gateway Addr\n",
                 1122);
    } else {

    }
#line 1123
    return (rt_val);
  } else {

  }
#line 1126
  if ((unsigned int )gtway_addr_set.ip_addr.addr[0] != 0U) {
#line 1127
    gtway_addr = (uint8_t *)(& gtway_addr_set.ip_addr.addr);
#line 1128
    rt_val = mgmt_modify_gateway(phba, gtway_addr, 2U, gateway_param->len);
#line 1130
    if (rt_val != 0) {
#line 1131
      log_value___0 = phba->attr_log_enable;
#line 1131
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1131
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to clear Gateway Addr Set\n", 1132);
      } else {

      }
#line 1133
      return (rt_val);
    } else {

    }
  } else {

  }
#line 1137
  gtway_addr = (uint8_t *)(& gateway_param->value);
#line 1138
  rt_val = mgmt_modify_gateway(phba, gtway_addr, 1U, gateway_param->len);
#line 1141
  if (rt_val != 0) {
#line 1142
    log_value___1 = phba->attr_log_enable;
#line 1142
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 1142
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Set Gateway Addr\n",
                 1143);
    } else {

    }
  } else {

  }
#line 1145
  return (rt_val);
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_gateway(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_def_gateway_resp *gateway ) 
{ 
  struct be_cmd_get_def_gateway_req *req ;
  struct be_dma_mem nonemb_cmd ;
  int rc ;
  int tmp ;

  {
#line 1155
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 22, 40);
#line 1158
  if (rc != 0) {
#line 1159
    return (rc);
  } else {

  }
#line 1161
  req = (struct be_cmd_get_def_gateway_req *)nonemb_cmd.va;
#line 1162
  req->ip_type = (u32 )ip_type;
#line 1164
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)gateway, 40);
#line 1164
  return (tmp);
}
}
#line 1168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_if_info(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_if_info_resp **if_info ) 
{ 
  struct be_cmd_get_if_info_req *req ;
  struct be_dma_mem nonemb_cmd ;
  uint32_t ioctl_size ;
  int rc ;
  unsigned int tmp ;
  void *tmp___0 ;
  uint32_t log_value ;

  {
#line 1173
  ioctl_size = 72U;
#line 1176
  tmp = mgmt_get_all_if_id(phba);
#line 1176
  if (tmp != 0U) {
#line 1177
    return (-5);
  } else {

  }
  ldv_54476: 
#line 1180
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 25, (int )ioctl_size);
#line 1183
  if (rc != 0) {
#line 1184
    return (rc);
  } else {

  }
#line 1186
  req = (struct be_cmd_get_if_info_req *)nonemb_cmd.va;
#line 1187
  req->interface_hndl = phba->interface_handle;
#line 1188
  req->ip_type = (u32 )ip_type;
#line 1191
  tmp___0 = kzalloc((size_t )ioctl_size, 208U);
#line 1191
  *if_info = (struct be_cmd_get_if_info_resp *)tmp___0;
#line 1192
  if ((unsigned long )*if_info == (unsigned long )((struct be_cmd_get_if_info_resp *)0)) {
#line 1193
    log_value = phba->attr_log_enable;
#line 1193
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1193
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Memory Allocation Failure\n",
                 1195);
    } else {

    }
#line 1198
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 1202
    return (-12);
  } else {

  }
#line 1205
  rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)*if_info, (int )ioctl_size);
#line 1209
  if (rc == -11) {
#line 1212
    ioctl_size = ((struct be_cmd_resp_hdr *)nonemb_cmd.va)->actual_resp_len;
#line 1214
    ioctl_size = ioctl_size + 16U;
#line 1217
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 1222
    kfree((void const   *)*if_info);
  } else {
#line 1224
    goto ldv_54475;
  }
#line 1225
  goto ldv_54476;
  ldv_54475: ;
#line 1226
  return (rc);
}
}
#line 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_nic_conf(struct beiscsi_hba *phba , struct be_cmd_get_nic_conf_resp *nic ) 
{ 
  struct be_dma_mem nonemb_cmd ;
  int rc ;
  int tmp ;

  {
#line 1235
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 7, 136);
#line 1238
  if (rc != 0) {
#line 1239
    return (rc);
  } else {

  }
#line 1241
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)nic, 136);
#line 1241
  return (tmp);
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int be_cmd_get_initname(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_hba_name *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
#line 1248
  tag = 0U;
#line 1251
  ctrl = & phba->ctrl;
#line 1253
  spin_lock(& ctrl->mbox_lock);
#line 1254
  tag = alloc_mcc_tag(phba);
#line 1255
  if (tag == 0U) {
#line 1256
    spin_unlock(& ctrl->mbox_lock);
#line 1257
    return (tag);
  } else {

  }
#line 1260
  wrb = wrb_from_mccq(phba);
#line 1261
  tmp = embedded_payload(wrb);
#line 1261
  req = (struct be_cmd_hba_name *)tmp;
#line 1262
  wrb->tag0 = wrb->tag0 | tag;
#line 1263
  be_wrb_hdr_prepare(wrb, 276, 1, 0);
#line 1264
  be_cmd_hdr_prepare(& req->hdr, 6, 6, 276);
#line 1268
  be_mcc_notify(phba);
#line 1269
  spin_unlock(& ctrl->mbox_lock);
#line 1270
  return (tag);
}
}
#line 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_ntwk_link_status_req *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
#line 1275
  tag = 0U;
#line 1278
  ctrl = & phba->ctrl;
#line 1280
  spin_lock(& ctrl->mbox_lock);
#line 1281
  tag = alloc_mcc_tag(phba);
#line 1282
  if (tag == 0U) {
#line 1283
    spin_unlock(& ctrl->mbox_lock);
#line 1284
    return (tag);
  } else {

  }
#line 1287
  wrb = wrb_from_mccq(phba);
#line 1288
  tmp = embedded_payload(wrb);
#line 1288
  req = (struct be_cmd_ntwk_link_status_req *)tmp;
#line 1289
  wrb->tag0 = wrb->tag0 | tag;
#line 1290
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1291
  be_cmd_hdr_prepare(& req->hdr, 1, 5, 20);
#line 1295
  be_mcc_notify(phba);
#line 1296
  spin_unlock(& ctrl->mbox_lock);
#line 1297
  return (tag);
}
}
#line 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba , unsigned int *s_handle ) 
{ 
  struct be_cmd_get_boot_target_resp *boot_resp ;
  struct be_mcc_wrb *wrb ;
  unsigned int tag ;
  uint8_t boot_retry ;
  int rc ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;

  {
#line 1320
  boot_retry = 3U;
  ldv_54511: 
#line 1325
  tag = mgmt_get_boot_target(phba);
#line 1326
  if (tag == 0U) {
#line 1327
    log_value = phba->attr_log_enable;
#line 1327
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1327
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Getting Boot Target Info Failed\n",
                 1329);
    } else {

    }
#line 1330
    return (-11);
  } else {

  }
#line 1333
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
#line 1334
  if (rc != 0) {
#line 1335
    log_value___0 = phba->attr_log_enable;
#line 1335
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1335
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : MBX CMD get_boot_target Failed\n",
                 1337);
    } else {

    }
#line 1338
    return (-16);
  } else {

  }
#line 1341
  tmp = embedded_payload(wrb);
#line 1341
  boot_resp = (struct be_cmd_get_boot_target_resp *)tmp;
#line 1344
  if (boot_resp->boot_session_count == 0U) {
#line 1345
    log_value___1 = phba->attr_log_enable;
#line 1345
    if ((log_value___1 & 33U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1345
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d  ;No boot targets configured\n", 1347);
    } else {

    }
#line 1348
    return (-6);
  } else {

  }
#line 1352
  if (boot_resp->boot_session_handle != -1) {
#line 1353
    *s_handle = (unsigned int )boot_resp->boot_session_handle;
#line 1354
    return (0);
  } else {

  }
#line 1358
  tag = mgmt_reopen_session(phba, 1U, 4294967295U);
#line 1360
  if (tag == 0U) {
#line 1361
    log_value___2 = phba->attr_log_enable;
#line 1361
    if ((log_value___2 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1361
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_reopen_session Failed\n",
                 1363);
    } else {

    }
#line 1364
    return (-11);
  } else {

  }
#line 1367
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1368
  if (rc != 0) {
#line 1369
    log_value___3 = phba->attr_log_enable;
#line 1369
    if ((log_value___3 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1369
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_reopen_session Failed",
                 1371);
    } else {

    }
#line 1372
    return (rc);
  } else {

  }
#line 1374
  boot_retry = (uint8_t )((int )boot_retry - 1);
#line 1374
  if ((unsigned int )boot_retry != 0U) {
#line 1376
    goto ldv_54511;
  } else {

  }
#line 1377
  log_value___4 = phba->attr_log_enable;
#line 1377
  if ((log_value___4 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1377
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Login to Boot Target Failed\n",
               1379);
  } else {

  }
#line 1380
  return (-6);
}
}
#line 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) 
{ 
  int rc ;
  unsigned int tag ;
  int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1401
  tmp = be_cmd_set_vlan(phba, (int )vlan_tag);
#line 1401
  tag = (unsigned int )tmp;
#line 1402
  if (tag == 0U) {
#line 1403
    log_value = phba->attr_log_enable;
#line 1403
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1403
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : VLAN Setting Failed\n",
                 1405);
    } else {

    }
#line 1406
    return (-16);
  } else {

  }
#line 1409
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1410
  if (rc != 0) {
#line 1411
    log_value___0 = phba->attr_log_enable;
#line 1411
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1411
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : VLAN MBX Cmd Failed\n",
                 1413);
    } else {

    }
#line 1414
    return (rc);
  } else {

  }
#line 1416
  return (rc);
}
}
#line 1429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_drvr_ver_disp(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  int tmp ;

  {
#line 1432
  tmp = snprintf(buf, 4096UL, "Avago Technologies OneConnectOpen-iSCSI Driver version10.6.0.0\n");
#line 1432
  return ((ssize_t )tmp);
}
}
#line 1445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_fw_ver_disp(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1448
  __mptr = (struct device  const  *)dev;
#line 1448
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 1449
  tmp = shost_priv(shost);
#line 1449
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1451
  tmp___0 = snprintf(buf, 4096UL, "%s\n", (char *)(& phba->fw_ver_str));
#line 1451
  return ((ssize_t )tmp___0);
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_active_session_disp(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint16_t avlbl_cids ;
  uint16_t ulp_num ;
  uint16_t len ;
  uint16_t total_cids ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1467
  __mptr = (struct device  const  *)dev;
#line 1467
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 1468
  tmp = shost_priv(shost);
#line 1468
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1469
  avlbl_cids = 0U;
#line 1469
  len = 0U;
#line 1469
  total_cids = 0U;
#line 1471
  ulp_num = 0U;
#line 1471
  goto ldv_54550;
  ldv_54549: 
#line 1472
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 1472
  if (tmp___2 != 0) {
#line 1473
    avlbl_cids = (phba->cid_array_info[(int )ulp_num])->avlbl_cids;
#line 1474
    total_cids = (uint16_t )phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 1475
    tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, (int )total_cids - (int )avlbl_cids);
#line 1475
    len = (int )((uint16_t )tmp___0) + (int )len;
  } else {
#line 1479
    tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, 0);
#line 1479
    len = (int )((uint16_t )tmp___1) + (int )len;
  }
#line 1471
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_54550: ;
#line 1471
  if ((unsigned int )ulp_num <= 1U) {
#line 1473
    goto ldv_54549;
  } else {

  }

#line 1483
  return ((ssize_t )len);
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_free_session_disp(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint16_t ulp_num ;
  uint16_t len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1499
  __mptr = (struct device  const  *)dev;
#line 1499
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 1500
  tmp = shost_priv(shost);
#line 1500
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1501
  len = 0U;
#line 1503
  ulp_num = 0U;
#line 1503
  goto ldv_54564;
  ldv_54563: 
#line 1504
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
#line 1504
  if (tmp___2 != 0) {
#line 1505
    tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, (int )(phba->cid_array_info[(int )ulp_num])->avlbl_cids);
#line 1505
    len = (int )((uint16_t )tmp___0) + (int )len;
  } else {
#line 1509
    tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, 0);
#line 1509
    len = (int )((uint16_t )tmp___1) + (int )len;
  }
#line 1503
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_54564: ;
#line 1503
  if ((unsigned int )ulp_num <= 1U) {
#line 1505
    goto ldv_54563;
  } else {

  }

#line 1513
  return ((ssize_t )len);
}
}
#line 1526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_adap_family_disp(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) 
{ 
  uint16_t dev_id ;
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1529
  dev_id = 0U;
#line 1530
  __mptr = (struct device  const  *)dev;
#line 1530
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 1531
  tmp = shost_priv(shost);
#line 1531
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1533
  dev_id = (phba->pcidev)->device;
#line 1534
  switch ((int )dev_id) {
  case 530: ;
  case 1794: ;
  case 1795: 
#line 1538
  tmp___0 = snprintf(buf, 4096UL, "BE2 Adapter Family\n");
#line 1538
  return ((ssize_t )tmp___0);
  case 546: ;
  case 1810: 
#line 1542
  tmp___1 = snprintf(buf, 4096UL, "BE3-R Adapter Family\n");
#line 1542
  return ((ssize_t )tmp___1);
  case 1826: 
#line 1545
  tmp___2 = snprintf(buf, 4096UL, "Skyhawk-R Adapter Family\n");
#line 1545
  return ((ssize_t )tmp___2);
  default: 
#line 1548
  tmp___3 = snprintf(buf, 4096UL, "Unknown Adapter Family: 0x%x\n", (int )dev_id);
#line 1548
  return ((ssize_t )tmp___3);
  }
}
}
#line 1564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_phys_port_disp(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1567
  __mptr = (struct device  const  *)dev;
#line 1567
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
#line 1568
  tmp = shost_priv(shost);
#line 1568
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1570
  tmp___0 = snprintf(buf, 4096UL, "Port Identifier : %d\n", phba->fw_config.phys_port);
#line 1570
  return ((ssize_t )tmp___0);
}
}
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ,
                            struct be_mem_descriptor *mem_descr ) 
{ 
  struct iscsi_wrb *pwrb ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;

  {
#line 1578
  pwrb = pwrb_handle->pwrb;
#line 1580
  memset((void *)pwrb, 0, 64UL);
#line 1581
  tmp = amap_mask(17U);
#line 1581
  amap_set((void *)pwrb, 2U, tmp, 15U, params->dw[1UL]);
#line 1585
  tmp___0 = amap_mask(4U);
#line 1585
  amap_set((void *)pwrb, 0U, tmp___0, 28U, 7U);
#line 1587
  tmp___1 = amap_mask(14U);
#line 1587
  amap_set((void *)pwrb, 3U, tmp___1, 0U, params->dw[2UL]);
#line 1592
  tmp___2 = amap_mask(2U);
#line 1592
  amap_set((void *)pwrb, 4U, tmp___2, 19U, params->dw[3UL] & 3U);
#line 1595
  tmp___3 = amap_mask(1U);
#line 1595
  amap_set((void *)pwrb, 4U, tmp___3, 18U, (params->dw[3UL] & 4U) >> 2);
#line 1598
  tmp___4 = amap_mask(1U);
#line 1598
  amap_set((void *)pwrb, 4U, tmp___4, 17U, (params->dw[3UL] & 8U) >> 3);
#line 1601
  tmp___5 = amap_mask(1U);
#line 1601
  amap_set((void *)pwrb, 4U, tmp___5, 28U, (params->dw[3UL] & 16U) >> 4);
#line 1604
  tmp___6 = amap_mask(1U);
#line 1604
  amap_set((void *)pwrb, 4U, tmp___6, 27U, (params->dw[3UL] & 32U) >> 5);
#line 1607
  tmp___7 = amap_mask(32U);
#line 1607
  amap_set((void *)pwrb, 5U, tmp___7, 0U, params->dw[4UL] + 1U);
#line 1611
  tmp___8 = amap_mask(8U);
#line 1611
  amap_set((void *)pwrb, 0U, tmp___8, 16U, (u32 )pwrb_handle->wrb_index);
#line 1614
  tmp___9 = amap_mask(19U);
#line 1614
  amap_set((void *)pwrb, 1U, tmp___9, 8U, params->dw[0UL]);
#line 1619
  tmp___10 = amap_mask(8U);
#line 1619
  amap_set((void *)pwrb, 1U, tmp___10, 0U, (u32 )pwrb_handle->nxt_wrb_index);
#line 1621
  tmp___11 = amap_mask(3U);
#line 1621
  amap_set((void *)pwrb, 3U, tmp___11, 29U, 0U);
#line 1623
  tmp___12 = amap_mask(1U);
#line 1623
  amap_set((void *)pwrb, 4U, tmp___12, 31U, 1U);
#line 1625
  tmp___13 = amap_mask(2U);
#line 1625
  amap_set((void *)pwrb, 4U, tmp___13, 29U, 0U);
#line 1627
  tmp___14 = amap_mask(1U);
#line 1627
  amap_set((void *)pwrb, 4U, tmp___14, 26U, 0U);
#line 1630
  mem_descr = mem_descr + 21UL;
#line 1631
  tmp___15 = amap_mask(32U);
#line 1631
  amap_set((void *)pwrb, 6U, tmp___15, 0U, (mem_descr->mem_array)->bus_address.u.a32.address_hi);
#line 1634
  tmp___16 = amap_mask(32U);
#line 1634
  amap_set((void *)pwrb, 7U, tmp___16, 0U, (mem_descr->mem_array)->bus_address.u.a32.address_lo);
#line 1635
  return;
}
}
#line 1639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ) 
{ 
  struct iscsi_wrb *pwrb ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;

  {
#line 1642
  pwrb = pwrb_handle->pwrb;
#line 1644
  memset((void *)pwrb, 0, 64UL);
#line 1646
  tmp = amap_mask(24U);
#line 1646
  amap_set((void *)pwrb, 0U, tmp, 0U, params->dw[0UL]);
#line 1650
  tmp___0 = amap_mask(5U);
#line 1650
  amap_set((void *)pwrb, 0U, tmp___0, 27U, 7U);
#line 1653
  tmp___1 = amap_mask(8U);
#line 1653
  amap_set((void *)pwrb, 1U, tmp___1, 0U, (u32 )pwrb_handle->nxt_wrb_index);
#line 1656
  tmp___2 = amap_mask(8U);
#line 1656
  amap_set((void *)pwrb, 1U, tmp___2, 8U, (u32 )pwrb_handle->wrb_index);
#line 1658
  tmp___3 = amap_mask(24U);
#line 1658
  amap_set((void *)pwrb, 2U, tmp___3, 0U, params->dw[1UL]);
#line 1662
  tmp___4 = amap_mask(24U);
#line 1662
  amap_set((void *)pwrb, 3U, tmp___4, 0U, params->dw[2UL]);
#line 1666
  tmp___5 = amap_mask(24U);
#line 1666
  amap_set((void *)pwrb, 8U, tmp___5, 0U, params->dw[5UL]);
#line 1670
  tmp___6 = amap_mask(16U);
#line 1670
  amap_set((void *)pwrb, 11U, tmp___6, 0U, 1U);
#line 1672
  tmp___7 = amap_mask(2U);
#line 1672
  amap_set((void *)pwrb, 4U, tmp___7, 19U, params->dw[3UL] & 3U);
#line 1675
  tmp___8 = amap_mask(1U);
#line 1675
  amap_set((void *)pwrb, 4U, tmp___8, 18U, (params->dw[3UL] & 4U) >> 2);
#line 1678
  tmp___9 = amap_mask(1U);
#line 1678
  amap_set((void *)pwrb, 4U, tmp___9, 17U, (params->dw[3UL] & 8U) >> 3);
#line 1681
  tmp___10 = amap_mask(1U);
#line 1681
  amap_set((void *)pwrb, 4U, tmp___10, 28U, (params->dw[3UL] & 16U) >> 4);
#line 1685
  tmp___11 = amap_mask(1U);
#line 1685
  amap_set((void *)pwrb, 4U, tmp___11, 27U, (params->dw[3UL] & 32U) >> 5);
#line 1688
  tmp___12 = amap_mask(1U);
#line 1688
  amap_set((void *)pwrb, 11U, tmp___12, 30U, (params->dw[3UL] & 64U) >> 6);
#line 1694
  tmp___13 = amap_mask(1U);
#line 1694
  amap_set((void *)pwrb, 11U, tmp___13, 31U, (params->dw[3UL] & 128U) >> 7);
#line 1700
  tmp___14 = amap_mask(16U);
#line 1700
  amap_set((void *)pwrb, 4U, tmp___14, 0U, (params->dw[3UL] & 16776960U) >> 8);
#line 1705
  tmp___15 = amap_mask(32U);
#line 1705
  amap_set((void *)pwrb, 5U, tmp___15, 0U, params->dw[4UL] + 1U);
#line 1706
  return;
}
}
#line 1722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.c"
int beiscsi_logout_fw_sess(struct beiscsi_hba *phba , uint32_t fw_sess_handle ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_logout_fw_sess *req ;
  struct be_cmd_resp_logout_fw_sess *resp ;
  unsigned int tag ;
  int rc ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp ;
  uint32_t log_value___1 ;
  void *tmp___0 ;
  uint32_t log_value___2 ;

  {
#line 1725
  ctrl = & phba->ctrl;
#line 1732
  log_value = phba->attr_log_enable;
#line 1732
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1732
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In bescsi_logout_fwboot_sess\n",
               1734);
  } else {

  }
#line 1736
  spin_lock(& ctrl->mbox_lock);
#line 1737
  tag = alloc_mcc_tag(phba);
#line 1738
  if (tag == 0U) {
#line 1739
    spin_unlock(& ctrl->mbox_lock);
#line 1740
    log_value___0 = phba->attr_log_enable;
#line 1740
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1740
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d : MBX Tag Failure\n", 1742);
    } else {

    }
#line 1743
    return (-22);
  } else {

  }
#line 1746
  wrb = wrb_from_mccq(phba);
#line 1747
  tmp = embedded_payload(wrb);
#line 1747
  req = (struct be_cmd_req_logout_fw_sess *)tmp;
#line 1748
  wrb->tag0 = wrb->tag0 | tag;
#line 1749
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1750
  be_cmd_hdr_prepare(& req->hdr, 6, 24, 20);
#line 1755
  req->session_handle = fw_sess_handle;
#line 1756
  be_mcc_notify(phba);
#line 1757
  spin_unlock(& ctrl->mbox_lock);
#line 1759
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
#line 1760
  if (rc != 0) {
#line 1761
    log_value___1 = phba->attr_log_enable;
#line 1761
    if ((log_value___1 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1761
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : MBX CMD FW_SESSION_LOGOUT_TARGET Failed\n",
                 1763);
    } else {

    }
#line 1764
    return (-16);
  } else {

  }
#line 1767
  tmp___0 = embedded_payload(wrb);
#line 1767
  resp = (struct be_cmd_resp_logout_fw_sess *)tmp___0;
#line 1768
  if (resp->session_status != 32U) {
#line 1770
    log_value___2 = phba->attr_log_enable;
#line 1770
    if ((log_value___2 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1770
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : FW_SESSION_LOGOUT_TARGET resp : 0x%x\n",
                 1773, resp->session_status);
    } else {

    }
#line 1774
    rc = -22;
  } else {

  }
#line 1777
  return (rc);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.o.c.prepared"
bool ldv_queue_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 180
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 180
  ldv_func_res = tmp;
#line 182
  activate_work_6(ldv_func_arg3, 2);
#line 184
  return (ldv_func_res);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.o.c.prepared"
bool ldv_queue_delayed_work_on_56(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 191
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 191
  ldv_func_res = tmp;
#line 193
  activate_work_6(& ldv_func_arg3->work, 2);
#line 195
  return (ldv_func_res);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.o.c.prepared"
bool ldv_queue_work_on_57(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 202
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 202
  ldv_func_res = tmp;
#line 204
  activate_work_6(ldv_func_arg3, 2);
#line 206
  return (ldv_func_res);
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.o.c.prepared"
void ldv_flush_workqueue_58(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 212
  flush_workqueue(ldv_func_arg1);
#line 214
  call_and_disable_all_6(2);
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_mgmt.o.c.prepared"
bool ldv_queue_delayed_work_on_59(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 221
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 221
  ldv_func_res = tmp;
#line 223
  activate_work_6(& ldv_func_arg3->work, 2);
#line 225
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 149 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_69(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_71(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_70(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_72(struct workqueue_struct *ldv_func_arg1 ) ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 761 "include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost___1(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_39508;
  ldv_39507: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_39508: 
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_39507;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 433 "include/scsi/libiscsi.h"
extern void iscsi_session_failure(struct iscsi_session * , enum iscsi_err  ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 59 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 61
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 64 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_get_wrb(struct be_queue_info *q , unsigned int wrb_num ) 
{ 


  {
#line 66
  return (q->dma_mem.va + (unsigned long )((unsigned int )q->entry_size * wrb_num));
}
}
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
#line 76
  index_inc(& q->head, (int )q->len);
#line 77
  return;
}
}
#line 1361 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/be2iscsi/be_cmds.h"
int beiscsi_pci_soft_reset(struct beiscsi_hba *phba ) ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_pci_soft_reset(struct beiscsi_hba *phba ) 
{ 
  u32 sreset ;
  u8 *pci_reset_offset ;
  u8 *pci_online0_offset ;
  u8 *pci_online1_offset ;
  u32 pconline0 ;
  u32 pconline1 ;
  u32 i ;

  {
#line 27
  pci_reset_offset = (u8 *)0U;
#line 28
  pci_online0_offset = (u8 *)0U;
#line 29
  pci_online1_offset = (u8 *)0U;
#line 30
  pconline0 = 0U;
#line 31
  pconline1 = 0U;
#line 34
  pci_reset_offset = phba->pci_va + 92UL;
#line 35
  pci_online0_offset = phba->pci_va + 176UL;
#line 36
  pci_online1_offset = phba->pci_va + 180UL;
#line 37
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 38
  sreset = sreset | 128U;
#line 39
  writel(sreset, (void volatile   *)pci_reset_offset);
#line 41
  i = 0U;
#line 42
  goto ldv_54179;
  ldv_54178: ;
#line 43
  if (i > 64U) {
#line 44
    goto ldv_54177;
  } else {

  }
#line 45
  msleep(100U);
#line 46
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 47
  i = i + 1U;
  ldv_54179: ;
#line 42
  if ((sreset & 128U) != 0U) {
#line 44
    goto ldv_54178;
  } else {

  }
  ldv_54177: ;
#line 50
  if ((sreset & 128U) != 0U) {
#line 51
    printk("\vbe2iscsi Soft Reset  did not deassert\n");
#line 53
    return (-5);
  } else {

  }
#line 55
  pconline1 = 128U;
#line 56
  writel(pconline0, (void volatile   *)pci_online0_offset);
#line 57
  writel(pconline1, (void volatile   *)pci_online1_offset);
#line 59
  sreset = sreset | 128U;
#line 60
  writel(sreset, (void volatile   *)pci_reset_offset);
#line 62
  i = 0U;
#line 63
  goto ldv_54182;
  ldv_54181: ;
#line 64
  if (i > 64U) {
#line 65
    goto ldv_54180;
  } else {

  }
#line 66
  msleep(1U);
#line 67
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 68
  i = i + 1U;
  ldv_54182: ;
#line 63
  if ((sreset & 128U) != 0U) {
#line 65
    goto ldv_54181;
  } else {

  }
  ldv_54180: ;
#line 70
  if ((sreset & 128U) != 0U) {
#line 71
    printk("\vbe2iscsi MPU Online Soft Reset did not deassert\n");
#line 73
    return (-5);
  } else {

  }
#line 75
  return (0);
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_chk_reset_complete(struct beiscsi_hba *phba ) 
{ 
  unsigned int num_loop ;
  u8 *mpu_sem ;
  u32 status ;
  uint32_t log_value ;

  {
#line 81
  mpu_sem = (u8 *)0U;
#line 84
  num_loop = 1000U;
#line 85
  mpu_sem = phba->csr_va + 172UL;
#line 86
  msleep(5000U);
#line 88
  goto ldv_54191;
  ldv_54190: 
#line 89
  status = readl((void const volatile   *)mpu_sem);
#line 91
  if ((int )status < 0 || (status & 65535U) == 49152U) {
#line 92
    goto ldv_54189;
  } else {

  }
#line 93
  msleep(60U);
#line 94
  num_loop = num_loop - 1U;
  ldv_54191: ;
#line 88
  if (num_loop != 0U) {
#line 90
    goto ldv_54190;
  } else {

  }
  ldv_54189: ;
#line 97
  if ((int )status < 0 || num_loop == 0U) {
#line 98
    log_value = phba->attr_log_enable;
#line 98
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 98
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Failed in be_chk_reset_completestatus = 0x%x\n",
                 100, status);
    } else {

    }
#line 101
    return (-5);
  } else {

  }
#line 104
  return (0);
}
}
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void be_mcc_notify(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;

  {
#line 109
  mccq = & phba->ctrl.mcc_obj.q;
#line 110
  val = 0U;
#line 112
  val = (u32 )mccq->id | val;
#line 113
  val = val | 65536U;
#line 114
  iowrite32(val, (void *)phba->db_va + 320U);
#line 115
  return;
}
}
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
unsigned int alloc_mcc_tag(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;

  {
#line 119
  tag = 0U;
#line 121
  if (phba->ctrl.mcc_tag_available != 0U) {
#line 122
    tag = phba->ctrl.mcc_tag[(int )phba->ctrl.mcc_alloc_index];
#line 123
    phba->ctrl.mcc_tag[(int )phba->ctrl.mcc_alloc_index] = 0U;
#line 124
    phba->ctrl.mcc_numtag[tag] = 0U;
  } else {

  }
#line 126
  if (tag != 0U) {
#line 127
    phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available - 1U;
#line 128
    if ((unsigned int )phba->ctrl.mcc_alloc_index == 15U) {
#line 129
      phba->ctrl.mcc_alloc_index = 0U;
    } else {
#line 131
      phba->ctrl.mcc_alloc_index = (unsigned short )((int )phba->ctrl.mcc_alloc_index + 1);
    }
  } else {

  }
#line 133
  return (tag);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_mccq_compl(struct beiscsi_hba *phba , uint32_t tag , struct be_mcc_wrb **wrb ,
                       struct be_dma_mem *mbx_cmd_mem ) 
{ 
  int rc ;
  uint32_t mcc_tag_response ;
  uint16_t status ;
  uint16_t addl_status ;
  uint16_t wrb_num ;
  struct be_mcc_wrb *temp_wrb ;
  struct be_cmd_req_hdr *mbx_hdr ;
  struct be_cmd_resp_hdr *mbx_resp_hdr ;
  struct be_queue_info *mccq ;
  bool tmp ;
  long __ret ;
  unsigned long tmp___0 ;
  wait_queue_t __wait ;
  long __ret___0 ;
  unsigned long tmp___1 ;
  long __int ;
  long tmp___2 ;
  bool __cond ;
  bool __cond___0 ;
  struct be_dma_mem *tag_mem ;
  uint32_t log_value ;
  void *tmp___3 ;
  void *tmp___4 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 153
  rc = 0;
#line 155
  status = 0U;
#line 155
  addl_status = 0U;
#line 155
  wrb_num = 0U;
#line 159
  mccq = & phba->ctrl.mcc_obj.q;
#line 161
  tmp = beiscsi_error(phba);
#line 161
  if ((int )tmp) {
#line 162
    free_mcc_tag(& phba->ctrl, tag);
#line 163
    return (-1);
  } else {

  }
#line 167
  spin_lock(& phba->ctrl.mbox_lock);
#line 168
  phba->ctrl.ptag_state[tag].tag_state = 1U;
#line 169
  spin_unlock(& phba->ctrl.mbox_lock);
#line 172
  tmp___0 = msecs_to_jiffies(110000U);
#line 172
  __ret = (long )tmp___0;
#line 172
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c",
                176, 0);
#line 172
  __cond___0 = phba->ctrl.mcc_numtag[tag] != 0U;
#line 172
  if ((int )__cond___0 && __ret == 0L) {
#line 172
    __ret = 1L;
  } else {

  }
#line 172
  if (((int )__cond___0 || __ret == 0L) == 0) {
#line 172
    tmp___1 = msecs_to_jiffies(110000U);
#line 172
    __ret___0 = (long )tmp___1;
#line 172
    INIT_LIST_HEAD(& __wait.task_list);
#line 172
    __wait.flags = 0U;
    ldv_54227: 
#line 172
    tmp___2 = prepare_to_wait_event((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                                    & __wait, 1);
#line 172
    __int = tmp___2;
#line 172
    __cond = phba->ctrl.mcc_numtag[tag] != 0U;
#line 172
    if ((int )__cond && __ret___0 == 0L) {
#line 172
      __ret___0 = 1L;
    } else {

    }
#line 172
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 172
      goto ldv_54226;
    } else {

    }
#line 172
    if (__int != 0L) {
#line 172
      __ret___0 = __int;
#line 172
      goto ldv_54226;
    } else {

    }
#line 172
    __ret___0 = schedule_timeout(__ret___0);
#line 172
    goto ldv_54227;
    ldv_54226: 
#line 172
    finish_wait((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                & __wait);
#line 172
    __ret = __ret___0;
  } else {

  }
#line 172
  rc = (int )__ret;
#line 178
  if (rc <= 0) {
#line 181
    spin_lock(& phba->ctrl.mbox_lock);
#line 182
    phba->ctrl.ptag_state[tag].tag_state = 2U;
#line 183
    spin_unlock(& phba->ctrl.mbox_lock);
#line 186
    tag_mem = & phba->ctrl.ptag_state[tag].tag_mem_state;
#line 187
    if ((unsigned long )mbx_cmd_mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 188
      tag_mem->size = mbx_cmd_mem->size;
#line 189
      tag_mem->va = mbx_cmd_mem->va;
#line 190
      tag_mem->dma = mbx_cmd_mem->dma;
    } else {
#line 192
      tag_mem->size = 0U;
    }
#line 194
    log_value = phba->attr_log_enable;
#line 194
    if ((log_value & 41U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 194
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Cmd Completion timed out\n",
                 197);
    } else {

    }
#line 198
    return (-16);
  } else {
#line 200
    rc = 0;
#line 202
    spin_lock(& phba->ctrl.mbox_lock);
#line 203
    phba->ctrl.ptag_state[tag].tag_state = 0U;
#line 204
    spin_unlock(& phba->ctrl.mbox_lock);
  }
#line 207
  mcc_tag_response = phba->ctrl.mcc_numtag[tag];
#line 208
  status = (unsigned int )((uint16_t )mcc_tag_response) & 255U;
#line 209
  addl_status = (uint16_t )((mcc_tag_response & 65280U) >> 8);
#line 212
  if ((unsigned long )mbx_cmd_mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 213
    mbx_hdr = (struct be_cmd_req_hdr *)mbx_cmd_mem->va;
  } else {
#line 215
    wrb_num = (uint16_t )((mcc_tag_response & 16711680U) >> 16);
#line 217
    tmp___3 = queue_get_wrb(mccq, (unsigned int )wrb_num);
#line 217
    temp_wrb = (struct be_mcc_wrb *)tmp___3;
#line 218
    tmp___4 = embedded_payload(temp_wrb);
#line 218
    mbx_hdr = (struct be_cmd_req_hdr *)tmp___4;
#line 220
    if ((unsigned long )wrb != (unsigned long )((struct be_mcc_wrb **)0)) {
#line 221
      *wrb = temp_wrb;
    } else {

    }
  }
#line 224
  if ((unsigned int )status != 0U || (unsigned int )addl_status != 0U) {
#line 225
    log_value___0 = phba->attr_log_enable;
#line 225
    if ((log_value___0 & 41U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 225
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Cmd Failed for Subsys : %d Opcode : %d with Status : %d and Extd_Status : %d\n",
                 233, (int )mbx_hdr->subsystem, (int )mbx_hdr->opcode, (int )status,
                 (int )addl_status);
    } else {

    }
#line 235
    if ((unsigned int )status == 4U) {
#line 236
      mbx_resp_hdr = (struct be_cmd_resp_hdr *)mbx_hdr;
#line 237
      log_value___1 = phba->attr_log_enable;
#line 237
      if ((log_value___1 & 41U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 237
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BC_%d : Insufficient Buffer Error Resp_Len : %d Actual_Resp_Len : %d\n",
                   243, mbx_resp_hdr->response_length, mbx_resp_hdr->actual_resp_len);
      } else {

      }
#line 245
      rc = -11;
#line 246
      goto release_mcc_tag;
    } else {

    }
#line 248
    rc = -5;
  } else {

  }
  release_mcc_tag: 
#line 253
  free_mcc_tag(& phba->ctrl, tag);
#line 255
  return (rc);
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void free_mcc_tag(struct be_ctrl_info *ctrl , unsigned int tag ) 
{ 


  {
#line 260
  spin_lock(& ctrl->mbox_lock);
#line 261
  tag = tag & 255U;
#line 262
  ctrl->mcc_tag[(int )ctrl->mcc_free_index] = tag;
#line 263
  if ((unsigned int )ctrl->mcc_free_index == 15U) {
#line 264
    ctrl->mcc_free_index = 0U;
  } else {
#line 266
    ctrl->mcc_free_index = (unsigned short )((int )ctrl->mcc_free_index + 1);
  }
#line 267
  ctrl->mcc_tag_available = ctrl->mcc_tag_available + 1U;
#line 268
  spin_unlock(& ctrl->mbox_lock);
#line 269
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
bool is_link_state_evt(u32 trailer ) 
{ 


  {
#line 273
  return (((trailer >> 8) & 255U) == 1U);
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static bool is_iscsi_evt(u32 trailer ) 
{ 


  {
#line 280
  return (((trailer >> 8) & 255U) == 4U);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static int iscsi_evt_type(u32 trailer ) 
{ 


  {
#line 287
  return ((int )(trailer >> 16) & 15);
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 293
  if (compl->flags != 0U) {
#line 294
    compl->flags = compl->flags;
#line 295
    __ret_warn_on = (int )compl->flags >= 0;
#line 295
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 295
    if (tmp != 0L) {
#line 295
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c",
                         295);
    } else {

    }
#line 295
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 296
    return (1);
  } else {
#line 298
    return (0);
  }
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 303
  compl->flags = 0U;
#line 304
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mcc_compl_process(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) 
{ 
  u16 compl_status ;
  u16 extd_status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct be_cmd_req_hdr *hdr ;
  void *tmp___1 ;
  struct be_cmd_resp_hdr *resp_hdr ;
  uint32_t log_value ;

  {
#line 321
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 321
  wrb = tmp;
#line 322
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 322
  phba = (struct beiscsi_hba *)tmp___0;
#line 323
  tmp___1 = embedded_payload(wrb);
#line 323
  hdr = (struct be_cmd_req_hdr *)tmp___1;
#line 326
  swap_dws((void *)compl, 4);
#line 328
  compl_status = (u16 )compl->status;
#line 330
  if ((unsigned int )compl_status != 0U) {
#line 331
    extd_status = (u16 )(compl->status >> 16);
#line 334
    log_value = phba->attr_log_enable;
#line 334
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 334
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : error in cmd completion: Subsystem : %d Opcode : %d status(compl/extd)=%d/%d\n",
                 340, (int )hdr->subsystem, (int )hdr->opcode, (int )compl_status,
                 (int )extd_status);
    } else {

    }
#line 342
    if ((unsigned int )compl_status == 4U) {
#line 343
      resp_hdr = (struct be_cmd_resp_hdr *)hdr;
#line 344
      if (resp_hdr->response_length != 0U) {
#line 345
        return (0);
      } else {

      }
    } else {

    }
#line 347
    return (-16);
  } else {

  }
#line 349
  return (0);
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  u16 compl_status ;
  u16 extd_status ;
  unsigned short tag ;
  struct be_dma_mem *tag_mem ;
  uint32_t log_value ;

  {
#line 355
  tmp = pci_get_drvdata(ctrl->pdev);
#line 355
  phba = (struct beiscsi_hba *)tmp;
#line 359
  swap_dws((void *)compl, 4);
#line 361
  compl_status = (u16 )compl->status;
#line 367
  tag = (unsigned int )((unsigned short )compl->tag0) & 255U;
#line 368
  extd_status = (u16 )(compl->status >> 16);
#line 371
  ctrl->mcc_numtag[(int )tag] = 2147483648U;
#line 372
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | (compl->tag0 & 16711680U);
#line 373
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | ((unsigned int )((int )extd_status << 8) & 65535U);
#line 374
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | ((unsigned int )compl_status & 255U);
#line 376
  if ((unsigned int )ctrl->ptag_state[(int )tag].tag_state == 1U) {
#line 377
    __wake_up((wait_queue_head_t *)(& ctrl->mcc_wait) + (unsigned long )tag, 1U, 1,
              (void *)0);
  } else
#line 378
  if ((unsigned int )ctrl->ptag_state[(int )tag].tag_state == 2U) {
#line 380
    tag_mem = & ctrl->ptag_state[(int )tag].tag_mem_state;
#line 382
    log_value = phba->attr_log_enable;
#line 382
    if ((log_value & 35U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
#line 382
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Completion for timeout Command from FW\n",
                 386);
    } else {

    }
#line 388
    if (tag_mem->size != 0U) {
#line 389
      pci_free_consistent(ctrl->pdev, (size_t )tag_mem->size, tag_mem->va, tag_mem->dma);
    } else {

    }
#line 393
    spin_lock(& phba->ctrl.mbox_lock);
#line 394
    ctrl->ptag_state[(int )tag].tag_state = 0U;
#line 395
    spin_unlock(& phba->ctrl.mbox_lock);
#line 398
    free_mcc_tag(ctrl, (unsigned int )tag);
  } else {

  }
#line 401
  return (0);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static struct be_mcc_compl *be_mcc_compl_get(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 406
  mcc_cq = & phba->ctrl.mcc_obj.cq;
#line 407
  tmp = queue_tail_node(mcc_cq);
#line 407
  compl = (struct be_mcc_compl *)tmp;
#line 409
  tmp___0 = be_mcc_compl_is_new(compl);
#line 409
  if ((int )tmp___0) {
#line 410
    queue_tail_inc(mcc_cq);
#line 411
    return (compl);
  } else {

  }
#line 413
  return ((struct be_mcc_compl *)0);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void be2iscsi_fail_session(struct iscsi_cls_session *cls_session ) 
{ 
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  uint32_t iscsi_err_flag ;

  {
#line 424
  tmp = dev_to_shost___1(cls_session->dev.parent);
#line 424
  shost = tmp;
#line 425
  tmp___0 = shost_priv(shost);
#line 425
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
#line 428
  if ((phba->state & 8U) != 0U) {
#line 429
    iscsi_err_flag = 1018U;
  } else {
#line 431
    iscsi_err_flag = 1011U;
  }
#line 433
  iscsi_session_failure((struct iscsi_session *)cls_session->dd_data, 1011);
#line 434
  return;
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void beiscsi_async_link_state_process(struct beiscsi_hba *phba , struct be_async_event_link_state *evt ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 439
  if ((unsigned int )evt->port_link_status == 0U || (((int )evt->port_link_status & 2) != 0 && (unsigned int )evt->port_fault != 0U)) {
#line 442
    phba->state = 2U;
#line 444
    log_value = phba->attr_log_enable;
#line 444
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 444
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Link Down on Port %d\n",
                 447, (int )evt->physical_port);
    } else {

    }
#line 449
    iscsi_host_for_each_session(phba->shost, & be2iscsi_fail_session);
  } else
#line 451
  if ((int )evt->port_link_status & 1 || (((int )evt->port_link_status & 2) != 0 && (unsigned int )evt->port_fault == 0U)) {
#line 454
    phba->state = 17U;
#line 455
    phba->get_boot = 45;
#line 457
    log_value___0 = phba->attr_log_enable;
#line 457
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 457
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Link UP on Port %d\n",
                 460, (int )evt->physical_port);
    } else {

    }
  } else {

  }
#line 460
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_process_mcc(struct beiscsi_hba *phba ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_ctrl_info *ctrl ;
  int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 467
  num = 0;
#line 467
  status = 0;
#line 468
  ctrl = & phba->ctrl;
#line 470
  spin_lock_bh(& phba->ctrl.mcc_cq_lock);
#line 471
  goto ldv_54310;
  ldv_54309: ;
#line 472
  if ((compl->flags & 1073741824U) != 0U) {
#line 474
    tmp___1 = is_link_state_evt(compl->flags);
#line 474
    if ((int )tmp___1) {
#line 476
      beiscsi_async_link_state_process(phba, (struct be_async_event_link_state *)compl);
    } else {
#line 478
      tmp___0 = is_iscsi_evt(compl->flags);
#line 478
      if ((int )tmp___0) {
#line 479
        tmp = iscsi_evt_type(compl->flags);
#line 479
        switch (tmp) {
        case 4: ;
        case 5: ;
        case 7: 
#line 483
        phba->state = phba->state | 16U;
#line 484
        phba->get_boot = 45;
#line 485
        log_value = phba->attr_log_enable;
#line 485
        if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 485
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Async iscsi Event, flags handled = 0x%08x\n", 490, compl->flags);
        } else {

        }
#line 491
        goto ldv_54305;
        default: 
#line 493
        phba->state = phba->state | 16U;
#line 494
        phba->get_boot = 45;
#line 495
        log_value___0 = phba->attr_log_enable;
#line 495
        if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 495
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Unsupported Async Event, flags = 0x%08x\n", 500, compl->flags);
        } else {

        }
        }
        ldv_54305: ;
      } else {
#line 503
        log_value___1 = phba->attr_log_enable;
#line 503
        if ((log_value___1 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 503
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Unsupported Async Event, flags = 0x%08x\n", 507, compl->flags);
        } else {

        }
      }
    }
  } else
#line 509
  if ((compl->flags & 268435456U) != 0U) {
#line 510
    status = be_mcc_compl_process(ctrl, compl);
#line 511
    atomic_dec(& phba->ctrl.mcc_obj.q.used);
  } else {

  }
#line 513
  be_mcc_compl_use(compl);
#line 514
  num = num + 1;
  ldv_54310: 
#line 471
  compl = be_mcc_compl_get(phba);
#line 471
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 473
    goto ldv_54309;
  } else {

  }

#line 517
  if (num != 0) {
#line 518
    hwi_ring_cq_db(phba, (unsigned int )phba->ctrl.mcc_obj.cq.id, (unsigned int )num,
                   1, 0);
  } else {

  }
#line 520
  spin_unlock_bh(& phba->ctrl.mcc_cq_lock);
#line 521
  return (status);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mcc_wait_compl(struct beiscsi_hba *phba ) 
{ 
  int i ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t log_value ;

  {
#line 538
  i = 0;
#line 538
  goto ldv_54319;
  ldv_54318: 
#line 539
  tmp = beiscsi_error(phba);
#line 539
  if ((int )tmp) {
#line 540
    return (-5);
  } else {

  }
#line 542
  status = beiscsi_process_mcc(phba);
#line 543
  if (status != 0) {
#line 544
    return (status);
  } else {

  }
#line 546
  tmp___0 = atomic_read((atomic_t const   *)(& phba->ctrl.mcc_obj.q.used));
#line 546
  if (tmp___0 == 0) {
#line 547
    goto ldv_54317;
  } else {

  }
#line 548
  __const_udelay(429500UL);
#line 538
  i = i + 1;
  ldv_54319: ;
#line 538
  if (i <= 119999) {
#line 540
    goto ldv_54318;
  } else {

  }
  ldv_54317: ;
#line 550
  if (i == 120000) {
#line 551
    log_value = phba->attr_log_enable;
#line 551
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 551
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW Timed Out\n",
                 553);
    } else {

    }
#line 554
    phba->fw_timeout = 1;
#line 555
    beiscsi_ue_detect(phba);
#line 556
    return (-16);
  } else {

  }
#line 558
  return (0);
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_mcc_notify_wait(struct beiscsi_hba *phba ) 
{ 
  int tmp ;

  {
#line 573
  be_mcc_notify(phba);
#line 574
  tmp = be_mcc_wait_compl(phba);
#line 574
  return (tmp);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mbox_db_ready_wait(struct be_ctrl_info *ctrl ) 
{ 
  void *db ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  unsigned long timeout ;
  bool read_flag ;
  int ret ;
  int i ;
  u32 ready ;
  wait_queue_head_t rdybit_check_q ;
  struct lock_class_key __key ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  long __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  bool __cond ;
  bool __cond___0 ;
  uint32_t log_value ;

  {
#line 591
  db = (void *)ctrl->db + 352U;
#line 592
  tmp = pci_get_drvdata(ctrl->pdev);
#line 592
  phba = (struct beiscsi_hba *)tmp;
#line 594
  read_flag = 0;
#line 595
  ret = 0;
#line 597
  __init_waitqueue_head(& rdybit_check_q, "&rdybit_check_q", & __key);
#line 597
  rdybit_check_q = rdybit_check_q;
#line 599
  tmp___0 = beiscsi_error(phba);
#line 599
  if ((int )tmp___0) {
#line 600
    return (-5);
  } else {

  }
#line 602
  timeout = (unsigned long )jiffies + 27500UL;
  ldv_54363: 
#line 605
  i = 0;
#line 605
  goto ldv_54343;
  ldv_54342: 
#line 606
  tmp___1 = ioread32(db);
#line 606
  ready = tmp___1 & 1U;
#line 607
  if (ready != 0U) {
#line 608
    read_flag = 1;
#line 609
    goto ldv_54337;
  } else {

  }
#line 611
  if (1) {
#line 611
    __const_udelay(4295000UL);
  } else {
#line 611
    __ms = 1UL;
#line 611
    goto ldv_54340;
    ldv_54339: 
#line 611
    __const_udelay(4295000UL);
    ldv_54340: 
#line 611
    tmp___2 = __ms;
#line 611
    __ms = __ms - 1UL;
#line 611
    if (tmp___2 != 0UL) {
#line 613
      goto ldv_54339;
    } else {

    }

  }
#line 605
  i = i + 1;
  ldv_54343: ;
#line 605
  if (i <= 3999) {
#line 607
    goto ldv_54342;
  } else {

  }
  ldv_54337: ;
#line 614
  if (! read_flag) {
#line 615
    __ret = 1250L;
#line 615
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c",
                  617, 0);
#line 615
    __cond___0 = (bool )(! ((int )read_flag != 0));
#line 615
    if ((int )__cond___0 && __ret == 0L) {
#line 615
      __ret = 1L;
    } else {

    }
#line 615
    if (((int )__cond___0 || __ret == 0L) == 0) {
#line 615
      __ret___0 = 1250L;
#line 615
      INIT_LIST_HEAD(& __wait.task_list);
#line 615
      __wait.flags = 0U;
      ldv_54354: 
#line 615
      tmp___3 = prepare_to_wait_event(& rdybit_check_q, & __wait, 2);
#line 615
      __int = tmp___3;
#line 615
      __cond = (bool )(! ((int )read_flag != 0));
#line 615
      if ((int )__cond && __ret___0 == 0L) {
#line 615
        __ret___0 = 1L;
      } else {

      }
#line 615
      if (((int )__cond || __ret___0 == 0L) != 0) {
#line 615
        goto ldv_54353;
      } else {

      }
#line 615
      __ret___0 = schedule_timeout(__ret___0);
#line 615
      goto ldv_54354;
      ldv_54353: 
#line 615
      finish_wait(& rdybit_check_q, & __wait);
#line 615
      __ret = __ret___0;
    } else {

    }
  } else {

  }
#line 619
  if ((long )((unsigned long )jiffies - timeout) < 0L && ! read_flag) {
#line 621
    goto ldv_54363;
  } else {

  }

#line 621
  if (! read_flag) {
#line 622
    log_value = phba->attr_log_enable;
#line 622
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 622
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW Timed Out\n",
                 624);
    } else {

    }
#line 625
    phba->fw_timeout = 1;
#line 626
    beiscsi_ue_detect(phba);
#line 627
    ret = -16;
  } else {

  }
#line 630
  return (ret);
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_mbox_notify(struct be_ctrl_info *ctrl ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  bool tmp___0 ;

  {
#line 647
  val = 0U;
#line 648
  db = (void *)ctrl->db + 352U;
#line 649
  mbox_mem = & ctrl->mbox_mem;
#line 650
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 651
  compl = & mbox->compl;
#line 652
  tmp = pci_get_drvdata(ctrl->pdev);
#line 652
  phba = (struct beiscsi_hba *)tmp;
#line 654
  status = be_mbox_db_ready_wait(ctrl);
#line 655
  if (status != 0) {
#line 656
    return (status);
  } else {

  }
#line 658
  val = val & 4294967294U;
#line 659
  val = val | 2U;
#line 660
  val = ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U) | val;
#line 661
  iowrite32(val, db);
#line 663
  status = be_mbox_db_ready_wait(ctrl);
#line 664
  if (status != 0) {
#line 665
    return (status);
  } else {

  }
#line 667
  val = 0U;
#line 668
  val = val & 4294967294U;
#line 669
  val = val & 4294967293U;
#line 670
  val = ((unsigned int )(mbox_mem->dma >> 4) << 2) | val;
#line 671
  iowrite32(val, db);
#line 673
  status = be_mbox_db_ready_wait(ctrl);
#line 674
  if (status != 0) {
#line 675
    return (status);
  } else {

  }
#line 677
  tmp___0 = be_mcc_compl_is_new(compl);
#line 677
  if ((int )tmp___0) {
#line 678
    status = be_mcc_compl_process(ctrl, & mbox->compl);
#line 679
    be_mcc_compl_use(compl);
#line 680
    if (status != 0) {
#line 681
      log_value = phba->attr_log_enable;
#line 681
      if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 681
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BC_%d : After be_mcc_compl_process\n", 683);
      } else {

      }
#line 685
      return (status);
    } else {

    }
  } else {
#line 688
    log_value___0 = phba->attr_log_enable;
#line 688
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 688
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Invalid Mailbox Completion\n",
                 690);
    } else {

    }
#line 692
    return (-16);
  }
#line 694
  return (0);
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mbox_notify_wait(struct beiscsi_hba *phba ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  struct be_ctrl_info *ctrl ;
  uint32_t log_value ;
  bool tmp ;

  {
#line 704
  val = 0U;
#line 705
  db = (void *)phba->ctrl.db + 352U;
#line 706
  mbox_mem = & phba->ctrl.mbox_mem;
#line 707
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 708
  compl = & mbox->compl;
#line 709
  ctrl = & phba->ctrl;
#line 711
  status = be_mbox_db_ready_wait(ctrl);
#line 712
  if (status != 0) {
#line 713
    return (status);
  } else {

  }
#line 715
  val = val | 2U;
#line 717
  val = ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U) | val;
#line 718
  iowrite32(val, db);
#line 721
  status = be_mbox_db_ready_wait(ctrl);
#line 722
  if (status != 0) {
#line 723
    return (status);
  } else {

  }
#line 725
  val = 0U;
#line 727
  val = ((unsigned int )(mbox_mem->dma >> 4) << 2) | val;
#line 728
  iowrite32(val, db);
#line 730
  status = be_mbox_db_ready_wait(ctrl);
#line 731
  if (status != 0) {
#line 732
    return (status);
  } else {

  }
#line 735
  tmp = be_mcc_compl_is_new(compl);
#line 735
  if ((int )tmp) {
#line 736
    status = be_mcc_compl_process(ctrl, & mbox->compl);
#line 737
    be_mcc_compl_use(compl);
#line 738
    if (status != 0) {
#line 739
      return (status);
    } else {

    }
  } else {
#line 741
    log_value = phba->attr_log_enable;
#line 741
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
#line 741
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : invalid mailbox completion\n",
                 743);
    } else {

    }
#line 745
    return (-16);
  }
#line 747
  return (0);
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void be_wrb_hdr_prepare(struct be_mcc_wrb *wrb , int payload_len , bool embedded ,
                        u8 sge_cnt ) 
{ 


  {
#line 753
  if ((int )embedded) {
#line 754
    wrb->embedded = wrb->embedded | 1U;
  } else {
#line 756
    wrb->embedded = wrb->embedded | ((u32 )((int )sge_cnt << 3) & 255U);
  }
#line 758
  wrb->payload_length = (u32 )payload_len;
#line 759
  swap_dws((void *)wrb, 8);
#line 760
  return;
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
void be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem , u8 opcode ,
                        int cmd_len ) 
{ 


  {
#line 765
  req_hdr->opcode = opcode;
#line 766
  req_hdr->subsystem = subsystem;
#line 767
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 768
  req_hdr->timeout = 100U;
#line 769
  return;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  u64 dma ;
  unsigned int _min1 ;
  u32 _min2 ;

  {
#line 775
  dma = mem->dma;
#line 777
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 777
  _min2 = max_pages;
#line 777
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 778
  i = 0;
#line 778
  goto ldv_54413;
  ldv_54412: 
#line 779
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 780
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 781
  dma = dma + 4096ULL;
#line 778
  i = i + 1;
  ldv_54413: ;
#line 778
  if (i < buf_pages) {
#line 780
    goto ldv_54412;
  } else {

  }

#line 785
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static u32 eq_delay_to_mult(u32 usec_delay ) 
{ 
  u32 round ;
  u32 multiplier ;
  u32 interrupt_rate ;
  u32 _min1 ;
  unsigned int _min2 ;

  {
#line 788
  round = 10U;
#line 791
  if (usec_delay == 0U) {
#line 792
    multiplier = 0U;
  } else {
#line 794
    interrupt_rate = 1000000U / usec_delay;
#line 795
    if (interrupt_rate == 0U) {
#line 796
      multiplier = 1023U;
    } else {
#line 798
      multiplier = (651042U - interrupt_rate) * round;
#line 799
      multiplier = multiplier / interrupt_rate;
#line 800
      multiplier = (round / 2U + multiplier) / round;
#line 801
      _min1 = multiplier;
#line 801
      _min2 = 1023U;
#line 801
      multiplier = _min1 < _min2 ? _min1 : _min2;
    }
  }
#line 804
  return (multiplier);
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem ) 
{ 


  {
#line 809
  return (& ((struct be_mcc_mailbox *)mbox_mem->va)->wrb);
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
#line 814
  mccq = & phba->ctrl.mcc_obj.q;
#line 817
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
#line 817
  __ret_warn_on = tmp >= (int )mccq->len;
#line 817
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 817
  if (tmp___0 != 0L) {
#line 817
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c",
                       817);
  } else {

  }
#line 817
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 818
  tmp___1 = queue_head_node(mccq);
#line 818
  wrb = (struct be_mcc_wrb *)tmp___1;
#line 819
  memset((void *)wrb, 0, 256UL);
#line 820
  wrb->tag0 = (u32 )(((int )mccq->head & 255) << 16);
#line 821
  queue_head_inc(mccq);
#line 822
  atomic_inc(& mccq->used);
#line 823
  return (wrb);
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl , struct be_queue_info *eq , int eq_delay ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_eq_create *req ;
  void *tmp___0 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___1 ;
  struct be_dma_mem *q_mem ;
  int status ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;

  {
#line 830
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 830
  wrb = tmp;
#line 831
  tmp___0 = embedded_payload(wrb);
#line 831
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 832
  tmp___1 = embedded_payload(wrb);
#line 832
  resp = (struct be_cmd_resp_eq_create *)tmp___1;
#line 833
  q_mem = & eq->dma_mem;
#line 836
  spin_lock(& ctrl->mbox_lock);
#line 837
  memset((void *)wrb, 0, 256UL);
#line 839
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 841
  be_cmd_hdr_prepare(& req->hdr, 1, 13, 100);
#line 844
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 846
  tmp___2 = amap_mask(8U);
#line 846
  amap_set((void *)(& req->context), 2U, tmp___2, 4U, (ctrl->pdev)->devfn & 7U);
#line 848
  tmp___3 = amap_mask(1U);
#line 848
  amap_set((void *)(& req->context), 0U, tmp___3, 29U, 1U);
#line 849
  tmp___4 = amap_mask(1U);
#line 849
  amap_set((void *)(& req->context), 0U, tmp___4, 31U, 0U);
#line 850
  tmp___5 = __ilog2_u32((unsigned int )eq->len / 256U);
#line 850
  tmp___6 = amap_mask(3U);
#line 850
  amap_set((void *)(& req->context), 1U, tmp___6, 26U, (u32 )tmp___5);
#line 852
  tmp___7 = eq_delay_to_mult((u32 )eq_delay);
#line 852
  tmp___8 = amap_mask(10U);
#line 852
  amap_set((void *)(& req->context), 2U, tmp___8, 13U, tmp___7);
#line 854
  swap_dws((void *)(& req->context), 16);
#line 856
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 858
  status = be_mbox_notify(ctrl);
#line 859
  if (status == 0) {
#line 860
    eq->id = resp->eq_id;
#line 861
    eq->created = 1;
  } else {

  }
#line 863
  spin_unlock(& ctrl->mbox_lock);
#line 864
  return (status);
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_fw_initialize(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  int status ;
  u8 *endian_check ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  uint32_t log_value ;

  {
#line 879
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 879
  wrb = tmp;
#line 880
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 880
  phba = (struct beiscsi_hba *)tmp___0;
#line 884
  spin_lock(& ctrl->mbox_lock);
#line 885
  memset((void *)wrb, 0, 256UL);
#line 887
  endian_check = (u8 *)wrb;
#line 888
  tmp___1 = endian_check;
#line 888
  endian_check = endian_check + 1;
#line 888
  *tmp___1 = 255U;
#line 889
  tmp___2 = endian_check;
#line 889
  endian_check = endian_check + 1;
#line 889
  *tmp___2 = 18U;
#line 890
  tmp___3 = endian_check;
#line 890
  endian_check = endian_check + 1;
#line 890
  *tmp___3 = 52U;
#line 891
  tmp___4 = endian_check;
#line 891
  endian_check = endian_check + 1;
#line 891
  *tmp___4 = 255U;
#line 892
  tmp___5 = endian_check;
#line 892
  endian_check = endian_check + 1;
#line 892
  *tmp___5 = 255U;
#line 893
  tmp___6 = endian_check;
#line 893
  endian_check = endian_check + 1;
#line 893
  *tmp___6 = 86U;
#line 894
  tmp___7 = endian_check;
#line 894
  endian_check = endian_check + 1;
#line 894
  *tmp___7 = 120U;
#line 895
  tmp___8 = endian_check;
#line 895
  endian_check = endian_check + 1;
#line 895
  *tmp___8 = 255U;
#line 896
  swap_dws((void *)wrb, 256);
#line 898
  status = be_mbox_notify(ctrl);
#line 899
  if (status != 0) {
#line 900
    log_value = phba->attr_log_enable;
#line 900
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 900
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : be_cmd_fw_initialize Failed\n",
                 901);
    } else {

    }
  } else {

  }
#line 903
  spin_unlock(& ctrl->mbox_lock);
#line 904
  return (status);
}
}
#line 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_fw_uninit(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  int status ;
  u8 *endian_check ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  uint32_t log_value ;

  {
#line 919
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 919
  wrb = tmp;
#line 920
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 920
  phba = (struct beiscsi_hba *)tmp___0;
#line 924
  spin_lock(& ctrl->mbox_lock);
#line 925
  memset((void *)wrb, 0, 256UL);
#line 927
  endian_check = (u8 *)wrb;
#line 928
  tmp___1 = endian_check;
#line 928
  endian_check = endian_check + 1;
#line 928
  *tmp___1 = 255U;
#line 929
  tmp___2 = endian_check;
#line 929
  endian_check = endian_check + 1;
#line 929
  *tmp___2 = 170U;
#line 930
  tmp___3 = endian_check;
#line 930
  endian_check = endian_check + 1;
#line 930
  *tmp___3 = 187U;
#line 931
  tmp___4 = endian_check;
#line 931
  endian_check = endian_check + 1;
#line 931
  *tmp___4 = 255U;
#line 932
  tmp___5 = endian_check;
#line 932
  endian_check = endian_check + 1;
#line 932
  *tmp___5 = 255U;
#line 933
  tmp___6 = endian_check;
#line 933
  endian_check = endian_check + 1;
#line 933
  *tmp___6 = 204U;
#line 934
  tmp___7 = endian_check;
#line 934
  endian_check = endian_check + 1;
#line 934
  *tmp___7 = 221U;
#line 935
  *endian_check = 255U;
#line 937
  swap_dws((void *)wrb, 256);
#line 939
  status = be_mbox_notify(ctrl);
#line 940
  if (status != 0) {
#line 941
    log_value = phba->attr_log_enable;
#line 941
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 941
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : be_cmd_fw_uninit Failed\n",
                 942);
    } else {

    }
  } else {

  }
#line 944
  spin_unlock(& ctrl->mbox_lock);
#line 945
  return (status);
}
}
#line 948 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl , struct be_queue_info *cq , struct be_queue_info *eq ,
                          bool sol_evts , bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_cq_create *req ;
  void *tmp___0 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___1 ;
  struct beiscsi_hba *phba ;
  void *tmp___2 ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  int tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  uint32_t log_value ;

  {
#line 952
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 952
  wrb = tmp;
#line 953
  tmp___0 = embedded_payload(wrb);
#line 953
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 954
  tmp___1 = embedded_payload(wrb);
#line 954
  resp = (struct be_cmd_resp_cq_create *)tmp___1;
#line 955
  tmp___2 = pci_get_drvdata(ctrl->pdev);
#line 955
  phba = (struct beiscsi_hba *)tmp___2;
#line 956
  q_mem = & cq->dma_mem;
#line 957
  ctxt = (void *)(& req->context);
#line 960
  spin_lock(& ctrl->mbox_lock);
#line 961
  memset((void *)wrb, 0, 256UL);
#line 963
  be_wrb_hdr_prepare(wrb, 68, 1, 0);
#line 965
  be_cmd_hdr_prepare(& req->hdr, 1, 12, 68);
#line 968
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 969
  if (phba->generation == 3U || phba->generation == 2U) {
#line 970
    tmp___3 = amap_mask(2U);
#line 970
    amap_set(ctxt, 0U, tmp___3, 12U, (u32 )coalesce_wm);
#line 972
    tmp___4 = amap_mask(1U);
#line 972
    amap_set(ctxt, 0U, tmp___4, 14U, (u32 )no_delay);
#line 973
    tmp___5 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 973
    tmp___6 = amap_mask(2U);
#line 973
    amap_set(ctxt, 0U, tmp___6, 27U, (u32 )tmp___5);
#line 975
    tmp___7 = amap_mask(1U);
#line 975
    amap_set(ctxt, 0U, tmp___7, 29U, 1U);
#line 976
    tmp___8 = amap_mask(1U);
#line 976
    amap_set(ctxt, 0U, tmp___8, 30U, (u32 )sol_evts);
#line 977
    tmp___9 = amap_mask(1U);
#line 977
    amap_set(ctxt, 0U, tmp___9, 31U, 1U);
#line 978
    tmp___10 = amap_mask(8U);
#line 978
    amap_set(ctxt, 1U, tmp___10, 22U, (u32 )eq->id);
#line 979
    tmp___11 = amap_mask(1U);
#line 979
    amap_set(ctxt, 1U, tmp___11, 31U, 1U);
#line 980
    tmp___12 = amap_mask(8U);
#line 980
    amap_set(ctxt, 2U, tmp___12, 4U, (ctrl->pdev)->devfn & 7U);
  } else {
#line 983
    req->hdr.version = 2U;
#line 984
    req->page_size = 1U;
#line 985
    tmp___13 = amap_mask(2U);
#line 985
    amap_set(ctxt, 0U, tmp___13, 12U, (u32 )coalesce_wm);
#line 987
    tmp___14 = amap_mask(1U);
#line 987
    amap_set(ctxt, 0U, tmp___14, 14U, (u32 )no_delay);
#line 989
    tmp___15 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 989
    tmp___16 = amap_mask(2U);
#line 989
    amap_set(ctxt, 0U, tmp___16, 27U, (u32 )tmp___15);
#line 991
    tmp___17 = amap_mask(1U);
#line 991
    amap_set(ctxt, 0U, tmp___17, 29U, 1U);
#line 992
    tmp___18 = amap_mask(1U);
#line 992
    amap_set(ctxt, 0U, tmp___18, 31U, 1U);
#line 993
    tmp___19 = amap_mask(16U);
#line 993
    amap_set(ctxt, 1U, tmp___19, 0U, (u32 )eq->id);
#line 994
    tmp___20 = amap_mask(1U);
#line 994
    amap_set(ctxt, 1U, tmp___20, 31U, 1U);
  }
#line 997
  swap_dws(ctxt, 16);
#line 999
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 4U, q_mem);
#line 1001
  status = be_mbox_notify(ctrl);
#line 1002
  if (status == 0) {
#line 1003
    cq->id = resp->cq_id;
#line 1004
    cq->created = 1;
  } else {
#line 1006
    log_value = phba->attr_log_enable;
#line 1006
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1006
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : In be_cmd_cq_create, status=ox%08x\n",
                 1008, status);
    } else {

    }
  }
#line 1010
  spin_unlock(& ctrl->mbox_lock);
#line 1012
  return (status);
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
#line 1017
  tmp = fls(q_len);
#line 1017
  len_encoded = (u32 )tmp;
#line 1018
  if (len_encoded == 16U) {
#line 1019
    len_encoded = 0U;
  } else {

  }
#line 1020
  return (len_encoded);
}
}
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_mccq_create(struct beiscsi_hba *phba , struct be_queue_info *mccq ,
                            struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  struct be_ctrl_info *ctrl ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
#line 1029
  q_mem = & mccq->dma_mem;
#line 1034
  spin_lock(& phba->ctrl.mbox_lock);
#line 1035
  ctrl = & phba->ctrl;
#line 1036
  wrb = wrb_from_mbox(& ctrl->mbox_mem);
#line 1037
  memset((void *)wrb, 0, 256UL);
#line 1038
  tmp = embedded_payload(wrb);
#line 1038
  req = (struct be_cmd_req_mcc_create *)tmp;
#line 1039
  ctxt = (void *)(& req->context);
#line 1041
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 1043
  be_cmd_hdr_prepare(& req->hdr, 1, 21, 100);
#line 1046
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1048
  tmp___0 = amap_mask(8U);
#line 1048
  amap_set(ctxt, 1U, tmp___0, 14U, (phba->pcidev)->devfn & 7U);
#line 1050
  tmp___1 = amap_mask(1U);
#line 1050
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1051
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1051
  tmp___3 = amap_mask(4U);
#line 1051
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1053
  tmp___4 = amap_mask(10U);
#line 1053
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1055
  swap_dws(ctxt, 16);
#line 1057
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1059
  status = be_mbox_notify_wait(phba);
#line 1060
  if (status == 0) {
#line 1061
    tmp___5 = embedded_payload(wrb);
#line 1061
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1062
    mccq->id = resp->id;
#line 1063
    mccq->created = 1;
  } else {

  }
#line 1065
  spin_unlock(& phba->ctrl.mbox_lock);
#line 1067
  return (status);
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_q_destroy *req ;
  void *tmp___0 ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  uint32_t log_value ;

  {
#line 1073
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1073
  wrb = tmp;
#line 1074
  tmp___0 = embedded_payload(wrb);
#line 1074
  req = (struct be_cmd_req_q_destroy *)tmp___0;
#line 1075
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1075
  phba = (struct beiscsi_hba *)tmp___1;
#line 1076
  subsys = 0U;
#line 1076
  opcode = 0U;
#line 1079
  log_value = phba->attr_log_enable;
#line 1079
  if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
#line 1079
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : In beiscsi_cmd_q_destroy queue_type : %d\n",
               1081, queue_type);
  } else {

  }
#line 1083
  spin_lock(& ctrl->mbox_lock);
#line 1084
  memset((void *)wrb, 0, 256UL);
#line 1085
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1087
  switch (queue_type) {
  case 1: 
#line 1089
  subsys = 1U;
#line 1090
  opcode = 55U;
#line 1091
  goto ldv_54511;
  case 2: 
#line 1093
  subsys = 1U;
#line 1094
  opcode = 54U;
#line 1095
  goto ldv_54511;
  case 3: 
#line 1097
  subsys = 1U;
#line 1098
  opcode = 53U;
#line 1099
  goto ldv_54511;
  case 4: 
#line 1101
  subsys = 2U;
#line 1102
  opcode = 67U;
#line 1103
  goto ldv_54511;
  case 5: 
#line 1105
  subsys = 2U;
#line 1106
  opcode = 65U;
#line 1107
  goto ldv_54511;
  case 6: 
#line 1109
  subsys = 2U;
#line 1110
  opcode = 3U;
#line 1111
  goto ldv_54511;
  default: 
#line 1113
  spin_unlock(& ctrl->mbox_lock);
#line 1114
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"),
                       "i" (1114), "i" (12UL));
  ldv_54518: ;
#line 1114
  goto ldv_54518;
#line 1115
  return (-6);
  }
  ldv_54511: 
#line 1117
  be_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20);
#line 1118
  if (queue_type != 6) {
#line 1119
    req->id = q->id;
  } else {

  }
#line 1121
  status = be_mbox_notify(ctrl);
#line 1123
  spin_unlock(& ctrl->mbox_lock);
#line 1124
  return (status);
}
}
#line 1145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl , struct be_queue_info *cq ,
                                    struct be_queue_info *dq , int length , int entry_size ,
                                    uint8_t is_header , uint8_t ulp_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_defq_create_req *req ;
  void *tmp___0 ;
  struct be_dma_mem *q_mem ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  void *ctxt ;
  int status ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct be_ring *defq_ring ;
  struct be_defq_create_resp *resp ;
  void *tmp___15 ;

  {
#line 1151
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1151
  wrb = tmp;
#line 1152
  tmp___0 = embedded_payload(wrb);
#line 1152
  req = (struct be_defq_create_req *)tmp___0;
#line 1153
  q_mem = & dq->dma_mem;
#line 1154
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1154
  phba = (struct beiscsi_hba *)tmp___1;
#line 1155
  ctxt = (void *)(& req->context);
#line 1158
  spin_lock(& ctrl->mbox_lock);
#line 1159
  memset((void *)wrb, 0, 256UL);
#line 1161
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 1163
  be_cmd_hdr_prepare(& req->hdr, 2, 64, 100);
#line 1166
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1167
  if ((unsigned int )phba->fw_config.dual_ulp_aware != 0U) {
#line 1168
    req->ulp_num = ulp_num;
#line 1169
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 1U);
#line 1170
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 2U);
  } else {

  }
#line 1173
  if (phba->generation == 3U || phba->generation == 2U) {
#line 1174
    tmp___2 = amap_mask(9U);
#line 1174
    amap_set(ctxt, 1U, tmp___2, 22U, 0U);
#line 1176
    tmp___3 = amap_mask(1U);
#line 1176
    amap_set(ctxt, 1U, tmp___3, 31U, 1U);
#line 1178
    tmp___4 = amap_mask(8U);
#line 1178
    amap_set(ctxt, 1U, tmp___4, 14U, (ctrl->pdev)->devfn & 7U);
#line 1180
    tmp___5 = be_encoded_q_len((int )((unsigned long )length / 8UL));
#line 1180
    tmp___6 = amap_mask(4U);
#line 1180
    amap_set(ctxt, 0U, tmp___6, 16U, tmp___5);
#line 1184
    tmp___7 = amap_mask(16U);
#line 1184
    amap_set(ctxt, 2U, tmp___7, 0U, (u32 )entry_size);
#line 1186
    tmp___8 = amap_mask(10U);
#line 1186
    amap_set(ctxt, 2U, tmp___8, 16U, (u32 )cq->id);
  } else {
#line 1189
    tmp___9 = amap_mask(9U);
#line 1189
    amap_set(ctxt, 1U, tmp___9, 22U, 0U);
#line 1191
    tmp___10 = amap_mask(1U);
#line 1191
    amap_set(ctxt, 1U, tmp___10, 31U, 1U);
#line 1193
    tmp___11 = be_encoded_q_len((int )((unsigned long )length / 8UL));
#line 1193
    tmp___12 = amap_mask(4U);
#line 1193
    amap_set(ctxt, 0U, tmp___12, 16U, tmp___11);
#line 1197
    tmp___13 = amap_mask(16U);
#line 1197
    amap_set(ctxt, 2U, tmp___13, 0U, (u32 )entry_size);
#line 1199
    tmp___14 = amap_mask(16U);
#line 1199
    amap_set(ctxt, 2U, tmp___14, 16U, (u32 )cq->id);
  }
#line 1203
  swap_dws(ctxt, 16);
#line 1205
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1207
  status = be_mbox_notify(ctrl);
#line 1208
  if (status == 0) {
#line 1210
    tmp___15 = embedded_payload(wrb);
#line 1210
    resp = (struct be_defq_create_resp *)tmp___15;
#line 1212
    dq->id = resp->id;
#line 1213
    dq->created = 1;
#line 1214
    if ((unsigned int )is_header != 0U) {
#line 1215
      defq_ring = (struct be_ring *)(& (phba->phwi_ctrlr)->default_pdu_hdr) + (unsigned long )ulp_num;
    } else {
#line 1217
      defq_ring = (struct be_ring *)(& (phba->phwi_ctrlr)->default_pdu_data) + (unsigned long )ulp_num;
    }
#line 1220
    defq_ring->id = (u32 )dq->id;
#line 1222
    if ((unsigned int )phba->fw_config.dual_ulp_aware == 0U) {
#line 1223
      defq_ring->ulp_num = 0U;
#line 1224
      defq_ring->doorbell_offset = 160U;
    } else {
#line 1226
      defq_ring->ulp_num = resp->ulp_num;
#line 1227
      defq_ring->doorbell_offset = resp->doorbell_offset;
    }
  } else {

  }
#line 1230
  spin_unlock(& ctrl->mbox_lock);
#line 1232
  return (status);
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_wrbq_create(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem , struct be_queue_info *wrbq ,
                       struct hwi_wrb_context *pwrb_context , uint8_t ulp_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_wrbq_create_req *req ;
  void *tmp___0 ;
  struct be_wrbq_create_resp *resp ;
  void *tmp___1 ;
  struct beiscsi_hba *phba ;
  void *tmp___2 ;
  int status ;

  {
#line 1252
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1252
  wrb = tmp;
#line 1253
  tmp___0 = embedded_payload(wrb);
#line 1253
  req = (struct be_wrbq_create_req *)tmp___0;
#line 1254
  tmp___1 = embedded_payload(wrb);
#line 1254
  resp = (struct be_wrbq_create_resp *)tmp___1;
#line 1255
  tmp___2 = pci_get_drvdata(ctrl->pdev);
#line 1255
  phba = (struct beiscsi_hba *)tmp___2;
#line 1258
  spin_lock(& ctrl->mbox_lock);
#line 1259
  memset((void *)wrb, 0, 256UL);
#line 1261
  be_wrb_hdr_prepare(wrb, 84, 1, 0);
#line 1263
  be_cmd_hdr_prepare(& req->hdr, 2, 66, 84);
#line 1265
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1267
  if ((unsigned int )phba->fw_config.dual_ulp_aware != 0U) {
#line 1268
    req->ulp_num = ulp_num;
#line 1269
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 1U);
#line 1270
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 2U);
  } else {

  }
#line 1273
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1275
  status = be_mbox_notify(ctrl);
#line 1276
  if (status == 0) {
#line 1277
    wrbq->id = resp->cid;
#line 1278
    wrbq->created = 1;
#line 1280
    pwrb_context->cid = wrbq->id;
#line 1281
    if ((unsigned int )phba->fw_config.dual_ulp_aware == 0U) {
#line 1282
      pwrb_context->doorbell_offset = 64U;
#line 1283
      pwrb_context->ulp_num = 0U;
    } else {
#line 1285
      pwrb_context->ulp_num = resp->ulp_num;
#line 1286
      pwrb_context->doorbell_offset = resp->doorbell_offset;
    }
  } else {

  }
#line 1289
  spin_unlock(& ctrl->mbox_lock);
#line 1290
  return (status);
}
}
#line 1293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_template_pages_req *req ;
  void *tmp___0 ;
  int status ;

  {
#line 1296
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1296
  wrb = tmp;
#line 1297
  tmp___0 = embedded_payload(wrb);
#line 1297
  req = (struct be_post_template_pages_req *)tmp___0;
#line 1300
  spin_lock(& ctrl->mbox_lock);
#line 1302
  memset((void *)wrb, 0, 256UL);
#line 1303
  be_wrb_hdr_prepare(wrb, 172, 1, 0);
#line 1304
  be_cmd_hdr_prepare(& req->hdr, 1, 24, 172);
#line 1308
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1309
  req->type = 1U;
#line 1310
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 16U, q_mem);
#line 1312
  status = be_mbox_notify(ctrl);
#line 1313
  spin_unlock(& ctrl->mbox_lock);
#line 1314
  return (status);
}
}
#line 1317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_remove_template_pages_req *req ;
  void *tmp___0 ;
  int status ;

  {
#line 1319
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1319
  wrb = tmp;
#line 1320
  tmp___0 = embedded_payload(wrb);
#line 1320
  req = (struct be_remove_template_pages_req *)tmp___0;
#line 1323
  spin_lock(& ctrl->mbox_lock);
#line 1325
  memset((void *)wrb, 0, 256UL);
#line 1326
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1327
  be_cmd_hdr_prepare(& req->hdr, 1, 25, 20);
#line 1331
  req->type = 1U;
#line 1333
  status = be_mbox_notify(ctrl);
#line 1334
  spin_unlock(& ctrl->mbox_lock);
#line 1335
  return (status);
}
}
#line 1338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ,
                                u32 page_offset___0 , u32 num_pages ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_sgl_pages_req *req ;
  void *tmp___0 ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  int status ;
  unsigned int curr_pages ;
  u32 internal_page_offset ;
  u32 temp_num_pages ;
  u32 _min1 ;
  unsigned int _min2 ;
  uint32_t log_value ;

  {
#line 1342
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1342
  wrb = tmp;
#line 1343
  tmp___0 = embedded_payload(wrb);
#line 1343
  req = (struct be_post_sgl_pages_req *)tmp___0;
#line 1344
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1344
  phba = (struct beiscsi_hba *)tmp___1;
#line 1347
  internal_page_offset = 0U;
#line 1348
  temp_num_pages = num_pages;
#line 1350
  if (num_pages == 255U) {
#line 1351
    num_pages = 1U;
  } else {

  }
#line 1353
  spin_lock(& ctrl->mbox_lock);
  ldv_54585: 
#line 1355
  memset((void *)wrb, 0, 256UL);
#line 1356
  be_wrb_hdr_prepare(wrb, 236, 1, 0);
#line 1357
  be_cmd_hdr_prepare(& req->hdr, 2, 2, 236);
#line 1360
  curr_pages = 26U;
#line 1362
  _min1 = num_pages;
#line 1362
  _min2 = curr_pages;
#line 1362
  req->num_pages = (u16 )(_min1 < _min2 ? _min1 : _min2);
#line 1363
  req->page_offset = (u16 )page_offset___0;
#line 1364
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), (u32 )req->num_pages,
                            q_mem);
#line 1365
  q_mem->dma = q_mem->dma + (unsigned long long )((unsigned long )req->num_pages * 4096UL);
#line 1366
  internal_page_offset = (u32 )req->num_pages + internal_page_offset;
#line 1367
  page_offset___0 = (u32 )req->num_pages + page_offset___0;
#line 1368
  num_pages = num_pages - (u32 )req->num_pages;
#line 1370
  if (temp_num_pages == 255U) {
#line 1371
    req->num_pages = (u16 )temp_num_pages;
  } else {

  }
#line 1373
  status = be_mbox_notify(ctrl);
#line 1374
  if (status != 0) {
#line 1375
    log_value = phba->attr_log_enable;
#line 1375
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
#line 1375
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW CMD to map iscsi frags failed.\n",
                 1376);
    } else {

    }
#line 1378
    goto error;
  } else {

  }
#line 1380
  if (num_pages != 0U) {
#line 1382
    goto ldv_54585;
  } else {

  }

  error: 
#line 1382
  spin_unlock(& ctrl->mbox_lock);
#line 1383
  if (status != 0) {
#line 1384
    beiscsi_cmd_q_destroy(ctrl, (struct be_queue_info *)0, 6);
  } else {

  }
#line 1385
  return (status);
}
}
#line 1388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_reset_function(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_sgl_pages_req *req ;
  void *tmp___0 ;
  int status ;
  void *tmp___1 ;

  {
#line 1390
  ctrl = & phba->ctrl;
#line 1391
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1391
  wrb = tmp;
#line 1392
  tmp___0 = embedded_payload(wrb);
#line 1392
  req = (struct be_post_sgl_pages_req *)tmp___0;
#line 1395
  spin_lock(& ctrl->mbox_lock);
#line 1397
  tmp___1 = embedded_payload(wrb);
#line 1397
  req = (struct be_post_sgl_pages_req *)tmp___1;
#line 1398
  be_wrb_hdr_prepare(wrb, 236, 1, 0);
#line 1399
  be_cmd_hdr_prepare(& req->hdr, 1, 61, 236);
#line 1401
  status = be_mbox_notify_wait(phba);
#line 1403
  spin_unlock(& ctrl->mbox_lock);
#line 1404
  return (status);
}
}
#line 1417 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_set_vlan_req *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
#line 1420
  tag = 0U;
#line 1423
  ctrl = & phba->ctrl;
#line 1425
  spin_lock(& ctrl->mbox_lock);
#line 1426
  tag = alloc_mcc_tag(phba);
#line 1427
  if (tag == 0U) {
#line 1428
    spin_unlock(& ctrl->mbox_lock);
#line 1429
    return ((int )tag);
  } else {

  }
#line 1432
  wrb = wrb_from_mccq(phba);
#line 1433
  tmp = embedded_payload(wrb);
#line 1433
  req = (struct be_cmd_set_vlan_req *)tmp;
#line 1434
  wrb->tag0 = wrb->tag0 | tag;
#line 1435
  be_wrb_hdr_prepare(wrb, 256, 1, 0);
#line 1436
  be_cmd_hdr_prepare(& req->hdr, 2, 14, 24);
#line 1440
  req->interface_hndl = phba->interface_handle;
#line 1441
  req->vlan_priority = (u32 )vlan_tag;
#line 1443
  be_mcc_notify(phba);
#line 1444
  spin_unlock(& ctrl->mbox_lock);
#line 1446
  return ((int )tag);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.o.c.prepared"
bool ldv_queue_work_on_69(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 180
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 180
  ldv_func_res = tmp;
#line 182
  activate_work_6(ldv_func_arg3, 2);
#line 184
  return (ldv_func_res);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.o.c.prepared"
bool ldv_queue_delayed_work_on_70(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 191
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 191
  ldv_func_res = tmp;
#line 193
  activate_work_6(& ldv_func_arg3->work, 2);
#line 195
  return (ldv_func_res);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.o.c.prepared"
bool ldv_queue_work_on_71(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 202
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 202
  ldv_func_res = tmp;
#line 204
  activate_work_6(ldv_func_arg3, 2);
#line 206
  return (ldv_func_res);
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.o.c.prepared"
void ldv_flush_workqueue_72(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 212
  flush_workqueue(ldv_func_arg1);
#line 214
  call_and_disable_all_6(2);
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/be2iscsi/be_cmds.o.c.prepared"
bool ldv_queue_delayed_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 221
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 221
  ldv_func_res = tmp;
#line 223
  activate_work_6(& ldv_func_arg3->work, 2);
#line 225
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6130/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
