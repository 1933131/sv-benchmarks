extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 489 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_29 {
   unsigned long seg ;
};
#line 489 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_29 mm_segment_t;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct timespec;
#line 157
struct compat_timespec;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 158
struct pollfd;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_47 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_46 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_sliced_vbi_format;
#line 151
struct v4l2_audio;
#line 152
struct videobuf_buffer;
#line 156
struct v4l2_subdev;
#line 160
struct v4l2_buffer;
#line 164
struct videobuf_queue;
#line 170
struct cx2341x_handler;
#line 176
struct v4l2_event_subscription;
#line 202
struct v4l2_encoder_cmd;
#line 224
struct v4l2_fh;
#line 227
struct v4l2_format;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_220 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_219 {
   struct __anonstruct____missing_field_name_220 __annonCompField58 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_219 __annonCompField59 ;
};
#line 50 "include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_222 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion____missing_field_name_221 {
   struct __anonstruct____missing_field_name_222 __annonCompField60 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_221 __annonCompField61 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_223 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_223 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_227 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField62 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_226 __annonCompField63 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct bdi_writeback;
#line 61
struct export_operations;
#line 63
struct iovec;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 69
struct vm_fault;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_231 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_231 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_232 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_232 __annonCompField65 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526
struct writeback_control;
#line 527 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_235 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_236 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_237 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_235 __annonCompField66 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_236 __annonCompField67 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_237 __annonCompField68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_238 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_238 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_240 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_239 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_240 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_239 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 261 "include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_244 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_244 __annonCompField69 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 679 "include/linux/interrupt.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_adapter;
#line 41
struct i2c_client;
#line 44
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 196 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client * , enum i2c_slave_event  , u8 * ) ;
};
#line 251
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
} ;
#line 359 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
   int (*reg_slave)(struct i2c_client * ) ;
   int (*unreg_slave)(struct i2c_client * ) ;
};
#line 411 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_adapter * ) ;
   void (*unprepare_recovery)(struct i2c_adapter * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 451 "include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 481 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks  const  *quirks ;
};
#line 640 "include/linux/i2c.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
#line 678 "include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 163 "include/linux/poll.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 32 "include/linux/cdev.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 558 "./include/uapi/linux/v4l2-common.h"
enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9
} ;
#line 571
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 594
enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4
} ;
#line 643
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 651 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 370 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 375 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 396 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
   __u32 xfer_func ;
};
#line 450 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 640 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 653 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 662 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_255 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 662 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_255 __annonCompField77 ;
   __u32 reserved[2U] ;
};
#line 681 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 690 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_256 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 690 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_256 __annonCompField78 ;
   __u32 reserved[2U] ;
};
#line 705 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 719 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 748 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
union __anonunion_m_257 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_257 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 805 "include/uapi/linux/videodev2.h"
union __anonunion_m_258 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 805 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_258 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 858 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_259 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_259 fmt ;
};
#line 940 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 962 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 972 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 997 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 1007 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 1012 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1039 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1175 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_260 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_260 __annonCompField79 ;
};
#line 1299 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_261 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_261 __annonCompField80 ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1381 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1429 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1447 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_262 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1447 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_262 __annonCompField81 ;
};
#line 1462 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1470
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U8 = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258
} ;
#line 1486 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1506 "include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1523 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_263 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1523 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_263 __annonCompField82 ;
   __u32 reserved ;
};
#line 1534 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1573 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1583 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1622 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1637 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1658 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1680 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1695 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1714 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_265 {
   __u32 data[8U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_264 {
   struct __anonstruct_raw_265 raw ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_264 __annonCompField83 ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_267 {
   __u64 pts ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_268 {
   __s32 speed ;
   __u32 format ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_269 {
   __u32 data[16U] ;
};
#line 1741 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_266 {
   struct __anonstruct_stop_267 stop ;
   struct __anonstruct_start_268 start ;
   struct __anonstruct_raw_269 raw ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_266 __annonCompField84 ;
};
#line 1790 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1810 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1838 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1917 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u32 bytesperline ;
   __u16 reserved[6U] ;
};
#line 1934 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 xfer_func ;
   __u8 reserved[7U] ;
};
#line 1964 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_271 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_271 fmt ;
};
#line 1998 "include/uapi/linux/videodev2.h"
union __anonunion_parm_272 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_272 parm ;
};
#line 2089 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_275 {
   __u32 addr ;
   char name[32U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_275 __annonCompField87 ;
};
#line 2125 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2132 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2143 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 169 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 172
struct media_pad;
#line 172 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 62
struct media_device;
#line 62 "include/media/media-entity.h"
struct __anonstruct_dev_282 {
   u32 major ;
   u32 minor ;
};
#line 62 "include/media/media-entity.h"
union __anonunion_info_281 {
   struct __anonstruct_dev_282 dev ;
};
#line 62 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_281 info ;
};
#line 155
struct video_device;
#line 156
struct v4l2_device;
#line 157
struct v4l2_ctrl_handler;
#line 158 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 78
struct vb2_queue;
#line 78
struct v4l2_ioctl_ops;
#line 78 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 86 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 147 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191 "include/media/v4l2-common.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 334 "include/media/v4l2-ioctl.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 45 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 81 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 100 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 111 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 132 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 156
struct v4l2_async_notifier;
#line 157
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_285 {
   struct device_node  const  *node ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_286 {
   char const   *name ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_287 {
   int adapter_id ;
   unsigned short address ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_288 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_284 {
   struct __anonstruct_of_285 of ;
   struct __anonstruct_device_name_286 device_name ;
   struct __anonstruct_i2c_287 i2c ;
   struct __anonstruct_custom_288 custom ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_284 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
struct v4l2_m2m_ctx;
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 115 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 116
struct tuner_setup;
#line 117
struct v4l2_mbus_frame_desc;
#line 118 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 63 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 119 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 180 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 207 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 234 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 255 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 267 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 341 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 381 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 396
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 400 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 448 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 467 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 480 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                         struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                          struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                              struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 524 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 536 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 557
struct regulator_bulk_data;
#line 558 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 579 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct device_node *of_node ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 619 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 684 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 133 "include/media/v4l2-device.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 30 "include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 1010 "include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1020 "include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1039 "include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1049 "include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1061 "include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1082 "include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1113 "include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1126 "include/uapi/linux/input.h"
union __anonunion_u_292 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1126 "include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_292 u ;
};
#line 1165 "include/uapi/linux/input.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 532
enum rc_type {
    RC_TYPE_UNKNOWN = 0,
    RC_TYPE_OTHER = 1,
    RC_TYPE_LIRC = 2,
    RC_TYPE_RC5 = 3,
    RC_TYPE_RC5X = 4,
    RC_TYPE_RC5_SZ = 5,
    RC_TYPE_JVC = 6,
    RC_TYPE_SONY12 = 7,
    RC_TYPE_SONY15 = 8,
    RC_TYPE_SONY20 = 9,
    RC_TYPE_NEC = 10,
    RC_TYPE_SANYO = 11,
    RC_TYPE_MCE_KBD = 12,
    RC_TYPE_RC6_0 = 13,
    RC_TYPE_RC6_6A_20 = 14,
    RC_TYPE_RC6_6A_24 = 15,
    RC_TYPE_RC6_6A_32 = 16,
    RC_TYPE_RC6_MCE = 17,
    RC_TYPE_SHARP = 18,
    RC_TYPE_XMP = 19
} ;
#line 555 "include/linux/input.h"
struct rc_map_table {
   u32 scancode ;
   u32 keycode ;
};
#line 83 "include/media/rc-map.h"
struct rc_map {
   struct rc_map_table *scan ;
   unsigned int size ;
   unsigned int len ;
   unsigned int alloc ;
   enum rc_type rc_type ;
   char const   *name ;
   spinlock_t lock ;
};
#line 26 "include/media/rc-core.h"
enum rc_driver_type {
    RC_DRIVER_SCANCODE = 0,
    RC_DRIVER_IR_RAW = 1
} ;
#line 31 "include/media/rc-core.h"
struct rc_scancode_filter {
   u32 data ;
   u32 mask ;
};
#line 52
struct ir_raw_event_ctrl;
#line 52 "include/media/rc-core.h"
struct rc_dev {
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[5U] ;
   char const   *input_name ;
   char const   *input_phys ;
   struct input_id input_id ;
   char *driver_name ;
   char const   *map_name ;
   struct rc_map rc_map ;
   struct mutex lock ;
   unsigned long devno ;
   struct ir_raw_event_ctrl *raw ;
   struct input_dev *input_dev ;
   enum rc_driver_type driver_type ;
   bool idle ;
   bool encode_wakeup ;
   u64 allowed_protocols ;
   u64 enabled_protocols ;
   u64 allowed_wakeup_protocols ;
   u64 enabled_wakeup_protocols ;
   struct rc_scancode_filter scancode_filter ;
   struct rc_scancode_filter scancode_wakeup_filter ;
   u32 scancode_mask ;
   u32 users ;
   void *priv ;
   spinlock_t keylock ;
   bool keypressed ;
   unsigned long keyup_jiffies ;
   struct timer_list timer_keyup ;
   u32 last_keycode ;
   enum rc_type last_protocol ;
   u32 last_scancode ;
   u8 last_toggle ;
   u32 timeout ;
   u32 min_timeout ;
   u32 max_timeout ;
   u32 rx_resolution ;
   u32 tx_resolution ;
   int (*change_protocol)(struct rc_dev * , u64 * ) ;
   int (*change_wakeup_protocol)(struct rc_dev * , u64 * ) ;
   int (*open)(struct rc_dev * ) ;
   void (*close)(struct rc_dev * ) ;
   int (*s_tx_mask)(struct rc_dev * , u32  ) ;
   int (*s_tx_carrier)(struct rc_dev * , u32  ) ;
   int (*s_tx_duty_cycle)(struct rc_dev * , u32  ) ;
   int (*s_rx_carrier_range)(struct rc_dev * , u32  , u32  ) ;
   int (*tx_ir)(struct rc_dev * , unsigned int * , unsigned int  ) ;
   void (*s_idle)(struct rc_dev * , bool  ) ;
   int (*s_learning_mode)(struct rc_dev * , int  ) ;
   int (*s_carrier_report)(struct rc_dev * , int  ) ;
   int (*s_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
   int (*s_wakeup_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
};
#line 286
struct IR_i2c;
#line 287 "include/media/rc-core.h"
struct IR_i2c {
   char *ir_codes ;
   struct i2c_client *c ;
   struct rc_dev *rc ;
   unsigned char old ;
   u32 polling_interval ;
   struct delayed_work work ;
   char name[32U] ;
   char phys[32U] ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
};
#line 25 "include/media/ir-kbd-i2c.h"
enum ir_kbd_get_key_fn {
    IR_KBD_GET_KEY_CUSTOM = 0,
    IR_KBD_GET_KEY_PIXELVIEW = 1,
    IR_KBD_GET_KEY_HAUP = 2,
    IR_KBD_GET_KEY_KNC1 = 3,
    IR_KBD_GET_KEY_FUSIONHDTV = 4,
    IR_KBD_GET_KEY_HAUP_XVR = 5,
    IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 6
} ;
#line 35 "include/media/ir-kbd-i2c.h"
struct IR_i2c_init_data {
   char *ir_codes ;
   char const   *name ;
   u64 type ;
   u32 polling_interval ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
   enum ir_kbd_get_key_fn internal_get_key_func ;
   struct rc_dev *rc_dev ;
};
#line 54
struct cx18;
#line 55 "include/media/ir-kbd-i2c.h"
struct cx18_mdl_ack {
   u32 id ;
   u32 data_used ;
};
#line 51 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
struct cx18_mailbox {
   u32 request ;
   u32 ack ;
   u32 reserved[6U] ;
   u32 cmd ;
   u32 args[6U] ;
   u32 error ;
};
#line 81
struct cx18_stream;
#line 94
struct v4l2_ctrl_helper;
#line 95
struct v4l2_ctrl;
#line 97 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
union v4l2_ctrl_ptr {
   s32 *p_s32 ;
   s64 *p_s64 ;
   u8 *p_u8 ;
   u16 *p_u16 ;
   u32 *p_u32 ;
   char *p_char ;
   void *p ;
};
#line 57 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 75 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_type_ops {
   bool (*equal)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  , union v4l2_ctrl_ptr  ) ;
   void (*init)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
   void (*log)(struct v4l2_ctrl  const  * ) ;
   int (*validate)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_295 {
   u64 step ;
   u64 menu_skip_mask ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_296 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct __anonstruct_cur_297 {
   s32 val ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char has_changed : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char is_int : 1 ;
   unsigned char is_string : 1 ;
   unsigned char is_ptr : 1 ;
   unsigned char is_array : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 minimum ;
   s64 maximum ;
   s64 default_value ;
   u32 elems ;
   u32 elem_size ;
   u32 dims[4U] ;
   u32 nr_of_dims ;
   union __anonunion____missing_field_name_295 __annonCompField94 ;
   union __anonunion____missing_field_name_296 __annonCompField95 ;
   unsigned long flags ;
   void *priv ;
   s32 val ;
   struct __anonstruct_cur_297 cur ;
   union v4l2_ctrl_ptr p_new ;
   union v4l2_ctrl_ptr p_cur ;
};
#line 212 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 229 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 837
enum cx18_av_video_input {
    CX18_AV_COMPOSITE1 = 1,
    CX18_AV_COMPOSITE2 = 2,
    CX18_AV_COMPOSITE3 = 3,
    CX18_AV_COMPOSITE4 = 4,
    CX18_AV_COMPOSITE5 = 5,
    CX18_AV_COMPOSITE6 = 6,
    CX18_AV_COMPOSITE7 = 7,
    CX18_AV_COMPOSITE8 = 8,
    CX18_AV_SVIDEO_LUMA1 = 16,
    CX18_AV_SVIDEO_LUMA2 = 32,
    CX18_AV_SVIDEO_LUMA3 = 48,
    CX18_AV_SVIDEO_LUMA4 = 64,
    CX18_AV_SVIDEO_LUMA5 = 80,
    CX18_AV_SVIDEO_LUMA6 = 96,
    CX18_AV_SVIDEO_LUMA7 = 112,
    CX18_AV_SVIDEO_LUMA8 = 128,
    CX18_AV_SVIDEO_CHROMA4 = 1024,
    CX18_AV_SVIDEO_CHROMA5 = 1280,
    CX18_AV_SVIDEO_CHROMA6 = 1536,
    CX18_AV_SVIDEO_CHROMA7 = 1792,
    CX18_AV_SVIDEO_CHROMA8 = 2048,
    CX18_AV_SVIDEO1 = 1296,
    CX18_AV_SVIDEO2 = 1568,
    CX18_AV_SVIDEO3 = 1840,
    CX18_AV_SVIDEO4 = 2112,
    CX18_AV_COMPONENT_LUMA1 = 4096,
    CX18_AV_COMPONENT_LUMA2 = 8192,
    CX18_AV_COMPONENT_LUMA3 = 12288,
    CX18_AV_COMPONENT_LUMA4 = 16384,
    CX18_AV_COMPONENT_LUMA5 = 20480,
    CX18_AV_COMPONENT_LUMA6 = 24576,
    CX18_AV_COMPONENT_LUMA7 = 28672,
    CX18_AV_COMPONENT_LUMA8 = 32768,
    CX18_AV_COMPONENT_R_CHROMA4 = 262144,
    CX18_AV_COMPONENT_R_CHROMA5 = 327680,
    CX18_AV_COMPONENT_R_CHROMA6 = 393216,
    CX18_AV_COMPONENT_B_CHROMA7 = 7340032,
    CX18_AV_COMPONENT_B_CHROMA8 = 8388608,
    CX18_AV_COMPONENT1 = 8785920
} ;
#line 879
enum cx18_av_audio_input {
    CX18_AV_AUDIO_SERIAL1 = 0,
    CX18_AV_AUDIO_SERIAL2 = 1,
    CX18_AV_AUDIO4 = 4,
    CX18_AV_AUDIO5 = 5,
    CX18_AV_AUDIO6 = 6,
    CX18_AV_AUDIO7 = 7,
    CX18_AV_AUDIO8 = 8
} ;
#line 889 "include/media/v4l2-ctrls.h"
struct cx18_av_state {
   struct v4l2_subdev sd ;
   struct v4l2_ctrl_handler hdl ;
   struct v4l2_ctrl *volume ;
   int radio ;
   v4l2_std_id std ;
   enum cx18_av_video_input vid_input ;
   enum cx18_av_audio_input aud_input ;
   u32 audclk_freq ;
   int audmode ;
   u32 rev ;
   int is_initialized ;
   int slicer_line_delay ;
   int slicer_line_offset ;
};
#line 389 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-av-core.h"
enum cx2341x_port {
    CX2341X_PORT_MEMORY = 0,
    CX2341X_PORT_STREAMING = 1,
    CX2341X_PORT_SERIAL = 2
} ;
#line 103 "include/media/cx2341x.h"
struct cx2341x_handler_ops {
   int (*s_audio_sampling_freq)(struct cx2341x_handler * , u32  ) ;
   int (*s_audio_mode)(struct cx2341x_handler * , u32  ) ;
   int (*s_video_encoding)(struct cx2341x_handler * , u32  ) ;
   int (*s_stream_vbi_fmt)(struct cx2341x_handler * , u32  ) ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_298 {
   struct v4l2_ctrl *audio_sampling_freq ;
   struct v4l2_ctrl *audio_encoding ;
   struct v4l2_ctrl *audio_l2_bitrate ;
   struct v4l2_ctrl *audio_mode ;
   struct v4l2_ctrl *audio_mode_extension ;
   struct v4l2_ctrl *audio_emphasis ;
   struct v4l2_ctrl *audio_crc ;
   struct v4l2_ctrl *audio_ac3_bitrate ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_299 {
   struct v4l2_ctrl *video_b_frames ;
   struct v4l2_ctrl *video_gop_size ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_300 {
   struct v4l2_ctrl *stream_type ;
   struct v4l2_ctrl *video_encoding ;
   struct v4l2_ctrl *video_bitrate_mode ;
   struct v4l2_ctrl *video_bitrate ;
   struct v4l2_ctrl *video_bitrate_peak ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_301 {
   struct v4l2_ctrl *video_mute ;
   struct v4l2_ctrl *video_mute_yuv ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_302 {
   struct v4l2_ctrl *video_spatial_filter_mode ;
   struct v4l2_ctrl *video_temporal_filter_mode ;
   struct v4l2_ctrl *video_median_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_303 {
   struct v4l2_ctrl *video_luma_spatial_filter_type ;
   struct v4l2_ctrl *video_chroma_spatial_filter_type ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_304 {
   struct v4l2_ctrl *video_spatial_filter ;
   struct v4l2_ctrl *video_temporal_filter ;
};
#line 116 "include/media/cx2341x.h"
struct __anonstruct____missing_field_name_305 {
   struct v4l2_ctrl *video_luma_median_filter_top ;
   struct v4l2_ctrl *video_luma_median_filter_bottom ;
   struct v4l2_ctrl *video_chroma_median_filter_top ;
   struct v4l2_ctrl *video_chroma_median_filter_bottom ;
};
#line 116 "include/media/cx2341x.h"
struct cx2341x_handler {
   u32 capabilities ;
   enum cx2341x_port port ;
   u16 width ;
   u16 height ;
   u16 is_50hz ;
   u32 audio_properties ;
   struct v4l2_ctrl_handler hdl ;
   void *priv ;
   int (*func)(void * , u32  , int  , int  , u32 * ) ;
   struct cx2341x_handler_ops  const  *ops ;
   struct v4l2_ctrl *stream_vbi_fmt ;
   struct __anonstruct____missing_field_name_298 __annonCompField96 ;
   struct __anonstruct____missing_field_name_299 __annonCompField97 ;
   struct __anonstruct____missing_field_name_300 __annonCompField98 ;
   struct __anonstruct____missing_field_name_301 __annonCompField99 ;
   struct __anonstruct____missing_field_name_302 __annonCompField100 ;
   struct __anonstruct____missing_field_name_303 __annonCompField101 ;
   struct __anonstruct____missing_field_name_304 __annonCompField102 ;
   struct __anonstruct____missing_field_name_305 __annonCompField103 ;
};
#line 198
enum dmx_output {
    DMX_OUT_DECODER = 0,
    DMX_OUT_TAP = 1,
    DMX_OUT_TS_TAP = 2,
    DMX_OUT_TSDEMUX_TAP = 3
} ;
#line 46 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_output dmx_output_t;
#line 47
enum dmx_input {
    DMX_IN_FRONTEND = 0,
    DMX_IN_DVR = 1
} ;
#line 52 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_input dmx_input_t;
#line 53
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 82 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 83 "./include/uapi/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16U] ;
   __u8 mask[16U] ;
   __u8 mode[16U] ;
};
#line 96 "./include/uapi/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 97 "./include/uapi/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 106 "./include/uapi/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 120 "./include/uapi/linux/dvb/dmx.h"
struct dmx_caps {
   __u32 caps ;
   int num_decoders ;
};
#line 125
enum dmx_source {
    DMX_SOURCE_FRONT0 = 0,
    DMX_SOURCE_FRONT1 = 1,
    DMX_SOURCE_FRONT2 = 2,
    DMX_SOURCE_FRONT3 = 3,
    DMX_SOURCE_DVR0 = 16,
    DMX_SOURCE_DVR1 = 17,
    DMX_SOURCE_DVR2 = 18,
    DMX_SOURCE_DVR3 = 19
} ;
#line 135 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_source dmx_source_t;
#line 142
enum dmx_success {
    DMX_OK = 0,
    DMX_LENGTH_ERROR = 1,
    DMX_OVERRUN_ERROR = 2,
    DMX_CRC_ERROR = 3,
    DMX_FRAME_ERROR = 4,
    DMX_FIFO_ERROR = 5,
    DMX_MISSED_ERROR = 6
} ;
#line 152
struct dmx_demux;
#line 152 "./include/uapi/linux/dvb/dmx.h"
struct dmx_ts_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int (*set)(struct dmx_ts_feed * , u16  , int  , enum dmx_ts_pes  , size_t  , struct timespec  ) ;
   int (*start_filtering)(struct dmx_ts_feed * ) ;
   int (*stop_filtering)(struct dmx_ts_feed * ) ;
};
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed;
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_filter {
   u8 filter_value[18U] ;
   u8 filter_mask[18U] ;
   u8 filter_mode[18U] ;
   struct dmx_section_feed *parent ;
   void *priv ;
};
#line 111 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int check_crc ;
   u32 crc_val ;
   u8 *secbuf ;
   u8 secbuf_base[4284U] ;
   u16 secbufp ;
   u16 seclen ;
   u16 tsfeedp ;
   int (*set)(struct dmx_section_feed * , u16  , size_t  , int  ) ;
   int (*allocate_filter)(struct dmx_section_feed * , struct dmx_section_filter ** ) ;
   int (*release_filter)(struct dmx_section_feed * , struct dmx_section_filter * ) ;
   int (*start_filtering)(struct dmx_section_feed * ) ;
   int (*stop_filtering)(struct dmx_section_feed * ) ;
};
#line 148
enum dmx_frontend_source {
    DMX_MEMORY_FE = 0,
    DMX_FRONTEND_0 = 1,
    DMX_FRONTEND_1 = 2,
    DMX_FRONTEND_2 = 3,
    DMX_FRONTEND_3 = 4,
    DMX_STREAM_0 = 5,
    DMX_STREAM_1 = 6,
    DMX_STREAM_2 = 7,
    DMX_STREAM_3 = 8
} ;
#line 160 "drivers/media/dvb-core/demux.h"
struct dmx_frontend {
   struct list_head connectivity_list ;
   enum dmx_frontend_source source ;
};
#line 176 "drivers/media/dvb-core/demux.h"
struct dmx_demux {
   u32 capabilities ;
   struct dmx_frontend *frontend ;
   void *priv ;
   int (*open)(struct dmx_demux * ) ;
   int (*close)(struct dmx_demux * ) ;
   int (*write)(struct dmx_demux * , char const   * , size_t  ) ;
   int (*allocate_ts_feed)(struct dmx_demux * , struct dmx_ts_feed ** , int (*)(u8 const   * ,
                                                                                size_t  ,
                                                                                u8 const   * ,
                                                                                size_t  ,
                                                                                struct dmx_ts_feed * ,
                                                                                enum dmx_success  ) ) ;
   int (*release_ts_feed)(struct dmx_demux * , struct dmx_ts_feed * ) ;
   int (*allocate_section_feed)(struct dmx_demux * , struct dmx_section_feed ** ,
                                int (*)(u8 const   * , size_t  , u8 const   * , size_t  ,
                                        struct dmx_section_filter * , enum dmx_success  ) ) ;
   int (*release_section_feed)(struct dmx_demux * , struct dmx_section_feed * ) ;
   int (*add_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*remove_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   struct list_head *(*get_frontends)(struct dmx_demux * ) ;
   int (*connect_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*disconnect_frontend)(struct dmx_demux * ) ;
   int (*get_pes_pids)(struct dmx_demux * , u16 * ) ;
   int (*get_caps)(struct dmx_demux * , struct dmx_caps * ) ;
   int (*set_source)(struct dmx_demux * , dmx_source_t const   * ) ;
   int (*get_stc)(struct dmx_demux * , unsigned int  , u64 * , unsigned int * ) ;
};
#line 239
struct dvb_frontend;
#line 240
struct dvb_device;
#line 240 "drivers/media/dvb-core/demux.h"
struct dvb_adapter {
   int num ;
   struct list_head list_head ;
   struct list_head device_list ;
   char const   *name ;
   u8 proposed_mac[6U] ;
   void *priv ;
   struct device *device ;
   struct module *module ;
   int mfe_shared ;
   struct dvb_device *mfe_dvbdev ;
   struct mutex mfe_lock ;
};
#line 76 "drivers/media/dvb-core/dvbdev.h"
struct dvb_device {
   struct list_head list_head ;
   struct file_operations  const  *fops ;
   struct dvb_adapter *adapter ;
   int type ;
   int minor ;
   u32 id ;
   int readers ;
   int writers ;
   int users ;
   wait_queue_head_t wait_queue ;
   int (*kernel_ioctl)(struct file * , unsigned int  , void * ) ;
   void *priv ;
};
#line 149 "drivers/media/dvb-core/dvbdev.h"
struct dvb_ringbuffer {
   u8 *data ;
   ssize_t size ;
   ssize_t pread ;
   ssize_t pwrite ;
   int error ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
};
#line 186 "drivers/media/dvb-core/dvb_ringbuffer.h"
enum dmxdev_type {
    DMXDEV_TYPE_NONE = 0,
    DMXDEV_TYPE_SEC = 1,
    DMXDEV_TYPE_PES = 2
} ;
#line 192
enum dmxdev_state {
    DMXDEV_STATE_FREE = 0,
    DMXDEV_STATE_ALLOCATED = 1,
    DMXDEV_STATE_SET = 2,
    DMXDEV_STATE_GO = 3,
    DMXDEV_STATE_DONE = 4,
    DMXDEV_STATE_TIMEDOUT = 5
} ;
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_filter_306 {
   struct dmx_section_filter *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_feed_307 {
   struct list_head ts ;
   struct dmx_section_feed *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_params_308 {
   struct dmx_sct_filter_params sec ;
   struct dmx_pes_filter_params pes ;
};
#line 63
struct dmxdev;
#line 63 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev_filter {
   union __anonunion_filter_306 filter ;
   union __anonunion_feed_307 feed ;
   union __anonunion_params_308 params ;
   enum dmxdev_type type ;
   enum dmxdev_state state ;
   struct dmxdev *dev ;
   struct dvb_ringbuffer buffer ;
   struct mutex mutex ;
   struct timer_list timer ;
   int todo ;
   u8 secheader[3U] ;
};
#line 92 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev {
   struct dvb_device *dvbdev ;
   struct dvb_device *dvr_dvbdev ;
   struct dmxdev_filter *filter ;
   struct dmx_demux *demux ;
   int filternum ;
   int capabilities ;
   unsigned char exit : 1 ;
   struct dmx_frontend *dvr_orig_fe ;
   struct dvb_ringbuffer dvr_buffer ;
   struct mutex mutex ;
   spinlock_t lock ;
};
#line 118
struct dvb_demux_feed;
#line 118 "drivers/media/dvb-core/dmxdev.h"
struct dvb_demux_filter {
   struct dmx_section_filter filter ;
   u8 maskandmode[18U] ;
   u8 maskandnotmode[18U] ;
   int doneq ;
   struct dvb_demux_filter *next ;
   struct dvb_demux_feed *feed ;
   int index ;
   int state ;
   int type ;
   u16 hw_handle ;
   struct timer_list timer ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_feed_309 {
   struct dmx_ts_feed ts ;
   struct dmx_section_feed sec ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_cb_310 {
   int (*ts)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_ts_feed * ,
             enum dmx_success  ) ;
   int (*sec)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_section_filter * ,
              enum dmx_success  ) ;
};
#line 64
struct dvb_demux;
#line 64 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux_feed {
   union __anonunion_feed_309 feed ;
   union __anonunion_cb_310 cb ;
   struct dvb_demux *demux ;
   void *priv ;
   int type ;
   int state ;
   u16 pid ;
   u8 *buffer ;
   int buffer_size ;
   struct timespec timeout ;
   struct dvb_demux_filter *filter ;
   int ts_type ;
   enum dmx_ts_pes pes_type ;
   int cc ;
   int pusi_seen ;
   u16 peslen ;
   struct list_head list_head ;
   unsigned int index ;
};
#line 100 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux {
   struct dmx_demux dmx ;
   void *priv ;
   int filternum ;
   int feednum ;
   int (*start_feed)(struct dvb_demux_feed * ) ;
   int (*stop_feed)(struct dvb_demux_feed * ) ;
   int (*write_to_decoder)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   u32 (*check_crc32)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   void (*memcopy)(struct dvb_demux_feed * , u8 * , u8 const   * , size_t  ) ;
   int users ;
   struct dvb_demux_filter *filter ;
   struct dvb_demux_feed *feed ;
   struct list_head frontend_list ;
   struct dvb_demux_feed *pesfilter[20U] ;
   u16 pids[20U] ;
   int playing ;
   int recording ;
   struct list_head feed_list ;
   u8 tsbuf[204U] ;
   int tsbufp ;
   struct mutex mutex ;
   spinlock_t lock ;
   uint8_t *cnt_storage ;
   struct timespec speed_last_time ;
   uint32_t speed_pkts_cnt ;
};
#line 149
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 156
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 190 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_frontend_info {
   char name[128U] ;
   enum fe_type type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   enum fe_caps caps ;
};
#line 85 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6U] ;
   __u8 msg_len ;
};
#line 95 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_slave_reply {
   __u8 msg[4U] ;
   __u8 msg_len ;
   int timeout ;
};
#line 101
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 107
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 112
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 117
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 127
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 133
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 149
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 166
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 178
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 192
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 200
enum fe_interleaving {
    INTERLEAVING_NONE = 0,
    INTERLEAVING_AUTO = 1,
    INTERLEAVING_240 = 2,
    INTERLEAVING_720 = 3
} ;
#line 207
enum fe_pilot {
    PILOT_ON = 0,
    PILOT_OFF = 1,
    PILOT_AUTO = 2
} ;
#line 213
enum fe_rolloff {
    ROLLOFF_35 = 0,
    ROLLOFF_20 = 1,
    ROLLOFF_25 = 2,
    ROLLOFF_AUTO = 3
} ;
#line 220
enum fe_delivery_system {
    SYS_UNDEFINED = 0,
    SYS_DVBC_ANNEX_A = 1,
    SYS_DVBC_ANNEX_B = 2,
    SYS_DVBT = 3,
    SYS_DSS = 4,
    SYS_DVBS = 5,
    SYS_DVBS2 = 6,
    SYS_DVBH = 7,
    SYS_ISDBT = 8,
    SYS_ISDBS = 9,
    SYS_ISDBC = 10,
    SYS_ATSC = 11,
    SYS_ATSCMH = 12,
    SYS_DTMB = 13,
    SYS_CMMB = 14,
    SYS_DAB = 15,
    SYS_DVBT2 = 16,
    SYS_TURBO = 17,
    SYS_DVBC_ANNEX_C = 18
} ;
#line 403 "./include/uapi/linux/dvb/frontend.h"
union __anonunion____missing_field_name_311 {
   __u64 uvalue ;
   __s64 svalue ;
};
#line 403 "./include/uapi/linux/dvb/frontend.h"
struct dtv_stats {
   __u8 scale ;
   union __anonunion____missing_field_name_311 __annonCompField104 ;
};
#line 454 "./include/uapi/linux/dvb/frontend.h"
struct dtv_fe_stats {
   __u8 len ;
   struct dtv_stats stat[4U] ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct __anonstruct_buffer_313 {
   __u8 data[32U] ;
   __u32 len ;
   __u32 reserved1[3U] ;
   void *reserved2 ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_u_312 {
   __u32 data ;
   struct dtv_fe_stats st ;
   struct __anonstruct_buffer_313 buffer ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct dtv_property {
   __u32 cmd ;
   __u32 reserved[3U] ;
   union __anonunion_u_312 u ;
   int result ;
};
#line 486 "./include/uapi/linux/dvb/frontend.h"
struct dvb_frontend_tune_settings {
   int min_delay_ms ;
   int step_size ;
   int max_drift ;
};
#line 56 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_info {
   char name[128U] ;
   u32 frequency_min ;
   u32 frequency_max ;
   u32 frequency_step ;
   u32 bandwidth_min ;
   u32 bandwidth_max ;
   u32 bandwidth_step ;
};
#line 70 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_parameters {
   unsigned int frequency ;
   unsigned int mode ;
   unsigned int audmode ;
   u64 std ;
};
#line 113
enum tuner_param {
    DVBFE_TUNER_FREQUENCY = 1,
    DVBFE_TUNER_TUNERSTEP = 2,
    DVBFE_TUNER_IFFREQ = 4,
    DVBFE_TUNER_BANDWIDTH = 8,
    DVBFE_TUNER_REFCLOCK = 16,
    DVBFE_TUNER_IQSENSE = 32,
    DVBFE_TUNER_DUMMY = (-0x7FFFFFFF-1)
} ;
#line 123
enum dvbfe_algo {
    DVBFE_ALGO_HW = 1,
    DVBFE_ALGO_SW = 2,
    DVBFE_ALGO_CUSTOM = 4,
    DVBFE_ALGO_RECOVERY = (-0x7FFFFFFF-1)
} ;
#line 130 "drivers/media/dvb-core/dvb_frontend.h"
struct tuner_state {
   u32 frequency ;
   u32 tunerstep ;
   u32 ifreq ;
   u32 bandwidth ;
   u32 iqsense ;
   u32 refclock ;
};
#line 164
enum dvbfe_search {
    DVBFE_ALGO_SEARCH_SUCCESS = 1,
    DVBFE_ALGO_SEARCH_ASLEEP = 2,
    DVBFE_ALGO_SEARCH_FAILED = 4,
    DVBFE_ALGO_SEARCH_INVALID = 8,
    DVBFE_ALGO_SEARCH_AGAIN = 16,
    DVBFE_ALGO_SEARCH_ERROR = (-0x7FFFFFFF-1)
} ;
#line 173 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_ops {
   struct dvb_tuner_info info ;
   int (*release)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*suspend)(struct dvb_frontend * ) ;
   int (*resume)(struct dvb_frontend * ) ;
   int (*set_params)(struct dvb_frontend * ) ;
   int (*set_analog_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*calc_regs)(struct dvb_frontend * , u8 * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
   int (*get_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_bandwidth)(struct dvb_frontend * , u32 * ) ;
   int (*get_if_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_status)(struct dvb_frontend * , u32 * ) ;
   int (*get_rf_strength)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   int (*set_frequency)(struct dvb_frontend * , u32  ) ;
   int (*set_bandwidth)(struct dvb_frontend * , u32  ) ;
   int (*set_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
   int (*get_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
};
#line 239 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_info {
   char *name ;
};
#line 243 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_ops {
   struct analog_demod_info info ;
   void (*set_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*has_signal)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   void (*tuner_status)(struct dvb_frontend * ) ;
   void (*standby)(struct dvb_frontend * ) ;
   void (*release)(struct dvb_frontend * ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
};
#line 260
struct dtv_frontend_properties;
#line 261 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend_ops {
   struct dvb_frontend_info info ;
   u8 delsys[8U] ;
   void (*release)(struct dvb_frontend * ) ;
   void (*release_sec)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*write)(struct dvb_frontend * , u8 const   * , int  ) ;
   int (*tune)(struct dvb_frontend * , bool  , unsigned int  , unsigned int * , enum fe_status * ) ;
   enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend * ) ;
   int (*set_frontend)(struct dvb_frontend * ) ;
   int (*get_tune_settings)(struct dvb_frontend * , struct dvb_frontend_tune_settings * ) ;
   int (*get_frontend)(struct dvb_frontend * ) ;
   int (*read_status)(struct dvb_frontend * , enum fe_status * ) ;
   int (*read_ber)(struct dvb_frontend * , u32 * ) ;
   int (*read_signal_strength)(struct dvb_frontend * , u16 * ) ;
   int (*read_snr)(struct dvb_frontend * , u16 * ) ;
   int (*read_ucblocks)(struct dvb_frontend * , u32 * ) ;
   int (*diseqc_reset_overload)(struct dvb_frontend * ) ;
   int (*diseqc_send_master_cmd)(struct dvb_frontend * , struct dvb_diseqc_master_cmd * ) ;
   int (*diseqc_recv_slave_reply)(struct dvb_frontend * , struct dvb_diseqc_slave_reply * ) ;
   int (*diseqc_send_burst)(struct dvb_frontend * , enum fe_sec_mini_cmd  ) ;
   int (*set_tone)(struct dvb_frontend * , enum fe_sec_tone_mode  ) ;
   int (*set_voltage)(struct dvb_frontend * , enum fe_sec_voltage  ) ;
   int (*enable_high_lnb_voltage)(struct dvb_frontend * , long  ) ;
   int (*dishnetwork_send_legacy_command)(struct dvb_frontend * , unsigned long  ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*ts_bus_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_lna)(struct dvb_frontend * ) ;
   enum dvbfe_search (*search)(struct dvb_frontend * ) ;
   struct dvb_tuner_ops tuner_ops ;
   struct analog_demod_ops analog_ops ;
   int (*set_property)(struct dvb_frontend * , struct dtv_property * ) ;
   int (*get_property)(struct dvb_frontend * , struct dtv_property * ) ;
};
#line 323 "drivers/media/dvb-core/dvb_frontend.h"
struct __anonstruct_layer_314 {
   u8 segment_count ;
   enum fe_code_rate fec ;
   enum fe_modulation modulation ;
   u8 interleaving ;
};
#line 323 "drivers/media/dvb-core/dvb_frontend.h"
struct dtv_frontend_properties {
   u32 state ;
   u32 frequency ;
   enum fe_modulation modulation ;
   enum fe_sec_voltage voltage ;
   enum fe_sec_tone_mode sectone ;
   enum fe_spectral_inversion inversion ;
   enum fe_code_rate fec_inner ;
   enum fe_transmit_mode transmission_mode ;
   u32 bandwidth_hz ;
   enum fe_guard_interval guard_interval ;
   enum fe_hierarchy hierarchy ;
   u32 symbol_rate ;
   enum fe_code_rate code_rate_HP ;
   enum fe_code_rate code_rate_LP ;
   enum fe_pilot pilot ;
   enum fe_rolloff rolloff ;
   enum fe_delivery_system delivery_system ;
   enum fe_interleaving interleaving ;
   u8 isdbt_partial_reception ;
   u8 isdbt_sb_mode ;
   u8 isdbt_sb_subchannel ;
   u32 isdbt_sb_segment_idx ;
   u32 isdbt_sb_segment_count ;
   u8 isdbt_layer_enabled ;
   struct __anonstruct_layer_314 layer[3U] ;
   u32 stream_id ;
   u8 atscmh_fic_ver ;
   u8 atscmh_parade_id ;
   u8 atscmh_nog ;
   u8 atscmh_tnog ;
   u8 atscmh_sgn ;
   u8 atscmh_prc ;
   u8 atscmh_rs_frame_mode ;
   u8 atscmh_rs_frame_ensemble ;
   u8 atscmh_rs_code_mode_pri ;
   u8 atscmh_rs_code_mode_sec ;
   u8 atscmh_sccc_block_mode ;
   u8 atscmh_sccc_code_mode_a ;
   u8 atscmh_sccc_code_mode_b ;
   u8 atscmh_sccc_code_mode_c ;
   u8 atscmh_sccc_code_mode_d ;
   u32 lna ;
   struct dtv_fe_stats strength ;
   struct dtv_fe_stats cnr ;
   struct dtv_fe_stats pre_bit_error ;
   struct dtv_fe_stats pre_bit_count ;
   struct dtv_fe_stats post_bit_error ;
   struct dtv_fe_stats post_bit_count ;
   struct dtv_fe_stats block_error ;
   struct dtv_fe_stats block_count ;
};
#line 411 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend {
   struct dvb_frontend_ops ops ;
   struct dvb_adapter *dvb ;
   void *demodulator_priv ;
   void *tuner_priv ;
   void *frontend_priv ;
   void *sec_priv ;
   void *analog_demod_priv ;
   struct dtv_frontend_properties dtv_property_cache ;
   int (*callback)(void * , int  , int  , int  ) ;
   int id ;
   unsigned int exit ;
};
#line 56 "include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_315 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_315 __annonCompField105 ;
   unsigned long nr_segs ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_317 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_317 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_318 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_318 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_319 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_319 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_320 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_320 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_321 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_321 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_322 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_322 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_323 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_323 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_324 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_324 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_325 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_326 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_325 ifr_ifrn ;
   union __anonunion_ifr_ifru_326 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_342 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_342 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_347 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_348 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_347 __annonCompField109 ;
   union __anonunion____missing_field_name_348 __annonCompField110 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_351 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_350 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_351 __annonCompField111 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_350 __annonCompField112 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_354 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_353 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_354 __annonCompField113 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_352 {
   struct __anonstruct____missing_field_name_353 __annonCompField114 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_356 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_355 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_356 __annonCompField116 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_357 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_358 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_359 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_352 __annonCompField115 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_355 __annonCompField117 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_357 __annonCompField118 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_358 __annonCompField119 ;
   union __anonunion____missing_field_name_359 __annonCompField120 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 508 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_368 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_368 possible_net_t;
#line 338 "include/linux/mii.h"
enum ldv_32014 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_32014 phy_interface_t;
#line 126
enum ldv_32068 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_32068 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_377 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_378 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_379 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_377 adj_list ;
   struct __anonstruct_all_adj_list_378 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_379 __annonCompField123 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 116 "include/linux/rtnetlink.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[29U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20
struct ip_mc_list;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 449 "include/linux/etherdevice.h"
struct dvb_net {
   struct dvb_device *dvbdev ;
   struct net_device *device[10U] ;
   int state[10U] ;
   unsigned char exit : 1 ;
   struct dmx_demux *demux ;
   struct mutex ioctl_mutex ;
};
#line 48 "drivers/media/dvb-core/dvb_net.h"
struct videobuf_mapping {
   unsigned int count ;
   struct videobuf_queue *q ;
};
#line 55 "include/media/videobuf-core.h"
enum videobuf_state {
    VIDEOBUF_NEEDS_INIT = 0,
    VIDEOBUF_PREPARED = 1,
    VIDEOBUF_QUEUED = 2,
    VIDEOBUF_ACTIVE = 3,
    VIDEOBUF_DONE = 4,
    VIDEOBUF_ERROR = 5,
    VIDEOBUF_IDLE = 6
} ;
#line 65 "include/media/videobuf-core.h"
struct videobuf_buffer {
   unsigned int i ;
   u32 magic ;
   unsigned int width ;
   unsigned int height ;
   unsigned int bytesperline ;
   unsigned long size ;
   enum v4l2_field field ;
   enum videobuf_state state ;
   struct list_head stream ;
   struct list_head queue ;
   wait_queue_head_t done ;
   unsigned int field_count ;
   struct timeval ts ;
   enum v4l2_memory memory ;
   size_t bsize ;
   size_t boff ;
   unsigned long baddr ;
   struct videobuf_mapping *map ;
   int privsize ;
   void *priv ;
};
#line 104 "include/media/videobuf-core.h"
struct videobuf_queue_ops {
   int (*buf_setup)(struct videobuf_queue * , unsigned int * , unsigned int * ) ;
   int (*buf_prepare)(struct videobuf_queue * , struct videobuf_buffer * , enum v4l2_field  ) ;
   void (*buf_queue)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   void (*buf_release)(struct videobuf_queue * , struct videobuf_buffer * ) ;
};
#line 115 "include/media/videobuf-core.h"
struct videobuf_qtype_ops {
   u32 magic ;
   struct videobuf_buffer *(*alloc_vb)(size_t  ) ;
   void *(*vaddr)(struct videobuf_buffer * ) ;
   int (*iolock)(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
   int (*sync)(struct videobuf_queue * , struct videobuf_buffer * ) ;
   int (*mmap_mapper)(struct videobuf_queue * , struct videobuf_buffer * , struct vm_area_struct * ) ;
};
#line 132 "include/media/videobuf-core.h"
struct videobuf_queue {
   struct mutex vb_lock ;
   struct mutex *ext_lock ;
   spinlock_t *irqlock ;
   struct device *dev ;
   wait_queue_head_t wait ;
   enum v4l2_buf_type type ;
   unsigned int msize ;
   enum v4l2_field field ;
   enum v4l2_field last ;
   struct videobuf_buffer *bufs[32U] ;
   struct videobuf_queue_ops  const  *ops ;
   struct videobuf_qtype_ops *int_ops ;
   unsigned char streaming : 1 ;
   unsigned char reading : 1 ;
   struct list_head stream ;
   unsigned int read_off ;
   struct videobuf_buffer *read_buf ;
   void *priv_data ;
};
#line 256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_options {
   int megabytes[7U] ;
   int cardtype ;
   int tuner ;
   int radio ;
};
#line 263 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_buffer {
   struct list_head list ;
   dma_addr_t dma_handle ;
   char *buf ;
   u32 bytesused ;
   u32 readpos ;
};
#line 309 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_mdl {
   struct list_head list ;
   u32 id ;
   unsigned int skipped ;
   unsigned long m_flags ;
   struct list_head buf_list ;
   struct cx18_buffer *curr_buf ;
   u32 bytesused ;
   u32 readpos ;
};
#line 323 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_queue {
   struct list_head list ;
   atomic_t depth ;
   u32 bytesused ;
   spinlock_t lock ;
};
#line 330 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_dvb {
   struct cx18_stream *stream ;
   struct dmx_frontend hw_frontend ;
   struct dmx_frontend mem_frontend ;
   struct dmxdev dmxdev ;
   struct dvb_adapter dvb_adapter ;
   struct dvb_demux demux ;
   struct dvb_frontend *fe ;
   struct dvb_net dvbnet ;
   int enabled ;
   int feeding ;
   struct mutex feedlock ;
};
#line 346
struct cx18_scb;
#line 347 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_in_work_order {
   struct work_struct work ;
   atomic_t pending ;
   struct cx18 *cx ;
   unsigned long flags ;
   int rpu ;
   struct cx18_mailbox mb ;
   struct cx18_mdl_ack mdl_ack[2U] ;
   char *str ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_stream {
   struct video_device video_dev ;
   struct cx18_dvb *dvb ;
   struct cx18 *cx ;
   char const   *name ;
   int type ;
   u32 handle ;
   u32 v4l2_dev_caps ;
   unsigned int mdl_base_idx ;
   u32 id ;
   unsigned long s_flags ;
   int dma ;
   wait_queue_head_t waitq ;
   struct list_head buf_pool ;
   u32 buffers ;
   u32 buf_size ;
   u32 bufs_per_mdl ;
   u32 mdl_size ;
   struct cx18_queue q_free ;
   struct cx18_queue q_busy ;
   struct cx18_queue q_full ;
   struct cx18_queue q_idle ;
   struct work_struct out_work_order ;
   u32 pixelformat ;
   u32 vb_bytes_per_frame ;
   u32 vb_bytes_per_line ;
   struct list_head vb_capture ;
   spinlock_t vb_lock ;
   struct timer_list vb_timeout ;
   struct videobuf_queue vbuf_q ;
   spinlock_t vbuf_q_lock ;
   enum v4l2_buf_type vb_type ;
};
#line 428 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_open_id {
   struct v4l2_fh fh ;
   u32 open_id ;
   int type ;
   struct cx18 *cx ;
};
#line 445
struct cx18_card;
#line 498 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct vbi_info {
   struct v4l2_format in ;
   struct v4l2_sliced_vbi_format *sliced_in ;
   u32 count ;
   u32 start[2U] ;
   u32 frame ;
   int insert_mpeg ;
   struct v4l2_sliced_vbi_data sliced_data[36U] ;
   u8 *sliced_mpeg_data[32U] ;
   u32 sliced_mpeg_size[32U] ;
   u32 inserted_frame ;
   struct cx18_mdl sliced_mpeg_mdl ;
   struct cx18_buffer sliced_mpeg_buf ;
};
#line 566 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_i2c_algo_callback_data {
   struct cx18 *cx ;
   int bus_index ;
};
#line 572
struct cx18_card_tuner_i2c;
#line 572
struct snd_cx18_card;
#line 572 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18 {
   int instance ;
   struct pci_dev *pci_dev ;
   struct v4l2_device v4l2_dev ;
   struct v4l2_subdev *sd_av ;
   struct v4l2_subdev *sd_extmux ;
   struct cx18_card  const  *card ;
   char const   *card_name ;
   struct cx18_card_tuner_i2c  const  *card_i2c ;
   u8 is_50hz ;
   u8 is_60hz ;
   u8 nof_inputs ;
   u8 nof_audio_inputs ;
   u32 v4l2_cap ;
   u32 hw_flags ;
   unsigned int free_mdl_idx ;
   struct cx18_scb *scb ;
   struct mutex epu2apu_mb_lock ;
   struct mutex epu2cpu_mb_lock ;
   struct cx18_av_state av_state ;
   struct cx2341x_handler cxhdl ;
   u32 filter_mode ;
   u32 temporal_strength ;
   u32 spatial_strength ;
   unsigned long dualwatch_jiffies ;
   u32 dualwatch_stereo_mode ;
   struct mutex serialize_lock ;
   struct cx18_options options ;
   int stream_buffers[7U] ;
   int stream_buf_size[7U] ;
   struct cx18_stream streams[7U] ;
   struct snd_cx18_card *alsa ;
   void (*pcm_announce_callback)(struct snd_cx18_card * , u8 * , size_t  ) ;
   unsigned long i_flags ;
   atomic_t ana_capturing ;
   atomic_t tot_capturing ;
   int search_pack_header ;
   int open_id ;
   resource_size_t base_addr ;
   u8 card_rev ;
   void *enc_mem ;
   void *reg_mem ;
   struct vbi_info vbi ;
   u64 mpg_data_received ;
   u64 vbi_data_inserted ;
   wait_queue_head_t mb_apu_waitq ;
   wait_queue_head_t mb_cpu_waitq ;
   wait_queue_head_t cap_w ;
   wait_queue_head_t dma_waitq ;
   u32 sw1_irq_mask ;
   u32 sw2_irq_mask ;
   u32 hw2_irq_mask ;
   struct workqueue_struct *in_work_queue ;
   char in_workq_name[11U] ;
   struct cx18_in_work_order in_work_order[70U] ;
   char epu_debug_str[256U] ;
   struct i2c_adapter i2c_adap[2U] ;
   struct i2c_algo_bit_data i2c_algo[2U] ;
   struct cx18_i2c_algo_callback_data i2c_algo_cb_data[2U] ;
   struct IR_i2c_init_data ir_i2c_init_data ;
   u32 gpio_dir ;
   u32 gpio_val ;
   struct mutex gpio_lock ;
   struct v4l2_subdev sd_gpiomux ;
   struct v4l2_subdev sd_resetctrl ;
   u32 audio_input ;
   u32 active_input ;
   v4l2_std_id std ;
   v4l2_std_id tuner_std ;
   struct work_struct request_module_wk ;
};
#line 693
struct tveeprom;
#line 190 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
struct cx18_card_video_input {
   u8 video_type ;
   u8 audio_index ;
   u32 video_input ;
};
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_audio_input {
   u8 audio_type ;
   u32 audio_input ;
   u16 muxer_input ;
};
#line 74 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_pci_info {
   u16 device ;
   u16 subsystem_vendor ;
   u16 subsystem_device ;
};
#line 81 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_init {
   u32 direction ;
   u32 initial_value ;
};
#line 90 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_i2c_slave_reset {
   u32 active_lo_mask ;
   u32 active_hi_mask ;
   int msecs_asserted ;
   int msecs_recovery ;
   u32 ir_reset_mask ;
};
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_gpio_audio_input {
   u32 mask ;
   u32 tuner ;
   u32 linein ;
   u32 radio ;
};
#line 105 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_tuner {
   v4l2_std_id std ;
   int tuner ;
};
#line 110 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card_tuner_i2c {
   unsigned short radio[2U] ;
   unsigned short demod[3U] ;
   unsigned short tv[4U] ;
};
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_ddr {
   u32 chip_config ;
   u32 refresh ;
   u32 timing1 ;
   u32 timing2 ;
   u32 tune_lane ;
   u32 initial_emrs ;
};
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card {
   int type ;
   char *name ;
   char *comment ;
   u32 v4l2_capabilities ;
   u32 hw_audio_ctrl ;
   u32 hw_muxer ;
   u32 hw_all ;
   struct cx18_card_video_input video_inputs[6U] ;
   struct cx18_card_audio_input audio_inputs[3U] ;
   struct cx18_card_audio_input radio_input ;
   u8 xceive_pin ;
   struct cx18_gpio_init gpio_init ;
   struct cx18_gpio_i2c_slave_reset gpio_i2c_slave_reset ;
   struct cx18_gpio_audio_input gpio_audio_input ;
   struct cx18_card_tuner tuners[2U] ;
   struct cx18_card_tuner_i2c *i2c ;
   struct cx18_ddr ddr ;
   struct cx18_card_pci_info  const  *pci_list ;
};
#line 63 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
struct cx18_mdl_ent {
   u32 paddr ;
   u32 length ;
};
#line 88 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-scb.h"
struct cx18_scb {
   u32 ipc_offset ;
   u32 reserved01[7U] ;
   u32 cpu_code_offset ;
   u32 reserved02[3U] ;
   u32 apu_code_offset ;
   u32 reserved03[3U] ;
   u32 hpu_code_offset ;
   u32 reserved04[3U] ;
   u32 ppu_code_offset ;
   u32 reserved05[3U] ;
   u32 cpu_state ;
   u32 reserved1[7U] ;
   u32 apu2cpu_mb_offset ;
   u32 apu2cpu_irq ;
   u32 cpu2apu_irq_ack ;
   u32 reserved2[13U] ;
   u32 hpu2cpu_mb_offset ;
   u32 hpu2cpu_irq ;
   u32 cpu2hpu_irq_ack ;
   u32 reserved3[13U] ;
   u32 ppu2cpu_mb_offset ;
   u32 ppu2cpu_irq ;
   u32 cpu2ppu_irq_ack ;
   u32 reserved4[13U] ;
   u32 epu2cpu_mb_offset ;
   u32 epu2cpu_irq ;
   u32 cpu2epu_irq_ack ;
   u32 reserved5[13U] ;
   u32 reserved6[8U] ;
   u32 apu_state ;
   u32 reserved11[7U] ;
   u32 cpu2apu_mb_offset ;
   u32 cpu2apu_irq ;
   u32 apu2cpu_irq_ack ;
   u32 reserved12[13U] ;
   u32 hpu2apu_mb_offset ;
   u32 hpu2apu_irq ;
   u32 apu2hpu_irq_ack ;
   u32 reserved13[13U] ;
   u32 ppu2apu_mb_offset ;
   u32 ppu2apu_irq ;
   u32 apu2ppu_irq_ack ;
   u32 reserved14[13U] ;
   u32 epu2apu_mb_offset ;
   u32 epu2apu_irq ;
   u32 apu2epu_irq_ack ;
   u32 reserved15[13U] ;
   u32 reserved16[8U] ;
   u32 hpu_state ;
   u32 reserved21[7U] ;
   u32 cpu2hpu_mb_offset ;
   u32 cpu2hpu_irq ;
   u32 hpu2cpu_irq_ack ;
   u32 reserved22[13U] ;
   u32 apu2hpu_mb_offset ;
   u32 apu2hpu_irq ;
   u32 hpu2apu_irq_ack ;
   u32 reserved23[13U] ;
   u32 ppu2hpu_mb_offset ;
   u32 ppu2hpu_irq ;
   u32 hpu2ppu_irq_ack ;
   u32 reserved24[13U] ;
   u32 epu2hpu_mb_offset ;
   u32 epu2hpu_irq ;
   u32 hpu2epu_irq_ack ;
   u32 reserved25[13U] ;
   u32 reserved26[8U] ;
   u32 ppu_state ;
   u32 reserved31[7U] ;
   u32 cpu2ppu_mb_offset ;
   u32 cpu2ppu_irq ;
   u32 ppu2cpu_irq_ack ;
   u32 reserved32[13U] ;
   u32 apu2ppu_mb_offset ;
   u32 apu2ppu_irq ;
   u32 ppu2apu_irq_ack ;
   u32 reserved33[13U] ;
   u32 hpu2ppu_mb_offset ;
   u32 hpu2ppu_irq ;
   u32 ppu2hpu_irq_ack ;
   u32 reserved34[13U] ;
   u32 epu2ppu_mb_offset ;
   u32 epu2ppu_irq ;
   u32 ppu2epu_irq_ack ;
   u32 reserved35[13U] ;
   u32 reserved36[8U] ;
   u32 epu_state ;
   u32 reserved41[7U] ;
   u32 cpu2epu_mb_offset ;
   u32 cpu2epu_irq ;
   u32 epu2cpu_irq_ack ;
   u32 reserved42[13U] ;
   u32 apu2epu_mb_offset ;
   u32 apu2epu_irq ;
   u32 epu2apu_irq_ack ;
   u32 reserved43[13U] ;
   u32 hpu2epu_mb_offset ;
   u32 hpu2epu_irq ;
   u32 epu2hpu_irq_ack ;
   u32 reserved44[13U] ;
   u32 ppu2epu_mb_offset ;
   u32 ppu2epu_irq ;
   u32 epu2ppu_irq_ack ;
   u32 reserved45[13U] ;
   u32 reserved46[8U] ;
   u32 semaphores[8U] ;
   u32 reserved50[32U] ;
   struct cx18_mailbox apu2cpu_mb ;
   struct cx18_mailbox hpu2cpu_mb ;
   struct cx18_mailbox ppu2cpu_mb ;
   struct cx18_mailbox epu2cpu_mb ;
   struct cx18_mailbox cpu2apu_mb ;
   struct cx18_mailbox hpu2apu_mb ;
   struct cx18_mailbox ppu2apu_mb ;
   struct cx18_mailbox epu2apu_mb ;
   struct cx18_mailbox cpu2hpu_mb ;
   struct cx18_mailbox apu2hpu_mb ;
   struct cx18_mailbox ppu2hpu_mb ;
   struct cx18_mailbox epu2hpu_mb ;
   struct cx18_mailbox cpu2ppu_mb ;
   struct cx18_mailbox apu2ppu_mb ;
   struct cx18_mailbox hpu2ppu_mb ;
   struct cx18_mailbox epu2ppu_mb ;
   struct cx18_mailbox cpu2epu_mb ;
   struct cx18_mailbox apu2epu_mb ;
   struct cx18_mailbox hpu2epu_mb ;
   struct cx18_mailbox ppu2epu_mb ;
   struct cx18_mdl_ack cpu_mdl_ack[7U][2U] ;
   struct cx18_mdl_ent cpu_mdl[1U] ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-controls.h"
struct xc2028_ctrl {
   char *fname ;
   int max_len ;
   int msleep ;
   unsigned int scode_table ;
   unsigned char mts : 1 ;
   unsigned char input1 : 1 ;
   unsigned char vhfbw7 : 1 ;
   unsigned char uhfbw8 : 1 ;
   unsigned char disable_power_mgmt : 1 ;
   unsigned char read_not_reliable : 1 ;
   unsigned int demod ;
   unsigned char type : 2 ;
};
#line 68 "drivers/media/tuners/tuner-xc2028.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 1088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 1107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 1209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___4;
#line 1220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef bool ldv_func_ret_type___7;
#line 1287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
struct i2c_board_info;
#line 44
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 271 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int irq ;
};
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 52 "include/linux/firmware.h"
struct cx18_apu_rom_seghdr {
   u32 sync1 ;
   u32 sync2 ;
   u32 addr ;
   u32 size ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 421 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
struct cx18_videobuf_buffer {
   struct videobuf_buffer vb ;
   v4l2_std_id tvnorm ;
   u32 bytes_used ;
};
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
struct __anonstruct_cx18_stream_info_393 {
   char const   *name ;
   int vfl_type ;
   int num_offset ;
   int dma ;
   u32 caps ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 45 "include/media/videobuf-vmalloc.h"
struct cx18_enc_idx_entry {
   __le32 length ;
   __le32 offset_low ;
   __le32 offset_high ;
   __le32 flags ;
   __le32 pts_low ;
   __le32 pts_high ;
};
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
struct cx18_api_info {
   u32 cmd ;
   u8 flags ;
   u8 rpu ;
   char const   *name ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
struct vbi_data_hdr {
   __be32 magic ;
   __be32 unknown ;
   __be32 pts ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
enum analog_signal_type {
    NONE = 0,
    CVBS = 1,
    Y = 2,
    C = 3,
    SIF = 4,
    Pb = 5,
    Pr = 6
} ;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
struct vbi_anc_data {
   u8 preamble[3U] ;
   u8 did ;
   u8 sdid ;
   u8 data_count ;
   u8 idid[2U] ;
   u8 payload[1U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-gpio.h"
struct s5h1409_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 gpio ;
   u16 qam_if ;
   u8 inversion ;
   u8 status_mode ;
   u16 mpeg_timing ;
   u8 hvr1600_opt ;
};
#line 72 "drivers/media/dvb-frontends/s5h1409.h"
struct mxl5005s_config {
   u8 i2c_address ;
   u32 if_freq ;
   u32 xtal_freq ;
   u8 agc_mode ;
   u8 tracking_filter ;
   u8 rssi_enable ;
   u8 cap_select ;
   u8 div_out ;
   u8 clock_out ;
   u32 output_load ;
   u32 top ;
   u8 mod_mode ;
   u8 if_mode ;
   u8 qam_gain ;
   u8 AgcMasterByte ;
};
#line 123 "drivers/media/tuners/mxl5005s.h"
struct s5h1411_config {
   u8 output_mode ;
   u8 gpio ;
   u16 mpeg_timing ;
   u16 qam_if ;
   u16 vsb_if ;
   u8 inversion ;
   u8 status_mode ;
};
#line 74 "drivers/media/dvb-frontends/s5h1411.h"
struct tda18271_std_map_item {
   u16 if_freq ;
   unsigned char agc_mode : 2 ;
   unsigned char std : 3 ;
   unsigned char fm_rfn : 1 ;
   unsigned char if_lvl : 3 ;
   unsigned char rfagc_top : 7 ;
};
#line 41 "drivers/media/tuners/tda18271.h"
struct tda18271_std_map {
   struct tda18271_std_map_item fm_radio ;
   struct tda18271_std_map_item atv_b ;
   struct tda18271_std_map_item atv_dk ;
   struct tda18271_std_map_item atv_gh ;
   struct tda18271_std_map_item atv_i ;
   struct tda18271_std_map_item atv_l ;
   struct tda18271_std_map_item atv_lc ;
   struct tda18271_std_map_item atv_mn ;
   struct tda18271_std_map_item atsc_6 ;
   struct tda18271_std_map_item dvbt_6 ;
   struct tda18271_std_map_item dvbt_7 ;
   struct tda18271_std_map_item dvbt_8 ;
   struct tda18271_std_map_item qam_6 ;
   struct tda18271_std_map_item qam_7 ;
   struct tda18271_std_map_item qam_8 ;
};
#line 59
enum tda18271_role {
    TDA18271_MASTER = 0,
    TDA18271_SLAVE = 1
} ;
#line 64
enum tda18271_i2c_gate {
    TDA18271_GATE_AUTO = 0,
    TDA18271_GATE_ANALOG = 1,
    TDA18271_GATE_DIGITAL = 2
} ;
#line 70
enum tda18271_output_options {
    TDA18271_OUTPUT_LT_XT_ON = 0,
    TDA18271_OUTPUT_LT_OFF = 1,
    TDA18271_OUTPUT_XT_OFF = 2
} ;
#line 76
enum tda18271_small_i2c {
    TDA18271_39_BYTE_CHUNK_INIT = 0,
    TDA18271_16_BYTE_CHUNK_INIT = 16,
    TDA18271_08_BYTE_CHUNK_INIT = 8,
    TDA18271_03_BYTE_CHUNK_INIT = 3
} ;
#line 83 "drivers/media/tuners/tda18271.h"
struct tda18271_config {
   struct tda18271_std_map *std_map ;
   enum tda18271_role role ;
   enum tda18271_i2c_gate gate ;
   enum tda18271_output_options output_opt ;
   enum tda18271_small_i2c small_i2c ;
   unsigned char rf_cal_on_startup : 1 ;
   unsigned char delay_cal : 1 ;
   unsigned int config ;
};
#line 126 "drivers/media/tuners/tda18271.h"
struct zl10353_config {
   u8 demod_address ;
   int adc_clock ;
   int if2 ;
   int no_tuner ;
   int parallel_ts ;
   unsigned char disable_i2c_gate_ctrl : 1 ;
   u8 clock_ctl_1 ;
   u8 pll_0 ;
};
#line 52 "include/linux/firmware.h"
struct mt352_config {
   u8 demod_address ;
   int adc_clock ;
   int if2 ;
   int no_tuner ;
   int (*demod_init)(struct dvb_frontend * ) ;
};
#line 47 "drivers/media/tuners/tuner-xc2028.h"
struct xc2028_config {
   struct i2c_adapter *i2c_adap ;
   u8 i2c_addr ;
   struct xc2028_ctrl *ctrl ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 44 "include/linux/i2c.h"
enum i2c_slave_event;
#line 44
enum i2c_slave_event;
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 57 "./arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5596: ;
#line 157
  return (__ret + i);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 173
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) ;
#line 68
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 72
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 81
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 85
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 94
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 98
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 120
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 121
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 124
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 146
void ldv_mutex_lock_vb_lock_of_videobuf_queue(struct mutex *lock ) ;
#line 150
void ldv_mutex_unlock_vb_lock_of_videobuf_queue(struct mutex *lock ) ;
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit((long )flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_24(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_27(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 441
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 447
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 460
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 463
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 471
extern bool flush_work(struct work_struct * ) ;
#line 474
bool ldv_flush_work_21(struct work_struct *ldv_func_arg1 ) ;
#line 476
extern bool cancel_work_sync(struct work_struct * ) ;
#line 479
bool ldv_cancel_work_sync_25(struct work_struct *ldv_func_arg1 ) ;
#line 483
bool ldv_cancel_work_sync_26(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work(system_wq, work);
#line 530
  return (tmp);
}
}
#line 139 "include/linux/ioport.h"
extern struct resource iomem_resource ;
#line 192
extern struct resource *__request_region(struct resource * , resource_size_t  , resource_size_t  ,
                                         char const   * , int  ) ;
#line 201
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 195
extern void iounmap(void volatile   * ) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 2821 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2823
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2823
  return (tmp);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_timer_state_5  =    0;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_8  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct timer_list *ldv_timer_list_5  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_15  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_sliced_vbi_format *cx18_av_vbi_ops_group1  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_20  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int pci_counter  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_audio *cx18_ioctl_ops_group1  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct videobuf_buffer *cx18_videobuf_qops_group2  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_0  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_21  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_5  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *resetctrl_core_ops_group0  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct file *cx18_v4l2_enc_fops_group0  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_13  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_12  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_buffer *cx18_ioctl_ops_group4  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_3_2  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_22  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_14  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct videobuf_queue *cx18_videobuf_qops_group1  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_3_0  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct file *cx18_ioctl_ops_group2  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_17  ;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct cx2341x_handler *cx18_cxhdl_ops_group0  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_19  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_9  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_24  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_event_subscription  const  *cx18_ioctl_ops_group0  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ref_cnt  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_3_3  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_vbi_ops_group0  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_1  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_7  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_23  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_video_ops_group0  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_audio_ops_group0  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_10  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_4_0  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_6  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_4_1  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_4_3  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_16  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_3_1  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_encoder_cmd *cx18_ioctl_ops_group6  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_2  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_25  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_2_0  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_4_2  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_11  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct pci_dev *cx18_pci_driver_group1  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_18  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_general_ops_group0  ;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_2_2  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_3  ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_fh *cx18_ioctl_ops_group3  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_subdev *cx18_av_tuner_ops_group0  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_2_3  ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
struct v4l2_format *cx18_ioctl_ops_group5  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_state_variable_4  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_work_2_1  ;
#line 230
void work_init_3(void) ;
#line 232
void ldv_initialize_v4l2_subdev_audio_ops_11(void) ;
#line 233
void ldv_initialize_v4l2_subdev_tuner_ops_12(void) ;
#line 235
void work_init_2(void) ;
#line 236
void call_and_disable_all_2(int state ) ;
#line 237
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 238
void activate_work_2(struct work_struct *work , int state ) ;
#line 239
void ldv_initialize_cx2341x_handler_ops_15(void) ;
#line 240
void activate_work_3(struct work_struct *work , int state ) ;
#line 241
void ldv_initialize_v4l2_subdev_core_ops_19(void) ;
#line 243
void choose_interrupt_1(void) ;
#line 244
void ldv_initialize_v4l2_ioctl_ops_16(void) ;
#line 245
void ldv_initialize_v4l2_subdev_vbi_ops_9(void) ;
#line 246
void call_and_disable_work_3(struct work_struct *work ) ;
#line 247
void ldv_pci_driver_25(void) ;
#line 248
void ldv_initialize_v4l2_subdev_core_ops_13(void) ;
#line 249
void ldv_videobuf_queue_ops_17(void) ;
#line 250
void disable_work_3(struct work_struct *work ) ;
#line 251
void disable_work_2(struct work_struct *work ) ;
#line 253
void work_init_4(void) ;
#line 254
void invoke_work_3(void) ;
#line 255
void disable_suitable_irq_1(int line , void *data ) ;
#line 256
int ldv_irq_1(int state , int line , void *data ) ;
#line 257
void activate_suitable_irq_1(int line , void *data ) ;
#line 261
void call_and_disable_all_3(int state ) ;
#line 265
void call_and_disable_work_2(struct work_struct *work ) ;
#line 266
void ldv_initialize_v4l2_subdev_video_ops_10(void) ;
#line 267
void invoke_work_2(void) ;
#line 268
void ldv_initialize_v4l2_file_operations_18(void) ;
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 857 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 859
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 863
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 865
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 885 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 887
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 887
  return (tmp);
}
}
#line 894 "include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
#line 896
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
#line 896
  return (tmp);
}
}
#line 898 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 900
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 900
  return (tmp);
}
}
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_29(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_30(struct pci_driver *ldv_func_arg1 ) ;
#line 61 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_set_mask(struct device * , u64  ) ;
#line 113 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
#line 115
  return (tmp);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_22(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 150
extern void free_irq(unsigned int  , void * ) ;
#line 153
void ldv_free_irq_23(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 157
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 77 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 104
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 87 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_vapi(struct cx18 *cx , u32 cmd , int args  , ...) ;
#line 88
int cx18_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) ;
#line 93
void cx18_in_work_handler(struct work_struct *work ) ;
#line 370 "include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-av-core.h"
int cx18_av_probe(struct cx18 *cx ) ;
#line 193 "include/media/cx2341x.h"
extern int cx2341x_handler_init(struct cx2341x_handler * , unsigned int  ) ;
#line 195
extern void cx2341x_handler_set_50hz(struct cx2341x_handler * , int  ) ;
#line 255 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
int cx18_debug  ;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples  =    1444U;
#line 678 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18 *to_cx18(struct v4l2_device *v4l2_dev ) 
{ 
  struct v4l2_device  const  *__mptr ;

  {
#line 680
  __mptr = (struct v4l2_device  const  *)v4l2_dev;
#line 680
  return ((struct cx18 *)__mptr + 0xfffffffffffffff0UL);
}
}
#line 684 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
int (*cx18_ext_init)(struct cx18 * )  ;
#line 687 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
int cx18_first_minor  ;
#line 692
int cx18_msleep_timeout(unsigned int msecs , int intr ) ;
#line 696
void cx18_read_eeprom(struct cx18 *cx , struct tveeprom *tv ) ;
#line 699
int cx18_init_on_first_open(struct cx18 *cx ) ;
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_readl(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned int tmp ;

  {
#line 62
  tmp = readl((void const volatile   *)addr);
#line 62
  return (tmp);
}
}
#line 167 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_read_reg(struct cx18 *cx , u32 reg ) 
{ 
  u32 tmp ;

  {
#line 169
  tmp = cx18_readl(cx, (void const   *)cx->reg_mem + (unsigned long )reg);
#line 169
  return (tmp);
}
}
#line 185
void cx18_sw1_irq_disable(struct cx18 *cx , u32 val ) ;
#line 187
void cx18_sw2_irq_disable(struct cx18 *cx , u32 val ) ;
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
struct cx18_card  const  *cx18_get_card(u16 index ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-i2c.h"
int cx18_i2c_register(struct cx18 *cx , unsigned int idx ) ;
#line 25
struct v4l2_subdev *cx18_find_hw(struct cx18 *cx , u32 hw ) ;
#line 28
int init_cx18_i2c(struct cx18 *cx ) ;
#line 29
void exit_cx18_i2c(struct cx18 *cx ) ;
#line 35 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-irq.h"
irqreturn_t cx18_irq_handler(int irq , void *dev_id ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-gpio.h"
void cx18_gpio_init(struct cx18 *cx ) ;
#line 25
int cx18_gpio_register(struct cx18 *cx , u32 hw ) ;
#line 34
int cx18_reset_tuner_gpio(void *dev , int component , int cmd , int value ) ;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-firmware.h"
int cx18_firmware_init(struct cx18 *cx ) ;
#line 23
void cx18_halt_firmware(struct cx18 *cx ) ;
#line 24
void cx18_init_memory(struct cx18 *cx ) ;
#line 25
void cx18_init_power(struct cx18 *cx , int lowpwr ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
int cx18_streams_setup(struct cx18 *cx ) ;
#line 28
int cx18_streams_register(struct cx18 *cx ) ;
#line 29
void cx18_streams_cleanup(struct cx18 *cx , int unregister ) ;
#line 62
void cx18_stop_all_captures(struct cx18 *cx ) ;
#line 278 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-scb.h"
void cx18_init_scb(struct cx18 *cx ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
int cx18_s_std(struct file *file , void *fh , v4l2_std_id std ) ;
#line 30
int cx18_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) ;
#line 31
int cx18_s_input(struct file *file , void *fh , unsigned int inp ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-controls.h"
struct cx2341x_handler_ops cx18_cxhdl_ops ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 51
extern int tveeprom_read(struct i2c_client * , unsigned char * , int  ) ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static char const   __kstrtab_cx18_ext_init[14U]  = 
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
  {      'c',      'x',      '1',      '8', 
        '_',      'e',      'x',      't', 
        '_',      'i',      'n',      'i', 
        't',      '\000'};
#line 53
struct kernel_symbol  const  __ksymtab_cx18_ext_init ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
struct kernel_symbol  const  __ksymtab_cx18_ext_init  =    {(unsigned long )(& cx18_ext_init), (char const   *)(& __kstrtab_cx18_ext_init)};
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static struct pci_device_id cx18_pci_tbl[2U]  = {      {5361U, 23418U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
struct pci_device_id  const  __mod_pci__cx18_pci_tbl_device_table[2U]  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static atomic_t cx18_instance  =    {0};
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cardtype[32U]  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int tuner[32U]  = 
#line 68
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int radio[32U]  = 
#line 72
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static char pal[3U]  = {      '-',      '-',      '\000'};
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static char secam[3U]  = {      '-',      '-',      '\000'};
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static char ntsc[2U]  = {      '-',      '\000'};
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_ts_buffers  =    1;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_mpg_buffers  =    2;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_idx_buffers  =    1;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_yuv_buffers  =    2;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_vbi_buffers  =    1;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_pcm_buffers  =    1;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_ts_bufsize  =    32;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_mpg_bufsize  =    32;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_idx_bufsize  =    2;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_yuv_bufsize  =    102;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_pcm_bufsize  =    4;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_ts_bufs  =    -1;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_mpg_bufs  =    -1;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_idx_bufs  =    63;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_yuv_bufs  =    -1;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_vbi_bufs  =    -1;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int enc_pcm_bufs  =    -1;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cx18_pci_latency  =    1;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void request_module_async(struct work_struct *work ) 
{ 
  struct cx18 *dev ;
  struct work_struct  const  *__mptr ;

  {
#line 257
  __mptr = (struct work_struct  const  *)work;
#line 257
  dev = (struct cx18 *)__mptr + 0xffffffffffff42b0UL;
#line 260
  __request_module(1, "cx18-alsa");
#line 263
  if ((unsigned long )cx18_ext_init != (unsigned long )((int (*)(struct cx18 * ))0)) {
#line 264
    (*cx18_ext_init)(dev);
  } else {

  }
#line 265
  return;
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void request_modules(struct cx18 *dev ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 269
  __init_work(& dev->request_module_wk, 0);
#line 269
  __constr_expr_0.counter = 137438953408L;
#line 269
  dev->request_module_wk.data = __constr_expr_0;
#line 269
  lockdep_init_map(& dev->request_module_wk.lockdep_map, "(&dev->request_module_wk)",
                   & __key, 0);
#line 269
  INIT_LIST_HEAD(& dev->request_module_wk.entry);
#line 269
  dev->request_module_wk.func = & request_module_async;
#line 270
  schedule_work(& dev->request_module_wk);
#line 271
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void flush_request_modules(struct cx18 *dev ) 
{ 


  {
#line 275
  ldv_flush_work_21(& dev->request_module_wk);
#line 276
  return;
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
int cx18_msleep_timeout(unsigned int msecs , int intr ) 
{ 
  long timeout ;
  unsigned long tmp ;
  int sig ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;

  {
#line 285
  tmp = msecs_to_jiffies(msecs);
#line 285
  timeout = (long )tmp;
  ldv_54445: 
#line 289
  tmp___0 = get_current();
#line 289
  tmp___0->task_state_change = 0UL;
#line 289
  __ret = intr != 0 ? 1L : 2L;
#line 289
  switch (8UL) {
  case 1UL: 
#line 289
  tmp___1 = get_current();
#line 289
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 289
  goto ldv_54439;
  case 2UL: 
#line 289
  tmp___2 = get_current();
#line 289
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 289
  goto ldv_54439;
  case 4UL: 
#line 289
  tmp___3 = get_current();
#line 289
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 289
  goto ldv_54439;
  case 8UL: 
#line 289
  tmp___4 = get_current();
#line 289
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 289
  goto ldv_54439;
  default: 
#line 289
  __xchg_wrong_size();
  }
  ldv_54439: 
#line 290
  timeout = schedule_timeout(timeout);
#line 291
  if (intr != 0) {
#line 291
    tmp___5 = get_current();
#line 291
    tmp___6 = signal_pending(tmp___5);
#line 291
    sig = tmp___6;
  } else {
#line 291
    sig = 0;
  }
#line 292
  if (sig == 0 && timeout != 0L) {
#line 294
    goto ldv_54445;
  } else {

  }

#line 293
  return (sig);
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_iounmap(struct cx18 *cx ) 
{ 


  {
#line 299
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 300
    return;
  } else {

  }
#line 303
  if ((unsigned long )cx->enc_mem != (unsigned long )((void *)0)) {
#line 304
    if ((cx18_debug & 2) != 0) {
#line 304
      printk("\016%s:  info: releasing enc_mem\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 305
    iounmap((void volatile   *)cx->enc_mem);
#line 306
    cx->enc_mem = (void *)0;
  } else {

  }
#line 308
  return;
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_eeprom_dump(struct cx18 *cx , unsigned char *eedata , int len ) 
{ 
  int i ;

  {
#line 314
  printk("\016%s: eeprom dump:\n", (char *)(& cx->v4l2_dev.name));
#line 315
  i = 0;
#line 315
  goto ldv_54457;
  ldv_54456: ;
#line 316
  if (((unsigned int )i & 15U) == 0U) {
#line 317
    printk("\016%s: eeprom %02x:", (char *)(& cx->v4l2_dev.name), i);
  } else {

  }
#line 318
  printk(" %02x", (int )*(eedata + (unsigned long )i));
#line 319
  if (i % 16 == 15) {
#line 320
    printk("\n");
  } else {

  }
#line 315
  i = i + 1;
  ldv_54457: ;
#line 315
  if (i < len) {
#line 317
    goto ldv_54456;
  } else {

  }

#line 322
  return;
}
}
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
void cx18_read_eeprom(struct cx18 *cx , struct tveeprom *tv ) 
{ 
  struct i2c_client *c ;
  u8 eedata[256U] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 330
  memset((void *)tv, 0, 76UL);
#line 332
  tmp = kzalloc(1480UL, 208U);
#line 332
  c = (struct i2c_client *)tmp;
#line 333
  if ((unsigned long )c == (unsigned long )((struct i2c_client *)0)) {
#line 334
    return;
  } else {

  }
#line 336
  strlcpy((char *)(& c->name), "cx18 tveeprom tmp", 20UL);
#line 337
  c->adapter = (struct i2c_adapter *)(& cx->i2c_adap);
#line 338
  c->addr = 80U;
#line 340
  tmp___0 = tveeprom_read(c, (unsigned char *)(& eedata), 256);
#line 340
  if (tmp___0 != 0) {
#line 341
    goto ret;
  } else {

  }
#line 343
  switch ((cx->card)->type) {
  case 0: ;
  case 1: ;
  case 9: 
#line 347
  tveeprom_hauppauge_analog(c, tv, (unsigned char *)(& eedata));
#line 348
  goto ldv_54469;
  case 3: ;
  case 8: 
#line 351
  tv->model = 1816U;
#line 352
  cx18_eeprom_dump(cx, (unsigned char *)(& eedata), 256);
#line 353
  printk("\016%s: eeprom PCI ID: %02x%02x:%02x%02x\n", (char *)(& cx->v4l2_dev.name),
         (int )eedata[2], (int )eedata[1], (int )eedata[4], (int )eedata[3]);
#line 355
  goto ldv_54469;
  default: 
#line 357
  tv->model = 4294967295U;
#line 358
  cx18_eeprom_dump(cx, (unsigned char *)(& eedata), 256);
#line 359
  goto ldv_54469;
  }
  ldv_54469: ;
  ret: 
#line 363
  kfree((void const   *)c);
#line 364
  return;
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_process_eeprom(struct cx18 *cx ) 
{ 
  struct tveeprom tv ;

  {
#line 370
  cx18_read_eeprom(cx, & tv);
#line 377
  switch (tv.model) {
  case 74301U: ;
  case 74321U: ;
  case 74351U: ;
  case 74361U: 
#line 383
  cx->card = cx18_get_card(9);
#line 384
  goto ldv_54481;
  case 74021U: ;
  case 74031U: ;
  case 74041U: ;
  case 74141U: ;
  case 74541U: ;
  case 74551U: ;
  case 74591U: ;
  case 74651U: ;
  case 74691U: ;
  case 74751U: ;
  case 74891U: 
#line 397
  cx->card = cx18_get_card(0);
#line 398
  goto ldv_54481;
  case 1816U: ;
#line 400
  return;
  case 4294967295U: 
#line 402
  printk("\016%s: Unknown EEPROM encoding\n", (char *)(& cx->v4l2_dev.name));
#line 403
  return;
  case 0U: 
#line 405
  printk("\v%s: Invalid EEPROM\n", (char *)(& cx->v4l2_dev.name));
#line 406
  return;
  default: 
#line 408
  printk("\v%s: Unknown model %d, defaulting to original HVR-1600 (cardtype=1)\n",
         (char *)(& cx->v4l2_dev.name), tv.model);
#line 410
  cx->card = cx18_get_card(0);
#line 411
  goto ldv_54481;
  }
  ldv_54481: 
#line 414
  cx->v4l2_cap = (cx->card)->v4l2_capabilities;
#line 415
  cx->card_name = (char const   *)(cx->card)->name;
#line 416
  cx->card_i2c = (struct cx18_card_tuner_i2c  const  *)(cx->card)->i2c;
#line 418
  printk("\016%s: Autodetected %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 420
  if (tv.tuner_type == 4U) {
#line 421
    printk("\v%s: tveeprom cannot autodetect tuner!\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 423
  if (cx->options.tuner == -1) {
#line 424
    cx->options.tuner = (int )tv.tuner_type;
  } else {

  }
#line 425
  if (cx->options.radio == -1) {
#line 426
    cx->options.radio = tv.has_radio != 0U;
  } else {

  }
#line 428
  if (cx->std != 0ULL) {
#line 430
    return;
  } else {

  }
#line 438
  if (((unsigned long long )tv.tuner_formats & 16758783ULL) == 16758783ULL) {
#line 440
    if ((cx18_debug & 2) != 0) {
#line 440
      printk("\016%s:  info: Worldwide tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 441
    cx->std = 16777215ULL;
  } else
#line 442
  if (((unsigned long long )tv.tuner_formats & 255ULL) != 0ULL) {
#line 443
    if ((cx18_debug & 2) != 0) {
#line 443
      printk("\016%s:  info: PAL tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 444
    cx->std = cx->std | 15ULL;
  } else
#line 445
  if (((unsigned long long )tv.tuner_formats & 45056ULL) != 0ULL) {
#line 446
    if ((cx18_debug & 2) != 0) {
#line 446
      printk("\016%s:  info: NTSC tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 447
    cx->std = cx->std | 4096ULL;
  } else
#line 448
  if (((unsigned long long )tv.tuner_formats & 16711680ULL) != 0ULL) {
#line 449
    if ((cx18_debug & 2) != 0) {
#line 449
      printk("\016%s:  info: SECAM tuner detected\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 450
    cx->std = cx->std | 4194304ULL;
  } else {
#line 452
    printk("\016%s: No tuner detected, default to NTSC-M\n", (char *)(& cx->v4l2_dev.name));
#line 453
    cx->std = cx->std | 4096ULL;
  }
#line 455
  return;
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static v4l2_std_id cx18_parse_std(struct cx18 *cx ) 
{ 


  {
#line 459
  switch ((int )pal[0]) {
  case 54: ;
#line 461
  return (2048ULL);
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
#line 466
  return (7ULL);
  case 104: ;
  case 72: ;
#line 469
  return (8ULL);
  case 110: ;
  case 78: ;
#line 472
  if ((int )((signed char )pal[1]) == 99 || (int )((signed char )pal[1]) == 67) {
#line 473
    return (1024ULL);
  } else {

  }
#line 474
  return (512ULL);
  case 105: ;
  case 73: ;
#line 477
  return (16ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: ;
#line 482
  return (224ULL);
  case 77: ;
  case 109: ;
#line 485
  return (256ULL);
  case 45: ;
#line 487
  goto ldv_54518;
  default: 
#line 489
  printk("\f%s: pal= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 490
  return (0ULL);
  }
  ldv_54518: ;
#line 493
  switch ((int )secam[0]) {
  case 98: ;
  case 66: ;
  case 103: ;
  case 71: ;
  case 104: ;
  case 72: ;
#line 500
  return (851968ULL);
  case 100: ;
  case 68: ;
  case 107: ;
  case 75: ;
#line 505
  return (3276800ULL);
  case 108: ;
  case 76: ;
#line 508
  if ((int )((signed char )secam[1]) == 67 || (int )((signed char )secam[1]) == 99) {
#line 509
    return (8388608ULL);
  } else {

  }
#line 510
  return (4194304ULL);
  case 45: ;
#line 512
  goto ldv_54533;
  default: 
#line 514
  printk("\f%s: secam= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 515
  return (0ULL);
  }
  ldv_54533: ;
#line 518
  switch ((int )ntsc[0]) {
  case 109: ;
  case 77: ;
#line 521
  return (4096ULL);
  case 106: ;
  case 74: ;
#line 524
  return (8192ULL);
  case 107: ;
  case 75: ;
#line 527
  return (32768ULL);
  case 45: ;
#line 529
  goto ldv_54542;
  default: 
#line 531
  printk("\f%s: ntsc= argument not recognised\n", (char *)(& cx->v4l2_dev.name));
#line 532
  return (0ULL);
  }
  ldv_54542: ;
#line 536
  return (0ULL);
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_process_options(struct cx18 *cx ) 
{ 
  int i ;
  int j ;
  struct cx18_card  const  *tmp ;

  {
#line 543
  cx->options.megabytes[1] = enc_ts_buffers;
#line 544
  cx->options.megabytes[0] = enc_mpg_buffers;
#line 545
  cx->options.megabytes[5] = enc_idx_buffers;
#line 546
  cx->options.megabytes[2] = enc_yuv_buffers;
#line 547
  cx->options.megabytes[3] = enc_vbi_buffers;
#line 548
  cx->options.megabytes[4] = enc_pcm_buffers;
#line 549
  cx->options.megabytes[6] = 0;
#line 551
  cx->stream_buffers[1] = enc_ts_bufs;
#line 552
  cx->stream_buffers[0] = enc_mpg_bufs;
#line 553
  cx->stream_buffers[5] = enc_idx_bufs;
#line 554
  cx->stream_buffers[2] = enc_yuv_bufs;
#line 555
  cx->stream_buffers[3] = enc_vbi_bufs;
#line 556
  cx->stream_buffers[4] = enc_pcm_bufs;
#line 557
  cx->stream_buffers[6] = 0;
#line 559
  cx->stream_buf_size[1] = enc_ts_bufsize;
#line 560
  cx->stream_buf_size[0] = enc_mpg_bufsize;
#line 561
  cx->stream_buf_size[5] = enc_idx_bufsize;
#line 562
  cx->stream_buf_size[2] = enc_yuv_bufsize;
#line 563
  cx->stream_buf_size[3] = (int )((unsigned int )vbi_active_samples * 36U);
#line 564
  cx->stream_buf_size[4] = enc_pcm_bufsize;
#line 565
  cx->stream_buf_size[6] = 0;
#line 568
  i = 0;
#line 568
  goto ldv_54551;
  ldv_54550: ;
#line 569
  if ((cx->stream_buffers[i] == 0 || cx->options.megabytes[i] <= 0) || cx->stream_buf_size[i] <= 0) {
#line 572
    cx->options.megabytes[i] = 0;
#line 573
    cx->stream_buffers[i] = 0;
#line 574
    cx->stream_buf_size[i] = 0;
#line 575
    goto ldv_54549;
  } else {

  }
#line 587
  if (i == 2) {
#line 588
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
#line 589
    cx->stream_buf_size[i] = cx->stream_buf_size[i] - cx->stream_buf_size[i] % 34560;
#line 592
    if (cx->stream_buf_size[i] <= 34559) {
#line 593
      cx->stream_buf_size[i] = 34560;
    } else {

    }
  } else
#line 595
  if (i == 5) {
#line 596
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
#line 597
    cx->stream_buf_size[i] = (int )((unsigned int )cx->stream_buf_size[i] - (unsigned int )((unsigned long )cx->stream_buf_size[i] % 1536UL));
#line 600
    if ((unsigned int )cx->stream_buf_size[i] <= 1535U) {
#line 601
      cx->stream_buf_size[i] = 1536;
    } else {

    }
  } else {

  }
#line 610
  if ((i == 3 || i == 2) || i == 5) {
#line 613
    if (cx->stream_buffers[i] < 0) {
#line 614
      cx->stream_buffers[i] = (cx->options.megabytes[i] * 1048576) / cx->stream_buf_size[i];
    } else {
#line 619
      cx->options.megabytes[i] = (cx->stream_buffers[i] * cx->stream_buf_size[i]) / 1048576;
    }
  } else {
#line 625
    if (cx->stream_buffers[i] < 0) {
#line 626
      cx->stream_buffers[i] = (cx->options.megabytes[i] * 1024) / cx->stream_buf_size[i];
    } else {
#line 631
      cx->options.megabytes[i] = (cx->stream_buffers[i] * cx->stream_buf_size[i]) / 1024;
    }
#line 636
    cx->stream_buf_size[i] = cx->stream_buf_size[i] * 1024;
  }
#line 638
  if ((cx18_debug & 2) != 0) {
#line 638
    printk("\016%s:  info: Stream type %d options: %d MB, %d buffers, %d bytes\n",
           (char *)(& cx->v4l2_dev.name), i, cx->options.megabytes[i], cx->stream_buffers[i],
           cx->stream_buf_size[i]);
  } else {

  }
  ldv_54549: 
#line 568
  i = i + 1;
  ldv_54551: ;
#line 568
  if (i <= 6) {
#line 570
    goto ldv_54550;
  } else {

  }
#line 643
  cx->options.cardtype = cardtype[cx->instance];
#line 644
  cx->options.tuner = tuner[cx->instance];
#line 645
  cx->options.radio = radio[cx->instance];
#line 647
  cx->std = cx18_parse_std(cx);
#line 648
  if (cx->options.cardtype == -1) {
#line 649
    printk("\016%s: Ignore card\n", (char *)(& cx->v4l2_dev.name));
#line 650
    return;
  } else {

  }
#line 652
  cx->card = cx18_get_card((int )((unsigned int )((u16 )cx->options.cardtype) + 65535U));
#line 653
  if ((unsigned long )cx->card != (unsigned long )((struct cx18_card  const  *)0)) {
#line 654
    printk("\016%s: User specified %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
  } else
#line 655
  if (cx->options.cardtype != 0) {
#line 656
    printk("\v%s: Unknown user specified type, trying to autodetect card\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 657
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 658
    if ((unsigned int )(cx->pci_dev)->subsystem_vendor == 112U) {
#line 659
      cx->card = cx18_get_card(0);
#line 660
      printk("\016%s: Autodetected Hauppauge card\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 663
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 664
    i = 0;
#line 664
    goto ldv_54560;
    ldv_54559: ;
#line 665
    if ((unsigned long )(cx->card)->pci_list == (unsigned long )((struct cx18_card_pci_info  const  */* const  */)0)) {
#line 666
      goto ldv_54553;
    } else {

    }
#line 667
    j = 0;
#line 667
    goto ldv_54557;
    ldv_54556: ;
#line 668
    if ((int )(cx->pci_dev)->device != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->device)) {
#line 670
      goto ldv_54554;
    } else {

    }
#line 671
    if ((int )(cx->pci_dev)->subsystem_vendor != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->subsystem_vendor)) {
#line 673
      goto ldv_54554;
    } else {

    }
#line 674
    if ((int )(cx->pci_dev)->subsystem_device != (int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->subsystem_device)) {
#line 676
      goto ldv_54554;
    } else {

    }
#line 677
    printk("\016%s: Autodetected %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
#line 678
    goto done;
    ldv_54554: 
#line 667
    j = j + 1;
    ldv_54557: ;
#line 667
    if ((unsigned int )((unsigned short )((cx->card)->pci_list + (unsigned long )j)->device) != 0U) {
#line 669
      goto ldv_54556;
    } else {

    }

    ldv_54553: 
#line 664
    i = i + 1;
    ldv_54560: 
#line 664
    tmp = cx18_get_card((int )((u16 )i));
#line 664
    cx->card = tmp;
#line 664
    if ((unsigned long )tmp != (unsigned long )((struct cx18_card  const  *)0)) {
#line 666
      goto ldv_54559;
    } else {

    }

  } else {

  }
  done: ;
#line 684
  if ((unsigned long )cx->card == (unsigned long )((struct cx18_card  const  *)0)) {
#line 685
    cx->card = cx18_get_card(0);
#line 686
    printk("\v%s: Unknown card: vendor/device: [%04x:%04x]\n", (char *)(& cx->v4l2_dev.name),
           (int )(cx->pci_dev)->vendor, (int )(cx->pci_dev)->device);
#line 688
    printk("\v%s:               subsystem vendor/device: [%04x:%04x]\n", (char *)(& cx->v4l2_dev.name),
           (int )(cx->pci_dev)->subsystem_vendor, (int )(cx->pci_dev)->subsystem_device);
#line 691
    printk("\v%s: Defaulting to %s card\n", (char *)(& cx->v4l2_dev.name), (cx->card)->name);
#line 692
    printk("\v%s: Please mail the vendor/device and subsystem vendor/device IDs and what kind of\n",
           (char *)(& cx->v4l2_dev.name));
#line 693
    printk("\v%s: card you have to the ivtv-devel mailinglist (www.ivtvdriver.org)\n",
           (char *)(& cx->v4l2_dev.name));
#line 694
    printk("\v%s: Prefix your subject line with [UNKNOWN CX18 CARD].\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 696
  cx->v4l2_cap = (cx->card)->v4l2_capabilities;
#line 697
  cx->card_name = (char const   *)(cx->card)->name;
#line 698
  cx->card_i2c = (struct cx18_card_tuner_i2c  const  *)(cx->card)->i2c;
#line 699
  return;
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cx18_create_in_workq(struct cx18 *cx ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 703
  snprintf((char *)(& cx->in_workq_name), 11UL, "%s-in", (char *)(& cx->v4l2_dev.name));
#line 705
  __lock_name = "\"%s\"cx->in_workq_name";
#line 705
  tmp = __alloc_workqueue_key("%s", 131074U, 1, & __key, __lock_name, (char *)(& cx->in_workq_name));
#line 705
  cx->in_work_queue = tmp;
#line 706
  if ((unsigned long )cx->in_work_queue == (unsigned long )((struct workqueue_struct *)0)) {
#line 707
    printk("\v%s: Unable to create incoming mailbox handler thread\n", (char *)(& cx->v4l2_dev.name));
#line 708
    return (-12);
  } else {

  }
#line 710
  return (0);
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_init_in_work_orders(struct cx18 *cx ) 
{ 
  int i ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 716
  i = 0;
#line 716
  goto ldv_54575;
  ldv_54574: 
#line 717
  cx->in_work_order[i].cx = cx;
#line 718
  cx->in_work_order[i].str = (char *)(& cx->epu_debug_str);
#line 719
  __init_work(& cx->in_work_order[i].work, 0);
#line 719
  __constr_expr_0.counter = 137438953408L;
#line 719
  cx->in_work_order[i].work.data = __constr_expr_0;
#line 719
  lockdep_init_map(& cx->in_work_order[i].work.lockdep_map, "(&cx->in_work_order[i].work)",
                   & __key, 0);
#line 719
  INIT_LIST_HEAD(& cx->in_work_order[i].work.entry);
#line 719
  cx->in_work_order[i].work.func = & cx18_in_work_handler;
#line 716
  i = i + 1;
  ldv_54575: ;
#line 716
  if (i <= 69) {
#line 718
    goto ldv_54574;
  } else {

  }

#line 723
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cx18_init_struct1(struct cx18 *cx ) 
{ 
  int ret ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;

  {
#line 732
  cx->base_addr = (cx->pci_dev)->resource[0].start;
#line 734
  __mutex_init(& cx->serialize_lock, "&cx->serialize_lock", & __key);
#line 735
  __mutex_init(& cx->gpio_lock, "&cx->gpio_lock", & __key___0);
#line 736
  __mutex_init(& cx->epu2apu_mb_lock, "&cx->epu2apu_mb_lock", & __key___1);
#line 737
  __mutex_init(& cx->epu2cpu_mb_lock, "&cx->epu2cpu_mb_lock", & __key___2);
#line 739
  ret = cx18_create_in_workq(cx);
#line 740
  if (ret != 0) {
#line 741
    return (ret);
  } else {

  }
#line 743
  cx18_init_in_work_orders(cx);
#line 746
  cx->open_id = 1;
#line 749
  cx->cxhdl.port = 0;
#line 750
  cx->cxhdl.capabilities = 3U;
#line 751
  cx->cxhdl.ops = (struct cx2341x_handler_ops  const  *)(& cx18_cxhdl_ops);
#line 752
  cx->cxhdl.func = & cx18_api_func;
#line 753
  cx->cxhdl.priv = (void *)(& cx->streams);
#line 754
  ret = cx2341x_handler_init(& cx->cxhdl, 50U);
#line 755
  if (ret != 0) {
#line 756
    return (ret);
  } else {

  }
#line 757
  cx->v4l2_dev.ctrl_handler = & cx->cxhdl.hdl;
#line 759
  cx->temporal_strength = (u32 )(cx->cxhdl.__annonCompField102.video_temporal_filter)->cur.val;
#line 760
  cx->spatial_strength = (u32 )(cx->cxhdl.__annonCompField102.video_spatial_filter)->cur.val;
#line 761
  cx->filter_mode = (u32 )(((cx->cxhdl.__annonCompField100.video_spatial_filter_mode)->cur.val | ((cx->cxhdl.__annonCompField100.video_temporal_filter_mode)->cur.val << 1)) | ((cx->cxhdl.__annonCompField100.video_median_filter_type)->cur.val << 2));
#line 765
  __init_waitqueue_head(& cx->cap_w, "&cx->cap_w", & __key___3);
#line 766
  __init_waitqueue_head(& cx->mb_apu_waitq, "&cx->mb_apu_waitq", & __key___4);
#line 767
  __init_waitqueue_head(& cx->mb_cpu_waitq, "&cx->mb_cpu_waitq", & __key___5);
#line 768
  __init_waitqueue_head(& cx->dma_waitq, "&cx->dma_waitq", & __key___6);
#line 771
  cx->vbi.in.type = 4U;
#line 772
  cx->vbi.sliced_in = & cx->vbi.in.fmt.sliced;
#line 775
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_buf.list);
#line 776
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_mdl.list);
#line 777
  INIT_LIST_HEAD(& cx->vbi.sliced_mpeg_mdl.buf_list);
#line 778
  list_add(& cx->vbi.sliced_mpeg_buf.list, & cx->vbi.sliced_mpeg_mdl.buf_list);
#line 780
  return (0);
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_init_struct2(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 789
  i = 0;
#line 789
  goto ldv_54595;
  ldv_54594: ;
#line 790
  if ((unsigned int )((unsigned char )(cx->card)->video_inputs[i].video_type) == 0U) {
#line 791
    goto ldv_54593;
  } else {

  }
#line 789
  i = i + 1;
  ldv_54595: ;
#line 789
  if (i <= 4) {
#line 791
    goto ldv_54594;
  } else {

  }
  ldv_54593: 
#line 792
  cx->nof_inputs = (u8 )i;
#line 793
  i = 0;
#line 793
  goto ldv_54598;
  ldv_54597: ;
#line 794
  if ((unsigned int )((unsigned char )(cx->card)->audio_inputs[i].audio_type) == 0U) {
#line 795
    goto ldv_54596;
  } else {

  }
#line 793
  i = i + 1;
  ldv_54598: ;
#line 793
  if (i <= 1) {
#line 795
    goto ldv_54597;
  } else {

  }
  ldv_54596: 
#line 796
  cx->nof_audio_inputs = (u8 )i;
#line 799
  i = 0;
#line 799
  goto ldv_54601;
  ldv_54600: ;
#line 800
  if ((unsigned int )((unsigned char )(cx->card)->video_inputs[i].video_type) == 1U) {
#line 802
    goto ldv_54599;
  } else {

  }
#line 799
  i = i + 1;
  ldv_54601: ;
#line 799
  if ((int )cx->nof_inputs > i) {
#line 801
    goto ldv_54600;
  } else {

  }
  ldv_54599: ;
#line 804
  if ((int )cx->nof_inputs == i) {
#line 805
    i = 0;
  } else {

  }
#line 806
  cx->active_input = (u32 )i;
#line 807
  cx->audio_input = (u32 )(cx->card)->video_inputs[i].audio_index;
#line 808
  return;
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cx18_setup_pci(struct cx18 *cx , struct pci_dev *pci_dev , struct pci_device_id  const  *pci_id ) 
{ 
  u16 cmd ;
  unsigned char pci_latency ;
  int tmp ;
  int tmp___0 ;
  struct resource *tmp___1 ;

  {
#line 816
  if ((cx18_debug & 2) != 0) {
#line 816
    printk("\016%s:  info: Enabling pci device\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 818
  tmp = pci_enable_device(pci_dev);
#line 818
  if (tmp != 0) {
#line 819
    printk("\v%s: Can\'t enable device %d!\n", (char *)(& cx->v4l2_dev.name), cx->instance);
#line 820
    return (-5);
  } else {

  }
#line 822
  tmp___0 = pci_set_dma_mask(pci_dev, 4294967295ULL);
#line 822
  if (tmp___0 != 0) {
#line 823
    printk("\v%s: No suitable DMA available, card %d\n", (char *)(& cx->v4l2_dev.name),
           cx->instance);
#line 824
    return (-5);
  } else {

  }
#line 826
  tmp___1 = __request_region(& iomem_resource, cx->base_addr, 67108864ULL, "cx18 encoder",
                             0);
#line 826
  if ((unsigned long )tmp___1 == (unsigned long )((struct resource *)0)) {
#line 827
    printk("\v%s: Cannot request encoder memory region, card %d\n", (char *)(& cx->v4l2_dev.name),
           cx->instance);
#line 829
    return (-5);
  } else {

  }
#line 833
  pci_read_config_word((struct pci_dev  const  *)pci_dev, 4, & cmd);
#line 834
  cmd = (u16 )((unsigned int )cmd | 6U);
#line 835
  pci_write_config_word((struct pci_dev  const  *)pci_dev, 4, (int )cmd);
#line 837
  cx->card_rev = pci_dev->revision;
#line 838
  pci_read_config_byte((struct pci_dev  const  *)pci_dev, 13, & pci_latency);
#line 840
  if ((unsigned int )pci_latency <= 63U && cx18_pci_latency != 0) {
#line 841
    printk("\016%s: Unreasonably low latency timer, setting to 64 (was %d)\n", (char *)(& cx->v4l2_dev.name),
           (int )pci_latency);
#line 843
    pci_write_config_byte((struct pci_dev  const  *)pci_dev, 13, 64);
#line 844
    pci_read_config_byte((struct pci_dev  const  *)pci_dev, 13, & pci_latency);
  } else {

  }
#line 847
  if ((cx18_debug & 2) != 0) {
#line 847
    printk("\016%s:  info: cx%d (rev %d) at %02x:%02x.%x, irq: %d, latency: %d, memory: 0x%llx\n",
           (char *)(& cx->v4l2_dev.name), (int )(cx->pci_dev)->device, (int )cx->card_rev,
           (int )(pci_dev->bus)->number, (pci_dev->devfn >> 3) & 31U, pci_dev->devfn & 7U,
           (cx->pci_dev)->irq, (int )pci_latency, cx->base_addr);
  } else {

  }
#line 853
  return (0);
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_init_subdevs(struct cx18 *cx ) 
{ 
  u32 hw ;
  u32 device ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 858
  hw = (cx->card)->hw_all;
#line 862
  i = 0;
#line 862
  device = 1U;
#line 862
  goto ldv_54624;
  ldv_54623: ;
#line 864
  if ((device & hw) == 0U) {
#line 865
    goto ldv_54615;
  } else {

  }
#line 867
  switch (device) {
  case 8U: ;
  case 2U: 
#line 871
  cx->hw_flags = cx->hw_flags | device;
#line 872
  goto ldv_54618;
  case 16U: 
#line 876
  cx->hw_flags = cx->hw_flags | device;
#line 877
  goto ldv_54618;
  case 64U: ;
#line 883
  goto ldv_54618;
  case 32U: 
#line 885
  tmp = cx18_gpio_register(cx, device);
#line 885
  if (tmp == 0) {
#line 886
    cx->hw_flags = cx->hw_flags | device;
  } else {

  }
#line 887
  goto ldv_54618;
  default: 
#line 889
  tmp___0 = cx18_i2c_register(cx, (unsigned int )i);
#line 889
  if (tmp___0 == 0) {
#line 890
    cx->hw_flags = cx->hw_flags | device;
  } else {

  }
#line 891
  goto ldv_54618;
  }
  ldv_54618: ;
  ldv_54615: 
#line 862
  i = i + 1;
#line 862
  device = device << 1;
  ldv_54624: ;
#line 862
  if (i <= 31) {
#line 864
    goto ldv_54623;
  } else {

  }

#line 895
  if ((cx->hw_flags & 16U) != 0U) {
#line 896
    cx->sd_av = cx18_find_hw(cx, 16U);
  } else {

  }
#line 898
  if ((unsigned int )(cx->card)->hw_muxer != 0U) {
#line 899
    cx->sd_extmux = cx18_find_hw(cx, (cx->card)->hw_muxer);
  } else {

  }
#line 900
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int cx18_probe(struct pci_dev *pci_dev , struct pci_device_id  const  *pci_id ) 
{ 
  int retval ;
  int i ;
  u32 devtype ;
  struct cx18 *cx ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct cx18_card  const  *orig_card ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct tuner_setup setup ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct xc2028_ctrl ctrl ;
  struct v4l2_priv_tun_config cfg ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 905
  retval = 0;
#line 911
  tmp = atomic_add_return(1, & cx18_instance);
#line 911
  i = tmp + -1;
#line 912
  if (i > 31) {
#line 913
    printk("\vcx18: cannot manage card %d, driver has a limit of 0 - %d\n", i, 31);
#line 915
    return (-12);
  } else {

  }
#line 918
  tmp___0 = kzalloc(48544UL, 32U);
#line 918
  cx = (struct cx18 *)tmp___0;
#line 919
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 920
    printk("\vcx18: cannot manage card %d, out of memory\n", i);
#line 922
    return (-12);
  } else {

  }
#line 924
  cx->pci_dev = pci_dev;
#line 925
  cx->instance = i;
#line 927
  retval = v4l2_device_register(& pci_dev->dev, & cx->v4l2_dev);
#line 928
  if (retval != 0) {
#line 929
    printk("\vcx18: v4l2_device_register of card %d failed\n", cx->instance);
#line 931
    kfree((void const   *)cx);
#line 932
    return (retval);
  } else {

  }
#line 934
  snprintf((char *)(& cx->v4l2_dev.name), 36UL, "cx18-%d", cx->instance);
#line 936
  printk("\016%s: Initializing card %d\n", (char *)(& cx->v4l2_dev.name), cx->instance);
#line 938
  cx18_process_options(cx);
#line 939
  if (cx->options.cardtype == -1) {
#line 940
    retval = -19;
#line 941
    goto err;
  } else {

  }
#line 944
  retval = cx18_init_struct1(cx);
#line 945
  if (retval != 0) {
#line 946
    goto err;
  } else {

  }
#line 948
  if ((cx18_debug & 2) != 0) {
#line 948
    printk("\016%s:  info: base addr: 0x%llx\n", (char *)(& cx->v4l2_dev.name), cx->base_addr);
  } else {

  }
#line 951
  retval = cx18_setup_pci(cx, pci_dev, pci_id);
#line 952
  if (retval != 0) {
#line 953
    goto free_workqueues;
  } else {

  }
#line 956
  if ((cx18_debug & 2) != 0) {
#line 956
    printk("\016%s:  info: attempting ioremap at 0x%llx len 0x%08x\n", (char *)(& cx->v4l2_dev.name),
           cx->base_addr, 67108864);
  } else {

  }
#line 958
  cx->enc_mem = ioremap_nocache(cx->base_addr, 67108864UL);
#line 960
  if ((unsigned long )cx->enc_mem == (unsigned long )((void *)0)) {
#line 961
    printk("\v%s: ioremap failed. Can\'t get a window into CX23418 memory and register space\n",
           (char *)(& cx->v4l2_dev.name));
#line 963
    printk("\v%s: Each capture card with a CX23418 needs 64 MB of vmalloc address space for the window\n",
           (char *)(& cx->v4l2_dev.name));
#line 965
    printk("\v%s: Check the output of \'grep Vmalloc /proc/meminfo\'\n", (char *)(& cx->v4l2_dev.name));
#line 966
    printk("\v%s: Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\n",
           (char *)(& cx->v4l2_dev.name));
#line 968
    retval = -12;
#line 969
    goto free_mem;
  } else {

  }
#line 971
  cx->reg_mem = cx->enc_mem + 33554432UL;
#line 972
  devtype = cx18_read_reg(cx, 13049896U);
#line 973
  switch (devtype & 4278190080U) {
  case 4278190080U: 
#line 975
  printk("\016%s: cx23418 revision %08x (A)\n", (char *)(& cx->v4l2_dev.name), devtype);
#line 976
  goto ldv_54638;
  case 16777216U: 
#line 978
  printk("\016%s: cx23418 revision %08x (B)\n", (char *)(& cx->v4l2_dev.name), devtype);
#line 979
  goto ldv_54638;
  default: 
#line 981
  printk("\016%s: cx23418 revision %08x (Unknown)\n", (char *)(& cx->v4l2_dev.name),
         devtype);
#line 982
  goto ldv_54638;
  }
  ldv_54638: 
#line 985
  cx18_init_power(cx, 1);
#line 986
  cx18_init_memory(cx);
#line 988
  cx->scb = (struct cx18_scb *)cx->enc_mem + 14417920U;
#line 989
  cx18_init_scb(cx);
#line 991
  cx18_gpio_init(cx);
#line 994
  retval = cx18_av_probe(cx);
#line 995
  if (retval != 0) {
#line 996
    printk("\v%s: Could not register A/V decoder subdevice\n", (char *)(& cx->v4l2_dev.name));
#line 997
    goto free_map;
  } else {

  }
#line 1001
  if (((unsigned int )(cx->card)->hw_all & 64U) != 0U) {
#line 1002
    tmp___1 = cx18_gpio_register(cx, 64U);
#line 1002
    if (tmp___1 != 0) {
#line 1003
      printk("\f%s: Could not register GPIO reset controllersubdevice; proceeding anyway.\n",
             (char *)(& cx->v4l2_dev.name));
    } else {
#line 1006
      cx->hw_flags = cx->hw_flags | 64U;
    }
  } else {

  }
#line 1010
  if ((cx18_debug & 2) != 0) {
#line 1010
    printk("\016%s:  info: activating i2c...\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1011
  retval = init_cx18_i2c(cx);
#line 1012
  if (retval != 0) {
#line 1013
    printk("\v%s: Could not initialize i2c\n", (char *)(& cx->v4l2_dev.name));
#line 1014
    goto free_map;
  } else {

  }
#line 1017
  if (((unsigned int )(cx->card)->hw_all & 2U) != 0U) {
#line 1020
    orig_card = cx->card;
#line 1021
    cx18_process_eeprom(cx);
#line 1023
    if ((unsigned long )cx->card != (unsigned long )orig_card) {
#line 1025
      cx18_gpio_init(cx);
#line 1026
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1026
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1026
      goto ldv_54649;
      ldv_54648: ;
#line 1026
      if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                             u32  ))0)) {
#line 1026
        (*(((__sd->ops)->core)->reset))(__sd, 0U);
      } else {

      }
#line 1026
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1026
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_54649: ;
#line 1026
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1028
        goto ldv_54648;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1030
  if ((unsigned long )(cx->card)->comment != (unsigned long )((char */* const  */)0)) {
#line 1031
    printk("\016%s: %s", (char *)(& cx->v4l2_dev.name), (cx->card)->comment);
  } else {

  }
#line 1032
  if ((unsigned int )(cx->card)->v4l2_capabilities == 0U) {
#line 1033
    retval = -19;
#line 1034
    goto free_i2c;
  } else {

  }
#line 1036
  cx18_init_memory(cx);
#line 1037
  cx18_init_scb(cx);
#line 1040
  retval = ldv_request_irq_22((cx->pci_dev)->irq, & cx18_irq_handler, 128UL, (char const   *)(& cx->v4l2_dev.name),
                              (void *)cx);
#line 1042
  if (retval != 0) {
#line 1043
    printk("\v%s: Failed to register irq %d\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1044
    goto free_i2c;
  } else {

  }
#line 1047
  if (cx->std == 0ULL) {
#line 1048
    cx->std = 4096ULL;
  } else {

  }
#line 1050
  if (cx->options.tuner == -1) {
#line 1051
    i = 0;
#line 1051
    goto ldv_54655;
    ldv_54654: ;
#line 1052
    if ((cx->std & (unsigned long long )(cx->card)->tuners[i].std) == 0ULL) {
#line 1053
      goto ldv_54652;
    } else {

    }
#line 1054
    cx->options.tuner = (cx->card)->tuners[i].tuner;
#line 1055
    goto ldv_54653;
    ldv_54652: 
#line 1051
    i = i + 1;
    ldv_54655: ;
#line 1051
    if (i <= 1) {
#line 1053
      goto ldv_54654;
    } else {

    }
    ldv_54653: ;
  } else {

  }
#line 1059
  if (cx->options.tuner == -1 && (unsigned long long )(cx->card)->tuners[0].std != 0ULL) {
#line 1060
    cx->std = (cx->card)->tuners[0].std;
#line 1061
    if ((cx->std & 255ULL) != 0ULL) {
#line 1062
      cx->std = 15ULL;
    } else
#line 1063
    if ((cx->std & 45056ULL) != 0ULL) {
#line 1064
      cx->std = 4096ULL;
    } else
#line 1065
    if ((cx->std & 16711680ULL) != 0ULL) {
#line 1066
      cx->std = 4194304ULL;
    } else {

    }
#line 1067
    cx->options.tuner = (cx->card)->tuners[0].tuner;
  } else {

  }
#line 1069
  if (cx->options.radio == -1) {
#line 1070
    cx->options.radio = (unsigned int )((unsigned char )(cx->card)->radio_input.audio_type) != 0U;
  } else {

  }
#line 1074
  cx18_init_struct2(cx);
#line 1076
  cx18_init_subdevs(cx);
#line 1078
  if ((cx->std & 63744ULL) != 0ULL) {
#line 1079
    cx->is_60hz = 1U;
  } else {
#line 1081
    cx->is_50hz = 1U;
  }
#line 1083
  cx2341x_handler_set_50hz(& cx->cxhdl, (unsigned int )cx->is_60hz == 0U);
#line 1085
  if (cx->options.radio > 0) {
#line 1086
    cx->v4l2_cap = cx->v4l2_cap | 262144U;
  } else {

  }
#line 1088
  if (cx->options.tuner >= 0) {
#line 1091
    setup.addr = 255U;
#line 1092
    setup.type = (unsigned int )cx->options.tuner;
#line 1093
    setup.mode_mask = 4U;
#line 1094
    setup.config = (void *)0;
#line 1095
    if (cx->options.radio > 0) {
#line 1096
      setup.mode_mask = setup.mode_mask | 2U;
    } else {

    }
#line 1097
    setup.tuner_callback = setup.type == 71U ? & cx18_reset_tuner_gpio : (int (*)(void * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  int  ))0;
#line 1099
    __mptr___1 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1099
    __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 1099
    goto ldv_54663;
    ldv_54662: ;
#line 1099
    if ((unsigned long )(__sd___0->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->tuner)->s_type_addr != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct tuner_setup * ))0)) {
#line 1099
      (*(((__sd___0->ops)->tuner)->s_type_addr))(__sd___0, & setup);
    } else {

    }
#line 1099
    __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1099
    __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
    ldv_54663: ;
#line 1099
    if ((unsigned long )(& __sd___0->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1101
      goto ldv_54662;
    } else {

    }

#line 1100
    if (setup.type == 71U) {
#line 1101
      ctrl.fname = (char *)"xc3028-v27.fw";
#line 1101
      ctrl.max_len = 64;
#line 1101
      ctrl.msleep = 0;
#line 1101
      ctrl.scode_table = 0U;
#line 1101
      ctrl.mts = (unsigned char)0;
#line 1101
      ctrl.input1 = (unsigned char)0;
#line 1101
      ctrl.vhfbw7 = (unsigned char)0;
#line 1101
      ctrl.uhfbw8 = (unsigned char)0;
#line 1101
      ctrl.disable_power_mgmt = (unsigned char)0;
#line 1101
      ctrl.read_not_reliable = (unsigned char)0;
#line 1101
      ctrl.demod = 0U;
#line 1101
      ctrl.type = (unsigned char)0;
#line 1105
      cfg.tuner = cx->options.tuner;
#line 1105
      cfg.priv = (void *)(& ctrl);
#line 1109
      __mptr___3 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1109
      __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff88UL;
#line 1109
      goto ldv_54673;
      ldv_54672: ;
#line 1109
      if ((unsigned long )(__sd___1->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___1->ops)->tuner)->s_config != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_priv_tun_config  const  * ))0)) {
#line 1109
        (*(((__sd___1->ops)->tuner)->s_config))(__sd___1, (struct v4l2_priv_tun_config  const  *)(& cfg));
      } else {

      }
#line 1109
      __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 1109
      __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff88UL;
      ldv_54673: ;
#line 1109
      if ((unsigned long )(& __sd___1->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1111
        goto ldv_54672;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1115
  cx->tuner_std = cx->std;
#line 1116
  if (cx->std == 16777215ULL) {
#line 1117
    cx->std = 4096ULL;
  } else {

  }
#line 1119
  retval = cx18_streams_setup(cx);
#line 1120
  if (retval != 0) {
#line 1121
    printk("\v%s: Error %d setting up streams\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1122
    goto free_irq;
  } else {

  }
#line 1124
  retval = cx18_streams_register(cx);
#line 1125
  if (retval != 0) {
#line 1126
    printk("\v%s: Error %d registering devices\n", (char *)(& cx->v4l2_dev.name),
           retval);
#line 1127
    goto free_streams;
  } else {

  }
#line 1130
  printk("\016%s: Initialized card: %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 1133
  request_modules(cx);
#line 1134
  return (0);
  free_streams: 
#line 1137
  cx18_streams_cleanup(cx, 1);
  free_irq: 
#line 1139
  ldv_free_irq_23((cx->pci_dev)->irq, (void *)cx);
  free_i2c: 
#line 1141
  exit_cx18_i2c(cx);
  free_map: 
#line 1143
  cx18_iounmap(cx);
  free_mem: 
#line 1145
  __release_region(& iomem_resource, cx->base_addr, 67108864ULL);
  free_workqueues: 
#line 1147
  ldv_destroy_workqueue_24(cx->in_work_queue);
  err: ;
#line 1149
  if (retval == 0) {
#line 1150
    retval = -19;
  } else {

  }
#line 1151
  printk("\v%s: Error %d on initialization\n", (char *)(& cx->v4l2_dev.name), retval);
#line 1153
  v4l2_device_unregister(& cx->v4l2_dev);
#line 1154
  kfree((void const   *)cx);
#line 1155
  return (retval);
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
int cx18_init_on_first_open(struct cx18 *cx ) 
{ 
  int video_input ;
  int fw_retry_count ;
  struct v4l2_frequency vf ;
  struct cx18_open_id fh ;
  v4l2_std_id std ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1161
  fw_retry_count = 3;
#line 1166
  fh.cx = cx;
#line 1168
  tmp = constant_test_bit(22L, (unsigned long const volatile   *)(& cx->i_flags));
#line 1168
  if (tmp != 0) {
#line 1169
    return (-6);
  } else {

  }
#line 1171
  tmp___0 = test_and_set_bit(21L, (unsigned long volatile   *)(& cx->i_flags));
#line 1171
  if (tmp___0 != 0) {
#line 1172
    return (0);
  } else {

  }
#line 1174
  goto ldv_54687;
  ldv_54686: 
#line 1176
  tmp___1 = cx18_firmware_init(cx);
#line 1176
  if (tmp___1 == 0) {
#line 1177
    goto ldv_54685;
  } else {

  }
#line 1178
  if (fw_retry_count > 1) {
#line 1179
    printk("\f%s: Retry loading firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
  ldv_54687: 
#line 1174
  fw_retry_count = fw_retry_count - 1;
#line 1174
  if (fw_retry_count > 0) {
#line 1176
    goto ldv_54686;
  } else {

  }
  ldv_54685: ;
#line 1182
  if (fw_retry_count == 0) {
#line 1183
    set_bit(22L, (unsigned long volatile   *)(& cx->i_flags));
#line 1184
    return (-6);
  } else {

  }
#line 1186
  set_bit(0L, (unsigned long volatile   *)(& cx->i_flags));
#line 1200
  cx18_vapi(cx, 268435457U, 2, 185, 0);
#line 1201
  cx18_vapi(cx, 268435461U, 0);
#line 1202
  cx18_vapi(cx, 268435458U, 1, 0);
#line 1204
  fw_retry_count = 3;
#line 1205
  goto ldv_54690;
  ldv_54689: 
#line 1207
  tmp___2 = cx18_firmware_init(cx);
#line 1207
  if (tmp___2 == 0) {
#line 1208
    goto ldv_54688;
  } else {

  }
#line 1209
  if (fw_retry_count > 1) {
#line 1210
    printk("\f%s: Retry loading firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
  ldv_54690: 
#line 1205
  fw_retry_count = fw_retry_count - 1;
#line 1205
  if (fw_retry_count > 0) {
#line 1207
    goto ldv_54689;
  } else {

  }
  ldv_54688: ;
#line 1213
  if (fw_retry_count == 0) {
#line 1214
    set_bit(22L, (unsigned long volatile   *)(& cx->i_flags));
#line 1215
    return (-6);
  } else {

  }
#line 1227
  cx18_vapi(cx, 268435457U, 2, 185, 0);
#line 1228
  cx18_vapi(cx, 268435461U, 0);
#line 1229
  cx18_vapi(cx, 268435458U, 1, 0);
#line 1232
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 1232
    if ((unsigned long )((cx->sd_av)->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->core)->load_fw != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1232
      (*((((cx->sd_av)->ops)->core)->load_fw))(cx->sd_av);
    } else {

    }
  } else {

  }
#line 1234
  vf.tuner = 0U;
#line 1235
  vf.type = 2U;
#line 1236
  vf.frequency = 6400U;
#line 1240
  if (cx->std == 8192ULL) {
#line 1241
    vf.frequency = 1460U;
  } else
#line 1242
  if ((cx->std & 4096ULL) != 0ULL) {
#line 1243
    vf.frequency = 1076U;
  } else {

  }
#line 1245
  video_input = (int )cx->active_input;
#line 1246
  cx->active_input = cx->active_input + 1U;
#line 1247
  cx18_s_input((struct file *)0, (void *)(& fh), (unsigned int )video_input);
#line 1251
  cx->std = cx->std + 1ULL;
#line 1252
  std = cx->tuner_std != 16777215ULL ? cx->tuner_std : 4096ULL;
#line 1253
  cx18_s_std((struct file *)0, (void *)(& fh), std);
#line 1254
  cx18_s_frequency((struct file *)0, (void *)(& fh), (struct v4l2_frequency  const  *)(& vf));
#line 1255
  return (0);
}
}
#line 1258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_cancel_in_work_orders(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 1261
  i = 0;
#line 1261
  goto ldv_54696;
  ldv_54695: 
#line 1262
  ldv_cancel_work_sync_25(& cx->in_work_order[i].work);
#line 1261
  i = i + 1;
  ldv_54696: ;
#line 1261
  if (i <= 69) {
#line 1263
    goto ldv_54695;
  } else {

  }

#line 1268
  return;
}
}
#line 1265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_cancel_out_work_orders(struct cx18 *cx ) 
{ 
  int i ;

  {
#line 1268
  i = 0;
#line 1268
  goto ldv_54703;
  ldv_54702: ;
#line 1269
  if ((unsigned long )(& cx->streams[i].video_dev) != (unsigned long )((struct video_device *)0)) {
#line 1270
    ldv_cancel_work_sync_26(& cx->streams[i].out_work_order);
  } else {

  }
#line 1268
  i = i + 1;
  ldv_54703: ;
#line 1268
  if (i <= 6) {
#line 1270
    goto ldv_54702;
  } else {

  }

#line 1275
  return;
}
}
#line 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void cx18_remove(struct pci_dev *pci_dev ) 
{ 
  struct v4l2_device *v4l2_dev ;
  void *tmp ;
  struct cx18 *cx ;
  struct cx18 *tmp___0 ;
  int i ;
  int tmp___1 ;

  {
#line 1275
  tmp = pci_get_drvdata(pci_dev);
#line 1275
  v4l2_dev = (struct v4l2_device *)tmp;
#line 1276
  tmp___0 = to_cx18(v4l2_dev);
#line 1276
  cx = tmp___0;
#line 1279
  if ((cx18_debug & 2) != 0) {
#line 1279
    printk("\016%s:  info: Removing Card\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1281
  flush_request_modules(cx);
#line 1284
  if ((cx18_debug & 2) != 0) {
#line 1284
    printk("\016%s:  info: Stopping all streams\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1285
  tmp___1 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1285
  if (tmp___1 > 0) {
#line 1286
    cx18_stop_all_captures(cx);
  } else {

  }
#line 1289
  cx18_sw1_irq_disable(cx, 196608U);
#line 1292
  cx18_cancel_in_work_orders(cx);
#line 1293
  cx18_cancel_out_work_orders(cx);
#line 1296
  cx18_sw2_irq_disable(cx, 136U);
#line 1298
  cx18_halt_firmware(cx);
#line 1300
  ldv_destroy_workqueue_27(cx->in_work_queue);
#line 1302
  cx18_streams_cleanup(cx, 1);
#line 1304
  exit_cx18_i2c(cx);
#line 1306
  ldv_free_irq_28((cx->pci_dev)->irq, (void *)cx);
#line 1308
  cx18_iounmap(cx);
#line 1310
  __release_region(& iomem_resource, cx->base_addr, 67108864ULL);
#line 1312
  pci_disable_device(cx->pci_dev);
#line 1314
  if ((unsigned long )cx->vbi.sliced_mpeg_data[0] != (unsigned long )((u8 *)0U)) {
#line 1315
    i = 0;
#line 1315
    goto ldv_54712;
    ldv_54711: 
#line 1316
    kfree((void const   *)cx->vbi.sliced_mpeg_data[i]);
#line 1315
    i = i + 1;
    ldv_54712: ;
#line 1315
    if (i <= 31) {
#line 1317
      goto ldv_54711;
    } else {

    }

  } else {

  }
#line 1318
  v4l2_ctrl_handler_free(& cx->av_state.hdl);
#line 1320
  printk("\016%s: Removed %s\n", (char *)(& cx->v4l2_dev.name), cx->card_name);
#line 1322
  v4l2_device_unregister(v4l2_dev);
#line 1323
  kfree((void const   *)cx);
#line 1324
  return;
}
}
#line 1328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static struct pci_driver cx18_pci_driver  = 
#line 1328
     {{0, 0}, "cx18", (struct pci_device_id  const  *)(& cx18_pci_tbl), & cx18_probe,
    & cx18_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                         0, 0, 0, 0}, {{{{{{0}}, 0U, 0U, 0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}}}},
                                                       {0, 0}}};
#line 1335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static int module_start(void) 
{ 
  int tmp ;

  {
#line 1337
  printk("\016cx18:  Start initialization, version %s\n", (char *)"1.5.1");
#line 1341
  if (cx18_first_minor < 0 || cx18_first_minor > 31) {
#line 1342
    printk("\vcx18:  Exiting, cx18_first_minor must be between 0 and %d\n", 31);
#line 1344
    return (-1);
  } else {

  }
#line 1347
  if (cx18_debug < 0 || cx18_debug > 511) {
#line 1348
    cx18_debug = 0;
#line 1349
    printk("\016cx18:   Debug value must be >= 0 and <= 511!\n");
  } else {

  }
#line 1352
  tmp = ldv___pci_register_driver_29(& cx18_pci_driver, & __this_module, "cx18");
#line 1352
  if (tmp != 0) {
#line 1353
    printk("\vcx18:   Error detecting PCI card\n");
#line 1354
    return (-19);
  } else {

  }
#line 1356
  printk("\016cx18:  End initialization\n");
#line 1357
  return (0);
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.c"
static void module_cleanup(void) 
{ 


  {
#line 1362
  ldv_pci_unregister_driver_30(& cx18_pci_driver);
#line 1363
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
extern void ldv_initialize(void) ;
#line 271
void ldv_check_final_state(void) ;
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_retval_3  ;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_retval_2  ;
#line 274
extern int ldv_shutdown_25(void) ;
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 278
  ldv_work_3_0 = 0;
#line 279
  ldv_work_3_1 = 0;
#line 280
  ldv_work_3_2 = 0;
#line 281
  ldv_work_3_3 = 0;
#line 282
  return;
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 286
  ldv_work_2_0 = 0;
#line 287
  ldv_work_2_1 = 0;
#line 288
  ldv_work_2_2 = 0;
#line 289
  ldv_work_2_3 = 0;
#line 290
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 295
  if (ldv_work_2_0 == state) {
#line 296
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 297
  if (ldv_work_2_1 == state) {
#line 298
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 299
  if (ldv_work_2_2 == state) {
#line 300
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 301
  if (ldv_work_2_3 == state) {
#line 302
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 303
  return;
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 307
  if ((unsigned long )handler == (unsigned long )(& cx18_irq_handler)) {
#line 308
    return (1);
  } else {

  }
#line 310
  return (0);
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 315
  if (ldv_work_2_0 == 0) {
#line 316
    ldv_work_struct_2_0 = work;
#line 317
    ldv_work_2_0 = state;
#line 318
    return;
  } else {

  }
#line 321
  if (ldv_work_2_1 == 0) {
#line 322
    ldv_work_struct_2_1 = work;
#line 323
    ldv_work_2_1 = state;
#line 324
    return;
  } else {

  }
#line 327
  if (ldv_work_2_2 == 0) {
#line 328
    ldv_work_struct_2_2 = work;
#line 329
    ldv_work_2_2 = state;
#line 330
    return;
  } else {

  }
#line 333
  if (ldv_work_2_3 == 0) {
#line 334
    ldv_work_struct_2_3 = work;
#line 335
    ldv_work_2_3 = state;
#line 336
    return;
  } else {

  }
#line 338
  return;
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 342
  if (ldv_work_3_0 == 0) {
#line 343
    ldv_work_struct_3_0 = work;
#line 344
    ldv_work_3_0 = state;
#line 345
    return;
  } else {

  }
#line 348
  if (ldv_work_3_1 == 0) {
#line 349
    ldv_work_struct_3_1 = work;
#line 350
    ldv_work_3_1 = state;
#line 351
    return;
  } else {

  }
#line 354
  if (ldv_work_3_2 == 0) {
#line 355
    ldv_work_struct_3_2 = work;
#line 356
    ldv_work_3_2 = state;
#line 357
    return;
  } else {

  }
#line 360
  if (ldv_work_3_3 == 0) {
#line 361
    ldv_work_struct_3_3 = work;
#line 362
    ldv_work_3_3 = state;
#line 363
    return;
  } else {

  }
#line 365
  return;
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 369
  tmp = __VERIFIER_nondet_int();
#line 369
  switch (tmp) {
  case 0: 
#line 371
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 373
  goto ldv_54766;
  case 1: 
#line 375
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 377
  goto ldv_54766;
  case 2: 
#line 379
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 381
  goto ldv_54766;
  case 3: 
#line 383
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 385
  goto ldv_54766;
  default: 
#line 386
  ldv_stop();
  }
  ldv_54766: ;
#line 388
  return;
}
}
#line 392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 395
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 397
    cx18_in_work_handler(work);
#line 398
    ldv_work_3_0 = 1;
#line 399
    return;
  } else {

  }
#line 401
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 403
    cx18_in_work_handler(work);
#line 404
    ldv_work_3_1 = 1;
#line 405
    return;
  } else {

  }
#line 407
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 409
    cx18_in_work_handler(work);
#line 410
    ldv_work_3_2 = 1;
#line 411
    return;
  } else {

  }
#line 413
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 415
    cx18_in_work_handler(work);
#line 416
    ldv_work_3_3 = 1;
#line 417
    return;
  } else {

  }
#line 419
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_pci_driver_25(void) 
{ 
  void *tmp ;

  {
#line 423
  tmp = ldv_init_zalloc(2976UL);
#line 423
  cx18_pci_driver_group1 = (struct pci_dev *)tmp;
#line 424
  return;
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 429
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 431
    ldv_work_3_0 = 1;
  } else {

  }
#line 433
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 435
    ldv_work_3_1 = 1;
  } else {

  }
#line 437
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 439
    ldv_work_3_2 = 1;
  } else {

  }
#line 441
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 443
    ldv_work_3_3 = 1;
  } else {

  }
#line 444
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 450
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 452
    ldv_work_2_0 = 1;
  } else {

  }
#line 454
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 456
    ldv_work_2_1 = 1;
  } else {

  }
#line 458
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 460
    ldv_work_2_2 = 1;
  } else {

  }
#line 462
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 464
    ldv_work_2_3 = 1;
  } else {

  }
#line 465
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 471
  tmp = __VERIFIER_nondet_int();
#line 471
  switch (tmp) {
  case 0: ;
#line 473
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 474
    ldv_work_3_0 = 4;
#line 475
    cx18_in_work_handler(ldv_work_struct_3_0);
#line 476
    ldv_work_3_0 = 1;
  } else {

  }
#line 479
  goto ldv_54791;
  case 1: ;
#line 481
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 482
    ldv_work_3_1 = 4;
#line 483
    cx18_in_work_handler(ldv_work_struct_3_0);
#line 484
    ldv_work_3_1 = 1;
  } else {

  }
#line 487
  goto ldv_54791;
  case 2: ;
#line 489
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 490
    ldv_work_3_2 = 4;
#line 491
    cx18_in_work_handler(ldv_work_struct_3_0);
#line 492
    ldv_work_3_2 = 1;
  } else {

  }
#line 495
  goto ldv_54791;
  case 3: ;
#line 497
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 498
    ldv_work_3_3 = 4;
#line 499
    cx18_in_work_handler(ldv_work_struct_3_0);
#line 500
    ldv_work_3_3 = 1;
  } else {

  }
#line 503
  goto ldv_54791;
  default: 
#line 504
  ldv_stop();
  }
  ldv_54791: ;
#line 506
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 511
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 512
    ldv_irq_1_0 = 0;
#line 513
    return;
  } else {

  }
#line 515
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 516
    ldv_irq_1_1 = 0;
#line 517
    return;
  } else {

  }
#line 519
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 520
    ldv_irq_1_2 = 0;
#line 521
    return;
  } else {

  }
#line 523
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 524
    ldv_irq_1_3 = 0;
#line 525
    return;
  } else {

  }
#line 527
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 533
  tmp = __VERIFIER_nondet_int();
#line 533
  irq_retval = (irqreturn_t )tmp;
#line 535
  if (state != 0) {
#line 536
    tmp___0 = __VERIFIER_nondet_int();
#line 536
    switch (tmp___0) {
    case 0: ;
#line 538
    if (state == 1) {
#line 539
      LDV_IN_INTERRUPT = 2;
#line 540
      irq_retval = cx18_irq_handler(line, data);
#line 541
      LDV_IN_INTERRUPT = 1;
#line 542
      return (state);
    } else {

    }
#line 545
    goto ldv_54807;
    default: 
#line 546
    ldv_stop();
    }
    ldv_54807: ;
  } else {

  }
#line 549
  return (state);
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 554
  if (ldv_irq_1_0 == 0) {
#line 555
    ldv_irq_line_1_0 = line;
#line 556
    ldv_irq_data_1_0 = data;
#line 557
    ldv_irq_1_0 = 1;
#line 558
    return;
  } else {

  }
#line 560
  if (ldv_irq_1_1 == 0) {
#line 561
    ldv_irq_line_1_1 = line;
#line 562
    ldv_irq_data_1_1 = data;
#line 563
    ldv_irq_1_1 = 1;
#line 564
    return;
  } else {

  }
#line 566
  if (ldv_irq_1_2 == 0) {
#line 567
    ldv_irq_line_1_2 = line;
#line 568
    ldv_irq_data_1_2 = data;
#line 569
    ldv_irq_1_2 = 1;
#line 570
    return;
  } else {

  }
#line 572
  if (ldv_irq_1_3 == 0) {
#line 573
    ldv_irq_line_1_3 = line;
#line 574
    ldv_irq_data_1_3 = data;
#line 575
    ldv_irq_1_3 = 1;
#line 576
    return;
  } else {

  }
#line 578
  return;
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 585
  if (ldv_work_3_0 == state) {
#line 586
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 587
  if (ldv_work_3_1 == state) {
#line 588
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 589
  if (ldv_work_3_2 == state) {
#line 590
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 591
  if (ldv_work_3_3 == state) {
#line 592
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 593
  return;
}
}
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 599
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 601
    request_module_async(work);
#line 602
    ldv_work_2_0 = 1;
#line 603
    return;
  } else {

  }
#line 605
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 607
    request_module_async(work);
#line 608
    ldv_work_2_1 = 1;
#line 609
    return;
  } else {

  }
#line 611
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 613
    request_module_async(work);
#line 614
    ldv_work_2_2 = 1;
#line 615
    return;
  } else {

  }
#line 617
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 619
    request_module_async(work);
#line 620
    ldv_work_2_3 = 1;
#line 621
    return;
  } else {

  }
#line 623
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 628
  tmp = __VERIFIER_nondet_int();
#line 628
  switch (tmp) {
  case 0: ;
#line 630
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 631
    ldv_work_2_0 = 4;
#line 632
    request_module_async(ldv_work_struct_2_0);
#line 633
    ldv_work_2_0 = 1;
  } else {

  }
#line 636
  goto ldv_54829;
  case 1: ;
#line 638
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 639
    ldv_work_2_1 = 4;
#line 640
    request_module_async(ldv_work_struct_2_0);
#line 641
    ldv_work_2_1 = 1;
  } else {

  }
#line 644
  goto ldv_54829;
  case 2: ;
#line 646
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 647
    ldv_work_2_2 = 4;
#line 648
    request_module_async(ldv_work_struct_2_0);
#line 649
    ldv_work_2_2 = 1;
  } else {

  }
#line 652
  goto ldv_54829;
  case 3: ;
#line 654
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 655
    ldv_work_2_3 = 4;
#line 656
    request_module_async(ldv_work_struct_2_0);
#line 657
    ldv_work_2_3 = 1;
  } else {

  }
#line 660
  goto ldv_54829;
  default: 
#line 661
  ldv_stop();
  }
  ldv_54829: ;
#line 663
  return;
}
}
#line 668
void ldv_main_exported_15(void) ;
#line 669
void ldv_main_exported_18(void) ;
#line 670
void ldv_main_exported_17(void) ;
#line 671
void ldv_main_exported_7(void) ;
#line 674
void ldv_main_exported_6(void) ;
#line 675
void ldv_main_exported_8(void) ;
#line 676
void ldv_main_exported_11(void) ;
#line 677
void ldv_main_exported_13(void) ;
#line 678
void ldv_main_exported_10(void) ;
#line 679
void ldv_main_exported_9(void) ;
#line 680
void ldv_main_exported_12(void) ;
#line 681
void ldv_main_exported_14(void) ;
#line 682
void ldv_main_exported_22(void) ;
#line 683
void ldv_main_exported_21(void) ;
#line 684
void ldv_main_exported_23(void) ;
#line 685
void ldv_main_exported_19(void) ;
#line 686
void ldv_main_exported_20(void) ;
#line 687
void ldv_main_exported_16(void) ;
#line 688
void ldv_main_exported_24(void) ;
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int main(void) 
{ 
  struct pci_device_id *ldvarg87 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 695
  tmp = ldv_init_zalloc(32UL);
#line 695
  ldvarg87 = (struct pci_device_id *)tmp;
#line 693
  ldv_initialize();
#line 697
  ldv_state_variable_11 = 0;
#line 698
  ldv_state_variable_21 = 0;
#line 699
  ldv_state_variable_7 = 0;
#line 700
  ldv_state_variable_17 = 0;
#line 702
  work_init_2();
#line 704
  ldv_state_variable_2 = 1;
#line 705
  ldv_state_variable_22 = 0;
#line 707
  ldv_state_variable_1 = 1;
#line 708
  ldv_state_variable_18 = 0;
#line 709
  ref_cnt = 0;
#line 710
  ldv_state_variable_0 = 1;
#line 711
  ldv_state_variable_23 = 0;
#line 712
  ldv_state_variable_16 = 0;
#line 713
  ldv_state_variable_13 = 0;
#line 714
  ldv_state_variable_25 = 0;
#line 715
  ldv_state_variable_6 = 0;
#line 717
  work_init_3();
#line 719
  ldv_state_variable_3 = 1;
#line 720
  ldv_state_variable_9 = 0;
#line 721
  ldv_state_variable_12 = 0;
#line 722
  ldv_state_variable_20 = 0;
#line 723
  ldv_state_variable_14 = 0;
#line 724
  ldv_state_variable_15 = 0;
#line 725
  ldv_state_variable_8 = 0;
#line 727
  work_init_4();
#line 729
  ldv_state_variable_4 = 1;
#line 730
  ldv_state_variable_24 = 0;
#line 731
  ldv_state_variable_19 = 0;
#line 732
  ldv_state_variable_10 = 0;
#line 734
  ldv_state_variable_5 = 1;
  ldv_54918: 
#line 736
  tmp___0 = __VERIFIER_nondet_int();
#line 736
  switch (tmp___0) {
  case 0: ;
#line 740
  if (ldv_state_variable_11 != 0) {
#line 741
    ldv_main_exported_11();
  } else {

  }
#line 744
  goto ldv_54881;
  case 1: ;
#line 748
  if (ldv_state_variable_21 != 0) {
#line 749
    ldv_main_exported_21();
  } else {

  }
#line 752
  goto ldv_54881;
  case 2: ;
#line 756
  if (ldv_state_variable_7 != 0) {
#line 757
    ldv_main_exported_7();
  } else {

  }
#line 760
  goto ldv_54881;
  case 3: ;
#line 764
  if (ldv_state_variable_17 != 0) {
#line 765
    ldv_main_exported_17();
  } else {

  }
#line 768
  goto ldv_54881;
  case 4: ;
#line 772
  if (ldv_state_variable_2 != 0) {
#line 773
    invoke_work_2();
  } else {

  }
#line 776
  goto ldv_54881;
  case 5: ;
#line 780
  if (ldv_state_variable_22 != 0) {
#line 781
    ldv_main_exported_22();
  } else {

  }
#line 784
  goto ldv_54881;
  case 6: ;
#line 788
  if (ldv_state_variable_1 != 0) {
#line 789
    choose_interrupt_1();
  } else {

  }
#line 792
  goto ldv_54881;
  case 7: ;
#line 796
  if (ldv_state_variable_18 != 0) {
#line 797
    ldv_main_exported_18();
  } else {

  }
#line 800
  goto ldv_54881;
  case 8: ;
#line 804
  if (ldv_state_variable_0 != 0) {
#line 805
    tmp___1 = __VERIFIER_nondet_int();
#line 805
    switch (tmp___1) {
    case 0: ;
#line 808
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 810
      module_cleanup();
#line 811
      ldv_state_variable_0 = 3;
#line 812
      goto ldv_final;
    } else {

    }
#line 815
    goto ldv_54892;
    case 1: ;
#line 818
    if (ldv_state_variable_0 == 1) {
#line 820
      ldv_retval_2 = module_start();
#line 821
      if (ldv_retval_2 != 0) {
#line 822
        ldv_state_variable_0 = 3;
#line 823
        goto ldv_final;
      } else {

      }
#line 826
      if (ldv_retval_2 == 0) {
#line 827
        ldv_state_variable_0 = 2;
#line 828
        ldv_state_variable_19 = 1;
#line 829
        ldv_initialize_v4l2_subdev_core_ops_19();
#line 830
        ldv_state_variable_10 = 1;
#line 831
        ldv_initialize_v4l2_subdev_video_ops_10();
#line 832
        ldv_state_variable_24 = 1;
#line 833
        ldv_state_variable_8 = 1;
#line 834
        ldv_state_variable_20 = 1;
#line 835
        ldv_state_variable_15 = 1;
#line 836
        ldv_initialize_cx2341x_handler_ops_15();
#line 837
        ldv_state_variable_14 = 1;
#line 838
        ldv_state_variable_12 = 1;
#line 839
        ldv_initialize_v4l2_subdev_tuner_ops_12();
#line 840
        ldv_state_variable_9 = 1;
#line 841
        ldv_initialize_v4l2_subdev_vbi_ops_9();
#line 842
        ldv_state_variable_6 = 1;
#line 843
        ldv_state_variable_13 = 1;
#line 844
        ldv_initialize_v4l2_subdev_core_ops_13();
#line 845
        ldv_state_variable_16 = 1;
#line 846
        ldv_initialize_v4l2_ioctl_ops_16();
#line 847
        ldv_state_variable_23 = 1;
#line 848
        ldv_state_variable_18 = 1;
#line 849
        ldv_initialize_v4l2_file_operations_18();
#line 850
        ldv_state_variable_22 = 1;
#line 851
        ldv_state_variable_17 = 1;
#line 852
        ldv_videobuf_queue_ops_17();
#line 853
        ldv_state_variable_7 = 1;
#line 854
        ldv_state_variable_21 = 1;
#line 855
        ldv_state_variable_11 = 1;
#line 856
        ldv_initialize_v4l2_subdev_audio_ops_11();
      } else {

      }
    } else {

    }
#line 860
    goto ldv_54892;
    default: 
#line 861
    ldv_stop();
    }
    ldv_54892: ;
  } else {

  }
#line 865
  goto ldv_54881;
  case 9: ;
#line 869
  if (ldv_state_variable_23 != 0) {
#line 870
    ldv_main_exported_23();
  } else {

  }
#line 873
  goto ldv_54881;
  case 10: ;
#line 877
  if (ldv_state_variable_16 != 0) {
#line 878
    ldv_main_exported_16();
  } else {

  }
#line 881
  goto ldv_54881;
  case 11: ;
#line 885
  if (ldv_state_variable_13 != 0) {
#line 886
    ldv_main_exported_13();
  } else {

  }
#line 889
  goto ldv_54881;
  case 12: ;
#line 893
  if (ldv_state_variable_25 != 0) {
#line 894
    tmp___2 = __VERIFIER_nondet_int();
#line 894
    switch (tmp___2) {
    case 0: ;
#line 897
    if (ldv_state_variable_25 == 1) {
#line 899
      ldv_retval_3 = cx18_probe(cx18_pci_driver_group1, (struct pci_device_id  const  *)ldvarg87);
#line 900
      if (ldv_retval_3 == 0) {
#line 901
        ldv_state_variable_25 = 2;
#line 902
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 906
    goto ldv_54900;
    case 1: ;
#line 909
    if (ldv_state_variable_25 == 2) {
#line 911
      cx18_remove(cx18_pci_driver_group1);
#line 912
      ldv_state_variable_25 = 1;
    } else {

    }
#line 915
    goto ldv_54900;
    case 2: ;
#line 918
    if (ldv_state_variable_25 == 2) {
#line 920
      ldv_shutdown_25();
#line 921
      ldv_state_variable_25 = 2;
    } else {

    }
#line 924
    goto ldv_54900;
    default: 
#line 925
    ldv_stop();
    }
    ldv_54900: ;
  } else {

  }
#line 929
  goto ldv_54881;
  case 13: ;
#line 933
  if (ldv_state_variable_6 != 0) {
#line 934
    ldv_main_exported_6();
  } else {

  }
#line 937
  goto ldv_54881;
  case 14: ;
#line 941
  if (ldv_state_variable_3 != 0) {
#line 942
    invoke_work_3();
  } else {

  }
#line 945
  goto ldv_54881;
  case 15: ;
#line 949
  if (ldv_state_variable_9 != 0) {
#line 950
    ldv_main_exported_9();
  } else {

  }
#line 953
  goto ldv_54881;
  case 16: ;
#line 957
  if (ldv_state_variable_12 != 0) {
#line 958
    ldv_main_exported_12();
  } else {

  }
#line 961
  goto ldv_54881;
  case 17: ;
#line 965
  if (ldv_state_variable_20 != 0) {
#line 966
    ldv_main_exported_20();
  } else {

  }
#line 969
  goto ldv_54881;
  case 18: ;
#line 973
  if (ldv_state_variable_14 != 0) {
#line 974
    ldv_main_exported_14();
  } else {

  }
#line 977
  goto ldv_54881;
  case 19: ;
#line 981
  if (ldv_state_variable_15 != 0) {
#line 982
    ldv_main_exported_15();
  } else {

  }
#line 985
  goto ldv_54881;
  case 20: ;
#line 989
  if (ldv_state_variable_8 != 0) {
#line 990
    ldv_main_exported_8();
  } else {

  }
#line 993
  goto ldv_54881;
  case 21: ;
#line 1000
  goto ldv_54881;
  case 22: ;
#line 1004
  if (ldv_state_variable_24 != 0) {
#line 1005
    ldv_main_exported_24();
  } else {

  }
#line 1008
  goto ldv_54881;
  case 23: ;
#line 1012
  if (ldv_state_variable_19 != 0) {
#line 1013
    ldv_main_exported_19();
  } else {

  }
#line 1016
  goto ldv_54881;
  case 24: ;
#line 1020
  if (ldv_state_variable_10 != 0) {
#line 1021
    ldv_main_exported_10();
  } else {

  }
#line 1024
  goto ldv_54881;
  case 25: ;
#line 1031
  goto ldv_54881;
  default: 
#line 1032
  ldv_stop();
  }
  ldv_54881: ;
#line 1034
  goto ldv_54918;
  ldv_final: 
#line 1036
  ldv_check_final_state();
#line 1037
  return 0;
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1068
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1068
  ldv_func_res = tmp;
#line 1070
  activate_work_2(ldv_func_arg3, 2);
#line 1072
  return (ldv_func_res);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1079
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1079
  ldv_func_res = tmp;
#line 1081
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1083
  return (ldv_func_res);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1090
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1090
  ldv_func_res = tmp;
#line 1092
  activate_work_2(ldv_func_arg3, 2);
#line 1094
  return (ldv_func_res);
}
}
#line 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1100
  flush_workqueue(ldv_func_arg1);
#line 1102
  call_and_disable_all_2(2);
#line 1103
  return;
}
}
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1109
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1109
  ldv_func_res = tmp;
#line 1111
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1113
  return (ldv_func_res);
}
}
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1119
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1121
  mutex_lock(ldv_func_arg1);
#line 1122
  return;
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1127
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1129
  mutex_unlock(ldv_func_arg1);
#line 1130
  return;
}
}
#line 1132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1135
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1137
  mutex_unlock(ldv_func_arg1);
#line 1138
  return;
}
}
#line 1140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1143
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1145
  mutex_lock(ldv_func_arg1);
#line 1146
  return;
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1151
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1153
  mutex_lock(ldv_func_arg1);
#line 1154
  return;
}
}
#line 1156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1160
  tmp = mutex_trylock(ldv_func_arg1);
#line 1160
  ldv_func_res = tmp;
#line 1162
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1162
  return (tmp___0);
#line 1164
  return (ldv_func_res);
}
}
#line 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1170
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1172
  mutex_unlock(ldv_func_arg1);
#line 1173
  return;
}
}
#line 1175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1178
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 1180
  mutex_lock(ldv_func_arg1);
#line 1181
  return;
}
}
#line 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1186
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 1188
  mutex_unlock(ldv_func_arg1);
#line 1189
  return;
}
}
#line 1191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1194
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 1196
  mutex_lock(ldv_func_arg1);
#line 1197
  return;
}
}
#line 1199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1202
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 1204
  mutex_unlock(ldv_func_arg1);
#line 1205
  return;
}
}
#line 1207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_flush_work_21(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 1211
  tmp = flush_work(ldv_func_arg1);
#line 1211
  ldv_func_res = tmp;
#line 1213
  call_and_disable_work_2(ldv_func_arg1);
#line 1215
  return (ldv_func_res);
}
}
#line 1218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
__inline static int ldv_request_irq_22(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1222
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1222
  ldv_func_res = tmp;
#line 1224
  tmp___0 = reg_check_1(handler);
#line 1224
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 1225
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
#line 1228
  return (ldv_func_res);
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_free_irq_23(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1234
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1236
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 1237
  return;
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_destroy_workqueue_24(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1242
  destroy_workqueue(ldv_func_arg1);
#line 1244
  call_and_disable_all_2(2);
#line 1245
  return;
}
}
#line 1247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_cancel_work_sync_25(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 1251
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1251
  ldv_func_res = tmp;
#line 1253
  disable_work_2(ldv_func_arg1);
#line 1255
  return (ldv_func_res);
}
}
#line 1258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
bool ldv_cancel_work_sync_26(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 1262
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1262
  ldv_func_res = tmp;
#line 1264
  disable_work_2(ldv_func_arg1);
#line 1266
  return (ldv_func_res);
}
}
#line 1269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_destroy_workqueue_27(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1272
  destroy_workqueue(ldv_func_arg1);
#line 1274
  call_and_disable_all_2(2);
#line 1275
  return;
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1280
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1282
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
#line 1283
  return;
}
}
#line 1285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
int ldv___pci_register_driver_29(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 1289
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1289
  ldv_func_res = tmp;
#line 1291
  ldv_state_variable_25 = 1;
#line 1292
  ldv_pci_driver_25();
#line 1295
  return (ldv_func_res);
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-driver.o.c.prepared"
void ldv_pci_unregister_driver_30(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 1301
  pci_unregister_driver(ldv_func_arg1);
#line 1303
  ldv_state_variable_25 = 0;
#line 1304
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_71(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_68(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_66(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_70(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_73(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-cards.h"
int cx18_get_input(struct cx18 *cx , u16 index , struct v4l2_input *input ) ;
#line 157
int cx18_get_audio_input(struct cx18 *cx , u16 index , struct v4l2_audio *audio ) ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_tuner_i2c cx18_i2c_std  =    {{65534U}, {67U, 65534U}, {97U, 96U, 65534U}};
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_tuner_i2c cx18_i2c_nxp  =    {{65534U}, {66U, 67U, 65534U}, {97U, 96U, 65534U}};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_hvr1600_esmt  = 
#line 61
     {0, (char *)"Hauppauge HVR-1600", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    84082769U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {12289U, 12289U}, {12289U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_std, {3U, 780U, 1143082626U, 8U, 0U, 0U}, 0};
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_hvr1600_s5h1411  = 
#line 108
     {9, (char *)"Hauppauge HVR-1600", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    84082769U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {14337U, 14337U}, {14337U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_nxp, {3U, 780U, 1143082626U, 8U, 0U, 0U}, 0};
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_hvr1600_samsung  = 
#line 155
     {1, (char *)"Hauppauge HVR-1600 (Preproduction)", (char *)"Simultaneous Digital and Analog TV capture supported\n",
    84082769U, 16U, 4U, 479U, {{1U, 0U, 7U}, {2U, 1U, 1296U}, {4U, 1U, 3U}, {3U, 2U,
                                                                             1568U},
                               {5U, 2U, 4U}}, {{1U, 8U, 17U}, {2U, 0U, 2U}, {3U, 0U,
                                                                             3U}},
    {1U, 0U, 4U}, (unsigned char)0, {12289U, 12289U}, {12289U, 0U, 10, 40, 1U}, {0U,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U},
    {{0ULL, 0}, {0ULL, 0}}, & cx18_i2c_std, {3U, 780U, 589499251U, 8U, 0U, 2U}, 0};
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_h900[2U]  = {      {23418U, 6235U, 57600U}, 
        {0U, 0U, 0U}};
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_h900  = 
#line 211
     {2, (char *)"Compro VideoMate H900", (char *)"Analog TV capture supported\n", 84082769U,
    16U, 0U, 81U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U, 5U, 0U}, {2U,
                                                                                 0U,
                                                                                 0U}},
    {1U, 0U, 0U}, 15U, {0U, 0U}, {0U, 0U, 0, 0, 0U}, {0U, 0U, 0U, 0U}, {{16777215ULL,
                                                                         71}}, & cx18_i2c_std,
    {327683U, 1875U, 607325828U, 31U, 0U, 0U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_h900)};
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_mpc718[2U]  = {      {23418U, 4779U, 1816U}, 
        {0U, 0U, 0U}};
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_mpc718  = 
#line 258
     {3, (char *)"Yuan MPC718 MiniPCI DVB-T/Analog", (char *)"Experimenters needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    84082769U, 16U, 32U, 123U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U,
                                                                              2U,
                                                                              2160U},
                                {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                             1U}},
    {1U, 5U, 2U}, 0U, {3U, 1U}, {0U, 0U, 0, 0, 0U}, {3U, 1U, 3U, 1U}, {{16777215ULL,
                                                                        71}}, & cx18_i2c_std,
    {771U, 957U, 909248870U, 31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_mpc718)};
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_gotview_dvd3[2U]  = {      {23418U, 22612U, 13123U}, 
        {0U, 0U, 0U}};
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_gotview_dvd3  = 
#line 318
     {8, (char *)"GoTView PCI DVD3 Hybrid", (char *)"Experimenters needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    84082769U, 16U, 32U, 123U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U,
                                                                              2U,
                                                                              2160U},
                                {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                             1U}},
    {1U, 5U, 2U}, 0U, {3U, 1U}, {0U, 0U, 0, 0, 0U}, {3U, 1U, 2U, 1U}, {{16777215ULL,
                                                                        71}}, & cx18_i2c_std,
    {771U, 957U, 909248870U, 31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_gotview_dvd3)};
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_cnxt_raptor_pal[2U]  = {      {23418U, 5361U, 9U}, 
        {0U, 0U, 0U}};
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_cnxt_raptor_pal  = 
#line 378
     {4, (char *)"Conexant Raptor PAL/SECAM", (char *)"Analog TV capture supported\n",
    84082769U, 16U, 32U, 49U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 1U}, {3U, 2U,
                                                                             2160U},
                               {5U, 2U, 6U}}, {{1U, 5U, 0U}, {2U, 0U, 1U}, {3U, 1U,
                                                                            1U}},
    {1U, 0U, 2U}, (unsigned char)0, {61442U, 4098U}, {0U, 0U, 0, 0, 0U}, {61442U,
                                                                          4098U, 8192U,
                                                                          16386U},
    {{16711935ULL, 38}}, & cx18_i2c_std, {328454U, 1875U, 857868627U, 9U, 0U, 0U},
    (struct cx18_card_pci_info  const  *)(& cx18_pci_cnxt_raptor_pal)};
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_toshiba_qosmio_dvbt[2U]  = {      {23418U, 4473U, 272U}, 
        {0U, 0U, 0U}};
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_toshiba_qosmio_dvbt  = 
#line 432
     {5, (char *)"Toshiba Qosmio DVB-T/Analog", (char *)"Experimenters and photos needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    84082769U, 16U, 0U, 81U, {{1U, 0U, 6U}, {2U, 1U, 1072U}, {4U, 1U, 1U}}, {{1U,
                                                                              5U,
                                                                              0U},
                                                                             {2U,
                                                                              0U,
                                                                              1U}},
    {(unsigned char)0, 0U, (unsigned short)0}, 15U, {0U, 0U}, {0U, 0U, 0, 0, 0U},
    {0U, 0U, 0U, 0U}, {{16777215ULL, 71}}, & cx18_i2c_std, {514U, 955U, 858917475U,
                                                            10U, 0U, 66U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_toshiba_qosmio_dvbt)};
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_leadtek_pvr2100[2U]  = {      {23418U, 4221U, 28455U}, 
        {0U, 0U, 0U}};
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_leadtek_pvr2100  = 
#line 475
     {6, (char *)"Leadtek WinFast PVR2100", (char *)"Experimenters and photos needed for device to work well.\n\tTo help, mail the ivtv-devel list (www.ivtvdriver.org).\n",
    84082769U, 16U, 32U, 113U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 7U}, {6U,
                                                                              1U,
                                                                              8785920U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 5U, 2U}, 1U, {7U, 6U}, {0U, 0U, 0, 0, 0U},
    {7U, 6U, 2U, 2U}, {{16777215ULL, 71}}, & cx18_i2c_std, {771U, 955U, 606211715U,
                                                            31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_leadtek_pvr2100)};
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card_pci_info  const  cx18_pci_leadtek_dvr3100h[2U]  = {      {23418U, 4221U, 26256U}, 
        {0U, 0U, 0U}};
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  cx18_card_leadtek_dvr3100h  = 
#line 528
     {7, (char *)"Leadtek WinFast DVR3100 H", (char *)"Simultaneous DVB-T and Analog capture supported,\n\texcept when capturing Analog from the antenna input.\n",
    84082769U, 16U, 32U, 121U, {{1U, 0U, 2U}, {2U, 1U, 1072U}, {4U, 1U, 7U}, {6U,
                                                                              1U,
                                                                              8785920U}},
    {{1U, 5U, 0U}, {2U, 0U, 1U}}, {1U, 5U, 2U}, 1U, {7U, 6U}, {0U, 0U, 0, 0, 0U},
    {7U, 6U, 2U, 2U}, {{16777215ULL, 71}}, & cx18_i2c_std, {771U, 955U, 606211715U,
                                                            31U, 0U, 2U}, (struct cx18_card_pci_info  const  *)(& cx18_pci_leadtek_dvr3100h)};
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
static struct cx18_card  const  *cx18_card_list[10U]  = 
#line 574
  {      & cx18_card_hvr1600_esmt,      & cx18_card_hvr1600_samsung,      & cx18_card_h900,      & cx18_card_mpc718, 
        & cx18_card_cnxt_raptor_pal,      & cx18_card_toshiba_qosmio_dvbt,      & cx18_card_leadtek_pvr2100,      & cx18_card_leadtek_dvr3100h, 
        & cx18_card_gotview_dvd3,      & cx18_card_hvr1600_s5h1411};
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
struct cx18_card  const  *cx18_get_card(u16 index ) 
{ 


  {
#line 589
  if ((unsigned int )index > 9U) {
#line 590
    return ((struct cx18_card  const  *)0);
  } else {

  }
#line 591
  return (cx18_card_list[(int )index]);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
int cx18_get_input(struct cx18 *cx , u16 index , struct v4l2_input *input ) 
{ 
  struct cx18_card_video_input  const  *card_input ;
  char const   *input_strs[6U] ;

  {
#line 596
  card_input = (struct cx18_card_video_input  const  *)(& (cx->card)->video_inputs) + (unsigned long )index;
#line 598
  input_strs[0] = "Tuner 1";
#line 598
  input_strs[1] = "S-Video 1";
#line 598
  input_strs[2] = "S-Video 2";
#line 598
  input_strs[3] = "Composite 1";
#line 598
  input_strs[4] = "Composite 2";
#line 598
  input_strs[5] = "Component 1";
#line 607
  if ((int )((unsigned short )cx->nof_inputs) <= (int )index) {
#line 608
    return (-22);
  } else {

  }
#line 609
  input->index = (__u32 )index;
#line 610
  strlcpy((char *)(& input->name), input_strs[(int )card_input->video_type + -1],
          32UL);
#line 612
  input->type = (unsigned int )((unsigned char )card_input->video_type) == 1U ? 1U : 2U;
#line 614
  input->audioset = (__u32 )((1 << (int )cx->nof_audio_inputs) + -1);
#line 615
  input->std = input->type == 1U ? cx->tuner_std : 16777215ULL;
#line 617
  return (0);
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.c"
int cx18_get_audio_input(struct cx18 *cx , u16 index , struct v4l2_audio *audio ) 
{ 
  struct cx18_card_audio_input  const  *aud_input ;
  char const   *input_strs[3U] ;

  {
#line 622
  aud_input = (struct cx18_card_audio_input  const  *)(& (cx->card)->audio_inputs) + (unsigned long )index;
#line 624
  input_strs[0] = "Tuner 1";
#line 624
  input_strs[1] = "Line In 1";
#line 624
  input_strs[2] = "Line In 2";
#line 630
  memset((void *)audio, 0, 52UL);
#line 631
  if ((int )((unsigned short )cx->nof_audio_inputs) <= (int )index) {
#line 632
    return (-22);
  } else {

  }
#line 633
  strlcpy((char *)(& audio->name), input_strs[(int )aud_input->audio_type + -1], 32UL);
#line 635
  audio->index = (__u32 )index;
#line 636
  audio->capability = 1U;
#line 637
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_66(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_unlock_68(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_70(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
int ldv_mutex_trylock_71(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_unlock_72(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_73(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-cards.o.c.prepared"
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 402 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) ;
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 335 "include/linux/i2c.h"
extern struct i2c_client *i2c_new_probed_device(struct i2c_adapter * , struct i2c_board_info * ,
                                                unsigned short const   * , int (*)(struct i2c_adapter * ,
                                                                                   unsigned short  ) ) ;
#line 528 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 530
  dev_set_drvdata(& dev->dev, data);
#line 531
  return;
}
}
#line 580
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 51 "include/linux/i2c-algo-bit.h"
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
#line 102 "include/media/v4l2-common.h"
extern struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device * , struct i2c_adapter * ,
                                               char const   * , u8  , unsigned short const   * ) ;
#line 66 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_noretry(struct cx18 *cx , u32 val , void *addr ) 
{ 


  {
#line 68
  writel(val, (void volatile   *)addr);
#line 69
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_53251;
  ldv_53250: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_53249;
  } else {

  }
#line 74
  i = i + 1;
  ldv_53251: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_53250;
  } else {

  }
  ldv_53249: ;
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect(struct cx18 *cx , u32 val , void *addr , u32 eval ,
                                        u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_53264;
  ldv_53263: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_53261;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_53262;
  } else {

  }
  ldv_53261: 
#line 88
  i = i + 1;
  ldv_53264: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_53263;
  } else {

  }
  ldv_53262: ;
#line 95
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 158
  cx18_writel(cx, val, cx->reg_mem + (unsigned long )reg);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect(struct cx18 *cx , u32 val , u32 reg , u32 eval ,
                                           u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static u8 const   hw_addrs[9U]  = 
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
  {      0U,      0U,      76U,      0U, 
        0U,      0U,      0U,      112U, 
        113U};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static u8 const   hw_bus[9U]  = 
#line 61
  {      1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U};
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static char const   * const  hw_devicenames[9U]  = 
#line 74
  {      "tuner",      "tveeprom",      "cs5345",      "cx23418_DTV", 
        "cx23418_AV",      "gpio_mux",      "gpio_reset_ctrl",      "ir_tx_z8f0811_haup", 
        "ir_rx_z8f0811_haup"};
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static int cx18_i2c_new_ir(struct cx18 *cx , struct i2c_adapter *adap , u32 hw , char const   *type ,
                           u8 addr ) 
{ 
  struct i2c_board_info info ;
  struct IR_i2c_init_data *init_data ;
  unsigned short addr_list[2U] ;
  struct i2c_client *tmp ;

  {
#line 90
  init_data = & cx->ir_i2c_init_data;
#line 91
  addr_list[0] = (unsigned short )addr;
#line 91
  addr_list[1] = 65534U;
#line 93
  memset((void *)(& info), 0, 64UL);
#line 94
  strlcpy((char *)(& info.type), type, 20UL);
#line 97
  switch (hw) {
  case 256U: 
#line 99
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 100
  init_data->internal_get_key_func = 5;
#line 101
  init_data->type = 8ULL;
#line 102
  init_data->name = cx->card_name;
#line 103
  info.platform_data = (void *)init_data;
#line 104
  goto ldv_53470;
  }
  ldv_53470: 
#line 107
  tmp = i2c_new_probed_device(adap, & info, (unsigned short const   *)(& addr_list),
                              (int (*)(struct i2c_adapter * , unsigned short  ))0);
#line 107
  return ((unsigned long )tmp == (unsigned long )((struct i2c_client *)0) ? -1 : 0);
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
int cx18_i2c_register(struct cx18 *cx , unsigned int idx ) 
{ 
  struct v4l2_subdev *sd ;
  int bus ;
  struct i2c_adapter *adap ;
  char const   *type ;
  u32 hw ;
  int tmp ;

  {
#line 114
  bus = (int )hw_bus[idx];
#line 115
  adap = (struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )bus;
#line 116
  type = hw_devicenames[idx];
#line 117
  hw = (u32 )(1 << (int )idx);
#line 119
  if (hw == 1U) {
#line 121
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->radio));
#line 123
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 124
      sd->grp_id = hw;
    } else {

    }
#line 125
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->demod));
#line 127
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 128
      sd->grp_id = hw;
    } else {

    }
#line 129
    sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, 0, (unsigned short const   *)(& (cx->card_i2c)->tv));
#line 131
    if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 132
      sd->grp_id = hw;
    } else {

    }
#line 133
    return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
  } else {

  }
#line 136
  if ((hw & 384U) != 0U) {
#line 137
    tmp = cx18_i2c_new_ir(cx, adap, hw, type, (int )hw_addrs[idx]);
#line 137
    return (tmp);
  } else {

  }
#line 140
  if ((unsigned int )((unsigned char )hw_addrs[idx]) == 0U) {
#line 141
    return (-1);
  } else {

  }
#line 144
  sd = v4l2_i2c_new_subdev(& cx->v4l2_dev, adap, type, (int )hw_addrs[idx], (unsigned short const   *)0U);
#line 146
  if ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0)) {
#line 147
    sd->grp_id = hw;
  } else {

  }
#line 148
  return ((unsigned long )sd != (unsigned long )((struct v4l2_subdev *)0) ? 0 : -1);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
struct v4l2_subdev *cx18_find_hw(struct cx18 *cx , u32 hw ) 
{ 
  struct v4l2_subdev *result ;
  struct v4l2_subdev *sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 154
  result = (struct v4l2_subdev *)0;
#line 157
  spin_lock(& cx->v4l2_dev.lock);
#line 158
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 158
  sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 158
  goto ldv_53492;
  ldv_53491: ;
#line 159
  if (sd->grp_id == hw) {
#line 160
    result = sd;
#line 161
    goto ldv_53490;
  } else {

  }
#line 158
  __mptr___0 = (struct list_head  const  *)sd->list.next;
#line 158
  sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53492: ;
#line 158
  if ((unsigned long )(& sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 160
    goto ldv_53491;
  } else {

  }
  ldv_53490: 
#line 164
  spin_unlock(& cx->v4l2_dev.lock);
#line 165
  return (result);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static void cx18_setscl(void *data , int state ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 r ;
  u32 tmp ;

  {
#line 170
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 171
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 172
  addr = bus_index != 0 ? 15880448U : 15814656U;
#line 173
  tmp = cx18_read_reg(cx, addr);
#line 173
  r = tmp;
#line 175
  if (state != 0) {
#line 176
    cx18_write_reg(cx, r | 1U, addr);
  } else {
#line 178
    cx18_write_reg(cx, r & 4294967294U, addr);
  }
#line 179
  return;
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static void cx18_setsda(void *data , int state ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 r ;
  u32 tmp ;

  {
#line 183
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 184
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 185
  addr = bus_index != 0 ? 15880448U : 15814656U;
#line 186
  tmp = cx18_read_reg(cx, addr);
#line 186
  r = tmp;
#line 188
  if (state != 0) {
#line 189
    cx18_write_reg(cx, r | 2U, addr);
  } else {
#line 191
    cx18_write_reg(cx, r & 4294967293U, addr);
  }
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static int cx18_getscl(void *data ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 tmp ;

  {
#line 196
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 197
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 198
  addr = bus_index != 0 ? 15880456U : 15814664U;
#line 200
  tmp = cx18_read_reg(cx, addr);
#line 200
  return ((int )tmp & 4);
}
}
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static int cx18_getsda(void *data ) 
{ 
  struct cx18 *cx ;
  int bus_index ;
  u32 addr ;
  u32 tmp ;

  {
#line 205
  cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;
#line 206
  bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;
#line 207
  addr = bus_index != 0 ? 15880456U : 15814664U;
#line 209
  tmp = cx18_read_reg(cx, addr);
#line 209
  return ((int )tmp & 8);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static struct i2c_adapter cx18_i2c_adap_template  = 
#line 213
     {& __this_module, 0U, (struct i2c_algorithm  const  *)0, (void *)0, {{{{0}}, 0U,
                                                                         0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                        {0}, 0, 0,
                                                                        0, 0, 0, 0,
                                                                        0}, 0, 0,
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0,
                                                                               (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
     0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0, (_Bool)0,
                  (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}}, 0U, 0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                  {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                 0}}},
                  0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                          {0, {0, 0}, 0, 0, 0UL}}, 0UL, {{0L}, {0,
                                                                                0},
                                                                         0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                  {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, 0, {0},
                  {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, 0, 0, 0, 0,
                  0UL, 0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
     0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                  0},
     {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, {'c', 'x', '1', '8',
                                                              ' ', 'i', '2', 'c',
                                                              ' ', 'd', 'r', 'i',
                                                              'v', 'e', 'r', '\000'},
    {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                     {0, 0}, 0, 0,
                                                                     {0, {0, 0}, 0,
                                                                      0, 0UL}}, {0,
                                                                                 0},
    0, 0};
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
static struct i2c_algo_bit_data cx18_i2c_algo_template  = 
#line 223
     {0, & cx18_setsda, & cx18_setscl, & cx18_getsda, & cx18_getscl, 0, 0, 5, 500};
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
int init_cx18_i2c(struct cx18 *cx ) 
{ 
  int i ;
  int err ;
  size_t tmp ;
  u32 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  unsigned long __ms___0 ;
  unsigned long tmp___2 ;
  unsigned long __ms___1 ;
  unsigned long tmp___3 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 236
  if ((cx18_debug & 64) != 0) {
#line 236
    printk("\016%s:  i2c: i2c init\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 238
  i = 0;
#line 238
  goto ldv_53529;
  ldv_53528: 
#line 240
  cx->i2c_algo[i] = cx18_i2c_algo_template;
#line 241
  cx->i2c_algo_cb_data[i].cx = cx;
#line 242
  cx->i2c_algo_cb_data[i].bus_index = i;
#line 243
  cx->i2c_algo[i].data = (void *)(& cx->i2c_algo_cb_data) + (unsigned long )i;
#line 246
  cx->i2c_adap[i] = cx18_i2c_adap_template;
#line 247
  cx->i2c_adap[i].algo_data = (void *)(& cx->i2c_algo) + (unsigned long )i;
#line 248
  tmp = strlen((char const   *)(& cx->i2c_adap[i].name));
#line 248
  sprintf((char *)(& cx->i2c_adap[i].name) + tmp, " #%d-%d", cx->instance, i);
#line 250
  i2c_set_adapdata((struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )i, (void *)(& cx->v4l2_dev));
#line 251
  cx->i2c_adap[i].dev.parent = & (cx->pci_dev)->dev;
#line 238
  i = i + 1;
  ldv_53529: ;
#line 238
  if (i <= 1) {
#line 240
    goto ldv_53528;
  } else {

  }
#line 254
  tmp___0 = cx18_read_reg(cx, 15880448U);
#line 254
  if (tmp___0 != 245807U) {
#line 257
    cx18_write_reg_expect(cx, 268435456U, 13045764U, 0U, 268439552U);
#line 260
    cx18_write_reg_expect(cx, 268439552U, 13045796U, 4096U, 268439552U);
  } else {

  }
#line 264
  cx18_write_reg_expect(cx, 12582912U, 13041692U, 0U, 12583104U);
#line 265
  __ms = 10UL;
#line 265
  goto ldv_53533;
  ldv_53532: 
#line 265
  __const_udelay(4295000UL);
  ldv_53533: 
#line 265
  tmp___1 = __ms;
#line 265
  __ms = __ms - 1UL;
#line 265
  if (tmp___1 != 0UL) {
#line 267
    goto ldv_53532;
  } else {

  }
#line 266
  cx18_write_reg_expect(cx, 12583104U, 13041692U, 192U, 12583104U);
#line 267
  __ms___0 = 10UL;
#line 267
  goto ldv_53537;
  ldv_53536: 
#line 267
  __const_udelay(4295000UL);
  ldv_53537: 
#line 267
  tmp___2 = __ms___0;
#line 267
  __ms___0 = __ms___0 - 1UL;
#line 267
  if (tmp___2 != 0UL) {
#line 269
    goto ldv_53536;
  } else {

  }
#line 268
  cx18_write_reg_expect(cx, 12582912U, 13041692U, 0U, 12583104U);
#line 269
  __ms___1 = 10UL;
#line 269
  goto ldv_53541;
  ldv_53540: 
#line 269
  __const_udelay(4295000UL);
  ldv_53541: 
#line 269
  tmp___3 = __ms___1;
#line 269
  __ms___1 = __ms___1 - 1UL;
#line 269
  if (tmp___3 != 0UL) {
#line 271
    goto ldv_53540;
  } else {

  }
#line 272
  cx18_write_reg(cx, 12582912U, 13054152U);
#line 274
  cx18_write_reg_expect(cx, 12582912U, 13054148U, 4282384383U, 12582912U);
#line 278
  cx18_write_reg(cx, 138251U, 15814656U);
#line 279
  cx18_setscl((void *)(& cx->i2c_algo_cb_data), 1);
#line 280
  cx18_setsda((void *)(& cx->i2c_algo_cb_data), 1);
#line 283
  cx18_write_reg(cx, 138251U, 15880448U);
#line 284
  cx18_setscl((void *)(& cx->i2c_algo_cb_data) + 1U, 1);
#line 285
  cx18_setsda((void *)(& cx->i2c_algo_cb_data) + 1U, 1);
#line 287
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 287
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 287
  goto ldv_53549;
  ldv_53548: ;
#line 287
  if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                         u32  ))0)) {
#line 287
    (*(((__sd->ops)->core)->reset))(__sd, 0U);
  } else {

  }
#line 287
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 287
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53549: ;
#line 287
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 289
    goto ldv_53548;
  } else {

  }
#line 290
  err = i2c_bit_add_bus((struct i2c_adapter *)(& cx->i2c_adap));
#line 291
  if (err != 0) {
#line 292
    goto err;
  } else {

  }
#line 293
  err = i2c_bit_add_bus((struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 294
  if (err != 0) {
#line 295
    goto err_del_bus_0;
  } else {

  }
#line 296
  return (0);
  err_del_bus_0: 
#line 299
  i2c_del_adapter((struct i2c_adapter *)(& cx->i2c_adap));
  err: ;
#line 301
  return (err);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.c"
void exit_cx18_i2c(struct cx18 *cx ) 
{ 
  int i ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 307
  if ((cx18_debug & 64) != 0) {
#line 307
    printk("\016%s:  i2c: i2c exit\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 308
  tmp = cx18_read_reg(cx, 15814656U);
#line 308
  cx18_write_reg(cx, tmp | 4U, 15814656U);
#line 310
  tmp___0 = cx18_read_reg(cx, 15880448U);
#line 310
  cx18_write_reg(cx, tmp___0 | 4U, 15880448U);
#line 313
  i = 0;
#line 313
  goto ldv_53558;
  ldv_53557: 
#line 314
  i2c_del_adapter((struct i2c_adapter *)(& cx->i2c_adap) + (unsigned long )i);
#line 313
  i = i + 1;
  ldv_53558: ;
#line 313
  if (i <= 1) {
#line 315
    goto ldv_53557;
  } else {

  }

#line 320
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  void *ldvarg109 ;
  void *tmp ;
  int ldvarg107 ;
  int ldvarg105 ;
  void *ldvarg106 ;
  void *tmp___0 ;
  void *ldvarg108 ;
  void *tmp___1 ;
  void *ldvarg104 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 271
  tmp = ldv_init_zalloc(1UL);
#line 271
  ldvarg109 = tmp;
#line 274
  tmp___0 = ldv_init_zalloc(1UL);
#line 274
  ldvarg106 = tmp___0;
#line 275
  tmp___1 = ldv_init_zalloc(1UL);
#line 275
  ldvarg108 = tmp___1;
#line 276
  tmp___2 = ldv_init_zalloc(1UL);
#line 276
  ldvarg104 = tmp___2;
#line 272
  ldv_memset((void *)(& ldvarg107), 0, 4UL);
#line 273
  ldv_memset((void *)(& ldvarg105), 0, 4UL);
#line 278
  tmp___3 = __VERIFIER_nondet_int();
#line 278
  switch (tmp___3) {
  case 0: ;
#line 281
  if (ldv_state_variable_24 == 1) {
#line 283
    cx18_getscl(ldvarg109);
#line 285
    ldv_state_variable_24 = 1;
  } else {

  }
#line 288
  goto ldv_53570;
  case 1: ;
#line 291
  if (ldv_state_variable_24 == 1) {
#line 293
    cx18_getsda(ldvarg108);
#line 295
    ldv_state_variable_24 = 1;
  } else {

  }
#line 298
  goto ldv_53570;
  case 2: ;
#line 301
  if (ldv_state_variable_24 == 1) {
#line 303
    cx18_setsda(ldvarg106, ldvarg107);
#line 305
    ldv_state_variable_24 = 1;
  } else {

  }
#line 308
  goto ldv_53570;
  case 3: ;
#line 311
  if (ldv_state_variable_24 == 1) {
#line 313
    cx18_setscl(ldvarg104, ldvarg105);
#line 315
    ldv_state_variable_24 = 1;
  } else {

  }
#line 318
  goto ldv_53570;
  default: 
#line 319
  ldv_stop();
  }
  ldv_53570: ;
#line 323
  return;
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 352
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 352
  ldv_func_res = tmp;
#line 354
  activate_work_2(ldv_func_arg3, 2);
#line 356
  return (ldv_func_res);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 363
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 363
  ldv_func_res = tmp;
#line 365
  activate_work_2(& ldv_func_arg3->work, 2);
#line 367
  return (ldv_func_res);
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 374
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 374
  ldv_func_res = tmp;
#line 376
  activate_work_2(ldv_func_arg3, 2);
#line 378
  return (ldv_func_res);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 384
  flush_workqueue(ldv_func_arg1);
#line 386
  call_and_disable_all_2(2);
#line 387
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 393
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 393
  ldv_func_res = tmp;
#line 395
  activate_work_2(& ldv_func_arg3->work, 2);
#line 397
  return (ldv_func_res);
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 403
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 405
  mutex_lock(ldv_func_arg1);
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 411
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 413
  mutex_unlock(ldv_func_arg1);
#line 414
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 419
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 421
  mutex_unlock(ldv_func_arg1);
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 427
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 429
  mutex_lock(ldv_func_arg1);
#line 430
  return;
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 435
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 437
  mutex_lock(ldv_func_arg1);
#line 438
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 444
  tmp = mutex_trylock(ldv_func_arg1);
#line 444
  ldv_func_res = tmp;
#line 446
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 446
  return (tmp___0);
#line 448
  return (ldv_func_res);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 454
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 456
  mutex_unlock(ldv_func_arg1);
#line 457
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 462
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 464
  mutex_lock(ldv_func_arg1);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 470
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 472
  mutex_unlock(ldv_func_arg1);
#line 473
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 478
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 480
  mutex_lock(ldv_func_arg1);
#line 481
  return;
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-i2c.o.c.prepared"
void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 486
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 488
  mutex_unlock(ldv_func_arg1);
#line 489
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_138(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_134(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_136(struct workqueue_struct *ldv_func_arg1 ) ;
#line 62 "./arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 62
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 62
  return (ret);
}
}
#line 70 "./arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 70
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
#line 71
  return;
}
}
#line 85 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_vapi_result(struct cx18 *cx , u32 *data , u32 cmd , int args  , ...) ;
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_raw_readl(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned int tmp ;

  {
#line 40
  tmp = __readl((void const volatile   *)addr);
#line 40
  return (tmp);
}
}
#line 44 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_raw_writel_noretry(struct cx18 *cx , u32 val , void *addr ) 
{ 


  {
#line 46
  __writel(val, (void volatile   *)addr);
#line 47
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_raw_writel(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 52
  i = 0;
#line 52
  goto ldv_53233;
  ldv_53232: 
#line 53
  cx18_raw_writel_noretry(cx, val, addr);
#line 54
  tmp = cx18_raw_readl(cx, (void const   *)addr);
#line 54
  if (tmp == val) {
#line 55
    goto ldv_53231;
  } else {

  }
#line 52
  i = i + 1;
  ldv_53233: ;
#line 52
  if (i <= 9) {
#line 54
    goto ldv_53232;
  } else {

  }
  ldv_53231: ;
#line 59
  return;
}
}
#line 184
void cx18_sw1_irq_enable(struct cx18 *cx , u32 val ) ;
#line 186
void cx18_sw2_irq_enable(struct cx18 *cx , u32 val ) ;
#line 188
void cx18_sw2_irq_disable_cpu(struct cx18 *cx , u32 val ) ;
#line 189
void cx18_setup_page(struct cx18 *cx , u32 addr ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
static int load_cpu_fw_direct(char const   *fn , u8 *mem , struct cx18 *cx ) 
{ 
  struct firmware  const  *fw ;
  int i ;
  int j ;
  unsigned int size ;
  u32 *dst ;
  u32 const   *src ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 103
  fw = (struct firmware  const  *)0;
#line 106
  dst = (u32 *)mem;
#line 109
  tmp = request_firmware(& fw, fn, & (cx->pci_dev)->dev);
#line 109
  if (tmp != 0) {
#line 110
    printk("\v%s: Unable to open firmware %s\n", (char *)(& cx->v4l2_dev.name), fn);
#line 111
    printk("\v%s: Did you put the firmware in the hotplug firmware directory?\n",
           (char *)(& cx->v4l2_dev.name));
#line 112
    return (-12);
  } else {

  }
#line 115
  src = (u32 const   *)fw->data;
#line 117
  i = 0;
#line 117
  goto ldv_53622;
  ldv_53621: 
#line 118
  cx18_setup_page(cx, (u32 )i);
#line 119
  j = i;
#line 119
  goto ldv_53619;
  ldv_53618: 
#line 121
  cx18_raw_writel(cx, *src, (void *)dst);
#line 122
  tmp___0 = cx18_raw_readl(cx, (void const   *)dst);
#line 122
  if (tmp___0 != (u32 )*src) {
#line 123
    printk("\v%s: Mismatch at offset %x\n", (char *)(& cx->v4l2_dev.name), i);
#line 124
    release_firmware(fw);
#line 125
    cx18_setup_page(cx, 0U);
#line 126
    return (-5);
  } else {

  }
#line 128
  dst = dst + 1;
#line 129
  src = src + 1;
#line 119
  j = j + 4;
  ldv_53619: ;
#line 119
  if ((unsigned long )j < (unsigned long )fw->size && i + 4096 > j) {
#line 121
    goto ldv_53618;
  } else {

  }
#line 117
  i = i + 4096;
  ldv_53622: ;
#line 117
  if ((unsigned long )i < (unsigned long )fw->size) {
#line 119
    goto ldv_53621;
  } else {

  }
#line 132
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 132
  if (tmp___1 == 0) {
#line 133
    printk("\016%s: loaded %s firmware (%zu bytes)\n", (char *)(& cx->v4l2_dev.name),
           fn, fw->size);
  } else {

  }
#line 134
  size = (unsigned int )fw->size;
#line 135
  release_firmware(fw);
#line 136
  cx18_setup_page(cx, 14417920U);
#line 137
  return ((int )size);
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
static int load_apu_fw_direct(char const   *fn , u8 *dst , struct cx18 *cx , u32 *entry_addr ) 
{ 
  struct firmware  const  *fw ;
  int i ;
  int j ;
  unsigned int size ;
  u32 const   *src ;
  struct cx18_apu_rom_seghdr seghdr ;
  u8 const   *vers ;
  u32 offset ;
  u32 apu_version ;
  int sz ;
  int tmp ;
  __le32 const   *shptr ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 143
  fw = (struct firmware  const  *)0;
#line 149
  offset = 0U;
#line 150
  apu_version = 0U;
#line 153
  tmp = request_firmware(& fw, fn, & (cx->pci_dev)->dev);
#line 153
  if (tmp != 0) {
#line 154
    printk("\v%s: unable to open firmware %s\n", (char *)(& cx->v4l2_dev.name), fn);
#line 155
    printk("\v%s: did you put the firmware in the hotplug firmware directory?\n",
           (char *)(& cx->v4l2_dev.name));
#line 156
    cx18_setup_page(cx, 0U);
#line 157
    return (-12);
  } else {

  }
#line 160
  *entry_addr = 0U;
#line 161
  src = (u32 const   *)fw->data;
#line 162
  vers = fw->data + 16UL;
#line 163
  sz = (int )fw->size;
#line 165
  apu_version = (u32 )((((int )*vers << 24) | ((int )*(vers + 4UL) << 16)) | (int )*(vers + 32UL));
#line 166
  goto ldv_53641;
  ldv_53649: 
#line 167
  shptr = src + (unsigned long )(offset / 4U);
#line 169
  seghdr.sync1 = *shptr;
#line 170
  seghdr.sync2 = *(shptr + 1UL);
#line 171
  seghdr.addr = *(shptr + 2UL);
#line 172
  seghdr.size = *(shptr + 3UL);
#line 174
  offset = offset + 16U;
#line 175
  if (seghdr.sync1 != 1835492691U || seghdr.sync2 != 1919182152U) {
#line 177
    offset = seghdr.size + offset;
#line 178
    goto ldv_53641;
  } else {

  }
#line 180
  if ((cx18_debug & 2) != 0) {
#line 180
    printk("\016%s:  info: load segment %x-%x\n", (char *)(& cx->v4l2_dev.name), seghdr.addr,
           (seghdr.addr + seghdr.size) - 1U);
  } else {

  }
#line 182
  if (*entry_addr == 0U) {
#line 183
    *entry_addr = seghdr.addr;
  } else {

  }
#line 184
  if (seghdr.size + offset > (u32 )sz) {
#line 185
    goto ldv_53642;
  } else {

  }
#line 186
  i = 0;
#line 186
  goto ldv_53647;
  ldv_53646: 
#line 187
  cx18_setup_page(cx, seghdr.addr + (u32 )i);
#line 188
  j = i;
#line 188
  goto ldv_53644;
  ldv_53643: 
#line 190
  cx18_raw_writel(cx, *(src + (unsigned long )((offset + (u32 )j) / 4U)), (void *)(dst + ((unsigned long )seghdr.addr + (unsigned long )j)));
#line 192
  tmp___0 = cx18_raw_readl(cx, (void const   *)(dst + ((unsigned long )seghdr.addr + (unsigned long )j)));
#line 192
  if (tmp___0 != (u32 )*(src + (unsigned long )((offset + (u32 )j) / 4U))) {
#line 194
    printk("\v%s: Mismatch at offset %x\n", (char *)(& cx->v4l2_dev.name), offset + (u32 )j);
#line 196
    release_firmware(fw);
#line 197
    cx18_setup_page(cx, 0U);
#line 198
    return (-5);
  } else {

  }
#line 188
  j = j + 4;
  ldv_53644: ;
#line 188
  if ((u32 )j < seghdr.size && i + 4096 > j) {
#line 190
    goto ldv_53643;
  } else {

  }
#line 186
  i = i + 4096;
  ldv_53647: ;
#line 186
  if ((u32 )i < seghdr.size) {
#line 188
    goto ldv_53646;
  } else {

  }
#line 202
  offset = seghdr.size + offset;
  ldv_53641: ;
#line 166
  if ((unsigned long )offset + 16UL < (unsigned long )fw->size) {
#line 168
    goto ldv_53649;
  } else {

  }
  ldv_53642: 
#line 204
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 204
  if (tmp___1 == 0) {
#line 205
    printk("\016%s: loaded %s firmware V%08x (%zu bytes)\n", (char *)(& cx->v4l2_dev.name),
           fn, apu_version, fw->size);
  } else {

  }
#line 207
  size = (unsigned int )fw->size;
#line 208
  release_firmware(fw);
#line 209
  cx18_setup_page(cx, 0U);
#line 210
  return ((int )size);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
void cx18_halt_firmware(struct cx18 *cx ) 
{ 


  {
#line 215
  if ((cx18_debug & 2) != 0) {
#line 215
    printk("\016%s:  info: Preparing for firmware halt.\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 216
  cx18_write_reg_expect(cx, 983055U, 13041680U, 15U, 983055U);
#line 218
  cx18_write_reg_expect(cx, 131074U, 13074720U, 2U, 131074U);
#line 219
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
void cx18_init_power(struct cx18 *cx , int lowpwr ) 
{ 


  {
#line 226
  cx18_write_reg(cx, 8U, 13074568U);
#line 229
  cx18_write_reg_expect(cx, 131072U, 13074720U, 0U, 131074U);
#line 271
  cx18_write_reg(cx, lowpwr != 0 ? 13U : 17U, 13074432U);
#line 272
  cx18_write_reg(cx, lowpwr != 0 ? 32489271U : 3728343U, 13074436U);
#line 275
  cx18_write_reg(cx, 2U, 13074440U);
#line 276
  cx18_write_reg(cx, 1U, 13074444U);
#line 277
  cx18_write_reg(cx, 4U, 13074448U);
#line 282
  cx18_write_reg(cx, lowpwr != 0 ? 13U : 12U, 13074452U);
#line 283
  cx18_write_reg(cx, lowpwr != 0 ? 3195716U : 19174015U, 13074456U);
#line 285
  cx18_write_reg(cx, 3U, 13074460U);
#line 289
  cx18_write_reg(cx, 15U, 13074496U);
#line 290
  cx18_write_reg(cx, 2876158U, 13074500U);
#line 291
  cx18_write_reg(cx, 8U, 13074504U);
#line 308
  if (lowpwr != 0) {
#line 309
    cx18_write_reg_expect(cx, 4294901792U, 13045760U, 32U, 4294967295U);
#line 311
    cx18_write_reg_expect(cx, 4294901764U, 13045764U, 4U, 4294967295U);
  } else {
#line 315
    cx18_write_reg_expect(cx, 393220U, 13045760U, 4U, 393222U);
#line 317
    cx18_write_reg_expect(cx, 393222U, 13045764U, 6U, 393222U);
  }
#line 321
  cx18_write_reg_expect(cx, 4294901762U, 13045768U, 2U, 4294967295U);
#line 323
  cx18_write_reg_expect(cx, 4294902020U, 13045772U, 260U, 4294967295U);
#line 325
  cx18_write_reg_expect(cx, 4294938662U, 13045792U, 36902U, 4294967295U);
#line 327
  cx18_write_reg_expect(cx, 4294914309U, 13045796U, 12549U, 4294967295U);
#line 328
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
void cx18_init_memory(struct cx18 *cx ) 
{ 


  {
#line 333
  cx18_msleep_timeout(10U, 0);
#line 334
  cx18_write_reg_expect(cx, 65536U, 13041684U, 0U, 65537U);
#line 336
  cx18_msleep_timeout(10U, 0);
#line 338
  cx18_write_reg(cx, (cx->card)->ddr.chip_config, 13107204U);
#line 340
  cx18_msleep_timeout(10U, 0);
#line 342
  cx18_write_reg(cx, (cx->card)->ddr.refresh, 13107208U);
#line 343
  cx18_write_reg(cx, (cx->card)->ddr.timing1, 13107212U);
#line 344
  cx18_write_reg(cx, (cx->card)->ddr.timing2, 13107216U);
#line 346
  cx18_msleep_timeout(10U, 0);
#line 349
  cx18_write_reg(cx, (cx->card)->ddr.tune_lane, 13107272U);
#line 350
  cx18_write_reg(cx, (cx->card)->ddr.initial_emrs, 13107284U);
#line 352
  cx18_msleep_timeout(10U, 0);
#line 354
  cx18_write_reg_expect(cx, 131072U, 13041684U, 0U, 131074U);
#line 356
  cx18_msleep_timeout(10U, 0);
#line 359
  cx18_write_reg(cx, 16U, 13107228U);
#line 361
  cx18_write_reg_expect(cx, 65537U, 13049892U, 1U, 65537U);
#line 364
  cx18_write_reg(cx, 72U, 13107356U);
#line 365
  cx18_write_reg(cx, 917504U, 13108476U);
#line 367
  cx18_write_reg(cx, 257U, 13173000U);
#line 368
  cx18_write_reg(cx, 257U, 13173028U);
#line 369
  cx18_write_reg(cx, 257U, 13173012U);
#line 370
  cx18_write_reg(cx, 257U, 13173016U);
#line 371
  cx18_write_reg(cx, 257U, 13173020U);
#line 372
  cx18_write_reg(cx, 257U, 13173032U);
#line 373
  cx18_write_reg(cx, 257U, 13173040U);
#line 374
  cx18_write_reg(cx, 257U, 13173044U);
#line 375
  cx18_write_reg(cx, 257U, 13173036U);
#line 376
  cx18_write_reg(cx, 257U, 13173048U);
#line 377
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.c"
int cx18_firmware_init(struct cx18 *cx ) 
{ 
  u32 fw_entry_addr ;
  int sz ;
  int retries ;
  u32 api_args[6U] ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
#line 389
  cx18_write_reg(cx, 5U, 13631564U);
#line 392
  cx18_write_reg_expect(cx, 983055U, 13041680U, 15U, 983055U);
#line 395
  cx18_msleep_timeout(1U, 0);
#line 398
  tmp = cx18_read_reg(cx, 13041680U);
#line 398
  if ((tmp & 8U) == 0U) {
#line 399
    printk("\v%s: %s: couldn\'t stop CPU to load firmware\n", (char *)(& cx->v4l2_dev.name),
           "cx18_firmware_init");
#line 400
    return (-5);
  } else {

  }
#line 403
  cx18_sw1_irq_enable(cx, 196608U);
#line 404
  cx18_sw2_irq_enable(cx, 136U);
#line 406
  sz = load_cpu_fw_direct("v4l-cx23418-cpu.fw", (u8 *)cx->enc_mem, cx);
#line 407
  if (sz <= 0) {
#line 408
    return (sz);
  } else {

  }
#line 411
  cx18_init_scb(cx);
#line 413
  fw_entry_addr = 0U;
#line 414
  sz = load_apu_fw_direct("v4l-cx23418-apu.fw", (u8 *)cx->enc_mem, cx, & fw_entry_addr);
#line 416
  if (sz <= 0) {
#line 417
    return (sz);
  } else {

  }
#line 420
  cx18_write_reg_expect(cx, 524288U, 13041680U, 0U, 524296U);
#line 424
  retries = 0;
#line 424
  goto ldv_53669;
  ldv_53668: 
#line 427
  cx18_msleep_timeout(10U, 0);
#line 426
  retries = retries + 1;
  ldv_53669: ;
#line 424
  if (retries <= 49) {
#line 424
    tmp___0 = cx18_read_reg(cx, 13041680U);
#line 424
    if ((int )tmp___0 & 1) {
#line 427
      goto ldv_53668;
    } else {
#line 430
      goto ldv_53670;
    }
  } else {

  }
  ldv_53670: 
#line 429
  cx18_msleep_timeout(200U, 0);
#line 431
  if (retries == 50) {
#line 431
    tmp___1 = cx18_read_reg(cx, 13041680U);
#line 431
    if ((int )tmp___1 & 1) {
#line 433
      printk("\v%s: Could not start the CPU\n", (char *)(& cx->v4l2_dev.name));
#line 434
      return (-5);
    } else {

    }
  } else {

  }
#line 446
  cx18_sw2_irq_disable_cpu(cx, 136U);
#line 449
  sz = cx18_vapi_result(cx, (u32 *)(& api_args), 536870915U, 1, 0);
#line 450
  if (sz < 0) {
#line 451
    return (sz);
  } else {

  }
#line 454
  cx18_write_reg_expect(cx, 335549440U, 13074704U, 5120U, 335549440U);
#line 455
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_134(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_flush_workqueue_136(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-firmware.o.c.prepared"
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_179(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_178(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_181(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_183(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_189(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) ;
#line 71
void ldv_mutex_lock_gpio_lock_of_cx18(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_gpio_lock_of_cx18(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) ;
#line 424 "include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long  ) ;
#line 656 "include/media/v4l2-subdev.h"
__inline static void v4l2_set_subdevdata(struct v4l2_subdev *sd , void *p ) 
{ 


  {
#line 658
  sd->dev_priv = p;
#line 659
  return;
}
}
#line 661 "include/media/v4l2-subdev.h"
__inline static void *v4l2_get_subdevdata(struct v4l2_subdev  const  *sd ) 
{ 


  {
#line 663
  return ((void *)sd->dev_priv);
}
}
#line 683
extern void v4l2_subdev_init(struct v4l2_subdev * , struct v4l2_subdev_ops  const  * ) ;
#line 109 "include/media/v4l2-device.h"
extern int v4l2_device_register_subdev(struct v4l2_device * , struct v4l2_subdev * ) ;
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect___1(struct cx18 *cx , u32 val , void *addr ,
                                            u32 eval , u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_53300;
  ldv_53299: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_53297;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_53298;
  } else {

  }
  ldv_53297: 
#line 88
  i = i + 1;
  ldv_53300: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_53299;
  } else {

  }
  ldv_53298: ;
#line 95
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect___1(struct cx18 *cx , u32 val , u32 reg ,
                                               u32 eval , u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect___1(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-gpio.h"
void cx18_reset_ir_gpio(void *data ) ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static void gpio_write(struct cx18 *cx ) 
{ 
  u32 dir_lo ;
  u32 val_lo ;
  u32 dir_hi ;
  u32 val_hi ;

  {
#line 54
  dir_lo = cx->gpio_dir & 65535U;
#line 55
  val_lo = cx->gpio_val & 65535U;
#line 56
  dir_hi = cx->gpio_dir >> 16;
#line 57
  val_hi = cx->gpio_val >> 16;
#line 59
  cx18_write_reg_expect___1(cx, dir_lo << 16, 13074696U, ~ dir_lo, dir_lo);
#line 61
  cx18_write_reg_expect___1(cx, (dir_lo << 16) | val_lo, 13074688U, val_lo, dir_lo);
#line 63
  cx18_write_reg_expect___1(cx, dir_hi << 16, 13074700U, ~ dir_hi, dir_hi);
#line 65
  cx18_write_reg_expect___1(cx, (dir_hi << 16) | val_hi, 13074692U, val_hi, dir_hi);
#line 66
  return;
}
}
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static void gpio_update(struct cx18 *cx , u32 mask , u32 data ) 
{ 


  {
#line 71
  if (mask == 0U) {
#line 72
    return;
  } else {

  }
#line 74
  ldv_mutex_lock_185(& cx->gpio_lock);
#line 75
  cx->gpio_val = (cx->gpio_val & ~ mask) | (data & mask);
#line 76
  gpio_write(cx);
#line 77
  ldv_mutex_unlock_186(& cx->gpio_lock);
#line 78
  return;
}
}
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static void gpio_reset_seq(struct cx18 *cx , u32 active_lo , u32 active_hi , unsigned int assert_msecs ,
                           unsigned int recovery_msecs ) 
{ 
  u32 mask ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 86
  mask = active_lo | active_hi;
#line 87
  if (mask == 0U) {
#line 88
    return;
  } else {

  }
#line 97
  gpio_update(cx, mask, ~ active_lo);
#line 98
  tmp = msecs_to_jiffies(assert_msecs);
#line 98
  schedule_timeout_uninterruptible((long )tmp);
#line 101
  gpio_update(cx, mask, ~ active_hi);
#line 102
  tmp___0 = msecs_to_jiffies(recovery_msecs);
#line 102
  schedule_timeout_uninterruptible((long )tmp___0);
#line 103
  return;
}
}
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int gpiomux_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 110
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 110
  cx = (struct cx18 *)tmp;
#line 112
  ldv_mutex_lock_187(& cx->gpio_lock);
#line 113
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& sd->name),
         cx->gpio_dir, cx->gpio_val);
#line 115
  ldv_mutex_unlock_188(& cx->gpio_lock);
#line 116
  return (0);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int gpiomux_s_radio(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 121
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 121
  cx = (struct cx18 *)tmp;
#line 128
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, (cx->card)->gpio_audio_input.radio);
#line 130
  return (0);
}
}
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int gpiomux_s_std(struct v4l2_subdev *sd , v4l2_std_id norm ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 data ;

  {
#line 135
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 135
  cx = (struct cx18 *)tmp;
#line 138
  switch ((int )(cx->card)->audio_inputs[cx->audio_input].muxer_input) {
  case 1: 
#line 140
  data = (cx->card)->gpio_audio_input.linein;
#line 141
  goto ldv_53538;
  case 0: 
#line 143
  data = (cx->card)->gpio_audio_input.tuner;
#line 144
  goto ldv_53538;
  default: 
#line 151
  data = (cx->card)->gpio_audio_input.tuner;
#line 152
  goto ldv_53538;
  }
  ldv_53538: 
#line 154
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, data);
#line 155
  return (0);
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int gpiomux_s_audio_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 data ;

  {
#line 161
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 161
  cx = (struct cx18 *)tmp;
#line 164
  switch (input) {
  case 0U: 
#line 166
  data = (cx->card)->gpio_audio_input.tuner;
#line 167
  goto ldv_53550;
  case 1U: 
#line 169
  data = (cx->card)->gpio_audio_input.linein;
#line 170
  goto ldv_53550;
  case 2U: 
#line 172
  data = (cx->card)->gpio_audio_input.radio;
#line 173
  goto ldv_53550;
  default: ;
#line 175
  return (-22);
  }
  ldv_53550: 
#line 177
  gpio_update(cx, (cx->card)->gpio_audio_input.mask, data);
#line 178
  return (0);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_core_ops  const  gpiomux_core_ops  = 
#line 181
     {& gpiomux_log_status, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0};
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_tuner_ops  const  gpiomux_tuner_ops  = 
#line 185
     {& gpiomux_s_radio, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_audio_ops  const  gpiomux_audio_ops  =    {0, 0, & gpiomux_s_audio_routing, 0};
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_video_ops  const  gpiomux_video_ops  = 
#line 193
     {0, 0, 0, & gpiomux_s_std, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_ops  const  gpiomux_ops  = 
#line 197
     {& gpiomux_core_ops, & gpiomux_tuner_ops, & gpiomux_audio_ops, & gpiomux_video_ops,
    0, 0, 0, 0};
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int resetctrl_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 209
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 209
  cx = (struct cx18 *)tmp;
#line 211
  ldv_mutex_lock_189(& cx->gpio_lock);
#line 212
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& sd->name),
         cx->gpio_dir, cx->gpio_val);
#line 214
  ldv_mutex_unlock_190(& cx->gpio_lock);
#line 215
  return (0);
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static int resetctrl_reset(struct v4l2_subdev *sd , u32 val ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_gpio_i2c_slave_reset  const  *p ;

  {
#line 220
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 220
  cx = (struct cx18 *)tmp;
#line 223
  p = & (cx->card)->gpio_i2c_slave_reset;
#line 224
  switch (val) {
  case 0U: 
#line 226
  gpio_reset_seq(cx, p->active_lo_mask, p->active_hi_mask, (unsigned int )p->msecs_asserted,
                 (unsigned int )p->msecs_recovery);
#line 228
  goto ldv_53570;
  case 1U: 
#line 244
  gpio_reset_seq(cx, p->ir_reset_mask, 0U, (unsigned int )p->msecs_asserted, (unsigned int )p->msecs_recovery);
#line 246
  goto ldv_53570;
  case 2U: ;
#line 248
  if ((int )(cx->card)->tuners[0].tuner == 71) {
#line 249
    gpio_reset_seq(cx, (u32 )(1 << (int )(cx->card)->xceive_pin), 0U, 1U, 1U);
  } else {

  }
#line 251
  goto ldv_53570;
  }
  ldv_53570: ;
#line 253
  return (0);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_core_ops  const  resetctrl_core_ops  = 
#line 256
     {& resetctrl_log_status, 0, 0, 0, & resetctrl_reset, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0};
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static struct v4l2_subdev_ops  const  resetctrl_ops  = 
#line 261
     {& resetctrl_core_ops, 0, 0, 0, 0, 0, 0, 0};
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
void cx18_gpio_init(struct cx18 *cx ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 270
  ldv_mutex_lock_191(& cx->gpio_lock);
#line 271
  cx->gpio_dir = (cx->card)->gpio_init.direction;
#line 272
  cx->gpio_val = (cx->card)->gpio_init.initial_value;
#line 274
  if ((int )(cx->card)->tuners[0].tuner == 71) {
#line 275
    cx->gpio_dir = cx->gpio_dir | (u32 )(1 << (int )(cx->card)->xceive_pin);
#line 276
    cx->gpio_val = cx->gpio_val | (u32 )(1 << (int )(cx->card)->xceive_pin);
  } else {

  }
#line 279
  if (cx->gpio_dir == 0U) {
#line 280
    ldv_mutex_unlock_192(& cx->gpio_lock);
#line 281
    return;
  } else {

  }
#line 284
  if ((cx18_debug & 2) != 0) {
#line 284
    tmp = cx18_read_reg(cx, 13074692U);
#line 284
    tmp___0 = cx18_read_reg(cx, 13074688U);
#line 284
    tmp___1 = cx18_read_reg(cx, 13074700U);
#line 284
    tmp___2 = cx18_read_reg(cx, 13074696U);
#line 284
    printk("\016%s:  info: GPIO initial dir: %08x/%08x out: %08x/%08x\n", (char *)(& cx->v4l2_dev.name),
           tmp___2, tmp___1, tmp___0, tmp);
  } else {

  }
#line 290
  gpio_write(cx);
#line 291
  ldv_mutex_unlock_193(& cx->gpio_lock);
#line 292
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
int cx18_gpio_register(struct cx18 *cx , u32 hw ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev_ops  const  *ops ;
  char *str ;
  int tmp ;

  {
#line 300
  switch (hw) {
  case 32U: 
#line 302
  sd = & cx->sd_gpiomux;
#line 303
  ops = & gpiomux_ops;
#line 304
  str = (char *)"gpio-mux";
#line 305
  goto ldv_53586;
  case 64U: 
#line 307
  sd = & cx->sd_resetctrl;
#line 308
  ops = & resetctrl_ops;
#line 309
  str = (char *)"gpio-reset-ctrl";
#line 310
  goto ldv_53586;
  default: ;
#line 312
  return (-22);
  }
  ldv_53586: 
#line 315
  v4l2_subdev_init(sd, ops);
#line 316
  v4l2_set_subdevdata(sd, (void *)cx);
#line 317
  snprintf((char *)(& sd->name), 32UL, "%s %s", (char *)(& cx->v4l2_dev.name), str);
#line 318
  sd->grp_id = hw;
#line 319
  tmp = v4l2_device_register_subdev(& cx->v4l2_dev, sd);
#line 319
  return (tmp);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
void cx18_reset_ir_gpio(void *data ) 
{ 
  struct cx18 *cx ;
  struct cx18 *tmp ;

  {
#line 324
  tmp = to_cx18((struct v4l2_device *)data);
#line 324
  cx = tmp;
#line 326
  if ((unsigned int )(cx->card)->gpio_i2c_slave_reset.ir_reset_mask == 0U) {
#line 327
    return;
  } else {

  }
#line 329
  if ((cx18_debug & 2) != 0) {
#line 329
    printk("\016%s:  info: Resetting IR microcontroller\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 331
  if ((unsigned long )(& cx->sd_resetctrl) != (unsigned long )((struct v4l2_subdev *)0)) {
#line 331
    if ((unsigned long )(cx->sd_resetctrl.ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((cx->sd_resetctrl.ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 u32  ))0)) {
#line 331
      (*(((cx->sd_resetctrl.ops)->core)->reset))(& cx->sd_resetctrl, 1U);
    } else {

    }
  } else {

  }
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
static char const   __kstrtab_cx18_reset_ir_gpio[19U]  = 
#line 334
  {      'c',      'x',      '1',      '8', 
        '_',      'r',      'e',      's', 
        'e',      't',      '_',      'i', 
        'r',      '_',      'g',      'p', 
        'i',      'o',      '\000'};
#line 334
struct kernel_symbol  const  __ksymtab_cx18_reset_ir_gpio ;
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
struct kernel_symbol  const  __ksymtab_cx18_reset_ir_gpio  =    {(unsigned long )(& cx18_reset_ir_gpio), (char const   *)(& __kstrtab_cx18_reset_ir_gpio)};
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.c"
int cx18_reset_tuner_gpio(void *dev , int component , int cmd , int value ) 
{ 
  struct i2c_algo_bit_data *algo ;
  struct cx18_i2c_algo_callback_data *cb_data ;
  struct cx18 *cx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 340
  algo = (struct i2c_algo_bit_data *)dev;
#line 341
  cb_data = (struct cx18_i2c_algo_callback_data *)algo->data;
#line 342
  cx = cb_data->cx;
#line 344
  if (cmd != 0 || (int )(cx->card)->tuners[0].tuner != 71) {
#line 346
    return (0);
  } else {

  }
#line 348
  if ((cx18_debug & 2) != 0) {
#line 348
    printk("\016%s:  info: Resetting XCeive tuner\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 349
  if ((unsigned long )(& cx->sd_resetctrl) != (unsigned long )((struct v4l2_subdev *)0)) {
#line 349
    if ((unsigned long )(cx->sd_resetctrl.ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((cx->sd_resetctrl.ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                 u32  ))0)) {
#line 349
      tmp = (*(((cx->sd_resetctrl.ops)->core)->reset))(& cx->sd_resetctrl, 2U);
#line 349
      tmp___0 = tmp;
    } else {
#line 349
      tmp___0 = -515;
    }
#line 349
    tmp___1 = tmp___0;
  } else {
#line 349
    tmp___1 = -19;
  }
#line 349
  return (tmp___1);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_initialize_v4l2_subdev_core_ops_19(void) 
{ 
  void *tmp ;

  {
#line 271
  tmp = ldv_init_zalloc(304UL);
#line 271
  resetctrl_core_ops_group0 = (struct v4l2_subdev *)tmp;
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct v4l2_subdev *ldvarg12 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 275
  tmp = ldv_init_zalloc(304UL);
#line 275
  ldvarg12 = (struct v4l2_subdev *)tmp;
#line 277
  tmp___0 = __VERIFIER_nondet_int();
#line 277
  switch (tmp___0) {
  case 0: ;
#line 280
  if (ldv_state_variable_22 == 1) {
#line 282
    gpiomux_s_radio(ldvarg12);
#line 284
    ldv_state_variable_22 = 1;
  } else {

  }
#line 287
  goto ldv_53617;
  default: 
#line 288
  ldv_stop();
  }
  ldv_53617: ;
#line 292
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  u32 ldvarg6 ;
  struct v4l2_subdev *ldvarg5 ;
  void *tmp ;
  u32 ldvarg4 ;
  u32 ldvarg7 ;
  int tmp___0 ;

  {
#line 296
  tmp = ldv_init_zalloc(304UL);
#line 296
  ldvarg5 = (struct v4l2_subdev *)tmp;
#line 295
  ldv_memset((void *)(& ldvarg6), 0, 4UL);
#line 297
  ldv_memset((void *)(& ldvarg4), 0, 4UL);
#line 298
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 300
  tmp___0 = __VERIFIER_nondet_int();
#line 300
  switch (tmp___0) {
  case 0: ;
#line 303
  if (ldv_state_variable_21 == 1) {
#line 305
    gpiomux_s_audio_routing(ldvarg5, ldvarg7, ldvarg6, ldvarg4);
#line 307
    ldv_state_variable_21 = 1;
  } else {

  }
#line 310
  goto ldv_53627;
  default: 
#line 311
  ldv_stop();
  }
  ldv_53627: ;
#line 315
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  struct v4l2_subdev *ldvarg20 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 318
  tmp = ldv_init_zalloc(304UL);
#line 318
  ldvarg20 = (struct v4l2_subdev *)tmp;
#line 320
  tmp___0 = __VERIFIER_nondet_int();
#line 320
  switch (tmp___0) {
  case 0: ;
#line 323
  if (ldv_state_variable_23 == 1) {
#line 325
    gpiomux_log_status(ldvarg20);
#line 327
    ldv_state_variable_23 = 1;
  } else {

  }
#line 330
  goto ldv_53634;
  default: 
#line 331
  ldv_stop();
  }
  ldv_53634: ;
#line 335
  return;
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  u32 ldvarg110 ;
  int tmp ;

  {
#line 338
  ldv_memset((void *)(& ldvarg110), 0, 4UL);
#line 340
  tmp = __VERIFIER_nondet_int();
#line 340
  switch (tmp) {
  case 0: ;
#line 343
  if (ldv_state_variable_19 == 1) {
#line 345
    resetctrl_log_status(resetctrl_core_ops_group0);
#line 347
    ldv_state_variable_19 = 1;
  } else {

  }
#line 350
  goto ldv_53641;
  case 1: ;
#line 353
  if (ldv_state_variable_19 == 1) {
#line 355
    resetctrl_reset(resetctrl_core_ops_group0, ldvarg110);
#line 357
    ldv_state_variable_19 = 1;
  } else {

  }
#line 360
  goto ldv_53641;
  default: 
#line 361
  ldv_stop();
  }
  ldv_53641: ;
#line 365
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  struct v4l2_subdev *ldvarg94 ;
  void *tmp ;
  v4l2_std_id ldvarg95 ;
  int tmp___0 ;

  {
#line 368
  tmp = ldv_init_zalloc(304UL);
#line 368
  ldvarg94 = (struct v4l2_subdev *)tmp;
#line 369
  ldv_memset((void *)(& ldvarg95), 0, 8UL);
#line 371
  tmp___0 = __VERIFIER_nondet_int();
#line 371
  switch (tmp___0) {
  case 0: ;
#line 374
  if (ldv_state_variable_20 == 1) {
#line 376
    gpiomux_s_std(ldvarg94, ldvarg95);
#line 378
    ldv_state_variable_20 = 1;
  } else {

  }
#line 381
  goto ldv_53650;
  default: 
#line 382
  ldv_stop();
  }
  ldv_53650: ;
#line 386
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 415
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 415
  ldv_func_res = tmp;
#line 417
  activate_work_2(ldv_func_arg3, 2);
#line 419
  return (ldv_func_res);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 426
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 426
  ldv_func_res = tmp;
#line 428
  activate_work_2(& ldv_func_arg3->work, 2);
#line 430
  return (ldv_func_res);
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 437
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 437
  ldv_func_res = tmp;
#line 439
  activate_work_2(ldv_func_arg3, 2);
#line 441
  return (ldv_func_res);
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 447
  flush_workqueue(ldv_func_arg1);
#line 449
  call_and_disable_all_2(2);
#line 450
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 456
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 456
  ldv_func_res = tmp;
#line 458
  activate_work_2(& ldv_func_arg3->work, 2);
#line 460
  return (ldv_func_res);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 466
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 468
  mutex_lock(ldv_func_arg1);
#line 469
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 474
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 476
  mutex_unlock(ldv_func_arg1);
#line 477
  return;
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 482
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 484
  mutex_unlock(ldv_func_arg1);
#line 485
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 490
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 492
  mutex_lock(ldv_func_arg1);
#line 493
  return;
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_178(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 498
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 500
  mutex_lock(ldv_func_arg1);
#line 501
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
int ldv_mutex_trylock_179(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 507
  tmp = mutex_trylock(ldv_func_arg1);
#line 507
  ldv_func_res = tmp;
#line 509
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 509
  return (tmp___0);
#line 511
  return (ldv_func_res);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 517
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 519
  mutex_unlock(ldv_func_arg1);
#line 520
  return;
}
}
#line 522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_181(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 525
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 527
  mutex_lock(ldv_func_arg1);
#line 528
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 533
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 535
  mutex_unlock(ldv_func_arg1);
#line 536
  return;
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_183(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 541
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 543
  mutex_lock(ldv_func_arg1);
#line 544
  return;
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 549
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 551
  mutex_unlock(ldv_func_arg1);
#line 552
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 557
  ldv_mutex_lock_gpio_lock_of_cx18(ldv_func_arg1);
#line 559
  mutex_lock(ldv_func_arg1);
#line 560
  return;
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 565
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 567
  mutex_unlock(ldv_func_arg1);
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 573
  ldv_mutex_lock_gpio_lock_of_cx18(ldv_func_arg1);
#line 575
  mutex_lock(ldv_func_arg1);
#line 576
  return;
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 581
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 583
  mutex_unlock(ldv_func_arg1);
#line 584
  return;
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_189(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 589
  ldv_mutex_lock_gpio_lock_of_cx18(ldv_func_arg1);
#line 591
  mutex_lock(ldv_func_arg1);
#line 592
  return;
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 597
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 599
  mutex_unlock(ldv_func_arg1);
#line 600
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 605
  ldv_mutex_lock_gpio_lock_of_cx18(ldv_func_arg1);
#line 607
  mutex_lock(ldv_func_arg1);
#line 608
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 613
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 615
  mutex_unlock(ldv_func_arg1);
#line 616
  return;
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-gpio.o.c.prepared"
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 621
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 623
  mutex_unlock(ldv_func_arg1);
#line 624
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 235 "include/uapi/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 


  {
#line 240
  *p = __swab32p((__u32 const   *)p);
#line 241
  return;
}
}
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 165 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
#line 170
  return;
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 229 "include/linux/list.h"
__inline static int list_is_singular(struct list_head  const  *head ) 
{ 
  int tmp ;

  {
#line 231
  tmp = list_empty(head);
#line 231
  return (tmp == 0 && (unsigned long )head->next == (unsigned long )head->prev);
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_233(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_230(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_231(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_232(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_237(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) ;
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 59
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_30524: ;
#line 19
    goto ldv_30524;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_30533: ;
#line 36
    goto ldv_30533;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_30584: ;
#line 108
    goto ldv_30584;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_30592: ;
#line 120
    goto ldv_30592;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 38 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 40
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 40
  return (tmp);
}
}
#line 44 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
#line 47
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
#line 48
  return;
}
}
#line 79 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ 


  {
#line 82
  dma_sync_single_for_cpu((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                          dma_handle, size, (enum dma_data_direction )direction);
#line 83
  return;
}
}
#line 86 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ 


  {
#line 89
  dma_sync_single_for_device((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             dma_handle, size, (enum dma_data_direction )direction);
#line 90
  return;
}
}
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_buf_sync_for_cpu(struct cx18_stream *s , struct cx18_buffer *buf ) 
{ 


  {
#line 32
  pci_dma_sync_single_for_cpu((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size,
                              s->dma);
#line 34
  return;
}
}
#line 43
void _cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) ;
#line 56
void cx18_buf_swap(struct cx18_buffer *buf ) ;
#line 57
void _cx18_mdl_swap(struct cx18_mdl *mdl ) ;
#line 69
struct cx18_queue *_cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl , struct cx18_queue *q ,
                                 int to_front ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static struct cx18_queue *cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                                struct cx18_queue *q ) 
{ 
  struct cx18_queue *tmp ;

  {
#line 76
  tmp = _cx18_enqueue(s, mdl, q, 0);
#line 76
  return (tmp);
}
}
#line 80 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static struct cx18_queue *cx18_push(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                             struct cx18_queue *q ) 
{ 
  struct cx18_queue *tmp ;

  {
#line 83
  tmp = _cx18_enqueue(s, mdl, q, 1);
#line 83
  return (tmp);
}
}
#line 86
void cx18_queue_init(struct cx18_queue *q ) ;
#line 87
struct cx18_mdl *cx18_dequeue(struct cx18_stream *s , struct cx18_queue *q ) ;
#line 88
struct cx18_mdl *cx18_queue_get_mdl(struct cx18_stream *s , u32 id , u32 bytesused ) ;
#line 90
void cx18_flush_queues(struct cx18_stream *s ) ;
#line 93
void cx18_unload_queues(struct cx18_stream *s ) ;
#line 94
void cx18_load_queues(struct cx18_stream *s ) ;
#line 97
int cx18_stream_alloc(struct cx18_stream *s ) ;
#line 98
void cx18_stream_free(struct cx18_stream *s ) ;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___1(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_53478;
  ldv_53477: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_53476;
  } else {

  }
#line 74
  i = i + 1;
  ldv_53478: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_53477;
  } else {

  }
  ldv_53476: ;
#line 81
  return;
}
}
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_buf_swap(struct cx18_buffer *buf ) 
{ 
  int i ;

  {
#line 35
  i = 0;
#line 35
  goto ldv_53592;
  ldv_53591: 
#line 36
  __swab32s((__u32 *)buf->buf + (unsigned long )i);
#line 35
  i = i + 4;
  ldv_53592: ;
#line 35
  if ((u32 )i < buf->bytesused) {
#line 37
    goto ldv_53591;
  } else {

  }

#line 42
  return;
}
}
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void _cx18_mdl_swap(struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 43
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 43
  buf = (struct cx18_buffer *)__mptr;
#line 43
  goto ldv_53604;
  ldv_53603: ;
#line 44
  if (buf->bytesused == 0U) {
#line 45
    goto ldv_53602;
  } else {

  }
#line 46
  cx18_buf_swap(buf);
#line 43
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 43
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_53604: ;
#line 43
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 45
    goto ldv_53603;
  } else {

  }
  ldv_53602: ;
#line 50
  return;
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_queue_init(struct cx18_queue *q ) 
{ 


  {
#line 52
  INIT_LIST_HEAD(& q->list);
#line 53
  atomic_set(& q->depth, 0);
#line 54
  q->bytesused = 0U;
#line 55
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
struct cx18_queue *_cx18_enqueue(struct cx18_stream *s , struct cx18_mdl *mdl , struct cx18_queue *q ,
                                 int to_front ) 
{ 
  int tmp ;

  {
#line 61
  if ((unsigned long )(& s->q_full) != (unsigned long )q) {
#line 62
    mdl->bytesused = 0U;
#line 63
    mdl->readpos = 0U;
#line 64
    mdl->m_flags = 0UL;
#line 65
    mdl->skipped = 0U;
#line 66
    mdl->curr_buf = (struct cx18_buffer *)0;
  } else {

  }
#line 70
  if ((unsigned long )(& s->q_busy) == (unsigned long )q) {
#line 70
    tmp = atomic_read((atomic_t const   *)(& q->depth));
#line 70
    if (tmp > 62) {
#line 72
      q = & s->q_free;
    } else {

    }
  } else {

  }
#line 74
  spin_lock(& q->lock);
#line 76
  if (to_front != 0) {
#line 77
    list_add(& mdl->list, & q->list);
  } else {
#line 79
    list_add_tail(& mdl->list, & q->list);
  }
#line 80
  q->bytesused = q->bytesused + (mdl->bytesused - mdl->readpos);
#line 81
  atomic_inc(& q->depth);
#line 83
  spin_unlock(& q->lock);
#line 84
  return (q);
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
struct cx18_mdl *cx18_dequeue(struct cx18_stream *s , struct cx18_queue *q ) 
{ 
  struct cx18_mdl *mdl ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 89
  mdl = (struct cx18_mdl *)0;
#line 91
  spin_lock(& q->lock);
#line 92
  tmp = list_empty((struct list_head  const  *)(& q->list));
#line 92
  if (tmp == 0) {
#line 93
    __mptr = (struct list_head  const  *)q->list.next;
#line 93
    mdl = (struct cx18_mdl *)__mptr;
#line 94
    list_del_init(& mdl->list);
#line 95
    q->bytesused = q->bytesused + (mdl->readpos - mdl->bytesused);
#line 96
    mdl->skipped = 0U;
#line 97
    atomic_dec(& q->depth);
  } else {

  }
#line 99
  spin_unlock(& q->lock);
#line 100
  return (mdl);
}
}
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
static void _cx18_mdl_update_bufs_for_cpu(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  u32 buf_size ;
  u32 bytesused ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 107
  buf_size = s->buf_size;
#line 108
  bytesused = mdl->bytesused;
#line 110
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 110
  buf = (struct cx18_buffer *)__mptr;
#line 110
  goto ldv_53633;
  ldv_53632: 
#line 111
  buf->readpos = 0U;
#line 112
  if (bytesused >= buf_size) {
#line 113
    buf->bytesused = buf_size;
#line 114
    bytesused = bytesused - buf_size;
  } else {
#line 116
    buf->bytesused = bytesused;
#line 117
    bytesused = 0U;
  }
#line 119
  cx18_buf_sync_for_cpu(s, buf);
#line 110
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 110
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_53633: ;
#line 110
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 112
    goto ldv_53632;
  } else {

  }

#line 117
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
__inline static void cx18_mdl_update_bufs_for_cpu(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 128
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 128
  if (tmp != 0) {
#line 129
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 129
    buf = (struct cx18_buffer *)__mptr;
#line 131
    buf->bytesused = mdl->bytesused;
#line 132
    buf->readpos = 0U;
#line 133
    cx18_buf_sync_for_cpu(s, buf);
  } else {
#line 135
    _cx18_mdl_update_bufs_for_cpu(s, mdl);
  }
#line 136
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
struct cx18_mdl *cx18_queue_get_mdl(struct cx18_stream *s , u32 id , u32 bytesused ) 
{ 
  struct cx18 *cx ;
  struct cx18_mdl *mdl ;
  struct cx18_mdl *tmp ;
  struct cx18_mdl *ret ;
  struct list_head sweep_up ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 142
  cx = s->cx;
#line 145
  ret = (struct cx18_mdl *)0;
#line 146
  sweep_up.next = & sweep_up;
#line 146
  sweep_up.prev = & sweep_up;
#line 154
  spin_lock(& s->q_busy.lock);
#line 155
  __mptr = (struct list_head  const  *)s->q_busy.list.next;
#line 155
  mdl = (struct cx18_mdl *)__mptr;
#line 155
  __mptr___0 = (struct list_head  const  *)mdl->list.next;
#line 155
  tmp = (struct cx18_mdl *)__mptr___0;
#line 155
  goto ldv_53661;
  ldv_53660: ;
#line 163
  if (mdl->id != id) {
#line 164
    mdl->skipped = mdl->skipped + 1U;
#line 165
    tmp___0 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 165
    if (mdl->skipped >= (unsigned int )(tmp___0 + -1)) {
#line 167
      printk("\f%s: Skipped %s, MDL %d, %d times - it must have dropped out of rotation\n",
             (char *)(& cx->v4l2_dev.name), s->name, mdl->id, mdl->skipped);
#line 172
      list_move_tail(& mdl->list, & sweep_up);
#line 173
      atomic_dec(& s->q_busy.depth);
    } else {

    }
#line 175
    goto ldv_53658;
  } else {

  }
#line 181
  list_del_init(& mdl->list);
#line 182
  atomic_dec(& s->q_busy.depth);
#line 183
  ret = mdl;
#line 184
  goto ldv_53659;
  ldv_53658: 
#line 155
  mdl = tmp;
#line 155
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 155
  tmp = (struct cx18_mdl *)__mptr___1;
  ldv_53661: ;
#line 155
  if ((unsigned long )(& mdl->list) != (unsigned long )(& s->q_busy.list)) {
#line 157
    goto ldv_53660;
  } else {

  }
  ldv_53659: 
#line 186
  spin_unlock(& s->q_busy.lock);
#line 192
  if ((unsigned long )ret != (unsigned long )((struct cx18_mdl *)0)) {
#line 193
    ret->bytesused = bytesused;
#line 194
    ret->skipped = 0U;
#line 196
    cx18_mdl_update_bufs_for_cpu(s, ret);
#line 197
    if (s->type != 1) {
#line 198
      set_bit(0L, (unsigned long volatile   *)(& ret->m_flags));
    } else {

    }
  } else {

  }
#line 202
  __mptr___2 = (struct list_head  const  *)sweep_up.next;
#line 202
  mdl = (struct cx18_mdl *)__mptr___2;
#line 202
  __mptr___3 = (struct list_head  const  *)mdl->list.next;
#line 202
  tmp = (struct cx18_mdl *)__mptr___3;
#line 202
  goto ldv_53669;
  ldv_53668: 
#line 203
  list_del_init(& mdl->list);
#line 204
  cx18_enqueue(s, mdl, & s->q_free);
#line 202
  mdl = tmp;
#line 202
  __mptr___4 = (struct list_head  const  *)tmp->list.next;
#line 202
  tmp = (struct cx18_mdl *)__mptr___4;
  ldv_53669: ;
#line 202
  if ((unsigned long )(& mdl->list) != (unsigned long )(& sweep_up)) {
#line 204
    goto ldv_53668;
  } else {

  }

#line 206
  return (ret);
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
static void cx18_queue_flush(struct cx18_stream *s , struct cx18_queue *q_src , struct cx18_queue *q_dst ) 
{ 
  struct cx18_mdl *mdl ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 216
  if (((unsigned long )q_src == (unsigned long )q_dst || (unsigned long )(& s->q_full) == (unsigned long )q_dst) || (unsigned long )(& s->q_busy) == (unsigned long )q_dst) {
#line 217
    return;
  } else {

  }
#line 219
  spin_lock(& q_src->lock);
#line 220
  spin_lock(& q_dst->lock);
#line 221
  goto ldv_53680;
  ldv_53679: 
#line 222
  __mptr = (struct list_head  const  *)q_src->list.next;
#line 222
  mdl = (struct cx18_mdl *)__mptr;
#line 223
  list_move_tail(& mdl->list, & q_dst->list);
#line 224
  mdl->bytesused = 0U;
#line 225
  mdl->readpos = 0U;
#line 226
  mdl->m_flags = 0UL;
#line 227
  mdl->skipped = 0U;
#line 228
  mdl->curr_buf = (struct cx18_buffer *)0;
#line 229
  atomic_inc(& q_dst->depth);
  ldv_53680: 
#line 221
  tmp = list_empty((struct list_head  const  *)(& q_src->list));
#line 221
  if (tmp == 0) {
#line 223
    goto ldv_53679;
  } else {

  }
#line 231
  cx18_queue_init(q_src);
#line 232
  spin_unlock(& q_src->lock);
#line 233
  spin_unlock(& q_dst->lock);
#line 234
  return;
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_flush_queues(struct cx18_stream *s ) 
{ 


  {
#line 238
  cx18_queue_flush(s, & s->q_busy, & s->q_free);
#line 239
  cx18_queue_flush(s, & s->q_full, & s->q_free);
#line 240
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_unload_queues(struct cx18_stream *s ) 
{ 
  struct cx18_queue *q_idle ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct list_head  const  *__mptr___1 ;

  {
#line 248
  q_idle = & s->q_idle;
#line 253
  cx18_queue_flush(s, & s->q_busy, q_idle);
#line 254
  cx18_queue_flush(s, & s->q_full, q_idle);
#line 255
  cx18_queue_flush(s, & s->q_free, q_idle);
#line 258
  spin_lock(& q_idle->lock);
#line 259
  __mptr = (struct list_head  const  *)q_idle->list.next;
#line 259
  mdl = (struct cx18_mdl *)__mptr;
#line 259
  goto ldv_53701;
  ldv_53700: ;
#line 260
  goto ldv_53698;
  ldv_53697: 
#line 261
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 261
  buf = (struct cx18_buffer *)__mptr___0;
#line 263
  list_move_tail(& buf->list, & s->buf_pool);
#line 264
  buf->bytesused = 0U;
#line 265
  buf->readpos = 0U;
  ldv_53698: 
#line 260
  tmp = list_empty((struct list_head  const  *)(& mdl->buf_list));
#line 260
  if (tmp == 0) {
#line 262
    goto ldv_53697;
  } else {

  }
#line 267
  mdl->id = s->mdl_base_idx;
#line 259
  __mptr___1 = (struct list_head  const  *)mdl->list.next;
#line 259
  mdl = (struct cx18_mdl *)__mptr___1;
  ldv_53701: ;
#line 259
  if ((unsigned long )mdl != (unsigned long )q_idle) {
#line 261
    goto ldv_53700;
  } else {

  }
#line 270
  spin_unlock(& q_idle->lock);
#line 271
  return;
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_load_queues(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  int mdl_id ;
  int i ;
  u32 partial_buf_size ;
  int tmp ;
  struct list_head  const  *__mptr ;

  {
#line 279
  cx = s->cx;
#line 291
  mdl_id = (int )s->mdl_base_idx;
#line 292
  mdl = cx18_dequeue(s, & s->q_idle);
#line 292
  i = (int )s->bufs_per_mdl;
#line 292
  goto ldv_53718;
  ldv_53717: 
#line 296
  mdl->id = (u32 )mdl_id;
#line 298
  i = 0;
#line 298
  goto ldv_53716;
  ldv_53715: 
#line 299
  tmp = list_empty((struct list_head  const  *)(& s->buf_pool));
#line 299
  if (tmp != 0) {
#line 300
    goto ldv_53712;
  } else {

  }
#line 302
  __mptr = (struct list_head  const  *)s->buf_pool.next;
#line 302
  buf = (struct cx18_buffer *)__mptr;
#line 304
  list_move_tail(& buf->list, & mdl->buf_list);
#line 307
  cx18_writel___1(cx, (u32 )buf->dma_handle, (void *)(& (cx->scb)->cpu_mdl[mdl_id + i].paddr));
#line 309
  cx18_writel___1(cx, s->buf_size, (void *)(& (cx->scb)->cpu_mdl[mdl_id + i].length));
#line 298
  i = i + 1;
  ldv_53716: ;
#line 298
  if ((u32 )i < s->bufs_per_mdl) {
#line 300
    goto ldv_53715;
  } else {

  }
  ldv_53712: ;
#line 313
  if ((u32 )i == s->bufs_per_mdl) {
#line 321
    partial_buf_size = s->mdl_size % s->buf_size;
#line 322
    if (partial_buf_size != 0U) {
#line 323
      cx18_writel___1(cx, partial_buf_size, (void *)(& (cx->scb)->cpu_mdl[(mdl_id + i) + -1].length));
    } else {

    }
#line 326
    cx18_enqueue(s, mdl, & s->q_free);
  } else {
#line 329
    cx18_push(s, mdl, & s->q_idle);
  }
#line 331
  mdl_id = mdl_id + i;
#line 294
  mdl = cx18_dequeue(s, & s->q_idle);
  ldv_53718: ;
#line 292
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0) && (u32 )i == s->bufs_per_mdl) {
#line 295
    goto ldv_53717;
  } else {

  }

#line 300
  return;
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void _cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  int dma ;
  u32 buf_size ;
  struct pci_dev *pci_dev ;
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 337
  dma = s->dma;
#line 338
  buf_size = s->buf_size;
#line 339
  pci_dev = (s->cx)->pci_dev;
#line 342
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 342
  buf = (struct cx18_buffer *)__mptr;
#line 342
  goto ldv_53733;
  ldv_53732: 
#line 343
  pci_dma_sync_single_for_device(pci_dev, buf->dma_handle, (size_t )buf_size, dma);
#line 342
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 342
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_53733: ;
#line 342
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 344
    goto ldv_53732;
  } else {

  }

#line 349
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
int cx18_stream_alloc(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  int i ;
  unsigned int bufsz ;
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 349
  cx = s->cx;
#line 352
  if (s->buffers == 0U) {
#line 353
    return (0);
  } else {

  }
#line 355
  if ((cx18_debug & 2) != 0) {
#line 355
    printk("\016%s:  info: Allocate %s stream: %d x %d buffers (%d.%02d kB total)\n",
           (char *)(& cx->v4l2_dev.name), s->name, s->buffers, s->buf_size, (s->buffers * s->buf_size) / 1024U,
           (((s->buffers * s->buf_size) * 100U) / 1024U) % 100U);
  } else {

  }
#line 361
  if ((long )(cx->free_mdl_idx + s->buffers) + 3248L > 65536L) {
#line 363
    bufsz = 62288U;
#line 366
    printk("\v%s: Too many buffers, cannot fit in SCB area\n", (char *)(& cx->v4l2_dev.name));
#line 367
    printk("\v%s: Max buffers = %zu\n", (char *)(& cx->v4l2_dev.name), (unsigned long )(bufsz / 8U));
#line 369
    return (-12);
  } else {

  }
#line 372
  s->mdl_base_idx = cx->free_mdl_idx;
#line 375
  i = 0;
#line 375
  goto ldv_53745;
  ldv_53744: 
#line 380
  tmp = kzalloc(64UL, 720U);
#line 380
  mdl = (struct cx18_mdl *)tmp;
#line 381
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 382
    goto ldv_53743;
  } else {

  }
#line 384
  tmp___0 = kzalloc(40UL, 720U);
#line 384
  buf = (struct cx18_buffer *)tmp___0;
#line 386
  if ((unsigned long )buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 387
    kfree((void const   *)mdl);
#line 388
    goto ldv_53743;
  } else {

  }
#line 391
  tmp___1 = kmalloc((size_t )s->buf_size, 720U);
#line 391
  buf->buf = (char *)tmp___1;
#line 392
  if ((unsigned long )buf->buf == (unsigned long )((char *)0)) {
#line 393
    kfree((void const   *)mdl);
#line 394
    kfree((void const   *)buf);
#line 395
    goto ldv_53743;
  } else {

  }
#line 398
  INIT_LIST_HEAD(& mdl->list);
#line 399
  INIT_LIST_HEAD(& mdl->buf_list);
#line 400
  mdl->id = s->mdl_base_idx;
#line 401
  cx18_enqueue(s, mdl, & s->q_idle);
#line 403
  INIT_LIST_HEAD(& buf->list);
#line 404
  buf->dma_handle = pci_map_single((s->cx)->pci_dev, (void *)buf->buf, (size_t )s->buf_size,
                                   s->dma);
#line 406
  cx18_buf_sync_for_cpu(s, buf);
#line 407
  list_add_tail(& buf->list, & s->buf_pool);
#line 375
  i = i + 1;
  ldv_53745: ;
#line 375
  if ((u32 )i < s->buffers) {
#line 377
    goto ldv_53744;
  } else {

  }
  ldv_53743: ;
#line 409
  if ((u32 )i == s->buffers) {
#line 410
    cx->free_mdl_idx = cx->free_mdl_idx + s->buffers;
#line 411
    return (0);
  } else {

  }
#line 413
  printk("\v%s: Couldn\'t allocate buffers for %s stream\n", (char *)(& cx->v4l2_dev.name),
         s->name);
#line 414
  cx18_stream_free(s);
#line 415
  return (-12);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.c"
void cx18_stream_free(struct cx18_stream *s ) 
{ 
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  struct cx18 *cx ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 422
  cx = s->cx;
#line 424
  if ((cx18_debug & 2) != 0) {
#line 424
    printk("\016%s:  info: Deallocating buffers for %s stream\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 427
  cx18_unload_queues(s);
#line 430
  goto ldv_53753;
  ldv_53752: 
#line 431
  kfree((void const   *)mdl);
  ldv_53753: 
#line 430
  mdl = cx18_dequeue(s, & s->q_idle);
#line 430
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 432
    goto ldv_53752;
  } else {

  }

#line 434
  goto ldv_53758;
  ldv_53757: 
#line 435
  __mptr = (struct list_head  const  *)s->buf_pool.next;
#line 435
  buf = (struct cx18_buffer *)__mptr;
#line 436
  list_del_init(& buf->list);
#line 438
  pci_unmap_single((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size, s->dma);
#line 440
  kfree((void const   *)buf->buf);
#line 441
  kfree((void const   *)buf);
  ldv_53758: 
#line 434
  tmp = list_empty((struct list_head  const  *)(& s->buf_pool));
#line 434
  if (tmp == 0) {
#line 436
    goto ldv_53757;
  } else {

  }

#line 441
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_unlock_230(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_231(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_232(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
int ldv_mutex_trylock_233(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_lock_237(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-queue.o.c.prepared"
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_269(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_266(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_267(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 149 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_260(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_262(struct workqueue_struct *ldv_func_arg1 ) ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) ;
#line 233
void choose_timer_5(struct timer_list *timer ) ;
#line 241
void call_and_disable_all_4(int state ) ;
#line 251
void disable_work_4(struct work_struct *work ) ;
#line 258
void invoke_work_4(void) ;
#line 259
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 261
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 262
int reg_timer_5(struct timer_list *timer ) ;
#line 263
void call_and_disable_work_4(struct work_struct *work ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 149 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 164 "include/media/v4l2-dev.h"
__inline static int video_register_device_no_warn(struct video_device *vdev , int type ,
                                                  int nr ) 
{ 
  int tmp ;

  {
#line 167
  tmp = __video_register_device(vdev, type, nr, 0, (vdev->fops)->owner);
#line 167
  return (tmp);
}
}
#line 172
extern void video_unregister_device(struct video_device * ) ;
#line 184
extern void video_device_release_empty(struct video_device * ) ;
#line 212 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 214
  dev_set_drvdata(& vdev->dev, data);
#line 215
  return;
}
}
#line 226 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 228
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 228
  return (tmp);
}
}
#line 333 "include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
int cx18_api(struct cx18 *cx , u32 cmd , int args , u32 *data ) ;
#line 707 "include/media/v4l2-ctrls.h"
extern s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl * ) ;
#line 196 "include/media/cx2341x.h"
extern int cx2341x_handler_setup(struct cx2341x_handler * ) ;
#line 197
extern void cx2341x_handler_set_busy(struct cx2341x_handler * , int  ) ;
#line 177 "include/media/videobuf-core.h"
extern int videobuf_waiton(struct videobuf_queue * , struct videobuf_buffer * , int  ,
                           int  ) ;
#line 179
extern int videobuf_iolock(struct videobuf_queue * , struct videobuf_buffer * , struct v4l2_framebuffer * ) ;
#line 232
extern int videobuf_mmap_free(struct videobuf_queue * ) ;
#line 32 "include/media/videobuf-vmalloc.h"
extern void videobuf_queue_vmalloc_init(struct videobuf_queue * , struct videobuf_queue_ops  const  * ,
                                        struct device * , spinlock_t * , enum v4l2_buf_type  ,
                                        enum v4l2_field  , unsigned int  , void * ,
                                        struct mutex * ) ;
#line 44
extern void videobuf_vmalloc_free(struct videobuf_buffer * ) ;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___0  =    1444U;
#line 496 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_60Hz  =    272U;
#line 497 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_50Hz  =    284U;
#line 702 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static int cx18_raw_vbi(struct cx18  const  *cx ) 
{ 


  {
#line 704
  return ((unsigned int )cx->vbi.in.type == 4U);
}
}
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-fileops.h"
int cx18_v4l2_open(struct file *filp ) ;
#line 26
ssize_t cx18_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) ;
#line 30
int cx18_v4l2_close(struct file *filp ) ;
#line 31
unsigned int cx18_v4l2_enc_poll(struct file *filp , poll_table *wait ) ;
#line 36
int cx18_v4l2_mmap(struct file *file , struct vm_area_struct *vma ) ;
#line 37
void cx18_vb_timeout(unsigned long data ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_buf_sync_for_device(struct cx18_stream *s , struct cx18_buffer *buf ) 
{ 


  {
#line 39
  pci_dma_sync_single_for_device((s->cx)->pci_dev, buf->dma_handle, (size_t )s->buf_size,
                                 s->dma);
#line 41
  return;
}
}
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_mdl_sync_for_device(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 48
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 48
  if (tmp != 0) {
#line 49
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 49
    cx18_buf_sync_for_device(s, (struct cx18_buffer *)__mptr);
  } else {
#line 53
    _cx18_mdl_sync_for_device(s, mdl);
  }
#line 54
  return;
}
}
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
void cx18_set_funcs(struct video_device *vdev ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
u32 cx18_find_handle(struct cx18 *cx ) ;
#line 26
struct cx18_stream *cx18_handle_to_stream(struct cx18 *cx , u32 handle ) ;
#line 32
void cx18_stream_rotate_idx_mdls(struct cx18 *cx ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static bool cx18_stream_enabled(struct cx18_stream *s ) 
{ 


  {
#line 36
  return ((bool )(((unsigned long )s->video_dev.v4l2_dev != (unsigned long )((struct v4l2_device *)0) || ((unsigned long )s->dvb != (unsigned long )((struct cx18_dvb *)0) && (s->dvb)->enabled != 0)) || (s->type == 5 && (s->cx)->stream_buffers[5] != 0)));
}
}
#line 56
void cx18_out_work_handler(struct work_struct *work ) ;
#line 59
int cx18_start_v4l2_encode_stream(struct cx18_stream *s ) ;
#line 60
int cx18_stop_v4l2_encode_stream(struct cx18_stream *s , int gop_end ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-dvb.h"
int cx18_dvb_register(struct cx18_stream *stream ) ;
#line 25
void cx18_dvb_unregister(struct cx18_stream *stream ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static struct v4l2_file_operations cx18_v4l2_enc_fops  = 
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
     {& __this_module, & cx18_v4l2_read, 0, & cx18_v4l2_enc_poll, & video_ioctl2, 0,
    0, & cx18_v4l2_mmap, & cx18_v4l2_open, & cx18_v4l2_close};
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static struct __anonstruct_cx18_stream_info_393 cx18_stream_info[7U]  = {      {"encoder MPEG", 0, 0, 2, 16973825U}, 
        {"TS", 0, -1, 2, 0U}, 
        {"encoder YUV", 0, 32, 2, 84082689U}, 
        {"encoder VBI", 1, 0, 2, 16842832U}, 
        {"encoder PCM audio", 0, 24, 2, 16973824U}, 
        {"encoder IDX", 0, -1, 2, 0U}, 
        {"encoder radio", 2, 0, 3, 327680U}};
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void cx18_dma_free(struct videobuf_queue *q , struct cx18_stream *s , struct cx18_videobuf_buffer *buf ) 
{ 


  {
#line 112
  videobuf_waiton(q, & buf->vb, 0, 0);
#line 113
  videobuf_vmalloc_free(& buf->vb);
#line 114
  buf->vb.state = 0;
#line 115
  return;
}
}
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static int cx18_prepare_buffer(struct videobuf_queue *q , struct cx18_stream *s ,
                               struct cx18_videobuf_buffer *buf , u32 pixelformat ,
                               unsigned int width , unsigned int height , enum v4l2_field field ) 
{ 
  struct cx18 *cx ;
  int rc ;

  {
#line 124
  cx = s->cx;
#line 125
  rc = 0;
#line 128
  buf->bytes_used = 0U;
#line 130
  if (width <= 47U || height <= 31U) {
#line 131
    return (-22);
  } else {

  }
#line 133
  buf->vb.size = (unsigned long )((width * height) * 2U);
#line 134
  if (buf->vb.baddr != 0UL && buf->vb.bsize < buf->vb.size) {
#line 135
    return (-22);
  } else {

  }
#line 138
  if ((((buf->vb.width != width || buf->vb.height != height) || (unsigned int )buf->vb.field != (unsigned int )field) || s->pixelformat != pixelformat) || buf->tvnorm != cx->std) {
#line 142
    buf->vb.width = width;
#line 143
    buf->vb.height = height;
#line 144
    buf->vb.field = field;
#line 145
    buf->tvnorm = cx->std;
#line 146
    s->pixelformat = pixelformat;
#line 150
    if (s->pixelformat == 842091848U) {
#line 151
      s->vb_bytes_per_frame = (height * 2160U) / 2U;
    } else {
#line 153
      s->vb_bytes_per_frame = height * 1440U;
    }
#line 154
    cx18_dma_free(q, s, buf);
  } else {

  }
#line 157
  if (buf->vb.baddr != 0UL && buf->vb.bsize < buf->vb.size) {
#line 158
    return (-22);
  } else {

  }
#line 160
  if ((unsigned int )buf->vb.field == 0U) {
#line 161
    buf->vb.field = 4;
  } else {

  }
#line 163
  if ((unsigned int )buf->vb.state == 0U) {
#line 164
    buf->vb.width = width;
#line 165
    buf->vb.height = height;
#line 166
    buf->vb.field = field;
#line 167
    buf->tvnorm = cx->std;
#line 168
    s->pixelformat = pixelformat;
#line 172
    if (s->pixelformat == 842091848U) {
#line 173
      s->vb_bytes_per_frame = (height * 2160U) / 2U;
    } else {
#line 175
      s->vb_bytes_per_frame = height * 1440U;
    }
#line 176
    rc = videobuf_iolock(q, & buf->vb, (struct v4l2_framebuffer *)0);
#line 177
    if (rc != 0) {
#line 178
      goto fail;
    } else {

    }
  } else {

  }
#line 180
  buf->vb.state = 1;
#line 181
  return (0);
  fail: 
#line 184
  cx18_dma_free(q, s, buf);
#line 185
  return (rc);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static int buffer_setup(struct videobuf_queue *q , unsigned int *count , unsigned int *size ) 
{ 
  struct cx18_stream *s ;
  struct cx18 *cx ;

  {
#line 198
  s = (struct cx18_stream *)q->priv_data;
#line 199
  cx = s->cx;
#line 201
  *size = (unsigned int )(((int )cx->cxhdl.width * 2) * (int )cx->cxhdl.height);
#line 202
  if (*count == 0U) {
#line 203
    *count = 32U;
  } else {

  }
#line 205
  goto ldv_53758;
  ldv_53757: 
#line 206
  *count = *count - 1U;
  ldv_53758: ;
#line 205
  if (*size * *count > 132710400U) {
#line 207
    goto ldv_53757;
  } else {

  }
#line 208
  q->field = 4;
#line 209
  q->last = 4;
#line 211
  return (0);
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static int buffer_prepare(struct videobuf_queue *q , struct videobuf_buffer *vb ,
                          enum v4l2_field field ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;
  struct cx18 *cx ;
  int tmp ;

  {
#line 219
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 219
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 220
  s = (struct cx18_stream *)q->priv_data;
#line 221
  cx = s->cx;
#line 223
  tmp = cx18_prepare_buffer(q, s, buf, s->pixelformat, (unsigned int )cx->cxhdl.width,
                            (unsigned int )cx->cxhdl.height, field);
#line 223
  return (tmp);
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void buffer_release(struct videobuf_queue *q , struct videobuf_buffer *vb ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;

  {
#line 231
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 231
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 232
  s = (struct cx18_stream *)q->priv_data;
#line 234
  cx18_dma_free(q, s, buf);
#line 235
  return;
}
}
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void buffer_queue(struct videobuf_queue *q , struct videobuf_buffer *vb ) 
{ 
  struct cx18_videobuf_buffer *buf ;
  struct videobuf_buffer  const  *__mptr ;
  struct cx18_stream *s ;

  {
#line 240
  __mptr = (struct videobuf_buffer  const  *)vb;
#line 240
  buf = (struct cx18_videobuf_buffer *)__mptr;
#line 241
  s = (struct cx18_stream *)q->priv_data;
#line 243
  buf->vb.state = 2;
#line 245
  list_add_tail(& buf->vb.queue, & s->vb_capture);
#line 246
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static struct videobuf_queue_ops cx18_videobuf_qops  =    {& buffer_setup, & buffer_prepare, & buffer_queue, & buffer_release};
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void cx18_stream_init(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;

  {
#line 257
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 259
  memset((void *)s, 0, 3400UL);
#line 262
  s->dvb = (struct cx18_dvb *)0;
#line 263
  s->cx = cx;
#line 264
  s->type = type;
#line 265
  s->name = cx18_stream_info[type].name;
#line 266
  s->handle = 4294967295U;
#line 268
  s->dma = cx18_stream_info[type].dma;
#line 269
  s->v4l2_dev_caps = cx18_stream_info[type].caps;
#line 270
  s->buffers = (u32 )cx->stream_buffers[type];
#line 271
  s->buf_size = (u32 )cx->stream_buf_size[type];
#line 272
  INIT_LIST_HEAD(& s->buf_pool);
#line 273
  s->bufs_per_mdl = 1U;
#line 274
  s->mdl_size = s->buf_size * s->bufs_per_mdl;
#line 276
  __init_waitqueue_head(& s->waitq, "&s->waitq", & __key);
#line 277
  s->id = 4294967295U;
#line 278
  spinlock_check(& s->q_free.lock);
#line 278
  __raw_spin_lock_init(& s->q_free.lock.__annonCompField17.rlock, "&(&s->q_free.lock)->rlock",
                       & __key___0);
#line 279
  cx18_queue_init(& s->q_free);
#line 280
  spinlock_check(& s->q_busy.lock);
#line 280
  __raw_spin_lock_init(& s->q_busy.lock.__annonCompField17.rlock, "&(&s->q_busy.lock)->rlock",
                       & __key___1);
#line 281
  cx18_queue_init(& s->q_busy);
#line 282
  spinlock_check(& s->q_full.lock);
#line 282
  __raw_spin_lock_init(& s->q_full.lock.__annonCompField17.rlock, "&(&s->q_full.lock)->rlock",
                       & __key___2);
#line 283
  cx18_queue_init(& s->q_full);
#line 284
  spinlock_check(& s->q_idle.lock);
#line 284
  __raw_spin_lock_init(& s->q_idle.lock.__annonCompField17.rlock, "&(&s->q_idle.lock)->rlock",
                       & __key___3);
#line 285
  cx18_queue_init(& s->q_idle);
#line 287
  __init_work(& s->out_work_order, 0);
#line 287
  __constr_expr_0.counter = 137438953408L;
#line 287
  s->out_work_order.data = __constr_expr_0;
#line 287
  lockdep_init_map(& s->out_work_order.lockdep_map, "(&s->out_work_order)", & __key___4,
                   0);
#line 287
  INIT_LIST_HEAD(& s->out_work_order.entry);
#line 287
  s->out_work_order.func = & cx18_out_work_handler;
#line 289
  INIT_LIST_HEAD(& s->vb_capture);
#line 290
  s->vb_timeout.function = & cx18_vb_timeout;
#line 291
  s->vb_timeout.data = (unsigned long )s;
#line 292
  reg_timer_5(& s->vb_timeout);
#line 293
  spinlock_check(& s->vb_lock);
#line 293
  __raw_spin_lock_init(& s->vb_lock.__annonCompField17.rlock, "&(&s->vb_lock)->rlock",
                       & __key___5);
#line 294
  if (type == 2) {
#line 295
    spinlock_check(& s->vbuf_q_lock);
#line 295
    __raw_spin_lock_init(& s->vbuf_q_lock.__annonCompField17.rlock, "&(&s->vbuf_q_lock)->rlock",
                         & __key___6);
#line 297
    s->vb_type = 1;
#line 298
    videobuf_queue_vmalloc_init(& s->vbuf_q, (struct videobuf_queue_ops  const  *)(& cx18_videobuf_qops),
                                & (cx->pci_dev)->dev, & s->vbuf_q_lock, 1, 4, 256U,
                                (void *)s, & cx->serialize_lock);
#line 306
    s->pixelformat = 842091848U;
#line 307
    s->vb_bytes_per_frame = (u32 )(((int )cx->cxhdl.height * 2160) / 2);
#line 308
    s->vb_bytes_per_line = 720U;
  } else {

  }
#line 310
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static int cx18_prep_dev(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  u32 cap ;
  int num_offset ;
  int num ;
  void *tmp ;

  {
#line 314
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 315
  cap = cx->v4l2_cap;
#line 316
  num_offset = cx18_stream_info[type].num_offset;
#line 317
  num = (cx->instance + cx18_first_minor) + num_offset;
#line 326
  s->video_dev.v4l2_dev = (struct v4l2_device *)0;
#line 327
  s->dvb = (struct cx18_dvb *)0;
#line 328
  s->cx = cx;
#line 329
  s->type = type;
#line 330
  s->name = cx18_stream_info[type].name;
#line 333
  if (type == 6 && (cap & 262144U) == 0U) {
#line 334
    return (0);
  } else {

  }
#line 337
  if (type == 3 && (cap & 80U) == 0U) {
#line 339
    return (0);
  } else {

  }
#line 343
  if (cx18_stream_info[type].dma != 3 && cx->stream_buffers[type] == 0) {
#line 345
    printk("\016%s: Disabled %s device\n", (char *)(& cx->v4l2_dev.name), cx18_stream_info[type].name);
#line 346
    return (0);
  } else {

  }
#line 349
  cx18_stream_init(cx, type);
#line 352
  if (type == 1) {
#line 353
    if (((unsigned int )(cx->card)->hw_all & 8U) != 0U) {
#line 354
      tmp = kzalloc(2224UL, 208U);
#line 354
      s->dvb = (struct cx18_dvb *)tmp;
#line 355
      if ((unsigned long )s->dvb == (unsigned long )((struct cx18_dvb *)0)) {
#line 356
        printk("\v%s: Couldn\'t allocate cx18_dvb structure for %s\n", (char *)(& cx->v4l2_dev.name),
               s->name);
#line 358
        return (-12);
      } else {

      }
    } else {
#line 362
      s->buffers = 0U;
    }
  } else {

  }
#line 366
  if (num_offset == -1) {
#line 367
    return (0);
  } else {

  }
#line 370
  snprintf((char *)(& s->video_dev.name), 32UL, "%s %s", (char *)(& cx->v4l2_dev.name),
           s->name);
#line 373
  s->video_dev.num = (u16 )num;
#line 374
  s->video_dev.v4l2_dev = & cx->v4l2_dev;
#line 375
  s->video_dev.fops = (struct v4l2_file_operations  const  *)(& cx18_v4l2_enc_fops);
#line 376
  s->video_dev.release = & video_device_release_empty;
#line 377
  if ((unsigned int )((unsigned char )((struct cx18_card_video_input  const  *)(& (cx->card)->video_inputs))->video_type) == 1U) {
#line 378
    s->video_dev.tvnorms = cx->tuner_std;
  } else {
#line 380
    s->video_dev.tvnorms = 16777215ULL;
  }
#line 381
  s->video_dev.lock = & cx->serialize_lock;
#line 382
  cx18_set_funcs(& s->video_dev);
#line 383
  return (0);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
int cx18_streams_setup(struct cx18 *cx ) 
{ 
  int type ;
  int ret ;

  {
#line 392
  type = 0;
#line 392
  goto ldv_53816;
  ldv_53815: 
#line 394
  ret = cx18_prep_dev(cx, type);
#line 395
  if (ret < 0) {
#line 396
    goto ldv_53814;
  } else {

  }
#line 399
  ret = cx18_stream_alloc((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
#line 400
  if (ret < 0) {
#line 401
    goto ldv_53814;
  } else {

  }
#line 392
  type = type + 1;
  ldv_53816: ;
#line 392
  if (type <= 6) {
#line 394
    goto ldv_53815;
  } else {

  }
  ldv_53814: ;
#line 403
  if (type == 7) {
#line 404
    return (0);
  } else {

  }
#line 407
  cx18_streams_cleanup(cx, 0);
#line 408
  return (ret);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static int cx18_reg_dev(struct cx18 *cx , int type ) 
{ 
  struct cx18_stream *s ;
  int vfl_type ;
  char const   *name ;
  int num ;
  int ret ;
  struct cx18_stream *s_mpg ;

  {
#line 413
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 414
  vfl_type = cx18_stream_info[type].vfl_type;
#line 418
  if (type == 1 && (unsigned long )s->dvb != (unsigned long )((struct cx18_dvb *)0)) {
#line 419
    ret = cx18_dvb_register(s);
#line 420
    if (ret < 0) {
#line 421
      printk("\v%s: DVB failed to register\n", (char *)(& cx->v4l2_dev.name));
#line 422
      return (ret);
    } else {

    }
  } else {

  }
#line 426
  if ((unsigned long )s->video_dev.v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 427
    return (0);
  } else {

  }
#line 429
  num = (int )s->video_dev.num;
#line 431
  if (type != 0) {
#line 432
    s_mpg = (struct cx18_stream *)(& cx->streams);
#line 434
    if ((unsigned long )s_mpg->video_dev.v4l2_dev != (unsigned long )((struct v4l2_device *)0)) {
#line 435
      num = (int )s_mpg->video_dev.num + cx18_stream_info[type].num_offset;
    } else {

    }
  } else {

  }
#line 438
  video_set_drvdata(& s->video_dev, (void *)s);
#line 441
  ret = video_register_device_no_warn(& s->video_dev, vfl_type, num);
#line 442
  if (ret < 0) {
#line 443
    printk("\v%s: Couldn\'t register v4l2 device for %s (device node number %d)\n",
           (char *)(& cx->v4l2_dev.name), s->name, num);
#line 445
    s->video_dev.v4l2_dev = (struct v4l2_device *)0;
#line 446
    return (ret);
  } else {

  }
#line 449
  name = video_device_node_name(& s->video_dev);
#line 451
  switch (vfl_type) {
  case 0: 
#line 453
  printk("\016%s: Registered device %s for %s (%d x %d.%02d kB)\n", (char *)(& cx->v4l2_dev.name),
         name, s->name, cx->stream_buffers[type], cx->stream_buf_size[type] / 1024,
         ((cx->stream_buf_size[type] * 100) / 1024) % 100);
#line 457
  goto ldv_53828;
  case 2: 
#line 460
  printk("\016%s: Registered device %s for %s\n", (char *)(& cx->v4l2_dev.name), name,
         s->name);
#line 461
  goto ldv_53828;
  case 1: ;
#line 464
  if (cx->stream_buffers[type] != 0) {
#line 465
    printk("\016%s: Registered device %s for %s (%d x %d bytes)\n", (char *)(& cx->v4l2_dev.name),
           name, s->name, cx->stream_buffers[type], cx->stream_buf_size[type]);
  } else {
#line 470
    printk("\016%s: Registered device %s for %s\n", (char *)(& cx->v4l2_dev.name),
           name, s->name);
  }
#line 472
  goto ldv_53828;
  }
  ldv_53828: ;
#line 475
  return (0);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
int cx18_streams_register(struct cx18 *cx ) 
{ 
  int type ;
  int err ;
  int ret ;

  {
#line 483
  ret = 0;
#line 486
  type = 0;
#line 486
  goto ldv_53838;
  ldv_53837: 
#line 487
  err = cx18_reg_dev(cx, type);
#line 488
  if (err != 0 && ret == 0) {
#line 489
    ret = err;
  } else {

  }
#line 486
  type = type + 1;
  ldv_53838: ;
#line 486
  if (type <= 6) {
#line 488
    goto ldv_53837;
  } else {

  }

#line 492
  if (ret == 0) {
#line 493
    return (0);
  } else {

  }
#line 496
  cx18_streams_cleanup(cx, 1);
#line 497
  return (ret);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
void cx18_streams_cleanup(struct cx18 *cx , int unregister ) 
{ 
  struct video_device *vdev ;
  int type ;

  {
#line 507
  type = 0;
#line 507
  goto ldv_53848;
  ldv_53847: ;
#line 510
  if (type == 1) {
#line 511
    if ((unsigned long )cx->streams[type].dvb != (unsigned long )((struct cx18_dvb *)0)) {
#line 512
      if (unregister != 0) {
#line 513
        cx18_dvb_unregister((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
      } else {

      }
#line 514
      kfree((void const   *)cx->streams[type].dvb);
#line 515
      cx->streams[type].dvb = (struct cx18_dvb *)0;
#line 516
      cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
    } else {

    }
#line 518
    goto ldv_53846;
  } else {

  }
#line 522
  if (type == 5) {
#line 524
    if (cx->stream_buffers[type] != 0) {
#line 525
      cx->stream_buffers[type] = 0;
#line 532
      if (cx->streams[type].buffers != 0U) {
#line 533
        cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
      } else {

      }
    } else {

    }
#line 535
    goto ldv_53846;
  } else {

  }
#line 539
  vdev = & cx->streams[type].video_dev;
#line 541
  if ((unsigned long )vdev->v4l2_dev == (unsigned long )((struct v4l2_device *)0)) {
#line 542
    goto ldv_53846;
  } else {

  }
#line 544
  if (type == 2) {
#line 545
    videobuf_mmap_free(& cx->streams[type].vbuf_q);
  } else {

  }
#line 547
  cx18_stream_free((struct cx18_stream *)(& cx->streams) + (unsigned long )type);
#line 549
  video_unregister_device(vdev);
  ldv_53846: 
#line 507
  type = type + 1;
  ldv_53848: ;
#line 507
  if (type <= 6) {
#line 509
    goto ldv_53847;
  } else {

  }

#line 514
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void cx18_vbi_setup(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  int raw ;
  int tmp ;
  u32 data[16U] ;
  int lines ;

  {
#line 555
  cx = s->cx;
#line 556
  tmp = cx18_raw_vbi((struct cx18  const  *)cx);
#line 556
  raw = tmp;
#line 560
  if ((unsigned int )cx->is_60hz != 0U) {
#line 561
    cx->vbi.count = 12U;
#line 562
    cx->vbi.start[0] = 10U;
#line 563
    cx->vbi.start[1] = 273U;
  } else {
#line 565
    cx->vbi.count = 18U;
#line 566
    cx->vbi.start[0] = 6U;
#line 567
    cx->vbi.start[1] = 318U;
  }
#line 571
  if (raw != 0) {
#line 572
    if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 572
      if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct v4l2_vbi_format * ))0)) {
#line 572
        (*((((cx->sd_av)->ops)->vbi)->s_raw_fmt))(cx->sd_av, & cx->vbi.in.fmt.vbi);
      } else {

      }
    } else {

    }
  } else
#line 574
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 574
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             struct v4l2_sliced_vbi_format * ))0)) {
#line 574
      (*((((cx->sd_av)->ops)->vbi)->s_sliced_fmt))(cx->sd_av, & cx->vbi.in.fmt.sliced);
    } else {

    }
  } else {

  }
#line 584
  if (raw != 0) {
#line 585
    lines = (int )(cx->vbi.count * 2U);
  } else {
#line 601
    lines = (unsigned int )cx->is_60hz != 0U ? 36 : 44;
  }
#line 604
  data[0] = s->handle;
#line 606
  data[1] = (u32 )(lines / 2 | (lines / 2 << 16));
#line 608
  data[2] = raw == 0 ? ((unsigned int )cx->is_60hz != 0U ? vbi_hblank_samples_60Hz : vbi_hblank_samples_50Hz) : vbi_active_samples___0;
#line 613
  data[3] = 1U;
#line 618
  if (raw != 0) {
#line 624
    data[4] = 543170656U;
#line 632
    data[5] = 812683472U;
  } else {
#line 648
    data[4] = 2968563952U;
#line 654
    data[5] = 2699075808U;
  }
#line 657
  if ((cx18_debug & 2) != 0) {
#line 657
    printk("\016%s:  info: Setup VBI h: %d lines %x bpl %d fr %d %x %x\n", (char *)(& cx->v4l2_dev.name),
           data[0], data[1], data[2], data[3], data[4], data[5]);
  } else {

  }
#line 660
  cx18_api(cx, 537002006U, 6, (u32 *)(& data));
#line 661
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
void cx18_stream_rotate_idx_mdls(struct cx18 *cx ) 
{ 
  struct cx18_stream *s ;
  struct cx18_mdl *mdl ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 665
  s = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 668
  tmp = cx18_stream_enabled(s);
#line 668
  if (tmp) {
#line 668
    tmp___0 = 0;
  } else {
#line 668
    tmp___0 = 1;
  }
#line 668
  if (tmp___0) {
#line 669
    return;
  } else {

  }
#line 672
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_free.depth));
#line 672
  tmp___2 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 672
  if (tmp___1 + tmp___2 > 2) {
#line 674
    return;
  } else {

  }
#line 677
  tmp___3 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 677
  if (tmp___3 <= 1) {
#line 678
    return;
  } else {

  }
#line 684
  mdl = cx18_dequeue(s, & s->q_full);
#line 685
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 686
    cx18_enqueue(s, mdl, & s->q_free);
  } else {

  }
#line 687
  return;
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static struct cx18_queue *_cx18_stream_put_mdl_fw(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18 *cx ;
  struct cx18_queue *q ;
  struct cx18_queue *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 693
  cx = s->cx;
#line 697
  if (s->handle == 4294967295U) {
#line 700
    tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 700
    return (tmp);
  } else {
#line 697
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& s->s_flags));
#line 697
    if (tmp___0 != 0) {
#line 700
      tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 700
      return (tmp);
    } else {
#line 697
      tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 697
      if (tmp___1 == 0) {
#line 700
        tmp = cx18_enqueue(s, mdl, & s->q_free);
#line 700
        return (tmp);
      } else {

      }
    }
  }
#line 702
  q = cx18_enqueue(s, mdl, & s->q_busy);
#line 703
  if ((unsigned long )(& s->q_busy) != (unsigned long )q) {
#line 704
    return (q);
  } else {

  }
#line 706
  cx18_mdl_sync_for_device(s, mdl);
#line 707
  cx18_vapi(cx, 537133061U, 5, s->handle, (long )((void *)(& (cx->scb)->cpu_mdl) + (unsigned long )mdl->id) - (long )cx->enc_mem,
            s->bufs_per_mdl, mdl->id, s->mdl_size);
#line 710
  return (q);
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void _cx18_stream_load_fw_queue(struct cx18_stream *s ) 
{ 
  struct cx18_queue *q ;
  struct cx18_mdl *mdl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 719
  tmp = atomic_read((atomic_t const   *)(& s->q_free.depth));
#line 719
  if (tmp == 0) {
#line 721
    return;
  } else {
#line 719
    tmp___0 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 719
    if (tmp___0 > 62) {
#line 721
      return;
    } else {

    }
  }
  ldv_53874: 
#line 725
  mdl = cx18_dequeue(s, & s->q_free);
#line 726
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 727
    goto ldv_53873;
  } else {

  }
#line 728
  q = _cx18_stream_put_mdl_fw(s, mdl);
#line 730
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_busy.depth));
#line 730
  if (tmp___1 <= 62 && (unsigned long )(& s->q_busy) == (unsigned long )q) {
#line 732
    goto ldv_53874;
  } else {

  }
  ldv_53873: ;
#line 737
  return;
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
void cx18_out_work_handler(struct work_struct *work ) 
{ 
  struct cx18_stream *s ;
  struct work_struct  const  *__mptr ;

  {
#line 736
  __mptr = (struct work_struct  const  *)work;
#line 736
  s = (struct cx18_stream *)__mptr + 0xfffffffffffff6a0UL;
#line 738
  _cx18_stream_load_fw_queue(s);
#line 739
  return;
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static void cx18_stream_configure_mdls(struct cx18_stream *s ) 
{ 
  int tmp ;

  {
#line 743
  cx18_unload_queues(s);
#line 745
  switch (s->type) {
  case 2: ;
#line 752
  if (s->pixelformat == 842091848U) {
#line 753
    s->mdl_size = (u32 )(((int )(s->cx)->cxhdl.height * 2160) / 2);
  } else {
#line 755
    s->mdl_size = (u32 )((int )(s->cx)->cxhdl.height * 1440);
  }
#line 756
  s->bufs_per_mdl = s->mdl_size / s->buf_size;
#line 757
  if (s->mdl_size % s->buf_size != 0U) {
#line 758
    s->bufs_per_mdl = s->bufs_per_mdl + 1U;
  } else {

  }
#line 759
  goto ldv_53885;
  case 3: 
#line 761
  s->bufs_per_mdl = 1U;
#line 762
  tmp = cx18_raw_vbi((struct cx18  const  *)s->cx);
#line 762
  if (tmp != 0) {
#line 763
    s->mdl_size = ((unsigned int )(s->cx)->is_60hz != 0U ? 24U : 36U) * (unsigned int )vbi_active_samples___0;
  } else {
#line 771
    s->mdl_size = (unsigned int )(s->cx)->is_60hz != 0U ? (unsigned int )vbi_hblank_samples_60Hz * 36U : (unsigned int )vbi_hblank_samples_50Hz * 44U;
  }
#line 775
  goto ldv_53885;
  default: 
#line 777
  s->bufs_per_mdl = 1U;
#line 778
  s->mdl_size = s->buf_size * s->bufs_per_mdl;
#line 779
  goto ldv_53885;
  }
  ldv_53885: 
#line 782
  cx18_load_queues(s);
#line 783
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
int cx18_start_v4l2_encode_stream(struct cx18_stream *s ) 
{ 
  u32 data[6U] ;
  struct cx18 *cx ;
  int captype ;
  struct cx18_stream *s_idx ;
  bool tmp ;
  int tmp___0 ;
  u64 tmp___1 ;
  s32 tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  s32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 788
  cx = s->cx;
#line 789
  captype = 0;
#line 792
  tmp = cx18_stream_enabled(s);
#line 792
  if (tmp) {
#line 792
    tmp___0 = 0;
  } else {
#line 792
    tmp___0 = 1;
  }
#line 792
  if (tmp___0) {
#line 793
    return (-22);
  } else {

  }
#line 795
  if ((cx18_debug & 2) != 0) {
#line 795
    printk("\016%s:  info: Start encoder stream %s\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 797
  switch (s->type) {
  case 0: 
#line 799
  captype = 1;
#line 800
  tmp___1 = 0ULL;
#line 800
  cx->vbi_data_inserted = tmp___1;
#line 800
  cx->mpg_data_received = tmp___1;
#line 801
  cx->dualwatch_jiffies = jiffies;
#line 802
  tmp___2 = v4l2_ctrl_g_ctrl(cx->cxhdl.__annonCompField96.audio_mode);
#line 802
  cx->dualwatch_stereo_mode = (u32 )tmp___2;
#line 803
  cx->search_pack_header = 0;
#line 804
  goto ldv_53896;
  case 5: 
#line 807
  captype = 2;
#line 808
  goto ldv_53896;
  case 1: 
#line 810
  captype = 7;
#line 811
  goto ldv_53896;
  case 2: 
#line 813
  captype = 3;
#line 814
  goto ldv_53896;
  case 4: 
#line 816
  captype = 4;
#line 817
  goto ldv_53896;
  case 3: 
#line 827
  captype = 5;
#line 829
  cx->vbi.frame = 0U;
#line 830
  cx->vbi.inserted_frame = 0U;
#line 831
  memset((void *)(& cx->vbi.sliced_mpeg_size), 0, 128UL);
#line 833
  goto ldv_53896;
  default: ;
#line 835
  return (-22);
  }
  ldv_53896: 
#line 839
  clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 841
  cx18_vapi_result(cx, (u32 *)(& data), 1073741825U, 1, 537001984);
#line 842
  s->handle = data[0];
#line 843
  cx18_vapi(cx, 537001985U, 2, s->handle, captype);
#line 856
  if (captype != 7) {
#line 857
    cx18_vapi(cx, 537002011U, 2, s->handle, 0);
#line 858
    cx18_vapi(cx, 537002005U, 3, s->handle, 3, 1);
#line 859
    cx18_vapi(cx, 537002005U, 3, s->handle, 8, 0);
#line 860
    cx18_vapi(cx, 537002005U, 3, s->handle, 4, 1);
#line 866
    tmp___3 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 866
    if (tmp___3 == 0) {
#line 867
      cx18_vapi(cx, 537002005U, 2, s->handle, 12);
    } else {

    }
#line 876
    cx18_vapi(cx, 537002007U, 3, s->handle, 312, 313);
#line 879
    if ((cx->v4l2_cap & 16U) != 0U) {
#line 880
      cx18_vbi_setup(s);
    } else {

    }
#line 887
    s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 888
    tmp___4 = cx18_stream_enabled(s_idx);
#line 888
    cx18_vapi_result(cx, (u32 *)(& data), 537002000U, 2, s->handle, (int )tmp___4 ? 7 : 0);
#line 892
    cx->cxhdl.priv = (void *)s;
#line 893
    cx2341x_handler_setup(& cx->cxhdl);
#line 899
    if ((unsigned long )cx->cxhdl.__annonCompField99.video_mute == (unsigned long )((struct v4l2_ctrl *)0)) {
#line 899
      tmp___6 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 899
      if (tmp___6 != 0) {
#line 901
        tmp___5 = v4l2_ctrl_g_ctrl(cx->cxhdl.__annonCompField99.video_mute_yuv);
#line 901
        cx18_vapi(cx, 537002003U, 2, s->handle, (tmp___5 << 8) | 1);
      } else {

      }
    } else {

    }
#line 907
    if (captype == 3) {
#line 908
      if (s->pixelformat == 1498831189U) {
#line 909
        cx18_vapi(cx, 537002019U, 2, s->handle, 1);
      } else {
#line 913
        cx18_vapi(cx, 537002019U, 2, s->handle, 0);
      }
    } else {

    }
  } else {

  }
#line 918
  tmp___7 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 918
  if (tmp___7 == 0) {
#line 919
    cx2341x_handler_set_busy(& cx->cxhdl, 1);
#line 920
    clear_bit(4L, (unsigned long volatile   *)(& cx->i_flags));
#line 921
    cx18_write_reg(cx, 7U, 13631564U);
  } else {

  }
#line 924
  cx18_vapi(cx, 537133058U, 3, s->handle, (long )((void *)(& (cx->scb)->cpu_mdl_ack) + (unsigned long )s->type) - (long )cx->enc_mem,
            (long )((void *)(& (cx->scb)->cpu_mdl_ack) + ((unsigned long )s->type + 1UL)) - (long )cx->enc_mem);
#line 929
  cx18_stream_configure_mdls(s);
#line 930
  _cx18_stream_load_fw_queue(s);
#line 933
  tmp___9 = cx18_vapi(cx, 537001986U, 1, s->handle);
#line 933
  if (tmp___9 != 0) {
#line 934
    if (cx18_debug & 1) {
#line 934
      printk("\016%s:  warning: Error starting capture!\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 936
    set_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 937
    if (s->type == 0) {
#line 938
      cx18_vapi(cx, 537001987U, 2, s->handle, 1);
    } else {
#line 940
      cx18_vapi(cx, 537001987U, 1, s->handle);
    }
#line 941
    clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 943
    cx18_vapi(cx, 537133062U, 1, s->handle);
#line 944
    cx18_vapi(cx, 1073741826U, 1, s->handle);
#line 945
    s->handle = 4294967295U;
#line 946
    clear_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 947
    tmp___8 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 947
    if (tmp___8 == 0) {
#line 948
      set_bit(4L, (unsigned long volatile   *)(& cx->i_flags));
#line 949
      cx18_write_reg(cx, 5U, 13631564U);
    } else {

    }
#line 951
    return (-22);
  } else {

  }
#line 955
  if (captype != 7) {
#line 956
    atomic_inc(& cx->ana_capturing);
  } else {

  }
#line 957
  atomic_inc(& cx->tot_capturing);
#line 958
  return (0);
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static char const   __kstrtab_cx18_start_v4l2_encode_stream[30U]  = 
#line 960
  {      'c',      'x',      '1',      '8', 
        '_',      's',      't',      'a', 
        'r',      't',      '_',      'v', 
        '4',      'l',      '2',      '_', 
        'e',      'n',      'c',      'o', 
        'd',      'e',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 960
struct kernel_symbol  const  __ksymtab_cx18_start_v4l2_encode_stream ;
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
struct kernel_symbol  const  __ksymtab_cx18_start_v4l2_encode_stream  =    {(unsigned long )(& cx18_start_v4l2_encode_stream), (char const   *)(& __kstrtab_cx18_start_v4l2_encode_stream)};
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
void cx18_stop_all_captures(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_stream *s ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 966
  i = 6;
#line 966
  goto ldv_53917;
  ldv_53916: 
#line 967
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 969
  tmp = cx18_stream_enabled(s);
#line 969
  if (tmp) {
#line 969
    tmp___0 = 0;
  } else {
#line 969
    tmp___0 = 1;
  }
#line 969
  if (tmp___0) {
#line 970
    goto ldv_53915;
  } else {

  }
#line 971
  tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 971
  if (tmp___1 != 0) {
#line 972
    cx18_stop_v4l2_encode_stream(s, 0);
  } else {

  }
  ldv_53915: 
#line 966
  i = i - 1;
  ldv_53917: ;
#line 966
  if (i >= 0) {
#line 968
    goto ldv_53916;
  } else {

  }

#line 973
  return;
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
int cx18_stop_v4l2_encode_stream(struct cx18_stream *s , int gop_end ) 
{ 
  struct cx18 *cx ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 978
  cx = s->cx;
#line 980
  tmp = cx18_stream_enabled(s);
#line 980
  if (tmp) {
#line 980
    tmp___0 = 0;
  } else {
#line 980
    tmp___0 = 1;
  }
#line 980
  if (tmp___0) {
#line 981
    return (-22);
  } else {

  }
#line 986
  if ((cx18_debug & 2) != 0) {
#line 986
    printk("\016%s:  info: Stop Capture\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 988
  tmp___1 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 988
  if (tmp___1 == 0) {
#line 989
    return (0);
  } else {

  }
#line 991
  set_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 992
  if (s->type == 0) {
#line 993
    cx18_vapi(cx, 537001987U, 2, s->handle, gop_end == 0);
  } else {
#line 995
    cx18_vapi(cx, 537001987U, 1, s->handle);
  }
#line 997
  if (s->type == 0 && gop_end != 0) {
#line 998
    printk("\016%s: ignoring gop_end: not (yet?) supported by the firmware\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1001
  if (s->type != 1) {
#line 1002
    atomic_dec(& cx->ana_capturing);
  } else {

  }
#line 1003
  atomic_dec(& cx->tot_capturing);
#line 1006
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 1009
  cx18_vapi(cx, 537133062U, 1, s->handle);
#line 1011
  cx18_vapi(cx, 1073741826U, 1, s->handle);
#line 1012
  s->handle = 4294967295U;
#line 1013
  clear_bit(9L, (unsigned long volatile   *)(& s->s_flags));
#line 1015
  tmp___2 = atomic_read((atomic_t const   *)(& cx->tot_capturing));
#line 1015
  if (tmp___2 > 0) {
#line 1016
    return (0);
  } else {

  }
#line 1018
  cx2341x_handler_set_busy(& cx->cxhdl, 0);
#line 1019
  cx18_write_reg(cx, 5U, 13631564U);
#line 1020
  __wake_up(& s->waitq, 3U, 1, (void *)0);
#line 1022
  return (0);
}
}
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
static char const   __kstrtab_cx18_stop_v4l2_encode_stream[29U]  = 
#line 1024
  {      'c',      'x',      '1',      '8', 
        '_',      's',      't',      'o', 
        'p',      '_',      'v',      '4', 
        'l',      '2',      '_',      'e', 
        'n',      'c',      'o',      'd', 
        'e',      '_',      's',      't', 
        'r',      'e',      'a',      'm', 
        '\000'};
#line 1024
struct kernel_symbol  const  __ksymtab_cx18_stop_v4l2_encode_stream ;
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
struct kernel_symbol  const  __ksymtab_cx18_stop_v4l2_encode_stream  =    {(unsigned long )(& cx18_stop_v4l2_encode_stream), (char const   *)(& __kstrtab_cx18_stop_v4l2_encode_stream)};
#line 1026 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
u32 cx18_find_handle(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_stream *s ;

  {
#line 1031
  i = 0;
#line 1031
  goto ldv_53938;
  ldv_53937: 
#line 1032
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1034
  if ((unsigned long )s->video_dev.v4l2_dev != (unsigned long )((struct v4l2_device *)0) && s->handle != 4294967295U) {
#line 1035
    return (s->handle);
  } else {

  }
#line 1031
  i = i + 1;
  ldv_53938: ;
#line 1031
  if (i <= 6) {
#line 1033
    goto ldv_53937;
  } else {

  }

#line 1037
  return (4294967295U);
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.c"
struct cx18_stream *cx18_handle_to_stream(struct cx18 *cx , u32 handle ) 
{ 
  int i ;
  struct cx18_stream *s ;
  bool tmp ;

  {
#line 1045
  if (handle == 4294967295U) {
#line 1046
    return ((struct cx18_stream *)0);
  } else {

  }
#line 1048
  i = 0;
#line 1048
  goto ldv_53948;
  ldv_53947: 
#line 1049
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1050
  if (s->handle != handle) {
#line 1051
    goto ldv_53946;
  } else {

  }
#line 1052
  tmp = cx18_stream_enabled(s);
#line 1052
  if ((int )tmp) {
#line 1053
    return (s);
  } else {

  }
  ldv_53946: 
#line 1048
  i = i + 1;
  ldv_53948: ;
#line 1048
  if (i <= 6) {
#line 1050
    goto ldv_53947;
  } else {

  }

#line 1055
  return ((struct cx18_stream *)0);
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_retval_0  ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_retval_1  ;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 274
  if (ldv_work_4_0 == 0) {
#line 275
    ldv_work_struct_4_0 = work;
#line 276
    ldv_work_4_0 = state;
#line 277
    return;
  } else {

  }
#line 280
  if (ldv_work_4_1 == 0) {
#line 281
    ldv_work_struct_4_1 = work;
#line 282
    ldv_work_4_1 = state;
#line 283
    return;
  } else {

  }
#line 286
  if (ldv_work_4_2 == 0) {
#line 287
    ldv_work_struct_4_2 = work;
#line 288
    ldv_work_4_2 = state;
#line 289
    return;
  } else {

  }
#line 292
  if (ldv_work_4_3 == 0) {
#line 293
    ldv_work_struct_4_3 = work;
#line 294
    ldv_work_4_3 = state;
#line 295
    return;
  } else {

  }
#line 297
  return;
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void choose_timer_5(struct timer_list *timer ) 
{ 


  {
#line 301
  LDV_IN_INTERRUPT = 2;
#line 302
  (*(timer->function))(timer->data);
#line 303
  LDV_IN_INTERRUPT = 1;
#line 304
  ldv_timer_state_5 = 2;
#line 305
  return;
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 310
  if (ldv_work_4_0 == state) {
#line 311
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 312
  if (ldv_work_4_1 == state) {
#line 313
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 314
  if (ldv_work_4_2 == state) {
#line 315
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 316
  if (ldv_work_4_3 == state) {
#line 317
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 318
  return;
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_videobuf_queue_ops_17(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 322
  tmp = ldv_init_zalloc(608UL);
#line 322
  cx18_videobuf_qops_group1 = (struct videobuf_queue *)tmp;
#line 323
  tmp___0 = ldv_init_zalloc(240UL);
#line 323
  cx18_videobuf_qops_group2 = (struct videobuf_buffer *)tmp___0;
#line 324
  return;
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 329
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 331
    ldv_work_4_0 = 1;
  } else {

  }
#line 333
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 335
    ldv_work_4_1 = 1;
  } else {

  }
#line 337
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 339
    ldv_work_4_2 = 1;
  } else {

  }
#line 341
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 343
    ldv_work_4_3 = 1;
  } else {

  }
#line 344
  return;
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 349
  ldv_work_4_0 = 0;
#line 350
  ldv_work_4_1 = 0;
#line 351
  ldv_work_4_2 = 0;
#line 352
  ldv_work_4_3 = 0;
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = __VERIFIER_nondet_int();
#line 358
  switch (tmp) {
  case 0: ;
#line 360
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 361
    ldv_work_4_0 = 4;
#line 362
    cx18_out_work_handler(ldv_work_struct_4_0);
#line 363
    ldv_work_4_0 = 1;
  } else {

  }
#line 366
  goto ldv_53977;
  case 1: ;
#line 368
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 369
    ldv_work_4_1 = 4;
#line 370
    cx18_out_work_handler(ldv_work_struct_4_0);
#line 371
    ldv_work_4_1 = 1;
  } else {

  }
#line 374
  goto ldv_53977;
  case 2: ;
#line 376
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 377
    ldv_work_4_2 = 4;
#line 378
    cx18_out_work_handler(ldv_work_struct_4_0);
#line 379
    ldv_work_4_2 = 1;
  } else {

  }
#line 382
  goto ldv_53977;
  case 3: ;
#line 384
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 385
    ldv_work_4_3 = 4;
#line 386
    cx18_out_work_handler(ldv_work_struct_4_0);
#line 387
    ldv_work_4_3 = 1;
  } else {

  }
#line 390
  goto ldv_53977;
  default: 
#line 391
  ldv_stop();
  }
  ldv_53977: ;
#line 393
  return;
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 397
  if ((unsigned long )ldv_timer_list_5 == (unsigned long )timer) {
#line 398
    if (ldv_timer_state_5 == 2 || pending_flag != 0) {
#line 399
      ldv_timer_list_5 = timer;
#line 400
      ldv_timer_list_5->data = data;
#line 401
      ldv_timer_state_5 = 1;
    } else {

    }
#line 403
    return;
  } else {

  }
#line 405
  reg_timer_5(timer);
#line 406
  ldv_timer_list_5->data = data;
#line 407
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 411
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_5) {
#line 412
    ldv_timer_state_5 = 0;
#line 413
    return;
  } else {

  }
#line 415
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int reg_timer_5(struct timer_list *timer ) 
{ 


  {
#line 419
  ldv_timer_list_5 = timer;
#line 420
  ldv_timer_state_5 = 1;
#line 421
  return (0);
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 427
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 429
    cx18_out_work_handler(work);
#line 430
    ldv_work_4_0 = 1;
#line 431
    return;
  } else {

  }
#line 433
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 435
    cx18_out_work_handler(work);
#line 436
    ldv_work_4_1 = 1;
#line 437
    return;
  } else {

  }
#line 439
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 441
    cx18_out_work_handler(work);
#line 442
    ldv_work_4_2 = 1;
#line 443
    return;
  } else {

  }
#line 445
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 447
    cx18_out_work_handler(work);
#line 448
    ldv_work_4_3 = 1;
#line 449
    return;
  } else {

  }
#line 451
  return;
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_initialize_v4l2_file_operations_18(void) 
{ 
  void *tmp ;

  {
#line 455
  tmp = __VERIFIER_nondet_pointer();
#line 455
  cx18_v4l2_enc_fops_group0 = (struct file *)tmp;
#line 456
  return;
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  struct poll_table_struct *ldvarg15 ;
  void *tmp ;
  loff_t *ldvarg16 ;
  void *tmp___0 ;
  struct vm_area_struct *ldvarg19 ;
  void *tmp___1 ;
  unsigned long ldvarg13 ;
  unsigned int ldvarg14 ;
  size_t ldvarg17 ;
  char *ldvarg18 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 460
  tmp = ldv_init_zalloc(16UL);
#line 460
  ldvarg15 = (struct poll_table_struct *)tmp;
#line 461
  tmp___0 = ldv_init_zalloc(8UL);
#line 461
  ldvarg16 = (loff_t *)tmp___0;
#line 462
  tmp___1 = ldv_init_zalloc(184UL);
#line 462
  ldvarg19 = (struct vm_area_struct *)tmp___1;
#line 466
  tmp___2 = ldv_init_zalloc(1UL);
#line 466
  ldvarg18 = (char *)tmp___2;
#line 463
  ldv_memset((void *)(& ldvarg13), 0, 8UL);
#line 464
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
#line 465
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
#line 468
  tmp___3 = __VERIFIER_nondet_int();
#line 468
  switch (tmp___3) {
  case 0: ;
#line 471
  if (ldv_state_variable_18 == 1) {
#line 473
    cx18_v4l2_mmap(cx18_v4l2_enc_fops_group0, ldvarg19);
#line 475
    ldv_state_variable_18 = 1;
  } else {

  }
#line 478
  if (ldv_state_variable_18 == 2) {
#line 480
    cx18_v4l2_mmap(cx18_v4l2_enc_fops_group0, ldvarg19);
#line 482
    ldv_state_variable_18 = 2;
  } else {

  }
#line 485
  goto ldv_54012;
  case 1: ;
#line 488
  if (ldv_state_variable_18 == 2) {
#line 490
    cx18_v4l2_close(cx18_v4l2_enc_fops_group0);
#line 492
    ldv_state_variable_18 = 1;
#line 493
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 496
  goto ldv_54012;
  case 2: ;
#line 499
  if (ldv_state_variable_18 == 2) {
#line 501
    cx18_v4l2_read(cx18_v4l2_enc_fops_group0, ldvarg18, ldvarg17, ldvarg16);
#line 503
    ldv_state_variable_18 = 2;
  } else {

  }
#line 506
  goto ldv_54012;
  case 3: ;
#line 509
  if (ldv_state_variable_18 == 1) {
#line 511
    cx18_v4l2_enc_poll(cx18_v4l2_enc_fops_group0, ldvarg15);
#line 513
    ldv_state_variable_18 = 1;
  } else {

  }
#line 516
  if (ldv_state_variable_18 == 2) {
#line 518
    cx18_v4l2_enc_poll(cx18_v4l2_enc_fops_group0, ldvarg15);
#line 520
    ldv_state_variable_18 = 2;
  } else {

  }
#line 523
  goto ldv_54012;
  case 4: ;
#line 526
  if (ldv_state_variable_18 == 1) {
#line 528
    ldv_retval_1 = cx18_v4l2_open(cx18_v4l2_enc_fops_group0);
#line 530
    if (ldv_retval_1 == 0) {
#line 531
      ldv_state_variable_18 = 2;
#line 532
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 536
  goto ldv_54012;
  case 5: ;
#line 539
  if (ldv_state_variable_18 == 1) {
#line 541
    video_ioctl2(cx18_v4l2_enc_fops_group0, ldvarg14, ldvarg13);
#line 543
    ldv_state_variable_18 = 1;
  } else {

  }
#line 546
  if (ldv_state_variable_18 == 2) {
#line 548
    video_ioctl2(cx18_v4l2_enc_fops_group0, ldvarg14, ldvarg13);
#line 550
    ldv_state_variable_18 = 2;
  } else {

  }
#line 553
  goto ldv_54012;
  default: 
#line 554
  ldv_stop();
  }
  ldv_54012: ;
#line 558
  return;
}
}
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  enum v4l2_field ldvarg9 ;
  unsigned int *ldvarg10 ;
  void *tmp ;
  unsigned int *ldvarg11 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 562
  tmp = ldv_init_zalloc(4UL);
#line 562
  ldvarg10 = (unsigned int *)tmp;
#line 563
  tmp___0 = ldv_init_zalloc(4UL);
#line 563
  ldvarg11 = (unsigned int *)tmp___0;
#line 561
  ldv_memset((void *)(& ldvarg9), 0, 4UL);
#line 565
  tmp___1 = __VERIFIER_nondet_int();
#line 565
  switch (tmp___1) {
  case 0: ;
#line 568
  if (ldv_state_variable_17 == 1) {
#line 570
    buffer_setup(cx18_videobuf_qops_group1, ldvarg11, ldvarg10);
#line 572
    ldv_state_variable_17 = 1;
  } else {

  }
#line 575
  if (ldv_state_variable_17 == 2) {
#line 577
    buffer_setup(cx18_videobuf_qops_group1, ldvarg11, ldvarg10);
#line 579
    ldv_state_variable_17 = 2;
  } else {

  }
#line 582
  goto ldv_54026;
  case 1: ;
#line 585
  if (ldv_state_variable_17 == 2) {
#line 587
    buffer_release(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 589
    ldv_state_variable_17 = 1;
#line 590
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 593
  goto ldv_54026;
  case 2: ;
#line 596
  if (ldv_state_variable_17 == 1) {
#line 598
    buffer_queue(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 600
    ldv_state_variable_17 = 1;
  } else {

  }
#line 603
  if (ldv_state_variable_17 == 2) {
#line 605
    buffer_queue(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2);
#line 607
    ldv_state_variable_17 = 2;
  } else {

  }
#line 610
  goto ldv_54026;
  case 3: ;
#line 613
  if (ldv_state_variable_17 == 1) {
#line 615
    ldv_retval_0 = buffer_prepare(cx18_videobuf_qops_group1, cx18_videobuf_qops_group2,
                                  ldvarg9);
#line 617
    if (ldv_retval_0 == 0) {
#line 618
      ldv_state_variable_17 = 2;
#line 619
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 623
  goto ldv_54026;
  default: 
#line 624
  ldv_stop();
  }
  ldv_54026: ;
#line 628
  return;
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 657
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 657
  ldv_func_res = tmp;
#line 659
  activate_work_2(ldv_func_arg3, 2);
#line 661
  return (ldv_func_res);
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
bool ldv_queue_delayed_work_on_260(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 668
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 668
  ldv_func_res = tmp;
#line 670
  activate_work_2(& ldv_func_arg3->work, 2);
#line 672
  return (ldv_func_res);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
bool ldv_queue_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 679
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 679
  ldv_func_res = tmp;
#line 681
  activate_work_2(ldv_func_arg3, 2);
#line 683
  return (ldv_func_res);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_flush_workqueue_262(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 689
  flush_workqueue(ldv_func_arg1);
#line 691
  call_and_disable_all_2(2);
#line 692
  return;
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
bool ldv_queue_delayed_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 698
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 698
  ldv_func_res = tmp;
#line 700
  activate_work_2(& ldv_func_arg3->work, 2);
#line 702
  return (ldv_func_res);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 708
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 710
  mutex_lock(ldv_func_arg1);
#line 711
  return;
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 716
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 718
  mutex_unlock(ldv_func_arg1);
#line 719
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_unlock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 724
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 726
  mutex_unlock(ldv_func_arg1);
#line 727
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 732
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 734
  mutex_lock(ldv_func_arg1);
#line 735
  return;
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 740
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 742
  mutex_lock(ldv_func_arg1);
#line 743
  return;
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
int ldv_mutex_trylock_269(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 749
  tmp = mutex_trylock(ldv_func_arg1);
#line 749
  ldv_func_res = tmp;
#line 751
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 751
  return (tmp___0);
#line 753
  return (ldv_func_res);
}
}
#line 756 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 759
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 761
  mutex_unlock(ldv_func_arg1);
#line 762
  return;
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 767
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 769
  mutex_lock(ldv_func_arg1);
#line 770
  return;
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 775
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 777
  mutex_unlock(ldv_func_arg1);
#line 778
  return;
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 783
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 785
  mutex_lock(ldv_func_arg1);
#line 786
  return;
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-streams.o.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 791
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 793
  mutex_unlock(ldv_func_arg1);
#line 794
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 113 "include/linux/list.h"
extern void list_del(struct list_head * ) ;
#line 111 "include/linux/string.h"
extern void *memchr(void const   * , int  , __kernel_size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_305(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_301(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_310(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_312(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) ;
#line 221
void ldv_mutex_unlock_321(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_300(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_304(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_311(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_313(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) ;
#line 153
void ldv_mutex_lock_serialize_lock_of_cx18(struct mutex *lock ) ;
#line 157
void ldv_mutex_unlock_serialize_lock_of_cx18(struct mutex *lock ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
#line 373
  return;
}
}
#line 924 "include/linux/wait.h"
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 931
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_295(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_296(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_298(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_295(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___0(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___0(system_wq, work);
#line 530
  return (tmp);
}
}
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 652 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 64 "include/linux/poll.h"
__inline static unsigned long poll_requested_events(poll_table const   *p ) 
{ 


  {
#line 66
  return ((unsigned long )p != (unsigned long )((poll_table const   *)0) ? (unsigned long )p->_key : 0xffffffffffffffffUL);
}
}
#line 207 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 209
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 209
  return (tmp);
}
}
#line 217
extern struct video_device *video_devdata(struct file * ) ;
#line 60 "include/media/v4l2-fh.h"
extern void v4l2_fh_init(struct v4l2_fh * , struct video_device * ) ;
#line 65
extern void v4l2_fh_add(struct v4l2_fh * ) ;
#line 78
extern void v4l2_fh_del(struct v4l2_fh * ) ;
#line 85
extern void v4l2_fh_exit(struct v4l2_fh * ) ;
#line 97
extern int v4l2_fh_is_singular(struct v4l2_fh * ) ;
#line 102 "include/media/v4l2-fh.h"
__inline static int v4l2_fh_is_singular_file(struct file *filp ) 
{ 
  int tmp ;

  {
#line 104
  tmp = v4l2_fh_is_singular((struct v4l2_fh *)filp->private_data);
#line 104
  return (tmp);
}
}
#line 376 "include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_lock(struct v4l2_ctrl *ctrl ) 
{ 


  {
#line 378
  ldv_mutex_lock_307((ctrl->handler)->lock);
#line 379
  return;
}
}
#line 385 "include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_unlock(struct v4l2_ctrl *ctrl ) 
{ 


  {
#line 387
  ldv_mutex_unlock_308((ctrl->handler)->lock);
#line 388
  return;
}
}
#line 710
extern int __v4l2_ctrl_s_ctrl(struct v4l2_ctrl * , s32  ) ;
#line 721 "include/media/v4l2-ctrls.h"
__inline static int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl , s32 val ) 
{ 
  int rval ;

  {
#line 725
  v4l2_ctrl_lock(ctrl);
#line 726
  rval = __v4l2_ctrl_s_ctrl(ctrl, val);
#line 727
  v4l2_ctrl_unlock(ctrl);
#line 729
  return (rval);
}
}
#line 216 "include/media/videobuf-core.h"
extern ssize_t videobuf_read_stream(struct videobuf_queue * , char * , size_t  , loff_t * ,
                                    int  , int  ) ;
#line 222
extern unsigned int videobuf_poll_stream(struct file * , struct videobuf_queue * ,
                                         poll_table * ) ;
#line 233
extern int videobuf_mmap_mapper(struct videobuf_queue * , struct vm_area_struct * ) ;
#line 436 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18_open_id *fh2id(struct v4l2_fh *fh ) 
{ 
  struct v4l2_fh  const  *__mptr ;

  {
#line 438
  __mptr = (struct v4l2_fh  const  *)fh;
#line 438
  return ((struct cx18_open_id *)__mptr);
}
}
#line 441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
__inline static struct cx18_open_id *file2id(struct file *file ) 
{ 
  struct cx18_open_id *tmp ;

  {
#line 443
  tmp = fh2id((struct v4l2_fh *)file->private_data);
#line 443
  return (tmp);
}
}
#line 32 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-fileops.h"
int cx18_start_capture(struct cx18_open_id *id ) ;
#line 33
void cx18_stop_capture(struct cx18_open_id *id , int gop_end ) ;
#line 34
void cx18_mute(struct cx18 *cx ) ;
#line 35
void cx18_unmute(struct cx18 *cx ) ;
#line 40
int cx18_claim_stream(struct cx18_open_id *id , int type ) ;
#line 41
void cx18_release_stream(struct cx18_stream *s ) ;
#line 59 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-queue.h"
__inline static void cx18_mdl_swap(struct cx18_mdl *mdl ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 61
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 61
  if (tmp != 0) {
#line 62
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 62
    cx18_buf_swap((struct cx18_buffer *)__mptr);
  } else {
#line 65
    _cx18_mdl_swap(mdl);
  }
#line 66
  return;
}
}
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-vbi.h"
void cx18_process_vbi_data(struct cx18 *cx , struct cx18_mdl *mdl , int streamtype ) ;
#line 24 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-audio.h"
int cx18_audio_set_io(struct cx18 *cx ) ;
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_load_fw_queue(struct cx18_stream *s ) 
{ 


  {
#line 45
  schedule_work___0(& s->out_work_order);
#line 46
  return;
}
}
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_put_mdl_fw(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 


  {
#line 52
  cx18_enqueue(s, mdl, & s->q_free);
#line 53
  cx18_stream_load_fw_queue(s);
#line 54
  return;
}
}
#line 126 "include/media/v4l2-event.h"
extern int v4l2_event_pending(struct v4l2_fh * ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
int cx18_claim_stream(struct cx18_open_id *id , int type ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_assoc ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 46
  cx = id->cx;
#line 47
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )type;
#line 51
  if (type == 5) {
#line 52
    printk("\f%s: MPEG Index stream cannot be claimed directly, but something tried.\n",
           (char *)(& cx->v4l2_dev.name));
#line 54
    return (-22);
  } else {

  }
#line 57
  tmp = test_and_set_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 57
  if (tmp != 0) {
#line 59
    if (s->id == id->open_id) {
#line 61
      return (0);
    } else {

    }
#line 63
    if (s->id == 4294967295U && type == 3) {
#line 67
      s->id = id->open_id;
#line 68
      if ((cx18_debug & 2) != 0) {
#line 68
        printk("\016%s:  info: Start Read VBI\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 69
      return (0);
    } else {

    }
#line 72
    if ((cx18_debug & 2) != 0) {
#line 72
      printk("\016%s:  info: Stream %d is busy\n", (char *)(& cx->v4l2_dev.name),
             type);
    } else {

    }
#line 73
    return (-16);
  } else {

  }
#line 75
  s->id = id->open_id;
#line 85
  if (type != 0) {
#line 86
    return (0);
  } else {

  }
#line 88
  s_assoc = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 89
  if (cx->vbi.insert_mpeg != 0) {
#line 89
    tmp___2 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 89
    if (tmp___2 == 0) {
#line 90
      s_assoc = (struct cx18_stream *)(& cx->streams) + 3UL;
    } else {
#line 89
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 91
    tmp___0 = cx18_stream_enabled(s_assoc);
#line 91
    if (tmp___0) {
#line 91
      tmp___1 = 0;
    } else {
#line 91
      tmp___1 = 1;
    }
#line 91
    if (tmp___1) {
#line 92
      return (0);
    } else {

    }
  }
#line 94
  set_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 97
  set_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 98
  return (0);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static char const   __kstrtab_cx18_claim_stream[18U]  = 
#line 100
  {      'c',      'x',      '1',      '8', 
        '_',      'c',      'l',      'a', 
        'i',      'm',      '_',      's', 
        't',      'r',      'e',      'a', 
        'm',      '\000'};
#line 100
struct kernel_symbol  const  __ksymtab_cx18_claim_stream ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
struct kernel_symbol  const  __ksymtab_cx18_claim_stream  =    {(unsigned long )(& cx18_claim_stream), (char const   *)(& __kstrtab_cx18_claim_stream)};
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
void cx18_release_stream(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s_assoc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 106
  cx = s->cx;
#line 109
  s->id = 4294967295U;
#line 110
  if (s->type == 5) {
#line 115
    return;
  } else {

  }
#line 118
  if (s->type == 3) {
#line 118
    tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 118
    if (tmp != 0) {
#line 121
      return;
    } else {

    }
  } else {

  }
#line 123
  tmp___0 = test_and_clear_bit(3L, (unsigned long volatile   *)(& s->s_flags));
#line 123
  if (tmp___0 == 0) {
#line 124
    if (cx18_debug & 1) {
#line 124
      printk("\016%s:  warning: Release stream %s not in use!\n", (char *)(& cx->v4l2_dev.name),
             s->name);
    } else {

    }
#line 125
    return;
  } else {

  }
#line 128
  cx18_flush_queues(s);
#line 136
  if (s->type != 0) {
#line 137
    return;
  } else {

  }
#line 140
  s_assoc = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 141
  tmp___1 = test_and_clear_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 141
  if (tmp___1 != 0) {
#line 142
    clear_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 143
    cx18_flush_queues(s_assoc);
  } else {

  }
#line 147
  s_assoc = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 148
  tmp___2 = test_and_clear_bit(5L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 148
  if (tmp___2 != 0) {
#line 149
    if (s_assoc->id == 4294967295U) {
#line 154
      clear_bit(3L, (unsigned long volatile   *)(& s_assoc->s_flags));
#line 155
      cx18_flush_queues(s_assoc);
    } else {

    }
  } else {

  }
#line 157
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static char const   __kstrtab_cx18_release_stream[20U]  = 
#line 159
  {      'c',      'x',      '1',      '8', 
        '_',      'r',      'e',      'l', 
        'e',      'a',      's',      'e', 
        '_',      's',      't',      'r', 
        'e',      'a',      'm',      '\000'};
#line 159
struct kernel_symbol  const  __ksymtab_cx18_release_stream ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
struct kernel_symbol  const  __ksymtab_cx18_release_stream  =    {(unsigned long )(& cx18_release_stream), (char const   *)(& __kstrtab_cx18_release_stream)};
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static void cx18_dualwatch(struct cx18 *cx ) 
{ 
  struct v4l2_tuner vt ;
  u32 new_stereo_mode ;
  u32 dual ;
  s32 tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 165
  dual = 512U;
#line 167
  tmp = v4l2_ctrl_g_ctrl(cx->cxhdl.__annonCompField96.audio_mode);
#line 167
  new_stereo_mode = (u32 )tmp;
#line 168
  memset((void *)(& vt), 0, 84UL);
#line 169
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 169
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 169
  goto ldv_53730;
  ldv_53729: ;
#line 169
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 169
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, & vt);
  } else {

  }
#line 169
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 169
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53730: ;
#line 169
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 171
    goto ldv_53729;
  } else {

  }

#line 170
  if (vt.audmode == 4U && (vt.rxsubchans & 4U) != 0U) {
#line 172
    new_stereo_mode = dual;
  } else {

  }
#line 174
  if (cx->dualwatch_stereo_mode == new_stereo_mode) {
#line 175
    return;
  } else {

  }
#line 177
  if ((cx18_debug & 2) != 0) {
#line 177
    printk("\016%s:  info: dualwatch: change stereo flag from 0x%x to 0x%x.\n", (char *)(& cx->v4l2_dev.name),
           cx->dualwatch_stereo_mode, new_stereo_mode);
  } else {

  }
#line 179
  tmp___0 = v4l2_ctrl_s_ctrl(cx->cxhdl.__annonCompField96.audio_mode, (s32 )new_stereo_mode);
#line 179
  if (tmp___0 != 0) {
#line 180
    if ((cx18_debug & 2) != 0) {
#line 180
      printk("\016%s:  info: dualwatch: changing stereo flag failed\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
  } else {

  }
#line 181
  return;
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static struct cx18_mdl *cx18_get_mdl(struct cx18_stream *s , int non_block , int *err ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s_vbi ;
  struct cx18_mdl *mdl ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;

  {
#line 187
  cx = s->cx;
#line 188
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 190
  tmp = get_current();
#line 190
  wait.flags = 0U;
#line 190
  wait.private = (void *)tmp;
#line 190
  wait.func = & autoremove_wake_function;
#line 190
  wait.task_list.next = & wait.task_list;
#line 190
  wait.task_list.prev = & wait.task_list;
#line 192
  *err = 0;
  ldv_53750: ;
#line 194
  if (s->type == 0) {
#line 196
    tmp___0 = msecs_to_jiffies(1000U);
#line 196
    if ((long )((cx->dualwatch_jiffies + tmp___0) - (unsigned long )jiffies) < 0L) {
#line 197
      cx->dualwatch_jiffies = jiffies;
#line 198
      cx18_dualwatch(cx);
    } else {

    }
#line 200
    tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 200
    if (tmp___1 != 0) {
#line 200
      tmp___2 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 200
      if (tmp___2 == 0) {
#line 202
        goto ldv_53748;
        ldv_53747: 
#line 205
        cx18_process_vbi_data(cx, mdl, s_vbi->type);
#line 207
        cx18_stream_put_mdl_fw(s_vbi, mdl);
        ldv_53748: 
#line 202
        mdl = cx18_dequeue(s_vbi, & s_vbi->q_full);
#line 202
        if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 204
          goto ldv_53747;
        } else {

        }

      } else {

      }
    } else {

    }
#line 210
    mdl = & cx->vbi.sliced_mpeg_mdl;
#line 211
    if (mdl->readpos != mdl->bytesused) {
#line 212
      return (mdl);
    } else {

    }
  } else {

  }
#line 216
  mdl = cx18_dequeue(s, & s->q_full);
#line 217
  if ((unsigned long )mdl != (unsigned long )((struct cx18_mdl *)0)) {
#line 218
    tmp___3 = test_and_clear_bit(0L, (unsigned long volatile   *)(& mdl->m_flags));
#line 218
    if (tmp___3 == 0) {
#line 220
      return (mdl);
    } else {

    }
#line 221
    if (s->type == 0) {
#line 223
      cx18_mdl_swap(mdl);
    } else {
#line 226
      cx18_process_vbi_data(cx, mdl, s->type);
    }
#line 228
    return (mdl);
  } else {

  }
#line 232
  tmp___4 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 232
  if (tmp___4 == 0) {
#line 233
    if ((cx18_debug & 2) != 0) {
#line 233
      printk("\016%s:  info: EOS %s\n", (char *)(& cx->v4l2_dev.name), s->name);
    } else {

    }
#line 234
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 238
  if (non_block != 0) {
#line 239
    *err = -11;
#line 240
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 244
  prepare_to_wait(& s->waitq, & wait, 1);
#line 247
  tmp___5 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 247
  if (tmp___5 == 0) {
#line 248
    schedule();
  } else {

  }
#line 249
  finish_wait(& s->waitq, & wait);
#line 250
  tmp___6 = get_current();
#line 250
  tmp___7 = signal_pending(tmp___6);
#line 250
  if (tmp___7 != 0) {
#line 252
    if ((cx18_debug & 2) != 0) {
#line 252
      printk("\016%s:  info: User stopped %s\n", (char *)(& cx->v4l2_dev.name), s->name);
    } else {

    }
#line 253
    *err = -4;
#line 254
    return ((struct cx18_mdl *)0);
  } else {

  }
#line 256
  goto ldv_53750;
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static void cx18_setup_sliced_vbi_mdl(struct cx18 *cx ) 
{ 
  struct cx18_mdl *mdl ;
  struct cx18_buffer *buf ;
  int idx ;

  {
#line 261
  mdl = & cx->vbi.sliced_mpeg_mdl;
#line 262
  buf = & cx->vbi.sliced_mpeg_buf;
#line 263
  idx = (int )cx->vbi.inserted_frame & 31;
#line 265
  buf->buf = (char *)cx->vbi.sliced_mpeg_data[idx];
#line 266
  buf->bytesused = cx->vbi.sliced_mpeg_size[idx];
#line 267
  buf->readpos = 0U;
#line 269
  mdl->curr_buf = (struct cx18_buffer *)0;
#line 270
  mdl->bytesused = cx->vbi.sliced_mpeg_size[idx];
#line 271
  mdl->readpos = 0U;
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static size_t cx18_copy_buf_to_user(struct cx18_stream *s , struct cx18_buffer *buf ,
                                    char *ubuf , size_t ucount , bool *stop ) 
{ 
  struct cx18 *cx ;
  size_t len ;
  char const   *start ;
  char const   *p ;
  u8 const   *q ;
  u8 ch ;
  int stuffing ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 277
  cx = s->cx;
#line 278
  len = (size_t )(buf->bytesused - buf->readpos);
#line 280
  *stop = 0;
#line 281
  if (len > ucount) {
#line 282
    len = ucount;
  } else {

  }
#line 283
  if (cx->vbi.insert_mpeg != 0 && s->type == 0) {
#line 283
    tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 283
    if (tmp___0 == 0) {
#line 283
      if ((unsigned long )(& cx->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 304
        start = (char const   *)buf->buf + (unsigned long )buf->readpos;
#line 305
        p = start + 1UL;
#line 307
        ch = cx->search_pack_header != 0 ? 186U : 224U;
#line 310
        goto ldv_53773;
        ldv_53777: 
#line 312
        tmp = memchr((void const   *)p, 0, (__kernel_size_t )((long )(start + len) - (long )p));
#line 312
        q = (u8 const   *)tmp;
#line 313
        if ((unsigned long )q == (unsigned long )((u8 const   *)0U)) {
#line 314
          goto ldv_53772;
        } else {

        }
#line 315
        p = (char const   *)q + 1U;
#line 321
        if ((((unsigned long )((char *)q + 15UL) >= (unsigned long )(buf->buf + (unsigned long )buf->bytesused) || (unsigned int )((unsigned char )*(q + 1UL)) != 0U) || (unsigned int )((unsigned char )*(q + 2UL)) != 1U) || (int )((unsigned char )*(q + 3UL)) != (int )ch) {
#line 323
          goto ldv_53773;
        } else {

        }
#line 326
        if (cx->search_pack_header == 0) {
#line 328
          if (((int )*(q + 6UL) & 192) != 128) {
#line 329
            goto ldv_53773;
          } else {

          }
#line 331
          if ((((int )*(q + 7UL) & 192) == 128 && ((int )*(q + 9UL) & 240) == 32) || (((int )*(q + 7UL) & 192) == 192 && ((int )*(q + 9UL) & 240) == 48)) {
#line 336
            ch = 186U;
#line 337
            cx->search_pack_header = 1;
#line 338
            p = (char const   *)q + 9U;
          } else {

          }
#line 340
          goto ldv_53773;
        } else {

        }
#line 346
        stuffing = (int )*(q + 13UL) & 7;
#line 348
        i = 0;
#line 348
        goto ldv_53776;
        ldv_53775: ;
#line 349
        if ((unsigned int )((unsigned char )*(q + (unsigned long )(i + 14))) != 255U) {
#line 350
          goto ldv_53774;
        } else {

        }
#line 348
        i = i + 1;
        ldv_53776: ;
#line 348
        if (i < stuffing) {
#line 350
          goto ldv_53775;
        } else {

        }
        ldv_53774: ;
#line 351
        if (((((i == stuffing && ((int )*(q + 4UL) & 196) == 68) && ((int )*(q + 12UL) & 3) == 3) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 14))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 15))) == 0U) && (unsigned int )((unsigned char )*(q + (unsigned long )(stuffing + 16))) == 1U) {
#line 358
          cx->search_pack_header = 0;
#line 359
          len = (size_t )((long )q - (long )start);
#line 360
          cx18_setup_sliced_vbi_mdl(cx);
#line 361
          *stop = 1;
#line 362
          goto ldv_53772;
        } else {

        }
        ldv_53773: ;
#line 310
        if ((unsigned long )(start + len) > (unsigned long )p) {
#line 312
          goto ldv_53777;
        } else {

        }
        ldv_53772: ;
      } else {

      }
    } else {

    }
  } else {

  }
#line 366
  tmp___1 = copy_to_user((void *)ubuf, (void const   *)buf->buf + (unsigned long )buf->readpos,
                         len);
#line 366
  if (tmp___1 != 0UL) {
#line 367
    if (cx18_debug & 1) {
#line 367
      printk("\016%s:  warning: copy %zd bytes to user failed for %s\n", (char *)(& cx->v4l2_dev.name),
             len, s->name);
    } else {

    }
#line 369
    return (0xfffffffffffffff2UL);
  } else {

  }
#line 371
  buf->readpos = buf->readpos + (u32 )len;
#line 372
  if (s->type == 0 && (unsigned long )(& cx->vbi.sliced_mpeg_buf) != (unsigned long )buf) {
#line 374
    cx->mpg_data_received = cx->mpg_data_received + (unsigned long long )len;
  } else {

  }
#line 375
  return (len);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static size_t cx18_copy_mdl_to_user(struct cx18_stream *s , struct cx18_mdl *mdl ,
                                    char *ubuf , size_t ucount ) 
{ 
  size_t tot_written ;
  int rc ;
  bool stop ;
  struct list_head  const  *__mptr ;
  size_t tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 381
  tot_written = 0UL;
#line 383
  stop = 0;
#line 385
  if ((unsigned long )mdl->curr_buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 386
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 386
    mdl->curr_buf = (struct cx18_buffer *)__mptr;
  } else {

  }
#line 389
  if ((unsigned long )(& (mdl->curr_buf)->list) == (unsigned long )(& mdl->buf_list)) {
#line 395
    mdl->readpos = mdl->bytesused;
#line 396
    return (0UL);
  } else {

  }
#line 399
  goto ldv_53794;
  ldv_53793: ;
#line 401
  if ((mdl->curr_buf)->readpos >= (mdl->curr_buf)->bytesused) {
#line 402
    goto ldv_53791;
  } else {

  }
#line 404
  tmp = cx18_copy_buf_to_user(s, mdl->curr_buf, ubuf + tot_written, ucount - tot_written,
                              & stop);
#line 404
  rc = (int )tmp;
#line 406
  if (rc < 0) {
#line 407
    return ((size_t )rc);
  } else {

  }
#line 408
  mdl->readpos = mdl->readpos + (u32 )rc;
#line 409
  tot_written = (size_t )rc + tot_written;
#line 411
  if ((((int )stop || tot_written >= ucount) || (mdl->curr_buf)->readpos < (mdl->curr_buf)->bytesused) || mdl->readpos >= mdl->bytesused) {
#line 415
    goto ldv_53792;
  } else {

  }
  ldv_53791: 
#line 399
  __mptr___0 = (struct list_head  const  *)(mdl->curr_buf)->list.next;
#line 399
  mdl->curr_buf = (struct cx18_buffer *)__mptr___0;
  ldv_53794: ;
#line 399
  if ((unsigned long )(& (mdl->curr_buf)->list) != (unsigned long )(& mdl->buf_list)) {
#line 401
    goto ldv_53793;
  } else {

  }
  ldv_53792: ;
#line 417
  return (tot_written);
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static ssize_t cx18_read(struct cx18_stream *s , char *ubuf , size_t tot_count , int non_block ) 
{ 
  struct cx18 *cx ;
  size_t tot_written ;
  int single_frame ;
  int tmp ;
  int tmp___0 ;
  struct cx18_mdl *mdl ;
  int rc ;
  size_t tmp___1 ;
  int idx ;

  {
#line 423
  cx = s->cx;
#line 424
  tot_written = 0UL;
#line 425
  single_frame = 0;
#line 427
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 427
  if (tmp == 0 && s->id == 4294967295U) {
#line 429
    if (cx18_debug & 1) {
#line 429
      printk("\016%s:  warning: Stream %s not initialized before read\n", (char *)(& cx->v4l2_dev.name),
             s->name);
    } else {

    }
#line 431
    return (-5L);
  } else {

  }
#line 437
  if (s->type == 3) {
#line 437
    tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 437
    if (tmp___0 == 0) {
#line 438
      single_frame = 1;
    } else {

    }
  } else {

  }
  ldv_53808: 
#line 444
  mdl = cx18_get_mdl(s, non_block, & rc);
#line 446
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 448
    if (tot_written != 0UL) {
#line 449
      goto ldv_53806;
    } else {

    }
#line 451
    if (rc == 0) {
#line 452
      clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 453
      clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 454
      cx18_release_stream(s);
    } else {

    }
#line 457
    return ((ssize_t )rc);
  } else {

  }
#line 460
  tmp___1 = cx18_copy_mdl_to_user(s, mdl, ubuf + tot_written, tot_count - tot_written);
#line 460
  rc = (int )tmp___1;
#line 463
  if ((unsigned long )(& cx->vbi.sliced_mpeg_mdl) != (unsigned long )mdl) {
#line 464
    if (mdl->readpos == mdl->bytesused) {
#line 465
      cx18_stream_put_mdl_fw(s, mdl);
    } else {
#line 467
      cx18_push(s, mdl, & s->q_full);
    }
  } else
#line 468
  if (mdl->readpos == mdl->bytesused) {
#line 469
    idx = (int )cx->vbi.inserted_frame & 31;
#line 471
    cx->vbi.sliced_mpeg_size[idx] = 0U;
#line 472
    cx->vbi.inserted_frame = cx->vbi.inserted_frame + 1U;
#line 473
    cx->vbi_data_inserted = cx->vbi_data_inserted + (u64 )mdl->bytesused;
  } else {

  }
#line 475
  if (rc < 0) {
#line 476
    return ((ssize_t )rc);
  } else {

  }
#line 477
  tot_written = (size_t )rc + tot_written;
#line 479
  if (tot_written == tot_count || single_frame != 0) {
#line 480
    goto ldv_53806;
  } else {

  }
#line 481
  goto ldv_53808;
  ldv_53806: ;
#line 482
  return ((ssize_t )tot_written);
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static ssize_t cx18_read_pos(struct cx18_stream *s , char *ubuf , size_t count , loff_t *pos ,
                             int non_block ) 
{ 
  ssize_t rc ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  struct cx18 *cx ;

  {
#line 488
  if (count != 0UL) {
#line 488
    tmp = cx18_read(s, ubuf, count, non_block);
#line 488
    tmp___0 = tmp;
  } else {
#line 488
    tmp___0 = 0L;
  }
#line 488
  rc = tmp___0;
#line 489
  cx = s->cx;
#line 491
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 491
    printk("\016%s:  file: read %zd from %s, got %zd\n", (char *)(& cx->v4l2_dev.name),
           count, s->name, rc);
  } else {

  }
#line 492
  if (rc > 0L) {
#line 493
    pos = pos + (unsigned long )rc;
  } else {

  }
#line 494
  return (rc);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
int cx18_start_capture(struct cx18_open_id *id ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_vbi ;
  struct cx18_stream *s_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 499
  cx = id->cx;
#line 500
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 504
  if (s->type == 6) {
#line 506
    return (-1);
  } else {

  }
#line 510
  tmp = cx18_claim_stream(id, s->type);
#line 510
  if (tmp != 0) {
#line 511
    return (-16);
  } else {

  }
#line 515
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 515
  if (tmp___0 != 0) {
#line 517
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 518
    return (0);
  } else {
#line 515
    tmp___1 = test_and_set_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 515
    if (tmp___1 != 0) {
#line 517
      set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 518
      return (0);
    } else {

    }
  }
#line 522
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 523
  s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 524
  if (s->type == 0) {
#line 530
    tmp___3 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 530
    if (tmp___3 != 0) {
#line 530
      tmp___4 = test_and_set_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
#line 530
      if (tmp___4 == 0) {
#line 532
        tmp___2 = cx18_start_v4l2_encode_stream(s_idx);
#line 532
        if (tmp___2 != 0) {
#line 533
          if (cx18_debug & 1) {
#line 533
            printk("\016%s:  warning: IDX capture start failed\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 534
          clear_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
#line 535
          goto start_failed;
        } else {

        }
#line 537
        if ((cx18_debug & 2) != 0) {
#line 537
          printk("\016%s:  info: IDX capture started\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
#line 539
    tmp___6 = constant_test_bit(5L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 539
    if (tmp___6 != 0) {
#line 539
      tmp___7 = test_and_set_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 539
      if (tmp___7 == 0) {
#line 541
        tmp___5 = cx18_start_v4l2_encode_stream(s_vbi);
#line 541
        if (tmp___5 != 0) {
#line 542
          if (cx18_debug & 1) {
#line 542
            printk("\016%s:  warning: VBI capture start failed\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 543
          clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
#line 544
          goto start_failed;
        } else {

        }
#line 546
        if ((cx18_debug & 2) != 0) {
#line 546
          printk("\016%s:  info: VBI insertion started\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 551
  tmp___9 = cx18_start_v4l2_encode_stream(s);
#line 551
  if (tmp___9 == 0) {
#line 553
    set_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 555
    tmp___8 = test_and_clear_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 555
    if (tmp___8 != 0) {
#line 556
      cx18_vapi(cx, 537001991U, 1, s->handle);
    } else {

    }
#line 557
    return (0);
  } else {

  }
  start_failed: ;
#line 561
  if (cx18_debug & 1) {
#line 561
    printk("\016%s:  warning: Failed to start capturing for stream %s\n", (char *)(& cx->v4l2_dev.name),
           s->name);
  } else {

  }
#line 568
  if (s->type == 0) {
#line 570
    tmp___10 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 570
    if (tmp___10 != 0) {
#line 571
      cx18_stop_v4l2_encode_stream(s_idx, 0);
#line 572
      clear_bit(4L, (unsigned long volatile   *)(& s_idx->s_flags));
    } else {

    }
#line 575
    tmp___11 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 575
    if (tmp___11 != 0) {
#line 575
      tmp___12 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 575
      if (tmp___12 == 0) {
#line 577
        cx18_stop_v4l2_encode_stream(s_vbi, 0);
#line 578
        clear_bit(4L, (unsigned long volatile   *)(& s_vbi->s_flags));
      } else {

      }
    } else {

    }
  } else {

  }
#line 581
  clear_bit(4L, (unsigned long volatile   *)(& s->s_flags));
#line 582
  cx18_release_stream(s);
#line 583
  return (-5);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
ssize_t cx18_v4l2_read(struct file *filp , char *buf , size_t count , loff_t *pos ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int rc ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 589
  tmp = file2id(filp);
#line 589
  id = tmp;
#line 590
  cx = id->cx;
#line 591
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 594
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 594
    printk("\016%s:  file: read %zd bytes from %s\n", (char *)(& cx->v4l2_dev.name),
           count, s->name);
  } else {

  }
#line 596
  ldv_mutex_lock_311(& cx->serialize_lock);
#line 597
  rc = cx18_start_capture(id);
#line 598
  ldv_mutex_unlock_312(& cx->serialize_lock);
#line 599
  if (rc != 0) {
#line 600
    return ((ssize_t )rc);
  } else {

  }
#line 602
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 604
    tmp___0 = videobuf_read_stream(& s->vbuf_q, buf, count, pos, 0, (int )filp->f_flags & 2048);
#line 604
    return (tmp___0);
  } else {

  }
#line 608
  tmp___1 = cx18_read_pos(s, buf, count, pos, (int )filp->f_flags & 2048);
#line 608
  return (tmp___1);
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
unsigned int cx18_v4l2_enc_poll(struct file *filp , poll_table *wait ) 
{ 
  unsigned long req_events ;
  unsigned long tmp ;
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp___0 ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int eof ;
  int tmp___1 ;
  unsigned int res ;
  int rc ;
  int tmp___2 ;
  int videobuf_poll ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 613
  tmp = poll_requested_events((poll_table const   *)wait);
#line 613
  req_events = tmp;
#line 614
  tmp___0 = file2id(filp);
#line 614
  id = tmp___0;
#line 615
  cx = id->cx;
#line 616
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 617
  tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 617
  eof = tmp___1;
#line 618
  res = 0U;
#line 621
  if (eof == 0) {
#line 621
    tmp___2 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 621
    if (tmp___2 == 0) {
#line 621
      if ((req_events & 65UL) != 0UL) {
#line 625
        ldv_mutex_lock_313(& cx->serialize_lock);
#line 626
        rc = cx18_start_capture(id);
#line 627
        ldv_mutex_unlock_314(& cx->serialize_lock);
#line 628
        if (rc != 0) {
#line 629
          if ((cx18_debug & 2) != 0) {
#line 629
            printk("\016%s:  info: Could not start capture for %s (%d)\n", (char *)(& cx->v4l2_dev.name),
                   s->name, rc);
          } else {

          }
#line 631
          return (8U);
        } else {

        }
#line 633
        if ((cx18_debug & 32) != 0) {
#line 633
          printk("\016%s:  file: Encoder poll started capture\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 636
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 638
    tmp___3 = videobuf_poll_stream(filp, & s->vbuf_q, wait);
#line 638
    videobuf_poll = (int )tmp___3;
#line 640
    tmp___4 = v4l2_event_pending(& id->fh);
#line 640
    if (tmp___4 != 0) {
#line 641
      res = res | 2U;
    } else {

    }
#line 642
    if (eof != 0 && videobuf_poll == 8) {
#line 643
      return (res | 16U);
    } else {

    }
#line 644
    return (res | (unsigned int )videobuf_poll);
  } else {

  }
#line 648
  if ((cx18_debug & 32) != 0 && (cx18_debug & 256) != 0) {
#line 648
    printk("\016%s:  file: Encoder poll\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 649
  tmp___5 = v4l2_event_pending(& id->fh);
#line 649
  if (tmp___5 != 0) {
#line 650
    res = res | 2U;
  } else {
#line 652
    poll_wait(filp, & s->waitq, wait);
  }
#line 654
  tmp___6 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 654
  if (tmp___6 != 0) {
#line 655
    return (res | 65U);
  } else {

  }
#line 656
  if (eof != 0) {
#line 657
    return (res | 16U);
  } else {

  }
#line 658
  return (res);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
int cx18_v4l2_mmap(struct file *file , struct vm_area_struct *vma ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  int eof ;
  int tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 663
  id = (struct cx18_open_id *)file->private_data;
#line 664
  cx = id->cx;
#line 665
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 666
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& s->s_flags));
#line 666
  eof = tmp;
#line 668
  if ((unsigned int )s->vb_type == 1U && id->type == 2) {
#line 672
    if (eof == 0) {
#line 672
      tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 672
      if (tmp___0 == 0) {
#line 675
        ldv_mutex_lock_315(& cx->serialize_lock);
#line 676
        rc = cx18_start_capture(id);
#line 677
        ldv_mutex_unlock_316(& cx->serialize_lock);
#line 678
        if (rc != 0) {
#line 679
          if ((cx18_debug & 2) != 0) {
#line 679
            printk("\016%s:  info: Could not start capture for %s (%d)\n", (char *)(& cx->v4l2_dev.name),
                   s->name, rc);
          } else {

          }
#line 682
          return (-22);
        } else {

        }
#line 684
        if ((cx18_debug & 32) != 0) {
#line 684
          printk("\016%s:  file: Encoder mmap started capture\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
      } else {

      }
    } else {

    }
#line 687
    tmp___1 = videobuf_mmap_mapper(& s->vbuf_q, vma);
#line 687
    return (tmp___1);
  } else {

  }
#line 690
  return (-22);
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
void cx18_vb_timeout(unsigned long data ) 
{ 
  struct cx18_stream *s ;
  struct cx18_videobuf_buffer *buf ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 695
  s = (struct cx18_stream *)data;
#line 702
  tmp = spinlock_check(& s->vb_lock);
#line 702
  flags = _raw_spin_lock_irqsave(tmp);
#line 703
  goto ldv_53869;
  ldv_53868: 
#line 704
  __mptr = (struct list_head  const  *)s->vb_capture.next;
#line 704
  buf = (struct cx18_videobuf_buffer *)__mptr + 0xffffffffffffffc8UL;
#line 706
  list_del(& buf->vb.queue);
#line 707
  buf->vb.state = 5;
#line 708
  __wake_up(& buf->vb.done, 3U, 1, (void *)0);
  ldv_53869: 
#line 703
  tmp___0 = list_empty((struct list_head  const  *)(& s->vb_capture));
#line 703
  if (tmp___0 == 0) {
#line 705
    goto ldv_53868;
  } else {

  }
#line 710
  spin_unlock_irqrestore(& s->vb_lock, flags);
#line 711
  return;
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
void cx18_stop_capture(struct cx18_open_id *id , int gop_end ) 
{ 
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct cx18_stream *s_vbi ;
  struct cx18_stream *s_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 715
  cx = id->cx;
#line 716
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 717
  s_vbi = (struct cx18_stream *)(& cx->streams) + 3UL;
#line 718
  s_idx = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 720
  if ((cx18_debug & 16) != 0) {
#line 720
    printk("\016%s:  ioctl: close() of %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 725
  tmp___3 = constant_test_bit(4L, (unsigned long const volatile   *)(& s->s_flags));
#line 725
  if (tmp___3 != 0) {
#line 726
    if ((cx18_debug & 2) != 0) {
#line 726
      printk("\016%s:  info: close stopping capture\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 727
    if (id->type == 0) {
#line 729
      tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 729
      if (tmp != 0) {
#line 729
        tmp___0 = constant_test_bit(8L, (unsigned long const volatile   *)(& s_vbi->s_flags));
#line 729
        if (tmp___0 == 0) {
#line 731
          if ((cx18_debug & 2) != 0) {
#line 731
            printk("\016%s:  info: close stopping embedded VBI capture\n", (char *)(& cx->v4l2_dev.name));
          } else {

          }
#line 733
          cx18_stop_v4l2_encode_stream(s_vbi, 0);
        } else {

        }
      } else {

      }
#line 735
      tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& s_idx->s_flags));
#line 735
      if (tmp___1 != 0) {
#line 736
        if ((cx18_debug & 2) != 0) {
#line 736
          printk("\016%s:  info: close stopping IDX capture\n", (char *)(& cx->v4l2_dev.name));
        } else {

        }
#line 737
        cx18_stop_v4l2_encode_stream(s_idx, 0);
      } else {

      }
    } else {

    }
#line 740
    if (id->type == 3) {
#line 740
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& s->s_flags));
#line 740
      if (tmp___2 != 0) {
#line 743
        s->id = 4294967295U;
      } else {
#line 745
        cx18_stop_v4l2_encode_stream(s, gop_end);
      }
    } else {
#line 745
      cx18_stop_v4l2_encode_stream(s, gop_end);
    }
  } else {

  }
#line 747
  if (gop_end == 0) {
#line 748
    clear_bit(8L, (unsigned long volatile   *)(& s->s_flags));
#line 749
    clear_bit(7L, (unsigned long volatile   *)(& s->s_flags));
#line 750
    cx18_release_stream(s);
  } else {

  }
#line 752
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
int cx18_v4l2_close(struct file *filp ) 
{ 
  struct v4l2_fh *fh ;
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 756
  fh = (struct v4l2_fh *)filp->private_data;
#line 757
  tmp = fh2id(fh);
#line 757
  id = tmp;
#line 758
  cx = id->cx;
#line 759
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 761
  if ((cx18_debug & 16) != 0) {
#line 761
    printk("\016%s:  ioctl: close() of %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 763
  ldv_mutex_lock_317(& cx->serialize_lock);
#line 765
  if (id->type == 6) {
#line 765
    tmp___3 = v4l2_fh_is_singular_file(filp);
#line 765
    if (tmp___3 != 0) {
#line 768
      cx18_mute(cx);
#line 770
      clear_bit(5L, (unsigned long volatile   *)(& cx->i_flags));
#line 772
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 772
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 772
      goto ldv_53892;
      ldv_53891: ;
#line 772
      if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                v4l2_std_id  ))0)) {
#line 772
        (*(((__sd->ops)->video)->s_std))(__sd, cx->std);
      } else {

      }
#line 772
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 772
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_53892: ;
#line 772
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 774
        goto ldv_53891;
      } else {

      }
#line 774
      cx18_audio_set_io(cx);
#line 775
      tmp___2 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 775
      if (tmp___2 > 0) {
#line 777
        tmp___0 = v4l2_ctrl_g_ctrl(cx->cxhdl.__annonCompField99.video_mute);
#line 777
        tmp___1 = v4l2_ctrl_g_ctrl(cx->cxhdl.__annonCompField99.video_mute_yuv);
#line 777
        cx18_vapi(cx, 537002003U, 2, s->handle, tmp___0 | (tmp___1 << 8));
      } else {

      }
#line 782
      cx18_unmute(cx);
    } else {

    }
  } else {

  }
#line 785
  v4l2_fh_del(fh);
#line 786
  v4l2_fh_exit(fh);
#line 789
  if (s->id == id->open_id) {
#line 790
    cx18_stop_capture(id, 0);
  } else {

  }
#line 791
  kfree((void const   *)id);
#line 792
  ldv_mutex_unlock_318(& cx->serialize_lock);
#line 793
  return (0);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
static int cx18_serialized_open(struct cx18_stream *s , struct file *filp ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *item ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___3 ;

  {
#line 798
  cx = s->cx;
#line 801
  if ((cx18_debug & 32) != 0) {
#line 801
    printk("\016%s:  file: open %s\n", (char *)(& cx->v4l2_dev.name), s->name);
  } else {

  }
#line 804
  tmp = kzalloc(192UL, 208U);
#line 804
  item = (struct cx18_open_id *)tmp;
#line 805
  if ((unsigned long )item == (unsigned long )((struct cx18_open_id *)0)) {
#line 806
    if (cx18_debug & 1) {
#line 806
      printk("\016%s:  warning: nomem on v4l2 open\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 807
    return (-12);
  } else {

  }
#line 809
  v4l2_fh_init(& item->fh, & s->video_dev);
#line 811
  item->cx = cx;
#line 812
  item->type = s->type;
#line 814
  tmp___0 = cx->open_id;
#line 814
  cx->open_id = cx->open_id + 1;
#line 814
  item->open_id = (u32 )tmp___0;
#line 815
  filp->private_data = (void *)(& item->fh);
#line 816
  v4l2_fh_add(& item->fh);
#line 818
  if (item->type == 6) {
#line 818
    tmp___3 = v4l2_fh_is_singular_file(filp);
#line 818
    if (tmp___3 != 0) {
#line 820
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 820
      if (tmp___2 == 0) {
#line 821
        tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 821
        if (tmp___1 > 0) {
#line 824
          v4l2_fh_del(& item->fh);
#line 825
          v4l2_fh_exit(& item->fh);
#line 826
          kfree((void const   *)item);
#line 827
          return (-16);
        } else {

        }
      } else {

      }
#line 832
      set_bit(5L, (unsigned long volatile   *)(& cx->i_flags));
#line 834
      cx18_mute(cx);
#line 836
      __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 836
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 836
      goto ldv_53906;
      ldv_53905: ;
#line 836
      if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_radio != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 836
        (*(((__sd->ops)->tuner)->s_radio))(__sd);
      } else {

      }
#line 836
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 836
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_53906: ;
#line 836
      if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 838
        goto ldv_53905;
      } else {

      }
#line 838
      cx18_audio_set_io(cx);
#line 840
      cx18_unmute(cx);
    } else {

    }
  } else {

  }
#line 842
  return (0);
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
int cx18_v4l2_open(struct file *filp ) 
{ 
  int res ;
  struct video_device *video_dev ;
  struct video_device *tmp ;
  struct cx18_stream *s ;
  void *tmp___0 ;
  struct cx18 *cx ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 848
  tmp = video_devdata(filp);
#line 848
  video_dev = tmp;
#line 849
  tmp___0 = video_get_drvdata(video_dev);
#line 849
  s = (struct cx18_stream *)tmp___0;
#line 850
  cx = s->cx;
#line 852
  ldv_mutex_lock_319(& cx->serialize_lock);
#line 853
  tmp___2 = cx18_init_on_first_open(cx);
#line 853
  if (tmp___2 != 0) {
#line 854
    tmp___1 = video_device_node_name(video_dev);
#line 854
    printk("\v%s: Failed to initialize on %s\n", (char *)(& cx->v4l2_dev.name), tmp___1);
#line 856
    ldv_mutex_unlock_320(& cx->serialize_lock);
#line 857
    return (-6);
  } else {

  }
#line 859
  res = cx18_serialized_open(s, filp);
#line 860
  ldv_mutex_unlock_321(& cx->serialize_lock);
#line 861
  return (res);
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
void cx18_mute(struct cx18 *cx ) 
{ 
  u32 h ;
  int tmp ;

  {
#line 867
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 867
  if (tmp != 0) {
#line 868
    h = cx18_find_handle(cx);
#line 869
    if (h != 4294967295U) {
#line 870
      cx18_vapi(cx, 537002004U, 2, h, 1);
    } else {
#line 872
      printk("\v%s: Can\'t find valid task handle for mute\n", (char *)(& cx->v4l2_dev.name));
    }
  } else {

  }
#line 874
  if ((cx18_debug & 2) != 0) {
#line 874
    printk("\016%s:  info: Mute\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 875
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.c"
void cx18_unmute(struct cx18 *cx ) 
{ 
  u32 h ;
  int tmp ;

  {
#line 880
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 880
  if (tmp != 0) {
#line 881
    h = cx18_find_handle(cx);
#line 882
    if (h != 4294967295U) {
#line 883
      cx18_msleep_timeout(100U, 0);
#line 884
      cx18_vapi(cx, 537002005U, 2, h, 12);
#line 885
      cx18_vapi(cx, 537002004U, 2, h, 0);
    } else {
#line 887
      printk("\v%s: Can\'t find valid task handle for unmute\n", (char *)(& cx->v4l2_dev.name));
    }
  } else {

  }
#line 889
  if ((cx18_debug & 2) != 0) {
#line 889
    printk("\016%s:  info: Unmute\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 890
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
bool ldv_queue_work_on_295(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
bool ldv_queue_delayed_work_on_296(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_flush_workqueue_298(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
bool ldv_queue_delayed_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_300(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_301(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_304(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
int ldv_mutex_trylock_305(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_310(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_311(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 439
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 441
  mutex_lock(ldv_func_arg1);
#line 442
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_312(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 447
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 449
  mutex_unlock(ldv_func_arg1);
#line 450
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_313(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 455
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 457
  mutex_lock(ldv_func_arg1);
#line 458
  return;
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 463
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 465
  mutex_unlock(ldv_func_arg1);
#line 466
  return;
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 471
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 473
  mutex_lock(ldv_func_arg1);
#line 474
  return;
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 479
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 481
  mutex_unlock(ldv_func_arg1);
#line 482
  return;
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 487
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 489
  mutex_lock(ldv_func_arg1);
#line 490
  return;
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 495
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 497
  mutex_unlock(ldv_func_arg1);
#line 498
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 503
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 505
  mutex_lock(ldv_func_arg1);
#line 506
  return;
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 511
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 513
  mutex_unlock(ldv_func_arg1);
#line 514
  return;
}
}
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-fileops.o.c.prepared"
void ldv_mutex_unlock_321(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 519
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 521
  mutex_unlock(ldv_func_arg1);
#line 522
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_363(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_368(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_371(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_358(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_361(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_365(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_367(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_370(struct mutex *ldv_func_arg1 ) ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_369(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_353(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_354(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_356(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_353(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___1(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___1(system_wq, work);
#line 530
  return (tmp);
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 221 "include/media/v4l2-dev.h"
__inline static void *video_drvdata(struct file *file ) 
{ 
  struct video_device *tmp ;
  void *tmp___0 ;

  {
#line 223
  tmp = video_devdata(file);
#line 223
  tmp___0 = video_get_drvdata(tmp);
#line 223
  return (tmp___0);
}
}
#line 411 "include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler * , char const   * ) ;
#line 802
extern int v4l2_ctrl_subscribe_event(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 202 "include/media/videobuf-core.h"
extern int videobuf_reqbufs(struct videobuf_queue * , struct v4l2_requestbuffers * ) ;
#line 204
extern int videobuf_querybuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 205
extern int videobuf_qbuf(struct videobuf_queue * , struct v4l2_buffer * ) ;
#line 207
extern int videobuf_dqbuf(struct videobuf_queue * , struct v4l2_buffer * , int  ) ;
#line 209
extern int videobuf_streamon(struct videobuf_queue * ) ;
#line 210
extern int videobuf_streamoff(struct videobuf_queue * ) ;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___1  =    1444U;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___3(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_53265;
  ldv_53264: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_53263;
  } else {

  }
#line 74
  i = i + 1;
  ldv_53265: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_53264;
  } else {

  }
  ldv_53263: ;
#line 81
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_enc(struct cx18 *cx , u32 val , u32 addr ) 
{ 


  {
#line 176
  cx18_writel___3(cx, val, cx->enc_mem + (unsigned long )addr);
#line 177
  return;
}
}
#line 179 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u32 cx18_read_enc(struct cx18 *cx , u32 addr ) 
{ 
  u32 tmp ;

  {
#line 181
  tmp = cx18_readl(cx, (void const   *)cx->enc_mem + (unsigned long )addr);
#line 181
  return (tmp);
}
}
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-video.h"
void cx18_video_set_io(struct cx18 *cx ) ;
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_load_fw_queue___0(struct cx18_stream *s ) 
{ 


  {
#line 45
  schedule_work___1(& s->out_work_order);
#line 46
  return;
}
}
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-ioctl.h"
u16 cx18_service2vbi(int type ) ;
#line 26
void cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) ;
#line 27
u16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt ) ;
#line 130 "include/media/v4l2-event.h"
extern int v4l2_event_unsubscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
u16 cx18_service2vbi(int type ) 
{ 


  {
#line 46
  switch (type) {
  case 1: ;
#line 48
  return (1U);
  case 4096: ;
#line 50
  return (4U);
  case 16384: ;
#line 52
  return (5U);
  case 1024: ;
#line 54
  return (7U);
  default: ;
#line 56
  return (0U);
  }
}
}
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int valid_service_line(int field , int line , int is_pal ) 
{ 


  {
#line 63
  return (((is_pal != 0 && line > 5) && ((field == 0 && line <= 23) || (field == 1 && line <= 22))) || ((is_pal == 0 && line > 9) && line <= 21));
}
}
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static u16 select_service_from_set(int field , int line , u16 set , int is_pal ) 
{ 
  u16 valid_set ;
  int i ;
  int tmp ;

  {
#line 77
  valid_set = is_pal != 0 ? 17409U : 4096U;
#line 80
  set = (u16 )((int )set & (int )valid_set);
#line 81
  if ((unsigned int )set == 0U) {
#line 82
    return (0U);
  } else {
#line 81
    tmp = valid_service_line(field, line, is_pal);
#line 81
    if (tmp == 0) {
#line 82
      return (0U);
    } else {

    }
  }
#line 83
  if (is_pal == 0) {
#line 84
    if (line == 21 && ((int )set & 4096) != 0) {
#line 85
      return (4096U);
    } else {

    }
  } else {
#line 87
    if ((line == 16 && field == 0) && ((int )set & 1024) != 0) {
#line 88
      return (1024U);
    } else {

    }
#line 89
    if ((line == 23 && field == 0) && ((int )set & 16384) != 0) {
#line 90
      return (16384U);
    } else {

    }
#line 91
    if (line == 23) {
#line 92
      return (0U);
    } else {

    }
  }
#line 94
  i = 0;
#line 94
  goto ldv_53742;
  ldv_53741: ;
#line 95
  if (((int )set >> i) & 1) {
#line 96
    return ((u16 )(1 << i));
  } else {

  }
#line 94
  i = i + 1;
  ldv_53742: ;
#line 94
  if (i <= 31) {
#line 96
    goto ldv_53741;
  } else {

  }

#line 98
  return (0U);
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
void cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  u16 set ;
  int f ;
  int l ;

  {
#line 107
  set = fmt->service_set;
#line 110
  fmt->service_set = 0U;
#line 111
  f = 0;
#line 111
  goto ldv_53755;
  ldv_53754: 
#line 112
  l = 0;
#line 112
  goto ldv_53752;
  ldv_53751: 
#line 113
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )set, is_pal);
#line 112
  l = l + 1;
  ldv_53752: ;
#line 112
  if (l <= 23) {
#line 114
    goto ldv_53751;
  } else {

  }
#line 111
  f = f + 1;
  ldv_53755: ;
#line 111
  if (f <= 1) {
#line 113
    goto ldv_53754;
  } else {

  }

#line 118
  return;
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int check_service_set(struct v4l2_sliced_vbi_format *fmt , int is_pal ) 
{ 
  int f ;
  int l ;
  u16 set ;

  {
#line 124
  set = 0U;
#line 126
  f = 0;
#line 126
  goto ldv_53768;
  ldv_53767: 
#line 127
  l = 0;
#line 127
  goto ldv_53765;
  ldv_53764: 
#line 128
  fmt->service_lines[f][l] = select_service_from_set(f, l, (int )fmt->service_lines[f][l],
                                                     is_pal);
#line 129
  set = (u16 )((int )fmt->service_lines[f][l] | (int )set);
#line 127
  l = l + 1;
  ldv_53765: ;
#line 127
  if (l <= 23) {
#line 129
    goto ldv_53764;
  } else {

  }
#line 126
  f = f + 1;
  ldv_53768: ;
#line 126
  if (f <= 1) {
#line 128
    goto ldv_53767;
  } else {

  }

#line 132
  return ((unsigned int )set != 0U);
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
u16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt ) 
{ 
  int f ;
  int l ;
  u16 set ;

  {
#line 139
  set = 0U;
#line 141
  f = 0;
#line 141
  goto ldv_53780;
  ldv_53779: 
#line 142
  l = 0;
#line 142
  goto ldv_53777;
  ldv_53776: 
#line 143
  set = (u16 )((int )fmt->service_lines[f][l] | (int )set);
#line 142
  l = l + 1;
  ldv_53777: ;
#line 142
  if (l <= 23) {
#line 144
    goto ldv_53776;
  } else {

  }
#line 141
  f = f + 1;
  ldv_53780: ;
#line 141
  if (f <= 1) {
#line 143
    goto ldv_53779;
  } else {

  }

#line 145
  return (set);
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct v4l2_pix_format *pixfmt ;

  {
#line 151
  tmp = fh2id((struct v4l2_fh *)fh);
#line 151
  id = tmp;
#line 152
  cx = id->cx;
#line 153
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 154
  pixfmt = & fmt->fmt.pix;
#line 156
  pixfmt->width = (__u32 )cx->cxhdl.width;
#line 157
  pixfmt->height = (__u32 )cx->cxhdl.height;
#line 158
  pixfmt->colorspace = 1U;
#line 159
  pixfmt->field = 4U;
#line 160
  if (id->type == 2) {
#line 161
    pixfmt->pixelformat = s->pixelformat;
#line 162
    pixfmt->sizeimage = s->vb_bytes_per_frame;
#line 163
    pixfmt->bytesperline = s->vb_bytes_per_line;
  } else {
#line 165
    pixfmt->pixelformat = 1195724877U;
#line 166
    pixfmt->sizeimage = 131072U;
#line 167
    pixfmt->bytesperline = 0U;
  }
#line 169
  return (0);
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_vbi_format *vbifmt ;
  __u32 tmp___0 ;

  {
#line 175
  tmp = fh2id((struct v4l2_fh *)fh);
#line 175
  cx = tmp->cx;
#line 176
  vbifmt = & fmt->fmt.vbi;
#line 178
  vbifmt->sampling_rate = 27000000U;
#line 179
  vbifmt->offset = 248U;
#line 180
  vbifmt->samples_per_line = (unsigned int )vbi_active_samples___1 - 4U;
#line 181
  vbifmt->sample_format = 1497715271U;
#line 182
  vbifmt->start[0] = (__s32 )cx->vbi.start[0];
#line 183
  vbifmt->start[1] = (__s32 )cx->vbi.start[1];
#line 184
  tmp___0 = cx->vbi.count;
#line 184
  vbifmt->count[1] = tmp___0;
#line 184
  vbifmt->count[0] = tmp___0;
#line 185
  vbifmt->flags = 0U;
#line 186
  vbifmt->reserved[0] = 0U;
#line 187
  vbifmt->reserved[1] = 0U;
#line 188
  return (0);
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;

  {
#line 194
  tmp = fh2id((struct v4l2_fh *)fh);
#line 194
  cx = tmp->cx;
#line 195
  vbifmt = & fmt->fmt.sliced;
#line 198
  vbifmt->reserved[0] = 0U;
#line 199
  vbifmt->reserved[1] = 0U;
#line 200
  vbifmt->io_size = 2304U;
#line 201
  memset((void *)(& vbifmt->service_lines), 0, 96UL);
#line 202
  vbifmt->service_set = 0U;
#line 209
  if ((unsigned long )cx->sd_av == (unsigned long )((struct v4l2_subdev *)0)) {
#line 210
    return (-22);
  } else
#line 209
  if ((unsigned long )((cx->sd_av)->ops)->vbi == (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) || (unsigned long )(((cx->sd_av)->ops)->vbi)->g_sliced_fmt == (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                           struct v4l2_sliced_vbi_format * ))0)) {
#line 210
    return (-22);
  } else {
#line 209
    tmp___0 = (*((((cx->sd_av)->ops)->vbi)->g_sliced_fmt))(cx->sd_av, & fmt->fmt.sliced);
#line 209
    if (tmp___0 != 0) {
#line 210
      return (-22);
    } else {

    }
  }
#line 212
  vbifmt->service_set = cx18_get_service_set(vbifmt);
#line 213
  return (0);
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_try_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int w ;
  int h ;
  int min_h ;
  int _min1 ;
  int _min2 ;
  int _max1 ;
  int _max2 ;
  int _min1___0 ;
  int _min2___0 ;
  int _max1___0 ;
  int _max2___0 ;

  {
#line 219
  tmp = fh2id((struct v4l2_fh *)fh);
#line 219
  id = tmp;
#line 220
  cx = id->cx;
#line 221
  w = (int )fmt->fmt.pix.width;
#line 222
  h = (int )fmt->fmt.pix.height;
#line 223
  min_h = 2;
#line 225
  _min1 = w;
#line 225
  _min2 = 720;
#line 225
  w = _min1 < _min2 ? _min1 : _min2;
#line 226
  _max1 = w;
#line 226
  _max2 = 2;
#line 226
  w = _max1 > _max2 ? _max1 : _max2;
#line 227
  if (id->type == 2) {
#line 229
    h = h & -32;
#line 230
    min_h = 32;
  } else {

  }
#line 232
  _min1___0 = h;
#line 232
  _min2___0 = (unsigned int )cx->is_50hz != 0U ? 576 : 480;
#line 232
  h = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 233
  _max1___0 = h;
#line 233
  _max2___0 = min_h;
#line 233
  h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 235
  fmt->fmt.pix.width = (__u32 )w;
#line 236
  fmt->fmt.pix.height = (__u32 )h;
#line 237
  return (0);
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_try_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  int tmp ;

  {
#line 243
  tmp = cx18_g_fmt_vbi_cap(file, fh, fmt);
#line 243
  return (tmp);
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_try_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;

  {
#line 249
  tmp = fh2id((struct v4l2_fh *)fh);
#line 249
  cx = tmp->cx;
#line 250
  vbifmt = & fmt->fmt.sliced;
#line 252
  vbifmt->io_size = 2304U;
#line 253
  vbifmt->reserved[0] = 0U;
#line 254
  vbifmt->reserved[1] = 0U;
#line 257
  if ((unsigned int )vbifmt->service_set != 0U) {
#line 258
    cx18_expand_service_set(vbifmt, (int )cx->is_50hz);
  } else {

  }
#line 260
  tmp___0 = check_service_set(vbifmt, (int )cx->is_50hz);
#line 260
  if (tmp___0 != 0) {
#line 261
    vbifmt->service_set = cx18_get_service_set(vbifmt);
  } else {

  }
#line 262
  return (0);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_subdev_format format ;
  struct cx18_stream *s ;
  int ret ;
  int w ;
  int h ;
  int tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  int tmp___3 ;

  {
#line 268
  tmp = fh2id((struct v4l2_fh *)fh);
#line 268
  id = tmp;
#line 269
  cx = id->cx;
#line 270
  format.which = 1U;
#line 270
  format.pad = 0U;
#line 270
  format.format.width = 0U;
#line 270
  format.format.height = 0U;
#line 270
  format.format.code = 0U;
#line 270
  format.format.field = 0U;
#line 270
  format.format.colorspace = 0U;
#line 270
  format.format.ycbcr_enc = (unsigned short)0;
#line 270
  format.format.quantization = (unsigned short)0;
#line 270
  format.format.xfer_func = (unsigned short)0;
#line 270
  format.format.reserved[0] = (unsigned short)0;
#line 270
  format.format.reserved[1] = (unsigned short)0;
#line 270
  format.format.reserved[2] = (unsigned short)0;
#line 270
  format.format.reserved[3] = (unsigned short)0;
#line 270
  format.format.reserved[4] = (unsigned short)0;
#line 270
  format.format.reserved[5] = (unsigned short)0;
#line 270
  format.format.reserved[6] = (unsigned short)0;
#line 270
  format.format.reserved[7] = (unsigned short)0;
#line 270
  format.format.reserved[8] = (unsigned short)0;
#line 270
  format.format.reserved[9] = (unsigned short)0;
#line 270
  format.format.reserved[10] = (unsigned short)0;
#line 270
  format.reserved[0] = 0U;
#line 270
  format.reserved[1] = 0U;
#line 270
  format.reserved[2] = 0U;
#line 270
  format.reserved[3] = 0U;
#line 270
  format.reserved[4] = 0U;
#line 270
  format.reserved[5] = 0U;
#line 270
  format.reserved[6] = 0U;
#line 270
  format.reserved[7] = 0U;
#line 273
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 277
  ret = cx18_try_fmt_vid_cap(file, fh, fmt);
#line 278
  if (ret != 0) {
#line 279
    return (ret);
  } else {

  }
#line 280
  w = (int )fmt->fmt.pix.width;
#line 281
  h = (int )fmt->fmt.pix.height;
#line 283
  if (((int )cx->cxhdl.width == w && (int )cx->cxhdl.height == h) && s->pixelformat == fmt->fmt.pix.pixelformat) {
#line 285
    return (0);
  } else {

  }
#line 287
  tmp___0 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 287
  if (tmp___0 > 0) {
#line 288
    return (-16);
  } else {

  }
#line 290
  s->pixelformat = fmt->fmt.pix.pixelformat;
#line 293
  if (s->pixelformat == 842091848U) {
#line 294
    s->vb_bytes_per_frame = (u32 )((h * 2160) / 2);
#line 295
    s->vb_bytes_per_line = 720U;
  } else {
#line 297
    s->vb_bytes_per_frame = (u32 )(h * 1440);
#line 298
    s->vb_bytes_per_line = 1440U;
  }
#line 301
  tmp___1 = (u16 )w;
#line 301
  cx->cxhdl.width = tmp___1;
#line 301
  format.format.width = (__u32 )tmp___1;
#line 302
  tmp___2 = (u16 )h;
#line 302
  cx->cxhdl.height = tmp___2;
#line 302
  format.format.height = (__u32 )tmp___2;
#line 303
  format.format.code = 1U;
#line 304
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 304
    if ((unsigned long )((cx->sd_av)->ops)->pad != (unsigned long )((struct v4l2_subdev_pad_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->pad)->set_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        struct v4l2_subdev_pad_config * ,
                                                                                                                                                                                                                        struct v4l2_subdev_format * ))0)) {
#line 304
      (*((((cx->sd_av)->ops)->pad)->set_fmt))(cx->sd_av, (struct v4l2_subdev_pad_config *)0,
                                              & format);
    } else {

    }
  } else {

  }
#line 305
  tmp___3 = cx18_g_fmt_vid_cap(file, fh, fmt);
#line 305
  return (tmp___3);
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_fmt_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 311
  tmp = fh2id((struct v4l2_fh *)fh);
#line 311
  id = tmp;
#line 312
  cx = id->cx;
#line 319
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 319
  if (tmp___0 == 0) {
#line 319
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 319
    if (tmp___1 > 0) {
#line 320
      return (-16);
    } else {

    }
  } else {

  }
#line 327
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 327
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_raw_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                          struct v4l2_vbi_format * ))0)) {
#line 327
      tmp___2 = (*((((cx->sd_av)->ops)->vbi)->s_raw_fmt))(cx->sd_av, & fmt->fmt.vbi);
#line 327
      tmp___3 = tmp___2;
    } else {
#line 327
      tmp___3 = -515;
    }
#line 327
    ret = tmp___3;
  } else {
#line 327
    ret = -19;
  }
#line 328
  if (ret != 0) {
#line 329
    return (ret);
  } else {

  }
#line 332
  (cx->vbi.sliced_in)->service_set = 0U;
#line 333
  cx->vbi.in.type = 4U;
#line 335
  tmp___4 = cx18_g_fmt_vbi_cap(file, fh, fmt);
#line 335
  return (tmp___4);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_fmt_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_format *fmt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int ret ;
  struct v4l2_sliced_vbi_format *vbifmt ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 341
  tmp = fh2id((struct v4l2_fh *)fh);
#line 341
  id = tmp;
#line 342
  cx = id->cx;
#line 344
  vbifmt = & fmt->fmt.sliced;
#line 346
  cx18_try_fmt_sliced_vbi_cap(file, fh, fmt);
#line 352
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 352
  if (tmp___0 != 0) {
#line 352
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 352
    if (tmp___1 > 0) {
#line 353
      return (-16);
    } else {

    }
  } else {

  }
#line 360
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 360
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             struct v4l2_sliced_vbi_format * ))0)) {
#line 360
      tmp___2 = (*((((cx->sd_av)->ops)->vbi)->s_sliced_fmt))(cx->sd_av, & fmt->fmt.sliced);
#line 360
      tmp___3 = tmp___2;
    } else {
#line 360
      tmp___3 = -515;
    }
#line 360
    ret = tmp___3;
  } else {
#line 360
    ret = -19;
  }
#line 361
  if (ret != 0) {
#line 362
    return (ret);
  } else {

  }
#line 364
  cx->vbi.in.type = 6U;
#line 365
  memcpy((void *)cx->vbi.sliced_in, (void const   *)vbifmt, 112UL);
#line 366
  return (0);
}
}
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_register(struct file *file , void *fh , struct v4l2_dbg_register *reg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  u32 tmp___0 ;

  {
#line 373
  tmp = fh2id((struct v4l2_fh *)fh);
#line 373
  cx = tmp->cx;
#line 375
  if ((reg->reg & 3ULL) != 0ULL) {
#line 376
    return (-22);
  } else {

  }
#line 377
  if (reg->reg > 67108863ULL) {
#line 378
    return (-22);
  } else {

  }
#line 379
  reg->size = 4U;
#line 380
  tmp___0 = cx18_read_enc(cx, (u32 )reg->reg);
#line 380
  reg->val = (__u64 )tmp___0;
#line 381
  return (0);
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_register(struct file *file , void *fh , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 387
  tmp = fh2id((struct v4l2_fh *)fh);
#line 387
  cx = tmp->cx;
#line 389
  if (((unsigned long long )reg->reg & 3ULL) != 0ULL) {
#line 390
    return (-22);
  } else {

  }
#line 391
  if ((unsigned long long )reg->reg > 67108863ULL) {
#line 392
    return (-22);
  } else {

  }
#line 393
  cx18_write_enc(cx, (u32 )reg->val, (u32 )reg->reg);
#line 394
  return (0);
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_querycap(struct file *file , void *fh , struct v4l2_capability *vcap ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18_stream *s ;
  void *tmp___0 ;
  struct cx18 *cx ;
  char const   *tmp___1 ;

  {
#line 401
  tmp = fh2id((struct v4l2_fh *)fh);
#line 401
  id = tmp;
#line 402
  tmp___0 = video_drvdata(file);
#line 402
  s = (struct cx18_stream *)tmp___0;
#line 403
  cx = id->cx;
#line 405
  strlcpy((char *)(& vcap->driver), "cx18", 16UL);
#line 406
  strlcpy((char *)(& vcap->card), cx->card_name, 32UL);
#line 407
  tmp___1 = pci_name((struct pci_dev  const  *)cx->pci_dev);
#line 407
  snprintf((char *)(& vcap->bus_info), 32UL, "PCI:%s", tmp___1);
#line 409
  vcap->capabilities = cx->v4l2_cap;
#line 410
  vcap->device_caps = s->v4l2_dev_caps;
#line 411
  vcap->capabilities = vcap->capabilities | 2147483648U;
#line 412
  return (0);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_enumaudio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 417
  tmp = fh2id((struct v4l2_fh *)fh);
#line 417
  cx = tmp->cx;
#line 419
  tmp___0 = cx18_get_audio_input(cx, (int )((u16 )vin->index), vin);
#line 419
  return (tmp___0);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_audio(struct file *file , void *fh , struct v4l2_audio *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 424
  tmp = fh2id((struct v4l2_fh *)fh);
#line 424
  cx = tmp->cx;
#line 426
  vin->index = cx->audio_input;
#line 427
  tmp___0 = cx18_get_audio_input(cx, (int )((u16 )vin->index), vin);
#line 427
  return (tmp___0);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_audio(struct file *file , void *fh , struct v4l2_audio  const  *vout ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 432
  tmp = fh2id((struct v4l2_fh *)fh);
#line 432
  cx = tmp->cx;
#line 434
  if ((unsigned int )vout->index >= (unsigned int )cx->nof_audio_inputs) {
#line 435
    return (-22);
  } else {

  }
#line 436
  cx->audio_input = vout->index;
#line 437
  cx18_audio_set_io(cx);
#line 438
  return (0);
}
}
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_enum_input(struct file *file , void *fh , struct v4l2_input *vin ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int tmp___0 ;

  {
#line 443
  tmp = fh2id((struct v4l2_fh *)fh);
#line 443
  cx = tmp->cx;
#line 446
  tmp___0 = cx18_get_input(cx, (int )((u16 )vin->index), vin);
#line 446
  return (tmp___0);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_cropcap(struct file *file , void *fh , struct v4l2_cropcap *cropcap ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 452
  tmp = fh2id((struct v4l2_fh *)fh);
#line 452
  cx = tmp->cx;
#line 454
  if (cropcap->type != 1U) {
#line 455
    return (-22);
  } else {

  }
#line 456
  cropcap->pixelaspect.numerator = (unsigned int )cx->is_50hz != 0U ? 59U : 10U;
#line 457
  cropcap->pixelaspect.denominator = (unsigned int )cx->is_50hz != 0U ? 54U : 11U;
#line 458
  return (0);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_selection(struct file *file , void *fh , struct v4l2_selection *sel ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  __s32 tmp___0 ;

  {
#line 464
  tmp = fh2id((struct v4l2_fh *)fh);
#line 464
  cx = tmp->cx;
#line 466
  if (sel->type != 1U) {
#line 467
    return (-22);
  } else {

  }
#line 468
  switch (sel->target) {
  case 2U: ;
  case 1U: 
#line 471
  tmp___0 = 0;
#line 471
  sel->r.left = tmp___0;
#line 471
  sel->r.top = tmp___0;
#line 472
  sel->r.width = 720U;
#line 473
  sel->r.height = (unsigned int )cx->is_50hz != 0U ? 576U : 480U;
#line 474
  goto ldv_53926;
  default: ;
#line 476
  return (-22);
  }
  ldv_53926: ;
#line 478
  return (0);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_enum_fmt_vid_cap(struct file *file , void *fh , struct v4l2_fmtdesc *fmt ) 
{ 
  struct v4l2_fmtdesc formats[3U] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 484
  formats[0].index = 0U;
#line 484
  formats[0].type = 1U;
#line 484
  formats[0].flags = 0U;
#line 484
  formats[0].description[0] = 'H';
#line 484
  formats[0].description[1] = 'M';
#line 484
  formats[0].description[2] = '1';
#line 484
  formats[0].description[3] = '2';
#line 484
  formats[0].description[4] = ' ';
#line 484
  formats[0].description[5] = '(';
#line 484
  formats[0].description[6] = 'Y';
#line 484
  formats[0].description[7] = 'U';
#line 484
  formats[0].description[8] = 'V';
#line 484
  formats[0].description[9] = ' ';
#line 484
  formats[0].description[10] = '4';
#line 484
  formats[0].description[11] = ':';
#line 484
  formats[0].description[12] = '1';
#line 484
  formats[0].description[13] = ':';
#line 484
  formats[0].description[14] = '1';
#line 484
  formats[0].description[15] = ')';
#line 484
  formats[0].description[16] = '\000';
#line 484
  tmp = 17U;
#line 484
  while (1) {
#line 484
    if (tmp >= 32U) {
#line 484
      break;
    } else {

    }
#line 484
    formats[0].description[tmp] = (unsigned char)0;
#line 484
    tmp = tmp + 1U;
  }
#line 484
  formats[0].pixelformat = 842091848U;
#line 484
  formats[0].reserved[0] = 0U;
#line 484
  formats[0].reserved[1] = 0U;
#line 484
  formats[0].reserved[2] = 0U;
#line 484
  formats[0].reserved[3] = 0U;
#line 484
  formats[1].index = 1U;
#line 484
  formats[1].type = 1U;
#line 484
  formats[1].flags = 1U;
#line 484
  formats[1].description[0] = 'M';
#line 484
  formats[1].description[1] = 'P';
#line 484
  formats[1].description[2] = 'E';
#line 484
  formats[1].description[3] = 'G';
#line 484
  formats[1].description[4] = '\000';
#line 484
  tmp___0 = 5U;
#line 484
  while (1) {
#line 484
    if (tmp___0 >= 32U) {
#line 484
      break;
    } else {

    }
#line 484
    formats[1].description[tmp___0] = (unsigned char)0;
#line 484
    tmp___0 = tmp___0 + 1U;
  }
#line 484
  formats[1].pixelformat = 1195724877U;
#line 484
  formats[1].reserved[0] = 0U;
#line 484
  formats[1].reserved[1] = 0U;
#line 484
  formats[1].reserved[2] = 0U;
#line 484
  formats[1].reserved[3] = 0U;
#line 484
  formats[2].index = 2U;
#line 484
  formats[2].type = 1U;
#line 484
  formats[2].flags = 0U;
#line 484
  formats[2].description[0] = 'U';
#line 484
  formats[2].description[1] = 'Y';
#line 484
  formats[2].description[2] = 'V';
#line 484
  formats[2].description[3] = 'Y';
#line 484
  formats[2].description[4] = ' ';
#line 484
  formats[2].description[5] = '4';
#line 484
  formats[2].description[6] = ':';
#line 484
  formats[2].description[7] = '2';
#line 484
  formats[2].description[8] = ':';
#line 484
  formats[2].description[9] = '2';
#line 484
  formats[2].description[10] = '\000';
#line 484
  tmp___1 = 11U;
#line 484
  while (1) {
#line 484
    if (tmp___1 >= 32U) {
#line 484
      break;
    } else {

    }
#line 484
    formats[2].description[tmp___1] = (unsigned char)0;
#line 484
    tmp___1 = tmp___1 + 1U;
  }
#line 484
  formats[2].pixelformat = 1498831189U;
#line 484
  formats[2].reserved[0] = 0U;
#line 484
  formats[2].reserved[1] = 0U;
#line 484
  formats[2].reserved[2] = 0U;
#line 484
  formats[2].reserved[3] = 0U;
#line 496
  if (fmt->index > 2U) {
#line 497
    return (-22);
  } else {

  }
#line 498
  *fmt = formats[fmt->index];
#line 499
  return (0);
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_input(struct file *file , void *fh , unsigned int *i ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 504
  tmp = fh2id((struct v4l2_fh *)fh);
#line 504
  cx = tmp->cx;
#line 506
  *i = cx->active_input;
#line 507
  return (0);
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
int cx18_s_input(struct file *file , void *fh , unsigned int inp ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  v4l2_std_id std ;
  struct cx18_card_video_input  const  *card_input ;

  {
#line 512
  tmp = fh2id((struct v4l2_fh *)fh);
#line 512
  id = tmp;
#line 513
  cx = id->cx;
#line 514
  std = 16777215ULL;
#line 515
  card_input = (struct cx18_card_video_input  const  *)(& (cx->card)->video_inputs) + (unsigned long )inp;
#line 518
  if ((unsigned int )cx->nof_inputs <= inp) {
#line 519
    return (-22);
  } else {

  }
#line 521
  if (cx->active_input == inp) {
#line 522
    if ((cx18_debug & 2) != 0) {
#line 522
      printk("\016%s:  info: Input unchanged\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 523
    return (0);
  } else {

  }
#line 526
  if ((cx18_debug & 2) != 0) {
#line 526
    printk("\016%s:  info: Changing input from %d to %d\n", (char *)(& cx->v4l2_dev.name),
           cx->active_input, inp);
  } else {

  }
#line 529
  cx->active_input = inp;
#line 531
  cx->audio_input = (u32 )(cx->card)->video_inputs[inp].audio_index;
#line 532
  if ((unsigned int )((unsigned char )card_input->video_type) == 1U) {
#line 533
    std = cx->tuner_std;
  } else {

  }
#line 534
  cx->streams[0].video_dev.tvnorms = std;
#line 535
  cx->streams[2].video_dev.tvnorms = std;
#line 536
  cx->streams[3].video_dev.tvnorms = std;
#line 540
  cx18_mute(cx);
#line 541
  cx18_video_set_io(cx);
#line 542
  cx18_audio_set_io(cx);
#line 543
  cx18_unmute(cx);
#line 544
  return (0);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_frequency(struct file *file , void *fh , struct v4l2_frequency *vf ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 550
  tmp = fh2id((struct v4l2_fh *)fh);
#line 550
  cx = tmp->cx;
#line 552
  if (vf->tuner != 0U) {
#line 553
    return (-22);
  } else {

  }
#line 555
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 555
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 555
  goto ldv_53963;
  ldv_53962: ;
#line 555
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency * ))0)) {
#line 555
    (*(((__sd->ops)->tuner)->g_frequency))(__sd, vf);
  } else {

  }
#line 555
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 555
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53963: ;
#line 555
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 557
    goto ldv_53962;
  } else {

  }

#line 556
  return (0);
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
int cx18_s_frequency(struct file *file , void *fh , struct v4l2_frequency  const  *vf ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 561
  tmp = fh2id((struct v4l2_fh *)fh);
#line 561
  id = tmp;
#line 562
  cx = id->cx;
#line 564
  if ((unsigned int )vf->tuner != 0U) {
#line 565
    return (-22);
  } else {

  }
#line 567
  cx18_mute(cx);
#line 568
  if ((cx18_debug & 2) != 0) {
#line 568
    printk("\016%s:  info: v4l2 ioctl: set frequency %d\n", (char *)(& cx->v4l2_dev.name),
           vf->frequency);
  } else {

  }
#line 569
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 569
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 569
  goto ldv_53978;
  ldv_53977: ;
#line 569
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_frequency  const  * ))0)) {
#line 569
    (*(((__sd->ops)->tuner)->s_frequency))(__sd, vf);
  } else {

  }
#line 569
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 569
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53978: ;
#line 569
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 571
    goto ldv_53977;
  } else {

  }
#line 570
  cx18_unmute(cx);
#line 571
  return (0);
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_std(struct file *file , void *fh , v4l2_std_id *std ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 576
  tmp = fh2id((struct v4l2_fh *)fh);
#line 576
  cx = tmp->cx;
#line 578
  *std = cx->std;
#line 579
  return (0);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
int cx18_s_std(struct file *file , void *fh , v4l2_std_id std ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  int tmp___0 ;
  int tmp___1 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 584
  tmp = fh2id((struct v4l2_fh *)fh);
#line 584
  id = tmp;
#line 585
  cx = id->cx;
#line 587
  if ((std & 16777215ULL) == 0ULL) {
#line 588
    return (-22);
  } else {

  }
#line 590
  if (cx->std == std) {
#line 591
    return (0);
  } else {

  }
#line 593
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 593
  if (tmp___0 != 0) {
#line 598
    return (-16);
  } else {
#line 593
    tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 593
    if (tmp___1 > 0) {
#line 598
      return (-16);
    } else {

    }
  }
#line 601
  cx->std = std;
#line 602
  cx->is_60hz = (std & 63744ULL) != 0ULL;
#line 603
  cx->is_50hz = (unsigned int )cx->is_60hz == 0U;
#line 604
  cx2341x_handler_set_50hz(& cx->cxhdl, (int )cx->is_50hz);
#line 605
  cx->cxhdl.width = 720U;
#line 606
  cx->cxhdl.height = (unsigned int )cx->is_50hz != 0U ? 576U : 480U;
#line 607
  cx->vbi.count = (unsigned int )cx->is_50hz != 0U ? 18U : 12U;
#line 608
  cx->vbi.start[0] = (unsigned int )cx->is_50hz != 0U ? 6U : 10U;
#line 609
  cx->vbi.start[1] = (unsigned int )cx->is_50hz != 0U ? 318U : 273U;
#line 610
  if ((cx18_debug & 2) != 0) {
#line 610
    printk("\016%s:  info: Switching standard to %llx.\n", (char *)(& cx->v4l2_dev.name),
           cx->std);
  } else {

  }
#line 614
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 614
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 614
  goto ldv_53999;
  ldv_53998: ;
#line 614
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                            v4l2_std_id  ))0)) {
#line 614
    (*(((__sd->ops)->video)->s_std))(__sd, cx->std);
  } else {

  }
#line 614
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 614
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53999: ;
#line 614
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 616
    goto ldv_53998;
  } else {

  }

#line 615
  return (0);
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_s_tuner(struct file *file , void *fh , struct v4l2_tuner  const  *vt ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 620
  tmp = fh2id((struct v4l2_fh *)fh);
#line 620
  id = tmp;
#line 621
  cx = id->cx;
#line 623
  if ((unsigned int )vt->index != 0U) {
#line 624
    return (-22);
  } else {

  }
#line 626
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 626
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 626
  goto ldv_54014;
  ldv_54013: ;
#line 626
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner  const  * ))0)) {
#line 626
    (*(((__sd->ops)->tuner)->s_tuner))(__sd, vt);
  } else {

  }
#line 626
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 626
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_54014: ;
#line 626
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 628
    goto ldv_54013;
  } else {

  }

#line 627
  return (0);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_tuner(struct file *file , void *fh , struct v4l2_tuner *vt ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 632
  tmp = fh2id((struct v4l2_fh *)fh);
#line 632
  cx = tmp->cx;
#line 634
  if (vt->index != 0U) {
#line 635
    return (-22);
  } else {

  }
#line 637
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 637
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 637
  goto ldv_54028;
  ldv_54027: ;
#line 637
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 637
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, vt);
  } else {

  }
#line 637
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 637
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_54028: ;
#line 637
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 639
    goto ldv_54027;
  } else {

  }

#line 639
  if (vt->type == 1U) {
#line 640
    strlcpy((char *)(& vt->name), "cx18 Radio Tuner", 32UL);
  } else {
#line 642
    strlcpy((char *)(& vt->name), "cx18 TV Tuner", 32UL);
  }
#line 643
  return (0);
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_sliced_vbi_cap(struct file *file , void *fh , struct v4l2_sliced_vbi_cap *cap ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  int set ;
  int f ;
  int l ;
  int tmp___0 ;

  {
#line 649
  tmp = fh2id((struct v4l2_fh *)fh);
#line 649
  cx = tmp->cx;
#line 650
  set = (unsigned int )cx->is_50hz != 0U ? 17409 : 4096;
#line 653
  if (cap->type != 6U) {
#line 654
    return (-22);
  } else {

  }
#line 656
  cap->service_set = 0U;
#line 657
  f = 0;
#line 657
  goto ldv_54043;
  ldv_54042: 
#line 658
  l = 0;
#line 658
  goto ldv_54040;
  ldv_54039: 
#line 659
  tmp___0 = valid_service_line(f, l, (int )cx->is_50hz);
#line 659
  if (tmp___0 != 0) {
#line 664
    cap->service_lines[f][l] = (__u16 )set;
#line 665
    cap->service_set = (__u16 )((int )((short )cap->service_set) | (int )((short )set));
  } else {
#line 667
    cap->service_lines[f][l] = 0U;
  }
#line 658
  l = l + 1;
  ldv_54040: ;
#line 658
  if (l <= 23) {
#line 660
    goto ldv_54039;
  } else {

  }
#line 657
  f = f + 1;
  ldv_54043: ;
#line 657
  if (f <= 1) {
#line 659
    goto ldv_54042;
  } else {

  }
#line 670
  f = 0;
#line 670
  goto ldv_54046;
  ldv_54045: 
#line 671
  cap->reserved[f] = 0U;
#line 670
  f = f + 1;
  ldv_54046: ;
#line 670
  if (f <= 2) {
#line 672
    goto ldv_54045;
  } else {

  }

#line 672
  return (0);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int _cx18_process_idx_data(struct cx18_buffer *buf , struct v4l2_enc_idx *idx ) 
{ 
  int consumed ;
  int remaining ;
  struct v4l2_enc_idx_entry *e_idx ;
  struct cx18_enc_idx_entry *e_buf ;
  int mapping[8U] ;

  {
#line 683
  mapping[0] = -1;
#line 683
  mapping[1] = 0;
#line 683
  mapping[2] = 1;
#line 683
  mapping[3] = -1;
#line 683
  mapping[4] = 2;
#line 683
  mapping[5] = -1;
#line 683
  mapping[6] = -1;
#line 683
  mapping[7] = -1;
#line 693
  remaining = (int )(buf->bytesused - buf->readpos);
#line 694
  consumed = 0;
#line 695
  e_idx = (struct v4l2_enc_idx_entry *)(& idx->entry) + (unsigned long )idx->entries;
#line 696
  e_buf = (struct cx18_enc_idx_entry *)buf->buf + (unsigned long )buf->readpos;
#line 698
  goto ldv_54058;
  ldv_54057: 
#line 701
  e_idx->offset = ((unsigned long long )e_buf->offset_high << 32) | (unsigned long long )e_buf->offset_low;
#line 704
  e_idx->pts = (((unsigned long long )e_buf->pts_high & 1ULL) << 32) | (unsigned long long )e_buf->pts_low;
#line 707
  e_idx->length = e_buf->length;
#line 709
  e_idx->flags = (__u32 )mapping[e_buf->flags & 7U];
#line 711
  e_idx->reserved[0] = 0U;
#line 712
  e_idx->reserved[1] = 0U;
#line 714
  idx->entries = idx->entries + 1U;
#line 715
  e_idx = (struct v4l2_enc_idx_entry *)(& idx->entry) + (unsigned long )idx->entries;
#line 716
  e_buf = e_buf + 1;
#line 718
  remaining = (int )((unsigned int )remaining - 24U);
#line 719
  consumed = (int )((unsigned int )consumed + 24U);
  ldv_54058: ;
#line 698
  if ((unsigned int )remaining > 23U && idx->entries <= 63U) {
#line 701
    goto ldv_54057;
  } else {

  }

#line 723
  if (remaining > 0 && (unsigned int )remaining <= 23U) {
#line 724
    consumed = consumed + remaining;
  } else {

  }
#line 726
  buf->readpos = buf->readpos + (u32 )consumed;
#line 727
  return (consumed);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_process_idx_data(struct cx18_stream *s , struct cx18_mdl *mdl , struct v4l2_enc_idx *idx ) 
{ 
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 733
  if (s->type != 5) {
#line 734
    return (-22);
  } else {

  }
#line 736
  if ((unsigned long )mdl->curr_buf == (unsigned long )((struct cx18_buffer *)0)) {
#line 737
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 737
    mdl->curr_buf = (struct cx18_buffer *)__mptr;
  } else {

  }
#line 740
  if ((unsigned long )(& (mdl->curr_buf)->list) == (unsigned long )(& mdl->buf_list)) {
#line 746
    mdl->readpos = mdl->bytesused;
#line 747
    return (0);
  } else {

  }
#line 750
  goto ldv_54072;
  ldv_54071: ;
#line 753
  if ((mdl->curr_buf)->readpos >= (mdl->curr_buf)->bytesused) {
#line 754
    goto ldv_54069;
  } else {

  }
#line 756
  tmp = _cx18_process_idx_data(mdl->curr_buf, idx);
#line 756
  mdl->readpos = mdl->readpos + (u32 )tmp;
#line 759
  if ((idx->entries > 63U || (mdl->curr_buf)->readpos < (mdl->curr_buf)->bytesused) || mdl->readpos >= mdl->bytesused) {
#line 762
    goto ldv_54070;
  } else {

  }
  ldv_54069: 
#line 750
  __mptr___0 = (struct list_head  const  *)(mdl->curr_buf)->list.next;
#line 750
  mdl->curr_buf = (struct cx18_buffer *)__mptr___0;
  ldv_54072: ;
#line 750
  if ((unsigned long )(& (mdl->curr_buf)->list) != (unsigned long )(& mdl->buf_list)) {
#line 752
    goto ldv_54071;
  } else {

  }
  ldv_54070: ;
#line 764
  return (0);
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_g_enc_index(struct file *file , void *fh , struct v4l2_enc_idx *idx ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct cx18_stream *s ;
  s32 tmp___0 ;
  struct cx18_mdl *mdl ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 770
  tmp = fh2id((struct v4l2_fh *)fh);
#line 770
  cx = tmp->cx;
#line 771
  s = (struct cx18_stream *)(& cx->streams) + 5UL;
#line 775
  tmp___1 = cx18_stream_enabled(s);
#line 775
  if (tmp___1) {
#line 775
    tmp___2 = 0;
  } else {
#line 775
    tmp___2 = 1;
  }
#line 775
  if (tmp___2) {
#line 776
    return (-22);
  } else {

  }
#line 779
  tmp___0 = (s32 )(s->buffers - s->bufs_per_mdl * 3U);
#line 781
  if (tmp___0 <= 0) {
#line 782
    tmp___0 = 1;
  } else {

  }
#line 783
  tmp___0 = (s32 )((s->buf_size * (u32 )tmp___0) / 24U);
#line 786
  idx->entries = 0U;
#line 787
  idx->entries_cap = (__u32 )tmp___0;
#line 788
  memset((void *)(& idx->reserved), 0, 16UL);
  ldv_54083: 
#line 792
  mdl = cx18_dequeue(s, & s->q_full);
#line 793
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 794
    goto ldv_54082;
  } else {

  }
#line 797
  cx18_process_idx_data(s, mdl, idx);
#line 798
  if (mdl->readpos < mdl->bytesused) {
#line 800
    cx18_push(s, mdl, & s->q_full);
#line 801
    goto ldv_54082;
  } else {

  }
#line 805
  cx18_enqueue(s, mdl, & s->q_free);
#line 807
  if (idx->entries <= 63U) {
#line 809
    goto ldv_54083;
  } else {

  }
  ldv_54082: 
#line 810
  cx18_stream_load_fw_queue___0(s);
#line 811
  return (0);
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static struct videobuf_queue *cx18_vb_queue(struct cx18_open_id *id ) 
{ 
  struct videobuf_queue *q ;
  struct cx18 *cx ;
  struct cx18_stream *s ;

  {
#line 816
  q = (struct videobuf_queue *)0;
#line 817
  cx = id->cx;
#line 818
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 820
  switch ((unsigned int )s->vb_type) {
  case 1U: 
#line 822
  q = & s->vbuf_q;
#line 823
  goto ldv_54091;
  case 4U: ;
#line 825
  goto ldv_54091;
  default: ;
#line 827
  goto ldv_54091;
  }
  ldv_54091: ;
#line 829
  return (q);
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_streamon(struct file *file , void *priv , enum v4l2_buf_type type ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  unsigned long tmp ;
  struct videobuf_queue *tmp___0 ;
  int tmp___1 ;

  {
#line 835
  id = (struct cx18_open_id *)file->private_data;
#line 836
  cx = id->cx;
#line 837
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 840
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 842
    return (-22);
  } else {

  }
#line 844
  if (id->type != 2) {
#line 845
    return (-22);
  } else {

  }
#line 848
  tmp = msecs_to_jiffies(2000U);
#line 848
  ldv_mod_timer_369(& s->vb_timeout, tmp + (unsigned long )jiffies);
#line 850
  tmp___0 = cx18_vb_queue(id);
#line 850
  tmp___1 = videobuf_streamon(tmp___0);
#line 850
  return (tmp___1);
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_streamoff(struct file *file , void *priv , enum v4l2_buf_type type ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 856
  id = (struct cx18_open_id *)file->private_data;
#line 857
  cx = id->cx;
#line 858
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 861
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 863
    return (-22);
  } else {

  }
#line 865
  if (id->type != 2) {
#line 866
    return (-22);
  } else {

  }
#line 868
  tmp = cx18_vb_queue(id);
#line 868
  tmp___0 = videobuf_streamoff(tmp);
#line 868
  return (tmp___0);
}
}
#line 871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_reqbufs(struct file *file , void *priv , struct v4l2_requestbuffers *rb ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 874
  id = (struct cx18_open_id *)file->private_data;
#line 875
  cx = id->cx;
#line 876
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 878
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 880
    return (-22);
  } else {

  }
#line 882
  tmp = cx18_vb_queue(id);
#line 882
  tmp___0 = videobuf_reqbufs(tmp, rb);
#line 882
  return (tmp___0);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_querybuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 888
  id = (struct cx18_open_id *)file->private_data;
#line 889
  cx = id->cx;
#line 890
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 892
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 894
    return (-22);
  } else {

  }
#line 896
  tmp = cx18_vb_queue(id);
#line 896
  tmp___0 = videobuf_querybuf(tmp, b);
#line 896
  return (tmp___0);
}
}
#line 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_qbuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 901
  id = (struct cx18_open_id *)file->private_data;
#line 902
  cx = id->cx;
#line 903
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 905
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 907
    return (-22);
  } else {

  }
#line 909
  tmp = cx18_vb_queue(id);
#line 909
  tmp___0 = videobuf_qbuf(tmp, b);
#line 909
  return (tmp___0);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_dqbuf(struct file *file , void *priv , struct v4l2_buffer *b ) 
{ 
  struct cx18_open_id *id ;
  struct cx18 *cx ;
  struct cx18_stream *s ;
  struct videobuf_queue *tmp ;
  int tmp___0 ;

  {
#line 914
  id = (struct cx18_open_id *)file->private_data;
#line 915
  cx = id->cx;
#line 916
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )id->type;
#line 918
  if ((unsigned int )s->vb_type != 1U && (unsigned int )s->vb_type != 4U) {
#line 920
    return (-22);
  } else {

  }
#line 922
  tmp = cx18_vb_queue(id);
#line 922
  tmp___0 = videobuf_dqbuf(tmp, b, (int )file->f_flags & 2048);
#line 922
  return (tmp___0);
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct cx18_open_id *id ;
  struct cx18_open_id *tmp ;
  struct cx18 *cx ;
  u32 h ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 928
  tmp = fh2id((struct v4l2_fh *)fh);
#line 928
  id = tmp;
#line 929
  cx = id->cx;
#line 932
  switch (enc->cmd) {
  case 0U: ;
#line 934
  if ((cx18_debug & 16) != 0) {
#line 934
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 935
  enc->flags = 0U;
#line 936
  tmp___0 = cx18_start_capture(id);
#line 936
  return (tmp___0);
  case 1U: ;
#line 939
  if ((cx18_debug & 16) != 0) {
#line 939
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 940
  enc->flags = enc->flags & 1U;
#line 941
  cx18_stop_capture(id, (int )enc->flags & 1);
#line 943
  goto ldv_54152;
  case 2U: ;
#line 946
  if ((cx18_debug & 16) != 0) {
#line 946
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 947
  enc->flags = 0U;
#line 948
  tmp___1 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 948
  if (tmp___1 == 0) {
#line 949
    return (-1);
  } else {

  }
#line 950
  tmp___2 = test_and_set_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 950
  if (tmp___2 != 0) {
#line 951
    return (0);
  } else {

  }
#line 952
  h = cx18_find_handle(cx);
#line 953
  if (h == 4294967295U) {
#line 954
    printk("\v%s: Can\'t find valid task handle for V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
#line 956
    return (-77);
  } else {

  }
#line 958
  cx18_mute(cx);
#line 959
  cx18_vapi(cx, 537001991U, 1, h);
#line 960
  goto ldv_54152;
  case 3U: ;
#line 963
  if ((cx18_debug & 16) != 0) {
#line 963
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 964
  enc->flags = 0U;
#line 965
  tmp___3 = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 965
  if (tmp___3 == 0) {
#line 966
    return (-1);
  } else {

  }
#line 967
  tmp___4 = test_and_clear_bit(13L, (unsigned long volatile   *)(& cx->i_flags));
#line 967
  if (tmp___4 == 0) {
#line 968
    return (0);
  } else {

  }
#line 969
  h = cx18_find_handle(cx);
#line 970
  if (h == 4294967295U) {
#line 971
    printk("\v%s: Can\'t find valid task handle for V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
#line 973
    return (-77);
  } else {

  }
#line 975
  cx18_vapi(cx, 537001992U, 1, h);
#line 976
  cx18_unmute(cx);
#line 977
  goto ldv_54152;
  default: ;
#line 980
  if ((cx18_debug & 16) != 0) {
#line 980
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& cx->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 981
  return (-22);
  }
  ldv_54152: ;
#line 983
  return (0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_try_encoder_cmd(struct file *file , void *fh , struct v4l2_encoder_cmd *enc ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;

  {
#line 989
  tmp = fh2id((struct v4l2_fh *)fh);
#line 989
  cx = tmp->cx;
#line 991
  switch (enc->cmd) {
  case 0U: ;
#line 993
  if ((cx18_debug & 16) != 0) {
#line 993
    printk("\016%s:  ioctl: V4L2_ENC_CMD_START\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 994
  enc->flags = 0U;
#line 995
  goto ldv_54163;
  case 1U: ;
#line 998
  if ((cx18_debug & 16) != 0) {
#line 998
    printk("\016%s:  ioctl: V4L2_ENC_CMD_STOP\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 999
  enc->flags = enc->flags & 1U;
#line 1000
  goto ldv_54163;
  case 2U: ;
#line 1003
  if ((cx18_debug & 16) != 0) {
#line 1003
    printk("\016%s:  ioctl: V4L2_ENC_CMD_PAUSE\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1004
  enc->flags = 0U;
#line 1005
  goto ldv_54163;
  case 3U: ;
#line 1008
  if ((cx18_debug & 16) != 0) {
#line 1008
    printk("\016%s:  ioctl: V4L2_ENC_CMD_RESUME\n", (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 1009
  enc->flags = 0U;
#line 1010
  goto ldv_54163;
  default: ;
#line 1013
  if ((cx18_debug & 16) != 0) {
#line 1013
    printk("\016%s:  ioctl: Unknown cmd %d\n", (char *)(& cx->v4l2_dev.name), enc->cmd);
  } else {

  }
#line 1014
  return (-22);
  }
  ldv_54163: ;
#line 1016
  return (0);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static int cx18_log_status(struct file *file , void *fh ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  struct v4l2_input vidin ;
  struct v4l2_audio audin ;
  int i ;
  struct tveeprom tv ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct cx18_stream *s ;
  int tmp___1 ;

  {
#line 1021
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1021
  cx = tmp->cx;
#line 1026
  printk("\016%s: Version: %s  Card: %s\n", (char *)(& cx->v4l2_dev.name), (char *)"1.5.1",
         cx->card_name);
#line 1027
  if ((cx->hw_flags & 2U) != 0U) {
#line 1030
    cx18_read_eeprom(cx, & tv);
  } else {

  }
#line 1032
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1032
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1032
  goto ldv_54183;
  ldv_54182: ;
#line 1032
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->log_status != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 1032
    (*(((__sd->ops)->core)->log_status))(__sd);
  } else {

  }
#line 1032
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1032
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_54183: ;
#line 1032
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1034
    goto ldv_54182;
  } else {

  }
#line 1033
  cx18_get_input(cx, (int )((u16 )cx->active_input), & vidin);
#line 1034
  cx18_get_audio_input(cx, (int )((u16 )cx->audio_input), & audin);
#line 1035
  printk("\016%s: Video Input: %s\n", (char *)(& cx->v4l2_dev.name), (__u8 *)(& vidin.name));
#line 1036
  printk("\016%s: Audio Input: %s\n", (char *)(& cx->v4l2_dev.name), (__u8 *)(& audin.name));
#line 1037
  ldv_mutex_lock_370(& cx->gpio_lock);
#line 1038
  printk("\016%s: GPIO:  direction 0x%08x, value 0x%08x\n", (char *)(& cx->v4l2_dev.name),
         cx->gpio_dir, cx->gpio_val);
#line 1040
  ldv_mutex_unlock_371(& cx->gpio_lock);
#line 1041
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 1041
  printk("\016%s: Tuner: %s\n", (char *)(& cx->v4l2_dev.name), tmp___0 != 0 ? (char *)"Radio" : (char *)"TV");
#line 1043
  v4l2_ctrl_handler_log_status(& cx->cxhdl.hdl, (char const   *)(& cx->v4l2_dev.name));
#line 1044
  printk("\016%s: Status flags: 0x%08lx\n", (char *)(& cx->v4l2_dev.name), cx->i_flags);
#line 1045
  i = 0;
#line 1045
  goto ldv_54188;
  ldv_54187: 
#line 1046
  s = (struct cx18_stream *)(& cx->streams) + (unsigned long )i;
#line 1048
  if ((unsigned long )s->video_dev.v4l2_dev == (unsigned long )((struct v4l2_device *)0) || s->buffers == 0U) {
#line 1049
    goto ldv_54186;
  } else {

  }
#line 1050
  tmp___1 = atomic_read((atomic_t const   *)(& s->q_full.depth));
#line 1050
  printk("\016%s: Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\n",
         (char *)(& cx->v4l2_dev.name), s->name, s->s_flags, (((u32 )tmp___1 * s->bufs_per_mdl) * 100U) / s->buffers,
         (s->buffers * s->buf_size) / 1024U, s->buffers);
  ldv_54186: 
#line 1045
  i = i + 1;
  ldv_54188: ;
#line 1045
  if (i <= 6) {
#line 1047
    goto ldv_54187;
  } else {

  }
#line 1056
  printk("\016%s: Read MPEG/VBI: %lld/%lld bytes\n", (char *)(& cx->v4l2_dev.name),
         (long long )cx->mpg_data_received, (long long )cx->vbi_data_inserted);
#line 1059
  return (0);
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static long cx18_default(struct file *file , void *fh , bool valid_prio , unsigned int cmd ,
                         void *arg ) 
{ 
  struct cx18 *cx ;
  struct cx18_open_id *tmp ;
  u32 val ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1065
  tmp = fh2id((struct v4l2_fh *)fh);
#line 1065
  cx = tmp->cx;
#line 1067
  switch (cmd) {
  case 1074029670U: 
#line 1069
  val = *((u32 *)arg);
#line 1071
  if (val == 0U || (int )val & 1) {
#line 1072
    __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 1072
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1072
    goto ldv_54206;
    ldv_54205: ;
#line 1072
    if (((__sd->grp_id & 64U) != 0U && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                           u32  ))0)) {
#line 1072
      (*(((__sd->ops)->core)->reset))(__sd, 1U);
    } else {

    }
#line 1072
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1072
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_54206: ;
#line 1072
    if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 1074
      goto ldv_54205;
    } else {

    }

  } else {

  }
#line 1074
  goto ldv_54208;
  default: ;
#line 1078
  return (-25L);
  }
  ldv_54208: ;
#line 1080
  return (0L);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
static struct v4l2_ioctl_ops  const  cx18_ioctl_ops  = 
#line 1083
     {& cx18_querycap, & cx18_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & cx18_g_fmt_vid_cap,
    0, 0, 0, & cx18_g_fmt_vbi_cap, 0, & cx18_g_fmt_sliced_vbi_cap, 0, 0, 0, 0, & cx18_s_fmt_vid_cap,
    0, 0, 0, & cx18_s_fmt_vbi_cap, 0, & cx18_s_fmt_sliced_vbi_cap, 0, 0, 0, 0, & cx18_try_fmt_vid_cap,
    0, 0, 0, & cx18_try_fmt_vbi_cap, 0, & cx18_try_fmt_sliced_vbi_cap, 0, 0, 0, 0,
    & cx18_reqbufs, & cx18_querybuf, & cx18_qbuf, 0, & cx18_dqbuf, 0, 0, 0, 0, 0,
    & cx18_streamon, & cx18_streamoff, & cx18_g_std, & cx18_s_std, 0, & cx18_enum_input,
    & cx18_g_input, & cx18_s_input, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cx18_enumaudio,
    & cx18_g_audio, & cx18_s_audio, 0, 0, 0, 0, 0, & cx18_cropcap, 0, 0, & cx18_g_selection,
    0, 0, 0, & cx18_g_enc_index, & cx18_encoder_cmd, & cx18_try_encoder_cmd, 0, 0,
    0, 0, & cx18_g_tuner, & cx18_s_tuner, & cx18_g_frequency, & cx18_s_frequency,
    0, & cx18_g_sliced_vbi_cap, & cx18_log_status, 0, & cx18_g_register, & cx18_s_register,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & v4l2_ctrl_subscribe_event, & v4l2_event_unsubscribe,
    & cx18_default};
#line 1129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.c"
void cx18_set_funcs(struct video_device *vdev ) 
{ 


  {
#line 1131
  vdev->ioctl_ops = & cx18_ioctl_ops;
#line 1132
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_16(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 271
  tmp = ldv_init_zalloc(32UL);
#line 271
  cx18_ioctl_ops_group0 = (struct v4l2_event_subscription  const  *)tmp;
#line 272
  tmp___0 = ldv_init_zalloc(208UL);
#line 272
  cx18_ioctl_ops_group5 = (struct v4l2_format *)tmp___0;
#line 273
  tmp___1 = ldv_init_zalloc(52UL);
#line 273
  cx18_ioctl_ops_group1 = (struct v4l2_audio *)tmp___1;
#line 274
  tmp___2 = ldv_init_zalloc(176UL);
#line 274
  cx18_ioctl_ops_group3 = (struct v4l2_fh *)tmp___2;
#line 275
  tmp___3 = __VERIFIER_nondet_pointer();
#line 275
  cx18_ioctl_ops_group2 = (struct file *)tmp___3;
#line 276
  tmp___4 = ldv_init_zalloc(88UL);
#line 276
  cx18_ioctl_ops_group4 = (struct v4l2_buffer *)tmp___4;
#line 277
  tmp___5 = ldv_init_zalloc(40UL);
#line 277
  cx18_ioctl_ops_group6 = (struct v4l2_encoder_cmd *)tmp___5;
#line 278
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  void *ldvarg75 ;
  void *tmp ;
  void *ldvarg52 ;
  void *tmp___0 ;
  struct v4l2_fmtdesc *ldvarg74 ;
  void *tmp___1 ;
  enum v4l2_buf_type ldvarg76 ;
  void *ldvarg82 ;
  void *tmp___2 ;
  void *ldvarg22 ;
  void *tmp___3 ;
  void *ldvarg25 ;
  void *tmp___4 ;
  struct v4l2_sliced_vbi_cap *ldvarg61 ;
  void *tmp___5 ;
  void *ldvarg54 ;
  void *tmp___6 ;
  enum v4l2_buf_type ldvarg21 ;
  struct v4l2_input *ldvarg30 ;
  void *tmp___7 ;
  unsigned int *ldvarg68 ;
  void *tmp___8 ;
  struct v4l2_tuner *ldvarg78 ;
  void *tmp___9 ;
  struct v4l2_frequency *ldvarg70 ;
  void *tmp___10 ;
  void *ldvarg73 ;
  void *tmp___11 ;
  unsigned int ldvarg26 ;
  bool ldvarg27 ;
  unsigned int ldvarg63 ;
  void *ldvarg45 ;
  void *tmp___12 ;
  void *ldvarg81 ;
  void *tmp___13 ;
  void *ldvarg40 ;
  void *tmp___14 ;
  struct v4l2_capability *ldvarg36 ;
  void *tmp___15 ;
  void *ldvarg55 ;
  void *tmp___16 ;
  void *ldvarg66 ;
  void *tmp___17 ;
  void *ldvarg79 ;
  void *tmp___18 ;
  void *ldvarg57 ;
  void *tmp___19 ;
  struct v4l2_dbg_register *ldvarg65 ;
  void *tmp___20 ;
  void *ldvarg62 ;
  void *tmp___21 ;
  v4l2_std_id ldvarg49 ;
  struct v4l2_enc_idx *ldvarg59 ;
  void *tmp___22 ;
  void *ldvarg80 ;
  void *tmp___23 ;
  struct v4l2_cropcap *ldvarg41 ;
  void *tmp___24 ;
  void *ldvarg60 ;
  void *tmp___25 ;
  void *ldvarg31 ;
  void *tmp___26 ;
  void *ldvarg39 ;
  void *tmp___27 ;
  void *ldvarg47 ;
  void *tmp___28 ;
  struct v4l2_frequency *ldvarg34 ;
  void *tmp___29 ;
  void *ldvarg28 ;
  void *tmp___30 ;
  void *ldvarg48 ;
  void *tmp___31 ;
  void *ldvarg33 ;
  void *tmp___32 ;
  void *ldvarg69 ;
  void *tmp___33 ;
  void *ldvarg38 ;
  void *tmp___34 ;
  void *ldvarg35 ;
  void *tmp___35 ;
  void *ldvarg24 ;
  void *tmp___36 ;
  void *ldvarg83 ;
  void *tmp___37 ;
  void *ldvarg44 ;
  void *tmp___38 ;
  void *ldvarg29 ;
  void *tmp___39 ;
  void *ldvarg64 ;
  void *tmp___40 ;
  struct v4l2_requestbuffers *ldvarg53 ;
  void *tmp___41 ;
  void *ldvarg37 ;
  void *tmp___42 ;
  void *ldvarg58 ;
  void *tmp___43 ;
  void *ldvarg46 ;
  void *tmp___44 ;
  void *ldvarg50 ;
  void *tmp___45 ;
  struct v4l2_dbg_register *ldvarg56 ;
  void *tmp___46 ;
  void *ldvarg72 ;
  void *tmp___47 ;
  void *ldvarg71 ;
  void *tmp___48 ;
  void *ldvarg42 ;
  void *tmp___49 ;
  struct v4l2_selection *ldvarg43 ;
  void *tmp___50 ;
  struct v4l2_audio *ldvarg23 ;
  void *tmp___51 ;
  void *ldvarg67 ;
  void *tmp___52 ;
  v4l2_std_id *ldvarg32 ;
  void *tmp___53 ;
  struct v4l2_tuner *ldvarg51 ;
  void *tmp___54 ;
  void *ldvarg77 ;
  void *tmp___55 ;
  int tmp___56 ;

  {
#line 281
  tmp = ldv_init_zalloc(1UL);
#line 281
  ldvarg75 = tmp;
#line 282
  tmp___0 = ldv_init_zalloc(1UL);
#line 282
  ldvarg52 = tmp___0;
#line 283
  tmp___1 = ldv_init_zalloc(64UL);
#line 283
  ldvarg74 = (struct v4l2_fmtdesc *)tmp___1;
#line 285
  tmp___2 = ldv_init_zalloc(1UL);
#line 285
  ldvarg82 = tmp___2;
#line 286
  tmp___3 = ldv_init_zalloc(1UL);
#line 286
  ldvarg22 = tmp___3;
#line 287
  tmp___4 = ldv_init_zalloc(1UL);
#line 287
  ldvarg25 = tmp___4;
#line 288
  tmp___5 = ldv_init_zalloc(116UL);
#line 288
  ldvarg61 = (struct v4l2_sliced_vbi_cap *)tmp___5;
#line 289
  tmp___6 = ldv_init_zalloc(1UL);
#line 289
  ldvarg54 = tmp___6;
#line 291
  tmp___7 = ldv_init_zalloc(80UL);
#line 291
  ldvarg30 = (struct v4l2_input *)tmp___7;
#line 292
  tmp___8 = ldv_init_zalloc(4UL);
#line 292
  ldvarg68 = (unsigned int *)tmp___8;
#line 293
  tmp___9 = ldv_init_zalloc(84UL);
#line 293
  ldvarg78 = (struct v4l2_tuner *)tmp___9;
#line 294
  tmp___10 = ldv_init_zalloc(44UL);
#line 294
  ldvarg70 = (struct v4l2_frequency *)tmp___10;
#line 295
  tmp___11 = ldv_init_zalloc(1UL);
#line 295
  ldvarg73 = tmp___11;
#line 299
  tmp___12 = ldv_init_zalloc(1UL);
#line 299
  ldvarg45 = tmp___12;
#line 300
  tmp___13 = ldv_init_zalloc(1UL);
#line 300
  ldvarg81 = tmp___13;
#line 301
  tmp___14 = ldv_init_zalloc(1UL);
#line 301
  ldvarg40 = tmp___14;
#line 302
  tmp___15 = ldv_init_zalloc(104UL);
#line 302
  ldvarg36 = (struct v4l2_capability *)tmp___15;
#line 303
  tmp___16 = ldv_init_zalloc(1UL);
#line 303
  ldvarg55 = tmp___16;
#line 304
  tmp___17 = ldv_init_zalloc(1UL);
#line 304
  ldvarg66 = tmp___17;
#line 305
  tmp___18 = ldv_init_zalloc(1UL);
#line 305
  ldvarg79 = tmp___18;
#line 306
  tmp___19 = ldv_init_zalloc(1UL);
#line 306
  ldvarg57 = tmp___19;
#line 307
  tmp___20 = ldv_init_zalloc(56UL);
#line 307
  ldvarg65 = (struct v4l2_dbg_register *)tmp___20;
#line 308
  tmp___21 = ldv_init_zalloc(1UL);
#line 308
  ldvarg62 = tmp___21;
#line 310
  tmp___22 = ldv_init_zalloc(2072UL);
#line 310
  ldvarg59 = (struct v4l2_enc_idx *)tmp___22;
#line 311
  tmp___23 = ldv_init_zalloc(1UL);
#line 311
  ldvarg80 = tmp___23;
#line 312
  tmp___24 = ldv_init_zalloc(44UL);
#line 312
  ldvarg41 = (struct v4l2_cropcap *)tmp___24;
#line 313
  tmp___25 = ldv_init_zalloc(1UL);
#line 313
  ldvarg60 = tmp___25;
#line 314
  tmp___26 = ldv_init_zalloc(1UL);
#line 314
  ldvarg31 = tmp___26;
#line 315
  tmp___27 = ldv_init_zalloc(1UL);
#line 315
  ldvarg39 = tmp___27;
#line 316
  tmp___28 = ldv_init_zalloc(1UL);
#line 316
  ldvarg47 = tmp___28;
#line 317
  tmp___29 = ldv_init_zalloc(44UL);
#line 317
  ldvarg34 = (struct v4l2_frequency *)tmp___29;
#line 318
  tmp___30 = ldv_init_zalloc(1UL);
#line 318
  ldvarg28 = tmp___30;
#line 319
  tmp___31 = ldv_init_zalloc(1UL);
#line 319
  ldvarg48 = tmp___31;
#line 320
  tmp___32 = ldv_init_zalloc(1UL);
#line 320
  ldvarg33 = tmp___32;
#line 321
  tmp___33 = ldv_init_zalloc(1UL);
#line 321
  ldvarg69 = tmp___33;
#line 322
  tmp___34 = ldv_init_zalloc(1UL);
#line 322
  ldvarg38 = tmp___34;
#line 323
  tmp___35 = ldv_init_zalloc(1UL);
#line 323
  ldvarg35 = tmp___35;
#line 324
  tmp___36 = ldv_init_zalloc(1UL);
#line 324
  ldvarg24 = tmp___36;
#line 325
  tmp___37 = ldv_init_zalloc(1UL);
#line 325
  ldvarg83 = tmp___37;
#line 326
  tmp___38 = ldv_init_zalloc(1UL);
#line 326
  ldvarg44 = tmp___38;
#line 327
  tmp___39 = ldv_init_zalloc(1UL);
#line 327
  ldvarg29 = tmp___39;
#line 328
  tmp___40 = ldv_init_zalloc(1UL);
#line 328
  ldvarg64 = tmp___40;
#line 329
  tmp___41 = ldv_init_zalloc(20UL);
#line 329
  ldvarg53 = (struct v4l2_requestbuffers *)tmp___41;
#line 330
  tmp___42 = ldv_init_zalloc(1UL);
#line 330
  ldvarg37 = tmp___42;
#line 331
  tmp___43 = ldv_init_zalloc(1UL);
#line 331
  ldvarg58 = tmp___43;
#line 332
  tmp___44 = ldv_init_zalloc(1UL);
#line 332
  ldvarg46 = tmp___44;
#line 333
  tmp___45 = ldv_init_zalloc(1UL);
#line 333
  ldvarg50 = tmp___45;
#line 334
  tmp___46 = ldv_init_zalloc(56UL);
#line 334
  ldvarg56 = (struct v4l2_dbg_register *)tmp___46;
#line 335
  tmp___47 = ldv_init_zalloc(1UL);
#line 335
  ldvarg72 = tmp___47;
#line 336
  tmp___48 = ldv_init_zalloc(1UL);
#line 336
  ldvarg71 = tmp___48;
#line 337
  tmp___49 = ldv_init_zalloc(1UL);
#line 337
  ldvarg42 = tmp___49;
#line 338
  tmp___50 = ldv_init_zalloc(64UL);
#line 338
  ldvarg43 = (struct v4l2_selection *)tmp___50;
#line 339
  tmp___51 = ldv_init_zalloc(52UL);
#line 339
  ldvarg23 = (struct v4l2_audio *)tmp___51;
#line 340
  tmp___52 = ldv_init_zalloc(1UL);
#line 340
  ldvarg67 = tmp___52;
#line 341
  tmp___53 = ldv_init_zalloc(8UL);
#line 341
  ldvarg32 = (v4l2_std_id *)tmp___53;
#line 342
  tmp___54 = ldv_init_zalloc(84UL);
#line 342
  ldvarg51 = (struct v4l2_tuner *)tmp___54;
#line 343
  tmp___55 = ldv_init_zalloc(1UL);
#line 343
  ldvarg77 = tmp___55;
#line 284
  ldv_memset((void *)(& ldvarg76), 0, 4UL);
#line 290
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
#line 296
  ldv_memset((void *)(& ldvarg26), 0, 4UL);
#line 297
  ldv_memset((void *)(& ldvarg27), 0, 1UL);
#line 298
  ldv_memset((void *)(& ldvarg63), 0, 4UL);
#line 309
  ldv_memset((void *)(& ldvarg49), 0, 8UL);
#line 345
  tmp___56 = __VERIFIER_nondet_int();
#line 345
  switch (tmp___56) {
  case 0: ;
#line 348
  if (ldv_state_variable_16 == 1) {
#line 350
    cx18_try_fmt_sliced_vbi_cap(cx18_ioctl_ops_group2, ldvarg83, cx18_ioctl_ops_group5);
#line 352
    ldv_state_variable_16 = 1;
  } else {

  }
#line 355
  goto ldv_54284;
  case 1: ;
#line 358
  if (ldv_state_variable_16 == 1) {
#line 360
    cx18_s_fmt_vbi_cap(cx18_ioctl_ops_group2, ldvarg82, cx18_ioctl_ops_group5);
#line 362
    ldv_state_variable_16 = 1;
  } else {

  }
#line 365
  goto ldv_54284;
  case 2: ;
#line 368
  if (ldv_state_variable_16 == 1) {
#line 370
    cx18_try_fmt_vid_cap(cx18_ioctl_ops_group2, ldvarg81, cx18_ioctl_ops_group5);
#line 372
    ldv_state_variable_16 = 1;
  } else {

  }
#line 375
  goto ldv_54284;
  case 3: ;
#line 378
  if (ldv_state_variable_16 == 1) {
#line 380
    cx18_try_encoder_cmd(cx18_ioctl_ops_group2, ldvarg80, cx18_ioctl_ops_group6);
#line 382
    ldv_state_variable_16 = 1;
  } else {

  }
#line 385
  goto ldv_54284;
  case 4: ;
#line 388
  if (ldv_state_variable_16 == 1) {
#line 390
    cx18_s_tuner(cx18_ioctl_ops_group2, ldvarg79, (struct v4l2_tuner  const  *)ldvarg78);
#line 392
    ldv_state_variable_16 = 1;
  } else {

  }
#line 395
  goto ldv_54284;
  case 5: ;
#line 398
  if (ldv_state_variable_16 == 1) {
#line 400
    cx18_streamoff(cx18_ioctl_ops_group2, ldvarg77, ldvarg76);
#line 402
    ldv_state_variable_16 = 1;
  } else {

  }
#line 405
  goto ldv_54284;
  case 6: ;
#line 408
  if (ldv_state_variable_16 == 1) {
#line 410
    cx18_enum_fmt_vid_cap(cx18_ioctl_ops_group2, ldvarg75, ldvarg74);
#line 412
    ldv_state_variable_16 = 1;
  } else {

  }
#line 415
  goto ldv_54284;
  case 7: ;
#line 418
  if (ldv_state_variable_16 == 1) {
#line 420
    cx18_s_fmt_vid_cap(cx18_ioctl_ops_group2, ldvarg73, cx18_ioctl_ops_group5);
#line 422
    ldv_state_variable_16 = 1;
  } else {

  }
#line 425
  goto ldv_54284;
  case 8: ;
#line 428
  if (ldv_state_variable_16 == 1) {
#line 430
    cx18_encoder_cmd(cx18_ioctl_ops_group2, ldvarg72, cx18_ioctl_ops_group6);
#line 432
    ldv_state_variable_16 = 1;
  } else {

  }
#line 435
  goto ldv_54284;
  case 9: ;
#line 438
  if (ldv_state_variable_16 == 1) {
#line 440
    cx18_g_frequency(cx18_ioctl_ops_group2, ldvarg71, ldvarg70);
#line 442
    ldv_state_variable_16 = 1;
  } else {

  }
#line 445
  goto ldv_54284;
  case 10: ;
#line 448
  if (ldv_state_variable_16 == 1) {
#line 450
    cx18_g_input(cx18_ioctl_ops_group2, ldvarg69, ldvarg68);
#line 452
    ldv_state_variable_16 = 1;
  } else {

  }
#line 455
  goto ldv_54284;
  case 11: ;
#line 458
  if (ldv_state_variable_16 == 1) {
#line 460
    cx18_qbuf(cx18_ioctl_ops_group2, ldvarg67, cx18_ioctl_ops_group4);
#line 462
    ldv_state_variable_16 = 1;
  } else {

  }
#line 465
  goto ldv_54284;
  case 12: ;
#line 468
  if (ldv_state_variable_16 == 1) {
#line 470
    cx18_g_register(cx18_ioctl_ops_group2, ldvarg66, ldvarg65);
#line 472
    ldv_state_variable_16 = 1;
  } else {

  }
#line 475
  goto ldv_54284;
  case 13: ;
#line 478
  if (ldv_state_variable_16 == 1) {
#line 480
    cx18_s_input(cx18_ioctl_ops_group2, ldvarg64, ldvarg63);
#line 482
    ldv_state_variable_16 = 1;
  } else {

  }
#line 485
  goto ldv_54284;
  case 14: ;
#line 488
  if (ldv_state_variable_16 == 1) {
#line 490
    cx18_g_sliced_vbi_cap(cx18_ioctl_ops_group2, ldvarg62, ldvarg61);
#line 492
    ldv_state_variable_16 = 1;
  } else {

  }
#line 495
  goto ldv_54284;
  case 15: ;
#line 498
  if (ldv_state_variable_16 == 1) {
#line 500
    cx18_g_enc_index(cx18_ioctl_ops_group2, ldvarg60, ldvarg59);
#line 502
    ldv_state_variable_16 = 1;
  } else {

  }
#line 505
  goto ldv_54284;
  case 16: ;
#line 508
  if (ldv_state_variable_16 == 1) {
#line 510
    cx18_g_fmt_sliced_vbi_cap(cx18_ioctl_ops_group2, ldvarg58, cx18_ioctl_ops_group5);
#line 512
    ldv_state_variable_16 = 1;
  } else {

  }
#line 515
  goto ldv_54284;
  case 17: ;
#line 518
  if (ldv_state_variable_16 == 1) {
#line 520
    cx18_s_register(cx18_ioctl_ops_group2, ldvarg57, (struct v4l2_dbg_register  const  *)ldvarg56);
#line 522
    ldv_state_variable_16 = 1;
  } else {

  }
#line 525
  goto ldv_54284;
  case 18: ;
#line 528
  if (ldv_state_variable_16 == 1) {
#line 530
    cx18_enumaudio(cx18_ioctl_ops_group2, ldvarg55, cx18_ioctl_ops_group1);
#line 532
    ldv_state_variable_16 = 1;
  } else {

  }
#line 535
  goto ldv_54284;
  case 19: ;
#line 538
  if (ldv_state_variable_16 == 1) {
#line 540
    cx18_reqbufs(cx18_ioctl_ops_group2, ldvarg54, ldvarg53);
#line 542
    ldv_state_variable_16 = 1;
  } else {

  }
#line 545
  goto ldv_54284;
  case 20: ;
#line 548
  if (ldv_state_variable_16 == 1) {
#line 550
    v4l2_event_unsubscribe(cx18_ioctl_ops_group3, cx18_ioctl_ops_group0);
#line 552
    ldv_state_variable_16 = 1;
  } else {

  }
#line 555
  goto ldv_54284;
  case 21: ;
#line 558
  if (ldv_state_variable_16 == 1) {
#line 560
    cx18_g_tuner(cx18_ioctl_ops_group2, ldvarg52, ldvarg51);
#line 562
    ldv_state_variable_16 = 1;
  } else {

  }
#line 565
  goto ldv_54284;
  case 22: ;
#line 568
  if (ldv_state_variable_16 == 1) {
#line 570
    cx18_s_std(cx18_ioctl_ops_group2, ldvarg50, ldvarg49);
#line 572
    ldv_state_variable_16 = 1;
  } else {

  }
#line 575
  goto ldv_54284;
  case 23: ;
#line 578
  if (ldv_state_variable_16 == 1) {
#line 580
    cx18_try_fmt_vbi_cap(cx18_ioctl_ops_group2, ldvarg48, cx18_ioctl_ops_group5);
#line 582
    ldv_state_variable_16 = 1;
  } else {

  }
#line 585
  goto ldv_54284;
  case 24: ;
#line 588
  if (ldv_state_variable_16 == 1) {
#line 590
    cx18_log_status(cx18_ioctl_ops_group2, ldvarg47);
#line 592
    ldv_state_variable_16 = 1;
  } else {

  }
#line 595
  goto ldv_54284;
  case 25: ;
#line 598
  if (ldv_state_variable_16 == 1) {
#line 600
    cx18_dqbuf(cx18_ioctl_ops_group2, ldvarg46, cx18_ioctl_ops_group4);
#line 602
    ldv_state_variable_16 = 1;
  } else {

  }
#line 605
  goto ldv_54284;
  case 26: ;
#line 608
  if (ldv_state_variable_16 == 1) {
#line 610
    cx18_querybuf(cx18_ioctl_ops_group2, ldvarg45, cx18_ioctl_ops_group4);
#line 612
    ldv_state_variable_16 = 1;
  } else {

  }
#line 615
  goto ldv_54284;
  case 27: ;
#line 618
  if (ldv_state_variable_16 == 1) {
#line 620
    cx18_g_selection(cx18_ioctl_ops_group2, ldvarg44, ldvarg43);
#line 622
    ldv_state_variable_16 = 1;
  } else {

  }
#line 625
  goto ldv_54284;
  case 28: ;
#line 628
  if (ldv_state_variable_16 == 1) {
#line 630
    cx18_cropcap(cx18_ioctl_ops_group2, ldvarg42, ldvarg41);
#line 632
    ldv_state_variable_16 = 1;
  } else {

  }
#line 635
  goto ldv_54284;
  case 29: ;
#line 638
  if (ldv_state_variable_16 == 1) {
#line 640
    cx18_g_fmt_vid_cap(cx18_ioctl_ops_group2, ldvarg40, cx18_ioctl_ops_group5);
#line 642
    ldv_state_variable_16 = 1;
  } else {

  }
#line 645
  goto ldv_54284;
  case 30: ;
#line 648
  if (ldv_state_variable_16 == 1) {
#line 650
    cx18_s_fmt_sliced_vbi_cap(cx18_ioctl_ops_group2, ldvarg39, cx18_ioctl_ops_group5);
#line 652
    ldv_state_variable_16 = 1;
  } else {

  }
#line 655
  goto ldv_54284;
  case 31: ;
#line 658
  if (ldv_state_variable_16 == 1) {
#line 660
    cx18_g_audio(cx18_ioctl_ops_group2, ldvarg38, cx18_ioctl_ops_group1);
#line 662
    ldv_state_variable_16 = 1;
  } else {

  }
#line 665
  goto ldv_54284;
  case 32: ;
#line 668
  if (ldv_state_variable_16 == 1) {
#line 670
    cx18_querycap(cx18_ioctl_ops_group2, ldvarg37, ldvarg36);
#line 672
    ldv_state_variable_16 = 1;
  } else {

  }
#line 675
  goto ldv_54284;
  case 33: ;
#line 678
  if (ldv_state_variable_16 == 1) {
#line 680
    cx18_s_frequency(cx18_ioctl_ops_group2, ldvarg35, (struct v4l2_frequency  const  *)ldvarg34);
#line 682
    ldv_state_variable_16 = 1;
  } else {

  }
#line 685
  goto ldv_54284;
  case 34: ;
#line 688
  if (ldv_state_variable_16 == 1) {
#line 690
    cx18_g_std(cx18_ioctl_ops_group2, ldvarg33, ldvarg32);
#line 692
    ldv_state_variable_16 = 1;
  } else {

  }
#line 695
  goto ldv_54284;
  case 35: ;
#line 698
  if (ldv_state_variable_16 == 1) {
#line 700
    cx18_enum_input(cx18_ioctl_ops_group2, ldvarg31, ldvarg30);
#line 702
    ldv_state_variable_16 = 1;
  } else {

  }
#line 705
  goto ldv_54284;
  case 36: ;
#line 708
  if (ldv_state_variable_16 == 1) {
#line 710
    v4l2_ctrl_subscribe_event(cx18_ioctl_ops_group3, cx18_ioctl_ops_group0);
#line 712
    ldv_state_variable_16 = 1;
  } else {

  }
#line 715
  goto ldv_54284;
  case 37: ;
#line 718
  if (ldv_state_variable_16 == 1) {
#line 720
    cx18_default(cx18_ioctl_ops_group2, ldvarg28, (int )ldvarg27, ldvarg26, ldvarg29);
#line 722
    ldv_state_variable_16 = 1;
  } else {

  }
#line 725
  goto ldv_54284;
  case 38: ;
#line 728
  if (ldv_state_variable_16 == 1) {
#line 730
    cx18_g_fmt_vbi_cap(cx18_ioctl_ops_group2, ldvarg25, cx18_ioctl_ops_group5);
#line 732
    ldv_state_variable_16 = 1;
  } else {

  }
#line 735
  goto ldv_54284;
  case 39: ;
#line 738
  if (ldv_state_variable_16 == 1) {
#line 740
    cx18_s_audio(cx18_ioctl_ops_group2, ldvarg24, (struct v4l2_audio  const  *)ldvarg23);
#line 742
    ldv_state_variable_16 = 1;
  } else {

  }
#line 745
  goto ldv_54284;
  case 40: ;
#line 748
  if (ldv_state_variable_16 == 1) {
#line 750
    cx18_streamon(cx18_ioctl_ops_group2, ldvarg22, ldvarg21);
#line 752
    ldv_state_variable_16 = 1;
  } else {

  }
#line 755
  goto ldv_54284;
  default: 
#line 756
  ldv_stop();
  }
  ldv_54284: ;
#line 760
  return;
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
bool ldv_queue_work_on_353(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 789
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 789
  ldv_func_res = tmp;
#line 791
  activate_work_2(ldv_func_arg3, 2);
#line 793
  return (ldv_func_res);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
bool ldv_queue_delayed_work_on_354(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 800
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 800
  ldv_func_res = tmp;
#line 802
  activate_work_2(& ldv_func_arg3->work, 2);
#line 804
  return (ldv_func_res);
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 811
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 811
  ldv_func_res = tmp;
#line 813
  activate_work_2(ldv_func_arg3, 2);
#line 815
  return (ldv_func_res);
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_flush_workqueue_356(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 821
  flush_workqueue(ldv_func_arg1);
#line 823
  call_and_disable_all_2(2);
#line 824
  return;
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
bool ldv_queue_delayed_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 830
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 830
  ldv_func_res = tmp;
#line 832
  activate_work_2(& ldv_func_arg3->work, 2);
#line 834
  return (ldv_func_res);
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_358(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 842
  mutex_lock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 848
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 850
  mutex_unlock(ldv_func_arg1);
#line 851
  return;
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 856
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 858
  mutex_unlock(ldv_func_arg1);
#line 859
  return;
}
}
#line 861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_361(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 864
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 866
  mutex_lock(ldv_func_arg1);
#line 867
  return;
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 872
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 874
  mutex_lock(ldv_func_arg1);
#line 875
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_mutex_trylock_363(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 881
  tmp = mutex_trylock(ldv_func_arg1);
#line 881
  ldv_func_res = tmp;
#line 883
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 883
  return (tmp___0);
#line 885
  return (ldv_func_res);
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 891
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 893
  mutex_unlock(ldv_func_arg1);
#line 894
  return;
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_365(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 899
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 901
  mutex_lock(ldv_func_arg1);
#line 902
  return;
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 907
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 909
  mutex_unlock(ldv_func_arg1);
#line 910
  return;
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_367(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 915
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 917
  mutex_lock(ldv_func_arg1);
#line 918
  return;
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_368(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 923
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 925
  mutex_unlock(ldv_func_arg1);
#line 926
  return;
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
int ldv_mod_timer_369(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 932
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 932
  ldv_func_res = tmp;
#line 934
  activate_pending_timer_5(ldv_func_arg1, ldv_func_arg2, 1);
#line 936
  return (ldv_func_res);
}
}
#line 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_lock_370(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 942
  ldv_mutex_lock_gpio_lock_of_cx18(ldv_func_arg1);
#line 944
  mutex_lock(ldv_func_arg1);
#line 945
  return;
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-ioctl.o.c.prepared"
void ldv_mutex_unlock_371(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 950
  ldv_mutex_unlock_gpio_lock_of_cx18(ldv_func_arg1);
#line 952
  mutex_unlock(ldv_func_arg1);
#line 953
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_405(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_401(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_406(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_408(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_410(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_403(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_404(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_409(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_396(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_398(struct workqueue_struct *ldv_func_arg1 ) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.c"
static int cx18_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl , u32 fmt ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  int type ;
  int tmp ;
  int i ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
#line 35
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 35
  cx = (struct cx18 *)__mptr + 0xfffffffffffffb58UL;
#line 36
  type = (cxhdl->__annonCompField98.stream_type)->val;
#line 38
  tmp = atomic_read((atomic_t const   *)(& cx->ana_capturing));
#line 38
  if (tmp > 0) {
#line 39
    return (-16);
  } else {

  }
#line 41
  if (fmt != 1U || ((type != 0 && type != 3) && type != 5)) {
#line 46
    cx->vbi.insert_mpeg = 0;
#line 47
    if ((cx18_debug & 2) != 0) {
#line 47
      printk("\016%s:  info: disabled insertion of sliced VBI data into the MPEG stream\n",
             (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 49
    return (0);
  } else {

  }
#line 53
  if ((unsigned long )cx->vbi.sliced_mpeg_data[0] == (unsigned long )((u8 *)0U)) {
#line 56
    i = 0;
#line 56
    goto ldv_53320;
    ldv_53319: 
#line 57
    tmp___0 = kmalloc(1592UL, 208U);
#line 57
    cx->vbi.sliced_mpeg_data[i] = (u8 *)tmp___0;
#line 59
    if ((unsigned long )cx->vbi.sliced_mpeg_data[i] == (unsigned long )((u8 *)0U)) {
#line 60
      goto ldv_53317;
      ldv_53316: 
#line 61
      kfree((void const   *)cx->vbi.sliced_mpeg_data[i]);
#line 62
      cx->vbi.sliced_mpeg_data[i] = (u8 *)0U;
      ldv_53317: 
#line 60
      i = i - 1;
#line 60
      if (i >= 0) {
#line 62
        goto ldv_53316;
      } else {

      }
#line 64
      cx->vbi.insert_mpeg = 0;
#line 66
      printk("\f%s: Unable to allocate buffers for sliced VBI data insertion\n", (char *)(& cx->v4l2_dev.name));
#line 68
      return (-12);
    } else {

    }
#line 56
    i = i + 1;
    ldv_53320: ;
#line 56
    if (i <= 31) {
#line 58
      goto ldv_53319;
    } else {

    }

  } else {

  }
#line 73
  cx->vbi.insert_mpeg = (int )fmt;
#line 74
  if ((cx18_debug & 2) != 0) {
#line 74
    printk("\016%s:  info: enabled insertion of sliced VBI data into the MPEG PS,when sliced VBI is enabled\n",
           (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 81
  tmp___1 = cx18_get_service_set(cx->vbi.sliced_in);
#line 81
  if ((unsigned int )tmp___1 == 0U) {
#line 82
    if ((unsigned int )cx->is_60hz != 0U) {
#line 83
      (cx->vbi.sliced_in)->service_set = 4096U;
    } else {
#line 86
      (cx->vbi.sliced_in)->service_set = 16384U;
    }
#line 87
    cx18_expand_service_set(cx->vbi.sliced_in, (int )cx->is_50hz);
  } else {

  }
#line 89
  return (0);
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.c"
static int cx18_s_video_encoding(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  int is_mpeg1 ;
  struct v4l2_subdev_format format ;
  struct v4l2_mbus_framefmt *fmt ;

  {
#line 94
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 94
  cx = (struct cx18 *)__mptr + 0xfffffffffffffb58UL;
#line 95
  is_mpeg1 = val == 0U;
#line 96
  format.which = 1U;
#line 96
  format.pad = 0U;
#line 96
  format.format.width = 0U;
#line 96
  format.format.height = 0U;
#line 96
  format.format.code = 0U;
#line 96
  format.format.field = 0U;
#line 96
  format.format.colorspace = 0U;
#line 96
  format.format.ycbcr_enc = (unsigned short)0;
#line 96
  format.format.quantization = (unsigned short)0;
#line 96
  format.format.xfer_func = (unsigned short)0;
#line 96
  format.format.reserved[0] = (unsigned short)0;
#line 96
  format.format.reserved[1] = (unsigned short)0;
#line 96
  format.format.reserved[2] = (unsigned short)0;
#line 96
  format.format.reserved[3] = (unsigned short)0;
#line 96
  format.format.reserved[4] = (unsigned short)0;
#line 96
  format.format.reserved[5] = (unsigned short)0;
#line 96
  format.format.reserved[6] = (unsigned short)0;
#line 96
  format.format.reserved[7] = (unsigned short)0;
#line 96
  format.format.reserved[8] = (unsigned short)0;
#line 96
  format.format.reserved[9] = (unsigned short)0;
#line 96
  format.format.reserved[10] = (unsigned short)0;
#line 96
  format.reserved[0] = 0U;
#line 96
  format.reserved[1] = 0U;
#line 96
  format.reserved[2] = 0U;
#line 96
  format.reserved[3] = 0U;
#line 96
  format.reserved[4] = 0U;
#line 96
  format.reserved[5] = 0U;
#line 96
  format.reserved[6] = 0U;
#line 96
  format.reserved[7] = 0U;
#line 99
  fmt = & format.format;
#line 102
  fmt->width = (__u32 )((int )cxhdl->width / (is_mpeg1 != 0 ? 2 : 1));
#line 103
  fmt->height = (__u32 )cxhdl->height;
#line 104
  fmt->code = 1U;
#line 105
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 105
    if ((unsigned long )((cx->sd_av)->ops)->pad != (unsigned long )((struct v4l2_subdev_pad_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->pad)->set_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        struct v4l2_subdev_pad_config * ,
                                                                                                                                                                                                                        struct v4l2_subdev_format * ))0)) {
#line 105
      (*((((cx->sd_av)->ops)->pad)->set_fmt))(cx->sd_av, (struct v4l2_subdev_pad_config *)0,
                                              & format);
    } else {

    }
  } else {

  }
#line 106
  return (0);
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.c"
static int cx18_s_audio_sampling_freq(struct cx2341x_handler *cxhdl , u32 idx ) 
{ 
  u32 freqs[3U] ;
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 111
  freqs[0] = 44100U;
#line 111
  freqs[1] = 48000U;
#line 111
  freqs[2] = 32000U;
#line 112
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 112
  cx = (struct cx18 *)__mptr + 0xfffffffffffffb58UL;
#line 116
  if (idx <= 2U) {
#line 117
    __mptr___0 = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 117
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
#line 117
    goto ldv_53348;
    ldv_53347: ;
#line 117
    if ((unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->audio)->s_clock_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                     u32  ))0)) {
#line 117
      (*(((__sd->ops)->audio)->s_clock_freq))(__sd, freqs[idx]);
    } else {

    }
#line 117
    __mptr___1 = (struct list_head  const  *)__sd->list.next;
#line 117
    __sd = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
    ldv_53348: ;
#line 117
    if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 119
      goto ldv_53347;
    } else {

    }

  } else {

  }
#line 118
  return (0);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.c"
static int cx18_s_audio_mode(struct cx2341x_handler *cxhdl , u32 val ) 
{ 
  struct cx18 *cx ;
  struct cx2341x_handler  const  *__mptr ;

  {
#line 123
  __mptr = (struct cx2341x_handler  const  *)cxhdl;
#line 123
  cx = (struct cx18 *)__mptr + 0xfffffffffffffb58UL;
#line 125
  cx->dualwatch_stereo_mode = val;
#line 126
  return (0);
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.c"
struct cx2341x_handler_ops cx18_cxhdl_ops  =    {& cx18_s_audio_sampling_freq, & cx18_s_audio_mode, & cx18_s_video_encoding, & cx18_s_stream_vbi_fmt};
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_initialize_cx2341x_handler_ops_15(void) 
{ 
  void *tmp ;

  {
#line 271
  tmp = ldv_init_zalloc(520UL);
#line 271
  cx18_cxhdl_ops_group0 = (struct cx2341x_handler *)tmp;
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  u32 ldvarg99 ;
  u32 ldvarg100 ;
  u32 ldvarg97 ;
  u32 ldvarg98 ;
  int tmp ;

  {
#line 275
  ldv_memset((void *)(& ldvarg99), 0, 4UL);
#line 276
  ldv_memset((void *)(& ldvarg100), 0, 4UL);
#line 277
  ldv_memset((void *)(& ldvarg97), 0, 4UL);
#line 278
  ldv_memset((void *)(& ldvarg98), 0, 4UL);
#line 280
  tmp = __VERIFIER_nondet_int();
#line 280
  switch (tmp) {
  case 0: ;
#line 283
  if (ldv_state_variable_15 == 1) {
#line 285
    cx18_s_stream_vbi_fmt(cx18_cxhdl_ops_group0, ldvarg100);
#line 287
    ldv_state_variable_15 = 1;
  } else {

  }
#line 290
  goto ldv_53369;
  case 1: ;
#line 293
  if (ldv_state_variable_15 == 1) {
#line 295
    cx18_s_video_encoding(cx18_cxhdl_ops_group0, ldvarg99);
#line 297
    ldv_state_variable_15 = 1;
  } else {

  }
#line 300
  goto ldv_53369;
  case 2: ;
#line 303
  if (ldv_state_variable_15 == 1) {
#line 305
    cx18_s_audio_sampling_freq(cx18_cxhdl_ops_group0, ldvarg98);
#line 307
    ldv_state_variable_15 = 1;
  } else {

  }
#line 310
  goto ldv_53369;
  case 3: ;
#line 313
  if (ldv_state_variable_15 == 1) {
#line 315
    cx18_s_audio_mode(cx18_cxhdl_ops_group0, ldvarg97);
#line 317
    ldv_state_variable_15 = 1;
  } else {

  }
#line 320
  goto ldv_53369;
  default: 
#line 321
  ldv_stop();
  }
  ldv_53369: ;
#line 325
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_2(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
bool ldv_queue_delayed_work_on_396(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_2(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_2(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_flush_workqueue_398(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_2(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
bool ldv_queue_delayed_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_2(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_unlock_401(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 423
  mutex_unlock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_403(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 429
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 431
  mutex_lock(ldv_func_arg1);
#line 432
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_404(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 437
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 439
  mutex_lock(ldv_func_arg1);
#line 440
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
int ldv_mutex_trylock_405(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 446
  tmp = mutex_trylock(ldv_func_arg1);
#line 446
  ldv_func_res = tmp;
#line 448
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 448
  return (tmp___0);
#line 450
  return (ldv_func_res);
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_unlock_406(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 458
  mutex_unlock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_unlock_408(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_lock_409(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-controls.o.c.prepared"
void ldv_mutex_unlock_410(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 490
  mutex_unlock(ldv_func_arg1);
#line 491
  return;
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list * ) ;
#line 1
void ldv__builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list * ) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 50 "include/linux/string.h"
extern char *strchr(char const   * , int  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_441(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_442(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_444(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_449(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_439(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_440(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_443(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_448(struct mutex *ldv_func_arg1 ) ;
#line 111
void ldv_mutex_lock_mb_lock(struct mutex *lock ) ;
#line 115
void ldv_mutex_unlock_mb_lock(struct mutex *lock ) ;
#line 223 "include/linux/time.h"
extern struct timeval ns_to_timeval(s64 const    ) ;
#line 284 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 162 "include/linux/timekeeping.h"
extern ktime_t ktime_get(void) ;
#line 173 "include/linux/timer.h"
int ldv_mod_timer_447(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 926 "include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_431(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_433(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_432(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_435(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_434(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___2(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_431(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work___2(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work___2(system_wq, work);
#line 530
  return (tmp);
}
}
#line 215 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
#line 217
  memcpy(dst, (void const   *)src, count);
#line 218
  return;
}
}
#line 91 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-mailbox.h"
void cx18_api_epu_cmd_irq(struct cx18 *cx , int rpu ) ;
#line 145 "drivers/media/dvb-core/dvb_demux.h"
extern void dvb_dmx_swfilter(struct dvb_demux * , u8 const   * , size_t  ) ;
#line 42 "include/media/videobuf-vmalloc.h"
extern void *videobuf_to_vmalloc(struct videobuf_buffer * ) ;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___4(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_53269;
  ldv_53268: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_53267;
  } else {

  }
#line 74
  i = i + 1;
  ldv_53269: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_53268;
  } else {

  }
  ldv_53267: ;
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect___2(struct cx18 *cx , u32 val , void *addr ,
                                            u32 eval , u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_53282;
  ldv_53281: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_53279;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_53280;
  } else {

  }
  ldv_53279: 
#line 88
  i = i + 1;
  ldv_53282: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_53281;
  } else {

  }
  ldv_53280: ;
#line 95
  return;
}
}
#line 141 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_memcpy_fromio(struct cx18 *cx , void *to , void const   *from ,
                                        unsigned int len ) 
{ 


  {
#line 144
  memcpy_fromio(to, (void const volatile   *)from, (size_t )len);
#line 145
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect___2(struct cx18 *cx , u32 val , u32 reg ,
                                               u32 eval , u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect___2(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-streams.h"
__inline static void cx18_stream_load_fw_queue___1(struct cx18_stream *s ) 
{ 


  {
#line 45
  schedule_work___2(& s->out_work_order);
#line 46
  return;
}
}
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static char const   *rpu_str[4U]  = {      "APU",      "CPU",      "EPU",      "HPU"};
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static struct cx18_api_info  const  api_info[43U]  = 
#line 48
  {      {537001985U, 0U, 1U, "CX18_CPU_SET_CHANNEL_TYPE"}, 
        {33554435U, 0U, 1U, "CX18_EPU_DEBUG"}, 
        {1073741825U, 0U, 1U, "CX18_CREATE_TASK"}, 
        {1073741826U, 0U, 1U, "CX18_DESTROY_TASK"}, 
        {537001986U, 8U, 1U, "CX18_CPU_CAPTURE_START"}, 
        {537001987U, 8U, 1U, "CX18_CPU_CAPTURE_STOP"}, 
        {537001991U, 0U, 1U, "CX18_CPU_CAPTURE_PAUSE"}, 
        {537001992U, 0U, 1U, "CX18_CPU_CAPTURE_RESUME"}, 
        {537001985U, 0U, 1U, "CX18_CPU_SET_CHANNEL_TYPE"}, 
        {537002002U, 0U, 1U, "CX18_CPU_SET_STREAM_OUTPUT_TYPE"}, 
        {537001988U, 0U, 1U, "CX18_CPU_SET_VIDEO_IN"}, 
        {537001989U, 0U, 1U, "CX18_CPU_SET_VIDEO_RATE"}, 
        {537001990U, 0U, 1U, "CX18_CPU_SET_VIDEO_RESOLUTION"}, 
        {537001993U, 0U, 1U, "CX18_CPU_SET_FILTER_PARAM"}, 
        {537001996U, 0U, 1U, "CX18_CPU_SET_SPATIAL_FILTER_TYPE"}, 
        {537001998U, 0U, 1U, "CX18_CPU_SET_MEDIAN_CORING"}, 
        {537002000U, 0U, 1U, "CX18_CPU_SET_INDEXTABLE"}, 
        {537002001U, 0U, 1U, "CX18_CPU_SET_AUDIO_PARAMETERS"}, 
        {537002003U, 0U, 1U, "CX18_CPU_SET_VIDEO_MUTE"}, 
        {537002004U, 0U, 1U, "CX18_CPU_SET_AUDIO_MUTE"}, 
        {537002005U, 0U, 1U, "CX18_CPU_SET_MISC_PARAMETERS"}, 
        {537002006U, 8U, 1U, "CX18_CPU_SET_RAW_VBI_PARAM"}, 
        {537002007U, 0U, 1U, "CX18_CPU_SET_CAPTURE_LINE_NO"}, 
        {537002008U, 0U, 1U, "CX18_CPU_SET_COPYRIGHT"}, 
        {537002009U, 0U, 1U, "CX18_CPU_SET_AUDIO_PID"}, 
        {537002010U, 0U, 1U, "CX18_CPU_SET_VIDEO_PID"}, 
        {537002011U, 0U, 1U, "CX18_CPU_SET_VER_CROP_LINE"}, 
        {537002012U, 0U, 1U, "CX18_CPU_SET_GOP_STRUCTURE"}, 
        {537002013U, 0U, 1U, "CX18_CPU_SET_SCENE_CHANGE_DETECTION"}, 
        {537002014U, 0U, 1U, "CX18_CPU_SET_ASPECT_RATIO"}, 
        {537002015U, 0U, 1U, "CX18_CPU_SET_SKIP_INPUT_FRAME"}, 
        {537002016U, 0U, 1U, "CX18_CPU_SET_SLICED_VBI_PARAM"}, 
        {537002017U, 0U, 1U, "CX18_CPU_SET_USERDATA_PLACE_HOLDER"}, 
        {537002018U, 0U, 1U, "CX18_CPU_GET_ENC_PTS"}, 
        {537002019U, 0U, 1U, "CX18_CPU_SET_VFC_PARAM"}, 
        {537133058U, 0U, 1U, "CX18_CPU_DE_SET_MDL_ACK"}, 
        {537133061U, 4U, 1U, "CX18_CPU_DE_SET_MDL"}, 
        {537133062U, 8U, 1U, "CX18_CPU_DE_RELEASE_MDL"}, 
        {268435457U, 0U, 0U, "CX18_APU_START"}, 
        {268435458U, 0U, 0U, "CX18_APU_STOP"}, 
        {268435461U, 0U, 0U, "CX18_APU_RESETAI"}, 
        {536870915U, 0U, 1U, "CX18_CPU_DEBUG_PEEK32"}, 
        {0U, 0U, 0U, "0"}};
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static struct cx18_api_info  const  *find_api_info(u32 cmd ) 
{ 
  int i ;

  {
#line 99
  i = 0;
#line 99
  goto ldv_53626;
  ldv_53625: ;
#line 100
  if ((unsigned int )api_info[i].cmd == cmd) {
#line 101
    return ((struct cx18_api_info  const  *)(& api_info) + (unsigned long )i);
  } else {

  }
#line 99
  i = i + 1;
  ldv_53626: ;
#line 99
  if ((unsigned int )api_info[i].cmd != 0U) {
#line 101
    goto ldv_53625;
  } else {

  }

#line 102
  return ((struct cx18_api_info  const  *)0);
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static char *u32arr2hex(u32 *data , int n , char *buf ) 
{ 
  char *p ;
  int i ;

  {
#line 111
  i = 0;
#line 111
  p = buf;
#line 111
  goto ldv_53636;
  ldv_53635: 
#line 113
  snprintf(p, 12UL, " %#010x", *(data + (unsigned long )i));
#line 111
  i = i + 1;
#line 111
  p = p + 11UL;
  ldv_53636: ;
#line 111
  if (i < n) {
#line 113
    goto ldv_53635;
  } else {

  }
#line 115
  *p = 0;
#line 116
  return (buf);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void dump_mb(struct cx18 *cx , struct cx18_mailbox *mb , char *name ) 
{ 
  char argstr[67U] ;
  char *tmp ;

  {
#line 123
  if ((cx18_debug & 4) == 0) {
#line 124
    return;
  } else {

  }
#line 126
  if ((cx18_debug & 4) != 0) {
#line 126
    tmp = u32arr2hex((u32 *)(& mb->args), 6, (char *)(& argstr));
#line 126
    printk("\016%s:  api: %s: req %#010x ack %#010x cmd %#010x err %#010x args%s\n",
           (char *)(& cx->v4l2_dev.name), name, mb->request, mb->ack, mb->cmd, mb->error,
           tmp);
  } else {

  }
#line 127
  return;
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void cx18_mdl_send_to_dvb(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 140
  if (((unsigned long )s->dvb == (unsigned long )((struct cx18_dvb *)0) || (s->dvb)->enabled == 0) || mdl->bytesused == 0U) {
#line 141
    return;
  } else {

  }
#line 146
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 146
  if (tmp != 0) {
#line 147
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 147
    buf = (struct cx18_buffer *)__mptr;
#line 149
    if (buf->bytesused != 0U) {
#line 150
      dvb_dmx_swfilter(& (s->dvb)->demux, (u8 const   *)buf->buf, (size_t )buf->bytesused);
    } else {

    }
#line 152
    return;
  } else {

  }
#line 155
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 155
  buf = (struct cx18_buffer *)__mptr___0;
#line 155
  goto ldv_53657;
  ldv_53656: ;
#line 156
  if (buf->bytesused == 0U) {
#line 157
    goto ldv_53655;
  } else {

  }
#line 158
  dvb_dmx_swfilter(& (s->dvb)->demux, (u8 const   *)buf->buf, (size_t )buf->bytesused);
#line 155
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 155
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_53657: ;
#line 155
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 157
    goto ldv_53656;
  } else {

  }
  ldv_53655: ;
#line 162
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void cx18_mdl_send_to_videobuf(struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_videobuf_buffer *vb_buf ;
  struct cx18_buffer *buf ;
  u8 *p ;
  u32 offset ;
  int dispatch ;
  int tmp ;
  struct list_head  const  *__mptr ;
  void *tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  ktime_t tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 168
  offset = 0U;
#line 169
  dispatch = 0;
#line 171
  if (mdl->bytesused == 0U) {
#line 172
    return;
  } else {

  }
#line 175
  spin_lock(& s->vb_lock);
#line 176
  tmp = list_empty((struct list_head  const  *)(& s->vb_capture));
#line 176
  if (tmp != 0) {
#line 177
    goto out;
  } else {

  }
#line 179
  __mptr = (struct list_head  const  *)s->vb_capture.next;
#line 179
  vb_buf = (struct cx18_videobuf_buffer *)__mptr + 0xffffffffffffffc8UL;
#line 182
  tmp___0 = videobuf_to_vmalloc(& vb_buf->vb);
#line 182
  p = (u8 *)tmp___0;
#line 183
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
#line 184
    goto out;
  } else {

  }
#line 186
  offset = vb_buf->bytes_used;
#line 187
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 187
  buf = (struct cx18_buffer *)__mptr___0;
#line 187
  goto ldv_53676;
  ldv_53675: ;
#line 188
  if (buf->bytesused == 0U) {
#line 189
    goto ldv_53674;
  } else {

  }
#line 191
  if ((size_t )(buf->bytesused + offset) <= vb_buf->vb.bsize) {
#line 192
    memcpy((void *)p + (unsigned long )offset, (void const   *)buf->buf, (size_t )buf->bytesused);
#line 193
    offset = buf->bytesused + offset;
#line 194
    vb_buf->bytes_used = vb_buf->bytes_used + buf->bytesused;
  } else {

  }
#line 187
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 187
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_53676: ;
#line 187
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 189
    goto ldv_53675;
  } else {

  }
  ldv_53674: ;
#line 199
  if (vb_buf->bytes_used >= s->vb_bytes_per_frame) {
#line 200
    dispatch = 1;
#line 201
    vb_buf->bytes_used = 0U;
  } else {

  }
#line 204
  if (dispatch != 0) {
#line 205
    tmp___1 = ktime_get();
#line 205
    vb_buf->vb.ts = ns_to_timeval(tmp___1.tv64);
#line 206
    list_del(& vb_buf->vb.queue);
#line 207
    vb_buf->vb.state = 4;
#line 208
    __wake_up(& vb_buf->vb.done, 3U, 1, (void *)0);
  } else {

  }
#line 211
  tmp___2 = msecs_to_jiffies(2000U);
#line 211
  ldv_mod_timer_447(& s->vb_timeout, tmp___2 + (unsigned long )jiffies);
  out: 
#line 214
  spin_unlock(& s->vb_lock);
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void cx18_mdl_send_to_alsa(struct cx18 *cx , struct cx18_stream *s , struct cx18_mdl *mdl ) 
{ 
  struct cx18_buffer *buf ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 222
  if (mdl->bytesused == 0U) {
#line 223
    return;
  } else {

  }
#line 228
  tmp = list_is_singular((struct list_head  const  *)(& mdl->buf_list));
#line 228
  if (tmp != 0) {
#line 229
    __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 229
    buf = (struct cx18_buffer *)__mptr;
#line 231
    if (buf->bytesused != 0U) {
#line 232
      (*(cx->pcm_announce_callback))(cx->alsa, (u8 *)buf->buf, (size_t )buf->bytesused);
    } else {

    }
#line 234
    return;
  } else {

  }
#line 237
  __mptr___0 = (struct list_head  const  *)mdl->buf_list.next;
#line 237
  buf = (struct cx18_buffer *)__mptr___0;
#line 237
  goto ldv_53691;
  ldv_53690: ;
#line 238
  if (buf->bytesused == 0U) {
#line 239
    goto ldv_53689;
  } else {

  }
#line 240
  (*(cx->pcm_announce_callback))(cx->alsa, (u8 *)buf->buf, (size_t )buf->bytesused);
#line 237
  __mptr___1 = (struct list_head  const  *)buf->list.next;
#line 237
  buf = (struct cx18_buffer *)__mptr___1;
  ldv_53691: ;
#line 237
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 239
    goto ldv_53690;
  } else {

  }
  ldv_53689: ;
#line 244
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void epu_dma_done(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 handle ;
  u32 mdl_ack_count ;
  u32 id ;
  struct cx18_mailbox *mb ;
  struct cx18_mdl_ack *mdl_ack ;
  struct cx18_stream *s ;
  struct cx18_mdl *mdl ;
  int i ;

  {
#line 253
  mb = & order->mb;
#line 254
  handle = mb->args[0];
#line 255
  s = cx18_handle_to_stream(cx, handle);
#line 257
  if ((unsigned long )s == (unsigned long )((struct cx18_stream *)0)) {
#line 258
    printk("\f%s: Got DMA done notification for unknown/inactive handle %d, %s mailbox seq no %d\n",
           (char *)(& cx->v4l2_dev.name), handle, (int )order->flags & 1 ? (char *)"stale" : (char *)"good",
           mb->request);
#line 262
    return;
  } else {

  }
#line 265
  mdl_ack_count = mb->args[2];
#line 266
  mdl_ack = (struct cx18_mdl_ack *)(& order->mdl_ack);
#line 267
  i = 0;
#line 267
  goto ldv_53707;
  ldv_53706: 
#line 268
  id = mdl_ack->id;
#line 290
  if ((int )order->flags & 1 && (s->mdl_base_idx > id || s->mdl_base_idx + s->buffers <= id)) {
#line 293
    printk("\f%s: Fell behind! Ignoring stale mailbox with  inconsistent data. Lost MDL for mailbox seq no %d\n",
           (char *)(& cx->v4l2_dev.name), mb->request);
#line 296
    goto ldv_53704;
  } else {

  }
#line 298
  mdl = cx18_queue_get_mdl(s, id, mdl_ack->data_used);
#line 300
  if ((cx18_debug & 8) != 0 && (cx18_debug & 256) != 0) {
#line 300
    printk("\016%s:  dma: DMA DONE for %s (MDL %d)\n", (char *)(& cx->v4l2_dev.name),
           s->name, id);
  } else {

  }
#line 301
  if ((unsigned long )mdl == (unsigned long )((struct cx18_mdl *)0)) {
#line 302
    printk("\f%s: Could not find MDL %d for stream %s\n", (char *)(& cx->v4l2_dev.name),
           id, s->name);
#line 304
    goto ldv_53705;
  } else {

  }
#line 307
  if ((cx18_debug & 8) != 0 && (cx18_debug & 256) != 0) {
#line 307
    printk("\016%s:  dma: %s recv bytesused = %d\n", (char *)(& cx->v4l2_dev.name),
           s->name, mdl->bytesused);
  } else {

  }
#line 310
  if (s->type == 1) {
#line 311
    cx18_mdl_send_to_dvb(s, mdl);
#line 312
    cx18_enqueue(s, mdl, & s->q_free);
  } else
#line 313
  if (s->type == 4) {
#line 315
    if ((unsigned long )cx->pcm_announce_callback != (unsigned long )((void (*)(struct snd_cx18_card * ,
                                                                                u8 * ,
                                                                                size_t  ))0)) {
#line 316
      cx18_mdl_send_to_alsa(cx, s, mdl);
#line 317
      cx18_enqueue(s, mdl, & s->q_free);
    } else {
#line 319
      cx18_enqueue(s, mdl, & s->q_full);
    }
  } else
#line 321
  if (s->type == 2) {
#line 322
    cx18_mdl_send_to_videobuf(s, mdl);
#line 323
    cx18_enqueue(s, mdl, & s->q_free);
  } else {
#line 325
    cx18_enqueue(s, mdl, & s->q_full);
#line 326
    if (s->type == 5) {
#line 327
      cx18_stream_rotate_idx_mdls(cx);
    } else {

    }
  }
  ldv_53705: 
#line 267
  i = i + 1;
#line 267
  mdl_ack = mdl_ack + 1;
  ldv_53707: ;
#line 267
  if ((u32 )i < mdl_ack_count) {
#line 269
    goto ldv_53706;
  } else {

  }
  ldv_53704: 
#line 331
  cx18_stream_load_fw_queue___1(s);
#line 333
  __wake_up(& cx->dma_waitq, 3U, 1, (void *)0);
#line 334
  if (s->id != 4294967295U) {
#line 335
    __wake_up(& s->waitq, 3U, 1, (void *)0);
  } else {

  }
#line 336
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void epu_debug(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  char *p ;
  char *str ;
  int tmp ;

  {
#line 341
  str = order->str;
#line 343
  if ((cx18_debug & 2) != 0) {
#line 343
    printk("\016%s:  info: %x %s\n", (char *)(& cx->v4l2_dev.name), order->mb.args[0],
           str);
  } else {

  }
#line 344
  p = strchr((char const   *)str, 46);
#line 345
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& cx->i_flags));
#line 345
  if ((tmp == 0 && (unsigned long )p != (unsigned long )((char *)0)) && (unsigned long )p > (unsigned long )str) {
#line 346
    printk("\016%s: FW version: %s\n", (char *)(& cx->v4l2_dev.name), p + 0xffffffffffffffffUL);
  } else {

  }
#line 347
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void epu_cmd(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 


  {
#line 351
  switch (order->rpu) {
  case 1: ;
#line 354
  switch (order->mb.cmd) {
  case 33816577U: 
#line 356
  epu_dma_done(cx, order);
#line 357
  goto ldv_53720;
  case 33554435U: 
#line 359
  epu_debug(cx, order);
#line 360
  goto ldv_53720;
  default: 
#line 362
  printk("\f%s: Unknown CPU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 364
  goto ldv_53720;
  }
  ldv_53720: ;
#line 366
  goto ldv_53723;
  case 0: 
#line 369
  printk("\f%s: Unknown APU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 371
  goto ldv_53723;
  default: ;
#line 373
  goto ldv_53723;
  }
  ldv_53723: ;
#line 376
  return;
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void free_in_work_order(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 


  {
#line 380
  atomic_set(& order->pending, 0);
#line 381
  return;
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
void cx18_in_work_handler(struct work_struct *work ) 
{ 
  struct cx18_in_work_order *order ;
  struct work_struct  const  *__mptr ;
  struct cx18 *cx ;

  {
#line 386
  __mptr = (struct work_struct  const  *)work;
#line 386
  order = (struct cx18_in_work_order *)__mptr;
#line 387
  cx = order->cx;
#line 388
  epu_cmd(cx, order);
#line 389
  free_in_work_order(cx, order);
#line 390
  return;
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static void mb_ack_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  struct cx18_mailbox *ack_mb ;
  u32 ack_irq ;
  u32 req ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 402
  switch (order->rpu) {
  case 0: 
#line 404
  ack_irq = 131072U;
#line 405
  ack_mb = & (cx->scb)->apu2epu_mb;
#line 406
  goto ldv_53745;
  case 1: 
#line 408
  ack_irq = 65536U;
#line 409
  ack_mb = & (cx->scb)->cpu2epu_mb;
#line 410
  goto ldv_53745;
  default: 
#line 412
  printk("\f%s: Unhandled RPU (%d) for command %x ack\n", (char *)(& cx->v4l2_dev.name),
         order->rpu, order->mb.cmd);
#line 414
  return;
  }
  ldv_53745: 
#line 417
  req = order->mb.request;
#line 419
  tmp = cx18_readl(cx, (void const   *)(& ack_mb->request));
#line 419
  if (tmp != req) {
#line 419
    goto _L;
  } else {
#line 419
    tmp___0 = cx18_readl(cx, (void const   *)(& ack_mb->ack));
#line 419
    if (tmp___0 == req) {
      _L: /* CIL Label */ 
#line 421
      if (cx18_debug & 1) {
#line 421
        printk("\016%s:  warning: Possibly falling behind: %s self-ack\'ed our incoming %s to EPU mailbox (sequence no. %u) while processing\n",
               (char *)(& cx->v4l2_dev.name), rpu_str[order->rpu], rpu_str[order->rpu],
               req);
      } else {

      }
#line 425
      order->flags = order->flags | 2UL;
#line 426
      return;
    } else {

    }
  }
#line 428
  cx18_writel___4(cx, req, (void *)(& ack_mb->ack));
#line 429
  cx18_write_reg_expect___2(cx, ack_irq, 13054272U, ack_irq, ack_irq);
#line 430
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static int epu_dma_done_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 handle ;
  u32 mdl_ack_offset ;
  u32 mdl_ack_count ;
  struct cx18_mailbox *mb ;
  int i ;

  {
#line 439
  mb = & order->mb;
#line 440
  handle = mb->args[0];
#line 441
  mdl_ack_offset = mb->args[1];
#line 442
  mdl_ack_count = mb->args[2];
#line 444
  if ((handle == 4294967295U || mdl_ack_count == 0U) || mdl_ack_count > 2U) {
#line 446
    if ((order->flags & 3UL) == 0UL) {
#line 447
      mb_ack_irq(cx, order);
    } else {

    }
#line 448
    return (-1);
  } else {

  }
#line 451
  i = 0;
#line 451
  goto ldv_53758;
  ldv_53757: 
#line 452
  *((u32 *)(& order->mdl_ack) + (unsigned long )i / 4UL) = cx18_readl(cx, (void const   *)(cx->enc_mem + ((unsigned long )mdl_ack_offset + (unsigned long )i)));
#line 451
  i = (int )((unsigned int )i + 4U);
  ldv_53758: ;
#line 451
  if ((unsigned long )i < (unsigned long )mdl_ack_count * 8UL) {
#line 453
    goto ldv_53757;
  } else {

  }

#line 455
  if ((order->flags & 3UL) == 0UL) {
#line 456
    mb_ack_irq(cx, order);
  } else {

  }
#line 457
  return (1);
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static int epu_debug_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  u32 str_offset ;
  char *str ;

  {
#line 464
  str = order->str;
#line 466
  *str = 0;
#line 467
  str_offset = order->mb.args[1];
#line 468
  if (str_offset != 0U) {
#line 469
    cx18_setup_page(cx, str_offset);
#line 470
    cx18_memcpy_fromio(cx, (void *)str, (void const   *)cx->enc_mem + (unsigned long )str_offset,
                       252U);
#line 471
    *(str + 252UL) = 0;
#line 472
    cx18_setup_page(cx, 14417920U);
  } else {

  }
#line 475
  if ((order->flags & 3UL) == 0UL) {
#line 476
    mb_ack_irq(cx, order);
  } else {

  }
#line 478
  return (str_offset != 0U);
}
}
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
__inline static int epu_cmd_irq(struct cx18 *cx , struct cx18_in_work_order *order ) 
{ 
  int ret ;

  {
#line 484
  ret = -1;
#line 486
  switch (order->rpu) {
  case 1: ;
#line 489
  switch (order->mb.cmd) {
  case 33816577U: 
#line 491
  ret = epu_dma_done_irq(cx, order);
#line 492
  goto ldv_53773;
  case 33554435U: 
#line 494
  ret = epu_debug_irq(cx, order);
#line 495
  goto ldv_53773;
  default: 
#line 497
  printk("\f%s: Unknown CPU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 499
  goto ldv_53773;
  }
  ldv_53773: ;
#line 501
  goto ldv_53776;
  case 0: 
#line 504
  printk("\f%s: Unknown APU to EPU mailbox command %#0x\n", (char *)(& cx->v4l2_dev.name),
         order->mb.cmd);
#line 506
  goto ldv_53776;
  default: ;
#line 508
  goto ldv_53776;
  }
  ldv_53776: ;
#line 510
  return (ret);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
__inline static struct cx18_in_work_order *alloc_in_work_order_irq(struct cx18 *cx ) 
{ 
  int i ;
  struct cx18_in_work_order *order ;
  int tmp ;

  {
#line 517
  order = (struct cx18_in_work_order *)0;
#line 519
  i = 0;
#line 519
  goto ldv_53786;
  ldv_53785: 
#line 528
  tmp = atomic_read((atomic_t const   *)(& cx->in_work_order[i].pending));
#line 528
  if (tmp == 0) {
#line 529
    order = (struct cx18_in_work_order *)(& cx->in_work_order) + (unsigned long )i;
#line 530
    atomic_set(& order->pending, 1);
#line 531
    goto ldv_53784;
  } else {

  }
#line 519
  i = i + 1;
  ldv_53786: ;
#line 519
  if (i <= 69) {
#line 521
    goto ldv_53785;
  } else {

  }
  ldv_53784: ;
#line 534
  return (order);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
void cx18_api_epu_cmd_irq(struct cx18 *cx , int rpu ) 
{ 
  struct cx18_mailbox *mb ;
  struct cx18_mailbox *order_mb ;
  struct cx18_in_work_order *order ;
  int submit ;
  int i ;

  {
#line 545
  switch (rpu) {
  case 1: 
#line 547
  mb = & (cx->scb)->cpu2epu_mb;
#line 548
  goto ldv_53797;
  case 0: 
#line 550
  mb = & (cx->scb)->apu2epu_mb;
#line 551
  goto ldv_53797;
  default: ;
#line 553
  return;
  }
  ldv_53797: 
#line 556
  order = alloc_in_work_order_irq(cx);
#line 557
  if ((unsigned long )order == (unsigned long )((struct cx18_in_work_order *)0)) {
#line 558
    printk("\f%s: Unable to find blank work order form to schedule incoming mailbox command processing\n",
           (char *)(& cx->v4l2_dev.name));
#line 560
    return;
  } else {

  }
#line 563
  order->flags = 0UL;
#line 564
  order->rpu = rpu;
#line 565
  order_mb = & order->mb;
#line 568
  i = 0;
#line 568
  goto ldv_53801;
  ldv_53800: 
#line 569
  *(& order_mb->cmd + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->cmd) + (unsigned long )i);
#line 568
  i = i + 1;
  ldv_53801: ;
#line 568
  if (i <= 3) {
#line 570
    goto ldv_53800;
  } else {

  }
#line 572
  i = 0;
#line 572
  goto ldv_53804;
  ldv_53803: 
#line 573
  *(& order_mb->request + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->request) + (unsigned long )i);
#line 572
  i = i + 1;
  ldv_53804: ;
#line 572
  if (i <= 1) {
#line 574
    goto ldv_53803;
  } else {

  }

#line 575
  if (order_mb->request == order_mb->ack) {
#line 576
    if (cx18_debug & 1) {
#line 576
      printk("\016%s:  warning: Possibly falling behind: %s self-ack\'ed our incoming %s to EPU mailbox (sequence no. %u)\n",
             (char *)(& cx->v4l2_dev.name), rpu_str[rpu], rpu_str[rpu], order_mb->request);
    } else {

    }
#line 580
    if (cx18_debug & 1) {
#line 581
      dump_mb(cx, order_mb, (char *)"incoming");
    } else {

    }
#line 582
    order->flags = 1UL;
  } else {

  }
#line 589
  submit = epu_cmd_irq(cx, order);
#line 590
  if (submit > 0) {
#line 591
    queue_work___2(cx->in_work_queue, & order->work);
  } else {

  }
#line 592
  return;
}
}
#line 600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static int cx18_api_call(struct cx18 *cx , u32 cmd , int args , u32 *data ) 
{ 
  struct cx18_api_info  const  *info ;
  struct cx18_api_info  const  *tmp ;
  u32 irq ;
  u32 req ;
  u32 ack ;
  u32 err ;
  struct cx18_mailbox *mb ;
  wait_queue_head_t *waitq ;
  struct mutex *mb_lock ;
  unsigned long t0 ;
  unsigned long timeout ;
  unsigned long ret ;
  int i ;
  char argstr[67U] ;
  wait_queue_t w ;
  struct task_struct *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  bool __cond ;
  bool __cond___0 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 602
  tmp = find_api_info(cmd);
#line 602
  info = tmp;
#line 610
  tmp___0 = get_current();
#line 610
  w.flags = 0U;
#line 610
  w.private = (void *)tmp___0;
#line 610
  w.func = & autoremove_wake_function;
#line 610
  w.task_list.next = & w.task_list;
#line 610
  w.task_list.prev = & w.task_list;
#line 612
  if ((unsigned long )info == (unsigned long )((struct cx18_api_info  const  *)0)) {
#line 613
    printk("\f%s: unknown cmd %x\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 614
    return (-22);
  } else {

  }
#line 617
  if ((cx18_debug & 4) != 0) {
#line 618
    if (cmd == 537133061U) {
#line 619
      if ((cx18_debug & 256) != 0) {
#line 620
        if ((cx18_debug & 4) != 0 && (cx18_debug & 256) != 0) {
#line 620
          tmp___1 = u32arr2hex(data, args, (char *)(& argstr));
#line 620
          printk("\016%s:  api: %s\tcmd %#010x args%s\n", (char *)(& cx->v4l2_dev.name),
                 info->name, cmd, tmp___1);
        } else {

        }
      } else {

      }
    } else
#line 624
    if ((cx18_debug & 4) != 0) {
#line 624
      tmp___2 = u32arr2hex(data, args, (char *)(& argstr));
#line 624
      printk("\016%s:  api: %s\tcmd %#010x args%s\n", (char *)(& cx->v4l2_dev.name),
             info->name, cmd, tmp___2);
    } else {

    }
  } else {

  }
#line 629
  switch ((int )info->rpu) {
  case 0: 
#line 631
  waitq = & cx->mb_apu_waitq;
#line 632
  mb_lock = & cx->epu2apu_mb_lock;
#line 633
  irq = 128U;
#line 634
  mb = & (cx->scb)->epu2apu_mb;
#line 635
  goto ldv_53827;
  case 1: 
#line 637
  waitq = & cx->mb_cpu_waitq;
#line 638
  mb_lock = & cx->epu2cpu_mb_lock;
#line 639
  irq = 8U;
#line 640
  mb = & (cx->scb)->epu2cpu_mb;
#line 641
  goto ldv_53827;
  default: 
#line 643
  printk("\f%s: Unknown RPU (%d) for API call\n", (char *)(& cx->v4l2_dev.name), (int )info->rpu);
#line 644
  return (-22);
  }
  ldv_53827: 
#line 647
  ldv_mutex_lock_448(mb_lock);
#line 658
  req = cx18_readl(cx, (void const   *)(& mb->request));
#line 659
  timeout = msecs_to_jiffies(10U);
#line 660
  __ret = (long )timeout;
#line 660
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c",
                662, 0);
#line 660
  ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 660
  __cond___0 = ack == req;
#line 660
  if ((int )__cond___0 && __ret == 0L) {
#line 660
    __ret = 1L;
  } else {

  }
#line 660
  if (((int )__cond___0 || __ret == 0L) == 0) {
#line 660
    __ret___0 = (long )timeout;
#line 660
    INIT_LIST_HEAD(& __wait.task_list);
#line 660
    __wait.flags = 0U;
    ldv_53840: 
#line 660
    tmp___3 = prepare_to_wait_event(waitq, & __wait, 2);
#line 660
    __int = tmp___3;
#line 660
    ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 660
    __cond = ack == req;
#line 660
    if ((int )__cond && __ret___0 == 0L) {
#line 660
      __ret___0 = 1L;
    } else {

    }
#line 660
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 660
      goto ldv_53839;
    } else {

    }
#line 660
    __ret___0 = schedule_timeout(__ret___0);
#line 660
    goto ldv_53840;
    ldv_53839: 
#line 660
    finish_wait(waitq, & __wait);
#line 660
    __ret = __ret___0;
  } else {

  }
#line 660
  ret = (unsigned long )__ret;
#line 663
  if (req != ack) {
#line 665
    cx18_writel___4(cx, req, (void *)(& mb->ack));
#line 666
    printk("\v%s: mbox was found stuck busy when setting up for %s; clearing busy and trying to proceed\n",
           (char *)(& cx->v4l2_dev.name), info->name);
  } else
#line 668
  if (ret != timeout) {
#line 669
    if ((cx18_debug & 4) != 0) {
#line 669
      tmp___4 = jiffies_to_msecs(timeout - ret);
#line 669
      printk("\016%s:  api: waited %u msecs for busy mbox to be acked\n", (char *)(& cx->v4l2_dev.name),
             tmp___4);
    } else {

    }
  } else {

  }
#line 673
  req = (req & 4294967294U) != 4294967294U ? req + 1U : 1U;
#line 675
  cx18_writel___4(cx, cmd, (void *)(& mb->cmd));
#line 676
  i = 0;
#line 676
  goto ldv_53844;
  ldv_53843: 
#line 677
  cx18_writel___4(cx, *(data + (unsigned long )i), (void *)(& mb->args) + (unsigned long )i);
#line 676
  i = i + 1;
  ldv_53844: ;
#line 676
  if (i < args) {
#line 678
    goto ldv_53843;
  } else {

  }
#line 678
  cx18_writel___4(cx, 0U, (void *)(& mb->error));
#line 679
  cx18_writel___4(cx, req, (void *)(& mb->request));
#line 680
  cx18_writel___4(cx, req - 1U, (void *)(& mb->ack));
#line 685
  timeout = msecs_to_jiffies(((int )info->flags & 4) != 0 ? 10U : 20U);
#line 687
  if ((cx18_debug & 128) != 0 && (cx18_debug & 256) != 0) {
#line 687
    printk("\016%s:  irq: sending interrupt SW1: %x to send %s\n", (char *)(& cx->v4l2_dev.name),
           irq, info->name);
  } else {

  }
#line 691
  prepare_to_wait(waitq, & w, 2);
#line 692
  cx18_write_reg_expect___2(cx, irq, 13054208U, irq, irq);
#line 694
  t0 = jiffies;
#line 695
  ack = cx18_readl(cx, (void const   *)(& mb->ack));
#line 696
  if (ack != req) {
#line 697
    schedule_timeout((long )timeout);
#line 698
    ret = (unsigned long )jiffies - t0;
#line 699
    ack = cx18_readl(cx, (void const   *)(& mb->ack));
  } else {
#line 701
    ret = (unsigned long )jiffies - t0;
  }
#line 704
  finish_wait(waitq, & w);
#line 706
  if (req != ack) {
#line 707
    ldv_mutex_unlock_449(mb_lock);
#line 708
    if (ret >= timeout) {
#line 710
      if (cx18_debug & 1) {
#line 710
        tmp___5 = jiffies_to_msecs(ret);
#line 710
        printk("\016%s:  warning: sending %s timed out waiting %d msecs for RPU acknowledgement\n",
               (char *)(& cx->v4l2_dev.name), info->name, tmp___5);
      } else {

      }
    } else
#line 714
    if (cx18_debug & 1) {
#line 714
      tmp___6 = jiffies_to_msecs(ret);
#line 714
      printk("\016%s:  warning: woken up before mailbox ack was ready after submitting %s to RPU.  only waited %d msecs on req %u but awakened with unmatched ack %u\n",
             (char *)(& cx->v4l2_dev.name), info->name, tmp___6, req, ack);
    } else {

    }
#line 722
    return (-22);
  } else {

  }
#line 725
  if (ret >= timeout) {
#line 726
    if (cx18_debug & 1) {
#line 726
      tmp___7 = jiffies_to_msecs(ret);
#line 726
      printk("\016%s:  warning: failed to be awakened upon RPU acknowledgment sending %s; timed out waiting %d msecs\n",
             (char *)(& cx->v4l2_dev.name), info->name, tmp___7);
    } else {

    }
  } else
#line 730
  if ((cx18_debug & 4) != 0 && (cx18_debug & 256) != 0) {
#line 730
    tmp___8 = jiffies_to_msecs(ret);
#line 730
    printk("\016%s:  api: waited %u msecs for %s to be acked\n", (char *)(& cx->v4l2_dev.name),
           tmp___8, info->name);
  } else {

  }
#line 734
  i = 0;
#line 734
  goto ldv_53847;
  ldv_53846: 
#line 735
  *(data + (unsigned long )i) = cx18_readl(cx, (void const   *)(& mb->args) + (unsigned long )i);
#line 734
  i = i + 1;
  ldv_53847: ;
#line 734
  if (i <= 5) {
#line 736
    goto ldv_53846;
  } else {

  }
#line 736
  err = cx18_readl(cx, (void const   *)(& mb->error));
#line 737
  ldv_mutex_unlock_450(mb_lock);
#line 744
  if (((int )info->flags & 8) != 0) {
#line 745
    cx18_msleep_timeout(300U, 0);
  } else {

  }
#line 747
  if (err != 0U) {
#line 748
    if ((cx18_debug & 4) != 0) {
#line 748
      printk("\016%s:  api: mailbox error %08x for command %s\n", (char *)(& cx->v4l2_dev.name),
             err, info->name);
    } else {

    }
  } else {

  }
#line 750
  return (err != 0U ? -5 : 0);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
int cx18_api(struct cx18 *cx , u32 cmd , int args , u32 *data ) 
{ 
  int tmp ;

  {
#line 755
  tmp = cx18_api_call(cx, cmd, args, data);
#line 755
  return (tmp);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
static int cx18_set_filter_param(struct cx18_stream *s ) 
{ 
  struct cx18 *cx ;
  u32 mode ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 760
  cx = s->cx;
#line 764
  mode = (int )cx->filter_mode & 1 ? 2U : cx->spatial_strength != 0U;
#line 765
  ret = cx18_vapi(cx, 537001993U, 4, s->handle, 1, mode, cx->spatial_strength);
#line 767
  mode = (cx->filter_mode & 2U) == 0U ? cx->temporal_strength != 0U : 2U;
#line 768
  if (ret == 0) {
#line 768
    tmp = cx18_vapi(cx, 537001993U, 4, s->handle, 0, mode, cx->temporal_strength);
#line 768
    ret = tmp;
  } else {
#line 768
    ret = ret;
  }
#line 770
  if (ret == 0) {
#line 770
    tmp___0 = cx18_vapi(cx, 537001993U, 4, s->handle, 2, cx->filter_mode >> 2, 0);
#line 770
    ret = tmp___0;
  } else {
#line 770
    ret = ret;
  }
#line 772
  return (ret);
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
int cx18_api_func(void *priv , u32 cmd , int in , int out , u32 *data ) 
{ 
  struct cx18_stream *s ;
  struct cx18 *cx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 778
  s = (struct cx18_stream *)priv;
#line 779
  cx = s->cx;
#line 781
  switch (cmd) {
  case 187U: ;
#line 783
  return (0);
  case 143U: 
#line 785
  tmp = cx18_vapi(cx, 537001988U, 6, s->handle, 0, 0, 0, 0, *data);
#line 785
  return (tmp);
  case 145U: 
#line 788
  tmp___0 = cx18_vapi(cx, 537001990U, 3, s->handle, *(data + 1UL), *data);
#line 788
  return (tmp___0);
  case 185U: 
#line 791
  tmp___1 = cx18_vapi(cx, 537002002U, 2, s->handle, *data);
#line 791
  return (tmp___1);
  case 153U: 
#line 794
  tmp___2 = cx18_vapi(cx, 537002014U, 2, s->handle, *data);
#line 794
  return (tmp___2);
  case 151U: 
#line 798
  tmp___3 = cx18_vapi(cx, 537002012U, 3, s->handle, *data, *(data + 1UL));
#line 798
  return (tmp___3);
  case 197U: ;
#line 801
  return (0);
  case 189U: 
#line 803
  tmp___4 = cx18_vapi(cx, 537002001U, 2, s->handle, *data);
#line 803
  return (tmp___4);
  case 218U: 
#line 806
  tmp___5 = cx18_vapi(cx, 537002004U, 2, s->handle, *data);
#line 806
  return (tmp___5);
  case 149U: 
#line 809
  tmp___6 = cx18_vapi(cx, 537001989U, 5, s->handle, *data, *(data + 1UL), *(data + 2UL),
                      *(data + 3UL));
#line 809
  return (tmp___6);
  case 217U: 
#line 812
  tmp___7 = cx18_vapi(cx, 537002003U, 2, s->handle, *data);
#line 812
  return (tmp___7);
  case 208U: 
#line 815
  tmp___8 = cx18_vapi(cx, 537002015U, 2, s->handle, *data);
#line 815
  return (tmp___8);
  case 220U: 
#line 818
  tmp___9 = cx18_vapi(cx, 537002005U, 4, s->handle, *data, *(data + 1UL), *(data + 2UL));
#line 818
  return (tmp___9);
  case 155U: 
#line 821
  cx->filter_mode = (*data & 3U) | (*(data + 1UL) << 2);
#line 822
  tmp___10 = cx18_set_filter_param(s);
#line 822
  return (tmp___10);
  case 157U: 
#line 824
  cx->spatial_strength = *data;
#line 825
  cx->temporal_strength = *(data + 1UL);
#line 826
  tmp___11 = cx18_set_filter_param(s);
#line 826
  return (tmp___11);
  case 161U: 
#line 828
  tmp___12 = cx18_vapi(cx, 537001996U, 3, s->handle, *data, *(data + 1UL));
#line 828
  return (tmp___12);
  case 159U: 
#line 831
  tmp___13 = cx18_vapi(cx, 537001998U, 5, s->handle, *data, *(data + 1UL), *(data + 2UL),
                       *(data + 3UL));
#line 831
  return (tmp___13);
  }
#line 834
  printk("\f%s: Unknown cmd %x\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 835
  return (0);
}
}
#line 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
int cx18_vapi_result(struct cx18 *cx , u32 *data , u32 cmd , int args  , ...) 
{ 
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 844
  ldv__builtin_va_start((va_list *)(& ap));
#line 845
  i = 0;
#line 845
  goto ldv_53896;
  ldv_53895: 
#line 846
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 846
  *(data + (unsigned long )i) = tmp;
#line 845
  i = i + 1;
  ldv_53896: ;
#line 845
  if (i < args) {
#line 847
    goto ldv_53895;
  } else {

  }
#line 847
  ldv__builtin_va_end((va_list *)(& ap));
#line 848
  tmp___0 = cx18_api(cx, cmd, args, data);
#line 848
  return (tmp___0);
}
}
#line 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.c"
int cx18_vapi(struct cx18 *cx , u32 cmd , int args  , ...) 
{ 
  u32 data[6U] ;
  va_list ap ;
  int i ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 857
  if ((unsigned long )cx == (unsigned long )((struct cx18 *)0)) {
#line 858
    printk("\v%s: cx == NULL (cmd=%x)\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 859
    return (0);
  } else {

  }
#line 861
  if (args > 6) {
#line 862
    printk("\v%s: args too big (cmd=%x)\n", (char *)(& cx->v4l2_dev.name), cmd);
#line 863
    args = 6;
  } else {

  }
#line 865
  ldv__builtin_va_start((va_list *)(& ap));
#line 866
  i = 0;
#line 866
  goto ldv_53907;
  ldv_53906: 
#line 867
  ldv__builtin_va_arg(ap, sizeof(u32 ), (void *)(& tmp));
#line 867
  data[i] = tmp;
#line 866
  i = i + 1;
  ldv_53907: ;
#line 866
  if (i < args) {
#line 868
    goto ldv_53906;
  } else {

  }
#line 868
  ldv__builtin_va_end((va_list *)(& ap));
#line 869
  tmp___0 = cx18_api(cx, cmd, args, (u32 *)(& data));
#line 869
  return (tmp___0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
bool ldv_queue_work_on_431(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
bool ldv_queue_delayed_work_on_432(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
bool ldv_queue_work_on_433(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_flush_workqueue_434(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
bool ldv_queue_delayed_work_on_435(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_439(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_440(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_mutex_trylock_441(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_442(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_443(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_444(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
int ldv_mod_timer_447(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 440
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 440
  ldv_func_res = tmp;
#line 442
  activate_pending_timer_5(ldv_func_arg1, ldv_func_arg2, 1);
#line 444
  return (ldv_func_res);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_lock_448(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 450
  ldv_mutex_lock_mb_lock(ldv_func_arg1);
#line 452
  mutex_lock(ldv_func_arg1);
#line 453
  return;
}
}
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_449(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 458
  ldv_mutex_unlock_mb_lock(ldv_func_arg1);
#line 460
  mutex_unlock(ldv_func_arg1);
#line 461
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-mailbox.o.c.prepared"
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 466
  ldv_mutex_unlock_mb_lock(ldv_func_arg1);
#line 468
  mutex_unlock(ldv_func_arg1);
#line 469
  return;
}
}
#line 61 "./arch/x86/include/asm/string_64.h"
extern void *__memmove(void * , void const   * , size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_485(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_481(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_486(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_488(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_480(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_487(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_489(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_475(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_476(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_478(struct workqueue_struct *ldv_func_arg1 ) ;
#line 495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_active_samples___2  =    1444U;
#line 496 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_60Hz___0  =    272U;
#line 497 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-driver.h"
static unsigned int const   vbi_hblank_samples_50Hz___0  =    284U;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static u8 const   raw_vbi_sav_rp[2U]  = {      32U,      96U};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static u8 const   sliced_vbi_eav_rp[2U]  = {      176U,      240U};
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static void copy_vbi_data(struct cx18 *cx , int lines , u32 pts_stamp ) 
{ 
  int line ;
  int i ;
  u32 linemask[2U] ;
  unsigned short size ;
  u8 mpeg_hdr_data[32U] ;
  int sd ;
  int idx ;
  u8 *dst ;
  struct v4l2_sliced_vbi_data *sdata ;
  int f ;
  int l ;
  u16 tmp ;

  {
#line 41
  line = 0;
#line 43
  linemask[0] = 0U;
#line 43
  linemask[1] = 0U;
#line 45
  mpeg_hdr_data[0] = 0U;
#line 45
  mpeg_hdr_data[1] = 0U;
#line 45
  mpeg_hdr_data[2] = 1U;
#line 45
  mpeg_hdr_data[3] = 186U;
#line 45
  mpeg_hdr_data[4] = 68U;
#line 45
  mpeg_hdr_data[5] = 0U;
#line 45
  mpeg_hdr_data[6] = 12U;
#line 45
  mpeg_hdr_data[7] = 102U;
#line 45
  mpeg_hdr_data[8] = 36U;
#line 45
  mpeg_hdr_data[9] = 1U;
#line 45
  mpeg_hdr_data[10] = 1U;
#line 45
  mpeg_hdr_data[11] = 209U;
#line 45
  mpeg_hdr_data[12] = 211U;
#line 45
  mpeg_hdr_data[13] = 250U;
#line 45
  mpeg_hdr_data[14] = 255U;
#line 45
  mpeg_hdr_data[15] = 255U;
#line 45
  mpeg_hdr_data[16] = 0U;
#line 45
  mpeg_hdr_data[17] = 0U;
#line 45
  mpeg_hdr_data[18] = 1U;
#line 45
  mpeg_hdr_data[19] = 189U;
#line 45
  mpeg_hdr_data[20] = 0U;
#line 45
  mpeg_hdr_data[21] = 26U;
#line 45
  mpeg_hdr_data[22] = 132U;
#line 45
  mpeg_hdr_data[23] = 128U;
#line 45
  mpeg_hdr_data[24] = 7U;
#line 45
  mpeg_hdr_data[25] = 33U;
#line 45
  mpeg_hdr_data[26] = 0U;
#line 45
  mpeg_hdr_data[27] = 93U;
#line 45
  mpeg_hdr_data[28] = 99U;
#line 45
  mpeg_hdr_data[29] = 167U;
#line 45
  mpeg_hdr_data[30] = 255U;
#line 45
  mpeg_hdr_data[31] = 255U;
#line 58
  sd = 32;
#line 59
  idx = (int )cx->vbi.frame & 31;
#line 60
  dst = cx->vbi.sliced_mpeg_data[idx];
#line 62
  i = 0;
#line 62
  goto ldv_53325;
  ldv_53324: 
#line 63
  sdata = (struct v4l2_sliced_vbi_data *)(& cx->vbi.sliced_data) + (unsigned long )i;
#line 66
  if (sdata->id == 0U) {
#line 67
    goto ldv_53323;
  } else {

  }
#line 69
  l = (int )(sdata->line - 6U);
#line 70
  f = (int )sdata->field;
#line 71
  if (f != 0) {
#line 72
    l = l + 18;
  } else {

  }
#line 73
  if (l <= 31) {
#line 74
    linemask[0] = linemask[0] | (u32 )(1 << l);
  } else {
#line 76
    linemask[1] = linemask[1] | (u32 )(1 << (l + -32));
  }
#line 77
  tmp = cx18_service2vbi((int )sdata->id);
#line 77
  *(dst + (unsigned long )((sd + 12) + line * 43)) = (u8 )tmp;
#line 78
  memcpy((void *)(dst + (((unsigned long )sd + (unsigned long )(line * 43)) + 13UL)),
           (void const   *)(& sdata->data), 42UL);
#line 79
  line = line + 1;
  ldv_53323: 
#line 62
  i = i + 1;
  ldv_53325: ;
#line 62
  if (i < lines) {
#line 64
    goto ldv_53324;
  } else {

  }
#line 81
  memcpy((void *)dst, (void const   *)(& mpeg_hdr_data), 32UL);
#line 82
  if (line == 36) {
#line 86
    memcpy((void *)dst + (unsigned long )sd, (void const   *)"ITV0", 4UL);
#line 87
    __memmove((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(dst + ((unsigned long )sd + 12UL)),
              (size_t )(line * 43));
#line 88
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 4U;
  } else {
#line 90
    memcpy((void *)dst + (unsigned long )sd, (void const   *)"itv0", 4UL);
#line 93
    memcpy((void *)(dst + ((unsigned long )sd + 4UL)), (void const   *)(& linemask),
             8UL);
#line 94
    size = (((unsigned int )((unsigned short )line) * 43U + 3U) & 65532U) + 12U;
  }
#line 96
  *(dst + 20UL) = (u8 )(((int )size + 10) >> 8);
#line 97
  *(dst + 21UL) = (u8 )((unsigned int )((unsigned char )size) + 10U);
#line 98
  *(dst + 25UL) = ((unsigned int )((u8 )(pts_stamp >> 29)) & 6U) | 33U;
#line 99
  *(dst + 26UL) = (u8 )(pts_stamp >> 22);
#line 100
  *(dst + 27UL) = (unsigned int )((u8 )(pts_stamp >> 14)) | 1U;
#line 101
  *(dst + 28UL) = (u8 )(pts_stamp >> 7);
#line 102
  *(dst + 29UL) = (unsigned int )((int )((u8 )pts_stamp) << 1U) | 1U;
#line 103
  cx->vbi.sliced_mpeg_size[idx] = (u32 )((int )size + sd);
#line 104
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static u32 compress_raw_buf(struct cx18 *cx , u8 *buf , u32 size , u32 hdr_size ) 
{ 
  u32 line_size ;
  u32 lines ;
  u8 *q ;
  u8 *p ;
  int i ;

  {
#line 111
  line_size = vbi_active_samples___2;
#line 112
  lines = cx->vbi.count * 2U;
#line 113
  q = buf;
#line 118
  buf = buf + (unsigned long )hdr_size;
#line 120
  i = 0;
#line 120
  goto ldv_53340;
  ldv_53339: 
#line 121
  p = buf + (unsigned long )((u32 )i * line_size);
#line 124
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || ((int )*(p + 3UL) != (int )((unsigned char )raw_vbi_sav_rp[0]) && (int )*(p + 3UL) != (int )((unsigned char )raw_vbi_sav_rp[1]))) {
#line 127
    goto ldv_53338;
  } else {

  }
#line 128
  if ((u32 )i == lines - 1U) {
#line 130
    memcpy((void *)q, (void const   *)p + 4U, (size_t )((line_size - hdr_size) - 4U));
#line 131
    q = q + (unsigned long )((line_size - hdr_size) - 4U);
#line 132
    p = p + (unsigned long )((line_size - hdr_size) - 1U);
#line 133
    memset((void *)q, (int )*p, (size_t )hdr_size);
  } else {
#line 135
    memcpy((void *)q, (void const   *)p + 4U, (size_t )(line_size - 4U));
#line 136
    q = q + (unsigned long )(line_size - 4U);
  }
#line 120
  i = i + 1;
  ldv_53340: ;
#line 120
  if ((u32 )i < lines) {
#line 122
    goto ldv_53339;
  } else {

  }
  ldv_53338: ;
#line 139
  return ((line_size - 4U) * lines);
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static u32 compress_sliced_buf(struct cx18 *cx , u8 *buf , u32 size , u32 const   hdr_size ) 
{ 
  struct v4l2_decode_vbi_line vbi ;
  int i ;
  u32 line ;
  u32 line_size ;
  u8 *p ;

  {
#line 147
  line = 0U;
#line 148
  line_size = (unsigned int )cx->is_60hz != 0U ? vbi_hblank_samples_60Hz___0 : vbi_hblank_samples_50Hz___0;
#line 152
  i = (int )hdr_size;
#line 152
  buf = buf + (unsigned long )hdr_size;
#line 152
  goto ldv_53353;
  ldv_53352: ;
#line 153
  if ((((unsigned int )*buf == 255U && (unsigned int )*(buf + 1UL) == 0U) && (unsigned int )*(buf + 2UL) == 0U) && ((int )*(buf + 3UL) == (int )((unsigned char )sliced_vbi_eav_rp[0]) || (int )*(buf + 3UL) == (int )((unsigned char )sliced_vbi_eav_rp[1]))) {
#line 156
    goto ldv_53351;
  } else {

  }
#line 152
  i = i + 1;
#line 152
  buf = buf + 1;
  ldv_53353: ;
#line 152
  if ((u32 )i < size) {
#line 154
    goto ldv_53352;
  } else {

  }
  ldv_53351: 
#line 164
  size = ((unsigned int )hdr_size - (unsigned int )i) + size;
#line 165
  if (size < line_size) {
#line 166
    return (line);
  } else {

  }
#line 168
  i = 0;
#line 168
  goto ldv_53357;
  ldv_53356: 
#line 169
  p = buf + (unsigned long )((u32 )i * line_size);
#line 172
  if ((((unsigned int )*p != 255U || (unsigned int )*(p + 1UL) != 0U) || (unsigned int )*(p + 2UL) != 0U) || ((int )*(p + 3UL) != (int )((unsigned char )sliced_vbi_eav_rp[0]) && (int )*(p + 3UL) != (int )((unsigned char )sliced_vbi_eav_rp[1]))) {
#line 175
    goto ldv_53355;
  } else {

  }
#line 176
  vbi.p = p + 4UL;
#line 177
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 177
    if ((unsigned long )((cx->sd_av)->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->vbi)->decode_vbi_line != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                struct v4l2_decode_vbi_line * ))0)) {
#line 177
      (*((((cx->sd_av)->ops)->vbi)->decode_vbi_line))(cx->sd_av, & vbi);
    } else {

    }
  } else {

  }
#line 178
  if (vbi.type != 0U) {
#line 179
    cx->vbi.sliced_data[line].id = vbi.type;
#line 180
    cx->vbi.sliced_data[line].field = vbi.is_second_field;
#line 181
    cx->vbi.sliced_data[line].line = vbi.line;
#line 182
    memcpy((void *)(& cx->vbi.sliced_data[line].data), (void const   *)vbi.p, 42UL);
#line 183
    line = line + 1U;
  } else {

  }
  ldv_53355: 
#line 168
  i = i + 1;
  ldv_53357: ;
#line 168
  if ((u32 )i < size / line_size) {
#line 170
    goto ldv_53356;
  } else {

  }

#line 186
  return (line);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
static void _cx18_process_vbi_data(struct cx18 *cx , struct cx18_buffer *buf ) 
{ 
  struct vbi_data_hdr *hdr ;
  u8 *p ;
  u32 size ;
  u32 pts ;
  int lines ;
  u32 tmp ;
  int tmp___0 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  u32 tmp___4 ;

  {
#line 199
  hdr = (struct vbi_data_hdr *)buf->buf;
#line 201
  p = (u8 *)buf->buf;
#line 202
  size = buf->bytesused;
#line 211
  cx18_buf_swap(buf);
#line 214
  tmp___0 = cx18_raw_vbi((struct cx18  const  *)cx);
#line 214
  if (tmp___0 != 0) {
#line 216
    tmp = compress_raw_buf(cx, p, size, 12U);
#line 216
    buf->bytesused = tmp;
#line 216
    size = tmp;
#line 223
    p = p + (unsigned long )(size - 4U);
#line 224
    memcpy((void *)p, (void const   *)(& cx->vbi.frame), 4UL);
#line 225
    cx->vbi.frame = cx->vbi.frame + 1U;
#line 226
    return;
  } else {

  }
#line 231
  tmp___3 = __fswab32(hdr->magic);
#line 231
  if (tmp___3 == 1073741823U) {
#line 231
    tmp___2 = __fswab32(hdr->pts);
#line 231
    pts = tmp___2;
  } else {
#line 231
    pts = 0U;
  }
#line 234
  tmp___4 = compress_sliced_buf(cx, p, size, 12U);
#line 234
  lines = (int )tmp___4;
#line 237
  if (lines == 0) {
#line 238
    cx->vbi.sliced_data[0].id = 0U;
#line 239
    cx->vbi.sliced_data[0].line = 0U;
#line 240
    cx->vbi.sliced_data[0].field = 0U;
#line 241
    lines = 1;
  } else {

  }
#line 243
  size = (u32 )((unsigned long )lines) * 64U;
#line 243
  buf->bytesused = size;
#line 244
  memcpy((void *)p, (void const   *)(& cx->vbi.sliced_data), (size_t )size);
#line 246
  if (cx->vbi.insert_mpeg != 0) {
#line 247
    copy_vbi_data(cx, lines, pts);
  } else {

  }
#line 248
  cx->vbi.frame = cx->vbi.frame + 1U;
#line 249
  return;
}
}
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.c"
void cx18_process_vbi_data(struct cx18 *cx , struct cx18_mdl *mdl , int streamtype ) 
{ 
  struct cx18_buffer *buf ;
  u32 orig_used ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 257
  if (streamtype != 3) {
#line 258
    return;
  } else {

  }
#line 270
  __mptr = (struct list_head  const  *)mdl->buf_list.next;
#line 270
  buf = (struct cx18_buffer *)__mptr;
#line 270
  goto ldv_53385;
  ldv_53384: 
#line 271
  orig_used = buf->bytesused;
#line 272
  if (orig_used == 0U) {
#line 273
    goto ldv_53383;
  } else {

  }
#line 274
  _cx18_process_vbi_data(cx, buf);
#line 275
  mdl->bytesused = mdl->bytesused + (buf->bytesused - orig_used);
#line 270
  __mptr___0 = (struct list_head  const  *)buf->list.next;
#line 270
  buf = (struct cx18_buffer *)__mptr___0;
  ldv_53385: ;
#line 270
  if ((unsigned long )(& buf->list) != (unsigned long )(& mdl->buf_list)) {
#line 272
    goto ldv_53384;
  } else {

  }
  ldv_53383: ;
#line 277
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
bool ldv_queue_work_on_475(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_476(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
bool ldv_queue_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_flush_workqueue_478(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_480(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_unlock_481(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
int ldv_mutex_trylock_485(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_unlock_486(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_487(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_unlock_488(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_lock_489(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-vbi.o.c.prepared"
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_521(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_517(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_518(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_522(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_524(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_526(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_516(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_519(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_520(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_523(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_525(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_512(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_515(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_514(struct workqueue_struct *ldv_func_arg1 ) ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.c"
int cx18_audio_set_io(struct cx18 *cx ) 
{ 
  struct cx18_card_audio_input  const  *in ;
  u32 u ;
  u32 v ;
  int err ;
  int tmp ;
  struct v4l2_subdev *__sd ;
  long __err ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 44
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& cx->i_flags));
#line 44
  if (tmp != 0) {
#line 45
    in = & (cx->card)->radio_input;
  } else {
#line 47
    in = (struct cx18_card_audio_input  const  *)(& (cx->card)->audio_inputs) + (unsigned long )cx->audio_input;
  }
#line 50
  if ((unsigned long )cx->sd_extmux != (unsigned long )((struct v4l2_subdev *)0)) {
#line 50
    if ((unsigned long )((cx->sd_extmux)->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_extmux)->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ,
                                                                                                                                                                                                                                        u32  ))0)) {
#line 50
      (*((((cx->sd_extmux)->ops)->audio)->s_routing))(cx->sd_extmux, (unsigned int )in->muxer_input,
                                                      0U, 0U);
    } else {

    }
  } else {

  }
#line 53
  __err = 0L;
#line 53
  __mptr = (struct list_head  const  *)cx->v4l2_dev.subdevs.next;
#line 53
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 53
  goto ldv_53444;
  ldv_53443: ;
#line 53
  if ((((unsigned int )(cx->card)->hw_audio_ctrl == 0U || (__sd->grp_id & (u32 )(cx->card)->hw_audio_ctrl) != 0U) && (unsigned long )(__sd->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->audio)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                                                                                                                u32  ))0)) {
#line 53
    tmp___0 = (*(((__sd->ops)->audio)->s_routing))(__sd, in->audio_input, 0U, 0U);
#line 53
    __err = (long )tmp___0;
  } else {

  }
#line 53
  if (__err != 0L && __err != -515L) {
#line 53
    goto ldv_53442;
  } else {

  }
#line 53
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 53
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53444: ;
#line 53
  if ((unsigned long )(& __sd->list) != (unsigned long )(& cx->v4l2_dev.subdevs)) {
#line 55
    goto ldv_53443;
  } else {

  }
  ldv_53442: 
#line 53
  err = (int )(__err != -515L ? __err : 0L);
#line 55
  if (err != 0) {
#line 56
    return (err);
  } else {

  }
#line 59
  u = cx18_read_reg(cx, 13049876U);
#line 60
  v = u & 4294967247U;
#line 61
  switch (in->audio_input) {
  case 0U: 
#line 63
  v = v;
#line 64
  goto ldv_53448;
  case 1U: 
#line 66
  v = v | 16U;
#line 67
  goto ldv_53448;
  default: 
#line 69
  v = v | 32U;
#line 70
  goto ldv_53448;
  }
  ldv_53448: ;
#line 72
  if (v == u) {
#line 74
    u = u & 4294967247U;
#line 75
    switch (in->audio_input) {
    case 0U: 
#line 77
    u = u | 32U;
#line 78
    goto ldv_53452;
    case 1U: 
#line 80
    u = u | 32U;
#line 81
    goto ldv_53452;
    default: 
#line 83
    u = u;
#line 84
    goto ldv_53452;
    }
    ldv_53452: 
#line 86
    cx18_write_reg_expect(cx, u | 2816U, 13049876U, u, 48U);
  } else {

  }
#line 89
  cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 91
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_512(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
bool ldv_queue_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_flush_workqueue_514(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_515(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_516(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_unlock_517(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_unlock_518(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_519(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_520(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
int ldv_mutex_trylock_521(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_unlock_522(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_523(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_unlock_524(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_lock_525(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-audio.o.c.prepared"
void ldv_mutex_unlock_526(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_557(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_553(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_558(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_560(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_562(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_552(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_556(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_559(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_561(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_547(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_549(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_548(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_550(struct workqueue_struct *ldv_func_arg1 ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.c"
void cx18_video_set_io(struct cx18 *cx ) 
{ 
  int inp ;

  {
#line 28
  inp = (int )cx->active_input;
#line 30
  if ((unsigned long )cx->sd_av != (unsigned long )((struct v4l2_subdev *)0)) {
#line 30
    if ((unsigned long )((cx->sd_av)->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )(((cx->sd_av)->ops)->video)->s_routing != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                u32  ,
                                                                                                                                                                                                                                u32  ))0)) {
#line 30
      (*((((cx->sd_av)->ops)->video)->s_routing))(cx->sd_av, (cx->card)->video_inputs[inp].video_input,
                                                  0U, 0U);
    } else {

    }
  } else {

  }
#line 31
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
bool ldv_queue_work_on_547(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
bool ldv_queue_delayed_work_on_548(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
bool ldv_queue_work_on_549(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_flush_workqueue_550(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
bool ldv_queue_delayed_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_552(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_unlock_553(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_556(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
int ldv_mutex_trylock_557(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_unlock_558(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_559(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_unlock_560(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_lock_561(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-video.o.c.prepared"
void ldv_mutex_unlock_562(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_593(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_590(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_594(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_588(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_591(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_585(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_584(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_587(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_586(struct workqueue_struct *ldv_func_arg1 ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.c"
static void xpu_ack(struct cx18 *cx , u32 sw2 ) 
{ 


  {
#line 31
  if ((sw2 & 8U) != 0U) {
#line 32
    __wake_up(& cx->mb_cpu_waitq, 3U, 1, (void *)0);
  } else {

  }
#line 33
  if ((sw2 & 128U) != 0U) {
#line 34
    __wake_up(& cx->mb_apu_waitq, 3U, 1, (void *)0);
  } else {

  }
#line 35
  return;
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.c"
static void epu_cmd___0(struct cx18 *cx , u32 sw1 ) 
{ 


  {
#line 39
  if ((sw1 & 65536U) != 0U) {
#line 40
    cx18_api_epu_cmd_irq(cx, 1);
  } else {

  }
#line 41
  if ((sw1 & 131072U) != 0U) {
#line 42
    cx18_api_epu_cmd_irq(cx, 0);
  } else {

  }
#line 43
  return;
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.c"
irqreturn_t cx18_irq_handler(int irq , void *dev_id ) 
{ 
  struct cx18 *cx ;
  u32 sw1 ;
  u32 sw2 ;
  u32 hw2 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
#line 47
  cx = (struct cx18 *)dev_id;
#line 50
  tmp = cx18_read_reg(cx, 13054212U);
#line 50
  sw1 = tmp & cx->sw1_irq_mask;
#line 51
  tmp___0 = cx18_read_reg(cx, 13054276U);
#line 51
  sw2 = tmp___0 & cx->sw2_irq_mask;
#line 52
  tmp___1 = cx18_read_reg(cx, 13054148U);
#line 52
  hw2 = tmp___1 & cx->hw2_irq_mask;
#line 54
  if (sw1 != 0U) {
#line 55
    cx18_write_reg_expect(cx, sw1, 13054212U, ~ sw1, sw1);
  } else {

  }
#line 56
  if (sw2 != 0U) {
#line 57
    cx18_write_reg_expect(cx, sw2, 13054276U, ~ sw2, sw2);
  } else {

  }
#line 58
  if (hw2 != 0U) {
#line 59
    cx18_write_reg_expect(cx, hw2, 13054148U, ~ hw2, hw2);
  } else {

  }
#line 61
  if ((sw1 != 0U || sw2 != 0U) || hw2 != 0U) {
#line 62
    if ((cx18_debug & 128) != 0 && (cx18_debug & 256) != 0) {
#line 62
      printk("\016%s:  irq: received interrupts SW1: %x  SW2: %x  HW2: %x\n", (char *)(& cx->v4l2_dev.name),
             sw1, sw2, hw2);
    } else {

    }
  } else {

  }
#line 69
  if (sw1 != 0U) {
#line 70
    epu_cmd___0(cx, sw1);
  } else {

  }
#line 77
  if (sw2 != 0U) {
#line 78
    xpu_ack(cx, sw2);
  } else {

  }
#line 80
  return ((irqreturn_t )((sw1 != 0U || sw2 != 0U) || hw2 != 0U));
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
bool ldv_queue_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
bool ldv_queue_delayed_work_on_584(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
bool ldv_queue_work_on_585(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_flush_workqueue_586(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
bool ldv_queue_delayed_work_on_587(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_588(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_unlock_590(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_591(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
int ldv_mutex_trylock_593(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_unlock_594(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-irq.o.c.prepared"
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_629(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_625(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_626(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_630(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_634(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_624(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_627(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_628(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_619(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_620(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_622(struct workqueue_struct *ldv_func_arg1 ) ;
#line 343 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler * , unsigned int  ,
                                        struct lock_class_key * , char const   * ) ;
#line 398
extern int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler * ) ;
#line 443
extern struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                           u32  , s64  , s64  , u64  , s64  ) ;
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-av-core.h"
__inline static struct cx18_av_state *to_cx18_av_state(struct v4l2_subdev *sd ) 
{ 
  struct v4l2_subdev  const  *__mptr ;

  {
#line 348
  __mptr = (struct v4l2_subdev  const  *)sd;
#line 348
  return ((struct cx18_av_state *)__mptr);
}
}
#line 351 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-av-core.h"
__inline static struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_ctrl_handler  const  *__mptr ;

  {
#line 353
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 353
  return (& ((struct cx18_av_state *)__mptr + 0xfffffffffffffed0UL)->sd);
}
}
#line 358
int cx18_av_write(struct cx18 *cx , u16 addr , u8 value ) ;
#line 359
int cx18_av_write4(struct cx18 *cx , u16 addr , u32 value ) ;
#line 360
int cx18_av_write4_noretry(struct cx18 *cx , u16 addr , u32 value ) ;
#line 361
int cx18_av_write_expect(struct cx18 *cx , u16 addr , u8 value , u8 eval , u8 mask ) ;
#line 362
int cx18_av_write4_expect(struct cx18 *cx , u16 addr , u32 value , u32 eval , u32 mask ) ;
#line 364
u8 cx18_av_read(struct cx18 *cx , u16 addr ) ;
#line 365
u32 cx18_av_read4(struct cx18 *cx , u16 addr ) ;
#line 366
int cx18_av_and_or(struct cx18 *cx , u16 addr , unsigned int and_mask , u8 or_value ) ;
#line 367
int cx18_av_and_or4(struct cx18 *cx , u16 addr , u32 and_mask , u32 or_value ) ;
#line 368
void cx18_av_std_setup(struct cx18 *cx ) ;
#line 374
int cx18_av_loadfw(struct cx18 *cx ) ;
#line 378
int cx18_av_s_clock_freq(struct v4l2_subdev *sd , u32 freq ) ;
#line 379
void cx18_av_audio_set_path(struct cx18 *cx ) ;
#line 380
struct v4l2_ctrl_ops  const  cx18_av_audio_ctrl_ops ;
#line 384
int cx18_av_decode_vbi_line(struct v4l2_subdev *sd , struct v4l2_decode_vbi_line *vbi ) ;
#line 386
int cx18_av_s_raw_fmt(struct v4l2_subdev *sd , struct v4l2_vbi_format *fmt ) ;
#line 387
int cx18_av_g_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) ;
#line 388
int cx18_av_s_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) ;
#line 151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_noretry(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 153
  cx18_writel_noretry(cx, val, cx->reg_mem + (unsigned long )reg);
#line 154
  return;
}
}
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_write(struct cx18 *cx , u16 addr , u8 value ) 
{ 
  u32 reg ;
  u32 mask ;
  int shift ;
  u32 x ;
  u32 tmp ;

  {
#line 31
  reg = (u32 )(((int )addr & -4) + 12845056);
#line 32
  mask = 255U;
#line 33
  shift = ((int )addr & 3) * 8;
#line 34
  tmp = cx18_read_reg(cx, reg);
#line 34
  x = tmp;
#line 36
  x = (~ (mask << shift) & x) | ((unsigned int )value << shift);
#line 37
  cx18_write_reg(cx, x, reg);
#line 38
  return (0);
}
}
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_write_expect(struct cx18 *cx , u16 addr , u8 value , u8 eval , u8 mask ) 
{ 
  u32 reg ;
  int shift ;
  u32 x ;
  u32 tmp ;

  {
#line 43
  reg = (u32 )(((int )addr & -4) + 12845056);
#line 44
  shift = ((int )addr & 3) * 8;
#line 45
  tmp = cx18_read_reg(cx, reg);
#line 45
  x = tmp;
#line 47
  x = (~ (255U << shift) & x) | ((unsigned int )value << shift);
#line 48
  cx18_write_reg_expect(cx, x, reg, (unsigned int )eval << shift, (unsigned int )mask << shift);
#line 50
  return (0);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_write4(struct cx18 *cx , u16 addr , u32 value ) 
{ 


  {
#line 55
  cx18_write_reg(cx, value, (u32 )((int )addr + 12845056));
#line 56
  return (0);
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_write4_expect(struct cx18 *cx , u16 addr , u32 value , u32 eval , u32 mask ) 
{ 


  {
#line 62
  cx18_write_reg_expect(cx, value, (u32 )((int )addr + 12845056), eval, mask);
#line 63
  return (0);
}
}
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_write4_noretry(struct cx18 *cx , u16 addr , u32 value ) 
{ 


  {
#line 68
  cx18_write_reg_noretry(cx, value, (u32 )((int )addr + 12845056));
#line 69
  return (0);
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
u8 cx18_av_read(struct cx18 *cx , u16 addr ) 
{ 
  u32 x ;
  u32 tmp ;
  int shift ;

  {
#line 74
  tmp = cx18_read_reg(cx, (u32 )(((int )addr & -4) + 12845056));
#line 74
  x = tmp;
#line 75
  shift = ((int )addr & 3) * 8;
#line 77
  return ((u8 )(x >> shift));
}
}
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
u32 cx18_av_read4(struct cx18 *cx , u16 addr ) 
{ 
  u32 tmp ;

  {
#line 82
  tmp = cx18_read_reg(cx, (u32 )((int )addr + 12845056));
#line 82
  return (tmp);
}
}
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_and_or(struct cx18 *cx , u16 addr , unsigned int and_mask , u8 or_value ) 
{ 
  u8 tmp ;
  int tmp___0 ;

  {
#line 88
  tmp = cx18_av_read(cx, (int )addr);
#line 88
  tmp___0 = cx18_av_write(cx, (int )addr, ((int )tmp & (int )((u8 )and_mask)) | (int )or_value);
#line 88
  return (tmp___0);
}
}
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_and_or4(struct cx18 *cx , u16 addr , u32 and_mask , u32 or_value ) 
{ 
  u32 tmp ;
  int tmp___0 ;

  {
#line 96
  tmp = cx18_av_read4(cx, (int )addr);
#line 96
  tmp___0 = cx18_av_write4(cx, (int )addr, (tmp & and_mask) | or_value);
#line 96
  return (tmp___0);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static void cx18_av_init(struct cx18 *cx ) 
{ 


  {
#line 113
  cx18_av_write4(cx, 264, 370017295U);
#line 117
  cx18_av_write4(cx, 268, 2876158U);
#line 121
  cx18_av_write4(cx, 272, 5384109U);
#line 124
  cx18_av_write(cx, 295, 86);
#line 125
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static void cx18_av_initialize(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int default_volume ;
  u32 v ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  s64 tmp___5 ;

  {
#line 129
  tmp = to_cx18_av_state(sd);
#line 129
  state = tmp;
#line 130
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 130
  cx = (struct cx18 *)tmp___0;
#line 134
  cx18_av_loadfw(cx);
#line 136
  cx18_av_write4_expect(cx, 2048, 50331648U, 50331648U, 318767104U);
#line 140
  v = cx18_av_read4(cx, 0);
#line 142
  cx18_av_write4_expect(cx, 0, v | 1U, v, 65534U);
#line 144
  cx18_av_write4_expect(cx, 0, v & 65534U, v & 65534U, 65535U);
#line 148
  tmp___1 = cx18_av_read4(cx, 344);
#line 148
  v = tmp___1 & 3791650559U;
#line 150
  cx18_av_write4(cx, 344, v);
#line 152
  cx18_av_write4(cx, 344, v | 268435712U);
#line 154
  tmp___2 = cx18_av_read4(cx, 348);
#line 154
  v = tmp___2 & 3791650559U;
#line 156
  cx18_av_write4(cx, 348, v);
#line 158
  cx18_av_write4(cx, 348, v | 100663552U);
#line 161
  cx18_av_write4(cx, 308, 661506U);
#line 163
  tmp___3 = cx18_av_read4(cx, 316);
#line 163
  v = tmp___3 | 1U;
#line 165
  cx18_av_write4_expect(cx, 316, v, v, 50372367U);
#line 167
  cx18_av_write4_expect(cx, 316, v & 4294967294U, v & 4294967294U, 50372367U);
#line 171
  cx18_av_and_or4(cx, 276, 4294967295U, 265216U);
#line 174
  cx18_av_and_or4(cx, 280, 4294967295U, 2U);
#line 177
  cx18_av_write4(cx, 1188, 32768U);
#line 178
  cx18_av_write4(cx, 1188, 0U);
#line 195
  cx18_av_and_or4(cx, 256, 4294705151U, 1179648U);
#line 198
  cx18_av_init(cx);
#line 203
  cx18_av_and_or4(cx, 1024, 4294436848U, 33818624U);
#line 207
  cx18_av_and_or4(cx, 1184, 4294967295U, 5242880U);
#line 210
  cx18_av_and_or4(cx, 1164, 4294902015U, 8192U);
#line 219
  cx18_av_write4(cx, 1028, 1074996526U);
#line 242
  cx18_av_and_or4(cx, 260, 4278190080U, 23808U);
#line 249
  cx18_av_write4(cx, 1144, 1713898015U);
#line 250
  tmp___4 = cx18_av_read(cx, 2260);
#line 250
  default_volume = (int )tmp___4;
#line 255
  if (default_volume > 228) {
#line 257
    default_volume = 228;
#line 258
    cx18_av_write(cx, 2260, 228);
  } else
#line 259
  if (default_volume <= 19) {
#line 261
    default_volume = 20;
#line 262
    cx18_av_write(cx, 2260, 20);
  } else {

  }
#line 264
  default_volume = (((228 - default_volume) >> 1) + 23) << 9;
#line 265
  tmp___5 = (s64 )default_volume;
#line 265
  (state->volume)->default_value = tmp___5;
#line 265
  (state->volume)->cur.val = (s32 )tmp___5;
#line 266
  v4l2_ctrl_handler_setup(& state->hdl);
#line 267
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_reset(struct v4l2_subdev *sd , u32 val ) 
{ 


  {
#line 271
  cx18_av_initialize(sd);
#line 272
  return (0);
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_load_fw(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;

  {
#line 277
  tmp = to_cx18_av_state(sd);
#line 277
  state = tmp;
#line 279
  if (state->is_initialized == 0) {
#line 281
    state->is_initialized = 1;
#line 282
    cx18_av_initialize(sd);
  } else {

  }
#line 284
  return (0);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
void cx18_av_std_setup(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  v4l2_std_id std ;
  int src_decimation ;
  int hblank ;
  int hactive ;
  int burst ;
  int vblank ;
  int vactive ;
  int sc ;
  int vblank656 ;
  int luma_lpf ;
  int uv_lpf ;
  int comb ;
  u32 pll_int ;
  u32 pll_frac ;
  u32 pll_post ;
  u8 tmp ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  int fsc ;
  int pll ;
  u64 tmp___2 ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 289
  state = & cx->av_state;
#line 290
  sd = & state->sd;
#line 291
  std = state->std;
#line 297
  src_decimation = 543;
#line 305
  if ((std & 0xffffffffffff4fffULL) != 0ULL) {
#line 306
    cx18_av_write(cx, 1183, 17);
  } else {
#line 308
    cx18_av_write(cx, 1183, 20);
  }
#line 318
  if ((std & 16713471ULL) != 0ULL) {
#line 350
    vblank656 = 48;
#line 351
    vblank = 38;
#line 352
    vactive = 579;
#line 361
    hblank = 132;
#line 362
    hactive = 720;
#line 371
    burst = 93;
#line 372
    luma_lpf = 2;
#line 373
    if ((std & 255ULL) != 0ULL) {
#line 374
      uv_lpf = 1;
#line 375
      comb = 32;
#line 377
      sc = 688700;
    } else
#line 378
    if (std == 1024ULL) {
#line 379
      uv_lpf = 1;
#line 380
      comb = 32;
#line 382
      sc = 556422;
    } else {
#line 384
      uv_lpf = 0;
#line 385
      comb = 0;
#line 388
      sc = 672314;
    }
  } else {
#line 410
    vblank656 = 38;
#line 411
    vblank = 26;
#line 412
    vactive = 481;
#line 421
    hactive = 720;
#line 422
    hblank = 122;
#line 423
    luma_lpf = 1;
#line 424
    uv_lpf = 1;
#line 433
    if (std == 2048ULL) {
#line 434
      burst = 90;
#line 435
      luma_lpf = 2;
#line 436
      comb = 32;
#line 438
      sc = 688700;
    } else
#line 439
    if (std == 256ULL) {
#line 441
      burst = 97;
#line 442
      comb = 32;
#line 444
      sc = 555421;
    } else {
#line 446
      burst = 90;
#line 447
      comb = 102;
#line 449
      sc = 556032;
    }
  }
#line 454
  tmp = cx18_av_read(cx, 264);
#line 454
  pll_int = (u32 )tmp;
#line 455
  tmp___0 = cx18_av_read4(cx, 268);
#line 455
  pll_frac = tmp___0 & 33554431U;
#line 456
  tmp___1 = cx18_av_read(cx, 265);
#line 456
  pll_post = (u32 )tmp___1;
#line 457
  if ((cx18_debug & 2) != 0) {
#line 457
    printk("\016%s:  info: PLL regs = int: %u, frac: %u, post: %u\n", (char *)(& sd->name),
           pll_int, pll_frac, pll_post);
  } else {

  }
#line 460
  if (pll_post != 0U) {
#line 464
    pll = (int )((((unsigned long long )pll_int << 25) + (unsigned long long )pll_frac) * 28636360ULL >> 25);
#line 465
    pll = (int )((u32 )pll / pll_post);
#line 466
    if ((cx18_debug & 2) != 0) {
#line 466
      printk("\016%s:  info: Video PLL = %d.%06d MHz\n", (char *)(& sd->name), pll / 1000000,
             pll % 1000000);
    } else {

    }
#line 468
    if ((cx18_debug & 2) != 0) {
#line 468
      printk("\016%s:  info: Pixel rate = %d.%06d Mpixel/sec\n", (char *)(& sd->name),
             pll / 8000000, (pll / 8) % 1000000);
    } else {

    }
#line 471
    if ((cx18_debug & 2) != 0) {
#line 471
      printk("\016%s:  info: ADC XTAL/pixel clock decimation ratio = %d.%03d\n", (char *)(& sd->name),
             src_decimation / 256, ((src_decimation % 256) * 1000) / 256);
    } else {

    }
#line 475
    tmp___2 = (unsigned long long )sc * 28636360ULL;
#line 476
    __base = (uint32_t )src_decimation;
#line 476
    __rem = (uint32_t )(tmp___2 % (u64 )__base);
#line 476
    tmp___2 = tmp___2 / (u64 )__base;
#line 477
    fsc = (int )(tmp___2 >> 13);
#line 478
    if ((cx18_debug & 2) != 0) {
#line 478
      printk("\016%s:  info: Chroma sub-carrier initial freq = %d.%06d MHz\n", (char *)(& sd->name),
             fsc / 1000000, fsc % 1000000);
    } else {

    }
#line 482
    if ((cx18_debug & 2) != 0) {
#line 482
      printk("\016%s:  info: hblank %i, hactive %i, vblank %i, vactive %i, vblank656 %i, src_dec %i, burst 0x%02x, luma_lpf %i, uv_lpf %i, comb 0x%02x, sc 0x%06x\n",
             (char *)(& sd->name), hblank, hactive, vblank, vactive, vblank656, src_decimation,
             burst, luma_lpf, uv_lpf, comb, sc);
    } else {

    }
  } else {

  }
#line 492
  cx18_av_write(cx, 1136, (int )((u8 )hblank));
#line 493
  cx18_av_write(cx, 1137, (int )((u8 )(((int )((signed char )(hblank >> 8)) & 3) | (int )((signed char )(hactive << 4)))));
#line 495
  cx18_av_write(cx, 1138, (int )((u8 )(hactive >> 4)));
#line 498
  cx18_av_write(cx, 1139, (int )((u8 )burst));
#line 501
  cx18_av_write(cx, 1140, (int )((u8 )vblank));
#line 502
  cx18_av_write(cx, 1141, (int )((u8 )(((int )((signed char )(vblank >> 8)) & 3) | (int )((signed char )(vactive << 4)))));
#line 504
  cx18_av_write(cx, 1142, (int )((u8 )(vactive >> 4)));
#line 505
  cx18_av_write(cx, 1143, (int )((u8 )vblank656));
#line 508
  cx18_av_write(cx, 1144, (int )((u8 )src_decimation));
#line 509
  cx18_av_write(cx, 1145, (int )((u8 )(src_decimation >> 8)));
#line 512
  cx18_av_write(cx, 1146, (int )((u8 )((int )((signed char )(luma_lpf << 6)) | ((int )((signed char )(uv_lpf << 4)) & 48))));
#line 515
  cx18_av_write(cx, 1147, (int )((u8 )comb));
#line 518
  cx18_av_write(cx, 1148, (int )((u8 )sc));
#line 519
  cx18_av_write(cx, 1149, (int )((u8 )(sc >> 8)));
#line 520
  cx18_av_write(cx, 1150, (int )((u8 )(sc >> 16)));
#line 522
  if ((std & 16713471ULL) != 0ULL) {
#line 523
    state->slicer_line_delay = 1;
#line 524
    state->slicer_line_offset = state->slicer_line_delay + 4;
  } else {
#line 526
    state->slicer_line_delay = 0;
#line 527
    state->slicer_line_offset = state->slicer_line_delay + 8;
  }
#line 529
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 530
  return;
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static void input_change(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  v4l2_std_id std ;
  u8 v ;

  {
#line 534
  state = & cx->av_state;
#line 535
  std = state->std;
#line 539
  cx18_av_write(cx, 1183, (std & 45056ULL) != 0ULL ? 20 : 17);
#line 540
  cx18_av_and_or(cx, 1025, 4294967199U, 0);
#line 541
  cx18_av_and_or(cx, 1025, 4294967199U, 96);
#line 543
  if ((std & 63744ULL) != 0ULL) {
#line 544
    if (std == 8192ULL) {
#line 546
      cx18_av_write_expect(cx, 2056, 247, 247, 255);
#line 547
      cx18_av_write_expect(cx, 2059, 2, 2, 63);
    } else
#line 548
    if (std == 32768ULL) {
#line 550
      cx18_av_write_expect(cx, 2056, 248, 248, 255);
#line 551
      cx18_av_write_expect(cx, 2059, 3, 3, 63);
    } else {
#line 554
      cx18_av_write_expect(cx, 2056, 246, 246, 255);
#line 555
      cx18_av_write_expect(cx, 2059, 1, 1, 63);
    }
  } else
#line 557
  if ((std & 255ULL) != 0ULL) {
#line 559
    cx18_av_write_expect(cx, 2056, 255, 255, 255);
#line 560
    cx18_av_write_expect(cx, 2059, 3, 3, 63);
  } else
#line 561
  if ((std & 16711680ULL) != 0ULL) {
#line 563
    cx18_av_write_expect(cx, 2056, 255, 255, 255);
#line 564
    cx18_av_write_expect(cx, 2059, 3, 3, 63);
  } else {

  }
#line 567
  v = cx18_av_read(cx, 2051);
#line 568
  if (((int )v & 16) != 0) {
#line 570
    v = (unsigned int )v & 239U;
#line 571
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 572
    v = (u8 )((unsigned int )v | 16U);
#line 573
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 575
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_frequency(struct v4l2_subdev *sd , struct v4l2_frequency  const  *freq ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 580
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 580
  cx = (struct cx18 *)tmp;
#line 581
  input_change(cx);
#line 582
  return (0);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int set_input(struct cx18 *cx , enum cx18_av_video_input vid_input , enum cx18_av_audio_input aud_input ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  enum analog_signal_type ch[3U] ;
  u8 afe_mux_cfg ;
  u8 adc2_cfg ;
  u8 input_mode ;
  u32 afe_cfg ;
  int i ;
  int luma ;
  int r_chroma ;
  int b_chroma ;
  int luma___0 ;
  int chroma ;

  {
#line 588
  state = & cx->av_state;
#line 589
  sd = & state->sd;
#line 593
  ch[0] = 0;
#line 593
  ch[1] = 0;
#line 593
  ch[2] = 0;
#line 601
  if ((cx18_debug & 2) != 0) {
#line 601
    printk("\016%s:  info: decoder set video input %d, audio input %d\n", (char *)(& sd->name),
           (unsigned int )vid_input, (unsigned int )aud_input);
  } else {

  }
#line 604
  if ((unsigned int )vid_input != 0U && (unsigned int )vid_input <= 8U) {
#line 606
    afe_mux_cfg = (unsigned int )((u8 )vid_input) + 239U;
#line 607
    ch[0] = 1;
#line 608
    input_mode = 0U;
  } else
#line 609
  if ((unsigned int )vid_input > 4095U) {
#line 610
    luma = (int )vid_input & 61440;
#line 611
    r_chroma = (int )vid_input & 983040;
#line 612
    b_chroma = (int )vid_input & 15728640;
#line 614
    if ((((((((unsigned int )vid_input & 4278194175U) != 0U || luma <= 4095) || luma > 32768) || r_chroma <= 262143) || r_chroma > 393216) || b_chroma <= 7340031) || b_chroma > 8388608) {
#line 621
      printk("\v%s: 0x%06x is not a valid video input!\n", (char *)(& sd->name), (unsigned int )vid_input);
#line 623
      return (-22);
    } else {

    }
#line 625
    afe_mux_cfg = (u8 )((luma + -4096) >> 12);
#line 626
    ch[0] = 2;
#line 627
    afe_mux_cfg = (u8 )((int )((signed char )((r_chroma + -262144) >> 12)) | (int )((signed char )afe_mux_cfg));
#line 628
    ch[1] = 6;
#line 629
    afe_mux_cfg = (u8 )((int )((signed char )((b_chroma + -7340032) >> 14)) | (int )((signed char )afe_mux_cfg));
#line 630
    ch[2] = 5;
#line 631
    input_mode = 6U;
  } else {
#line 633
    luma___0 = (int )vid_input & 240;
#line 634
    chroma = (int )vid_input & 3840;
#line 636
    if ((((((unsigned int )vid_input & 4294963215U) != 0U || luma___0 <= 15) || luma___0 > 128) || chroma <= 1023) || chroma > 2048) {
#line 641
      printk("\v%s: 0x%06x is not a valid video input!\n", (char *)(& sd->name), (unsigned int )vid_input);
#line 643
      return (-22);
    } else {

    }
#line 645
    afe_mux_cfg = (unsigned int )((u8 )((luma___0 + -16) >> 4)) + 240U;
#line 646
    ch[0] = 2;
#line 647
    if (chroma > 1791) {
#line 648
      afe_mux_cfg = (unsigned int )afe_mux_cfg & 63U;
#line 649
      afe_mux_cfg = (u8 )((int )((signed char )((chroma + -1792) >> 2)) | (int )((signed char )afe_mux_cfg));
#line 650
      ch[2] = 3;
    } else {
#line 652
      afe_mux_cfg = (unsigned int )afe_mux_cfg & 207U;
#line 653
      afe_mux_cfg = (u8 )((int )((signed char )((chroma + -1024) >> 4)) | (int )((signed char )afe_mux_cfg));
#line 654
      ch[1] = 3;
    }
#line 656
    input_mode = 2U;
  }
#line 659
  switch ((unsigned int )aud_input) {
  case 0U: ;
  case 1U: ;
#line 663
  goto ldv_53568;
  case 4U: 
#line 665
  afe_mux_cfg = (unsigned int )afe_mux_cfg & 207U;
#line 666
  ch[1] = 4;
#line 667
  goto ldv_53568;
  case 5U: 
#line 669
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & -49) | 16);
#line 670
  ch[1] = 4;
#line 671
  goto ldv_53568;
  case 6U: 
#line 673
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & -49) | 32);
#line 674
  ch[1] = 4;
#line 675
  goto ldv_53568;
  case 7U: 
#line 677
  afe_mux_cfg = (unsigned int )afe_mux_cfg & 63U;
#line 678
  ch[2] = 4;
#line 679
  goto ldv_53568;
  case 8U: 
#line 681
  afe_mux_cfg = (u8 )(((int )((signed char )afe_mux_cfg) & 63) | 64);
#line 682
  ch[2] = 4;
#line 683
  goto ldv_53568;
  default: 
#line 686
  printk("\v%s: 0x%04x is not a valid audio input!\n", (char *)(& sd->name), (unsigned int )aud_input);
#line 688
  return (-22);
  }
  ldv_53568: 
#line 692
  cx18_av_write_expect(cx, 259, (int )afe_mux_cfg, (int )afe_mux_cfg, 247);
#line 694
  cx18_av_and_or(cx, 1025, 4294967289U, (int )input_mode);
#line 697
  adc2_cfg = cx18_av_read(cx, 258);
#line 698
  if ((unsigned int )ch[2] == 0U) {
#line 699
    adc2_cfg = (unsigned int )adc2_cfg & 253U;
  } else {
#line 701
    adc2_cfg = (u8 )((unsigned int )adc2_cfg | 2U);
  }
#line 704
  if ((unsigned int )ch[1] != 0U && (unsigned int )ch[2] != 0U) {
#line 705
    adc2_cfg = (u8 )((unsigned int )adc2_cfg | 4U);
  } else {
#line 707
    adc2_cfg = (unsigned int )adc2_cfg & 251U;
  }
#line 708
  cx18_av_write_expect(cx, 258, (int )adc2_cfg, (int )adc2_cfg, 23);
#line 711
  afe_cfg = cx18_av_read4(cx, 260);
#line 712
  afe_cfg = afe_cfg & 4278190080U;
#line 713
  afe_cfg = afe_cfg | 20480U;
#line 714
  if ((unsigned int )ch[1] != 0U && (unsigned int )ch[2] != 0U) {
#line 715
    afe_cfg = afe_cfg | 48U;
  } else {

  }
#line 717
  i = 0;
#line 717
  goto ldv_53585;
  ldv_53584: ;
#line 718
  switch ((unsigned int )ch[i]) {
  default: ;
  case 0U: 
#line 722
  afe_cfg = (u32 )(512 << i) | afe_cfg;
#line 723
  goto ldv_53577;
  case 1U: ;
  case 2U: ;
#line 726
  if (i > 0) {
#line 727
    afe_cfg = afe_cfg | 8192U;
  } else {

  }
#line 728
  goto ldv_53577;
  case 3U: ;
  case 5U: ;
  case 6U: 
#line 733
  afe_cfg = (u32 )(512 << i) | afe_cfg;
#line 734
  if (i == 0 && (unsigned int )ch[i] == 3U) {
#line 735
    afe_cfg = afe_cfg & 4294963199U;
  } else {

  }
#line 736
  goto ldv_53577;
  case 4U: 
#line 742
  afe_cfg = (u32 )(576 << i) | afe_cfg;
#line 743
  if (i == 0) {
#line 744
    afe_cfg = afe_cfg & 4294950911U;
  } else {

  }
#line 745
  goto ldv_53577;
  }
  ldv_53577: 
#line 717
  i = i + 1;
  ldv_53585: ;
#line 717
  if (i <= 2) {
#line 719
    goto ldv_53584;
  } else {

  }
#line 749
  cx18_av_write4(cx, 260, afe_cfg);
#line 751
  state->vid_input = vid_input;
#line 752
  state->aud_input = aud_input;
#line 753
  cx18_av_audio_set_path(cx);
#line 754
  input_change(cx);
#line 755
  return (0);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_video_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 761
  tmp = to_cx18_av_state(sd);
#line 761
  state = tmp;
#line 762
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 762
  cx = (struct cx18 *)tmp___0;
#line 763
  tmp___1 = set_input(cx, (enum cx18_av_video_input )input, state->aud_input);
#line 763
  return (tmp___1);
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_audio_routing(struct v4l2_subdev *sd , u32 input , u32 output ,
                                   u32 config ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 769
  tmp = to_cx18_av_state(sd);
#line 769
  state = tmp;
#line 770
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 770
  cx = (struct cx18 *)tmp___0;
#line 771
  tmp___1 = set_input(cx, state->vid_input, (enum cx18_av_audio_input )input);
#line 771
  return (tmp___1);
}
}
#line 774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_g_tuner(struct v4l2_subdev *sd , struct v4l2_tuner *vt ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 vpres ;
  u8 mode ;
  int val ;
  u8 tmp___1 ;

  {
#line 776
  tmp = to_cx18_av_state(sd);
#line 776
  state = tmp;
#line 777
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 777
  cx = (struct cx18 *)tmp___0;
#line 780
  val = 0;
#line 782
  if (state->radio != 0) {
#line 783
    return (0);
  } else {

  }
#line 785
  tmp___1 = cx18_av_read(cx, 1038);
#line 785
  vpres = (unsigned int )tmp___1 & 32U;
#line 786
  vt->signal = (unsigned int )vpres != 0U ? 65535 : 0;
#line 788
  vt->capability = vt->capability | 112U;
#line 792
  mode = cx18_av_read(cx, 2052);
#line 795
  if (((int )mode & 15) == 1) {
#line 796
    val = val | 2;
  } else {
#line 798
    val = val | 1;
  }
#line 800
  if ((unsigned int )mode == 2U || (unsigned int )mode == 4U) {
#line 801
    val = 12;
  } else {

  }
#line 803
  if (((int )mode & 16) != 0) {
#line 804
    val = val | 4;
  } else {

  }
#line 806
  vt->rxsubchans = (__u32 )val;
#line 807
  vt->audmode = (__u32 )state->audmode;
#line 808
  return (0);
}
}
#line 811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_tuner(struct v4l2_subdev *sd , struct v4l2_tuner  const  *vt ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 v ;

  {
#line 813
  tmp = to_cx18_av_state(sd);
#line 813
  state = tmp;
#line 814
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 814
  cx = (struct cx18 *)tmp___0;
#line 817
  if (state->radio != 0) {
#line 818
    return (0);
  } else {

  }
#line 820
  v = cx18_av_read(cx, 2057);
#line 821
  v = (unsigned int )v & 240U;
#line 823
  switch (vt->audmode) {
  case 0U: ;
#line 828
  goto ldv_53620;
  case 1U: ;
  case 3U: 
#line 834
  v = (u8 )((unsigned int )v | 4U);
#line 835
  goto ldv_53620;
  case 4U: 
#line 840
  v = (u8 )((unsigned int )v | 7U);
#line 841
  goto ldv_53620;
  case 2U: 
#line 846
  v = (u8 )((unsigned int )v | 1U);
#line 847
  goto ldv_53620;
  default: ;
#line 849
  return (-22);
  }
  ldv_53620: 
#line 851
  cx18_av_write_expect(cx, 2057, (int )v, (int )v, 255);
#line 852
  state->audmode = (int )vt->audmode;
#line 853
  return (0);
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_std(struct v4l2_subdev *sd , v4l2_std_id norm ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  u8 fmt ;
  u8 pal_m ;

  {
#line 858
  tmp = to_cx18_av_state(sd);
#line 858
  state = tmp;
#line 859
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 859
  cx = (struct cx18 *)tmp___0;
#line 861
  fmt = 0U;
#line 862
  pal_m = 0U;
#line 864
  if (state->radio == 0 && state->std == norm) {
#line 865
    return (0);
  } else {

  }
#line 867
  state->radio = 0;
#line 868
  state->std = norm;
#line 871
  if (state->std == 8192ULL) {
#line 872
    fmt = 2U;
  } else
#line 873
  if (state->std == 16384ULL) {
#line 874
    fmt = 3U;
  } else
#line 875
  if (state->std == 256ULL) {
#line 876
    pal_m = 1U;
#line 877
    fmt = 5U;
  } else
#line 878
  if (state->std == 512ULL) {
#line 879
    fmt = 6U;
  } else
#line 880
  if (state->std == 1024ULL) {
#line 881
    fmt = 7U;
  } else
#line 882
  if (state->std == 2048ULL) {
#line 883
    fmt = 8U;
  } else
#line 886
  if ((state->std & 45056ULL) != 0ULL) {
#line 887
    fmt = 1U;
  } else
#line 888
  if ((state->std & 255ULL) != 0ULL) {
#line 889
    fmt = 4U;
  } else
#line 890
  if ((state->std & 16711680ULL) != 0ULL) {
#line 891
    fmt = 12U;
  } else {

  }
#line 894
  if ((cx18_debug & 2) != 0) {
#line 894
    printk("\016%s:  info: changing video std to fmt %i\n", (char *)(& sd->name),
           (int )fmt);
  } else {

  }
#line 899
  if ((unsigned int )fmt > 3U && (unsigned int )fmt <= 7U) {
#line 901
    cx18_av_and_or(cx, 1024, 4294967280U, 1);
#line 903
    cx18_av_and_or(cx, 1147, 4294967289U, 0);
  } else {

  }
#line 905
  cx18_av_and_or(cx, 1024, 4294967248U, (int )((unsigned int )fmt | 32U));
#line 906
  cx18_av_and_or(cx, 1027, 4294967292U, (int )pal_m);
#line 907
  cx18_av_std_setup(cx);
#line 908
  input_change(cx);
#line 909
  return (0);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_radio(struct v4l2_subdev *sd ) 
{ 
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;

  {
#line 914
  tmp = to_cx18_av_state(sd);
#line 914
  state = tmp;
#line 915
  state->radio = 1;
#line 916
  return (0);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;

  {
#line 921
  tmp = to_sd(ctrl);
#line 921
  sd = tmp;
#line 922
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 922
  cx = (struct cx18 *)tmp___0;
#line 924
  switch (ctrl->id) {
  case 9963776U: 
#line 926
  cx18_av_write(cx, 1044, (int )((unsigned int )((u8 )ctrl->val) + 128U));
#line 927
  goto ldv_53644;
  case 9963777U: 
#line 930
  cx18_av_write(cx, 1045, (int )((u8 )ctrl->val) << 1U);
#line 931
  goto ldv_53644;
  case 9963778U: 
#line 934
  cx18_av_write(cx, 1056, (int )((u8 )ctrl->val) << 1U);
#line 935
  cx18_av_write(cx, 1057, (int )((u8 )ctrl->val) << 1U);
#line 936
  goto ldv_53644;
  case 9963779U: 
#line 939
  cx18_av_write(cx, 1058, (int )((u8 )ctrl->val));
#line 940
  goto ldv_53644;
  default: ;
#line 943
  return (-22);
  }
  ldv_53644: ;
#line 945
  return (0);
}
}
#line 948 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_set_fmt(struct v4l2_subdev *sd , struct v4l2_subdev_pad_config *cfg ,
                           struct v4l2_subdev_format *format ) 
{ 
  struct v4l2_mbus_framefmt *fmt ;
  struct cx18_av_state *state ;
  struct cx18_av_state *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;
  int HSC ;
  int VSC ;
  int Vsrc ;
  int Hsrc ;
  int filter ;
  int Vlines ;
  int is_50Hz ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;

  {
#line 952
  fmt = & format->format;
#line 953
  tmp = to_cx18_av_state(sd);
#line 953
  state = tmp;
#line 954
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 954
  cx = (struct cx18 *)tmp___0;
#line 956
  is_50Hz = (state->std & 63744ULL) == 0ULL;
#line 958
  if (format->pad != 0U || fmt->code != 1U) {
#line 959
    return (-22);
  } else {

  }
#line 961
  fmt->field = 4U;
#line 962
  fmt->colorspace = 1U;
#line 964
  tmp___1 = cx18_av_read(cx, 1142);
#line 964
  Vsrc = ((int )tmp___1 & 63) << 4;
#line 965
  tmp___2 = cx18_av_read(cx, 1141);
#line 965
  Vsrc = ((int )tmp___2 >> 4) | Vsrc;
#line 967
  tmp___3 = cx18_av_read(cx, 1138);
#line 967
  Hsrc = ((int )tmp___3 & 63) << 4;
#line 968
  tmp___4 = cx18_av_read(cx, 1137);
#line 968
  Hsrc = ((int )tmp___4 >> 4) | Hsrc;
#line 977
  Vlines = (int )(fmt->height + (is_50Hz != 0 ? 3U : 1U));
#line 986
  if (((fmt->width * 16U < (__u32 )Hsrc || (__u32 )Hsrc < fmt->width) || Vlines * 8 < Vsrc) || Vsrc < Vlines) {
#line 988
    printk("\v%s: %dx%d is not a valid size!\n", (char *)(& sd->name), fmt->width,
           fmt->height);
#line 990
    return (-34);
  } else {

  }
#line 993
  if (format->which == 0U) {
#line 994
    return (0);
  } else {

  }
#line 996
  HSC = (int )((__u32 )(Hsrc * 1048576) / fmt->width - 1048576U);
#line 997
  VSC = 66048 - (Vsrc * 512) / Vlines;
#line 998
  VSC = VSC & 8191;
#line 1000
  if (fmt->width > 384U) {
#line 1001
    filter = 0;
  } else
#line 1002
  if (fmt->width > 192U) {
#line 1003
    filter = 1;
  } else
#line 1004
  if (fmt->width > 96U) {
#line 1005
    filter = 2;
  } else {
#line 1007
    filter = 3;
  }
#line 1009
  if ((cx18_debug & 2) != 0) {
#line 1009
    printk("\016%s:  info: decoder set size %dx%d -> scale  %ux%u\n", (char *)(& sd->name),
           fmt->width, fmt->height, HSC, VSC);
  } else {

  }
#line 1014
  cx18_av_write(cx, 1048, (int )((u8 )HSC));
#line 1015
  cx18_av_write(cx, 1049, (int )((u8 )(HSC >> 8)));
#line 1016
  cx18_av_write(cx, 1050, (int )((u8 )(HSC >> 16)));
#line 1018
  cx18_av_write(cx, 1052, (int )((u8 )VSC));
#line 1019
  cx18_av_write(cx, 1053, (int )((u8 )(VSC >> 8)));
#line 1021
  cx18_av_write(cx, 1054, (int )((u8 )((int )((signed char )filter) | 8)));
#line 1022
  return (0);
}
}
#line 1025 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_stream(struct v4l2_subdev *sd , int enable ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1027
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1027
  cx = (struct cx18 *)tmp;
#line 1029
  if ((cx18_debug & 2) != 0) {
#line 1029
    printk("\016%s:  info: %s output\n", (char *)(& sd->name), enable != 0 ? (char *)"enable" : (char *)"disable");
  } else {

  }
#line 1030
  if (enable != 0) {
#line 1031
    cx18_av_write(cx, 277, 140);
#line 1032
    cx18_av_write(cx, 278, 7);
  } else {
#line 1034
    cx18_av_write(cx, 277, 0);
#line 1035
    cx18_av_write(cx, 278, 0);
  }
#line 1037
  return (0);
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static void log_video_status(struct cx18 *cx ) 
{ 
  char const   *fmt_strs[16U] ;
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  u8 vidfmt_sel ;
  u8 tmp ;
  u8 gen_stat1 ;
  u8 tmp___0 ;
  u8 gen_stat2 ;
  u8 tmp___1 ;
  int vid_input ;

  {
#line 1042
  fmt_strs[0] = "0x0";
#line 1042
  fmt_strs[1] = "NTSC-M";
#line 1042
  fmt_strs[2] = "NTSC-J";
#line 1042
  fmt_strs[3] = "NTSC-4.43";
#line 1042
  fmt_strs[4] = "PAL-BDGHI";
#line 1042
  fmt_strs[5] = "PAL-M";
#line 1042
  fmt_strs[6] = "PAL-N";
#line 1042
  fmt_strs[7] = "PAL-Nc";
#line 1042
  fmt_strs[8] = "PAL-60";
#line 1042
  fmt_strs[9] = "0x9";
#line 1042
  fmt_strs[10] = "0xA";
#line 1042
  fmt_strs[11] = "0xB";
#line 1042
  fmt_strs[12] = "SECAM";
#line 1042
  fmt_strs[13] = "0xD";
#line 1042
  fmt_strs[14] = "0xE";
#line 1042
  fmt_strs[15] = "0xF";
#line 1051
  state = & cx->av_state;
#line 1052
  sd = & state->sd;
#line 1053
  tmp = cx18_av_read(cx, 1024);
#line 1053
  vidfmt_sel = (unsigned int )tmp & 15U;
#line 1054
  tmp___0 = cx18_av_read(cx, 1037);
#line 1054
  gen_stat1 = tmp___0;
#line 1055
  tmp___1 = cx18_av_read(cx, 1038);
#line 1055
  gen_stat2 = tmp___1;
#line 1056
  vid_input = (int )state->vid_input;
#line 1058
  printk("\016%s: Video signal:              %spresent\n", (char *)(& sd->name), ((int )gen_stat2 & 32) != 0 ? (char *)"" : (char *)"not ");
#line 1060
  printk("\016%s: Detected format:           %s\n", (char *)(& sd->name), fmt_strs[(int )gen_stat1 & 15]);
#line 1063
  printk("\016%s: Specified standard:        %s\n", (char *)(& sd->name), (unsigned int )vidfmt_sel != 0U ? fmt_strs[(int )vidfmt_sel] : (char const   */* const  */)"automatic detection");
#line 1067
  if (vid_input > 0 && vid_input <= 8) {
#line 1069
    printk("\016%s: Specified video input:     Composite %d\n", (char *)(& sd->name),
           vid_input);
  } else {
#line 1072
    printk("\016%s: Specified video input:     S-Video (Luma In%d, Chroma In%d)\n",
           (char *)(& sd->name), (vid_input & 240) >> 4, (vid_input & 3840) >> 8);
  }
#line 1078
  printk("\016%s: Specified audioclock freq: %d Hz\n", (char *)(& sd->name), state->audclk_freq);
#line 1079
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static void log_audio_status(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  u8 download_ctl ;
  u8 tmp ;
  u8 mod_det_stat0 ;
  u8 tmp___0 ;
  u8 mod_det_stat1 ;
  u8 tmp___1 ;
  u8 audio_config ;
  u8 tmp___2 ;
  u8 pref_mode ;
  u8 tmp___3 ;
  u8 afc0 ;
  u8 tmp___4 ;
  u8 mute_ctl ;
  u8 tmp___5 ;
  int aud_input ;
  char *p ;

  {
#line 1084
  state = & cx->av_state;
#line 1085
  sd = & state->sd;
#line 1086
  tmp = cx18_av_read(cx, 2051);
#line 1086
  download_ctl = tmp;
#line 1087
  tmp___0 = cx18_av_read(cx, 2052);
#line 1087
  mod_det_stat0 = tmp___0;
#line 1088
  tmp___1 = cx18_av_read(cx, 2053);
#line 1088
  mod_det_stat1 = tmp___1;
#line 1089
  tmp___2 = cx18_av_read(cx, 2056);
#line 1089
  audio_config = tmp___2;
#line 1090
  tmp___3 = cx18_av_read(cx, 2057);
#line 1090
  pref_mode = tmp___3;
#line 1091
  tmp___4 = cx18_av_read(cx, 2059);
#line 1091
  afc0 = tmp___4;
#line 1092
  tmp___5 = cx18_av_read(cx, 2259);
#line 1092
  mute_ctl = tmp___5;
#line 1093
  aud_input = (int )state->aud_input;
#line 1096
  switch ((int )mod_det_stat0) {
  case 0: 
#line 1097
  p = (char *)"mono";
#line 1097
  goto ldv_53694;
  case 1: 
#line 1098
  p = (char *)"stereo";
#line 1098
  goto ldv_53694;
  case 2: 
#line 1099
  p = (char *)"dual";
#line 1099
  goto ldv_53694;
  case 4: 
#line 1100
  p = (char *)"tri";
#line 1100
  goto ldv_53694;
  case 16: 
#line 1101
  p = (char *)"mono with SAP";
#line 1101
  goto ldv_53694;
  case 17: 
#line 1102
  p = (char *)"stereo with SAP";
#line 1102
  goto ldv_53694;
  case 18: 
#line 1103
  p = (char *)"dual with SAP";
#line 1103
  goto ldv_53694;
  case 20: 
#line 1104
  p = (char *)"tri with SAP";
#line 1104
  goto ldv_53694;
  case 254: 
#line 1105
  p = (char *)"forced mode";
#line 1105
  goto ldv_53694;
  default: 
#line 1106
  p = (char *)"not defined";
#line 1106
  goto ldv_53694;
  }
  ldv_53694: 
#line 1108
  printk("\016%s: Detected audio mode:       %s\n", (char *)(& sd->name), p);
#line 1110
  switch ((int )mod_det_stat1) {
  case 0: 
#line 1111
  p = (char *)"not defined";
#line 1111
  goto ldv_53705;
  case 1: 
#line 1112
  p = (char *)"EIAJ";
#line 1112
  goto ldv_53705;
  case 2: 
#line 1113
  p = (char *)"A2-M";
#line 1113
  goto ldv_53705;
  case 3: 
#line 1114
  p = (char *)"A2-BG";
#line 1114
  goto ldv_53705;
  case 4: 
#line 1115
  p = (char *)"A2-DK1";
#line 1115
  goto ldv_53705;
  case 5: 
#line 1116
  p = (char *)"A2-DK2";
#line 1116
  goto ldv_53705;
  case 6: 
#line 1117
  p = (char *)"A2-DK3";
#line 1117
  goto ldv_53705;
  case 7: 
#line 1118
  p = (char *)"A1 (6.0 MHz FM Mono)";
#line 1118
  goto ldv_53705;
  case 8: 
#line 1119
  p = (char *)"AM-L";
#line 1119
  goto ldv_53705;
  case 9: 
#line 1120
  p = (char *)"NICAM-BG";
#line 1120
  goto ldv_53705;
  case 10: 
#line 1121
  p = (char *)"NICAM-DK";
#line 1121
  goto ldv_53705;
  case 11: 
#line 1122
  p = (char *)"NICAM-I";
#line 1122
  goto ldv_53705;
  case 12: 
#line 1123
  p = (char *)"NICAM-L";
#line 1123
  goto ldv_53705;
  case 13: 
#line 1124
  p = (char *)"BTSC/EIAJ/A2-M Mono (4.5 MHz FMMono)";
#line 1124
  goto ldv_53705;
  case 14: 
#line 1125
  p = (char *)"IF FM Radio";
#line 1125
  goto ldv_53705;
  case 15: 
#line 1126
  p = (char *)"BTSC";
#line 1126
  goto ldv_53705;
  case 16: 
#line 1127
  p = (char *)"detected chrominance";
#line 1127
  goto ldv_53705;
  case 253: 
#line 1128
  p = (char *)"unknown audio standard";
#line 1128
  goto ldv_53705;
  case 254: 
#line 1129
  p = (char *)"forced audio standard";
#line 1129
  goto ldv_53705;
  case 255: 
#line 1130
  p = (char *)"no detected audio standard";
#line 1130
  goto ldv_53705;
  default: 
#line 1131
  p = (char *)"not defined";
#line 1131
  goto ldv_53705;
  }
  ldv_53705: 
#line 1133
  printk("\016%s: Detected audio standard:   %s\n", (char *)(& sd->name), p);
#line 1134
  printk("\016%s: Audio muted:               %s\n", (char *)(& sd->name), ((int )mute_ctl & 2) != 0 ? (char *)"yes" : (char *)"no");
#line 1136
  printk("\016%s: Audio microcontroller:     %s\n", (char *)(& sd->name), ((int )download_ctl & 16) != 0 ? (char *)"running" : (char *)"stopped");
#line 1139
  switch ((int )audio_config >> 4) {
  case 0: 
#line 1140
  p = (char *)"undefined";
#line 1140
  goto ldv_53727;
  case 1: 
#line 1141
  p = (char *)"BTSC";
#line 1141
  goto ldv_53727;
  case 2: 
#line 1142
  p = (char *)"EIAJ";
#line 1142
  goto ldv_53727;
  case 3: 
#line 1143
  p = (char *)"A2-M";
#line 1143
  goto ldv_53727;
  case 4: 
#line 1144
  p = (char *)"A2-BG";
#line 1144
  goto ldv_53727;
  case 5: 
#line 1145
  p = (char *)"A2-DK1";
#line 1145
  goto ldv_53727;
  case 6: 
#line 1146
  p = (char *)"A2-DK2";
#line 1146
  goto ldv_53727;
  case 7: 
#line 1147
  p = (char *)"A2-DK3";
#line 1147
  goto ldv_53727;
  case 8: 
#line 1148
  p = (char *)"A1 (6.0 MHz FM Mono)";
#line 1148
  goto ldv_53727;
  case 9: 
#line 1149
  p = (char *)"AM-L";
#line 1149
  goto ldv_53727;
  case 10: 
#line 1150
  p = (char *)"NICAM-BG";
#line 1150
  goto ldv_53727;
  case 11: 
#line 1151
  p = (char *)"NICAM-DK";
#line 1151
  goto ldv_53727;
  case 12: 
#line 1152
  p = (char *)"NICAM-I";
#line 1152
  goto ldv_53727;
  case 13: 
#line 1153
  p = (char *)"NICAM-L";
#line 1153
  goto ldv_53727;
  case 14: 
#line 1154
  p = (char *)"FM radio";
#line 1154
  goto ldv_53727;
  case 15: 
#line 1155
  p = (char *)"automatic detection";
#line 1155
  goto ldv_53727;
  default: 
#line 1156
  p = (char *)"undefined";
#line 1156
  goto ldv_53727;
  }
  ldv_53727: 
#line 1158
  printk("\016%s: Configured audio standard: %s\n", (char *)(& sd->name), p);
#line 1160
  if ((unsigned int )((int )audio_config >> 4) <= 14U) {
#line 1161
    switch ((int )audio_config & 15) {
    case 0: 
#line 1162
    p = (char *)"MONO1 (LANGUAGE A/Mono L+R channel for BTSC, EIAJ, A2)";
#line 1162
    goto ldv_53745;
    case 1: 
#line 1163
    p = (char *)"MONO2 (LANGUAGE B)";
#line 1163
    goto ldv_53745;
    case 2: 
#line 1164
    p = (char *)"MONO3 (STEREO forced MONO)";
#line 1164
    goto ldv_53745;
    case 3: 
#line 1165
    p = (char *)"MONO4 (NICAM ANALOG-Language C/Analog Fallback)";
#line 1165
    goto ldv_53745;
    case 4: 
#line 1166
    p = (char *)"STEREO";
#line 1166
    goto ldv_53745;
    case 5: 
#line 1167
    p = (char *)"DUAL1 (AC)";
#line 1167
    goto ldv_53745;
    case 6: 
#line 1168
    p = (char *)"DUAL2 (BC)";
#line 1168
    goto ldv_53745;
    case 7: 
#line 1169
    p = (char *)"DUAL3 (AB)";
#line 1169
    goto ldv_53745;
    default: 
#line 1170
    p = (char *)"undefined";
    }
    ldv_53745: 
#line 1172
    printk("\016%s: Configured audio mode:     %s\n", (char *)(& sd->name), p);
  } else {
#line 1174
    switch ((int )audio_config & 15) {
    case 0: 
#line 1175
    p = (char *)"BG";
#line 1175
    goto ldv_53755;
    case 1: 
#line 1176
    p = (char *)"DK1";
#line 1176
    goto ldv_53755;
    case 2: 
#line 1177
    p = (char *)"DK2";
#line 1177
    goto ldv_53755;
    case 3: 
#line 1178
    p = (char *)"DK3";
#line 1178
    goto ldv_53755;
    case 4: 
#line 1179
    p = (char *)"I";
#line 1179
    goto ldv_53755;
    case 5: 
#line 1180
    p = (char *)"L";
#line 1180
    goto ldv_53755;
    case 6: 
#line 1181
    p = (char *)"BTSC";
#line 1181
    goto ldv_53755;
    case 7: 
#line 1182
    p = (char *)"EIAJ";
#line 1182
    goto ldv_53755;
    case 8: 
#line 1183
    p = (char *)"A2-M";
#line 1183
    goto ldv_53755;
    case 9: 
#line 1184
    p = (char *)"FM Radio (4.5 MHz)";
#line 1184
    goto ldv_53755;
    case 10: 
#line 1185
    p = (char *)"FM Radio (5.5 MHz)";
#line 1185
    goto ldv_53755;
    case 11: 
#line 1186
    p = (char *)"S-Video";
#line 1186
    goto ldv_53755;
    case 15: 
#line 1187
    p = (char *)"automatic standard and mode detection";
#line 1187
    goto ldv_53755;
    default: 
#line 1188
    p = (char *)"undefined";
#line 1188
    goto ldv_53755;
    }
    ldv_53755: 
#line 1190
    printk("\016%s: Configured audio system:   %s\n", (char *)(& sd->name), p);
  }
#line 1193
  if (aud_input != 0) {
#line 1194
    printk("\016%s: Specified audio input:     Tuner (In%d)\n", (char *)(& sd->name),
           aud_input);
  } else {
#line 1197
    printk("\016%s: Specified audio input:     External\n", (char *)(& sd->name));
  }
#line 1199
  switch ((int )pref_mode & 15) {
  case 0: 
#line 1200
  p = (char *)"mono/language A";
#line 1200
  goto ldv_53770;
  case 1: 
#line 1201
  p = (char *)"language B";
#line 1201
  goto ldv_53770;
  case 2: 
#line 1202
  p = (char *)"language C";
#line 1202
  goto ldv_53770;
  case 3: 
#line 1203
  p = (char *)"analog fallback";
#line 1203
  goto ldv_53770;
  case 4: 
#line 1204
  p = (char *)"stereo";
#line 1204
  goto ldv_53770;
  case 5: 
#line 1205
  p = (char *)"language AC";
#line 1205
  goto ldv_53770;
  case 6: 
#line 1206
  p = (char *)"language BC";
#line 1206
  goto ldv_53770;
  case 7: 
#line 1207
  p = (char *)"language AB";
#line 1207
  goto ldv_53770;
  default: 
#line 1208
  p = (char *)"undefined";
#line 1208
  goto ldv_53770;
  }
  ldv_53770: 
#line 1210
  printk("\016%s: Preferred audio mode:      %s\n", (char *)(& sd->name), p);
#line 1212
  if (((int )audio_config & 15) == 15) {
#line 1213
    switch (((int )afc0 >> 3) & 1) {
    case 0: 
#line 1214
    p = (char *)"system DK";
#line 1214
    goto ldv_53780;
    case 1: 
#line 1215
    p = (char *)"system L";
#line 1215
    goto ldv_53780;
    }
    ldv_53780: 
#line 1217
    printk("\016%s: Selected 65 MHz format:    %s\n", (char *)(& sd->name), p);
#line 1219
    switch ((int )afc0 & 7) {
    case 0: 
#line 1220
    p = (char *)"Chroma";
#line 1220
    goto ldv_53783;
    case 1: 
#line 1221
    p = (char *)"BTSC";
#line 1221
    goto ldv_53783;
    case 2: 
#line 1222
    p = (char *)"EIAJ";
#line 1222
    goto ldv_53783;
    case 3: 
#line 1223
    p = (char *)"A2-M";
#line 1223
    goto ldv_53783;
    case 4: 
#line 1224
    p = (char *)"autodetect";
#line 1224
    goto ldv_53783;
    default: 
#line 1225
    p = (char *)"undefined";
#line 1225
    goto ldv_53783;
    }
    ldv_53783: 
#line 1227
    printk("\016%s: Selected 45 MHz format:    %s\n", (char *)(& sd->name), p);
  } else {

  }
#line 1229
  return;
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_log_status(struct v4l2_subdev *sd ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1233
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1233
  cx = (struct cx18 *)tmp;
#line 1234
  log_video_status(cx);
#line 1235
  log_audio_status(cx);
#line 1236
  return (0);
}
}
#line 1240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_g_register(struct v4l2_subdev *sd , struct v4l2_dbg_register *reg ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  u32 tmp___0 ;

  {
#line 1243
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1243
  cx = (struct cx18 *)tmp;
#line 1245
  if ((reg->reg & 3ULL) != 0ULL) {
#line 1246
    return (-22);
  } else {

  }
#line 1247
  reg->size = 4U;
#line 1248
  tmp___0 = cx18_av_read4(cx, (int )((u16 )reg->reg) & 4092);
#line 1248
  reg->val = (__u64 )tmp___0;
#line 1249
  return (0);
}
}
#line 1252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static int cx18_av_s_register(struct v4l2_subdev *sd , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct cx18 *cx ;
  void *tmp ;

  {
#line 1255
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 1255
  cx = (struct cx18 *)tmp;
#line 1257
  if (((unsigned long long )reg->reg & 3ULL) != 0ULL) {
#line 1258
    return (-22);
  } else {

  }
#line 1259
  cx18_av_write4(cx, (int )((u16 )reg->reg) & 4092, (u32 )reg->val);
#line 1260
  return (0);
}
}
#line 1264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_ctrl_ops  const  cx18_av_ctrl_ops  =    {0, 0, & cx18_av_s_ctrl};
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_core_ops  const  cx18_av_general_ops  = 
#line 1268
     {& cx18_av_log_status, 0, 0, & cx18_av_load_fw, & cx18_av_reset, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & cx18_av_g_register, & cx18_av_s_register, 0, 0, 0, 0};
#line 1278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_tuner_ops  const  cx18_av_tuner_ops  = 
#line 1278
     {& cx18_av_s_radio, & cx18_av_s_frequency, 0, 0, & cx18_av_g_tuner, & cx18_av_s_tuner,
    0, 0, 0, 0};
#line 1285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_audio_ops  const  cx18_av_audio_ops  =    {& cx18_av_s_clock_freq, 0, & cx18_av_s_audio_routing, 0};
#line 1290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_video_ops  const  cx18_av_video_ops  = 
#line 1290
     {& cx18_av_s_video_routing, 0, 0, & cx18_av_s_std, 0, 0, 0, 0, 0, 0, & cx18_av_s_stream,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_vbi_ops  const  cx18_av_vbi_ops  =    {& cx18_av_decode_vbi_line, 0, 0, 0, & cx18_av_s_raw_fmt, & cx18_av_g_sliced_fmt,
    & cx18_av_s_sliced_fmt};
#line 1303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_pad_ops  const  cx18_av_pad_ops  = 
#line 1303
     {0, 0, 0, 0, & cx18_av_set_fmt, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
static struct v4l2_subdev_ops  const  cx18_av_ops  = 
#line 1307
     {& cx18_av_general_ops, & cx18_av_tuner_ops, & cx18_av_audio_ops, & cx18_av_video_ops,
    & cx18_av_vbi_ops, 0, 0, & cx18_av_pad_ops};
#line 1316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.c"
int cx18_av_probe(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  struct v4l2_subdev *sd ;
  int err ;
  u32 tmp ;
  struct lock_class_key _key ;
  int err___0 ;

  {
#line 1318
  state = & cx->av_state;
#line 1322
  tmp = cx18_av_read4(cx, 256);
#line 1322
  state->rev = tmp & 65535U;
#line 1324
  state->vid_input = 7;
#line 1325
  state->aud_input = 8;
#line 1326
  state->audclk_freq = 48000U;
#line 1327
  state->audmode = 3;
#line 1328
  state->slicer_line_delay = 0;
#line 1329
  state->slicer_line_offset = state->slicer_line_delay + 8;
#line 1331
  sd = & state->sd;
#line 1332
  v4l2_subdev_init(sd, & cx18_av_ops);
#line 1333
  v4l2_set_subdevdata(sd, (void *)cx);
#line 1334
  snprintf((char *)(& sd->name), 32UL, "%s %03x", (char *)(& cx->v4l2_dev.name), state->rev >> 4);
#line 1336
  sd->grp_id = 16U;
#line 1337
  v4l2_ctrl_handler_init_class(& state->hdl, 9U, & _key, "cx18_av_core:1337:(&state->hdl)->_lock");
#line 1338
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963776U, 0LL, 255LL, 1ULL,
                    128LL);
#line 1340
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963777U, 0LL, 127LL, 1ULL,
                    64LL);
#line 1342
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963778U, 0LL, 127LL, 1ULL,
                    64LL);
#line 1344
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_ctrl_ops, 9963779U, -128LL, 127LL, 1ULL,
                    0LL);
#line 1347
  state->volume = v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963781U,
                                    0LL, 65535LL, 655ULL, 0LL);
#line 1350
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963785U, 0LL, 1LL, 1ULL,
                    0LL);
#line 1353
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963782U, 0LL, 65535LL,
                    655ULL, 32768LL);
#line 1356
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963783U, 0LL, 65535LL,
                    655ULL, 32768LL);
#line 1359
  v4l2_ctrl_new_std(& state->hdl, & cx18_av_audio_ctrl_ops, 9963784U, 0LL, 65535LL,
                    655ULL, 32768LL);
#line 1362
  sd->ctrl_handler = & state->hdl;
#line 1363
  if (state->hdl.error != 0) {
#line 1364
    err___0 = state->hdl.error;
#line 1366
    v4l2_ctrl_handler_free(& state->hdl);
#line 1367
    return (err___0);
  } else {

  }
#line 1369
  err = v4l2_device_register_subdev(& cx->v4l2_dev, sd);
#line 1370
  if (err != 0) {
#line 1371
    v4l2_ctrl_handler_free(& state->hdl);
  } else {
#line 1373
    cx18_av_init(cx);
  }
#line 1374
  return (err);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_audio_ops_11(void) 
{ 
  void *tmp ;

  {
#line 271
  tmp = ldv_init_zalloc(304UL);
#line 271
  cx18_av_audio_ops_group0 = (struct v4l2_subdev *)tmp;
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_tuner_ops_12(void) 
{ 
  void *tmp ;

  {
#line 275
  tmp = ldv_init_zalloc(304UL);
#line 275
  cx18_av_tuner_ops_group0 = (struct v4l2_subdev *)tmp;
#line 276
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_vbi_ops_9(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 279
  tmp = ldv_init_zalloc(304UL);
#line 279
  cx18_av_vbi_ops_group0 = (struct v4l2_subdev *)tmp;
#line 280
  tmp___0 = ldv_init_zalloc(112UL);
#line 280
  cx18_av_vbi_ops_group1 = (struct v4l2_sliced_vbi_format *)tmp___0;
#line 281
  return;
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_core_ops_13(void) 
{ 
  void *tmp ;

  {
#line 284
  tmp = ldv_init_zalloc(304UL);
#line 284
  cx18_av_general_ops_group0 = (struct v4l2_subdev *)tmp;
#line 285
  return;
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_initialize_v4l2_subdev_video_ops_10(void) 
{ 
  void *tmp ;

  {
#line 288
  tmp = ldv_init_zalloc(304UL);
#line 288
  cx18_av_video_ops_group0 = (struct v4l2_subdev *)tmp;
#line 289
  return;
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  struct v4l2_subdev_pad_config *ldvarg103 ;
  void *tmp ;
  struct v4l2_subdev *ldvarg101 ;
  void *tmp___0 ;
  struct v4l2_subdev_format *ldvarg102 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 292
  tmp = ldv_init_zalloc(80UL);
#line 292
  ldvarg103 = (struct v4l2_subdev_pad_config *)tmp;
#line 293
  tmp___0 = ldv_init_zalloc(304UL);
#line 293
  ldvarg101 = (struct v4l2_subdev *)tmp___0;
#line 294
  tmp___1 = ldv_init_zalloc(88UL);
#line 294
  ldvarg102 = (struct v4l2_subdev_format *)tmp___1;
#line 296
  tmp___2 = __VERIFIER_nondet_int();
#line 296
  switch (tmp___2) {
  case 0: ;
#line 299
  if (ldv_state_variable_8 == 1) {
#line 301
    cx18_av_set_fmt(ldvarg101, ldvarg103, ldvarg102);
#line 303
    ldv_state_variable_8 = 1;
  } else {

  }
#line 306
  goto ldv_53842;
  default: 
#line 307
  ldv_stop();
  }
  ldv_53842: ;
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  u32 ldvarg2 ;
  u32 ldvarg0 ;
  u32 ldvarg3 ;
  u32 ldvarg1 ;
  int tmp ;

  {
#line 314
  ldv_memset((void *)(& ldvarg2), 0, 4UL);
#line 315
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 316
  ldv_memset((void *)(& ldvarg3), 0, 4UL);
#line 317
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 319
  tmp = __VERIFIER_nondet_int();
#line 319
  switch (tmp) {
  case 0: ;
#line 322
  if (ldv_state_variable_11 == 1) {
#line 324
    cx18_av_s_audio_routing(cx18_av_audio_ops_group0, ldvarg3, ldvarg2, ldvarg1);
#line 326
    ldv_state_variable_11 = 1;
  } else {

  }
#line 329
  goto ldv_53852;
  case 1: ;
#line 332
  if (ldv_state_variable_11 == 1) {
#line 334
    cx18_av_s_clock_freq(cx18_av_audio_ops_group0, ldvarg0);
#line 336
    ldv_state_variable_11 = 1;
  } else {

  }
#line 339
  goto ldv_53852;
  default: 
#line 340
  ldv_stop();
  }
  ldv_53852: ;
#line 344
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  struct v4l2_dbg_register *ldvarg86 ;
  void *tmp ;
  struct v4l2_dbg_register *ldvarg84 ;
  void *tmp___0 ;
  u32 ldvarg85 ;
  int tmp___1 ;

  {
#line 347
  tmp = ldv_init_zalloc(56UL);
#line 347
  ldvarg86 = (struct v4l2_dbg_register *)tmp;
#line 348
  tmp___0 = ldv_init_zalloc(56UL);
#line 348
  ldvarg84 = (struct v4l2_dbg_register *)tmp___0;
#line 349
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
#line 351
  tmp___1 = __VERIFIER_nondet_int();
#line 351
  switch (tmp___1) {
  case 0: ;
#line 354
  if (ldv_state_variable_13 == 1) {
#line 356
    cx18_av_load_fw(cx18_av_general_ops_group0);
#line 358
    ldv_state_variable_13 = 1;
  } else {

  }
#line 361
  goto ldv_53862;
  case 1: ;
#line 364
  if (ldv_state_variable_13 == 1) {
#line 366
    cx18_av_s_register(cx18_av_general_ops_group0, (struct v4l2_dbg_register  const  *)ldvarg86);
#line 368
    ldv_state_variable_13 = 1;
  } else {

  }
#line 371
  goto ldv_53862;
  case 2: ;
#line 374
  if (ldv_state_variable_13 == 1) {
#line 376
    cx18_av_reset(cx18_av_general_ops_group0, ldvarg85);
#line 378
    ldv_state_variable_13 = 1;
  } else {

  }
#line 381
  goto ldv_53862;
  case 3: ;
#line 384
  if (ldv_state_variable_13 == 1) {
#line 386
    cx18_av_g_register(cx18_av_general_ops_group0, ldvarg84);
#line 388
    ldv_state_variable_13 = 1;
  } else {

  }
#line 391
  goto ldv_53862;
  case 4: ;
#line 394
  if (ldv_state_variable_13 == 1) {
#line 396
    cx18_av_log_status(cx18_av_general_ops_group0);
#line 398
    ldv_state_variable_13 = 1;
  } else {

  }
#line 401
  goto ldv_53862;
  default: 
#line 402
  ldv_stop();
  }
  ldv_53862: ;
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  u32 ldvarg115 ;
  u32 ldvarg114 ;
  u32 ldvarg113 ;
  int ldvarg112 ;
  v4l2_std_id ldvarg111 ;
  int tmp ;

  {
#line 409
  ldv_memset((void *)(& ldvarg115), 0, 4UL);
#line 410
  ldv_memset((void *)(& ldvarg114), 0, 4UL);
#line 411
  ldv_memset((void *)(& ldvarg113), 0, 4UL);
#line 412
  ldv_memset((void *)(& ldvarg112), 0, 4UL);
#line 413
  ldv_memset((void *)(& ldvarg111), 0, 8UL);
#line 415
  tmp = __VERIFIER_nondet_int();
#line 415
  switch (tmp) {
  case 0: ;
#line 418
  if (ldv_state_variable_10 == 1) {
#line 420
    cx18_av_s_video_routing(cx18_av_video_ops_group0, ldvarg115, ldvarg114, ldvarg113);
#line 422
    ldv_state_variable_10 = 1;
  } else {

  }
#line 425
  goto ldv_53877;
  case 1: ;
#line 428
  if (ldv_state_variable_10 == 1) {
#line 430
    cx18_av_s_stream(cx18_av_video_ops_group0, ldvarg112);
#line 432
    ldv_state_variable_10 = 1;
  } else {

  }
#line 435
  goto ldv_53877;
  case 2: ;
#line 438
  if (ldv_state_variable_10 == 1) {
#line 440
    cx18_av_s_std(cx18_av_video_ops_group0, ldvarg111);
#line 442
    ldv_state_variable_10 = 1;
  } else {

  }
#line 445
  goto ldv_53877;
  default: 
#line 446
  ldv_stop();
  }
  ldv_53877: ;
#line 450
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  struct v4l2_vbi_format *ldvarg90 ;
  void *tmp ;
  struct v4l2_decode_vbi_line *ldvarg89 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 453
  tmp = ldv_init_zalloc(44UL);
#line 453
  ldvarg90 = (struct v4l2_vbi_format *)tmp;
#line 454
  tmp___0 = ldv_init_zalloc(24UL);
#line 454
  ldvarg89 = (struct v4l2_decode_vbi_line *)tmp___0;
#line 456
  tmp___1 = __VERIFIER_nondet_int();
#line 456
  switch (tmp___1) {
  case 0: ;
#line 459
  if (ldv_state_variable_9 == 1) {
#line 461
    cx18_av_s_raw_fmt(cx18_av_vbi_ops_group0, ldvarg90);
#line 463
    ldv_state_variable_9 = 1;
  } else {

  }
#line 466
  goto ldv_53887;
  case 1: ;
#line 469
  if (ldv_state_variable_9 == 1) {
#line 471
    cx18_av_g_sliced_fmt(cx18_av_vbi_ops_group0, cx18_av_vbi_ops_group1);
#line 473
    ldv_state_variable_9 = 1;
  } else {

  }
#line 476
  goto ldv_53887;
  case 2: ;
#line 479
  if (ldv_state_variable_9 == 1) {
#line 481
    cx18_av_decode_vbi_line(cx18_av_vbi_ops_group0, ldvarg89);
#line 483
    ldv_state_variable_9 = 1;
  } else {

  }
#line 486
  goto ldv_53887;
  case 3: ;
#line 489
  if (ldv_state_variable_9 == 1) {
#line 491
    cx18_av_s_sliced_fmt(cx18_av_vbi_ops_group0, cx18_av_vbi_ops_group1);
#line 493
    ldv_state_variable_9 = 1;
  } else {

  }
#line 496
  goto ldv_53887;
  default: 
#line 497
  ldv_stop();
  }
  ldv_53887: ;
#line 501
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  struct v4l2_frequency *ldvarg92 ;
  void *tmp ;
  struct v4l2_tuner *ldvarg91 ;
  void *tmp___0 ;
  struct v4l2_tuner *ldvarg93 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 504
  tmp = ldv_init_zalloc(44UL);
#line 504
  ldvarg92 = (struct v4l2_frequency *)tmp;
#line 505
  tmp___0 = ldv_init_zalloc(84UL);
#line 505
  ldvarg91 = (struct v4l2_tuner *)tmp___0;
#line 506
  tmp___1 = ldv_init_zalloc(84UL);
#line 506
  ldvarg93 = (struct v4l2_tuner *)tmp___1;
#line 508
  tmp___2 = __VERIFIER_nondet_int();
#line 508
  switch (tmp___2) {
  case 0: ;
#line 511
  if (ldv_state_variable_12 == 1) {
#line 513
    cx18_av_s_tuner(cx18_av_tuner_ops_group0, (struct v4l2_tuner  const  *)ldvarg93);
#line 515
    ldv_state_variable_12 = 1;
  } else {

  }
#line 518
  goto ldv_53899;
  case 1: ;
#line 521
  if (ldv_state_variable_12 == 1) {
#line 523
    cx18_av_s_radio(cx18_av_tuner_ops_group0);
#line 525
    ldv_state_variable_12 = 1;
  } else {

  }
#line 528
  goto ldv_53899;
  case 2: ;
#line 531
  if (ldv_state_variable_12 == 1) {
#line 533
    cx18_av_s_frequency(cx18_av_tuner_ops_group0, (struct v4l2_frequency  const  *)ldvarg92);
#line 535
    ldv_state_variable_12 = 1;
  } else {

  }
#line 538
  goto ldv_53899;
  case 3: ;
#line 541
  if (ldv_state_variable_12 == 1) {
#line 543
    cx18_av_g_tuner(cx18_av_tuner_ops_group0, ldvarg91);
#line 545
    ldv_state_variable_12 = 1;
  } else {

  }
#line 548
  goto ldv_53899;
  default: 
#line 549
  ldv_stop();
  }
  ldv_53899: ;
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  struct v4l2_ctrl *ldvarg96 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 556
  tmp = ldv_init_zalloc(208UL);
#line 556
  ldvarg96 = (struct v4l2_ctrl *)tmp;
#line 558
  tmp___0 = __VERIFIER_nondet_int();
#line 558
  switch (tmp___0) {
  case 0: ;
#line 561
  if (ldv_state_variable_14 == 1) {
#line 563
    cx18_av_s_ctrl(ldvarg96);
#line 565
    ldv_state_variable_14 = 1;
  } else {

  }
#line 568
  goto ldv_53909;
  default: 
#line 569
  ldv_stop();
  }
  ldv_53909: ;
#line 573
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
bool ldv_queue_work_on_619(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 602
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 602
  ldv_func_res = tmp;
#line 604
  activate_work_2(ldv_func_arg3, 2);
#line 606
  return (ldv_func_res);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
bool ldv_queue_delayed_work_on_620(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 613
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 613
  ldv_func_res = tmp;
#line 615
  activate_work_2(& ldv_func_arg3->work, 2);
#line 617
  return (ldv_func_res);
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 624
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 624
  ldv_func_res = tmp;
#line 626
  activate_work_2(ldv_func_arg3, 2);
#line 628
  return (ldv_func_res);
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_flush_workqueue_622(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 634
  flush_workqueue(ldv_func_arg1);
#line 636
  call_and_disable_all_2(2);
#line 637
  return;
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
bool ldv_queue_delayed_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 643
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 643
  ldv_func_res = tmp;
#line 645
  activate_work_2(& ldv_func_arg3->work, 2);
#line 647
  return (ldv_func_res);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_624(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 653
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 655
  mutex_lock(ldv_func_arg1);
#line 656
  return;
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_unlock_625(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 661
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 663
  mutex_unlock(ldv_func_arg1);
#line 664
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_unlock_626(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 669
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 671
  mutex_unlock(ldv_func_arg1);
#line 672
  return;
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_627(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 677
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 679
  mutex_lock(ldv_func_arg1);
#line 680
  return;
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_628(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 685
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 687
  mutex_lock(ldv_func_arg1);
#line 688
  return;
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
int ldv_mutex_trylock_629(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 694
  tmp = mutex_trylock(ldv_func_arg1);
#line 694
  ldv_func_res = tmp;
#line 696
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 696
  return (tmp___0);
#line 698
  return (ldv_func_res);
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_unlock_630(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 704
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 706
  mutex_unlock(ldv_func_arg1);
#line 707
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 712
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 714
  mutex_lock(ldv_func_arg1);
#line 715
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 720
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 722
  mutex_unlock(ldv_func_arg1);
#line 723
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 728
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 730
  mutex_lock(ldv_func_arg1);
#line 731
  return;
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-core.o.c.prepared"
void ldv_mutex_unlock_634(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 736
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 738
  mutex_unlock(ldv_func_arg1);
#line 739
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_665(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_661(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_662(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_666(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_660(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_663(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_667(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_656(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_659(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_658(struct workqueue_struct *ldv_func_arg1 ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static int set_audclk_freq(struct cx18 *cx , u32 freq ) 
{ 
  struct cx18_av_state *state ;

  {
#line 29
  state = & cx->av_state;
#line 31
  if ((freq != 32000U && freq != 44100U) && freq != 48000U) {
#line 32
    return (-22);
  } else {

  }
#line 70
  if ((unsigned int )state->aud_input > 1U) {
#line 71
    switch (freq) {
    case 32000U: 
#line 77
    cx18_av_write4(cx, 264, 537723919U);
#line 81
    cx18_av_write4(cx, 268, 2876158U);
#line 85
    cx18_av_write4(cx, 272, 24540172U);
#line 89
    cx18_av_write4(cx, 2304, 134346623U);
#line 90
    cx18_av_write4(cx, 2308, 134346623U);
#line 91
    cx18_av_write4(cx, 2316, 134346623U);
#line 94
    cx18_av_write(cx, 295, 96);
#line 97
    cx18_av_write4(cx, 300, 287322111U);
#line 104
    cx18_av_write4(cx, 296, 2685218552U);
#line 105
    goto ldv_53222;
    case 44100U: 
#line 112
    cx18_av_write4(cx, 264, 403571727U);
#line 116
    cx18_av_write4(cx, 268, 2876158U);
#line 120
    cx18_av_write4(cx, 272, 6463986U);
#line 124
    cx18_av_write4(cx, 2304, 134311257U);
#line 125
    cx18_av_write4(cx, 2308, 134311257U);
#line 126
    cx18_av_write4(cx, 2316, 134311257U);
#line 129
    cx18_av_write(cx, 295, 88);
#line 132
    cx18_av_write4(cx, 300, 287347455U);
#line 139
    cx18_av_write4(cx, 296, 2686274552U);
#line 140
    goto ldv_53222;
    case 48000U: 
#line 147
    cx18_av_write4(cx, 264, 370017295U);
#line 151
    cx18_av_write4(cx, 268, 2876158U);
#line 155
    cx18_av_write4(cx, 272, 5384109U);
#line 159
    cx18_av_write4(cx, 2304, 134303658U);
#line 160
    cx18_av_write4(cx, 2308, 134303658U);
#line 161
    cx18_av_write4(cx, 2316, 134303658U);
#line 164
    cx18_av_write(cx, 295, 86);
#line 167
    cx18_av_write4(cx, 300, 287334399U);
#line 174
    cx18_av_write4(cx, 296, 2685506552U);
#line 175
    goto ldv_53222;
    }
    ldv_53222: ;
  } else {
#line 178
    switch (freq) {
    case 32000U: 
#line 184
    cx18_av_write4(cx, 264, 806159375U);
#line 188
    cx18_av_write4(cx, 268, 2876158U);
#line 192
    cx18_av_write4(cx, 272, 24540172U);
#line 196
    cx18_av_write4(cx, 2296, 134283264U);
#line 200
    cx18_av_write4(cx, 2304, 134348800U);
#line 201
    cx18_av_write4(cx, 2308, 134348800U);
#line 202
    cx18_av_write4(cx, 2316, 134348800U);
#line 205
    cx18_av_write(cx, 295, 112);
#line 208
    cx18_av_write4(cx, 300, 287318015U);
#line 215
    cx18_av_write4(cx, 296, 2685218552U);
#line 216
    goto ldv_53226;
    case 44100U: 
#line 223
    cx18_av_write4(cx, 264, 604898319U);
#line 227
    cx18_av_write4(cx, 268, 2876158U);
#line 231
    cx18_av_write4(cx, 272, 6463986U);
#line 235
    cx18_av_write4(cx, 2296, 134308045U);
#line 239
    cx18_av_write4(cx, 2304, 134312837U);
#line 240
    cx18_av_write4(cx, 2308, 134312837U);
#line 241
    cx18_av_write4(cx, 2316, 134312837U);
#line 244
    cx18_av_write(cx, 295, 100);
#line 247
    cx18_av_write4(cx, 300, 287334911U);
#line 254
    cx18_av_write4(cx, 296, 2686274552U);
#line 255
    goto ldv_53226;
    case 48000U: 
#line 262
    cx18_av_write4(cx, 264, 537723919U);
#line 266
    cx18_av_write4(cx, 268, 2876158U);
#line 270
    cx18_av_write4(cx, 272, 24540172U);
#line 274
    cx18_av_write4(cx, 2296, 134316032U);
#line 278
    cx18_av_write4(cx, 2304, 134305109U);
#line 279
    cx18_av_write4(cx, 2308, 134305109U);
#line 280
    cx18_av_write4(cx, 2316, 134305109U);
#line 283
    cx18_av_write(cx, 295, 96);
#line 286
    cx18_av_write4(cx, 300, 287326207U);
#line 293
    cx18_av_write4(cx, 296, 2685506552U);
#line 294
    goto ldv_53226;
    }
    ldv_53226: ;
  }
#line 298
  state->audclk_freq = freq;
#line 300
  return (0);
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
void cx18_av_audio_set_path(struct cx18 *cx ) 
{ 
  struct cx18_av_state *state ;
  u8 v ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 305
  state = & cx->av_state;
#line 309
  tmp = cx18_av_read(cx, 2051);
#line 309
  v = (unsigned int )tmp & 239U;
#line 310
  cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 313
  tmp___0 = cx18_av_read(cx, 2064);
#line 313
  v = (u8 )((unsigned int )tmp___0 | 1U);
#line 314
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 317
  cx18_av_write(cx, 2259, 31);
#line 319
  if ((unsigned int )state->aud_input <= 1U) {
#line 321
    cx18_av_write4(cx, 2256, 16846866U);
  } else {
#line 328
    cx18_av_write4(cx, 2256, 520501360U);
  }
#line 331
  set_audclk_freq(cx, state->audclk_freq);
#line 334
  tmp___1 = cx18_av_read(cx, 2064);
#line 334
  v = (unsigned int )tmp___1 & 254U;
#line 335
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 337
  if ((unsigned int )state->aud_input > 1U) {
#line 340
    tmp___2 = cx18_av_read(cx, 2051);
#line 340
    v = (u8 )((unsigned int )tmp___2 | 16U);
#line 341
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 343
  return;
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static void set_volume(struct cx18 *cx , int volume ) 
{ 
  int vol ;

  {
#line 348
  vol = volume >> 9;
#line 352
  if (vol <= 23) {
#line 353
    vol = 0;
  } else {
#line 355
    vol = vol + -23;
  }
#line 358
  cx18_av_write(cx, 2260, (int )((unsigned int )((u8 )(114 - vol)) * 2U));
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static void set_bass(struct cx18 *cx , int bass ) 
{ 


  {
#line 364
  cx18_av_and_or(cx, 2265, 4294967232U, (int )(48U - (unsigned int )((u8 )((bass * 48) / 65535))));
#line 365
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static void set_treble(struct cx18 *cx , int treble ) 
{ 


  {
#line 370
  cx18_av_and_or(cx, 2267, 4294967232U, (int )(48U - (unsigned int )((u8 )((treble * 48) / 65535))));
#line 371
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static void set_balance(struct cx18 *cx , int balance ) 
{ 
  int bal ;

  {
#line 375
  bal = balance >> 8;
#line 376
  if (bal > 128) {
#line 378
    cx18_av_and_or(cx, 2261, 127U, 128);
#line 380
    cx18_av_and_or(cx, 2261, 4294967168U, (int )((u8 )bal) & 127);
  } else {
#line 383
    cx18_av_and_or(cx, 2261, 127U, 0);
#line 385
    cx18_av_and_or(cx, 2261, 4294967168U, (int )(128U - (unsigned int )((u8 )bal)));
  }
#line 387
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static void set_mute(struct cx18 *cx , int mute ) 
{ 
  struct cx18_av_state *state ;
  u8 v ;

  {
#line 391
  state = & cx->av_state;
#line 394
  if ((unsigned int )state->aud_input > 1U) {
#line 399
    v = cx18_av_read(cx, 2051);
#line 400
    if (mute != 0) {
#line 402
      v = (unsigned int )v & 239U;
#line 403
      cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 404
      cx18_av_write(cx, 2259, 31);
    } else {
#line 407
      v = (u8 )((unsigned int )v | 16U);
#line 408
      cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
    }
  } else {
#line 412
    cx18_av_and_or(cx, 2259, 4294967293U, mute != 0 ? 2 : 0);
  }
#line 413
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
int cx18_av_s_clock_freq(struct v4l2_subdev *sd , u32 freq ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  int retval ;
  u8 v ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;

  {
#line 418
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 418
  cx = (struct cx18 *)tmp;
#line 419
  state = & cx->av_state;
#line 423
  if ((unsigned int )state->aud_input > 1U) {
#line 424
    tmp___0 = cx18_av_read(cx, 2051);
#line 424
    v = (unsigned int )tmp___0 & 239U;
#line 425
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
#line 426
    cx18_av_write(cx, 2259, 31);
  } else {

  }
#line 428
  tmp___1 = cx18_av_read(cx, 2064);
#line 428
  v = (u8 )((unsigned int )tmp___1 | 1U);
#line 429
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 431
  retval = set_audclk_freq(cx, freq);
#line 433
  tmp___2 = cx18_av_read(cx, 2064);
#line 433
  v = (unsigned int )tmp___2 & 254U;
#line 434
  cx18_av_write_expect(cx, 2064, (int )v, (int )v, 15);
#line 435
  if ((unsigned int )state->aud_input > 1U) {
#line 436
    tmp___3 = cx18_av_read(cx, 2051);
#line 436
    v = (u8 )((unsigned int )tmp___3 | 16U);
#line 437
    cx18_av_write_expect(cx, 2051, (int )v, (int )v, 31);
  } else {

  }
#line 439
  return (retval);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
static int cx18_av_audio_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct v4l2_subdev *sd ;
  struct v4l2_subdev *tmp ;
  struct cx18 *cx ;
  void *tmp___0 ;

  {
#line 444
  tmp = to_sd(ctrl);
#line 444
  sd = tmp;
#line 445
  tmp___0 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 445
  cx = (struct cx18 *)tmp___0;
#line 447
  switch (ctrl->id) {
  case 9963781U: 
#line 449
  set_volume(cx, ctrl->val);
#line 450
  goto ldv_53272;
  case 9963783U: 
#line 452
  set_bass(cx, ctrl->val);
#line 453
  goto ldv_53272;
  case 9963784U: 
#line 455
  set_treble(cx, ctrl->val);
#line 456
  goto ldv_53272;
  case 9963782U: 
#line 458
  set_balance(cx, ctrl->val);
#line 459
  goto ldv_53272;
  case 9963785U: 
#line 461
  set_mute(cx, ctrl->val);
#line 462
  goto ldv_53272;
  default: ;
#line 464
  return (-22);
  }
  ldv_53272: ;
#line 466
  return (0);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.c"
struct v4l2_ctrl_ops  const  cx18_av_audio_ctrl_ops  =    {0, 0, & cx18_av_audio_s_ctrl};
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  struct v4l2_ctrl *ldvarg8 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 271
  tmp = ldv_init_zalloc(208UL);
#line 271
  ldvarg8 = (struct v4l2_ctrl *)tmp;
#line 273
  tmp___0 = __VERIFIER_nondet_int();
#line 273
  switch (tmp___0) {
  case 0: ;
#line 276
  if (ldv_state_variable_7 == 1) {
#line 278
    cx18_av_audio_s_ctrl(ldvarg8);
#line 280
    ldv_state_variable_7 = 1;
  } else {

  }
#line 283
  goto ldv_53284;
  default: 
#line 284
  ldv_stop();
  }
  ldv_53284: ;
#line 288
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 317
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 317
  ldv_func_res = tmp;
#line 319
  activate_work_2(ldv_func_arg3, 2);
#line 321
  return (ldv_func_res);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_656(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 328
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 328
  ldv_func_res = tmp;
#line 330
  activate_work_2(& ldv_func_arg3->work, 2);
#line 332
  return (ldv_func_res);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
bool ldv_queue_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 339
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 339
  ldv_func_res = tmp;
#line 341
  activate_work_2(ldv_func_arg3, 2);
#line 343
  return (ldv_func_res);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_flush_workqueue_658(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 349
  flush_workqueue(ldv_func_arg1);
#line 351
  call_and_disable_all_2(2);
#line 352
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_659(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 358
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 358
  ldv_func_res = tmp;
#line 360
  activate_work_2(& ldv_func_arg3->work, 2);
#line 362
  return (ldv_func_res);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_660(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 368
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 370
  mutex_lock(ldv_func_arg1);
#line 371
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_unlock_661(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 376
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 378
  mutex_unlock(ldv_func_arg1);
#line 379
  return;
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_unlock_662(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 384
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 386
  mutex_unlock(ldv_func_arg1);
#line 387
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_663(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 392
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 394
  mutex_lock(ldv_func_arg1);
#line 395
  return;
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 400
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 402
  mutex_lock(ldv_func_arg1);
#line 403
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
int ldv_mutex_trylock_665(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 409
  tmp = mutex_trylock(ldv_func_arg1);
#line 409
  ldv_func_res = tmp;
#line 411
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 411
  return (tmp___0);
#line 413
  return (ldv_func_res);
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_unlock_666(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 419
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 421
  mutex_unlock(ldv_func_arg1);
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_667(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 427
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 429
  mutex_lock(ldv_func_arg1);
#line 430
  return;
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 435
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 437
  mutex_unlock(ldv_func_arg1);
#line 438
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 443
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 445
  mutex_lock(ldv_func_arg1);
#line 446
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-audio.o.c.prepared"
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 451
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 453
  mutex_unlock(ldv_func_arg1);
#line 454
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_701(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_697(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_702(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_704(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_706(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_696(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_700(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_703(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_705(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_691(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_693(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_692(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_694(struct workqueue_struct *ldv_func_arg1 ) ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.c"
static int cx18_av_verifyfw(struct cx18 *cx , struct firmware  const  *fw ) 
{ 
  struct v4l2_subdev *sd ;
  int ret ;
  u8 const   *data ;
  u32 size ;
  int addr ;
  u32 expected ;
  u32 dl_control ;

  {
#line 38
  sd = & cx->av_state.sd;
#line 39
  ret = 0;
#line 46
  dl_control = cx18_av_read4(cx, 2048);
  ldv_53400: 
#line 48
  dl_control = dl_control & 16777215U;
#line 49
  dl_control = dl_control | 251658240U;
#line 50
  cx18_av_write4_noretry(cx, 2048, dl_control);
#line 51
  dl_control = cx18_av_read4(cx, 2048);
#line 52
  if ((dl_control & 4278190080U) != 251658240U) {
#line 54
    goto ldv_53400;
  } else {

  }

#line 55
  goto ldv_53403;
  ldv_53402: 
#line 56
  dl_control = cx18_av_read4(cx, 2048);
  ldv_53403: ;
#line 55
  if ((dl_control & 16383U) != 0U) {
#line 57
    goto ldv_53402;
  } else {

  }
#line 58
  data = fw->data;
#line 59
  size = (u32 )fw->size;
#line 60
  addr = 0;
#line 60
  goto ldv_53407;
  ldv_53406: 
#line 61
  dl_control = dl_control & 4294918143U;
#line 62
  expected = (((unsigned int )*(data + (unsigned long )addr) << 16) | (unsigned int )addr) | 251658240U;
#line 63
  if (expected != dl_control) {
#line 64
    printk("\v%s: verification of %s firmware load failed: expected %#010x got %#010x\n",
           (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw", expected, dl_control);
#line 67
    ret = -5;
#line 68
    goto ldv_53405;
  } else {

  }
#line 70
  dl_control = cx18_av_read4(cx, 2048);
#line 60
  addr = addr + 1;
  ldv_53407: ;
#line 60
  if ((u32 )addr < size) {
#line 62
    goto ldv_53406;
  } else {

  }
  ldv_53405: ;
#line 72
  if (ret == 0) {
#line 73
    printk("\016%s: verified load of %s firmware (%d bytes)\n", (char *)(& sd->name),
           (char *)"v4l-cx23418-dig.fw", size);
  } else {

  }
#line 75
  return (ret);
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.c"
int cx18_av_loadfw(struct cx18 *cx ) 
{ 
  struct v4l2_subdev *sd ;
  struct firmware  const  *fw ;
  u32 size ;
  u32 u ;
  u32 v ;
  u8 const   *ptr ;
  int i ;
  int retries1 ;
  int tmp ;
  u32 dl_control ;
  u32 value ;
  int retries2 ;
  int unrec_err ;
  int tmp___0 ;

  {
#line 80
  sd = & cx->av_state.sd;
#line 81
  fw = (struct firmware  const  *)0;
#line 86
  retries1 = 0;
#line 88
  tmp = request_firmware(& fw, "v4l-cx23418-dig.fw", & (cx->pci_dev)->dev);
#line 88
  if (tmp != 0) {
#line 89
    printk("\v%s: unable to open firmware %s\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw");
#line 90
    return (-22);
  } else {

  }
#line 95
  goto ldv_53431;
  ldv_53430: 
#line 96
  cx18_av_write4_expect(cx, 256, 65536U, 33840U, 4294967295U);
#line 98
  cx18_av_write_expect(cx, 2056, 246, 246, 255);
#line 101
  cx18_av_write4_expect(cx, 33024, 65536U, 33840U, 4294967295U);
#line 105
  cx18_av_write4_noretry(cx, 2048, 251658240U);
#line 107
  ptr = fw->data;
#line 108
  size = (u32 )fw->size;
#line 110
  i = 0;
#line 110
  goto ldv_53428;
  ldv_53427: 
#line 111
  dl_control = (((unsigned int )*(ptr + (unsigned long )i) << 16) | (unsigned int )i) | 251658240U;
#line 112
  value = 0U;
#line 114
  unrec_err = 0;
#line 116
  retries2 = 0;
#line 116
  goto ldv_53425;
  ldv_53424: 
#line 118
  cx18_av_write4_noretry(cx, 2048, dl_control);
#line 120
  __const_udelay(42950UL);
#line 121
  value = cx18_av_read4(cx, 2048);
#line 122
  if (value == dl_control) {
#line 123
    goto ldv_53423;
  } else {

  }
#line 127
  if (((value ^ dl_control) & 16128U) != 0U) {
#line 128
    unrec_err = 1;
#line 129
    goto ldv_53423;
  } else {

  }
#line 117
  retries2 = retries2 + 1;
  ldv_53425: ;
#line 116
  if (retries2 <= 9) {
#line 118
    goto ldv_53424;
  } else {

  }
  ldv_53423: ;
#line 132
  if (unrec_err != 0 || retries2 > 9) {
#line 133
    goto ldv_53426;
  } else {

  }
#line 110
  i = i + 1;
  ldv_53428: ;
#line 110
  if ((u32 )i < size) {
#line 112
    goto ldv_53427;
  } else {

  }
  ldv_53426: ;
#line 135
  if ((u32 )i == size) {
#line 136
    goto ldv_53429;
  } else {

  }
#line 137
  retries1 = retries1 + 1;
  ldv_53431: ;
#line 95
  if (retries1 <= 4) {
#line 97
    goto ldv_53430;
  } else {

  }
  ldv_53429: ;
#line 139
  if (retries1 > 4) {
#line 140
    printk("\v%s: unable to load firmware %s\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw");
#line 141
    release_firmware(fw);
#line 142
    return (-5);
  } else {

  }
#line 145
  cx18_av_write4_expect(cx, 2048, (u32 )fw->size | 50331648U, 50331648U, 318767104U);
#line 148
  printk("\016%s: loaded %s firmware (%d bytes)\n", (char *)(& sd->name), (char *)"v4l-cx23418-dig.fw",
         size);
#line 150
  tmp___0 = cx18_av_verifyfw(cx, fw);
#line 150
  if (tmp___0 == 0) {
#line 151
    cx18_av_write4_expect(cx, 2048, (u32 )fw->size | 318767104U, 318767104U, 318767104U);
  } else {

  }
#line 155
  cx18_av_and_or4(cx, 276, 4294967295U, 491520U);
#line 162
  cx18_av_write4(cx, 2324, 160U);
#line 171
  cx18_av_write4(cx, 2328, 416U);
#line 175
  cx18_av_write4(cx, 292, 1442887303U);
#line 177
  cx18_av_write4_expect(cx, 2056, 246U, 246U, 1057030143U);
#line 184
  cx18_av_write4(cx, 2508, 1U);
#line 186
  v = cx18_read_reg(cx, 13049876U);
#line 188
  if ((v & 2048U) != 0U) {
#line 189
    cx18_write_reg_expect(cx, v & 4294966271U, 13049876U, 0U, 1024U);
  } else {

  }
#line 193
  v = cx18_read_reg(cx, 13049876U);
#line 194
  u = v & 48U;
#line 195
  v = v & 4294967247U;
#line 196
  if (u == 32U || u == 48U) {
#line 198
    v = v;
#line 199
    cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 202
    v = (v & 4294967247U) | 32U;
  } else {
#line 205
    v = v | 32U;
#line 206
    cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 209
    v = (v & 4294967247U) | u;
  }
#line 211
  cx18_write_reg_expect(cx, v | 2816U, 13049876U, v, 48U);
#line 215
  v = cx18_av_read4(cx, 2056);
#line 216
  v = v | 255U;
#line 217
  v = v | 1024U;
#line 218
  v = v | 335544320U;
#line 219
  cx18_av_write4_expect(cx, 2056, v, v, 1057030143U);
#line 221
  release_firmware(fw);
#line 222
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
bool ldv_queue_work_on_691(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_692(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
bool ldv_queue_work_on_693(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_flush_workqueue_694(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
bool ldv_queue_delayed_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_696(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_unlock_697(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_700(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
int ldv_mutex_trylock_701(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_unlock_702(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_703(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_unlock_704(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_lock_705(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-firmware.o.c.prepared"
void ldv_mutex_unlock_706(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_737(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_733(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_734(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_738(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_740(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_742(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_732(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_735(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_736(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_739(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_741(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_727(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_729(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_728(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_731(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_730(struct workqueue_struct *ldv_func_arg1 ) ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
static u8 const   sliced_vbi_did[2U]  = {      145U,      85U};
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
static int odd_parity(u8 c ) 
{ 


  {
#line 75
  c = (u8 )(((int )c >> 4) ^ (int )c);
#line 76
  c = (u8 )(((int )c >> 2) ^ (int )c);
#line 77
  c = (u8 )(((int )c >> 1) ^ (int )c);
#line 79
  return ((int )c & 1);
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
static int decode_vps(u8 *dst , u8 *p ) 
{ 
  u8 biphase_tbl[256U] ;
  u8 c ;
  u8 err ;
  int i ;

  {
#line 84
  biphase_tbl[0] = 240U;
#line 84
  biphase_tbl[1] = 120U;
#line 84
  biphase_tbl[2] = 112U;
#line 84
  biphase_tbl[3] = 240U;
#line 84
  biphase_tbl[4] = 180U;
#line 84
  biphase_tbl[5] = 60U;
#line 84
  biphase_tbl[6] = 52U;
#line 84
  biphase_tbl[7] = 180U;
#line 84
  biphase_tbl[8] = 176U;
#line 84
  biphase_tbl[9] = 56U;
#line 84
  biphase_tbl[10] = 48U;
#line 84
  biphase_tbl[11] = 176U;
#line 84
  biphase_tbl[12] = 240U;
#line 84
  biphase_tbl[13] = 120U;
#line 84
  biphase_tbl[14] = 112U;
#line 84
  biphase_tbl[15] = 240U;
#line 84
  biphase_tbl[16] = 210U;
#line 84
  biphase_tbl[17] = 90U;
#line 84
  biphase_tbl[18] = 82U;
#line 84
  biphase_tbl[19] = 210U;
#line 84
  biphase_tbl[20] = 150U;
#line 84
  biphase_tbl[21] = 30U;
#line 84
  biphase_tbl[22] = 22U;
#line 84
  biphase_tbl[23] = 150U;
#line 84
  biphase_tbl[24] = 146U;
#line 84
  biphase_tbl[25] = 26U;
#line 84
  biphase_tbl[26] = 18U;
#line 84
  biphase_tbl[27] = 146U;
#line 84
  biphase_tbl[28] = 210U;
#line 84
  biphase_tbl[29] = 90U;
#line 84
  biphase_tbl[30] = 82U;
#line 84
  biphase_tbl[31] = 210U;
#line 84
  biphase_tbl[32] = 208U;
#line 84
  biphase_tbl[33] = 88U;
#line 84
  biphase_tbl[34] = 80U;
#line 84
  biphase_tbl[35] = 208U;
#line 84
  biphase_tbl[36] = 148U;
#line 84
  biphase_tbl[37] = 28U;
#line 84
  biphase_tbl[38] = 20U;
#line 84
  biphase_tbl[39] = 148U;
#line 84
  biphase_tbl[40] = 144U;
#line 84
  biphase_tbl[41] = 24U;
#line 84
  biphase_tbl[42] = 16U;
#line 84
  biphase_tbl[43] = 144U;
#line 84
  biphase_tbl[44] = 208U;
#line 84
  biphase_tbl[45] = 88U;
#line 84
  biphase_tbl[46] = 80U;
#line 84
  biphase_tbl[47] = 208U;
#line 84
  biphase_tbl[48] = 240U;
#line 84
  biphase_tbl[49] = 120U;
#line 84
  biphase_tbl[50] = 112U;
#line 84
  biphase_tbl[51] = 240U;
#line 84
  biphase_tbl[52] = 180U;
#line 84
  biphase_tbl[53] = 60U;
#line 84
  biphase_tbl[54] = 52U;
#line 84
  biphase_tbl[55] = 180U;
#line 84
  biphase_tbl[56] = 176U;
#line 84
  biphase_tbl[57] = 56U;
#line 84
  biphase_tbl[58] = 48U;
#line 84
  biphase_tbl[59] = 176U;
#line 84
  biphase_tbl[60] = 240U;
#line 84
  biphase_tbl[61] = 120U;
#line 84
  biphase_tbl[62] = 112U;
#line 84
  biphase_tbl[63] = 240U;
#line 84
  biphase_tbl[64] = 225U;
#line 84
  biphase_tbl[65] = 105U;
#line 84
  biphase_tbl[66] = 97U;
#line 84
  biphase_tbl[67] = 225U;
#line 84
  biphase_tbl[68] = 165U;
#line 84
  biphase_tbl[69] = 45U;
#line 84
  biphase_tbl[70] = 37U;
#line 84
  biphase_tbl[71] = 165U;
#line 84
  biphase_tbl[72] = 161U;
#line 84
  biphase_tbl[73] = 41U;
#line 84
  biphase_tbl[74] = 33U;
#line 84
  biphase_tbl[75] = 161U;
#line 84
  biphase_tbl[76] = 225U;
#line 84
  biphase_tbl[77] = 105U;
#line 84
  biphase_tbl[78] = 97U;
#line 84
  biphase_tbl[79] = 225U;
#line 84
  biphase_tbl[80] = 195U;
#line 84
  biphase_tbl[81] = 75U;
#line 84
  biphase_tbl[82] = 67U;
#line 84
  biphase_tbl[83] = 195U;
#line 84
  biphase_tbl[84] = 135U;
#line 84
  biphase_tbl[85] = 15U;
#line 84
  biphase_tbl[86] = 7U;
#line 84
  biphase_tbl[87] = 135U;
#line 84
  biphase_tbl[88] = 131U;
#line 84
  biphase_tbl[89] = 11U;
#line 84
  biphase_tbl[90] = 3U;
#line 84
  biphase_tbl[91] = 131U;
#line 84
  biphase_tbl[92] = 195U;
#line 84
  biphase_tbl[93] = 75U;
#line 84
  biphase_tbl[94] = 67U;
#line 84
  biphase_tbl[95] = 195U;
#line 84
  biphase_tbl[96] = 193U;
#line 84
  biphase_tbl[97] = 73U;
#line 84
  biphase_tbl[98] = 65U;
#line 84
  biphase_tbl[99] = 193U;
#line 84
  biphase_tbl[100] = 133U;
#line 84
  biphase_tbl[101] = 13U;
#line 84
  biphase_tbl[102] = 5U;
#line 84
  biphase_tbl[103] = 133U;
#line 84
  biphase_tbl[104] = 129U;
#line 84
  biphase_tbl[105] = 9U;
#line 84
  biphase_tbl[106] = 1U;
#line 84
  biphase_tbl[107] = 129U;
#line 84
  biphase_tbl[108] = 193U;
#line 84
  biphase_tbl[109] = 73U;
#line 84
  biphase_tbl[110] = 65U;
#line 84
  biphase_tbl[111] = 193U;
#line 84
  biphase_tbl[112] = 225U;
#line 84
  biphase_tbl[113] = 105U;
#line 84
  biphase_tbl[114] = 97U;
#line 84
  biphase_tbl[115] = 225U;
#line 84
  biphase_tbl[116] = 165U;
#line 84
  biphase_tbl[117] = 45U;
#line 84
  biphase_tbl[118] = 37U;
#line 84
  biphase_tbl[119] = 165U;
#line 84
  biphase_tbl[120] = 161U;
#line 84
  biphase_tbl[121] = 41U;
#line 84
  biphase_tbl[122] = 33U;
#line 84
  biphase_tbl[123] = 161U;
#line 84
  biphase_tbl[124] = 225U;
#line 84
  biphase_tbl[125] = 105U;
#line 84
  biphase_tbl[126] = 97U;
#line 84
  biphase_tbl[127] = 225U;
#line 84
  biphase_tbl[128] = 224U;
#line 84
  biphase_tbl[129] = 104U;
#line 84
  biphase_tbl[130] = 96U;
#line 84
  biphase_tbl[131] = 224U;
#line 84
  biphase_tbl[132] = 164U;
#line 84
  biphase_tbl[133] = 44U;
#line 84
  biphase_tbl[134] = 36U;
#line 84
  biphase_tbl[135] = 164U;
#line 84
  biphase_tbl[136] = 160U;
#line 84
  biphase_tbl[137] = 40U;
#line 84
  biphase_tbl[138] = 32U;
#line 84
  biphase_tbl[139] = 160U;
#line 84
  biphase_tbl[140] = 224U;
#line 84
  biphase_tbl[141] = 104U;
#line 84
  biphase_tbl[142] = 96U;
#line 84
  biphase_tbl[143] = 224U;
#line 84
  biphase_tbl[144] = 194U;
#line 84
  biphase_tbl[145] = 74U;
#line 84
  biphase_tbl[146] = 66U;
#line 84
  biphase_tbl[147] = 194U;
#line 84
  biphase_tbl[148] = 134U;
#line 84
  biphase_tbl[149] = 14U;
#line 84
  biphase_tbl[150] = 6U;
#line 84
  biphase_tbl[151] = 134U;
#line 84
  biphase_tbl[152] = 130U;
#line 84
  biphase_tbl[153] = 10U;
#line 84
  biphase_tbl[154] = 2U;
#line 84
  biphase_tbl[155] = 130U;
#line 84
  biphase_tbl[156] = 194U;
#line 84
  biphase_tbl[157] = 74U;
#line 84
  biphase_tbl[158] = 66U;
#line 84
  biphase_tbl[159] = 194U;
#line 84
  biphase_tbl[160] = 192U;
#line 84
  biphase_tbl[161] = 72U;
#line 84
  biphase_tbl[162] = 64U;
#line 84
  biphase_tbl[163] = 192U;
#line 84
  biphase_tbl[164] = 132U;
#line 84
  biphase_tbl[165] = 12U;
#line 84
  biphase_tbl[166] = 4U;
#line 84
  biphase_tbl[167] = 132U;
#line 84
  biphase_tbl[168] = 128U;
#line 84
  biphase_tbl[169] = 8U;
#line 84
  biphase_tbl[170] = 0U;
#line 84
  biphase_tbl[171] = 128U;
#line 84
  biphase_tbl[172] = 192U;
#line 84
  biphase_tbl[173] = 72U;
#line 84
  biphase_tbl[174] = 64U;
#line 84
  biphase_tbl[175] = 192U;
#line 84
  biphase_tbl[176] = 224U;
#line 84
  biphase_tbl[177] = 104U;
#line 84
  biphase_tbl[178] = 96U;
#line 84
  biphase_tbl[179] = 224U;
#line 84
  biphase_tbl[180] = 164U;
#line 84
  biphase_tbl[181] = 44U;
#line 84
  biphase_tbl[182] = 36U;
#line 84
  biphase_tbl[183] = 164U;
#line 84
  biphase_tbl[184] = 160U;
#line 84
  biphase_tbl[185] = 40U;
#line 84
  biphase_tbl[186] = 32U;
#line 84
  biphase_tbl[187] = 160U;
#line 84
  biphase_tbl[188] = 224U;
#line 84
  biphase_tbl[189] = 104U;
#line 84
  biphase_tbl[190] = 96U;
#line 84
  biphase_tbl[191] = 224U;
#line 84
  biphase_tbl[192] = 240U;
#line 84
  biphase_tbl[193] = 120U;
#line 84
  biphase_tbl[194] = 112U;
#line 84
  biphase_tbl[195] = 240U;
#line 84
  biphase_tbl[196] = 180U;
#line 84
  biphase_tbl[197] = 60U;
#line 84
  biphase_tbl[198] = 52U;
#line 84
  biphase_tbl[199] = 180U;
#line 84
  biphase_tbl[200] = 176U;
#line 84
  biphase_tbl[201] = 56U;
#line 84
  biphase_tbl[202] = 48U;
#line 84
  biphase_tbl[203] = 176U;
#line 84
  biphase_tbl[204] = 240U;
#line 84
  biphase_tbl[205] = 120U;
#line 84
  biphase_tbl[206] = 112U;
#line 84
  biphase_tbl[207] = 240U;
#line 84
  biphase_tbl[208] = 210U;
#line 84
  biphase_tbl[209] = 90U;
#line 84
  biphase_tbl[210] = 82U;
#line 84
  biphase_tbl[211] = 210U;
#line 84
  biphase_tbl[212] = 150U;
#line 84
  biphase_tbl[213] = 30U;
#line 84
  biphase_tbl[214] = 22U;
#line 84
  biphase_tbl[215] = 150U;
#line 84
  biphase_tbl[216] = 146U;
#line 84
  biphase_tbl[217] = 26U;
#line 84
  biphase_tbl[218] = 18U;
#line 84
  biphase_tbl[219] = 146U;
#line 84
  biphase_tbl[220] = 210U;
#line 84
  biphase_tbl[221] = 90U;
#line 84
  biphase_tbl[222] = 82U;
#line 84
  biphase_tbl[223] = 210U;
#line 84
  biphase_tbl[224] = 208U;
#line 84
  biphase_tbl[225] = 88U;
#line 84
  biphase_tbl[226] = 80U;
#line 84
  biphase_tbl[227] = 208U;
#line 84
  biphase_tbl[228] = 148U;
#line 84
  biphase_tbl[229] = 28U;
#line 84
  biphase_tbl[230] = 20U;
#line 84
  biphase_tbl[231] = 148U;
#line 84
  biphase_tbl[232] = 144U;
#line 84
  biphase_tbl[233] = 24U;
#line 84
  biphase_tbl[234] = 16U;
#line 84
  biphase_tbl[235] = 144U;
#line 84
  biphase_tbl[236] = 208U;
#line 84
  biphase_tbl[237] = 88U;
#line 84
  biphase_tbl[238] = 80U;
#line 84
  biphase_tbl[239] = 208U;
#line 84
  biphase_tbl[240] = 240U;
#line 84
  biphase_tbl[241] = 120U;
#line 84
  biphase_tbl[242] = 112U;
#line 84
  biphase_tbl[243] = 240U;
#line 84
  biphase_tbl[244] = 180U;
#line 84
  biphase_tbl[245] = 60U;
#line 84
  biphase_tbl[246] = 52U;
#line 84
  biphase_tbl[247] = 180U;
#line 84
  biphase_tbl[248] = 176U;
#line 84
  biphase_tbl[249] = 56U;
#line 84
  biphase_tbl[250] = 48U;
#line 84
  biphase_tbl[251] = 176U;
#line 84
  biphase_tbl[252] = 240U;
#line 84
  biphase_tbl[253] = 120U;
#line 84
  biphase_tbl[254] = 112U;
#line 84
  biphase_tbl[255] = 240U;
#line 119
  err = 0U;
#line 122
  i = 0;
#line 122
  goto ldv_53236;
  ldv_53235: 
#line 123
  err = (u8 )(((int )biphase_tbl[(int )*(p + (unsigned long )i)] | (int )biphase_tbl[(int )*(p + ((unsigned long )i + 1UL))]) | (int )err);
#line 124
  c = (u8 )(((int )((signed char )biphase_tbl[(int )*(p + ((unsigned long )i + 1UL))]) & 15) | (int )((signed char )((int )biphase_tbl[(int )*(p + (unsigned long )i)] << 4)));
#line 126
  *(dst + (unsigned long )(i / 2)) = c;
#line 122
  i = i + 2;
  ldv_53236: ;
#line 122
  if (i <= 25) {
#line 124
    goto ldv_53235;
  } else {

  }

#line 129
  return ((int )err & 240);
}
}
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
int cx18_av_g_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  u16 lcr2vbi[16U] ;
  int is_pal ;
  int i ;
  u8 tmp___0 ;
  u8 v ;
  u8 tmp___1 ;
  u8 v___0 ;
  u8 tmp___2 ;

  {
#line 134
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 134
  cx = (struct cx18 *)tmp;
#line 135
  state = & cx->av_state;
#line 136
  lcr2vbi[0] = 0U;
#line 136
  lcr2vbi[1] = 1U;
#line 136
  lcr2vbi[2] = 0U;
#line 136
  lcr2vbi[3] = 0U;
#line 136
  lcr2vbi[4] = 16384U;
#line 136
  lcr2vbi[5] = 0U;
#line 136
  lcr2vbi[6] = 4096U;
#line 136
  lcr2vbi[7] = 0U;
#line 136
  lcr2vbi[8] = 0U;
#line 136
  lcr2vbi[9] = 1024U;
#line 136
  lcr2vbi[10] = 0U;
#line 136
  lcr2vbi[11] = 0U;
#line 136
  lcr2vbi[12] = 0U;
#line 136
  lcr2vbi[13] = 0U;
#line 136
  lcr2vbi[14] = 0U;
#line 136
  lcr2vbi[15] = 0U;
#line 143
  is_pal = (state->std & 63744ULL) == 0ULL;
#line 146
  memset((void *)(& svbi->service_lines), 0, 96UL);
#line 147
  svbi->service_set = 0U;
#line 150
  tmp___0 = cx18_av_read(cx, 1028);
#line 150
  if (((int )tmp___0 & 16) == 0) {
#line 151
    return (0);
  } else {

  }
#line 153
  if (is_pal != 0) {
#line 154
    i = 7;
#line 154
    goto ldv_53249;
    ldv_53248: 
#line 155
    tmp___1 = cx18_av_read(cx, (int )((unsigned int )((u16 )i) + 1053U));
#line 155
    v = tmp___1;
#line 157
    svbi->service_lines[0][i] = lcr2vbi[(int )v >> 4];
#line 158
    svbi->service_lines[1][i] = lcr2vbi[(int )v & 15];
#line 159
    svbi->service_set = (__u16 )((int )svbi->service_set | ((int )svbi->service_lines[0][i] | (int )svbi->service_lines[1][i]));
#line 154
    i = i + 1;
    ldv_53249: ;
#line 154
    if (i <= 23) {
#line 156
      goto ldv_53248;
    } else {

    }

  } else {
#line 163
    i = 10;
#line 163
    goto ldv_53253;
    ldv_53252: 
#line 164
    tmp___2 = cx18_av_read(cx, (int )((unsigned int )((u16 )i) + 1050U));
#line 164
    v___0 = tmp___2;
#line 166
    svbi->service_lines[0][i] = lcr2vbi[(int )v___0 >> 4];
#line 167
    svbi->service_lines[1][i] = lcr2vbi[(int )v___0 & 15];
#line 168
    svbi->service_set = (__u16 )((int )svbi->service_set | ((int )svbi->service_lines[0][i] | (int )svbi->service_lines[1][i]));
#line 163
    i = i + 1;
    ldv_53253: ;
#line 163
    if (i <= 21) {
#line 165
      goto ldv_53252;
    } else {

    }

  }
#line 172
  return (0);
}
}
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
int cx18_av_s_raw_fmt(struct v4l2_subdev *sd , struct v4l2_vbi_format *fmt ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;

  {
#line 177
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 177
  cx = (struct cx18 *)tmp;
#line 178
  state = & cx->av_state;
#line 181
  cx18_av_std_setup(cx);
#line 184
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 185
  cx18_av_write(cx, 1028, 46);
#line 186
  return (0);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
int cx18_av_s_sliced_fmt(struct v4l2_subdev *sd , struct v4l2_sliced_vbi_format *svbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  int is_pal ;
  int i ;
  int x ;
  u8 lcr[24U] ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
#line 191
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 191
  cx = (struct cx18 *)tmp;
#line 192
  state = & cx->av_state;
#line 193
  is_pal = (state->std & 63744ULL) == 0ULL;
#line 197
  x = 0;
#line 197
  goto ldv_53272;
  ldv_53271: 
#line 198
  lcr[x] = 0U;
#line 197
  x = x + 1;
  ldv_53272: ;
#line 197
  if (x <= 23) {
#line 199
    goto ldv_53271;
  } else {

  }
#line 201
  cx18_av_std_setup(cx);
#line 204
  cx18_av_write(cx, 1028, 50);
#line 205
  cx18_av_write(cx, 1030, 19);
#line 206
  cx18_av_write(cx, 1151, (int )((u8 )state->slicer_line_delay));
#line 209
  if (is_pal != 0) {
#line 210
    i = 0;
#line 210
    goto ldv_53275;
    ldv_53274: 
#line 211
    tmp___0 = 0U;
#line 211
    svbi->service_lines[1][i] = tmp___0;
#line 211
    svbi->service_lines[0][i] = tmp___0;
#line 210
    i = i + 1;
    ldv_53275: ;
#line 210
    if (i <= 6) {
#line 212
      goto ldv_53274;
    } else {

    }

  } else {
#line 214
    i = 0;
#line 214
    goto ldv_53278;
    ldv_53277: 
#line 215
    tmp___1 = 0U;
#line 215
    svbi->service_lines[1][i] = tmp___1;
#line 215
    svbi->service_lines[0][i] = tmp___1;
#line 214
    i = i + 1;
    ldv_53278: ;
#line 214
    if (i <= 9) {
#line 216
      goto ldv_53277;
    } else {

    }
#line 218
    i = 22;
#line 218
    goto ldv_53281;
    ldv_53280: 
#line 219
    tmp___2 = 0U;
#line 219
    svbi->service_lines[1][i] = tmp___2;
#line 219
    svbi->service_lines[0][i] = tmp___2;
#line 218
    i = i + 1;
    ldv_53281: ;
#line 218
    if (i <= 23) {
#line 220
      goto ldv_53280;
    } else {

    }

  }
#line 224
  i = 7;
#line 224
  goto ldv_53292;
  ldv_53291: 
#line 225
  x = 0;
#line 225
  goto ldv_53289;
  ldv_53288: ;
#line 226
  switch ((int )svbi->service_lines[1 - x][i]) {
  case 1: 
#line 228
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(1 << x * 4)));
#line 229
  goto ldv_53284;
  case 16384: 
#line 231
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(4 << x * 4)));
#line 232
  goto ldv_53284;
  case 4096: 
#line 234
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(6 << x * 4)));
#line 235
  goto ldv_53284;
  case 1024: 
#line 237
  lcr[i] = (u8 )((int )((signed char )lcr[i]) | (int )((signed char )(9 << x * 4)));
#line 238
  goto ldv_53284;
  }
  ldv_53284: 
#line 225
  x = x + 1;
  ldv_53289: ;
#line 225
  if (x <= 1) {
#line 227
    goto ldv_53288;
  } else {

  }
#line 224
  i = i + 1;
  ldv_53292: ;
#line 224
  if (i <= 23) {
#line 226
    goto ldv_53291;
  } else {

  }

#line 243
  if (is_pal != 0) {
#line 244
    x = 1;
#line 244
    i = 1060;
#line 244
    goto ldv_53295;
    ldv_53294: 
#line 245
    cx18_av_write(cx, (int )((u16 )i), (int )lcr[x + 6]);
#line 244
    i = i + 1;
#line 244
    x = x + 1;
    ldv_53295: ;
#line 244
    if (i <= 1076) {
#line 246
      goto ldv_53294;
    } else {

    }

  } else {
#line 247
    x = 1;
#line 247
    i = 1060;
#line 247
    goto ldv_53298;
    ldv_53297: 
#line 248
    cx18_av_write(cx, (int )((u16 )i), (int )lcr[x + 9]);
#line 247
    i = i + 1;
#line 247
    x = x + 1;
    ldv_53298: ;
#line 247
    if (i <= 1072) {
#line 249
      goto ldv_53297;
    } else {

    }
#line 249
    i = 1073;
#line 249
    goto ldv_53301;
    ldv_53300: 
#line 250
    cx18_av_write(cx, (int )((u16 )i), 0);
#line 249
    i = i + 1;
    ldv_53301: ;
#line 249
    if (i <= 1076) {
#line 251
      goto ldv_53300;
    } else {

    }

  }
#line 253
  cx18_av_write(cx, 1084, 22);
#line 255
  cx18_av_write(cx, 1140, is_pal != 0 ? 38 : 26);
#line 256
  return (0);
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.c"
int cx18_av_decode_vbi_line(struct v4l2_subdev *sd , struct v4l2_decode_vbi_line *vbi ) 
{ 
  struct cx18 *cx ;
  void *tmp ;
  struct cx18_av_state *state ;
  struct vbi_anc_data *anc ;
  u8 *p ;
  int did ;
  int sdid ;
  int l ;
  int err ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 262
  tmp = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 262
  cx = (struct cx18 *)tmp;
#line 263
  state = & cx->av_state;
#line 264
  anc = (struct vbi_anc_data *)vbi->p;
#line 266
  err = 0;
#line 271
  if ((((unsigned int )anc->preamble[0] != 0U || (unsigned int )anc->preamble[1] != 255U) || (unsigned int )anc->preamble[2] != 255U) || ((int )anc->did != (int )((unsigned char )sliced_vbi_did[0]) && (int )anc->did != (int )((unsigned char )sliced_vbi_did[1]))) {
#line 275
    tmp___0 = 0U;
#line 275
    vbi->type = tmp___0;
#line 275
    vbi->line = tmp___0;
#line 276
    return (0);
  } else {

  }
#line 279
  did = (int )anc->did;
#line 280
  sdid = (int )anc->sdid & 15;
#line 281
  l = (int )anc->idid[0] & 63;
#line 282
  l = state->slicer_line_offset + l;
#line 283
  p = (u8 *)(& anc->payload);
#line 286
  switch (sdid) {
  case 1: 
#line 288
  sdid = 1;
#line 289
  goto ldv_53316;
  case 4: 
#line 291
  sdid = 16384;
#line 292
  goto ldv_53316;
  case 6: 
#line 294
  sdid = 4096;
#line 295
  tmp___1 = odd_parity((int )*p);
#line 295
  if (tmp___1 == 0) {
#line 295
    tmp___3 = 1;
  } else {
#line 295
    tmp___2 = odd_parity((int )*(p + 1UL));
#line 295
    if (tmp___2 == 0) {
#line 295
      tmp___3 = 1;
    } else {
#line 295
      tmp___3 = 0;
    }
  }
#line 295
  err = tmp___3;
#line 296
  goto ldv_53316;
  case 9: 
#line 298
  sdid = 1024;
#line 299
  tmp___4 = decode_vps(p, p);
#line 299
  if (tmp___4 != 0) {
#line 300
    err = 1;
  } else {

  }
#line 301
  goto ldv_53316;
  default: 
#line 303
  sdid = 0;
#line 304
  err = 1;
#line 305
  goto ldv_53316;
  }
  ldv_53316: 
#line 308
  vbi->type = err == 0 ? (u32 )sdid : 0U;
#line 309
  vbi->line = err == 0 ? (u32 )l : 0U;
#line 310
  vbi->is_second_field = (u32 )(err == 0 && (int )sliced_vbi_did[1] == did);
#line 311
  vbi->p = p;
#line 312
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
bool ldv_queue_work_on_727(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_728(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
bool ldv_queue_work_on_729(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_flush_workqueue_730(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_731(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_732(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_unlock_733(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_unlock_734(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_735(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_736(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
int ldv_mutex_trylock_737(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_unlock_738(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_739(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_unlock_740(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_lock_741(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-av-vbi.o.c.prepared"
void ldv_mutex_unlock_742(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_773(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_769(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_770(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_774(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_776(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_778(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_768(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_771(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_772(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_775(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_777(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) ;
#line 147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
void cx18_memset_io(struct cx18 *cx , void *addr , int val , size_t count ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.c"
void cx18_init_scb(struct cx18 *cx ) 
{ 


  {
#line 29
  cx18_setup_page(cx, 14417920U);
#line 30
  cx18_memset_io(cx, (void *)cx->scb, 0, 65536UL);
#line 32
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->apu2cpu_irq));
#line 33
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->cpu2apu_irq_ack));
#line 34
  cx18_writel(cx, 2U, (void *)(& (cx->scb)->hpu2cpu_irq));
#line 35
  cx18_writel(cx, 2U, (void *)(& (cx->scb)->cpu2hpu_irq_ack));
#line 36
  cx18_writel(cx, 4U, (void *)(& (cx->scb)->ppu2cpu_irq));
#line 37
  cx18_writel(cx, 4U, (void *)(& (cx->scb)->cpu2ppu_irq_ack));
#line 38
  cx18_writel(cx, 8U, (void *)(& (cx->scb)->epu2cpu_irq));
#line 39
  cx18_writel(cx, 8U, (void *)(& (cx->scb)->cpu2epu_irq_ack));
#line 41
  cx18_writel(cx, 16U, (void *)(& (cx->scb)->cpu2apu_irq));
#line 42
  cx18_writel(cx, 16U, (void *)(& (cx->scb)->apu2cpu_irq_ack));
#line 43
  cx18_writel(cx, 32U, (void *)(& (cx->scb)->hpu2apu_irq));
#line 44
  cx18_writel(cx, 32U, (void *)(& (cx->scb)->apu2hpu_irq_ack));
#line 45
  cx18_writel(cx, 64U, (void *)(& (cx->scb)->ppu2apu_irq));
#line 46
  cx18_writel(cx, 64U, (void *)(& (cx->scb)->apu2ppu_irq_ack));
#line 47
  cx18_writel(cx, 128U, (void *)(& (cx->scb)->epu2apu_irq));
#line 48
  cx18_writel(cx, 128U, (void *)(& (cx->scb)->apu2epu_irq_ack));
#line 50
  cx18_writel(cx, 256U, (void *)(& (cx->scb)->cpu2hpu_irq));
#line 51
  cx18_writel(cx, 256U, (void *)(& (cx->scb)->hpu2cpu_irq_ack));
#line 52
  cx18_writel(cx, 512U, (void *)(& (cx->scb)->apu2hpu_irq));
#line 53
  cx18_writel(cx, 512U, (void *)(& (cx->scb)->hpu2apu_irq_ack));
#line 54
  cx18_writel(cx, 1024U, (void *)(& (cx->scb)->ppu2hpu_irq));
#line 55
  cx18_writel(cx, 1024U, (void *)(& (cx->scb)->hpu2ppu_irq_ack));
#line 56
  cx18_writel(cx, 2048U, (void *)(& (cx->scb)->epu2hpu_irq));
#line 57
  cx18_writel(cx, 2048U, (void *)(& (cx->scb)->hpu2epu_irq_ack));
#line 59
  cx18_writel(cx, 4096U, (void *)(& (cx->scb)->cpu2ppu_irq));
#line 60
  cx18_writel(cx, 4096U, (void *)(& (cx->scb)->ppu2cpu_irq_ack));
#line 61
  cx18_writel(cx, 8192U, (void *)(& (cx->scb)->apu2ppu_irq));
#line 62
  cx18_writel(cx, 8192U, (void *)(& (cx->scb)->ppu2apu_irq_ack));
#line 63
  cx18_writel(cx, 16384U, (void *)(& (cx->scb)->hpu2ppu_irq));
#line 64
  cx18_writel(cx, 16384U, (void *)(& (cx->scb)->ppu2hpu_irq_ack));
#line 65
  cx18_writel(cx, 32768U, (void *)(& (cx->scb)->epu2ppu_irq));
#line 66
  cx18_writel(cx, 32768U, (void *)(& (cx->scb)->ppu2epu_irq_ack));
#line 68
  cx18_writel(cx, 65536U, (void *)(& (cx->scb)->cpu2epu_irq));
#line 69
  cx18_writel(cx, 65536U, (void *)(& (cx->scb)->epu2cpu_irq_ack));
#line 70
  cx18_writel(cx, 131072U, (void *)(& (cx->scb)->apu2epu_irq));
#line 71
  cx18_writel(cx, 131072U, (void *)(& (cx->scb)->epu2apu_irq_ack));
#line 72
  cx18_writel(cx, 262144U, (void *)(& (cx->scb)->hpu2epu_irq));
#line 73
  cx18_writel(cx, 262144U, (void *)(& (cx->scb)->epu2hpu_irq_ack));
#line 74
  cx18_writel(cx, 524288U, (void *)(& (cx->scb)->ppu2epu_irq));
#line 75
  cx18_writel(cx, 524288U, (void *)(& (cx->scb)->epu2ppu_irq_ack));
#line 77
  cx18_writel(cx, 14419776U, (void *)(& (cx->scb)->apu2cpu_mb_offset));
#line 79
  cx18_writel(cx, 14419840U, (void *)(& (cx->scb)->hpu2cpu_mb_offset));
#line 81
  cx18_writel(cx, 14419904U, (void *)(& (cx->scb)->ppu2cpu_mb_offset));
#line 83
  cx18_writel(cx, 14419968U, (void *)(& (cx->scb)->epu2cpu_mb_offset));
#line 85
  cx18_writel(cx, 14420032U, (void *)(& (cx->scb)->cpu2apu_mb_offset));
#line 87
  cx18_writel(cx, 14420096U, (void *)(& (cx->scb)->hpu2apu_mb_offset));
#line 89
  cx18_writel(cx, 14420160U, (void *)(& (cx->scb)->ppu2apu_mb_offset));
#line 91
  cx18_writel(cx, 14420224U, (void *)(& (cx->scb)->epu2apu_mb_offset));
#line 93
  cx18_writel(cx, 14420288U, (void *)(& (cx->scb)->cpu2hpu_mb_offset));
#line 95
  cx18_writel(cx, 14420352U, (void *)(& (cx->scb)->apu2hpu_mb_offset));
#line 97
  cx18_writel(cx, 14420416U, (void *)(& (cx->scb)->ppu2hpu_mb_offset));
#line 99
  cx18_writel(cx, 14420480U, (void *)(& (cx->scb)->epu2hpu_mb_offset));
#line 101
  cx18_writel(cx, 14420544U, (void *)(& (cx->scb)->cpu2ppu_mb_offset));
#line 103
  cx18_writel(cx, 14420608U, (void *)(& (cx->scb)->apu2ppu_mb_offset));
#line 105
  cx18_writel(cx, 14420672U, (void *)(& (cx->scb)->hpu2ppu_mb_offset));
#line 107
  cx18_writel(cx, 14420736U, (void *)(& (cx->scb)->epu2ppu_mb_offset));
#line 109
  cx18_writel(cx, 14420800U, (void *)(& (cx->scb)->cpu2epu_mb_offset));
#line 111
  cx18_writel(cx, 14420864U, (void *)(& (cx->scb)->apu2epu_mb_offset));
#line 113
  cx18_writel(cx, 14420928U, (void *)(& (cx->scb)->hpu2epu_mb_offset));
#line 115
  cx18_writel(cx, 14420992U, (void *)(& (cx->scb)->ppu2epu_mb_offset));
#line 118
  cx18_writel(cx, 14418016U, (void *)(& (cx->scb)->ipc_offset));
#line 121
  cx18_writel(cx, 1U, (void *)(& (cx->scb)->epu_state));
#line 122
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_768(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_unlock_769(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_unlock_770(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_771(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_772(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
int ldv_mutex_trylock_773(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_unlock_774(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_775(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_unlock_776(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_lock_777(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-scb.o.c.prepared"
void ldv_mutex_unlock_778(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_809(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_805(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_806(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_810(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_812(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_814(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_816(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_819(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_820(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_823(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_824(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_804(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_807(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_808(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_811(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_813(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_815(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_817(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_818(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_821(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_822(struct mutex *ldv_func_arg1 ) ;
#line 62
void ldv_mutex_lock_feedlock_of_cx18_dvb(struct mutex *lock ) ;
#line 66
void ldv_mutex_unlock_feedlock_of_cx18_dvb(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_799(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_801(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_800(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_803(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_802(struct workqueue_struct *ldv_func_arg1 ) ;
#line 196 "include/linux/module.h"
extern void *__symbol_get(char const   * ) ;
#line 492
extern void __symbol_put(char const   * ) ;
#line 113 "drivers/media/dvb-core/dvbdev.h"
extern int dvb_register_adapter(struct dvb_adapter * , char const   * , struct module * ,
                                struct device * , short * ) ;
#line 116
extern int dvb_unregister_adapter(struct dvb_adapter * ) ;
#line 116 "drivers/media/dvb-core/dmxdev.h"
extern int dvb_dmxdev_init(struct dmxdev * , struct dvb_adapter * ) ;
#line 117
extern void dvb_dmxdev_release(struct dmxdev * ) ;
#line 141 "drivers/media/dvb-core/dvb_demux.h"
extern int dvb_dmx_init(struct dvb_demux * ) ;
#line 142
extern void dvb_dmx_release(struct dvb_demux * ) ;
#line 433 "drivers/media/dvb-core/dvb_frontend.h"
extern int dvb_register_frontend(struct dvb_adapter * , struct dvb_frontend * ) ;
#line 436
extern int dvb_unregister_frontend(struct dvb_frontend * ) ;
#line 438
extern void dvb_frontend_detach(struct dvb_frontend * ) ;
#line 46 "drivers/media/dvb-core/dvb_net.h"
extern void dvb_net_release(struct dvb_net * ) ;
#line 47
extern int dvb_net_init(struct dvb_adapter * , struct dvb_net * , struct dmx_demux * ) ;
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel___7(struct cx18 *cx , u32 val , void *addr ) 
{ 
  int i ;
  u32 tmp ;

  {
#line 74
  i = 0;
#line 74
  goto ldv_53295;
  ldv_53294: 
#line 75
  cx18_writel_noretry(cx, val, addr);
#line 76
  tmp = cx18_readl(cx, (void const   *)addr);
#line 76
  if (tmp == val) {
#line 77
    goto ldv_53293;
  } else {

  }
#line 74
  i = i + 1;
  ldv_53295: ;
#line 74
  if (i <= 9) {
#line 76
    goto ldv_53294;
  } else {

  }
  ldv_53293: ;
#line 81
  return;
}
}
#line 82 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writel_expect___7(struct cx18 *cx , u32 val , void *addr ,
                                            u32 eval , u32 mask ) 
{ 
  int i ;
  u32 r ;

  {
#line 87
  eval = eval & mask;
#line 88
  i = 0;
#line 88
  goto ldv_53308;
  ldv_53307: 
#line 89
  cx18_writel_noretry(cx, val, addr);
#line 90
  r = cx18_readl(cx, (void const   *)addr);
#line 91
  if (r == 4294967295U && eval != 4294967295U) {
#line 92
    goto ldv_53305;
  } else {

  }
#line 93
  if ((r & mask) == eval) {
#line 94
    goto ldv_53306;
  } else {

  }
  ldv_53305: 
#line 88
  i = i + 1;
  ldv_53308: ;
#line 88
  if (i <= 9) {
#line 90
    goto ldv_53307;
  } else {

  }
  ldv_53306: ;
#line 95
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg___3(struct cx18 *cx , u32 val , u32 reg ) 
{ 


  {
#line 158
  cx18_writel___7(cx, val, cx->reg_mem + (unsigned long )reg);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_write_reg_expect___7(struct cx18 *cx , u32 val , u32 reg ,
                                               u32 eval , u32 mask ) 
{ 


  {
#line 164
  cx18_writel_expect___7(cx, val, cx->reg_mem + (unsigned long )reg, eval, mask);
#line 165
  return;
}
}
#line 66 "drivers/media/dvb-frontends/mt352.h"
__inline static int mt352_write(struct dvb_frontend *fe , u8 const   *buf , int len ) 
{ 
  int r ;

  {
#line 67
  r = 0;
#line 68
  if ((unsigned long )fe->ops.write != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                 u8 const   * , int  ))0)) {
#line 69
    r = (*(fe->ops.write))(fe, buf, len);
  } else {

  }
#line 70
  return (r);
}
}
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static short adapter_nr[8U]  = 
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct mxl5005s_config hauppauge_hvr1600_tuner  = 
#line 54
     {99U, 5380000U, 16000000U, 1U, 3U, 1U, 1U, 1U, 0U, 200U, 252U, 1U, 0U, 2U, 0U};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct s5h1409_config hauppauge_hvr1600_config  = 
#line 72
     {25U, 1U, 1U, 44000U, 0U, 1U, 1U, 1U};
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct s5h1411_config hcw_s5h1411_config  =    {1U, 0U, 1U, 4000U, 44000U, 1U, 1U};
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct tda18271_std_map hauppauge_tda18271_std_map  = 
#line 96
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {5380U, 3U, 3U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {4000U, 3U, 0U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct tda18271_config hauppauge_tda18271_config  = 
#line 103
     {& hauppauge_tda18271_std_map, 0, 2, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct zl10353_config leadtek_dvr3100h_demod  = 
#line 113
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static int yuan_mpc718_mt352_reqfw(struct cx18_stream *stream , struct firmware  const  **fw ) 
{ 
  struct cx18 *cx ;
  char const   *fn ;
  int ret ;
  size_t sz ;

  {
#line 139
  cx = stream->cx;
#line 140
  fn = "dvb-cx18-mpc718-mt352.fw";
#line 143
  ret = request_firmware(fw, fn, & (cx->pci_dev)->dev);
#line 144
  if (ret != 0) {
#line 145
    printk("\v%s: Unable to open firmware file %s\n", (char *)(& cx->v4l2_dev.name),
           fn);
  } else {
#line 147
    sz = (*fw)->size;
#line 148
    if ((sz <= 1UL || sz > 64UL) || (int )sz & 1) {
#line 149
      printk("\v%s: Firmware %s has a bad size: %lu bytes\n", (char *)(& cx->v4l2_dev.name),
             fn, sz);
#line 151
      ret = -84;
#line 152
      release_firmware(*fw);
#line 153
      *fw = (struct firmware  const  *)0;
    } else {

    }
  }
#line 157
  if (ret != 0) {
#line 158
    printk("\v%s: The MPC718 board variant with the MT352 DVB-Tdemodualtor will not work without it\n",
           (char *)(& cx->v4l2_dev.name));
#line 160
    printk("\v%s: Run \'linux/Documentation/dvb/get_dvb_firmware mpc718\' if you need the firmware\n",
           (char *)(& cx->v4l2_dev.name));
  } else {

  }
#line 163
  return (ret);
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static int yuan_mpc718_mt352_init(struct dvb_frontend *fe ) 
{ 
  struct cx18_dvb *dvb ;
  struct dvb_adapter  const  *__mptr ;
  struct cx18_stream *stream ;
  struct firmware  const  *fw ;
  int ret ;
  int i ;
  u8 buf[3U] ;

  {
#line 168
  __mptr = (struct dvb_adapter  const  *)fe->dvb;
#line 168
  dvb = (struct cx18_dvb *)__mptr + 0xfffffffffffffde0UL;
#line 170
  stream = dvb->stream;
#line 171
  fw = (struct firmware  const  *)0;
#line 176
  ret = yuan_mpc718_mt352_reqfw(stream, & fw);
#line 177
  if (ret != 0) {
#line 178
    return (ret);
  } else {

  }
#line 181
  i = 0;
#line 181
  goto ldv_53896;
  ldv_53895: 
#line 182
  buf[0] = *(fw->data + (unsigned long )i);
#line 184
  switch ((int )buf[0]) {
  case 85: ;
#line 187
  goto ldv_53890;
  case 84: 
#line 192
  buf[1] = 114U;
#line 193
  buf[2] = 73U;
#line 194
  mt352_write(fe, (u8 const   *)(& buf), 3);
#line 195
  goto ldv_53890;
  case 87: ;
#line 198
  goto ldv_53890;
  case 86: 
#line 201
  buf[1] = 49U;
#line 202
  buf[2] = 192U;
#line 203
  mt352_write(fe, (u8 const   *)(& buf), 3);
#line 204
  goto ldv_53890;
  default: 
#line 207
  buf[1] = *(fw->data + ((unsigned long )i + 1UL));
#line 208
  mt352_write(fe, (u8 const   *)(& buf), 2);
#line 209
  goto ldv_53890;
  }
  ldv_53890: 
#line 181
  i = i + 2;
  ldv_53896: ;
#line 181
  if ((unsigned long )i < (unsigned long )fw->size) {
#line 183
    goto ldv_53895;
  } else {

  }
#line 213
  buf[0] = 93U;
#line 214
  buf[1] = 1U;
#line 215
  mt352_write(fe, (u8 const   *)(& buf), 2);
#line 216
  release_firmware(fw);
#line 217
  return (0);
}
}
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct mt352_config yuan_mpc718_mt352_demod  =    {15U, 20480, 4560, 1, & yuan_mpc718_mt352_init};
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct zl10353_config yuan_mpc718_zl10353_demod  = 
#line 228
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static struct zl10353_config gotview_dvd3_zl10353_demod  = 
#line 236
     {15U, 0, 45600, 1, 1, 1U, (unsigned char)0, (unsigned char)0};
#line 244
static int dvb_register(struct cx18_stream *stream ) ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static int cx18_dvb_start_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct cx18_stream *stream ;
  struct cx18 *cx ;
  int ret ;
  u32 v ;
  int tmp ;

  {
#line 252
  demux = feed->demux;
#line 253
  stream = (struct cx18_stream *)demux->priv;
#line 258
  if ((unsigned long )stream == (unsigned long )((struct cx18_stream *)0)) {
#line 259
    return (-22);
  } else {

  }
#line 261
  cx = stream->cx;
#line 262
  if ((cx18_debug & 2) != 0) {
#line 262
    printk("\016%s:  info: Start feed: pid = 0x%x index = %d\n", (char *)(& cx->v4l2_dev.name),
           (int )feed->pid, feed->index);
  } else {

  }
#line 265
  ldv_mutex_lock_815(& cx->serialize_lock);
#line 266
  ret = cx18_init_on_first_open(cx);
#line 267
  ldv_mutex_unlock_816(& cx->serialize_lock);
#line 268
  if (ret != 0) {
#line 269
    printk("\v%s: Failed to initialize firmware starting DVB feed\n", (char *)(& cx->v4l2_dev.name));
#line 270
    return (ret);
  } else {

  }
#line 272
  ret = -22;
#line 274
  switch ((cx->card)->type) {
  case 0: ;
  case 1: ;
  case 9: 
#line 278
  v = cx18_read_reg(cx, 14000128U);
#line 279
  v = v | 4194304U;
#line 280
  v = v | 8192U;
#line 281
  v = v | 65536U;
#line 282
  v = v | 131072U;
#line 283
  v = v | 786432U;
#line 284
  cx18_write_reg___3(cx, v, 14000128U);
#line 285
  goto ldv_53914;
  case 7: ;
  case 3: ;
  case 8: ;
  default: ;
#line 294
  goto ldv_53914;
  }
  ldv_53914: ;
#line 297
  if ((unsigned long )demux->dmx.frontend == (unsigned long )((struct dmx_frontend *)0)) {
#line 298
    return (-22);
  } else {

  }
#line 300
  ldv_mutex_lock_817(& (stream->dvb)->feedlock);
#line 301
  tmp = (stream->dvb)->feeding;
#line 301
  (stream->dvb)->feeding = (stream->dvb)->feeding + 1;
#line 301
  if (tmp == 0) {
#line 302
    if ((cx18_debug & 2) != 0) {
#line 302
      printk("\016%s:  info: Starting Transport DMA\n", (char *)(& cx->v4l2_dev.name));
    } else {

    }
#line 303
    ldv_mutex_lock_818(& cx->serialize_lock);
#line 304
    set_bit(4L, (unsigned long volatile   *)(& stream->s_flags));
#line 305
    ret = cx18_start_v4l2_encode_stream(stream);
#line 306
    if (ret < 0) {
#line 307
      if ((cx18_debug & 2) != 0) {
#line 307
        printk("\016%s:  info: Failed to start Transport DMA\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 308
      (stream->dvb)->feeding = (stream->dvb)->feeding - 1;
#line 309
      if ((stream->dvb)->feeding == 0) {
#line 310
        clear_bit(4L, (unsigned long volatile   *)(& stream->s_flags));
      } else {

      }
    } else {

    }
#line 312
    ldv_mutex_unlock_819(& cx->serialize_lock);
  } else {
#line 314
    ret = 0;
  }
#line 315
  ldv_mutex_unlock_820(& (stream->dvb)->feedlock);
#line 317
  return (ret);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static int cx18_dvb_stop_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct cx18_stream *stream ;
  struct cx18 *cx ;
  int ret ;

  {
#line 323
  demux = feed->demux;
#line 324
  stream = (struct cx18_stream *)demux->priv;
#line 326
  ret = -22;
#line 328
  if ((unsigned long )stream != (unsigned long )((struct cx18_stream *)0)) {
#line 329
    cx = stream->cx;
#line 330
    if ((cx18_debug & 2) != 0) {
#line 330
      printk("\016%s:  info: Stop feed: pid = 0x%x index = %d\n", (char *)(& cx->v4l2_dev.name),
             (int )feed->pid, feed->index);
    } else {

    }
#line 333
    ldv_mutex_lock_821(& (stream->dvb)->feedlock);
#line 334
    (stream->dvb)->feeding = (stream->dvb)->feeding - 1;
#line 334
    if ((stream->dvb)->feeding == 0) {
#line 335
      if ((cx18_debug & 2) != 0) {
#line 335
        printk("\016%s:  info: Stopping Transport DMA\n", (char *)(& cx->v4l2_dev.name));
      } else {

      }
#line 336
      ldv_mutex_lock_822(& cx->serialize_lock);
#line 337
      ret = cx18_stop_v4l2_encode_stream(stream, 0);
#line 338
      ldv_mutex_unlock_823(& cx->serialize_lock);
    } else {
#line 340
      ret = 0;
    }
#line 341
    ldv_mutex_unlock_824(& (stream->dvb)->feedlock);
  } else {

  }
#line 344
  return (ret);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
int cx18_dvb_register(struct cx18_stream *stream ) 
{ 
  struct cx18 *cx ;
  struct cx18_dvb *dvb ;
  struct dvb_adapter *dvb_adapter ;
  struct dvb_demux *dvbdemux ;
  struct dmx_demux *dmx ;
  int ret ;
  struct lock_class_key __key ;

  {
#line 349
  cx = stream->cx;
#line 350
  dvb = stream->dvb;
#line 356
  if ((unsigned long )dvb == (unsigned long )((struct cx18_dvb *)0)) {
#line 357
    return (-22);
  } else {

  }
#line 359
  dvb->enabled = 0;
#line 360
  dvb->stream = stream;
#line 362
  ret = dvb_register_adapter(& dvb->dvb_adapter, "cx18", & __this_module, & (cx->pci_dev)->dev,
                             (short *)(& adapter_nr));
#line 365
  if (ret < 0) {
#line 366
    goto err_out;
  } else {

  }
#line 368
  dvb_adapter = & dvb->dvb_adapter;
#line 370
  dvbdemux = & dvb->demux;
#line 372
  dvbdemux->priv = (void *)stream;
#line 374
  dvbdemux->filternum = 256;
#line 375
  dvbdemux->feednum = 256;
#line 376
  dvbdemux->start_feed = & cx18_dvb_start_feed;
#line 377
  dvbdemux->stop_feed = & cx18_dvb_stop_feed;
#line 378
  dvbdemux->dmx.capabilities = 13U;
#line 380
  ret = dvb_dmx_init(dvbdemux);
#line 381
  if (ret < 0) {
#line 382
    goto err_dvb_unregister_adapter;
  } else {

  }
#line 384
  dmx = & dvbdemux->dmx;
#line 386
  dvb->hw_frontend.source = 1;
#line 387
  dvb->mem_frontend.source = 0;
#line 388
  dvb->dmxdev.filternum = 256;
#line 389
  dvb->dmxdev.demux = dmx;
#line 391
  ret = dvb_dmxdev_init(& dvb->dmxdev, dvb_adapter);
#line 392
  if (ret < 0) {
#line 393
    goto err_dvb_dmx_release;
  } else {

  }
#line 395
  ret = (*(dmx->add_frontend))(dmx, & dvb->hw_frontend);
#line 396
  if (ret < 0) {
#line 397
    goto err_dvb_dmxdev_release;
  } else {

  }
#line 399
  ret = (*(dmx->add_frontend))(dmx, & dvb->mem_frontend);
#line 400
  if (ret < 0) {
#line 401
    goto err_remove_hw_frontend;
  } else {

  }
#line 403
  ret = (*(dmx->connect_frontend))(dmx, & dvb->hw_frontend);
#line 404
  if (ret < 0) {
#line 405
    goto err_remove_mem_frontend;
  } else {

  }
#line 407
  ret = dvb_register(stream);
#line 408
  if (ret < 0) {
#line 409
    goto err_disconnect_frontend;
  } else {

  }
#line 411
  dvb_net_init(dvb_adapter, & dvb->dvbnet, dmx);
#line 413
  printk("\016%s: DVB Frontend registered\n", (char *)(& cx->v4l2_dev.name));
#line 414
  printk("\016%s: Registered DVB adapter%d for %s (%d x %d.%02d kB)\n", (char *)(& cx->v4l2_dev.name),
         (stream->dvb)->dvb_adapter.num, stream->name, stream->buffers, stream->buf_size / 1024U,
         ((stream->buf_size * 100U) / 1024U) % 100U);
#line 419
  __mutex_init(& dvb->feedlock, "&dvb->feedlock", & __key);
#line 420
  dvb->enabled = 1;
#line 421
  return (ret);
  err_disconnect_frontend: 
#line 424
  (*(dmx->disconnect_frontend))(dmx);
  err_remove_mem_frontend: 
#line 426
  (*(dmx->remove_frontend))(dmx, & dvb->mem_frontend);
  err_remove_hw_frontend: 
#line 428
  (*(dmx->remove_frontend))(dmx, & dvb->hw_frontend);
  err_dvb_dmxdev_release: 
#line 430
  dvb_dmxdev_release(& dvb->dmxdev);
  err_dvb_dmx_release: 
#line 432
  dvb_dmx_release(dvbdemux);
  err_dvb_unregister_adapter: 
#line 434
  dvb_unregister_adapter(dvb_adapter);
  err_out: ;
#line 436
  return (ret);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
void cx18_dvb_unregister(struct cx18_stream *stream ) 
{ 
  struct cx18 *cx ;
  struct cx18_dvb *dvb ;
  struct dvb_adapter *dvb_adapter ;
  struct dvb_demux *dvbdemux ;
  struct dmx_demux *dmx ;

  {
#line 441
  cx = stream->cx;
#line 442
  dvb = stream->dvb;
#line 447
  printk("\016%s: unregister DVB\n", (char *)(& cx->v4l2_dev.name));
#line 449
  if ((unsigned long )dvb == (unsigned long )((struct cx18_dvb *)0) || dvb->enabled == 0) {
#line 450
    return;
  } else {

  }
#line 452
  dvb_adapter = & dvb->dvb_adapter;
#line 453
  dvbdemux = & dvb->demux;
#line 454
  dmx = & dvbdemux->dmx;
#line 456
  (*(dmx->close))(dmx);
#line 457
  dvb_net_release(& dvb->dvbnet);
#line 458
  (*(dmx->remove_frontend))(dmx, & dvb->mem_frontend);
#line 459
  (*(dmx->remove_frontend))(dmx, & dvb->hw_frontend);
#line 460
  dvb_dmxdev_release(& dvb->dmxdev);
#line 461
  dvb_dmx_release(dvbdemux);
#line 462
  dvb_unregister_frontend(dvb->fe);
#line 463
  dvb_frontend_detach(dvb->fe);
#line 464
  dvb_unregister_adapter(dvb_adapter);
#line 465
  return;
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.c"
static int dvb_register(struct cx18_stream *stream ) 
{ 
  struct cx18_dvb *dvb ;
  struct cx18 *cx ;
  int ret ;
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , struct i2c_adapter * , struct mxl5005s_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , struct i2c_adapter * , struct mxl5005s_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;
  void *__r___1 ;
  struct dvb_frontend *(*__a___1)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___10 ;
  struct dvb_frontend *(*tmp___11)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___12 ;
  struct dvb_frontend *tmp___13 ;
  void *__r___2 ;
  struct dvb_frontend *(*__a___2)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___15 ;
  struct dvb_frontend *(*tmp___16)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                   struct tda18271_config * ) ;
  void *tmp___17 ;
  struct dvb_frontend *tmp___18 ;
  void *__r___3 ;
  struct dvb_frontend *(*__a___3)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___20 ;
  struct dvb_frontend *(*tmp___21)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___22 ;
  struct dvb_frontend *tmp___23 ;
  struct dvb_frontend *fe ;
  struct xc2028_config cfg ;
  struct xc2028_ctrl ctrl ;
  void *__r___4 ;
  struct dvb_frontend *(*__a___4)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___25 ;
  struct dvb_frontend *(*tmp___26)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___27 ;
  struct dvb_frontend *tmp___28 ;
  void *__r___5 ;
  struct dvb_frontend *(*__a___5)(struct mt352_config  const  * , struct i2c_adapter * ) ;
  void *tmp___30 ;
  struct dvb_frontend *(*tmp___31)(struct mt352_config  const  * , struct i2c_adapter * ) ;
  void *tmp___32 ;
  struct dvb_frontend *tmp___33 ;
  void *__r___6 ;
  struct dvb_frontend *(*__a___6)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___35 ;
  struct dvb_frontend *(*tmp___36)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___37 ;
  struct dvb_frontend *tmp___38 ;
  struct dvb_frontend *fe___0 ;
  struct xc2028_config cfg___0 ;
  struct xc2028_ctrl ctrl___0 ;
  void *__r___7 ;
  struct dvb_frontend *(*__a___7)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___40 ;
  struct dvb_frontend *(*tmp___41)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___42 ;
  struct dvb_frontend *tmp___43 ;
  void *__r___8 ;
  struct dvb_frontend *(*__a___8)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___45 ;
  struct dvb_frontend *(*tmp___46)(struct zl10353_config  const  * , struct i2c_adapter * ) ;
  void *tmp___47 ;
  struct dvb_frontend *tmp___48 ;
  struct dvb_frontend *fe___1 ;
  struct xc2028_config cfg___1 ;
  struct xc2028_ctrl ctrl___1 ;
  void *__r___9 ;
  struct dvb_frontend *(*__a___9)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___50 ;
  struct dvb_frontend *(*tmp___51)(struct dvb_frontend * , struct xc2028_config * ) ;
  void *tmp___52 ;
  struct dvb_frontend *tmp___53 ;

  {
#line 472
  dvb = stream->dvb;
#line 473
  cx = stream->cx;
#line 474
  ret = 0;
#line 476
  switch ((cx->card)->type) {
  case 0: ;
  case 1: 
#line 479
  __r = (void *)0;
#line 479
  tmp___2 = __symbol_get("s5h1409_attach");
#line 479
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 479
  if (tmp___1) {

  } else {
#line 479
    __request_module(1, "symbol:s5h1409_attach");
#line 479
    tmp___0 = __symbol_get("s5h1409_attach");
#line 479
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1409_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 479
  __a = tmp___1;
#line 479
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 479
    tmp___3 = (*__a)((struct s5h1409_config  const  *)(& hauppauge_hvr1600_config),
                     (struct i2c_adapter *)(& cx->i2c_adap));
#line 479
    __r = (void *)tmp___3;
#line 479
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 479
      __symbol_put("s5h1409_attach");
    } else {

    }
  } else {
#line 479
    printk("\vDVB: Unable to find symbol s5h1409_attach()\n");
  }
#line 479
  dvb->fe = (struct dvb_frontend *)__r;
#line 482
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 483
    __r___0 = (void *)0;
#line 483
    tmp___7 = __symbol_get("mxl5005s_attach");
#line 483
    tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                         struct mxl5005s_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct i2c_adapter * ,
                                                                                                                                           struct mxl5005s_config * ))0);
#line 483
    if (tmp___6) {

    } else {
#line 483
      __request_module(1, "symbol:mxl5005s_attach");
#line 483
      tmp___5 = __symbol_get("mxl5005s_attach");
#line 483
      tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                          struct mxl5005s_config * ))tmp___5;
    }
#line 483
    __a___0 = tmp___6;
#line 483
    if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct i2c_adapter * ,
                                                                              struct mxl5005s_config * ))0)) {
#line 483
      tmp___8 = (*__a___0)(dvb->fe, (struct i2c_adapter *)(& cx->i2c_adap), & hauppauge_hvr1600_tuner);
#line 483
      __r___0 = (void *)tmp___8;
#line 483
      if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 483
        __symbol_put("mxl5005s_attach");
      } else {

      }
    } else {
#line 483
      printk("\vDVB: Unable to find symbol mxl5005s_attach()\n");
    }
#line 486
    ret = 0;
  } else {

  }
#line 488
  goto ldv_53965;
  case 9: 
#line 490
  __r___1 = (void *)0;
#line 490
  tmp___12 = __symbol_get("s5h1411_attach");
#line 490
  tmp___11 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                        struct i2c_adapter * ))tmp___12) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 490
  if (tmp___11) {

  } else {
#line 490
    __request_module(1, "symbol:s5h1411_attach");
#line 490
    tmp___10 = __symbol_get("s5h1411_attach");
#line 490
    tmp___11 = (struct dvb_frontend *(*)(struct s5h1411_config  const  * , struct i2c_adapter * ))tmp___10;
  }
#line 490
  __a___1 = tmp___11;
#line 490
  if ((unsigned long )__a___1 != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 490
    tmp___13 = (*__a___1)((struct s5h1411_config  const  *)(& hcw_s5h1411_config),
                          (struct i2c_adapter *)(& cx->i2c_adap));
#line 490
    __r___1 = (void *)tmp___13;
#line 490
    if ((unsigned long )__r___1 == (unsigned long )((void *)0)) {
#line 490
      __symbol_put("s5h1411_attach");
    } else {

    }
  } else {
#line 490
    printk("\vDVB: Unable to find symbol s5h1411_attach()\n");
  }
#line 490
  dvb->fe = (struct dvb_frontend *)__r___1;
#line 493
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 494
    __r___2 = (void *)0;
#line 494
    tmp___17 = __symbol_get("tda18271_attach");
#line 494
    tmp___16 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          u8  , struct i2c_adapter * ,
                                                          struct tda18271_config * ))tmp___17) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                             u8  ,
                                                                                                                                             struct i2c_adapter * ,
                                                                                                                                             struct tda18271_config * ))0);
#line 494
    if (tmp___16) {

    } else {
#line 494
      __request_module(1, "symbol:tda18271_attach");
#line 494
      tmp___15 = __symbol_get("tda18271_attach");
#line 494
      tmp___16 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                           struct tda18271_config * ))tmp___15;
    }
#line 494
    __a___2 = tmp___16;
#line 494
    if ((unsigned long )__a___2 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              u8  ,
                                                                              struct i2c_adapter * ,
                                                                              struct tda18271_config * ))0)) {
#line 494
      tmp___18 = (*__a___2)(dvb->fe, 96, (struct i2c_adapter *)(& cx->i2c_adap), & hauppauge_tda18271_config);
#line 494
      __r___2 = (void *)tmp___18;
#line 494
      if ((unsigned long )__r___2 == (unsigned long )((void *)0)) {
#line 494
        __symbol_put("tda18271_attach");
      } else {

      }
    } else {
#line 494
      printk("\vDVB: Unable to find symbol tda18271_attach()\n");
    }
  } else {

  }
#line 497
  goto ldv_53965;
  case 7: 
#line 499
  __r___3 = (void *)0;
#line 499
  tmp___22 = __symbol_get("zl10353_attach");
#line 499
  tmp___21 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                        struct i2c_adapter * ))tmp___22) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 499
  if (tmp___21) {

  } else {
#line 499
    __request_module(1, "symbol:zl10353_attach");
#line 499
    tmp___20 = __symbol_get("zl10353_attach");
#line 499
    tmp___21 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___20;
  }
#line 499
  __a___3 = tmp___21;
#line 499
  if ((unsigned long )__a___3 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 499
    tmp___23 = (*__a___3)((struct zl10353_config  const  *)(& leadtek_dvr3100h_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 499
    __r___3 = (void *)tmp___23;
#line 499
    if ((unsigned long )__r___3 == (unsigned long )((void *)0)) {
#line 499
      __symbol_put("zl10353_attach");
    } else {

    }
  } else {
#line 499
    printk("\vDVB: Unable to find symbol zl10353_attach()\n");
  }
#line 499
  dvb->fe = (struct dvb_frontend *)__r___3;
#line 502
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 504
    cfg.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 504
    cfg.i2c_addr = 97U;
#line 504
    cfg.ctrl = (struct xc2028_ctrl *)0;
#line 509
    ctrl.fname = (char *)"xc3028-v27.fw";
#line 509
    ctrl.max_len = 64;
#line 509
    ctrl.msleep = 0;
#line 509
    ctrl.scode_table = 0U;
#line 509
    ctrl.mts = (unsigned char)0;
#line 509
    ctrl.input1 = (unsigned char)0;
#line 509
    ctrl.vhfbw7 = (unsigned char)0;
#line 509
    ctrl.uhfbw8 = (unsigned char)0;
#line 509
    ctrl.disable_power_mgmt = (unsigned char)0;
#line 509
    ctrl.read_not_reliable = (unsigned char)0;
#line 509
    ctrl.demod = 4560U;
#line 509
    ctrl.type = 0U;
#line 516
    __r___4 = (void *)0;
#line 516
    tmp___27 = __symbol_get("xc2028_attach");
#line 516
    tmp___26 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___27) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 516
    if (tmp___26) {

    } else {
#line 516
      __request_module(1, "symbol:xc2028_attach");
#line 516
      tmp___25 = __symbol_get("xc2028_attach");
#line 516
      tmp___26 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___25;
    }
#line 516
    __a___4 = tmp___26;
#line 516
    if ((unsigned long )__a___4 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 516
      tmp___28 = (*__a___4)(dvb->fe, & cfg);
#line 516
      __r___4 = (void *)tmp___28;
#line 516
      if ((unsigned long )__r___4 == (unsigned long )((void *)0)) {
#line 516
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 516
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 516
    fe = (struct dvb_frontend *)__r___4;
#line 517
    if ((unsigned long )fe != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                      void * ))0)) {
#line 518
      (*(fe->ops.tuner_ops.set_config))(fe, (void *)(& ctrl));
    } else {

    }
  } else {

  }
#line 520
  goto ldv_53965;
  case 3: 
#line 527
  __r___5 = (void *)0;
#line 527
  tmp___32 = __symbol_get("mt352_attach");
#line 527
  tmp___31 = (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                        struct i2c_adapter * ))tmp___32) != (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 527
  if (tmp___31) {

  } else {
#line 527
    __request_module(1, "symbol:mt352_attach");
#line 527
    tmp___30 = __symbol_get("mt352_attach");
#line 527
    tmp___31 = (struct dvb_frontend *(*)(struct mt352_config  const  * , struct i2c_adapter * ))tmp___30;
  }
#line 527
  __a___5 = tmp___31;
#line 527
  if ((unsigned long )__a___5 != (unsigned long )((struct dvb_frontend *(*)(struct mt352_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 527
    tmp___33 = (*__a___5)((struct mt352_config  const  *)(& yuan_mpc718_mt352_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 527
    __r___5 = (void *)tmp___33;
#line 527
    if ((unsigned long )__r___5 == (unsigned long )((void *)0)) {
#line 527
      __symbol_put("mt352_attach");
    } else {

    }
  } else {
#line 527
    printk("\vDVB: Unable to find symbol mt352_attach()\n");
  }
#line 527
  dvb->fe = (struct dvb_frontend *)__r___5;
#line 530
  if ((unsigned long )dvb->fe == (unsigned long )((struct dvb_frontend *)0)) {
#line 531
    __r___6 = (void *)0;
#line 531
    tmp___37 = __symbol_get("zl10353_attach");
#line 531
    tmp___36 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                          struct i2c_adapter * ))tmp___37) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                         struct i2c_adapter * ))0);
#line 531
    if (tmp___36) {

    } else {
#line 531
      __request_module(1, "symbol:zl10353_attach");
#line 531
      tmp___35 = __symbol_get("zl10353_attach");
#line 531
      tmp___36 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___35;
    }
#line 531
    __a___6 = tmp___36;
#line 531
    if ((unsigned long )__a___6 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                              struct i2c_adapter * ))0)) {
#line 531
      tmp___38 = (*__a___6)((struct zl10353_config  const  *)(& yuan_mpc718_zl10353_demod),
                            (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 531
      __r___6 = (void *)tmp___38;
#line 531
      if ((unsigned long )__r___6 == (unsigned long )((void *)0)) {
#line 531
        __symbol_put("zl10353_attach");
      } else {

      }
    } else {
#line 531
      printk("\vDVB: Unable to find symbol zl10353_attach()\n");
    }
#line 531
    dvb->fe = (struct dvb_frontend *)__r___6;
  } else {

  }
#line 534
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 536
    cfg___0.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 536
    cfg___0.i2c_addr = 97U;
#line 536
    cfg___0.ctrl = (struct xc2028_ctrl *)0;
#line 541
    ctrl___0.fname = (char *)"xc3028-v27.fw";
#line 541
    ctrl___0.max_len = 64;
#line 541
    ctrl___0.msleep = 0;
#line 541
    ctrl___0.scode_table = 0U;
#line 541
    ctrl___0.mts = (unsigned char)0;
#line 541
    ctrl___0.input1 = (unsigned char)0;
#line 541
    ctrl___0.vhfbw7 = (unsigned char)0;
#line 541
    ctrl___0.uhfbw8 = (unsigned char)0;
#line 541
    ctrl___0.disable_power_mgmt = (unsigned char)0;
#line 541
    ctrl___0.read_not_reliable = (unsigned char)0;
#line 541
    ctrl___0.demod = 4560U;
#line 541
    ctrl___0.type = 0U;
#line 548
    __r___7 = (void *)0;
#line 548
    tmp___42 = __symbol_get("xc2028_attach");
#line 548
    tmp___41 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___42) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 548
    if (tmp___41) {

    } else {
#line 548
      __request_module(1, "symbol:xc2028_attach");
#line 548
      tmp___40 = __symbol_get("xc2028_attach");
#line 548
      tmp___41 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___40;
    }
#line 548
    __a___7 = tmp___41;
#line 548
    if ((unsigned long )__a___7 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 548
      tmp___43 = (*__a___7)(dvb->fe, & cfg___0);
#line 548
      __r___7 = (void *)tmp___43;
#line 548
      if ((unsigned long )__r___7 == (unsigned long )((void *)0)) {
#line 548
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 548
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 548
    fe___0 = (struct dvb_frontend *)__r___7;
#line 549
    if ((unsigned long )fe___0 != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe___0->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                              void * ))0)) {
#line 550
      (*(fe___0->ops.tuner_ops.set_config))(fe___0, (void *)(& ctrl___0));
    } else {

    }
  } else {

  }
#line 552
  goto ldv_53965;
  case 8: 
#line 554
  __r___8 = (void *)0;
#line 554
  tmp___47 = __symbol_get("zl10353_attach");
#line 554
  tmp___46 = (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                        struct i2c_adapter * ))tmp___47) != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 554
  if (tmp___46) {

  } else {
#line 554
    __request_module(1, "symbol:zl10353_attach");
#line 554
    tmp___45 = __symbol_get("zl10353_attach");
#line 554
    tmp___46 = (struct dvb_frontend *(*)(struct zl10353_config  const  * , struct i2c_adapter * ))tmp___45;
  }
#line 554
  __a___8 = tmp___46;
#line 554
  if ((unsigned long )__a___8 != (unsigned long )((struct dvb_frontend *(*)(struct zl10353_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 554
    tmp___48 = (*__a___8)((struct zl10353_config  const  *)(& gotview_dvd3_zl10353_demod),
                          (struct i2c_adapter *)(& cx->i2c_adap) + 1UL);
#line 554
    __r___8 = (void *)tmp___48;
#line 554
    if ((unsigned long )__r___8 == (unsigned long )((void *)0)) {
#line 554
      __symbol_put("zl10353_attach");
    } else {

    }
  } else {
#line 554
    printk("\vDVB: Unable to find symbol zl10353_attach()\n");
  }
#line 554
  dvb->fe = (struct dvb_frontend *)__r___8;
#line 557
  if ((unsigned long )dvb->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 559
    cfg___1.i2c_adap = (struct i2c_adapter *)(& cx->i2c_adap) + 1UL;
#line 559
    cfg___1.i2c_addr = 97U;
#line 559
    cfg___1.ctrl = (struct xc2028_ctrl *)0;
#line 564
    ctrl___1.fname = (char *)"xc3028-v27.fw";
#line 564
    ctrl___1.max_len = 64;
#line 564
    ctrl___1.msleep = 0;
#line 564
    ctrl___1.scode_table = 0U;
#line 564
    ctrl___1.mts = (unsigned char)0;
#line 564
    ctrl___1.input1 = (unsigned char)0;
#line 564
    ctrl___1.vhfbw7 = (unsigned char)0;
#line 564
    ctrl___1.uhfbw8 = (unsigned char)0;
#line 564
    ctrl___1.disable_power_mgmt = (unsigned char)0;
#line 564
    ctrl___1.read_not_reliable = (unsigned char)0;
#line 564
    ctrl___1.demod = 4560U;
#line 564
    ctrl___1.type = 0U;
#line 571
    __r___9 = (void *)0;
#line 571
    tmp___52 = __symbol_get("xc2028_attach");
#line 571
    tmp___51 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          struct xc2028_config * ))tmp___52) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                           struct xc2028_config * ))0);
#line 571
    if (tmp___51) {

    } else {
#line 571
      __request_module(1, "symbol:xc2028_attach");
#line 571
      tmp___50 = __symbol_get("xc2028_attach");
#line 571
      tmp___51 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct xc2028_config * ))tmp___50;
    }
#line 571
    __a___9 = tmp___51;
#line 571
    if ((unsigned long )__a___9 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              struct xc2028_config * ))0)) {
#line 571
      tmp___53 = (*__a___9)(dvb->fe, & cfg___1);
#line 571
      __r___9 = (void *)tmp___53;
#line 571
      if ((unsigned long )__r___9 == (unsigned long )((void *)0)) {
#line 571
        __symbol_put("xc2028_attach");
      } else {

      }
    } else {
#line 571
      printk("\vDVB: Unable to find symbol xc2028_attach()\n");
    }
#line 571
    fe___1 = (struct dvb_frontend *)__r___9;
#line 572
    if ((unsigned long )fe___1 != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe___1->ops.tuner_ops.set_config != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                              void * ))0)) {
#line 573
      (*(fe___1->ops.tuner_ops.set_config))(fe___1, (void *)(& ctrl___1));
    } else {

    }
  } else {

  }
#line 575
  goto ldv_53965;
  default: ;
#line 578
  goto ldv_53965;
  }
  ldv_53965: ;
#line 581
  if ((unsigned long )dvb->fe == (unsigned long )((struct dvb_frontend *)0)) {
#line 582
    printk("\v%s: frontend initialization failed\n", (char *)(& cx->v4l2_dev.name));
#line 583
    return (-1);
  } else {

  }
#line 586
  (dvb->fe)->callback = & cx18_reset_tuner_gpio;
#line 588
  ret = dvb_register_frontend(& dvb->dvb_adapter, dvb->fe);
#line 589
  if (ret < 0) {
#line 590
    if ((unsigned long )(dvb->fe)->ops.release != (unsigned long )((void (*)(struct dvb_frontend * ))0)) {
#line 591
      (*((dvb->fe)->ops.release))(dvb->fe);
    } else {

    }
#line 592
    return (ret);
  } else {

  }
#line 600
  cx18_write_reg_expect___7(cx, 8388736U, 13045796U, 128U, 8388736U);
#line 606
  return (ret);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct dvb_frontend *ldvarg88 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 271
  tmp = ldv_init_zalloc(1304UL);
#line 271
  ldvarg88 = (struct dvb_frontend *)tmp;
#line 273
  tmp___0 = __VERIFIER_nondet_int();
#line 273
  switch (tmp___0) {
  case 0: ;
#line 276
  if (ldv_state_variable_6 == 1) {
#line 278
    yuan_mpc718_mt352_init(ldvarg88);
#line 280
    ldv_state_variable_6 = 1;
  } else {

  }
#line 283
  goto ldv_54013;
  default: 
#line 284
  ldv_stop();
  }
  ldv_54013: ;
#line 288
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
bool ldv_queue_work_on_799(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 317
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 317
  ldv_func_res = tmp;
#line 319
  activate_work_2(ldv_func_arg3, 2);
#line 321
  return (ldv_func_res);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_800(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 328
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 328
  ldv_func_res = tmp;
#line 330
  activate_work_2(& ldv_func_arg3->work, 2);
#line 332
  return (ldv_func_res);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
bool ldv_queue_work_on_801(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 339
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 339
  ldv_func_res = tmp;
#line 341
  activate_work_2(ldv_func_arg3, 2);
#line 343
  return (ldv_func_res);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_flush_workqueue_802(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 349
  flush_workqueue(ldv_func_arg1);
#line 351
  call_and_disable_all_2(2);
#line 352
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_803(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 358
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 358
  ldv_func_res = tmp;
#line 360
  activate_work_2(& ldv_func_arg3->work, 2);
#line 362
  return (ldv_func_res);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_804(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 368
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 370
  mutex_lock(ldv_func_arg1);
#line 371
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_805(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 376
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 378
  mutex_unlock(ldv_func_arg1);
#line 379
  return;
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_806(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 384
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 386
  mutex_unlock(ldv_func_arg1);
#line 387
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_807(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 392
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 394
  mutex_lock(ldv_func_arg1);
#line 395
  return;
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_808(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 400
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 402
  mutex_lock(ldv_func_arg1);
#line 403
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
int ldv_mutex_trylock_809(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 409
  tmp = mutex_trylock(ldv_func_arg1);
#line 409
  ldv_func_res = tmp;
#line 411
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 411
  return (tmp___0);
#line 413
  return (ldv_func_res);
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_810(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 419
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 421
  mutex_unlock(ldv_func_arg1);
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_811(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 427
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 429
  mutex_lock(ldv_func_arg1);
#line 430
  return;
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_812(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 435
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 437
  mutex_unlock(ldv_func_arg1);
#line 438
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_813(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 443
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 445
  mutex_lock(ldv_func_arg1);
#line 446
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_814(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 451
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 453
  mutex_unlock(ldv_func_arg1);
#line 454
  return;
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_815(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 459
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 461
  mutex_lock(ldv_func_arg1);
#line 462
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_816(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 467
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 469
  mutex_unlock(ldv_func_arg1);
#line 470
  return;
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_817(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 475
  ldv_mutex_lock_feedlock_of_cx18_dvb(ldv_func_arg1);
#line 477
  mutex_lock(ldv_func_arg1);
#line 478
  return;
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_818(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_819(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 493
  mutex_unlock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_820(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_unlock_feedlock_of_cx18_dvb(ldv_func_arg1);
#line 501
  mutex_unlock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_821(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 507
  ldv_mutex_lock_feedlock_of_cx18_dvb(ldv_func_arg1);
#line 509
  mutex_lock(ldv_func_arg1);
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_lock_822(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 515
  ldv_mutex_lock_serialize_lock_of_cx18(ldv_func_arg1);
#line 517
  mutex_lock(ldv_func_arg1);
#line 518
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_823(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 523
  ldv_mutex_unlock_serialize_lock_of_cx18(ldv_func_arg1);
#line 525
  mutex_unlock(ldv_func_arg1);
#line 526
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-dvb.o.c.prepared"
void ldv_mutex_unlock_824(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 531
  ldv_mutex_unlock_feedlock_of_cx18_dvb(ldv_func_arg1);
#line 533
  mutex_unlock(ldv_func_arg1);
#line 534
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_865(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_861(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_862(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_866(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_868(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_870(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_860(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_863(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_864(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_867(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_869(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_855(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_857(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_856(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_859(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_858(struct workqueue_struct *ldv_func_arg1 ) ;
#line 56 "./arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 56
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 57 "./arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 57
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
#line 57
  return (ret);
}
}
#line 64 "./arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 65 "./arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
#line 65
  __asm__  volatile   ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
#line 66
  return;
}
}
#line 98 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u16 cx18_readw(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned short tmp ;

  {
#line 100
  tmp = readw((void const volatile   *)addr);
#line 100
  return (tmp);
}
}
#line 104 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writew_noretry(struct cx18 *cx , u16 val , void *addr ) 
{ 


  {
#line 106
  writew((int )val, (void volatile   *)addr);
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writew(struct cx18 *cx , u16 val , void *addr ) 
{ 
  int i ;
  u16 tmp ;

  {
#line 112
  i = 0;
#line 112
  goto ldv_53282;
  ldv_53281: 
#line 113
  cx18_writew_noretry(cx, (int )val, addr);
#line 114
  tmp = cx18_readw(cx, (void const   *)addr);
#line 114
  if ((int )tmp == (int )val) {
#line 115
    goto ldv_53280;
  } else {

  }
#line 112
  i = i + 1;
  ldv_53282: ;
#line 112
  if (i <= 9) {
#line 114
    goto ldv_53281;
  } else {

  }
  ldv_53280: ;
#line 119
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static u8 cx18_readb(struct cx18 *cx , void const   *addr ) 
{ 
  unsigned char tmp ;

  {
#line 121
  tmp = readb((void const volatile   *)addr);
#line 121
  return (tmp);
}
}
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writeb_noretry(struct cx18 *cx , u8 val , void *addr ) 
{ 


  {
#line 127
  writeb((int )val, (void volatile   *)addr);
#line 128
  return;
}
}
#line 130 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/cx18/cx18-io.h"
__inline static void cx18_writeb(struct cx18 *cx , u8 val , void *addr ) 
{ 
  int i ;
  u8 tmp ;

  {
#line 133
  i = 0;
#line 133
  goto ldv_53300;
  ldv_53299: 
#line 134
  cx18_writeb_noretry(cx, (int )val, addr);
#line 135
  tmp = cx18_readb(cx, (void const   *)addr);
#line 135
  if ((int )tmp == (int )val) {
#line 136
    goto ldv_53298;
  } else {

  }
#line 133
  i = i + 1;
  ldv_53300: ;
#line 133
  if (i <= 9) {
#line 135
    goto ldv_53299;
  } else {

  }
  ldv_53298: ;
#line 140
  return;
}
}
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_memset_io(struct cx18 *cx , void *addr , int val , size_t count ) 
{ 
  u8 *dst ;
  u16 val2 ;
  u32 val4 ;

  {
#line 29
  dst = (u8 *)addr;
#line 30
  val2 = (u16 )((int )((short )(val << 8)) | (int )((short )val));
#line 31
  val4 = (u32 )((int )val2 | ((int )val2 << 16));
#line 34
  if (count != 0UL && (int )((unsigned long )dst) & 1) {
#line 35
    cx18_writeb(cx, (int )((unsigned char )val), (void *)dst);
#line 36
    count = count - 1UL;
#line 37
    dst = dst + 1;
  } else {

  }
#line 39
  if (count > 1UL && ((unsigned long )dst & 2UL) != 0UL) {
#line 40
    cx18_writew(cx, (int )val2, (void *)dst);
#line 41
    count = count - 2UL;
#line 42
    dst = dst + 2UL;
  } else {

  }
#line 44
  goto ldv_53373;
  ldv_53372: 
#line 45
  cx18_writel(cx, val4, (void *)dst);
#line 46
  count = count - 4UL;
#line 47
  dst = dst + 4UL;
  ldv_53373: ;
#line 44
  if (count > 3UL) {
#line 46
    goto ldv_53372;
  } else {

  }

#line 49
  if (count > 1UL) {
#line 50
    cx18_writew(cx, (int )val2, (void *)dst);
#line 51
    count = count - 2UL;
#line 52
    dst = dst + 2UL;
  } else {

  }
#line 54
  if (count != 0UL) {
#line 55
    cx18_writeb(cx, (int )((unsigned char )val), (void *)dst);
  } else {

  }
#line 56
  return;
}
}
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_sw1_irq_enable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 60
  cx18_write_reg_expect(cx, val, 13054212U, ~ val, val);
#line 61
  tmp = cx18_read_reg(cx, 13054236U);
#line 61
  cx->sw1_irq_mask = tmp | val;
#line 62
  cx18_write_reg(cx, cx->sw1_irq_mask, 13054236U);
#line 63
  return;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_sw1_irq_disable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 67
  tmp = cx18_read_reg(cx, 13054236U);
#line 67
  cx->sw1_irq_mask = tmp & ~ val;
#line 68
  cx18_write_reg(cx, cx->sw1_irq_mask, 13054236U);
#line 69
  return;
}
}
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_sw2_irq_enable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 73
  cx18_write_reg_expect(cx, val, 13054276U, ~ val, val);
#line 74
  tmp = cx18_read_reg(cx, 13054300U);
#line 74
  cx->sw2_irq_mask = tmp | val;
#line 75
  cx18_write_reg(cx, cx->sw2_irq_mask, 13054300U);
#line 76
  return;
}
}
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_sw2_irq_disable(struct cx18 *cx , u32 val ) 
{ 
  u32 tmp ;

  {
#line 80
  tmp = cx18_read_reg(cx, 13054300U);
#line 80
  cx->sw2_irq_mask = tmp & ~ val;
#line 81
  cx18_write_reg(cx, cx->sw2_irq_mask, 13054300U);
#line 82
  return;
}
}
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_sw2_irq_disable_cpu(struct cx18 *cx , u32 val ) 
{ 
  u32 r ;

  {
#line 87
  r = cx18_read_reg(cx, 13054296U);
#line 88
  cx18_write_reg(cx, ~ val & r, 13054296U);
#line 89
  return;
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.c"
void cx18_setup_page(struct cx18 *cx , u32 addr ) 
{ 
  u32 val ;

  {
#line 94
  val = cx18_read_reg(cx, 13631736U);
#line 95
  val = (val & 4294959359U) | ((addr >> 17) & 7936U);
#line 96
  cx18_write_reg(cx, val, 13631736U);
#line 97
  return;
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
bool ldv_queue_work_on_855(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 297
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 297
  ldv_func_res = tmp;
#line 299
  activate_work_2(ldv_func_arg3, 2);
#line 301
  return (ldv_func_res);
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
bool ldv_queue_delayed_work_on_856(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 308
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 308
  ldv_func_res = tmp;
#line 310
  activate_work_2(& ldv_func_arg3->work, 2);
#line 312
  return (ldv_func_res);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
bool ldv_queue_work_on_857(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 319
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 319
  ldv_func_res = tmp;
#line 321
  activate_work_2(ldv_func_arg3, 2);
#line 323
  return (ldv_func_res);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_flush_workqueue_858(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 329
  flush_workqueue(ldv_func_arg1);
#line 331
  call_and_disable_all_2(2);
#line 332
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
bool ldv_queue_delayed_work_on_859(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 338
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 338
  ldv_func_res = tmp;
#line 340
  activate_work_2(& ldv_func_arg3->work, 2);
#line 342
  return (ldv_func_res);
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_860(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 348
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 350
  mutex_lock(ldv_func_arg1);
#line 351
  return;
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_unlock_861(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 358
  mutex_unlock(ldv_func_arg1);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_unlock_862(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_863(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 372
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 374
  mutex_lock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_864(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 380
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 382
  mutex_lock(ldv_func_arg1);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
int ldv_mutex_trylock_865(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 389
  tmp = mutex_trylock(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 391
  return (tmp___0);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_unlock_866(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 399
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 401
  mutex_unlock(ldv_func_arg1);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_867(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 407
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 409
  mutex_lock(ldv_func_arg1);
#line 410
  return;
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_unlock_868(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 415
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 417
  mutex_unlock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_lock_869(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 423
  ldv_mutex_lock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 425
  mutex_lock(ldv_func_arg1);
#line 426
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/dscv/ri/32_7a/drivers/media/pci/cx18/cx18-io.o.c.prepared"
void ldv_mutex_unlock_870(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 431
  ldv_mutex_unlock_vb_lock_of_videobuf_queue(ldv_func_arg1);
#line 433
  mutex_unlock(ldv_func_arg1);
#line 434
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_feedlock_of_cx18_dvb  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_feedlock_of_cx18_dvb = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_feedlock_of_cx18_dvb = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_feedlock_of_cx18_dvb = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_feedlock_of_cx18_dvb = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_feedlock_of_cx18_dvb(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_feedlock_of_cx18_dvb = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_feedlock_of_cx18_dvb == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_feedlock_of_cx18_dvb(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_feedlock_of_cx18_dvb != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_feedlock_of_cx18_dvb = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_feedlock_of_cx18_dvb(void) 
{ 


  {
#line 166
  ldv_mutex_lock_feedlock_of_cx18_dvb((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_feedlock_of_cx18_dvb(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_feedlock_of_cx18_dvb((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_feedlock_of_cx18_dvb(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_feedlock_of_cx18_dvb((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_feedlock_of_cx18_dvb(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_feedlock_of_cx18_dvb((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_gpio_lock_of_cx18  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_gpio_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_gpio_lock_of_cx18 = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_gpio_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_gpio_lock_of_cx18 = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_gpio_lock_of_cx18(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_gpio_lock_of_cx18 = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_gpio_lock_of_cx18(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_gpio_lock_of_cx18 = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_gpio_lock_of_cx18(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_gpio_lock_of_cx18 = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_gpio_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_gpio_lock_of_cx18 == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_gpio_lock_of_cx18(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_gpio_lock_of_cx18 != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_gpio_lock_of_cx18 = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_gpio_lock_of_cx18(void) 
{ 


  {
#line 352
  ldv_mutex_lock_gpio_lock_of_cx18((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_gpio_lock_of_cx18(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_gpio_lock_of_cx18((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_gpio_lock_of_cx18(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_gpio_lock_of_cx18((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_gpio_lock_of_cx18(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_gpio_lock_of_cx18((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_i_mutex_of_inode = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_i_mutex_of_inode = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_i_mutex_of_inode = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_i_mutex_of_inode = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_i_mutex_of_inode = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_i_mutex_of_inode = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 538
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_lock != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_lock = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_lock != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_lock = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_lock != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_lock = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_lock != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_lock = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_lock != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_lock = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_lock == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_lock != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_lock = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 724
  ldv_mutex_lock_lock((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_lock((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 750
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_v4l2_ctrl_handler  =    1;
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 760
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 760
    ldv_error();
  } else {

  }
#line 763
  nondetermined = ldv_undef_int();
#line 766
  if (nondetermined != 0) {
#line 769
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 771
    return (0);
  } else {
#line 776
    return (-4);
  }
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 786
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 786
    ldv_error();
  } else {

  }
#line 789
  nondetermined = ldv_undef_int();
#line 792
  if (nondetermined != 0) {
#line 795
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 797
    return (0);
  } else {
#line 802
    return (-4);
  }
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 810
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 810
    ldv_error();
  } else {

  }
#line 812
  ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 813
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 821
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 821
    ldv_error();
  } else {

  }
#line 824
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 827
  if (is_mutex_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 835
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 837
    return (1);
  }
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_v4l2_ctrl_handler(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 847
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 847
    ldv_error();
  } else {

  }
#line 850
  atomic_value_after_dec = ldv_undef_int();
#line 853
  if (atomic_value_after_dec == 0) {
#line 856
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 858
    return (1);
  } else {

  }
#line 862
  return (0);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 871
  if (ldv_mutex_lock_of_v4l2_ctrl_handler == 1) {
#line 874
    nondetermined = ldv_undef_int();
#line 877
    if (nondetermined != 0) {
#line 880
      return (0);
    } else {
#line 885
      return (1);
    }
  } else {
#line 891
    return (1);
  }
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 899
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 2) {
#line 899
    ldv_error();
  } else {

  }
#line 901
  ldv_mutex_lock_of_v4l2_ctrl_handler = 1;
#line 902
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 910
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 911
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;

  {
#line 916
  tmp = ldv_mutex_trylock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 916
  return (tmp);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 922
  tmp___0 = ldv_undef_int();
#line 922
  if (tmp___0 != 0) {
#line 924
    ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 926
    return (0);
  } else {
#line 929
    tmp = ldv_undef_int_negative();
#line 929
    return (tmp);
  }
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 935
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 936
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mb_lock  =    1;
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mb_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 946
  if (ldv_mutex_mb_lock != 1) {
#line 946
    ldv_error();
  } else {

  }
#line 949
  nondetermined = ldv_undef_int();
#line 952
  if (nondetermined != 0) {
#line 955
    ldv_mutex_mb_lock = 2;
#line 957
    return (0);
  } else {
#line 962
    return (-4);
  }
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mb_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 972
  if (ldv_mutex_mb_lock != 1) {
#line 972
    ldv_error();
  } else {

  }
#line 975
  nondetermined = ldv_undef_int();
#line 978
  if (nondetermined != 0) {
#line 981
    ldv_mutex_mb_lock = 2;
#line 983
    return (0);
  } else {
#line 988
    return (-4);
  }
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mb_lock(struct mutex *lock ) 
{ 


  {
#line 996
  if (ldv_mutex_mb_lock != 1) {
#line 996
    ldv_error();
  } else {

  }
#line 998
  ldv_mutex_mb_lock = 2;
#line 999
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mb_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1007
  if (ldv_mutex_mb_lock != 1) {
#line 1007
    ldv_error();
  } else {

  }
#line 1010
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1013
  if (is_mutex_held_by_another_thread != 0) {
#line 1016
    return (0);
  } else {
#line 1021
    ldv_mutex_mb_lock = 2;
#line 1023
    return (1);
  }
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mb_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1033
  if (ldv_mutex_mb_lock != 1) {
#line 1033
    ldv_error();
  } else {

  }
#line 1036
  atomic_value_after_dec = ldv_undef_int();
#line 1039
  if (atomic_value_after_dec == 0) {
#line 1042
    ldv_mutex_mb_lock = 2;
#line 1044
    return (1);
  } else {

  }
#line 1048
  return (0);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mb_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1057
  if (ldv_mutex_mb_lock == 1) {
#line 1060
    nondetermined = ldv_undef_int();
#line 1063
    if (nondetermined != 0) {
#line 1066
      return (0);
    } else {
#line 1071
      return (1);
    }
  } else {
#line 1077
    return (1);
  }
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mb_lock(struct mutex *lock ) 
{ 


  {
#line 1085
  if (ldv_mutex_mb_lock != 2) {
#line 1085
    ldv_error();
  } else {

  }
#line 1087
  ldv_mutex_mb_lock = 1;
#line 1088
  return;
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mb_lock(void) 
{ 


  {
#line 1096
  ldv_mutex_lock_mb_lock((struct mutex *)0);
#line 1097
  return;
}
}
#line 1100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mb_lock(void) 
{ 
  int tmp ;

  {
#line 1102
  tmp = ldv_mutex_trylock_mb_lock((struct mutex *)0);
#line 1102
  return (tmp);
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mb_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1108
  tmp___0 = ldv_undef_int();
#line 1108
  if (tmp___0 != 0) {
#line 1110
    ldv_mutex_lock_mb_lock((struct mutex *)0);
#line 1112
    return (0);
  } else {
#line 1115
    tmp = ldv_undef_int_negative();
#line 1115
    return (tmp);
  }
}
}
#line 1119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mb_lock(void) 
{ 


  {
#line 1121
  ldv_mutex_unlock_mb_lock((struct mutex *)0);
#line 1122
  return;
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1132
  if (ldv_mutex_mutex_of_device != 1) {
#line 1132
    ldv_error();
  } else {

  }
#line 1135
  nondetermined = ldv_undef_int();
#line 1138
  if (nondetermined != 0) {
#line 1141
    ldv_mutex_mutex_of_device = 2;
#line 1143
    return (0);
  } else {
#line 1148
    return (-4);
  }
}
}
#line 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1158
  if (ldv_mutex_mutex_of_device != 1) {
#line 1158
    ldv_error();
  } else {

  }
#line 1161
  nondetermined = ldv_undef_int();
#line 1164
  if (nondetermined != 0) {
#line 1167
    ldv_mutex_mutex_of_device = 2;
#line 1169
    return (0);
  } else {
#line 1174
    return (-4);
  }
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1182
  if (ldv_mutex_mutex_of_device != 1) {
#line 1182
    ldv_error();
  } else {

  }
#line 1184
  ldv_mutex_mutex_of_device = 2;
#line 1185
  return;
}
}
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1193
  if (ldv_mutex_mutex_of_device != 1) {
#line 1193
    ldv_error();
  } else {

  }
#line 1196
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1199
  if (is_mutex_held_by_another_thread != 0) {
#line 1202
    return (0);
  } else {
#line 1207
    ldv_mutex_mutex_of_device = 2;
#line 1209
    return (1);
  }
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1219
  if (ldv_mutex_mutex_of_device != 1) {
#line 1219
    ldv_error();
  } else {

  }
#line 1222
  atomic_value_after_dec = ldv_undef_int();
#line 1225
  if (atomic_value_after_dec == 0) {
#line 1228
    ldv_mutex_mutex_of_device = 2;
#line 1230
    return (1);
  } else {

  }
#line 1234
  return (0);
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1243
  if (ldv_mutex_mutex_of_device == 1) {
#line 1246
    nondetermined = ldv_undef_int();
#line 1249
    if (nondetermined != 0) {
#line 1252
      return (0);
    } else {
#line 1257
      return (1);
    }
  } else {
#line 1263
    return (1);
  }
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1271
  if (ldv_mutex_mutex_of_device != 2) {
#line 1271
    ldv_error();
  } else {

  }
#line 1273
  ldv_mutex_mutex_of_device = 1;
#line 1274
  return;
}
}
#line 1279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 1282
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1283
  return;
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 1288
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 1288
  return (tmp);
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1294
  tmp___0 = ldv_undef_int();
#line 1294
  if (tmp___0 != 0) {
#line 1296
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1298
    return (0);
  } else {
#line 1301
    tmp = ldv_undef_int_negative();
#line 1301
    return (tmp);
  }
}
}
#line 1305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 1307
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 1308
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_serialize_lock_of_cx18  =    1;
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_serialize_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1318
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1318
    ldv_error();
  } else {

  }
#line 1321
  nondetermined = ldv_undef_int();
#line 1324
  if (nondetermined != 0) {
#line 1327
    ldv_mutex_serialize_lock_of_cx18 = 2;
#line 1329
    return (0);
  } else {
#line 1334
    return (-4);
  }
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_serialize_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1344
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1344
    ldv_error();
  } else {

  }
#line 1347
  nondetermined = ldv_undef_int();
#line 1350
  if (nondetermined != 0) {
#line 1353
    ldv_mutex_serialize_lock_of_cx18 = 2;
#line 1355
    return (0);
  } else {
#line 1360
    return (-4);
  }
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_serialize_lock_of_cx18(struct mutex *lock ) 
{ 


  {
#line 1368
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1368
    ldv_error();
  } else {

  }
#line 1370
  ldv_mutex_serialize_lock_of_cx18 = 2;
#line 1371
  return;
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_serialize_lock_of_cx18(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1379
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1379
    ldv_error();
  } else {

  }
#line 1382
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1385
  if (is_mutex_held_by_another_thread != 0) {
#line 1388
    return (0);
  } else {
#line 1393
    ldv_mutex_serialize_lock_of_cx18 = 2;
#line 1395
    return (1);
  }
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_serialize_lock_of_cx18(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1405
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1405
    ldv_error();
  } else {

  }
#line 1408
  atomic_value_after_dec = ldv_undef_int();
#line 1411
  if (atomic_value_after_dec == 0) {
#line 1414
    ldv_mutex_serialize_lock_of_cx18 = 2;
#line 1416
    return (1);
  } else {

  }
#line 1420
  return (0);
}
}
#line 1425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_serialize_lock_of_cx18(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1429
  if (ldv_mutex_serialize_lock_of_cx18 == 1) {
#line 1432
    nondetermined = ldv_undef_int();
#line 1435
    if (nondetermined != 0) {
#line 1438
      return (0);
    } else {
#line 1443
      return (1);
    }
  } else {
#line 1449
    return (1);
  }
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_serialize_lock_of_cx18(struct mutex *lock ) 
{ 


  {
#line 1457
  if (ldv_mutex_serialize_lock_of_cx18 != 2) {
#line 1457
    ldv_error();
  } else {

  }
#line 1459
  ldv_mutex_serialize_lock_of_cx18 = 1;
#line 1460
  return;
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_serialize_lock_of_cx18(void) 
{ 


  {
#line 1468
  ldv_mutex_lock_serialize_lock_of_cx18((struct mutex *)0);
#line 1469
  return;
}
}
#line 1472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_serialize_lock_of_cx18(void) 
{ 
  int tmp ;

  {
#line 1474
  tmp = ldv_mutex_trylock_serialize_lock_of_cx18((struct mutex *)0);
#line 1474
  return (tmp);
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_serialize_lock_of_cx18(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1480
  tmp___0 = ldv_undef_int();
#line 1480
  if (tmp___0 != 0) {
#line 1482
    ldv_mutex_lock_serialize_lock_of_cx18((struct mutex *)0);
#line 1484
    return (0);
  } else {
#line 1487
    tmp = ldv_undef_int_negative();
#line 1487
    return (tmp);
  }
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_serialize_lock_of_cx18(void) 
{ 


  {
#line 1493
  ldv_mutex_unlock_serialize_lock_of_cx18((struct mutex *)0);
#line 1494
  return;
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_vb_lock_of_videobuf_queue  =    1;
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1504
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1504
    ldv_error();
  } else {

  }
#line 1507
  nondetermined = ldv_undef_int();
#line 1510
  if (nondetermined != 0) {
#line 1513
    ldv_mutex_vb_lock_of_videobuf_queue = 2;
#line 1515
    return (0);
  } else {
#line 1520
    return (-4);
  }
}
}
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1530
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1530
    ldv_error();
  } else {

  }
#line 1533
  nondetermined = ldv_undef_int();
#line 1536
  if (nondetermined != 0) {
#line 1539
    ldv_mutex_vb_lock_of_videobuf_queue = 2;
#line 1541
    return (0);
  } else {
#line 1546
    return (-4);
  }
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 


  {
#line 1554
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1554
    ldv_error();
  } else {

  }
#line 1556
  ldv_mutex_vb_lock_of_videobuf_queue = 2;
#line 1557
  return;
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1565
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1565
    ldv_error();
  } else {

  }
#line 1568
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1571
  if (is_mutex_held_by_another_thread != 0) {
#line 1574
    return (0);
  } else {
#line 1579
    ldv_mutex_vb_lock_of_videobuf_queue = 2;
#line 1581
    return (1);
  }
}
}
#line 1586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_vb_lock_of_videobuf_queue(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1591
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1591
    ldv_error();
  } else {

  }
#line 1594
  atomic_value_after_dec = ldv_undef_int();
#line 1597
  if (atomic_value_after_dec == 0) {
#line 1600
    ldv_mutex_vb_lock_of_videobuf_queue = 2;
#line 1602
    return (1);
  } else {

  }
#line 1606
  return (0);
}
}
#line 1611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1615
  if (ldv_mutex_vb_lock_of_videobuf_queue == 1) {
#line 1618
    nondetermined = ldv_undef_int();
#line 1621
    if (nondetermined != 0) {
#line 1624
      return (0);
    } else {
#line 1629
      return (1);
    }
  } else {
#line 1635
    return (1);
  }
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_vb_lock_of_videobuf_queue(struct mutex *lock ) 
{ 


  {
#line 1643
  if (ldv_mutex_vb_lock_of_videobuf_queue != 2) {
#line 1643
    ldv_error();
  } else {

  }
#line 1645
  ldv_mutex_vb_lock_of_videobuf_queue = 1;
#line 1646
  return;
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_vb_lock_of_videobuf_queue(void) 
{ 


  {
#line 1654
  ldv_mutex_lock_vb_lock_of_videobuf_queue((struct mutex *)0);
#line 1655
  return;
}
}
#line 1658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_vb_lock_of_videobuf_queue(void) 
{ 
  int tmp ;

  {
#line 1660
  tmp = ldv_mutex_trylock_vb_lock_of_videobuf_queue((struct mutex *)0);
#line 1660
  return (tmp);
}
}
#line 1664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_vb_lock_of_videobuf_queue(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1666
  tmp___0 = ldv_undef_int();
#line 1666
  if (tmp___0 != 0) {
#line 1668
    ldv_mutex_lock_vb_lock_of_videobuf_queue((struct mutex *)0);
#line 1670
    return (0);
  } else {
#line 1673
    tmp = ldv_undef_int_negative();
#line 1673
    return (tmp);
  }
}
}
#line 1677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_vb_lock_of_videobuf_queue(void) 
{ 


  {
#line 1679
  ldv_mutex_unlock_vb_lock_of_videobuf_queue((struct mutex *)0);
#line 1680
  return;
}
}
#line 1684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4228/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 1687
  if (ldv_mutex_feedlock_of_cx18_dvb != 1) {
#line 1687
    ldv_error();
  } else {

  }
#line 1689
  if (ldv_mutex_gpio_lock_of_cx18 != 1) {
#line 1689
    ldv_error();
  } else {

  }
#line 1691
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 1691
    ldv_error();
  } else {

  }
#line 1693
  if (ldv_mutex_lock != 1) {
#line 1693
    ldv_error();
  } else {

  }
#line 1695
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 1695
    ldv_error();
  } else {

  }
#line 1697
  if (ldv_mutex_mb_lock != 1) {
#line 1697
    ldv_error();
  } else {

  }
#line 1699
  if (ldv_mutex_mutex_of_device != 1) {
#line 1699
    ldv_error();
  } else {

  }
#line 1701
  if (ldv_mutex_serialize_lock_of_cx18 != 1) {
#line 1701
    ldv_error();
  } else {

  }
#line 1703
  if (ldv_mutex_vb_lock_of_videobuf_queue != 1) {
#line 1703
    ldv_error();
  } else {

  }
#line 1707
  return;
}
}
