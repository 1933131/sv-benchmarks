extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 90 "include/linux/types.h"
typedef unsigned short ushort;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 599 "include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_channels;
#line 28
struct ethtool_eeprom;
#line 30
struct ethtool_coalesce;
#line 55
struct ethtool_wolinfo;
#line 75
struct ethtool_rxnfc;
#line 77
struct ethtool_pauseparam;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_220 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 35 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1908 "include/linux/pci.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_221 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_221 __annonCompField59 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 217 "./include/uapi/asm-generic/fcntl.h"
enum ldv_22286 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_22286 socket_state;
#line 54
struct poll_table_struct;
#line 55
struct net;
#line 72
struct fasync_struct;
#line 72 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_222 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_222 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_227 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_228 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_227 __annonCompField63 ;
   union __anonunion____missing_field_name_228 __annonCompField64 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 215
struct skb_frag_struct;
#line 215 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 216 "include/linux/skbuff.h"
struct __anonstruct_page_229 {
   struct page *p ;
};
#line 216 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_229 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 249 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 319 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_231 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_230 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_231 __annonCompField65 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_234 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_233 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_234 __annonCompField67 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_232 {
   struct __anonstruct____missing_field_name_233 __annonCompField68 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_236 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_235 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_236 __annonCompField70 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_237 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_238 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_239 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_232 __annonCompField69 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_235 __annonCompField71 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_237 __annonCompField72 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_238 __annonCompField73 ;
   union __anonunion____missing_field_name_239 __annonCompField74 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 767
struct rtable;
#line 890
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
} ;
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_241 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_241 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_242 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_242 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_243 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_243 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_244 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_244 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_245 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_245 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_246 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_246 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_247 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_247 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_248 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_248 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_249 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_250 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_249 ifr_ifrn ;
   union __anonunion_ifr_ifru_250 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_255 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_254 {
   struct __anonstruct____missing_field_name_255 __annonCompField75 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_254 __annonCompField76 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_257 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_256 {
   struct __anonstruct____missing_field_name_257 __annonCompField77 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_256 __annonCompField78 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_258 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_258 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_262 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_261 {
   struct __anonstruct____missing_field_name_262 __annonCompField79 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_261 __annonCompField80 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_266 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_266 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_267 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_267 __annonCompField82 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_270 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_271 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_272 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_270 __annonCompField83 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_271 __annonCompField84 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_272 __annonCompField85 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_273 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_273 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_275 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_274 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_275 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_274 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 715 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_306 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_306 possible_net_t;
#line 376
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 383 "include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_28516 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_28516 phy_interface_t;
#line 126
enum ldv_28570 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28570 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 97 "include/linux/security.h"
struct xfrm_policy;
#line 98
struct xfrm_state;
#line 114
struct request_sock;
#line 1628
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 191 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 331
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 339 "include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_317 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_318 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_316 adj_list ;
   struct __anonstruct_all_adj_list_317 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_318 __annonCompField95 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2893
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 131 "include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 170 "./arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 49 "include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 81 "include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
} ;
#line 273
struct bpf_prog_aux;
#line 314 "include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 325 "include/linux/filter.h"
union __anonunion____missing_field_name_333 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 325 "include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct bpf_insn  const  * ) ;
   union __anonunion____missing_field_name_333 __annonCompField100 ;
};
#line 342 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 101 "include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 136 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
   struct net *(*get_link_net)(struct net_device  const  * ) ;
};
#line 171
struct neigh_table;
#line 171 "include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 110 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 129
struct neigh_ops;
#line 129 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 158 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 166 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 174 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 187 "include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   bool (*key_eq)(struct neighbour  const  * , void const   * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 519
struct dn_route;
#line 519 "include/net/neighbour.h"
union __anonunion____missing_field_name_344 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 519 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_344 __annonCompField101 ;
};
#line 124 "include/net/sock.h"
struct __anonstruct_socket_lock_t_345 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 124 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_345 socket_lock_t;
#line 124
struct proto;
#line 130 "include/net/sock.h"
typedef __u32 __portpair;
#line 131 "include/net/sock.h"
typedef __u64 __addrpair;
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_347 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_346 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_347 __annonCompField102 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_348 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_350 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_349 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_350 __annonCompField105 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_351 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_352 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 132 "include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_346 __annonCompField103 ;
   union __anonunion____missing_field_name_348 __annonCompField104 ;
   union __anonunion____missing_field_name_349 __annonCompField106 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_351 __annonCompField107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_352 __annonCompField108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 219
struct cg_proto;
#line 220 "include/net/sock.h"
struct __anonstruct_sk_backlog_353 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 220 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_353 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 906
struct request_sock_ops;
#line 907
struct timewait_sock_ops;
#line 908
struct inet_hashinfo;
#line 909
struct raw_hashinfo;
#line 923
struct udp_table;
#line 923 "include/net/sock.h"
union __anonunion_h_356 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 923 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct sock * , struct msghdr * , size_t  , int  , int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_356 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1046 "include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 8 "include/linux/unaligned/packed_struct.h"
struct __una_u32 {
   u32 x ;
};
#line 174 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct request_sock  const  * ) ;
};
#line 46 "include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 330 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 19 "include/linux/cryptohash.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 52 "include/uapi/linux/ipv6.h"
struct ipv6_opt_hdr {
   __u8 nexthdr ;
   __u8 hdrlen ;
};
#line 106 "include/uapi/linux/ipv6.h"
struct ipv6hdr {
   unsigned char priority : 4 ;
   unsigned char version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 174 "include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};
#line 60 "include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};
#line 68 "include/linux/ipv6.h"
struct icmpv6_echo {
   __be16 identifier ;
   __be16 sequence ;
};
#line 23 "include/uapi/linux/icmpv6.h"
struct icmpv6_nd_advt {
   unsigned char reserved : 5 ;
   unsigned char override : 1 ;
   unsigned char solicited : 1 ;
   unsigned char router : 1 ;
   unsigned int reserved2 : 24 ;
};
#line 32 "include/uapi/linux/icmpv6.h"
struct icmpv6_nd_ra {
   __u8 hop_limit ;
   unsigned char reserved : 3 ;
   unsigned char router_pref : 2 ;
   unsigned char home_agent : 1 ;
   unsigned char other : 1 ;
   unsigned char managed : 1 ;
   __be16 rt_lifetime ;
};
#line 61 "include/uapi/linux/icmpv6.h"
union __anonunion_icmp6_dataun_374 {
   __be32 un_data32[1U] ;
   __be16 un_data16[2U] ;
   __u8 un_data8[4U] ;
   struct icmpv6_echo u_echo ;
   struct icmpv6_nd_advt u_nd_advt ;
   struct icmpv6_nd_ra u_nd_ra ;
};
#line 61 "include/uapi/linux/icmpv6.h"
struct icmp6hdr {
   __u8 icmp6_type ;
   __u8 icmp6_code ;
   __sum16 icmp6_cksum ;
   union __anonunion_icmp6_dataun_374 icmp6_dataun ;
};
#line 40 "include/linux/icmpv6.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};
#line 100 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 109 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 141 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 152 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 971 "include/net/ipv6.h"
union __anonunion____missing_field_name_378 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};
#line 971 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion____missing_field_name_378 __annonCompField110 ;
};
#line 25 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_379 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 30 "include/net/inetpeer.h"
struct __anonstruct____missing_field_name_381 {
   atomic_t rid ;
};
#line 30 "include/net/inetpeer.h"
union __anonunion____missing_field_name_380 {
   struct __anonstruct____missing_field_name_381 __annonCompField112 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 30 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion____missing_field_name_379 __annonCompField111 ;
   union __anonunion____missing_field_name_380 __annonCompField113 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};
#line 50 "./include/uapi/linux/route.h"
struct uncached_list;
#line 51 "./include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};
#line 317 "include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};
#line 92 "include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 100 "include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 112 "include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
};
#line 63 "include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 42 "include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 646 "include/linux/if_vlan.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 32 "include/linux/hwmon.h"
struct sensor_device_attribute {
   struct device_attribute dev_attr ;
   int index ;
};
#line 45 "include/linux/hwmon-sysfs.h"
struct be_eq_entry {
   u32 evt ;
};
#line 204 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_wrb {
   __le32 frag_pa_hi ;
   __le32 frag_pa_lo ;
   u32 rsvd0 ;
   __le32 frag_len ;
};
#line 237 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_hdr_wrb {
   __le32 dw[4U] ;
};
#line 281 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_tx_compl {
   u32 dw[4U] ;
};
#line 285 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_d {
   u32 fragpa_hi ;
   u32 fragpa_lo ;
};
#line 363 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_compl {
   u32 dw[4U] ;
};
#line 367
struct ocrdma_dev;
#line 77 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 117 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 173
struct be_adapter;
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_eq_obj {
   struct be_queue_info q ;
   char desc[32U] ;
   bool enable_aic ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 eqd ;
   u32 cur_eqd ;
   u8 idx ;
   u8 msix_idx ;
   u16 spurious_intr ;
   struct napi_struct napi ;
   struct be_adapter *adapter ;
   cpumask_var_t affinity_mask ;
   unsigned int state ;
   spinlock_t lock ;
};
#line 204 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_aic_obj {
   bool enable ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 prev_eqd ;
   u32 et_eqd ;
   ulong jiffies ;
   u64 rx_pkts_prev ;
   u64 tx_reqs_prev ;
};
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
   bool rearm_cq ;
};
#line 227 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_stats {
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_reqs ;
   u64 tx_compl ;
   ulong tx_jiffies ;
   u32 tx_stops ;
   u32 tx_drv_drops ;
   u32 tx_hdr_parse_err ;
   u32 tx_dma_err ;
   u32 tx_tso_err ;
   u32 tx_spoof_check_err ;
   u32 tx_qinq_err ;
   u32 tx_internal_parity_err ;
   struct u64_stats_sync sync ;
   struct u64_stats_sync sync_compl ;
};
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_compl_info {
   u8 status ;
   u16 end_index ;
};
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_obj {
   u32 db_offset ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct be_tx_compl_info txcp ;
   struct sk_buff *sent_skb_list[2048U] ;
   struct be_tx_stats stats ;
   u16 pend_wrb_cnt ;
   u16 last_req_wrb_cnt ;
   u16 last_req_hdr ;
};
#line 265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_page_info {
   struct page *page ;
   dma_addr_t bus ;
   u16 page_offset ;
   bool last_frag ;
};
#line 274 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_stats {
   u64 rx_bytes ;
   u64 rx_pkts ;
   u32 rx_drops_no_skbs ;
   u32 rx_drops_no_frags ;
   u32 rx_post_fail ;
   u32 rx_compl ;
   u32 rx_mcast_pkts ;
   u32 rx_compl_err ;
   struct u64_stats_sync sync ;
};
#line 286 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_compl_info {
   u32 rss_hash ;
   u16 vlan_tag ;
   u16 pkt_size ;
   u16 port ;
   u8 vlanf ;
   u8 num_rcvd ;
   u8 err ;
   u8 ipf ;
   u8 tcpf ;
   u8 udpf ;
   u8 ip_csum ;
   u8 l4_csum ;
   u8 ipv6 ;
   u8 qnq ;
   u8 pkt_type ;
   u8 ip_frag ;
   u8 tunneled ;
};
#line 306 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_obj {
   struct be_adapter *adapter ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct be_rx_compl_info rxcp ;
   struct be_rx_page_info page_info_tbl[1024U] ;
   struct be_rx_stats stats ;
   u8 rss_id ;
   bool rx_post_starved ;
};
#line 317 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_drv_stats {
   u32 eth_red_drops ;
   u32 dma_map_errors ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rx_drops_too_many_frags ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rx_roce_bytes_lsd ;
   u32 rx_roce_bytes_msd ;
   u32 rx_roce_frames ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
};
#line 358 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_vf_cfg {
   unsigned char mac_addr[6U] ;
   int if_handle ;
   int pmac_id ;
   u16 vlan_tag ;
   u32 tx_rate ;
   u32 plink_tracking ;
   u32 privileges ;
   bool spoofchk ;
};
#line 377 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct phy_info {
   u8 transceiver ;
   u8 autoneg ;
   u8 fc_autoneg ;
   u8 port_type ;
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   int link_speed ;
   u32 advertising ;
   u32 supported ;
   u8 cable_type ;
   u8 vendor_name[17U] ;
   u8 vendor_pn[17U] ;
};
#line 415 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_resources {
   u16 max_vfs ;
   u16 max_mcast_mac ;
   u16 max_tx_qs ;
   u16 max_rss_qs ;
   u16 max_rx_qs ;
   u16 max_cq_count ;
   u16 max_uc_mac ;
   u16 max_vlans ;
   u16 max_iface_count ;
   u16 max_mcc_count ;
   u16 max_evt_qs ;
   u32 if_cap_flags ;
   u32 vf_if_cap_flags ;
};
#line 431 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct rss_info {
   u64 rss_flags ;
   u8 rsstable[128U] ;
   u8 rss_queue[128U] ;
   u8 rss_hkey[40U] ;
};
#line 440 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_hwmon {
   struct device *hwmon_dev ;
   u8 be_on_die_temp ;
};
#line 458 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_wrb_params {
   u32 features ;
   u16 vlan_tag ;
   u16 lso_mss ;
};
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct __anonstruct_roce_db_388 {
   u32 size ;
   u32 total_size ;
   u64 io_addr ;
};
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_adapter {
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 *csr ;
   u8 *db ;
   u8 *pcicfg ;
   struct mutex mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   u16 cfg_num_qs ;
   u16 num_evt_qs ;
   u16 num_msix_vec ;
   struct be_eq_obj eq_obj[32U] ;
   struct msix_entry msix_entries[32U] ;
   bool isr_registered ;
   u16 num_tx_qs ;
   struct be_tx_obj tx_obj[32U] ;
   u16 num_rx_qs ;
   u16 num_rss_qs ;
   u16 need_def_rxq ;
   struct be_rx_obj rx_obj[32U] ;
   u32 big_page_size ;
   struct be_drv_stats drv_stats ;
   struct be_aic_obj aic_obj[32U] ;
   u8 vlan_prio_bmap ;
   u16 recommended_prio ;
   struct be_dma_mem rx_filter ;
   struct be_dma_mem stats_cmd ;
   struct delayed_work work ;
   u16 work_counter ;
   struct delayed_work be_err_detection_work ;
   u8 err_flags ;
   u32 flags ;
   u32 cmd_privileges ;
   char fw_ver[32U] ;
   char fw_on_flash[32U] ;
   int if_handle ;
   u32 if_flags ;
   u32 *pmac_id ;
   u32 uc_macs ;
   unsigned long vids[64U] ;
   u16 vlans_added ;
   u32 beacon_state ;
   bool eeh_error ;
   bool fw_timeout ;
   bool hw_error ;
   u32 port_num ;
   char port_name ;
   u8 mc_type ;
   u32 function_mode ;
   u32 function_caps ;
   u32 rx_fc ;
   u32 tx_fc ;
   bool stats_cmd_sent ;
   struct __anonstruct_roce_db_388 roce_db ;
   u32 num_msix_roce_vec ;
   struct ocrdma_dev *ocrdma_dev ;
   struct list_head entry ;
   u32 flash_status ;
   struct completion et_cmd_compl ;
   struct be_resources pool_res ;
   struct be_resources res ;
   u16 num_vfs ;
   u8 virtfn ;
   struct be_vf_cfg *vf_cfg ;
   bool be3_native ;
   u32 sli_family ;
   u8 hba_port_num ;
   u16 pvid ;
   __be16 vxlan_port ;
   int vxlan_port_count ;
   struct phy_info phy ;
   u8 wol_cap ;
   bool wol_en ;
   u16 asic_rev ;
   u16 qnq_vid ;
   u32 msg_enable ;
   int be_get_temp_freq ;
   struct be_hwmon hwmon_info ;
   u8 pf_number ;
   struct rss_info rss_info ;
   u32 bmc_filt_mask ;
};
#line 205 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd[3U] ;
};
#line 294 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd[2U] ;
   u8 base_status ;
   u8 addl_status ;
   u8 rsvd1[2U] ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 647 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v0 {
   u32 rx_bytes_lsd ;
   u32 rx_bytes_msd ;
   u32 rx_total_frames ;
   u32 rx_unicast_frames ;
   u32 rx_multicast_frames ;
   u32 rx_broadcast_frames ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_64_byte_packets ;
   u32 rx_65_127_byte_packets ;
   u32 rx_128_256_byte_packets ;
   u32 rx_256_511_byte_packets ;
   u32 rx_512_1023_byte_packets ;
   u32 rx_1024_1518_byte_packets ;
   u32 rx_1519_2047_byte_packets ;
   u32 rx_2048_4095_byte_packets ;
   u32 rx_4096_8191_byte_packets ;
   u32 rx_8192_9216_byte_packets ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rx_non_rss_packets ;
   u32 rx_ipv4_packets ;
   u32 rx_ipv6_packets ;
   u32 rx_ipv4_bytes_lsd ;
   u32 rx_ipv4_bytes_msd ;
   u32 rx_ipv6_bytes_lsd ;
   u32 rx_ipv6_bytes_msd ;
   u32 rx_chute1_packets ;
   u32 rx_chute2_packets ;
   u32 rx_chute3_packets ;
   u32 rx_management_packets ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 tx_bytes_lsd ;
   u32 tx_bytes_msd ;
   u32 tx_unicastframes ;
   u32 tx_multicastframes ;
   u32 tx_broadcastframes ;
   u32 tx_pauseframes ;
   u32 tx_controlframes ;
   u32 tx_64_byte_packets ;
   u32 tx_65_127_byte_packets ;
   u32 tx_128_256_byte_packets ;
   u32 tx_256_511_byte_packets ;
   u32 tx_512_1023_byte_packets ;
   u32 tx_1024_1518_byte_packets ;
   u32 tx_1519_2047_byte_packets ;
   u32 tx_2048_4095_byte_packets ;
   u32 tx_4096_8191_byte_packets ;
   u32 tx_8192_9216_byte_packets ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
};
#line 717 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v0 {
   struct be_port_rxf_stats_v0 port[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 management_rx_port_packets ;
   u32 management_rx_port_bytes ;
   u32 management_rx_port_pause_frames ;
   u32 management_rx_port_errors ;
   u32 management_tx_port_packets ;
   u32 management_tx_port_bytes ;
   u32 management_tx_port_pause ;
   u32 management_rx_port_rxfifo_overflow ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd0[7U] ;
   u32 port0_jabber_events ;
   u32 port1_jabber_events ;
   u32 rsvd1[6U] ;
};
#line 741 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v0 {
   u32 rx_drops_no_fragments[44U] ;
   u32 rsvd[4U] ;
};
#line 746 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pmem_stats {
   u32 eth_red_drops ;
   u32 rsvd[5U] ;
};
#line 751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v0 {
   struct be_rxf_stats_v0 rxf ;
   u32 rsvd[48U] ;
   struct be_erx_stats_v0 erx ;
   struct be_pmem_stats pmem ;
};
#line 763 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v0 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v0 hw_stats ;
};
#line 768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_pport_stats {
   u32 tx_packets_lo ;
   u32 tx_packets_hi ;
   u32 tx_unicast_packets_lo ;
   u32 tx_unicast_packets_hi ;
   u32 tx_multicast_packets_lo ;
   u32 tx_multicast_packets_hi ;
   u32 tx_broadcast_packets_lo ;
   u32 tx_broadcast_packets_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
   u32 tx_unicast_bytes_lo ;
   u32 tx_unicast_bytes_hi ;
   u32 tx_multicast_bytes_lo ;
   u32 tx_multicast_bytes_hi ;
   u32 tx_broadcast_bytes_lo ;
   u32 tx_broadcast_bytes_hi ;
   u32 tx_discards_lo ;
   u32 tx_discards_hi ;
   u32 tx_errors_lo ;
   u32 tx_errors_hi ;
   u32 tx_pause_frames_lo ;
   u32 tx_pause_frames_hi ;
   u32 tx_pause_on_frames_lo ;
   u32 tx_pause_on_frames_hi ;
   u32 tx_pause_off_frames_lo ;
   u32 tx_pause_off_frames_hi ;
   u32 tx_internal_mac_errors_lo ;
   u32 tx_internal_mac_errors_hi ;
   u32 tx_control_frames_lo ;
   u32 tx_control_frames_hi ;
   u32 tx_packets_64_bytes_lo ;
   u32 tx_packets_64_bytes_hi ;
   u32 tx_packets_65_to_127_bytes_lo ;
   u32 tx_packets_65_to_127_bytes_hi ;
   u32 tx_packets_128_to_255_bytes_lo ;
   u32 tx_packets_128_to_255_bytes_hi ;
   u32 tx_packets_256_to_511_bytes_lo ;
   u32 tx_packets_256_to_511_bytes_hi ;
   u32 tx_packets_512_to_1023_bytes_lo ;
   u32 tx_packets_512_to_1023_bytes_hi ;
   u32 tx_packets_1024_to_1518_bytes_lo ;
   u32 tx_packets_1024_to_1518_bytes_hi ;
   u32 tx_packets_1519_to_2047_bytes_lo ;
   u32 tx_packets_1519_to_2047_bytes_hi ;
   u32 tx_packets_2048_to_4095_bytes_lo ;
   u32 tx_packets_2048_to_4095_bytes_hi ;
   u32 tx_packets_4096_to_8191_bytes_lo ;
   u32 tx_packets_4096_to_8191_bytes_hi ;
   u32 tx_packets_8192_to_9216_bytes_lo ;
   u32 tx_packets_8192_to_9216_bytes_hi ;
   u32 tx_lso_packets_lo ;
   u32 tx_lso_packets_hi ;
   u32 rx_packets_lo ;
   u32 rx_packets_hi ;
   u32 rx_unicast_packets_lo ;
   u32 rx_unicast_packets_hi ;
   u32 rx_multicast_packets_lo ;
   u32 rx_multicast_packets_hi ;
   u32 rx_broadcast_packets_lo ;
   u32 rx_broadcast_packets_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 rx_unicast_bytes_lo ;
   u32 rx_unicast_bytes_hi ;
   u32 rx_multicast_bytes_lo ;
   u32 rx_multicast_bytes_hi ;
   u32 rx_broadcast_bytes_lo ;
   u32 rx_broadcast_bytes_hi ;
   u32 rx_unknown_protos ;
   u32 rsvd_69 ;
   u32 rx_discards_lo ;
   u32 rx_discards_hi ;
   u32 rx_errors_lo ;
   u32 rx_errors_hi ;
   u32 rx_crc_errors_lo ;
   u32 rx_crc_errors_hi ;
   u32 rx_alignment_errors_lo ;
   u32 rx_alignment_errors_hi ;
   u32 rx_symbol_errors_lo ;
   u32 rx_symbol_errors_hi ;
   u32 rx_pause_frames_lo ;
   u32 rx_pause_frames_hi ;
   u32 rx_pause_on_frames_lo ;
   u32 rx_pause_on_frames_hi ;
   u32 rx_pause_off_frames_lo ;
   u32 rx_pause_off_frames_hi ;
   u32 rx_frames_too_long_lo ;
   u32 rx_frames_too_long_hi ;
   u32 rx_internal_mac_errors_lo ;
   u32 rx_internal_mac_errors_hi ;
   u32 rx_undersize_packets ;
   u32 rx_oversize_packets ;
   u32 rx_fragment_packets ;
   u32 rx_jabbers ;
   u32 rx_control_frames_lo ;
   u32 rx_control_frames_hi ;
   u32 rx_control_frames_unknown_opcode_lo ;
   u32 rx_control_frames_unknown_opcode_hi ;
   u32 rx_in_range_errors ;
   u32 rx_out_of_range_errors ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_invalid_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errors ;
   u32 rx_tcp_checksum_errors ;
   u32 rx_udp_checksum_errors ;
   u32 rx_non_rss_packets ;
   u32 rsvd_111 ;
   u32 rx_ipv4_packets_lo ;
   u32 rx_ipv4_packets_hi ;
   u32 rx_ipv6_packets_lo ;
   u32 rx_ipv6_packets_hi ;
   u32 rx_ipv4_bytes_lo ;
   u32 rx_ipv4_bytes_hi ;
   u32 rx_ipv6_bytes_lo ;
   u32 rx_ipv6_bytes_hi ;
   u32 rx_nic_packets_lo ;
   u32 rx_nic_packets_hi ;
   u32 rx_tcp_packets_lo ;
   u32 rx_tcp_packets_hi ;
   u32 rx_iscsi_packets_lo ;
   u32 rx_iscsi_packets_hi ;
   u32 rx_management_packets_lo ;
   u32 rx_management_packets_hi ;
   u32 rx_switched_unicast_packets_lo ;
   u32 rx_switched_unicast_packets_hi ;
   u32 rx_switched_multicast_packets_lo ;
   u32 rx_switched_multicast_packets_hi ;
   u32 rx_switched_broadcast_packets_lo ;
   u32 rx_switched_broadcast_packets_hi ;
   u32 num_forwards_lo ;
   u32 num_forwards_hi ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
   u32 rx_drops_too_many_frags_lo ;
   u32 rx_drops_too_many_frags_hi ;
   u32 rx_drops_invalid_queue ;
   u32 rsvd_141 ;
   u32 rx_drops_mtu_lo ;
   u32 rx_drops_mtu_hi ;
   u32 rx_packets_64_bytes_lo ;
   u32 rx_packets_64_bytes_hi ;
   u32 rx_packets_65_to_127_bytes_lo ;
   u32 rx_packets_65_to_127_bytes_hi ;
   u32 rx_packets_128_to_255_bytes_lo ;
   u32 rx_packets_128_to_255_bytes_hi ;
   u32 rx_packets_256_to_511_bytes_lo ;
   u32 rx_packets_256_to_511_bytes_hi ;
   u32 rx_packets_512_to_1023_bytes_lo ;
   u32 rx_packets_512_to_1023_bytes_hi ;
   u32 rx_packets_1024_to_1518_bytes_lo ;
   u32 rx_packets_1024_to_1518_bytes_hi ;
   u32 rx_packets_1519_to_2047_bytes_lo ;
   u32 rx_packets_1519_to_2047_bytes_hi ;
   u32 rx_packets_2048_to_4095_bytes_lo ;
   u32 rx_packets_2048_to_4095_bytes_hi ;
   u32 rx_packets_4096_to_8191_bytes_lo ;
   u32 rx_packets_4096_to_8191_bytes_hi ;
   u32 rx_packets_8192_to_9216_bytes_lo ;
   u32 rx_packets_8192_to_9216_bytes_hi ;
};
#line 949 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_pport_stats {
   struct be_cmd_resp_hdr hdr ;
   struct lancer_pport_stats pport_stats ;
};
#line 1103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_set_eqd {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 1272 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_comp {
   unsigned long offset ;
   int optype ;
   int size ;
   int img_type ;
};
#line 1279 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct image_hdr {
   u32 imageid ;
   u32 imageoffset ;
   u32 imagelength ;
   u32 image_checksum ;
   u8 image_version[32U] ;
};
#line 1299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_file_hdr_g3 {
   u8 sign[52U] ;
   u8 ufi_version[4U] ;
   u32 file_len ;
   u32 cksum ;
   u32 antidote ;
   u32 num_imgs ;
   u8 build[24U] ;
   u8 asic_type_rev ;
   u8 rsvd[31U] ;
};
#line 1316 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_section_hdr {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 num_images ;
   u8 id_string[128U] ;
   u32 rsvd[4U] ;
};
#line 1325 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_section_hdr_g2 {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 build_num ;
   u8 id_string[128U] ;
   u32 rsvd[8U] ;
};
#line 1334 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_section_entry {
   u32 type ;
   u32 offset ;
   u32 pad_size ;
   u32 image_size ;
   u32 cksum ;
   u32 main ;
   u16 optype ;
   u16 rsvd0 ;
   u32 rsvd1 ;
   u8 ver_data[32U] ;
};
#line 1347 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_section_info {
   u8 cookie[32U] ;
   struct flash_section_hdr fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 1353 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flash_section_info_g2 {
   u8 cookie[32U] ;
   struct flash_section_hdr_g2 fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 1359 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flashrom_params {
   u32 op_code ;
   u32 op_type ;
   u32 data_buf_size ;
   u32 offset ;
};
#line 1373 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_write_flashrom {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 data_buf[32768U] ;
   u8 rsvd[4U] ;
};
#line 1827 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v1 {
   u32 rsvd0[12U] ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd1[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd2[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd3[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd4[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd5[3U] ;
};
#line 1865 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v1 {
   struct be_port_rxf_stats_v1 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[14U] ;
};
#line 1881 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v1 {
   u32 rx_drops_no_fragments[68U] ;
   u32 rsvd[4U] ;
};
#line 1886 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v2 {
   u32 rsvd0[10U] ;
   u32 roce_bytes_received_lsd ;
   u32 roce_bytes_received_msd ;
   u32 rsvd1[5U] ;
   u32 roce_frames_received ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd2[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd3[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd4[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd5[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd6[3U] ;
   u32 rx_drops_payload_size ;
   u32 rx_drops_clipped_header ;
   u32 rx_drops_crc ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
   u32 rsvd7[19U] ;
};
#line 1932 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v2 {
   struct be_port_rxf_stats_v2 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[35U] ;
};
#line 1947 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v1 {
   struct be_rxf_stats_v1 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v1 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1960 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v1 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v1 hw_stats ;
};
#line 1965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v2 {
   u32 rx_drops_no_fragments[136U] ;
   u32 rsvd[3U] ;
};
#line 1970 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v2 {
   struct be_rxf_stats_v2 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v2 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1983 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v2 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v2 hw_stats ;
};
#line 1672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 1683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 1694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 1713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 1724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 1745 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 1774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___5;
#line 1785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 1812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 1833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 847 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 len ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_payload_389 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 31 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_389 payload ;
};
#line 46
enum mcc_base_status {
    MCC_STATUS_SUCCESS = 0,
    MCC_STATUS_FAILED = 1,
    MCC_STATUS_ILLEGAL_REQUEST = 2,
    MCC_STATUS_ILLEGAL_FIELD = 3,
    MCC_STATUS_INSUFFICIENT_BUFFER = 4,
    MCC_STATUS_UNAUTHORIZED_REQUEST = 5,
    MCC_STATUS_NOT_SUPPORTED = 66,
    MCC_STATUS_FEATURE_NOT_SUPPORTED = 68
} ;
#line 57
enum mcc_addl_status {
    MCC_ADDL_STATUS_INSUFFICIENT_RESOURCES = 22,
    MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH = 77,
    MCC_ADDL_STATUS_TOO_MANY_INTERFACES = 74,
    MCC_ADDL_STATUS_INSUFFICIENT_VLANS = 171
} ;
#line 64 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 96 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   u32 flags ;
};
#line 129 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_qos_link_speed {
   u8 physical_port ;
   u8 rsvd[5U] ;
   u16 qos_link_speed ;
   u32 event_tag ;
   u32 flags ;
};
#line 140 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_cos_priority {
   u8 physical_port ;
   u8 available_priority_bmap ;
   u8 reco_default_priority ;
   u8 valid ;
   u8 rsvd0 ;
   u8 event_tag ;
   u32 flags ;
};
#line 153 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_pvid_state {
   u8 enabled ;
   u8 rsvd0 ;
   u16 tag ;
   u32 event_tag ;
   u32 rsvd1 ;
   u32 flags ;
};
#line 165 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_qnq {
   u8 valid ;
   u8 rsvd0 ;
   u16 vlan_tag ;
   u32 event_tag ;
   u8 rsvd1[4U] ;
   u32 flags ;
};
#line 175 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_misconfig_port {
   u32 event_data_word1 ;
   u32 event_data_word2 ;
   u32 rsvd0 ;
   u32 flags ;
};
#line 184 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_fw_control {
   u32 event_data_word1 ;
   u32 event_data_word2 ;
   u32 evt_tag ;
   u32 event_data_word4 ;
};
#line 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 307 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 343 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 351 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 msix_idx ;
};
#line 364 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mac_addr {
   u16 size_of_struct ;
   u8 addr[6U] ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mac_query {
   struct be_cmd_req_hdr hdr ;
   u8 type ;
   u8 permanent ;
   u16 if_id ;
   u32 pmac_id ;
};
#line 378 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mac_query {
   struct be_cmd_resp_hdr hdr ;
   struct mac_addr mac ;
};
#line 383 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_add {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u8 mac_address[6U] ;
   u8 rsvd0[2U] ;
};
#line 391 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_pmac_add {
   struct be_cmd_resp_hdr hdr ;
   u32 pmac_id ;
};
#line 396 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_del {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u32 pmac_id ;
};
#line 445 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 454 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 461 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fat {
   struct be_cmd_req_hdr hdr ;
   u32 fat_operation ;
   u32 read_log_offset ;
   u32 read_log_length ;
   u32 data_buffer_size ;
   u32 data_buffer[1U] ;
};
#line 470 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fat {
   struct be_cmd_resp_hdr hdr ;
   u32 log_size ;
   u32 read_log_length ;
   u32 rsvd[2U] ;
   u32 data_buffer[1U] ;
};
#line 508 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 516 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_ext_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u32 async_event_bitmap[1U] ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 525 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 531 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_tx_create {
   struct be_cmd_req_hdr hdr ;
   u8 num_pages ;
   u8 ulp_num ;
   u16 type ;
   u16 if_id ;
   u8 queue_size ;
   u8 rsvd0 ;
   u32 rsvd1 ;
   u16 cq_id ;
   u16 rsvd2 ;
   u32 rsvd3[13U] ;
   struct phys_addr pages[8U] ;
};
#line 550 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_tx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cid ;
   u16 rid ;
   u32 db_offset ;
   u32 rsvd0[4U] ;
};
#line 558 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_rx_create {
   struct be_cmd_req_hdr hdr ;
   u16 cq_id ;
   u8 frag_size ;
   u8 num_pages ;
   struct phys_addr pages[2U] ;
   u32 interface_id ;
   u16 max_frame_size ;
   u16 rsvd0 ;
   u32 rss_queue ;
};
#line 571 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_rx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u8 rss_id ;
   u8 rsvd0 ;
};
#line 586 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 609 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_create {
   struct be_cmd_req_hdr hdr ;
   u32 version ;
   u32 capability_flags ;
   u32 enable_flags ;
   u8 mac_addr[6U] ;
   u8 rsvd0 ;
   u8 pmac_invalid ;
   u32 vlan_tag ;
};
#line 635 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_if_create {
   struct be_cmd_resp_hdr hdr ;
   u32 interface_id ;
   u32 pmac_id ;
};
#line 641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_destroy {
   struct be_cmd_req_hdr hdr ;
   u32 interface_id ;
};
#line 935 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct pport_stats_params {
   u16 pport_num ;
   u8 rsvd ;
   u8 reset_stats ;
};
#line 941 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_cmd_params_390 {
   struct pport_stats_params params ;
   u8 rsvd[656U] ;
};
#line 941 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_pport_stats {
   struct be_cmd_req_hdr hdr ;
   union __anonunion_cmd_params_390 cmd_params ;
};
#line 961 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_cntl_addnl_attribs {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd[8U] ;
};
#line 966 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_cntl_addnl_attribs {
   struct be_cmd_resp_hdr hdr ;
   u16 ipl_file_number ;
   u8 ipl_file_version ;
   u8 rsvd0 ;
   u8 on_die_temperature ;
   u8 rsvd1[3U] ;
};
#line 975 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_vlan_config {
   struct be_cmd_req_hdr hdr ;
   u8 interface_id ;
   u8 promiscuous ;
   u8 untagged ;
   u8 num_vlan ;
   u16 normal_vlan[64U] ;
};
#line 984 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct macaddr {
   u8 byte[6U] ;
};
#line 990 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rx_filter {
   struct be_cmd_req_hdr hdr ;
   u32 global_flags_mask ;
   u32 global_flags ;
   u32 if_flags_mask ;
   u32 if_flags ;
   u32 if_id ;
   u32 mcast_num ;
   struct macaddr mcast_mac[64U] ;
};
#line 1001 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_link_status {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1024 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_link_status {
   struct be_cmd_resp_hdr hdr ;
   u8 physical_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 link_speed ;
   u8 logical_link_status ;
   u8 rsvd1[3U] ;
};
#line 1037 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_port_type {
   struct be_cmd_req_hdr hdr ;
   __le32 page_num ;
   __le32 port ;
};
#line 1050 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_port_type {
   struct be_cmd_resp_hdr hdr ;
   u32 page_num ;
   u32 port ;
   u8 page_data[256U] ;
};
#line 1071 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fw_version {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[32U] ;
   u8 rsvd1[32U] ;
};
#line 1078 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fw_version {
   struct be_cmd_resp_hdr hdr ;
   u8 firmware_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
};
#line 1084 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_flow_control {
   struct be_cmd_req_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1091 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_flow_control {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1097 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_flow_control {
   struct be_cmd_resp_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1110 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   u32 num_eq ;
   struct be_set_eqd set_eqd[32U] ;
};
#line 1116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_query_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd[31U] ;
};
#line 1129 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_query_fw_cfg {
   struct be_cmd_resp_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   u32 rsvd[26U] ;
   u32 function_caps ;
};
#line 1139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rss_config {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u16 enable_rss ;
   u16 cpu_table_size_log2 ;
   u32 hash[10U] ;
   u8 cpu_table[128U] ;
   u8 flush ;
   u8 rsvd0[3U] ;
};
#line 1173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_enable_disable_beacon {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 beacon_state ;
   u8 beacon_duration ;
   u8 status_duration ;
};
#line 1186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_beacon_state {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 rsvd0 ;
   u16 rsvd1 ;
};
#line 1193 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_beacon_state {
   struct be_cmd_resp_hdr resp_hdr ;
   u8 beacon_state ;
   u8 rsvd0[3U] ;
};
#line 1380 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_read_flash_crc {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 crc[4U] ;
   u8 rsvd[4U] ;
};
#line 1395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_write_object {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
   u32 write_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1406 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_write_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_write_len ;
   u8 change_status ;
   u8 rsvd3[3U] ;
};
#line 1422 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_read_object {
   struct be_cmd_req_hdr hdr ;
   u32 desired_read_len ;
   u32 read_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_read_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_read_len ;
   u32 eof ;
};
#line 1454 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_delete_object {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd1 ;
   u32 rsvd2 ;
   u8 object_name[104U] ;
};
#line 1461 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0[145U] ;
   u8 magic_mac[6U] ;
   u8 rsvd2[2U] ;
};
#line 1469 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config_v1 {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 query_options ;
   u8 rsvd1[5U] ;
   u32 rsvd2[288U] ;
   u8 magic_mac[6U] ;
   u8 rsvd3[22U] ;
};
#line 1479 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_acpi_wol_magic_config_v1 {
   struct be_cmd_resp_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 wol_settings ;
   u8 rsvd1[5U] ;
   u32 rsvd2[295U] ;
};
#line 1487 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_loopback_test {
   struct be_cmd_req_hdr hdr ;
   u32 loopback_type ;
   u32 num_pkts ;
   u64 pattern ;
   u32 src_port ;
   u32 dest_port ;
   u32 pkt_size ;
};
#line 1507 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_loopback_test {
   struct be_cmd_resp_hdr resp_hdr ;
   u32 status ;
   u32 num_txfer ;
   u32 num_rx ;
   u32 miscomp_off ;
   u32 ticks_compl ;
};
#line 1516 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_lmode {
   struct be_cmd_req_hdr hdr ;
   u8 src_port ;
   u8 dest_port ;
   u8 loopback_type ;
   u8 loopback_state ;
};
#line 1524 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_ddrdma_test {
   struct be_cmd_req_hdr hdr ;
   u64 pattern ;
   u32 byte_count ;
   u32 rsvd0 ;
   u8 snd_buff[4096U] ;
   u8 rsvd1[4096U] ;
};
#line 1534 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_ddrdma_test {
   struct be_cmd_resp_hdr hdr ;
   u64 pattern ;
   u32 byte_cnt ;
   u32 snd_err ;
   u8 rsvd0[4096U] ;
   u8 rcv_buff[4096U] ;
};
#line 1543 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[1024U] ;
};
#line 1574 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_phy_info {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[24U] ;
};
#line 1606 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_phy_info {
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 ext_phy_details ;
   u16 rsvd ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   u32 future_use[2U] ;
};
#line 1622 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_qos {
   struct be_cmd_req_hdr hdr ;
   u32 valid_bits ;
   u32 max_bps_nic ;
   u32 rsvd[7U] ;
};
#line 1633 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mgmt_hba_attribs {
   u32 rsvd0[24U] ;
   u8 controller_model_number[32U] ;
   u32 rsvd1[79U] ;
   u8 rsvd2[3U] ;
   u8 phy_port ;
   u32 rsvd3[13U] ;
};
#line 1643 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mgmt_controller_attrib {
   struct mgmt_hba_attribs hba_attribs ;
   u32 rsvd0[10U] ;
};
#line 1648 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cntl_attribs {
   struct be_cmd_req_hdr hdr ;
};
#line 1652 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cntl_attribs {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attrib attribs ;
};
#line 1657 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_func_cap {
   struct be_cmd_req_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1668 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_set_func_cap {
   struct be_cmd_resp_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1689 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_priv_map {
   u8 opcode ;
   u8 subsystem ;
   u32 priv_mask ;
};
#line 1699 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1704 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fn_privileges {
   struct be_cmd_resp_hdr hdr ;
   u32 privilege_mask ;
};
#line 1709 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 privileges ;
   u32 privileges_lancer ;
};
#line 1715 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_type ;
   u8 perm_override ;
   u16 iface_id ;
   u32 mac_id ;
   u32 rsvd[3U] ;
};
#line 1726 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct __anonstruct_s_mac_id_392 {
   u8 rsvd[2U] ;
   u32 mac_id ;
};
#line 1726 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_mac_addr_id_391 {
   u8 macaddr[6U] ;
   struct __anonstruct_s_mac_id_392 s_mac_id ;
};
#line 1726 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct get_list_macaddr {
   u16 mac_addr_size ;
   union __anonunion_mac_addr_id_391 mac_addr_id ;
};
#line 1737 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_mac_list {
   struct be_cmd_resp_hdr hdr ;
   struct get_list_macaddr fd_macaddr ;
   struct get_list_macaddr macid_macaddr ;
   u8 true_mac_count ;
   u8 pseudo_mac_count ;
   u8 mac_list_size ;
   u8 rsvd ;
   struct get_list_macaddr macaddr_list[64U] ;
};
#line 1749 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_count ;
   u8 rsvd1 ;
   u16 rsvd2 ;
   struct macaddr mac[64U] ;
};
#line 1781 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[20U] ;
};
#line 1805 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
};
#line 1810 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_hsw_config {
   struct be_cmd_resp_hdr hdr ;
   u8 context[16U] ;
   u32 rsvd ;
};
#line 1816 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 1822 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u8 port_name[4U] ;
};
#line 1988 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_mode {
   u8 mode ;
   u8 rsvd0 ;
   u16 port_mask ;
   u32 dbg_lvl ;
   u64 fun_mask ;
};
#line 2003 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_modules {
   u8 modules_str[32U] ;
   u32 modules_id ;
   u32 num_modes ;
   struct ext_fat_mode trace_lvl[4U] ;
};
#line 2010 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_fat_conf_params {
   u32 max_log_entries ;
   u32 log_entry_size ;
   u8 log_type ;
   u8 max_log_funs ;
   u8 max_log_ports ;
   u8 rsvd0 ;
   u32 supp_modes ;
   u32 num_modules ;
   struct ext_fat_modules module[27U] ;
};
#line 2022 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   u32 parameter_type ;
};
#line 2032 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   struct be_fat_conf_params set_params ;
};
#line 2037 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_res_desc_hdr {
   u8 desc_type ;
   u8 desc_len ;
};
#line 2056 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd0 ;
   u8 flags ;
   u8 link_num ;
   u8 mc_type ;
   u16 rsvd1 ;
   u8 nv_flags ;
   u8 rsvd2 ;
   __le16 nv_port ;
   u32 rsvd3[19U] ;
};
#line 2075 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pcie_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd0 ;
   u8 flags ;
   u16 rsvd1 ;
   u8 pf_num ;
   u8 rsvd2 ;
   u32 rsvd3 ;
   u8 sriov_state ;
   u8 pf_state ;
   u8 pf_type ;
   u8 rsvd4 ;
   u16 num_vfs ;
   u16 rsvd5 ;
   u32 rsvd6[17U] ;
};
#line 2092 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_nic_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd1 ;
   u8 flags ;
   u8 vf_num ;
   u8 rsvd2 ;
   u8 pf_num ;
   u8 rsvd3 ;
   u16 unicast_mac_count ;
   u8 rsvd4[6U] ;
   u16 mcc_count ;
   u16 vlan_count ;
   u16 mcast_mac_count ;
   u16 txq_count ;
   u16 rq_count ;
   u16 rssq_count ;
   u16 lro_count ;
   u16 cq_count ;
   u16 toe_conn_count ;
   u16 eq_count ;
   u16 vlan_id ;
   u16 iface_count ;
   u32 cap_flags ;
   u8 link_param ;
   u8 rsvd6 ;
   u16 channel_id_param ;
   u32 bw_min ;
   u32 bw_max ;
   u8 acpi_params ;
   u8 wol_param ;
   u16 rsvd7 ;
   u16 tunnel_iface_count ;
   u16 direct_tenant_iface_count ;
   u32 rsvd8[6U] ;
};
#line 2147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_func_config {
   struct be_cmd_req_hdr hdr ;
};
#line 2151 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_func_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[23232U] ;
};
#line 2162 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_profile_config {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd ;
   u8 type ;
   u16 rsvd1 ;
};
#line 2171 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_profile_config {
   struct be_cmd_resp_hdr hdr ;
   __le16 desc_count ;
   u16 rsvd ;
   u8 func_param[23232U] ;
};
#line 2178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_profile_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
   u32 desc_count ;
   u8 desc[176U] ;
};
#line 2186 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_active_profile {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 2191 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_active_profile {
   struct be_cmd_resp_hdr hdr ;
   u16 active_profile_id ;
   u16 next_profile_id ;
};
#line 2197 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_enable_disable_vf {
   struct be_cmd_req_hdr hdr ;
   u8 enable ;
   u8 rsvd[3U] ;
};
#line 2203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_intr_set {
   struct be_cmd_req_hdr hdr ;
   u8 intr_enabled ;
   u8 rsvd[3U] ;
};
#line 2214 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_if_desc {
   u32 if_id ;
   u32 cap_flags ;
   u32 en_flags ;
};
#line 2221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_iface_list {
   struct be_cmd_req_hdr hdr ;
};
#line 2225 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_iface_list {
   struct be_cmd_req_hdr hdr ;
   u32 if_cnt ;
   struct be_if_desc if_desc ;
};
#line 2231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ll_link {
   struct be_cmd_req_hdr hdr ;
   u32 link_config ;
};
#line 2238 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_manage_iface_filters {
   struct be_cmd_req_hdr hdr ;
   u8 op ;
   u8 rsvd0 ;
   u8 flags ;
   u8 rsvd1 ;
   u32 tunnel_iface_id ;
   u32 target_iface_id ;
   u8 mac[6U] ;
   u16 vlan_tag ;
   u32 tenant_id ;
   u32 filter_id ;
   u32 cap_flags ;
   u32 cap_control_flags ;
};
#line 3924 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
struct __anonstruct_desc_400 {
   struct be_pcie_res_desc pcie ;
   struct be_nic_res_desc nic_vft ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 1551 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 seeprom_data[1024U] ;
};
#line 2390 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_ethtool_stat {
   char desc[32U] ;
   int type ;
   int size ;
   int offset ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 368 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
enum be_interrupt_mode {
    BE_INTERRUPT_MODE_MSIX = 0,
    BE_INTERRUPT_MODE_INTX = 1,
    BE_INTERRUPT_MODE_MSI = 2
} ;
#line 374 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct __anonstruct_msix_387 {
   int num_vectors ;
   int start_vector ;
   u32 vector_list[32U] ;
};
#line 374 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_dev_info {
   u8 *db ;
   u64 unmapped_db ;
   u32 db_page_size ;
   u32 db_total_size ;
   u64 dpp_unmapped_addr ;
   u32 dpp_unmapped_len ;
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 mac_addr[6U] ;
   u32 dev_family ;
   enum be_interrupt_mode intr_mode ;
   struct __anonstruct_msix_387 msix ;
};
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
struct ocrdma_driver {
   unsigned char name[32U] ;
   u32 be_abi_version ;
   struct ocrdma_dev *(*add)(struct be_dev_info * ) ;
   void (*remove)(struct ocrdma_dev * ) ;
   void (*state_change_handler)(struct ocrdma_dev * , u32  ) ;
};
#line 1 "<compiler builtins>"
void __builtin_prefetch(void const   *  , ...) ;
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 108 "include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 110
  return ((word << shift) | (word >> (8UL * sizeof(word) - (unsigned long )shift)));
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 61
extern void *__memmove(void * , void const   * , size_t  ) ;
#line 63
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 209
extern unsigned int cpumask_local_spread(unsigned int  , int  ) ;
#line 270 "include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ 
  unsigned int tmp ;

  {
#line 272
  tmp = cpumask_check(cpu);
#line 272
  set_bit((long )tmp, (unsigned long volatile   *)(& dstp->bits));
#line 273
  return;
}
}
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 659
extern bool zalloc_cpumask_var(cpumask_var_t ** , gfp_t  ) ;
#line 661
extern void free_cpumask_var(cpumask_var_t  ) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 49 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 51
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1,%0": "+m" (v->counter): "ir" (i));
#line 53
  return;
}
}
#line 63 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 65
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %1,%0": "+m" (v->counter): "ir" (i));
#line 67
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 7 "include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 16 "include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
#line 18
  __local_bh_disable_ip(0UL, 512U);
#line 19
  return;
}
}
#line 22
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 29 "include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
#line 31
  __local_bh_enable_ip(0UL, 512U);
#line 32
  return;
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 30
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
#line 318
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
#line 363
  return;
}
}
#line 10 "include/linux/mmdebug.h"
extern void dump_page(struct page * , char const   * ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 181
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 429
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 468
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 471
bool ldv_cancel_delayed_work_sync_15(struct delayed_work *ldv_func_arg1 ) ;
#line 475
bool ldv_cancel_delayed_work_sync_16(struct delayed_work *ldv_func_arg1 ) ;
#line 479
bool ldv_cancel_delayed_work_sync_21(struct delayed_work *ldv_func_arg1 ) ;
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_6(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 585 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 588
  return (tmp);
}
}
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 76
extern void pci_iounmap(struct pci_dev * , void * ) ;
#line 17 "include/asm-generic/pci_iomap.h"
extern void *pci_iomap(struct pci_dev * , int  , unsigned long  ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 322 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
#line 327
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_channels *be_ethtool_ops_group2  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_8  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int pci_counter  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct pci_dev *be_driver_group1  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_0  =    0;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_eeprom *be_ethtool_ops_group0  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_3_2  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_coalesce *be_ethtool_ops_group3  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_3_0  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_3  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_2  =    0;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_9  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_0  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ref_cnt  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_2  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_3_3  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_7  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct pci_dev *be_eeh_handlers_group0  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_3  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct net_device *be_ethtool_ops_group6  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_1  =    0;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_2  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_wolinfo *be_ethtool_ops_group5  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_4_0  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_4_1  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_4_3  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_3_1  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_2_1  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void *ldv_irq_data_2_0  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_work_4_2  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_rxnfc *be_ethtool_ops_group4  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2_3  =    0;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct ethtool_pauseparam *be_ethtool_ops_group1  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct net_device *be_netdev_ops_group1  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 84
void work_init_3(void) ;
#line 85
void choose_interrupt_2(void) ;
#line 86
void disable_suitable_irq_2(int line , void *data ) ;
#line 87
void activate_work_4(struct work_struct *work , int state ) ;
#line 88
void ldv_initialize_pci_error_handlers_7(void) ;
#line 89
void activate_suitable_irq_2(int line , void *data ) ;
#line 90
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 91
void activate_work_3(struct work_struct *work , int state ) ;
#line 92
void ldv_initialize_ethtool_ops_5(void) ;
#line 93
void call_and_disable_all_4(int state ) ;
#line 94
void choose_interrupt_1(void) ;
#line 95
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
#line 96
void call_and_disable_work_3(struct work_struct *work ) ;
#line 97
void disable_work_3(struct work_struct *work ) ;
#line 98
void ldv_net_device_ops_9(void) ;
#line 99
void disable_work_4(struct work_struct *work ) ;
#line 100
void work_init_4(void) ;
#line 101
void invoke_work_3(void) ;
#line 102
void disable_suitable_irq_1(int line , void *data ) ;
#line 103
int ldv_irq_1(int state , int line , void *data ) ;
#line 104
void activate_suitable_irq_1(int line , void *data ) ;
#line 106
void invoke_work_4(void) ;
#line 107
void call_and_disable_all_3(int state ) ;
#line 108
void call_and_disable_work_4(struct work_struct *work ) ;
#line 109
int ldv_irq_2(int state , int line , void *data ) ;
#line 110
void ldv_pci_driver_6(void) ;
#line 845 "include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 


  {
#line 847
  return (dev->numa_node);
}
}
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 1086
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1090
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 861 "include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 867
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 889 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 892
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 892
  return (tmp);
}
}
#line 902 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 905
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 905
  return (tmp);
}
}
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 1024
extern int pci_save_state(struct pci_dev * ) ;
#line 1025
extern void pci_restore_state(struct pci_dev * ) ;
#line 1038
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1039
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 1042
extern int __pci_enable_wake(struct pci_dev * , pci_power_t  , bool  , bool  ) ;
#line 1051 "include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp ;

  {
#line 1054
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
#line 1054
  return (tmp);
}
}
#line 1092
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1094
extern void pci_release_regions(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_22(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_23(struct pci_driver *ldv_func_arg1 ) ;
#line 400 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 400
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 400
  return (tmp);
}
}
#line 532 "include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 534 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 536
  tmp___1 = PageTail((struct page  const  *)page);
#line 536
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 536
  if (tmp___2 != 0L) {
#line 537
    tmp = __get_page_tail(page);
#line 537
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 537
    if (tmp___0 != 0L) {
#line 538
      return;
    } else {

    }
  } else {

  }
#line 543
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField42.__annonCompField41.__annonCompField40._count));
#line 543
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 543
  if (tmp___4 != 0L) {
#line 543
    dump_page(page, "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)");
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (543), "i" (12UL));
    ldv_24098: ;
#line 543
    goto ldv_24098;
  } else {

  }
#line 544
  atomic_inc(& page->__annonCompField42.__annonCompField41.__annonCompField40._count);
#line 545
  return;
}
}
#line 569
extern void put_page(struct page * ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 1213 "include/linux/pci.h"
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1224
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 59
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_26424: ;
#line 19
    goto ldv_26424;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_26433: ;
#line 36
    goto ldv_26433;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 76 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 80
  tmp = get_dma_ops(dev);
#line 80
  ops = tmp;
#line 83
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 83
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 84
  tmp___1 = valid_dma_direction((int )dir);
#line 84
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 84
  if (tmp___2 != 0L) {
#line 84
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (84), "i" (12UL));
    ldv_26468: ;
#line 84
    goto ldv_26468;
  } else {

  }
#line 85
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 86
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 88
  return (addr);
}
}
#line 91 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 94
  tmp = get_dma_ops(dev);
#line 94
  ops = tmp;
#line 96
  tmp___0 = valid_dma_direction((int )dir);
#line 96
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 96
  if (tmp___1 != 0L) {
#line 96
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (96), "i" (12UL));
    ldv_26476: ;
#line 96
    goto ldv_26476;
  } else {

  }
#line 97
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 98
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 99
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 100
  return;
}
}
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_26484: ;
#line 108
    goto ldv_26484;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 47 "./arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 131
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 101 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 103
  tmp = dma_supported(dev, mask);
#line 103
  if (tmp == 0) {
#line 104
    return (-5);
  } else {

  }
#line 105
  dev->coherent_dma_mask = mask;
#line 106
  return (0);
}
}
#line 116 "include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp ;

  {
#line 118
  tmp = dma_set_mask(dev, mask);
#line 118
  rc = tmp;
#line 119
  if (rc == 0) {
#line 120
    dma_set_coherent_mask(dev, mask);
  } else {

  }
#line 121
  return (rc);
}
}
#line 183 "include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 186
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
#line 186
  ret = tmp;
#line 188
  return (ret);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 1669
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1670
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 1671
extern int pci_num_vf(struct pci_dev * ) ;
#line 1672
extern int pci_vfs_assigned(struct pci_dev * ) ;
#line 1673
extern int pci_sriov_set_totalvfs(struct pci_dev * , u16  ) ;
#line 1674
extern int pci_sriov_get_totalvfs(struct pci_dev * ) ;
#line 230 "include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 232
  return ((unsigned int )frag->size);
}
}
#line 235 "include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 237
  frag->size = size;
#line 238
  return;
}
}
#line 240 "include/linux/skbuff.h"
__inline static void skb_frag_size_add(skb_frag_t *frag , int delta ) 
{ 


  {
#line 242
  frag->size = frag->size + (__u32 )delta;
#line 243
  return;
}
}
#line 772
extern void kfree_skb(struct sk_buff * ) ;
#line 775
extern void consume_skb(struct sk_buff * ) ;
#line 842
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 852
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 862
extern int skb_pad(struct sk_buff * , int  ) ;
#line 926 "include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb , __u32 hash , enum pkt_hash_types type ) 
{ 


  {
#line 928
  skb->l4_hash = (unsigned int )type == 3U;
#line 929
  skb->sw_hash = 0U;
#line 930
  skb->hash = hash;
#line 931
  return;
}
}
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1085 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb ) 
{ 


  {
#line 1087
  atomic_inc(& skb->users);
#line 1088
  return (skb);
}
}
#line 1127 "include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 1131
  if ((unsigned int )*((unsigned char *)skb + 142UL) == 0U) {
#line 1132
    return (0);
  } else {

  }
#line 1134
  tmp = skb_end_pointer(skb);
#line 1134
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 1135
  dataref = (dataref & 65535) - (dataref >> 16);
#line 1136
  return (dataref != 1);
}
}
#line 1176 "include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff  const  *skb ) 
{ 
  int tmp ;

  {
#line 1178
  tmp = atomic_read(& skb->users);
#line 1178
  return (tmp != 1);
}
}
#line 1194 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t pri ) 
{ 
  struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1196
  if ((pri & 16U) != 0U) {
#line 1196
    __might_sleep("include/linux/skbuff.h", 1196, 0);
  } else {

  }
#line 1197
  tmp___1 = skb_shared((struct sk_buff  const  *)skb);
#line 1197
  if (tmp___1 != 0) {
#line 1198
    tmp = skb_clone(skb, pri);
#line 1198
    nskb = tmp;
#line 1200
    tmp___0 = ldv__builtin_expect((unsigned long )nskb != (unsigned long )((struct sk_buff *)0),
                               1L);
#line 1200
    if (tmp___0 != 0L) {
#line 1201
      consume_skb(skb);
    } else {
#line 1203
      kfree_skb(skb);
    }
#line 1204
    skb = nskb;
  } else {

  }
#line 1206
  return (skb);
}
}
#line 1567 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1569
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1572 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1574
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1654 "include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 1656
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
#line 1659 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1661
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1662
  return;
}
}
#line 1664 "include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1666
  skb_reset_tail_pointer(skb);
#line 1667
  skb->tail = skb->tail + (sk_buff_data_t )offset;
#line 1668
  return;
}
}
#line 1693 "include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
#line 1695
  tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 1695
  tmp = tmp___0;
#line 1696
  tmp___1 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1696
  tmp___2 = ldv__builtin_expect((long )tmp___1, 0L);
#line 1696
  if (tmp___2 != 0L) {
#line 1696
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/skbuff.h"),
                         "i" (1696), "i" (12UL));
    ldv_29123: ;
#line 1696
    goto ldv_29123;
  } else {

  }
#line 1697
  skb->tail = skb->tail + len;
#line 1698
  skb->len = skb->len + len;
#line 1699
  return (tmp);
}
}
#line 1702
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1723
extern unsigned char *__pskb_pull_tail(struct sk_buff * , int  ) ;
#line 1739 "include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 1741
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 1741
  tmp___0 = ldv__builtin_expect(tmp >= len, 1L);
#line 1741
  if (tmp___0 != 0L) {
#line 1742
    return (1);
  } else {

  }
#line 1743
  tmp___1 = ldv__builtin_expect(skb->len < len, 0L);
#line 1743
  if (tmp___1 != 0L) {
#line 1744
    return (0);
  } else {

  }
#line 1745
  tmp___2 = skb_headlen((struct sk_buff  const  *)skb);
#line 1745
  tmp___3 = __pskb_pull_tail(skb, (int )(len - tmp___2));
#line 1745
  return ((unsigned long )tmp___3 != (unsigned long )((unsigned char *)0U));
}
}
#line 1754 "include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff  const  *skb ) 
{ 


  {
#line 1756
  return ((unsigned int )((long )skb->data) - (unsigned int )((long )skb->head));
}
}
#line 1846 "include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1848
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_network_header);
}
}
#line 1863 "include/linux/skbuff.h"
__inline static unsigned char *skb_inner_mac_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1865
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_mac_header);
}
}
#line 1884 "include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1886
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
#line 1901 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1903
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 2049
extern int ___pskb_trim(struct sk_buff * , unsigned int  ) ;
#line 2051 "include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
#line 2053
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 2053
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2053
  if (tmp___1 != 0L) {
#line 2054
    __ret_warn_on = 1;
#line 2054
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2054
    if (tmp != 0L) {
#line 2054
      warn_slowpath_null("include/linux/skbuff.h", 2054);
    } else {

    }
#line 2054
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2055
    return;
  } else {

  }
#line 2057
  skb->len = len;
#line 2058
  skb_set_tail_pointer(skb, (int const   )len);
#line 2059
  return;
}
}
#line 2063 "include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;

  {
#line 2065
  if (skb->data_len != 0U) {
#line 2066
    tmp = ___pskb_trim(skb, len);
#line 2066
    return (tmp);
  } else {

  }
#line 2067
  __skb_trim(skb, len);
#line 2068
  return (0);
}
}
#line 2071 "include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2073
  if (skb->len > len) {
#line 2073
    tmp = __pskb_trim(skb, len);
#line 2073
    tmp___0 = tmp;
  } else {
#line 2073
    tmp___0 = 0;
  }
#line 2073
  return (tmp___0);
}
}
#line 2144
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2180 "include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                            unsigned int length ,
                                                            gfp_t gfp ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 2183
  tmp = __netdev_alloc_skb(dev, length, gfp);
#line 2183
  skb = tmp;
#line 2187
  return (skb);
}
}
#line 2190 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                          unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2193
  tmp = __netdev_alloc_skb_ip_align(dev, length, 32U);
#line 2193
  return (tmp);
}
}
#line 2276 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2278
  return ((struct page *)frag->page.p);
}
}
#line 2362 "include/linux/skbuff.h"
__inline static void __skb_frag_set_page(skb_frag_t *frag , struct page *page ) 
{ 


  {
#line 2364
  frag->page.p = page;
#line 2365
  return;
}
}
#line 2375 "include/linux/skbuff.h"
__inline static void skb_frag_set_page(struct sk_buff *skb , int f , struct page *page ) 
{ 
  unsigned char *tmp ;

  {
#line 2378
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2378
  __skb_frag_set_page((skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )f,
                      page);
#line 2379
  return;
}
}
#line 2394 "include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2399
  tmp = skb_frag_page(frag);
#line 2399
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
#line 2399
  return (tmp___0);
}
}
#line 2431 "include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb , unsigned int headroom , int cloned ) 
{ 
  int delta ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___1 ;

  {
#line 2434
  delta = 0;
#line 2436
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
#line 2436
  if (tmp___0 < headroom) {
#line 2437
    tmp = skb_headroom((struct sk_buff  const  *)skb);
#line 2437
    delta = (int )(headroom - tmp);
  } else {

  }
#line 2439
  if (delta != 0 || cloned != 0) {
#line 2440
    _max1 = 32;
#line 2440
    _max2 = 64;
#line 2440
    _max1___0 = 32;
#line 2440
    _max2___0 = 64;
#line 2440
    tmp___1 = pskb_expand_head(skb, (((_max1 > _max2 ? _max1 : _max2) + -1) + delta) & - (_max1___0 > _max2___0 ? _max1___0 : _max2___0),
                               0, 32U);
#line 2440
    return (tmp___1);
  } else {

  }
#line 2442
  return (0);
}
}
#line 2472 "include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb , unsigned int headroom ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2474
  tmp = skb_header_cloned((struct sk_buff  const  *)skb);
#line 2474
  tmp___0 = __skb_cow(skb, headroom, tmp);
#line 2474
  return (tmp___0);
}
}
#line 2505 "include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int size ;
  int tmp ;
  long tmp___0 ;

  {
#line 2507
  size = skb->len;
#line 2509
  tmp___0 = ldv__builtin_expect(size < len, 0L);
#line 2509
  if (tmp___0 != 0L) {
#line 2510
    len = len - size;
#line 2511
    tmp = skb_pad(skb, (int )len);
#line 2511
    if (tmp != 0) {
#line 2512
      return (-12);
    } else {

    }
#line 2513
    __skb_put(skb, len);
  } else {

  }
#line 2515
  return (0);
}
}
#line 3296 "include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 3298
  return ((u16 )skb->queue_mapping);
}
}
#line 3306 "include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 3308
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 3309
  return;
}
}
#line 3385 "include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3387
  tmp = skb_end_pointer(skb);
#line 3387
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 3391 "include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3393
  tmp = skb_end_pointer(skb);
#line 3393
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 3427 "include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 3429
  return;
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 50 "include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
#line 52
  msleep(seconds * 1000U);
#line 53
  return;
}
}
#line 71 "include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp ) 
{ 


  {
#line 73
  return;
}
}
#line 123 "include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 131
  return (0U);
}
}
#line 135 "include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync  const  *syncp ,
                                               unsigned int start ) 
{ 


  {
#line 144
  return (0);
}
}
#line 11 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_10(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_12(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 154
extern void free_irq(unsigned int  , void * ) ;
#line 157
void ldv_free_irq_11(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 161
void ldv_free_irq_13(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 165
void ldv_free_irq_14(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 263
extern int irq_set_affinity_hint(unsigned int  , struct cpumask  const  * ) ;
#line 391 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 394 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 396
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
#line 396
  return (tmp != 0);
}
}
#line 408 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 410
  tmp = napi_disable_pending(n);
#line 410
  if (tmp) {
#line 410
    tmp___0 = 0;
  } else {
#line 410
    tmp___0 = 1;
  }
#line 410
  if (tmp___0) {
#line 410
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 410
    if (tmp___1 == 0) {
#line 410
      tmp___2 = 1;
    } else {
#line 410
      tmp___2 = 0;
    }
  } else {
#line 410
    tmp___2 = 0;
  }
#line 410
  return ((bool )tmp___2);
}
}
#line 421 "include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
#line 423
  tmp = napi_schedule_prep(n);
#line 423
  if ((int )tmp) {
#line 424
    __napi_schedule(n);
  } else {

  }
#line 425
  return;
}
}
#line 458 "include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n ) 
{ 


  {
#line 460
  return;
}
}
#line 478
extern void napi_hash_add(struct napi_struct * ) ;
#line 487
extern void napi_hash_del(struct napi_struct * ) ;
#line 496
extern void napi_disable(struct napi_struct * ) ;
#line 505 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 507
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 507
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 507
  if (tmp___0 != 0L) {
#line 507
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (507), "i" (12UL));
    ldv_43177: ;
#line 507
    goto ldv_43177;
  } else {

  }
#line 508
  __asm__  volatile   ("": : : "memory");
#line 509
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
#line 510
  return;
}
}
#line 1822 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1825
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1880 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1882
  return ((void *)dev + 3008U);
}
}
#line 1911
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1920
extern void netif_napi_del(struct napi_struct * ) ;
#line 2202
extern void free_netdev(struct net_device * ) ;
#line 2205
void ldv_free_netdev_18(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_20(struct net_device *dev ) ;
#line 2515 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2517
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2518
  return;
}
}
#line 2531 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2535
  i = 0U;
#line 2535
  goto ldv_44251;
  ldv_44250: 
#line 2536
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2536
  txq = tmp;
#line 2537
  netif_tx_start_queue(txq);
#line 2535
  i = i + 1U;
  ldv_44251: ;
#line 2535
  if (dev->num_tx_queues > i) {
#line 2537
    goto ldv_44250;
  } else {

  }

#line 2542
  return;
}
}
#line 2565 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2567
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2568
  return;
}
}
#line 2584 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2586
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2586
  return (tmp != 0);
}
}
#line 2769 "include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2771
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
#line 2771
  return (tmp != 0);
}
}
#line 2802 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2804
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2804
  txq = tmp;
#line 2805
  netif_tx_stop_queue(txq);
#line 2806
  return;
}
}
#line 2815 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2818
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2818
  txq = tmp;
#line 2820
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2820
  return (tmp___0);
}
}
#line 2829
extern void netif_wake_subqueue(struct net_device * , u16  ) ;
#line 2832
extern int netif_set_xps_queue(struct net_device * , struct cpumask  const  * , u16  ) ;
#line 2867
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2870
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2892
extern int netif_get_num_default_rss_queues(void) ;
#line 2900
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2931 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2933
  __dev_kfree_skb_any(skb, 1);
#line 2934
  return;
}
}
#line 2936 "include/linux/netdevice.h"
__inline static void dev_consume_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2938
  __dev_kfree_skb_any(skb, 0);
#line 2939
  return;
}
}
#line 2943
extern int netif_receive_skb_sk(struct sock * , struct sk_buff * ) ;
#line 2944 "include/linux/netdevice.h"
__inline static int netif_receive_skb(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 2946
  tmp = netif_receive_skb_sk(skb->sk, skb);
#line 2946
  return (tmp);
}
}
#line 2950
extern struct sk_buff *napi_get_frags(struct napi_struct * ) ;
#line 2951
extern gro_result_t napi_gro_frags(struct napi_struct * ) ;
#line 3047
extern void netif_carrier_on(struct net_device * ) ;
#line 3049
extern void netif_carrier_off(struct net_device * ) ;
#line 3117
extern void netif_device_detach(struct net_device * ) ;
#line 3119
extern void netif_device_attach(struct net_device * ) ;
#line 3170 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 3172
  spin_lock(& txq->_xmit_lock);
#line 3173
  txq->xmit_lock_owner = cpu;
#line 3174
  return;
}
}
#line 3190 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 3192
  txq->xmit_lock_owner = -1;
#line 3193
  spin_unlock(& txq->_xmit_lock);
#line 3194
  return;
}
}
#line 3282 "include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3287
  local_bh_disable();
#line 3288
  __vpp_verify = (void const   *)0;
#line 3288
  switch (4UL) {
  case 1UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_44826;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_44826;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_44826;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3288
  goto ldv_44826;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_44826: 
#line 3288
  pscr_ret__ = pfo_ret__;
#line 3288
  goto ldv_44832;
  case 2UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_44836;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_44836;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_44836;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3288
  goto ldv_44836;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_44836: 
#line 3288
  pscr_ret__ = pfo_ret_____0;
#line 3288
  goto ldv_44832;
  case 4UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_44845;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_44845;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_44845;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3288
  goto ldv_44845;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_44845: 
#line 3288
  pscr_ret__ = pfo_ret_____1;
#line 3288
  goto ldv_44832;
  case 8UL: ;
#line 3288
  switch (4UL) {
  case 1UL: 
#line 3288
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_44854;
  case 2UL: 
#line 3288
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_44854;
  case 4UL: 
#line 3288
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_44854;
  case 8UL: 
#line 3288
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3288
  goto ldv_44854;
  default: 
#line 3288
  __bad_percpu_size();
  }
  ldv_44854: 
#line 3288
  pscr_ret__ = pfo_ret_____2;
#line 3288
  goto ldv_44832;
  default: 
#line 3288
  __bad_size_call_parameter();
#line 3288
  goto ldv_44832;
  }
  ldv_44832: 
#line 3288
  cpu = pscr_ret__;
#line 3289
  i = 0U;
#line 3289
  goto ldv_44864;
  ldv_44863: 
#line 3290
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3290
  txq = tmp;
#line 3292
  __netif_tx_lock(txq, cpu);
#line 3293
  netif_tx_stop_queue(txq);
#line 3294
  __netif_tx_unlock(txq);
#line 3289
  i = i + 1U;
  ldv_44864: ;
#line 3289
  if (dev->num_tx_queues > i) {
#line 3291
    goto ldv_44863;
  } else {

  }
#line 3296
  local_bh_enable();
#line 3297
  return;
}
}
#line 3352
extern int register_netdev(struct net_device * ) ;
#line 3355
int ldv_register_netdev_19(struct net_device *dev ) ;
#line 3357
extern void unregister_netdev(struct net_device * ) ;
#line 3360
void ldv_unregister_netdev_17(struct net_device *dev ) ;
#line 3549
extern void netdev_rss_key_fill(void * , size_t  ) ;
#line 3730 "include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 3733
  dev->gso_max_size = size;
#line 3734
  return;
}
}
#line 3834
extern void netdev_info(struct net_device  const  * , char const   *  , ...) ;
#line 33 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 93 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 96
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 111 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 
  u32 a ;

  {
#line 114
  a = *((u32 const   *)addr);
#line 121
  return ((a & 1U) != 0U);
}
}
#line 157 "include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 159
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
#line 186 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 190
  tmp = is_multicast_ether_addr(addr);
#line 190
  if (tmp) {
#line 190
    tmp___0 = 0;
  } else {
#line 190
    tmp___0 = 1;
  }
#line 190
  if (tmp___0) {
#line 190
    tmp___1 = is_zero_ether_addr(addr);
#line 190
    if (tmp___1) {
#line 190
      tmp___2 = 0;
    } else {
#line 190
      tmp___2 = 1;
    }
#line 190
    if (tmp___2) {
#line 190
      tmp___3 = 1;
    } else {
#line 190
      tmp___3 = 0;
    }
  } else {
#line 190
    tmp___3 = 0;
  }
#line 190
  return ((bool )tmp___3);
}
}
#line 244 "include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
#line 246
  memset((void *)addr, 0, 6UL);
#line 247
  return;
}
}
#line 271 "include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst , u8 const   *src ) 
{ 


  {
#line 274
  *((u32 *)dst) = *((u32 const   *)src);
#line 275
  *((u16 *)dst + 4U) = *((u16 const   *)src + 4U);
#line 276
  return;
}
}
#line 310 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 313
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 316
  return (fold == 0U);
}
}
#line 27 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 28
extern void rtnl_unlock(void) ;
#line 115
extern int ndo_dflt_bridge_getlink(struct sk_buff * , u32  , u32  , struct net_device * ,
                                   u16  , u32  , u32  , int  , u32  , int (*)(struct sk_buff * ,
                                                                              struct net_device * ,
                                                                              u32  ) ) ;
#line 241 "include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 292 "include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 294
  return ((void *)nlh + 16U);
}
}
#line 301 "include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 303
  return ((int )((unsigned int )nlh->nlmsg_len - 16U));
}
}
#line 311 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
#line 314
  tmp = nlmsg_data(nlh);
#line 314
  data = (unsigned char *)tmp;
#line 315
  return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
}
}
#line 323 "include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  int tmp ;

  {
#line 325
  tmp = nlmsg_len(nlh);
#line 325
  return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
}
}
#line 387 "include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr  const  *nlh , int hdrlen ,
                                               int attrtype ) 
{ 
  int tmp ;
  struct nlattr *tmp___0 ;
  struct nlattr *tmp___1 ;

  {
#line 390
  tmp = nlmsg_attrlen(nlh, hdrlen);
#line 390
  tmp___0 = nlmsg_attrdata(nlh, hdrlen);
#line 390
  tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
#line 390
  return (tmp___1);
}
}
#line 660 "include/net/netlink.h"
__inline static int nla_type(struct nlattr  const  *nla ) 
{ 


  {
#line 662
  return ((int )nla->nla_type & -49153);
}
}
#line 669 "include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 671
  return ((void *)nla + 4U);
}
}
#line 678 "include/net/netlink.h"
__inline static int nla_len(struct nlattr  const  *nla ) 
{ 


  {
#line 680
  return ((int )nla->nla_len + -4);
}
}
#line 688 "include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 690
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 703 "include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 705
  totlen = ((int )nla->nla_len + 3) & -4;
#line 707
  *remaining = *remaining - totlen;
#line 708
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 1010 "include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
#line 1012
  tmp = nla_data(nla);
#line 1012
  return (*((u16 *)tmp));
}
}
#line 16 "include/linux/unaligned/packed_struct.h"
__inline static u32 __get_unaligned_cpu32(void const   *p ) 
{ 
  struct __una_u32  const  *ptr ;

  {
#line 18
  ptr = (struct __una_u32  const  *)p;
#line 19
  return ((u32 )ptr->x);
}
}
#line 70 "include/linux/jhash.h"
__inline static u32 jhash(void const   *key , u32 length , u32 initval ) 
{ 
  u32 a ;
  u32 b ;
  u32 c ;
  u8 const   *k ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;

  {
#line 73
  k = (u8 const   *)key;
#line 76
  c = (length + initval) + 3735928559U;
#line 76
  b = c;
#line 76
  a = b;
#line 79
  goto ldv_49329;
  ldv_49328: 
#line 80
  tmp = __get_unaligned_cpu32((void const   *)k);
#line 80
  a = tmp + a;
#line 81
  tmp___0 = __get_unaligned_cpu32((void const   *)k + 4U);
#line 81
  b = tmp___0 + b;
#line 82
  tmp___1 = __get_unaligned_cpu32((void const   *)k + 8U);
#line 82
  c = tmp___1 + c;
#line 83
  a = a - c;
#line 83
  tmp___2 = rol32(c, 4U);
#line 83
  a = tmp___2 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___3 = rol32(a, 6U);
#line 83
  b = tmp___3 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___4 = rol32(b, 8U);
#line 83
  c = tmp___4 ^ c;
#line 83
  b = b + a;
#line 83
  a = a - c;
#line 83
  tmp___5 = rol32(c, 16U);
#line 83
  a = tmp___5 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___6 = rol32(a, 19U);
#line 83
  b = tmp___6 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___7 = rol32(b, 4U);
#line 83
  c = tmp___7 ^ c;
#line 83
  b = b + a;
#line 84
  length = length - 12U;
#line 85
  k = k + 12UL;
  ldv_49329: ;
#line 79
  if (length > 12U) {
#line 81
    goto ldv_49328;
  } else {

  }

#line 89
  switch (length) {
  case 12U: 
#line 90
  c = ((unsigned int )*(k + 11UL) << 24) + c;
  case 11U: 
#line 91
  c = ((unsigned int )*(k + 10UL) << 16) + c;
  case 10U: 
#line 92
  c = ((unsigned int )*(k + 9UL) << 8) + c;
  case 9U: 
#line 93
  c = (u32 )*(k + 8UL) + c;
  case 8U: 
#line 94
  b = ((unsigned int )*(k + 7UL) << 24) + b;
  case 7U: 
#line 95
  b = ((unsigned int )*(k + 6UL) << 16) + b;
  case 6U: 
#line 96
  b = ((unsigned int )*(k + 5UL) << 8) + b;
  case 5U: 
#line 97
  b = (u32 )*(k + 4UL) + b;
  case 4U: 
#line 98
  a = ((unsigned int )*(k + 3UL) << 24) + a;
  case 3U: 
#line 99
  a = ((unsigned int )*(k + 2UL) << 16) + a;
  case 2U: 
#line 100
  a = ((unsigned int )*(k + 1UL) << 8) + a;
  case 1U: 
#line 101
  a = (u32 )*k + a;
#line 102
  c = c ^ b;
#line 102
  tmp___8 = rol32(b, 14U);
#line 102
  c = c - tmp___8;
#line 102
  a = a ^ c;
#line 102
  tmp___9 = rol32(c, 11U);
#line 102
  a = a - tmp___9;
#line 102
  b = b ^ a;
#line 102
  tmp___10 = rol32(a, 25U);
#line 102
  b = b - tmp___10;
#line 102
  c = c ^ b;
#line 102
  tmp___11 = rol32(b, 16U);
#line 102
  c = c - tmp___11;
#line 102
  a = a ^ c;
#line 102
  tmp___12 = rol32(c, 4U);
#line 102
  a = a - tmp___12;
#line 102
  b = b ^ a;
#line 102
  tmp___13 = rol32(a, 14U);
#line 102
  b = b - tmp___13;
#line 102
  c = c ^ b;
#line 102
  tmp___14 = rol32(b, 24U);
#line 102
  c = c - tmp___14;
  case 0U: ;
#line 104
  goto ldv_49344;
  }
  ldv_49344: ;
#line 107
  return (c);
}
}
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 28 "include/linux/ip.h"
__inline static struct iphdr *inner_ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 30
  tmp = skb_inner_network_header(skb);
#line 30
  return ((struct iphdr *)tmp);
}
}
#line 7 "include/linux/icmpv6.h"
__inline static struct icmp6hdr *icmp6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 9
  tmp = skb_transport_header(skb);
#line 9
  return ((struct icmp6hdr *)tmp);
}
}
#line 25 "include/linux/udp.h"
__inline static struct udphdr *udp_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 27
  tmp = skb_transport_header(skb);
#line 27
  return ((struct udphdr *)tmp);
}
}
#line 74 "include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 76
  tmp = skb_network_header(skb);
#line 76
  return ((struct ipv6hdr *)tmp);
}
}
#line 79 "include/linux/ipv6.h"
__inline static struct ipv6hdr *inner_ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 81
  tmp = skb_inner_network_header(skb);
#line 81
  return ((struct ipv6hdr *)tmp);
}
}
#line 295 "include/linux/if_vlan.h"
__inline static int __vlan_insert_tag(struct sk_buff *skb , __be16 vlan_proto , u16 vlan_tci ) 
{ 
  struct vlan_ethhdr *veth ;
  int tmp ;
  unsigned char *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 300
  tmp = skb_cow_head(skb, 4U);
#line 300
  if (tmp < 0) {
#line 301
    return (-12);
  } else {

  }
#line 303
  tmp___0 = skb_push(skb, 4U);
#line 303
  veth = (struct vlan_ethhdr *)tmp___0;
#line 306
  __memmove((void *)skb->data, (void const   *)skb->data + 4U, 12UL);
#line 307
  skb->mac_header = (unsigned int )skb->mac_header + 65532U;
#line 310
  veth->h_vlan_proto = vlan_proto;
#line 313
  tmp___1 = __fswab16((int )vlan_tci);
#line 313
  veth->h_vlan_TCI = tmp___1;
#line 315
  return (0);
}
}
#line 332 "include/linux/if_vlan.h"
__inline static struct sk_buff *vlan_insert_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                u16 vlan_tci ) 
{ 
  int err ;

  {
#line 337
  err = __vlan_insert_tag(skb, (int )vlan_proto, (int )vlan_tci);
#line 338
  if (err != 0) {
#line 339
    dev_kfree_skb_any(skb);
#line 340
    return ((struct sk_buff *)0);
  } else {

  }
#line 342
  return (skb);
}
}
#line 357 "include/linux/if_vlan.h"
__inline static struct sk_buff *vlan_insert_tag_set_proto(struct sk_buff *skb , __be16 vlan_proto ,
                                                          u16 vlan_tci ) 
{ 


  {
#line 361
  skb = vlan_insert_tag(skb, (int )vlan_proto, (int )vlan_tci);
#line 362
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 363
    skb->protocol = vlan_proto;
  } else {

  }
#line 364
  return (skb);
}
}
#line 409 "include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                            u16 vlan_tci ) 
{ 


  {
#line 412
  skb->vlan_proto = vlan_proto;
#line 413
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 414
  return;
}
}
#line 481 "include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb , __be16 type , int *depth ) 
{ 
  unsigned int vlan_depth ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  struct vlan_hdr *vh ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 484
  vlan_depth = (unsigned int )skb->mac_len;
#line 490
  if ((unsigned int )type == 129U || (unsigned int )type == 43144U) {
#line 491
    if (vlan_depth != 0U) {
#line 492
      __ret_warn_on = vlan_depth <= 3U;
#line 492
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 492
      if (tmp != 0L) {
#line 492
        warn_slowpath_null("include/linux/if_vlan.h", 492);
      } else {

      }
#line 492
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 492
      if (tmp___0 != 0L) {
#line 493
        return (0U);
      } else {

      }
#line 494
      vlan_depth = vlan_depth - 4U;
    } else {
#line 496
      vlan_depth = 14U;
    }
    ldv_54824: 
#line 501
    tmp___1 = pskb_may_pull(skb, vlan_depth + 4U);
#line 501
    tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 501
    if (tmp___2 != 0L) {
#line 503
      return (0U);
    } else {

    }
#line 505
    vh = (struct vlan_hdr *)skb->data + (unsigned long )vlan_depth;
#line 506
    type = vh->h_vlan_encapsulated_proto;
#line 507
    vlan_depth = vlan_depth + 4U;
#line 509
    if ((unsigned int )type == 129U || (unsigned int )type == 43144U) {
#line 511
      goto ldv_54824;
    } else {

    }

  } else {

  }
#line 512
  if ((unsigned long )depth != (unsigned long )((int *)0)) {
#line 513
    *depth = (int )vlan_depth;
  } else {

  }
#line 515
  return (type);
}
}
#line 525 "include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb ) 
{ 
  __be16 tmp ;

  {
#line 527
  tmp = __vlan_get_protocol(skb, (int )skb->protocol, (int *)0);
#line 527
  return (tmp);
}
}
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 26 "include/linux/hwmon.h"
extern struct device *devm_hwmon_device_register_with_groups(struct device * , char const   * ,
                                                             void * , struct attribute_group  const  ** ) ;
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 130
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 130
  if (tmp != 0L) {
#line 130
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (130), "i" (12UL));
    ldv_55077: ;
#line 130
    goto ldv_55077;
  } else {

  }
#line 131
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 134 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_adv(u16 *index , u16 val , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 136
  tmp = MODULO((int )*index + (int )val, (int )limit);
#line 136
  *index = (u16 )tmp;
#line 137
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 141
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 141
  *index = (u16 )tmp;
#line 142
  return;
}
}
#line 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 146
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 149 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 151
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 154 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_index_node(struct be_queue_info *q , u16 index ) 
{ 


  {
#line 156
  return (q->dma_mem.va + (unsigned long )((int )index * (int )q->entry_size));
}
}
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
#line 161
  index_inc(& q->head, (int )q->len);
#line 162
  return;
}
}
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
#line 171
  index_inc(& q->tail, (int )q->len);
#line 172
  return;
}
}
#line 618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u16 be_max_qs(struct be_adapter *adapter ) 
{ 
  u16 num ;
  u16 __max1 ;
  u16 __max2 ;
  u16 _min1 ;
  u16 _min2 ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp ;

  {
#line 621
  __max1 = adapter->res.max_rss_qs;
#line 621
  __max2 = 1U;
#line 621
  num = (u16 )((int )__max1 > (int )__max2 ? __max1 : __max2);
#line 623
  _min1 = num;
#line 623
  _min2 = adapter->res.max_evt_qs;
#line 623
  num = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 624
  __min1 = num;
#line 624
  tmp = cpumask_weight(cpu_online_mask);
#line 624
  __min2 = (u16 )tmp;
#line 624
  return ((u16 )((int )__min1 < (int )__min2 ? __min1 : __min2));
}
}
#line 650
struct ethtool_ops  const  be_ethtool_ops ;
#line 701 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 703
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 707 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 709
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 710
  *dw = *dw & ~ (mask << (int )offset);
#line 711
  *dw = *dw | ((mask & value) << (int )offset);
#line 712
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 723
  dw = (u32 *)ptr;
#line 724
  return ((*(dw + (unsigned long )dw_offset) >> (int )offset) & mask);
}
}
#line 747 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 749
  return;
}
}
#line 774 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 is_udp_pkt(struct sk_buff *skb ) 
{ 
  u8 val ;
  struct iphdr *tmp ;
  struct ipv6hdr *tmp___0 ;
  struct iphdr *tmp___1 ;
  struct iphdr *tmp___2 ;

  {
#line 776
  val = 0U;
#line 778
  tmp___2 = ip_hdr((struct sk_buff  const  *)skb);
#line 778
  if ((unsigned int )*((unsigned char *)tmp___2 + 0UL) == 64U) {
#line 779
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 779
    val = (unsigned int )tmp->protocol == 17U;
  } else {
#line 780
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
#line 780
    if ((unsigned int )*((unsigned char *)tmp___1 + 0UL) == 96U) {
#line 781
      tmp___0 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 781
      val = (unsigned int )tmp___0->nexthdr == 17U;
    } else {

    }
  }
#line 783
  return (val);
}
}
#line 786 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool is_ipv4_pkt(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp ;
  int tmp___0 ;

  {
#line 788
  if ((unsigned int )skb->protocol == 8U) {
#line 788
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 788
    if ((unsigned int )*((unsigned char *)tmp + 0UL) == 64U) {
#line 788
      tmp___0 = 1;
    } else {
#line 788
      tmp___0 = 0;
    }
  } else {
#line 788
    tmp___0 = 0;
  }
#line 788
  return ((bool )tmp___0);
}
}
#line 798 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 be_check_error(struct be_adapter *adapter , u32 err_type ) 
{ 


  {
#line 800
  return ((int )adapter->err_flags & (int )((u8 )err_type));
}
}
#line 803 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_set_error(struct be_adapter *adapter , int err_type ) 
{ 
  struct net_device *netdev ;

  {
#line 805
  netdev = adapter->netdev;
#line 807
  adapter->err_flags = (u8 )((int )((signed char )adapter->err_flags) | (int )((signed char )err_type));
#line 808
  netif_carrier_off(netdev);
#line 810
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%s: Link down\n",
            (char *)(& netdev->name));
#line 811
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_clear_error(struct be_adapter *adapter , int err_type ) 
{ 


  {
#line 815
  adapter->err_flags = (u8 )((int )((signed char )adapter->err_flags) & ~ ((int )((signed char )err_type)));
#line 816
  return;
}
}
#line 818 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_multi_rxq(struct be_adapter  const  *adapter ) 
{ 


  {
#line 820
  return ((unsigned int )((unsigned short )adapter->num_rx_qs) > 1U);
}
}
#line 823
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) ;
#line 825
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) ;
#line 826
void be_parse_stats(struct be_adapter *adapter ) ;
#line 827
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) ;
#line 829
bool be_pause_supported(struct be_adapter *adapter ) ;
#line 831
int be_update_queues(struct be_adapter *adapter ) ;
#line 832
int be_poll(struct napi_struct *napi , int budget ) ;
#line 833
void be_eqd_update(struct be_adapter *adapter , bool force_update ) ;
#line 838
void be_roce_dev_add(struct be_adapter *adapter ) ;
#line 839
void be_roce_dev_remove(struct be_adapter *adapter ) ;
#line 844
void be_roce_dev_open(struct be_adapter *adapter ) ;
#line 845
void be_roce_dev_close(struct be_adapter *adapter ) ;
#line 846
void be_roce_dev_shutdown(struct be_adapter *adapter ) ;
#line 956 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static struct lancer_pport_stats *pport_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct lancer_cmd_resp_pport_stats *cmd ;

  {
#line 958
  cmd = (struct lancer_cmd_resp_pport_stats *)adapter->stats_cmd.va;
#line 959
  return (& cmd->pport_stats);
}
}
#line 2143 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool be_is_mc(struct be_adapter *adapter ) 
{ 


  {
#line 2145
  return ((unsigned int )adapter->mc_type > 1U);
}
}
#line 2260
int be_fw_wait_ready(struct be_adapter *adapter ) ;
#line 2263
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) ;
#line 2265
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) ;
#line 2267
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) ;
#line 2269
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) ;
#line 2270
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) ;
#line 2271
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) ;
#line 2274
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) ;
#line 2276
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) ;
#line 2277
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) ;
#line 2279
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) ;
#line 2281
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) ;
#line 2282
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) ;
#line 2285
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2286
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2288
int be_cmd_get_fw_ver(struct be_adapter *adapter ) ;
#line 2289
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) ;
#line 2290
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , u32 domain ) ;
#line 2292
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) ;
#line 2293
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) ;
#line 2294
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) ;
#line 2295
int be_cmd_query_fw_cfg(struct be_adapter *adapter ) ;
#line 2296
int be_cmd_reset_function(struct be_adapter *adapter ) ;
#line 2297
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size , u8 const   *rss_hkey ) ;
#line 2299
int be_process_mcc(struct be_adapter *adapter ) ;
#line 2307
int be_cmd_query_sfp_info(struct be_adapter *adapter ) ;
#line 2308
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 img_offset , u32 buf_size ) ;
#line 2311
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) ;
#line 2319
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , u16 img_optype ,
                         u32 img_offset , u32 crc_offset ) ;
#line 2321
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) ;
#line 2323
int be_cmd_fw_init(struct be_adapter *adapter ) ;
#line 2324
int be_cmd_fw_clean(struct be_adapter *adapter ) ;
#line 2325
void be_async_mcc_enable(struct be_adapter *adapter ) ;
#line 2326
void be_async_mcc_disable(struct be_adapter *adapter ) ;
#line 2336
int be_cmd_get_phy_info(struct be_adapter *adapter ) ;
#line 2337
int be_cmd_config_qos(struct be_adapter *adapter , u32 max_rate , u16 link_speed ,
                      u8 domain ) ;
#line 2339
void be_detect_error(struct be_adapter *adapter ) ;
#line 2340
int be_cmd_get_die_temperature(struct be_adapter *adapter ) ;
#line 2341
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) ;
#line 2342
int be_cmd_req_native_mode(struct be_adapter *adapter ) ;
#line 2345
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) ;
#line 2347
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) ;
#line 2352
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) ;
#line 2354
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) ;
#line 2357
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) ;
#line 2358
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode , u8 spoofchk ) ;
#line 2360
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode , bool *spoofchk ) ;
#line 2362
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) ;
#line 2364
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) ;
#line 2370
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) ;
#line 2375
int be_cmd_query_port_name(struct be_adapter *adapter ) ;
#line 2376
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) ;
#line 2378
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 query , u8 domain ) ;
#line 2380
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) ;
#line 2381
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) ;
#line 2383
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) ;
#line 2384
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) ;
#line 2385
int be_cmd_set_logical_link_config(struct be_adapter *adapter , int link_state , u8 domain ) ;
#line 2387
int be_cmd_set_vxlan_port(struct be_adapter *adapter , __be16 port ) ;
#line 2388
int be_cmd_manage_iface(struct be_adapter *adapter , u32 iface , u8 op ) ;
#line 2389
int be_cmd_set_sriov_config(struct be_adapter *adapter , struct be_resources pool_res ,
                            u16 num_vfs___0 , u16 num_vf_qs ) ;
#line 42 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 43
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 44
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 121 "include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb , struct napi_struct *napi ) 
{ 


  {
#line 124
  skb->__annonCompField72.napi_id = napi->napi_id;
#line 125
  return;
}
}
#line 188 "include/net/vxlan.h"
extern void vxlan_get_rx_port(struct net_device * ) ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static unsigned int num_vfs  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static ushort rx_frag_size  =    2048U;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_device_id  const  be_dev_ids[9U]  = 
#line 44
  {      {6562U, 529U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 545U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1792U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1808U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57888U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57896U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1824U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1832U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
struct pci_device_id  const  __mod_pci__be_dev_ids_device_table[9U]  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static char const   * const  ue_status_low_desc[32U]  = 
#line 57
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "ERX2 ",      "SPARE ",      "JTAG ",      "MPU_INTPEND "};
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static char const   * const  ue_status_hi_desc[32U]  = 
#line 93
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "ECRC",      "Poison TLP",      "NETC", 
        "PERIPH",      "LLTXULP",      "D2P",      "RCON", 
        "LDMA",      "LLTXP",      "LLTXPB",      "Unknown"};
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_queue_free(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 130
  mem = & q->dma_mem;
#line 132
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 133
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
#line 135
    mem->va = (void *)0;
  } else {

  }
#line 137
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_queue_alloc(struct be_adapter *adapter , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 142
  mem = & q->dma_mem;
#line 144
  memset((void *)q, 0, 40UL);
#line 145
  q->len = len;
#line 146
  q->entry_size = entry_size;
#line 147
  mem->size = (u32 )((int )len * (int )entry_size);
#line 148
  mem->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )mem->size, & mem->dma,
                                208U);
#line 150
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 151
    return (-12);
  } else {

  }
#line 152
  return (0);
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_reg_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  u32 reg ;
  u32 enabled ;

  {
#line 159
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 252, & reg);
#line 161
  enabled = reg & 536870912U;
#line 163
  if (enabled == 0U && (int )enable) {
#line 164
    reg = reg | 536870912U;
  } else
#line 165
  if (enabled != 0U && ! enable) {
#line 166
    reg = reg & 3758096383U;
  } else {
#line 168
    return;
  }
#line 170
  pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 252, reg);
#line 171
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  int status ;
  u8 tmp ;

  {
#line 176
  status = 0;
#line 179
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 180
    return;
  } else {

  }
#line 182
  tmp = be_check_error(adapter, 1U);
#line 182
  if ((unsigned int )tmp != 0U) {
#line 183
    return;
  } else {

  }
#line 185
  status = be_cmd_intr_set(adapter, (int )enable);
#line 186
  if (status != 0) {
#line 187
    be_reg_intr_set(adapter, (int )enable);
  } else {

  }
#line 188
  return;
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rxq_notify(struct be_adapter *adapter , u16 qid , u16 posted ) 
{ 
  u32 val ;
  u8 tmp ;

  {
#line 192
  val = 0U;
#line 194
  tmp = be_check_error(adapter, 3U);
#line 194
  if ((unsigned int )tmp != 0U) {
#line 195
    return;
  } else {

  }
#line 197
  val = ((u32 )qid & 1023U) | val;
#line 198
  val = (u32 )((int )posted << 24) | val;
#line 200
  __asm__  volatile   ("sfence": : : "memory");
#line 201
  iowrite32(val, (void *)adapter->db + 256U);
#line 202
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_txq_notify(struct be_adapter *adapter , struct be_tx_obj *txo , u16 posted ) 
{ 
  u32 val ;
  u8 tmp ;

  {
#line 207
  val = 0U;
#line 209
  tmp = be_check_error(adapter, 3U);
#line 209
  if ((unsigned int )tmp != 0U) {
#line 210
    return;
  } else {

  }
#line 212
  val = ((u32 )txo->q.id & 2047U) | val;
#line 213
  val = (u32 )(((int )posted & 16383) << 16) | val;
#line 215
  __asm__  volatile   ("sfence": : : "memory");
#line 216
  iowrite32(val, (void *)adapter->db + (unsigned long )txo->db_offset);
#line 217
  return;
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eq_notify(struct be_adapter *adapter , u16 qid , bool arm , bool clear_int ,
                         u16 num_popped , u32 eq_delay_mult_enc ) 
{ 
  u32 val ;
  u8 tmp ;

  {
#line 223
  val = 0U;
#line 225
  val = ((u32 )qid & 511U) | val;
#line 226
  val = (u32 )(((int )qid & 15872) << 2) | val;
#line 228
  tmp = be_check_error(adapter, 3U);
#line 228
  if ((unsigned int )tmp != 0U) {
#line 229
    return;
  } else {

  }
#line 231
  if ((int )arm) {
#line 232
    val = val | 536870912U;
  } else {

  }
#line 233
  if ((int )clear_int) {
#line 234
    val = val | 512U;
  } else {

  }
#line 235
  val = val | 1024U;
#line 236
  val = (u32 )((int )num_popped << 16) | val;
#line 237
  val = (eq_delay_mult_enc << 30) | val;
#line 238
  iowrite32(val, (void *)adapter->db + 288U);
#line 239
  return;
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) 
{ 
  u32 val ;
  u8 tmp ;

  {
#line 243
  val = 0U;
#line 245
  val = ((u32 )qid & 1023U) | val;
#line 246
  val = (u32 )(((int )qid & 31744) << 1) | val;
#line 249
  tmp = be_check_error(adapter, 3U);
#line 249
  if ((unsigned int )tmp != 0U) {
#line 250
    return;
  } else {

  }
#line 252
  if ((int )arm) {
#line 253
    val = val | 536870912U;
  } else {

  }
#line 254
  val = (u32 )((int )num_popped << 16) | val;
#line 255
  iowrite32(val, (void *)adapter->db + 288U);
#line 256
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mac_addr_set(struct net_device *netdev , void *p ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  struct sockaddr *addr ;
  int status ;
  u8 mac[6U] ;
  u32 old_pmac_id ;
  u32 curr_pmac_id ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 260
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 260
  adapter = (struct be_adapter *)tmp;
#line 261
  dev = & (adapter->pdev)->dev;
#line 262
  addr = (struct sockaddr *)p;
#line 265
  old_pmac_id = *(adapter->pmac_id);
#line 265
  curr_pmac_id = 0U;
#line 267
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
#line 267
  if (tmp___0) {
#line 267
    tmp___1 = 0;
  } else {
#line 267
    tmp___1 = 1;
  }
#line 267
  if (tmp___1) {
#line 268
    return (-99);
  } else {

  }
#line 273
  tmp___2 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)netdev->dev_addr);
#line 273
  if ((int )tmp___2) {
#line 274
    return (0);
  } else {

  }
#line 282
  status = be_cmd_pmac_add(adapter, (u8 *)(& addr->sa_data), (u32 )adapter->if_handle,
                           adapter->pmac_id, 0U);
#line 284
  if (status == 0) {
#line 285
    curr_pmac_id = *(adapter->pmac_id);
#line 290
    if (*(adapter->pmac_id) != old_pmac_id) {
#line 291
      be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )old_pmac_id, 0U);
    } else {

    }
  } else {

  }
#line 298
  status = be_cmd_get_active_mac(adapter, curr_pmac_id, (u8 *)(& mac), (u32 )adapter->if_handle,
                                 1, 0U);
#line 300
  if (status != 0) {
#line 301
    goto err;
  } else {

  }
#line 306
  tmp___3 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)(& mac));
#line 306
  if (tmp___3) {
#line 306
    tmp___4 = 0;
  } else {
#line 306
    tmp___4 = 1;
  }
#line 306
  if (tmp___4) {
#line 307
    status = -1;
#line 308
    goto err;
  } else {

  }
#line 311
  memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 312
  _dev_info((struct device  const  *)dev, "MAC address changed to %pM\n", (u8 *)(& mac));
#line 313
  return (0);
  err: 
#line 315
  dev_warn((struct device  const  *)dev, "MAC address change to %pM failed\n", (char *)(& addr->sa_data));
#line 316
  return (status);
}
}
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void *hw_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_cmd_resp_get_stats_v0 *cmd ;
  struct be_cmd_resp_get_stats_v1 *cmd___0 ;
  struct be_cmd_resp_get_stats_v2 *cmd___1 ;

  {
#line 322
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 323
    cmd = (struct be_cmd_resp_get_stats_v0 *)adapter->stats_cmd.va;
#line 325
    return ((void *)(& cmd->hw_stats));
  } else
#line 326
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 327
    cmd___0 = (struct be_cmd_resp_get_stats_v1 *)adapter->stats_cmd.va;
#line 329
    return ((void *)(& cmd___0->hw_stats));
  } else {
#line 331
    cmd___1 = (struct be_cmd_resp_get_stats_v2 *)adapter->stats_cmd.va;
#line 333
    return ((void *)(& cmd___1->hw_stats));
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void *be_erx_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_hw_stats_v1 *hw_stats___0 ;
  void *tmp___0 ;
  struct be_hw_stats_v2 *hw_stats___1 ;
  void *tmp___1 ;

  {
#line 340
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 341
    tmp = hw_stats_from_cmd(adapter);
#line 341
    hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 343
    return ((void *)(& hw_stats->erx));
  } else
#line 344
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 345
    tmp___0 = hw_stats_from_cmd(adapter);
#line 345
    hw_stats___0 = (struct be_hw_stats_v1 *)tmp___0;
#line 347
    return ((void *)(& hw_stats___0->erx));
  } else {
#line 349
    tmp___1 = hw_stats_from_cmd(adapter);
#line 349
    hw_stats___1 = (struct be_hw_stats_v2 *)tmp___1;
#line 351
    return ((void *)(& hw_stats___1->erx));
  }
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v0_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v0 *rxf_stats ;
  struct be_port_rxf_stats_v0 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 357
  tmp = hw_stats_from_cmd(adapter);
#line 357
  hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 358
  pmem_sts = & hw_stats->pmem;
#line 359
  rxf_stats = & hw_stats->rxf;
#line 360
  port_stats = (struct be_port_rxf_stats_v0 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 362
  drvs = & adapter->drv_stats;
#line 364
  swap_dws((void *)hw_stats, 1060);
#line 365
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 366
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 367
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 368
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 369
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 370
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 371
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 372
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 373
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 374
  drvs->rxpp_fifo_overflow_drop = port_stats->rx_fifo_overflow;
#line 375
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 376
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 377
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 378
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 379
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow;
#line 380
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 382
  drvs->rx_address_filtered = port_stats->rx_address_filtered + port_stats->rx_vlan_filtered;
#line 385
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 388
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 389
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 391
  if (adapter->port_num != 0U) {
#line 392
    drvs->jabber_events = rxf_stats->port1_jabber_events;
  } else {
#line 394
    drvs->jabber_events = rxf_stats->port0_jabber_events;
  }
#line 395
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 396
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 397
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 398
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 399
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 400
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 401
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v1_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v1 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v1 *rxf_stats ;
  struct be_port_rxf_stats_v1 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 406
  tmp = hw_stats_from_cmd(adapter);
#line 406
  hw_stats = (struct be_hw_stats_v1 *)tmp;
#line 407
  pmem_sts = & hw_stats->pmem;
#line 408
  rxf_stats = & hw_stats->rxf;
#line 409
  port_stats = (struct be_port_rxf_stats_v1 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 411
  drvs = & adapter->drv_stats;
#line 413
  swap_dws((void *)hw_stats, 1848);
#line 414
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 415
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 416
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 417
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 418
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 419
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 420
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 421
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 422
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 423
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 424
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 425
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 426
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 427
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 428
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 429
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 431
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 433
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 434
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 436
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 437
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 438
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 439
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 440
  drvs->jabber_events = port_stats->jabber_events;
#line 441
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 442
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 443
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 444
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 445
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 446
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 447
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 448
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v2_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v2 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v2 *rxf_stats ;
  struct be_port_rxf_stats_v2 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 452
  tmp = hw_stats_from_cmd(adapter);
#line 452
  hw_stats = (struct be_hw_stats_v2 *)tmp;
#line 453
  pmem_sts = & hw_stats->pmem;
#line 454
  rxf_stats = & hw_stats->rxf;
#line 455
  port_stats = (struct be_port_rxf_stats_v2 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 457
  drvs = & adapter->drv_stats;
#line 459
  swap_dws((void *)hw_stats, 2680);
#line 460
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 461
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 462
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 463
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 464
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 465
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 466
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 467
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 468
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 469
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 470
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 471
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 472
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 473
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 474
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 475
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 477
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 479
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 480
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 482
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 483
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 484
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 485
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 486
  drvs->jabber_events = port_stats->jabber_events;
#line 487
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 488
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 489
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 490
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 491
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 492
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 493
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 494
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 495
    drvs->rx_roce_bytes_lsd = port_stats->roce_bytes_received_lsd;
#line 496
    drvs->rx_roce_bytes_msd = port_stats->roce_bytes_received_msd;
#line 497
    drvs->rx_roce_frames = port_stats->roce_frames_received;
#line 498
    drvs->roce_drops_crc = port_stats->roce_drops_crc;
#line 499
    drvs->roce_drops_payload_len = port_stats->roce_drops_payload_len;
  } else {

  }
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_lancer_stats(struct be_adapter *adapter ) 
{ 
  struct be_drv_stats *drvs ;
  struct lancer_pport_stats *pport_stats ;
  struct lancer_pport_stats *tmp ;

  {
#line 506
  drvs = & adapter->drv_stats;
#line 507
  tmp = pport_stats_from_cmd(adapter);
#line 507
  pport_stats = tmp;
#line 509
  swap_dws((void *)pport_stats, 656);
#line 510
  drvs->rx_pause_frames = pport_stats->rx_pause_frames_lo;
#line 511
  drvs->rx_crc_errors = pport_stats->rx_crc_errors_lo;
#line 512
  drvs->rx_control_frames = pport_stats->rx_control_frames_lo;
#line 513
  drvs->rx_in_range_errors = pport_stats->rx_in_range_errors;
#line 514
  drvs->rx_frame_too_long = pport_stats->rx_frames_too_long_lo;
#line 515
  drvs->rx_dropped_runt = pport_stats->rx_dropped_runt;
#line 516
  drvs->rx_ip_checksum_errs = pport_stats->rx_ip_checksum_errors;
#line 517
  drvs->rx_tcp_checksum_errs = pport_stats->rx_tcp_checksum_errors;
#line 518
  drvs->rx_udp_checksum_errs = pport_stats->rx_udp_checksum_errors;
#line 519
  drvs->rx_dropped_tcp_length = pport_stats->rx_dropped_invalid_tcp_length;
#line 521
  drvs->rx_dropped_too_small = pport_stats->rx_dropped_too_small;
#line 522
  drvs->rx_dropped_too_short = pport_stats->rx_dropped_too_short;
#line 523
  drvs->rx_out_range_errors = pport_stats->rx_out_of_range_errors;
#line 524
  drvs->rx_dropped_header_too_small = pport_stats->rx_dropped_header_too_small;
#line 526
  drvs->rx_input_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 527
  drvs->rx_address_filtered = pport_stats->rx_address_filtered + pport_stats->rx_vlan_filtered;
#line 530
  drvs->rx_alignment_symbol_errors = pport_stats->rx_symbol_errors_lo;
#line 531
  drvs->rxpp_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 532
  drvs->tx_pauseframes = pport_stats->tx_pause_frames_lo;
#line 533
  drvs->tx_controlframes = pport_stats->tx_control_frames_lo;
#line 534
  drvs->jabber_events = pport_stats->rx_jabbers;
#line 535
  drvs->forwarded_packets = pport_stats->num_forwards_lo;
#line 536
  drvs->rx_drops_mtu = pport_stats->rx_drops_mtu_lo;
#line 537
  drvs->rx_drops_too_many_frags = pport_stats->rx_drops_too_many_frags_lo;
#line 539
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void accumulate_16bit_val(u32 *acc , u16 val ) 
{ 
  bool wrapped ;
  u32 newacc ;
  u32 __var ;

  {
#line 545
  wrapped = (u32 )val < (*acc & 65535U);
#line 546
  newacc = (*acc & 4294901760U) + (u32 )val;
#line 548
  if ((int )wrapped) {
#line 549
    newacc = newacc + 65536U;
  } else {

  }
#line 550
  __var = 0U;
#line 550
  *((u32 volatile   *)acc) = newacc;
#line 551
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_erx_stats(struct be_adapter *adapter , struct be_rx_obj *rxo ,
                               u32 erx_stat ) 
{ 


  {
#line 556
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 557
    rxo->stats.rx_drops_no_frags = erx_stat;
  } else {
#line 562
    accumulate_16bit_val(& rxo->stats.rx_drops_no_frags, (int )((unsigned short )erx_stat));
  }
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
void be_parse_stats(struct be_adapter *adapter ) 
{ 
  struct be_erx_stats_v2 *erx ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  int i ;
  u32 erx_stat ;

  {
#line 568
  tmp = be_erx_stats_from_cmd(adapter);
#line 568
  erx = (struct be_erx_stats_v2 *)tmp;
#line 573
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 574
    populate_lancer_stats(adapter);
  } else {
#line 576
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 577
      populate_be_v0_stats(adapter);
    } else
#line 578
    if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 580
      populate_be_v1_stats(adapter);
    } else {
#line 582
      populate_be_v2_stats(adapter);
    }
#line 585
    i = 0;
#line 585
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 585
    goto ldv_57731;
    ldv_57730: 
#line 586
    erx_stat = erx->rx_drops_no_fragments[(int )rxo->q.id];
#line 587
    populate_erx_stats(adapter, rxo, erx_stat);
#line 585
    i = i + 1;
#line 585
    rxo = rxo + 1;
    ldv_57731: ;
#line 585
    if ((int )adapter->num_rx_qs > i) {
#line 587
      goto ldv_57730;
    } else {

    }

  }
#line 593
  return;
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct rtnl_link_stats64 *be_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_drv_stats *drvs ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 pkts ;
  u64 bytes ;
  unsigned int start ;
  int i ;
  struct be_rx_stats  const  *rx_stats ;
  bool tmp___0 ;
  struct be_tx_stats  const  *tx_stats ;
  bool tmp___1 ;

  {
#line 595
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 595
  adapter = (struct be_adapter *)tmp;
#line 596
  drvs = & adapter->drv_stats;
#line 603
  i = 0;
#line 603
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 603
  goto ldv_57749;
  ldv_57748: 
#line 604
  rx_stats = (struct be_rx_stats  const  *)(& rxo->stats);
  ldv_57746: 
#line 607
  start = u64_stats_fetch_begin_irq(& rx_stats->sync);
#line 608
  pkts = rxo->stats.rx_pkts;
#line 609
  bytes = rxo->stats.rx_bytes;
#line 610
  tmp___0 = u64_stats_fetch_retry_irq(& rx_stats->sync, start);
#line 610
  if ((int )tmp___0) {
#line 612
    goto ldv_57746;
  } else {

  }
#line 611
  stats->rx_packets = stats->rx_packets + pkts;
#line 612
  stats->rx_bytes = stats->rx_bytes + bytes;
#line 613
  stats->multicast = stats->multicast + (__u64 )rxo->stats.rx_mcast_pkts;
#line 614
  stats->rx_dropped = stats->rx_dropped + (__u64 )(rxo->stats.rx_drops_no_skbs + rxo->stats.rx_drops_no_frags);
#line 603
  i = i + 1;
#line 603
  rxo = rxo + 1;
  ldv_57749: ;
#line 603
  if ((int )adapter->num_rx_qs > i) {
#line 605
    goto ldv_57748;
  } else {

  }
#line 618
  i = 0;
#line 618
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 618
  goto ldv_57755;
  ldv_57754: 
#line 619
  tx_stats = (struct be_tx_stats  const  *)(& txo->stats);
  ldv_57752: 
#line 622
  start = u64_stats_fetch_begin_irq(& tx_stats->sync);
#line 623
  pkts = txo->stats.tx_pkts;
#line 624
  bytes = txo->stats.tx_bytes;
#line 625
  tmp___1 = u64_stats_fetch_retry_irq(& tx_stats->sync, start);
#line 625
  if ((int )tmp___1) {
#line 627
    goto ldv_57752;
  } else {

  }
#line 626
  stats->tx_packets = stats->tx_packets + pkts;
#line 627
  stats->tx_bytes = stats->tx_bytes + bytes;
#line 618
  i = i + 1;
#line 618
  txo = txo + 1;
  ldv_57755: ;
#line 618
  if ((int )adapter->num_tx_qs > i) {
#line 620
    goto ldv_57754;
  } else {

  }
#line 631
  stats->rx_errors = (__u64 )(((((((((drvs->rx_crc_errors + drvs->rx_alignment_symbol_errors) + drvs->rx_in_range_errors) + drvs->rx_out_range_errors) + drvs->rx_frame_too_long) + drvs->rx_dropped_too_small) + drvs->rx_dropped_too_short) + drvs->rx_dropped_header_too_small) + drvs->rx_dropped_tcp_length) + drvs->rx_dropped_runt);
#line 643
  stats->rx_length_errors = (__u64 )((drvs->rx_in_range_errors + drvs->rx_out_range_errors) + drvs->rx_frame_too_long);
#line 647
  stats->rx_crc_errors = (__u64 )drvs->rx_crc_errors;
#line 650
  stats->rx_frame_errors = (__u64 )drvs->rx_alignment_symbol_errors;
#line 654
  stats->rx_fifo_errors = (__u64 )((drvs->rxpp_fifo_overflow_drop + drvs->rx_input_fifo_overflow_drop) + drvs->rx_drops_no_pbuf);
#line 657
  return (stats);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) 
{ 
  struct net_device *netdev ;

  {
#line 662
  netdev = adapter->netdev;
#line 664
  if (((unsigned long )adapter->flags & 2UL) == 0UL) {
#line 665
    netif_carrier_off(netdev);
#line 666
    adapter->flags = adapter->flags | 2U;
  } else {

  }
#line 669
  if ((unsigned int )link_status != 0U) {
#line 670
    netif_carrier_on(netdev);
  } else {
#line 672
    netif_carrier_off(netdev);
  }
#line 674
  netdev_info((struct net_device  const  *)netdev, "Link is %s\n", (unsigned int )link_status != 0U ? (char *)"Up" : (char *)"Down");
#line 675
  return;
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_stats_update(struct be_tx_obj *txo , struct sk_buff *skb ) 
{ 
  struct be_tx_stats *stats ;
  unsigned char *tmp___0 ;
  u64 tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 679
  stats = & txo->stats;
#line 681
  u64_stats_init(& stats->sync);
#line 682
  stats->tx_reqs = stats->tx_reqs + 1ULL;
#line 683
  stats->tx_bytes = stats->tx_bytes + (u64 )skb->len;
#line 684
  tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 684
  if ((int )((struct skb_shared_info *)tmp___2)->gso_segs != 0) {
#line 684
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 684
    tmp___1 = (u64 )((int )((struct skb_shared_info *)tmp___0)->gso_segs);
  } else {
#line 684
    tmp___1 = 1ULL;
  }
#line 684
  stats->tx_pkts = stats->tx_pkts + tmp___1;
#line 685
  u64_stats_init(& stats->sync);
#line 686
  return;
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u32 skb_wrb_cnt(struct sk_buff *skb ) 
{ 
  unsigned int tmp ;
  unsigned char *tmp___0 ;

  {
#line 692
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 692
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 692
  return ((u32 )((tmp != 0U ? 2 : 1) + (int )((struct skb_shared_info *)tmp___0)->nr_frags));
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void wrb_fill(struct be_eth_wrb *wrb , u64 addr , int len ) 
{ 


  {
#line 697
  wrb->frag_pa_hi = (unsigned int )(addr >> 32ULL);
#line 698
  wrb->frag_pa_lo = (unsigned int )addr;
#line 699
  wrb->frag_len = (unsigned int )len & 65535U;
#line 700
  wrb->rsvd0 = 0U;
#line 701
  return;
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void wrb_fill_dummy(struct be_eth_wrb *wrb ) 
{ 


  {
#line 708
  wrb->frag_pa_hi = 0U;
#line 709
  wrb->frag_pa_lo = 0U;
#line 710
  wrb->frag_len = 0U;
#line 711
  wrb->rsvd0 = 0U;
#line 712
  return;
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static u16 be_get_tx_vlan_tag(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  u8 vlan_prio ;
  u16 vlan_tag ;

  {
#line 720
  vlan_tag = (unsigned int )skb->vlan_tci & 61439U;
#line 721
  vlan_prio = (u8 )((int )vlan_tag >> 13);
#line 723
  if ((((int )adapter->vlan_prio_bmap >> (int )vlan_prio) & 1) == 0) {
#line 724
    vlan_tag = (u16 )(((int )((short )vlan_tag) & 8191) | (int )((short )adapter->recommended_prio));
  } else {

  }
#line 727
  return (vlan_tag);
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 skb_inner_ip_proto(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp___0 ;
  struct ipv6hdr *tmp___1 ;
  int tmp___2 ;
  struct iphdr *tmp___3 ;

  {
#line 733
  tmp___3 = inner_ip_hdr((struct sk_buff  const  *)skb);
#line 733
  if ((unsigned int )*((unsigned char *)tmp___3 + 0UL) == 64U) {
#line 733
    tmp___0 = inner_ip_hdr((struct sk_buff  const  *)skb);
#line 733
    tmp___2 = (u16 )tmp___0->protocol;
  } else {
#line 733
    tmp___1 = inner_ipv6_hdr((struct sk_buff  const  *)skb);
#line 733
    tmp___2 = (u16 )tmp___1->nexthdr;
  }
#line 733
  return (tmp___2);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 skb_ip_proto(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp___0 ;
  struct ipv6hdr *tmp___1 ;
  int tmp___2 ;
  struct iphdr *tmp___3 ;

  {
#line 739
  tmp___3 = ip_hdr((struct sk_buff  const  *)skb);
#line 739
  if ((unsigned int )*((unsigned char *)tmp___3 + 0UL) == 64U) {
#line 739
    tmp___0 = ip_hdr((struct sk_buff  const  *)skb);
#line 739
    tmp___2 = (u16 )tmp___0->protocol;
  } else {
#line 739
    tmp___1 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 739
    tmp___2 = (u16 )tmp___1->nexthdr;
  }
#line 739
  return (tmp___2);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_is_txq_full(struct be_tx_obj *txo ) 
{ 
  int tmp ;

  {
#line 745
  tmp = atomic_read((atomic_t const   *)(& txo->q.used));
#line 745
  return (tmp + 30 >= (int )txo->q.len);
}
}
#line 748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_can_txq_wake(struct be_tx_obj *txo ) 
{ 
  int tmp ;

  {
#line 750
  tmp = atomic_read((atomic_t const   *)(& txo->q.used));
#line 750
  return (tmp < (int )((unsigned int )txo->q.len / 2U));
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_is_tx_compl_pending(struct be_tx_obj *txo ) 
{ 
  int tmp ;

  {
#line 755
  tmp = atomic_read((atomic_t const   *)(& txo->q.used));
#line 755
  return (tmp > (int )txo->pend_wrb_cnt);
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_get_wrb_params_from_skb(struct be_adapter *adapter , struct sk_buff *skb ,
                                       struct be_wrb_params *wrb_params ) 
{ 
  u16 proto ;
  unsigned char *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 764
  tmp___1 = skb_is_gso((struct sk_buff  const  *)skb);
#line 764
  if ((int )tmp___1) {
#line 765
    wrb_params->features = wrb_params->features | 16U;
#line 766
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 766
    wrb_params->lso_mss = ((struct skb_shared_info *)tmp)->gso_size;
#line 767
    tmp___0 = skb_is_gso_v6((struct sk_buff  const  *)skb);
#line 767
    if ((int )tmp___0 && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 768
      wrb_params->features = wrb_params->features | 32U;
    } else {

    }
  } else
#line 769
  if ((unsigned int )*((unsigned char *)skb + 145UL) == 6U) {
#line 770
    if ((unsigned int )*((unsigned char *)skb + 146UL) != 0U) {
#line 771
      wrb_params->features = wrb_params->features | 2U;
#line 772
      proto = skb_inner_ip_proto(skb);
    } else {
#line 774
      proto = skb_ip_proto(skb);
    }
#line 776
    if ((unsigned int )proto == 6U) {
#line 777
      wrb_params->features = wrb_params->features | 4U;
    } else
#line 778
    if ((unsigned int )proto == 17U) {
#line 779
      wrb_params->features = wrb_params->features | 8U;
    } else {

    }
  } else {

  }
#line 782
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 783
    wrb_params->features = wrb_params->features | 64U;
#line 784
    wrb_params->vlan_tag = be_get_tx_vlan_tag(adapter, skb);
  } else {

  }
#line 787
  wrb_params->features = wrb_params->features | 1U;
#line 788
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void wrb_fill_hdr(struct be_adapter *adapter , struct be_eth_hdr_wrb *hdr ,
                         struct be_wrb_params *wrb_params , struct sk_buff *skb ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;

  {
#line 795
  memset((void *)hdr, 0, 16UL);
#line 797
  tmp = amap_mask(1U);
#line 797
  amap_set((void *)hdr, 2U, tmp, 2U, wrb_params->features & 1U);
#line 799
  tmp___0 = amap_mask(1U);
#line 799
  amap_set((void *)hdr, 2U, tmp___0, 6U, (u32 )(((unsigned long )wrb_params->features & 2UL) >> 1));
#line 801
  tmp___1 = amap_mask(1U);
#line 801
  amap_set((void *)hdr, 2U, tmp___1, 8U, (u32 )(((unsigned long )wrb_params->features & 4UL) >> 2));
#line 803
  tmp___2 = amap_mask(1U);
#line 803
  amap_set((void *)hdr, 2U, tmp___2, 7U, (u32 )(((unsigned long )wrb_params->features & 8UL) >> 3));
#line 806
  tmp___3 = amap_mask(1U);
#line 806
  amap_set((void *)hdr, 2U, tmp___3, 9U, (u32 )(((unsigned long )wrb_params->features & 16UL) >> 4));
#line 808
  tmp___4 = amap_mask(1U);
#line 808
  amap_set((void *)hdr, 2U, tmp___4, 4U, (u32 )(((unsigned long )wrb_params->features & 32UL) >> 5));
#line 810
  tmp___5 = amap_mask(14U);
#line 810
  amap_set((void *)hdr, 2U, tmp___5, 18U, (u32 )wrb_params->lso_mss);
#line 815
  tmp___6 = amap_mask(1U);
#line 815
  amap_set((void *)hdr, 2U, tmp___6, 1U, (u32 )(((unsigned long )wrb_params->features & 128UL) >> 7));
#line 817
  tmp___7 = amap_mask(1U);
#line 817
  amap_set((void *)hdr, 2U, tmp___7, 10U, (u32 )(((unsigned long )wrb_params->features & 64UL) >> 6));
#line 819
  tmp___8 = amap_mask(16U);
#line 819
  amap_set((void *)hdr, 3U, tmp___8, 16U, (u32 )wrb_params->vlan_tag);
#line 821
  tmp___9 = skb_wrb_cnt(skb);
#line 821
  tmp___10 = amap_mask(5U);
#line 821
  amap_set((void *)hdr, 2U, tmp___10, 13U, tmp___9);
#line 822
  tmp___11 = amap_mask(16U);
#line 822
  amap_set((void *)hdr, 3U, tmp___11, 0U, skb->len);
#line 823
  tmp___12 = amap_mask(1U);
#line 823
  amap_set((void *)hdr, 2U, tmp___12, 5U, (u32 )(((unsigned long )wrb_params->features & 256UL) >> 8));
#line 824
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void unmap_tx_frag(struct device *dev , struct be_eth_wrb *wrb , bool unmap_single ) 
{ 
  dma_addr_t dma ;
  u32 frag_len ;

  {
#line 831
  frag_len = wrb->frag_len;
#line 834
  dma = ((unsigned long long )wrb->frag_pa_hi << 32) | (unsigned long long )wrb->frag_pa_lo;
#line 836
  if (frag_len != 0U) {
#line 837
    if ((int )unmap_single) {
#line 838
      dma_unmap_single_attrs(dev, dma, (size_t )frag_len, 1, (struct dma_attrs *)0);
    } else {
#line 840
      dma_unmap_page(dev, dma, (size_t )frag_len, 1);
    }
  } else {

  }
#line 841
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 be_tx_get_wrb_hdr(struct be_tx_obj *txo ) 
{ 
  u16 head ;

  {
#line 847
  head = txo->q.head;
#line 849
  queue_head_inc(& txo->q);
#line 850
  return (head);
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_setup_wrb_hdr(struct be_adapter *adapter , struct be_tx_obj *txo ,
                                struct be_wrb_params *wrb_params , struct sk_buff *skb ,
                                u16 head ) 
{ 
  u32 num_frags ;
  u32 tmp ;
  struct be_queue_info *txq ;
  struct be_eth_hdr_wrb *hdr ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 859
  tmp = skb_wrb_cnt(skb);
#line 859
  num_frags = tmp;
#line 860
  txq = & txo->q;
#line 861
  tmp___0 = queue_index_node(txq, (int )head);
#line 861
  hdr = (struct be_eth_hdr_wrb *)tmp___0;
#line 863
  wrb_fill_hdr(adapter, hdr, wrb_params, skb);
#line 864
  swap_dws((void *)hdr, 16);
#line 866
  tmp___1 = ldv__builtin_expect((unsigned long )txo->sent_skb_list[(int )head] != (unsigned long )((struct sk_buff *)0),
                             0L);
#line 866
  if (tmp___1 != 0L) {
#line 866
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (866), "i" (12UL));
    ldv_57832: ;
#line 866
    goto ldv_57832;
  } else {

  }
#line 867
  txo->sent_skb_list[(int )head] = skb;
#line 868
  txo->last_req_hdr = head;
#line 869
  atomic_add((int )num_frags, & txq->used);
#line 870
  txo->last_req_wrb_cnt = (u16 )num_frags;
#line 871
  txo->pend_wrb_cnt = (int )txo->pend_wrb_cnt + (int )((u16 )num_frags);
#line 872
  return;
}
}
#line 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_setup_wrb_frag(struct be_tx_obj *txo , dma_addr_t busaddr , int len ) 
{ 
  struct be_eth_wrb *wrb ;
  struct be_queue_info *txq ;
  void *tmp ;

  {
#line 879
  txq = & txo->q;
#line 881
  tmp = queue_head_node(txq);
#line 881
  wrb = (struct be_eth_wrb *)tmp;
#line 882
  wrb_fill(wrb, busaddr, len);
#line 883
  queue_head_inc(txq);
#line 884
  return;
}
}
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_xmit_restore(struct be_adapter *adapter , struct be_tx_obj *txo , u16 head ,
                            bool map_single , u32 copied ) 
{ 
  struct device *dev ;
  struct be_eth_wrb *wrb ;
  struct be_queue_info *txq ;
  void *tmp ;

  {
#line 896
  txq = & txo->q;
#line 898
  dev = & (adapter->pdev)->dev;
#line 899
  txq->head = head;
#line 902
  queue_head_inc(txq);
#line 903
  goto ldv_57851;
  ldv_57850: 
#line 904
  tmp = queue_head_node(txq);
#line 904
  wrb = (struct be_eth_wrb *)tmp;
#line 905
  unmap_tx_frag(dev, wrb, (int )map_single);
#line 906
  map_single = 0;
#line 907
  copied = copied - wrb->frag_len;
#line 908
  queue_head_inc(txq);
  ldv_57851: ;
#line 903
  if (copied != 0U) {
#line 905
    goto ldv_57850;
  } else {

  }
#line 911
  txq->head = head;
#line 912
  return;
}
}
#line 918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u32 be_xmit_enqueue(struct be_adapter *adapter , struct be_tx_obj *txo , struct sk_buff *skb ,
                           struct be_wrb_params *wrb_params ) 
{ 
  u32 i ;
  u32 copied ;
  u32 wrb_cnt ;
  u32 tmp ;
  struct device *dev ;
  struct be_queue_info *txq ;
  bool map_single ;
  u16 head ;
  dma_addr_t busaddr ;
  int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  struct skb_frag_struct  const  *frag ;
  unsigned char *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 922
  copied = 0U;
#line 922
  tmp = skb_wrb_cnt(skb);
#line 922
  wrb_cnt = tmp;
#line 923
  dev = & (adapter->pdev)->dev;
#line 924
  txq = & txo->q;
#line 925
  map_single = 0;
#line 926
  head = txq->head;
#line 930
  head = be_tx_get_wrb_hdr(txo);
#line 932
  if (skb->len > skb->data_len) {
#line 933
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 933
    len = (int )tmp___0;
#line 935
    busaddr = dma_map_single_attrs(dev, (void *)skb->data, (size_t )len, 1, (struct dma_attrs *)0);
#line 936
    tmp___1 = dma_mapping_error(dev, busaddr);
#line 936
    if (tmp___1 != 0) {
#line 937
      goto dma_err;
    } else {

    }
#line 938
    map_single = 1;
#line 939
    be_tx_setup_wrb_frag(txo, busaddr, len);
#line 940
    copied = copied + (u32 )len;
  } else {

  }
#line 943
  i = 0U;
#line 943
  goto ldv_57871;
  ldv_57870: 
#line 944
  tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 944
  frag = (struct skb_frag_struct  const  *)(& ((struct skb_shared_info *)tmp___2)->frags) + (unsigned long )i;
#line 945
  tmp___3 = skb_frag_size(frag);
#line 945
  len = (int )tmp___3;
#line 947
  busaddr = skb_frag_dma_map(dev, frag, 0UL, (size_t )len, 1);
#line 948
  tmp___4 = dma_mapping_error(dev, busaddr);
#line 948
  if (tmp___4 != 0) {
#line 949
    goto dma_err;
  } else {

  }
#line 950
  be_tx_setup_wrb_frag(txo, busaddr, len);
#line 951
  copied = copied + (u32 )len;
#line 943
  i = i + 1U;
  ldv_57871: 
#line 943
  tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 943
  if ((u32 )((struct skb_shared_info *)tmp___5)->nr_frags > i) {
#line 945
    goto ldv_57870;
  } else {

  }
#line 954
  be_tx_setup_wrb_hdr(adapter, txo, wrb_params, skb, (int )head);
#line 956
  be_tx_stats_update(txo, skb);
#line 957
  return (wrb_cnt);
  dma_err: 
#line 960
  adapter->drv_stats.dma_map_errors = adapter->drv_stats.dma_map_errors + 1U;
#line 961
  be_xmit_restore(adapter, txo, (int )head, (int )map_single, copied);
#line 962
  return (0U);
}
}
#line 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int qnq_async_evt_rcvd(struct be_adapter *adapter ) 
{ 


  {
#line 967
  return ((int )adapter->flags & 128);
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_insert_vlan_in_pkt(struct be_adapter *adapter , struct sk_buff *skb ,
                                             struct be_wrb_params *wrb_params ) 
{ 
  u16 vlan_tag ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 975
  vlan_tag = 0U;
#line 977
  skb = skb_share_check(skb, 32U);
#line 978
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 978
  if (tmp != 0L) {
#line 979
    return (skb);
  } else {

  }
#line 981
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 982
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
  } else {

  }
#line 984
  tmp___0 = qnq_async_evt_rcvd(adapter);
#line 984
  if (tmp___0 != 0 && (unsigned int )adapter->pvid != 0U) {
#line 985
    if ((unsigned int )vlan_tag == 0U) {
#line 986
      vlan_tag = adapter->pvid;
    } else {

    }
#line 990
    wrb_params->features = wrb_params->features | 128U;
  } else {

  }
#line 993
  if ((unsigned int )vlan_tag != 0U) {
#line 994
    skb = vlan_insert_tag_set_proto(skb, 129, (int )vlan_tag);
#line 996
    tmp___1 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 996
    if (tmp___1 != 0L) {
#line 997
      return (skb);
    } else {

    }
#line 998
    skb->vlan_tci = 0U;
  } else {

  }
#line 1002
  if ((unsigned int )adapter->qnq_vid != 0U) {
#line 1003
    vlan_tag = adapter->qnq_vid;
#line 1004
    skb = vlan_insert_tag_set_proto(skb, 129, (int )vlan_tag);
#line 1006
    tmp___2 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 1006
    if (tmp___2 != 0L) {
#line 1007
      return (skb);
    } else {

    }
#line 1008
    wrb_params->features = wrb_params->features | 128U;
  } else {

  }
#line 1011
  return (skb);
}
}
#line 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_ipv6_exthdr_check(struct sk_buff *skb ) 
{ 
  struct ethhdr *eh ;
  u16 offset ;
  struct ipv6hdr *ip6h ;
  struct ipv6_opt_hdr *ehdr ;

  {
#line 1016
  eh = (struct ethhdr *)skb->data;
#line 1017
  offset = 14U;
#line 1019
  if ((unsigned int )eh->h_proto == 56710U) {
#line 1020
    ip6h = (struct ipv6hdr *)skb->data + (unsigned long )offset;
#line 1022
    offset = (unsigned int )offset + 40U;
#line 1023
    if ((unsigned int )ip6h->nexthdr != 6U && (unsigned int )ip6h->nexthdr != 17U) {
#line 1025
      ehdr = (struct ipv6_opt_hdr *)skb->data + (unsigned long )offset;
#line 1029
      if ((unsigned int )ehdr->hdrlen == 255U) {
#line 1030
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1033
  return (0);
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_tag_tx_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 


  {
#line 1038
  return ((((int )skb->vlan_tci & 4096) != 0 || (unsigned int )adapter->pvid != 0U) || (unsigned int )adapter->qnq_vid != 0U);
}
}
#line 1041 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ipv6_tx_stall_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 1043
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 1043
    tmp = be_ipv6_exthdr_check(skb);
#line 1043
    if ((int )tmp) {
#line 1043
      tmp___0 = 1;
    } else {
#line 1043
      tmp___0 = 0;
    }
  } else {
#line 1043
    tmp___0 = 0;
  }
#line 1043
  return (tmp___0);
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_lancer_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                                  struct be_wrb_params *wrb_params ) 
{ 
  struct vlan_ethhdr *veh ;
  unsigned int eth_hdr_len ;
  struct iphdr *ip ;
  __u16 tmp ;
  __u16 tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1051
  veh = (struct vlan_ethhdr *)skb->data;
#line 1059
  tmp = __fswab16((int )skb->protocol);
#line 1059
  eth_hdr_len = (unsigned int )tmp == 33024U ? 18U : 14U;
#line 1061
  if (skb->len <= 60U && (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || ((int )skb->vlan_tci & 4096) != 0)) {
#line 1061
    tmp___1 = is_ipv4_pkt(skb);
#line 1061
    if ((int )tmp___1) {
#line 1064
      ip = ip_hdr((struct sk_buff  const  *)skb);
#line 1065
      tmp___0 = __fswab16((int )ip->tot_len);
#line 1065
      pskb_trim(skb, (unsigned int )tmp___0 + eth_hdr_len);
    } else {

    }
  } else {

  }
#line 1071
  if ((unsigned int )adapter->pvid != 0U && (unsigned int )veh->h_vlan_proto == 129U) {
#line 1073
    wrb_params->features = wrb_params->features | 128U;
  } else {

  }
#line 1079
  if ((unsigned int )*((unsigned char *)skb + 145UL) != 6U && ((int )skb->vlan_tci & 4096) != 0) {
#line 1081
    skb = be_insert_vlan_in_pkt(adapter, skb, wrb_params);
#line 1082
    tmp___2 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 1082
    if (tmp___2 != 0L) {
#line 1083
      goto err;
    } else {

    }
  } else {

  }
#line 1090
  tmp___3 = be_ipv6_tx_stall_chk(adapter, skb);
#line 1090
  if (tmp___3 != 0 && ((unsigned int )adapter->pvid != 0U || (unsigned int )adapter->qnq_vid != 0U)) {
#line 1090
    tmp___4 = qnq_async_evt_rcvd(adapter);
#line 1090
    if (tmp___4 == 0) {
#line 1090
      tmp___5 = 1;
    } else {
#line 1090
      tmp___5 = 0;
    }
  } else {
#line 1090
    tmp___5 = 0;
  }
#line 1090
  tmp___6 = ldv__builtin_expect((long )tmp___5, 0L);
#line 1090
  if (tmp___6 != 0L) {
#line 1093
    goto tx_drop;
  } else {

  }
#line 1101
  tmp___8 = be_ipv6_tx_stall_chk(adapter, skb);
#line 1101
  if (tmp___8 != 0) {
#line 1101
    tmp___9 = be_vlan_tag_tx_chk(adapter, skb);
#line 1101
    if (tmp___9 != 0) {
#line 1103
      skb = be_insert_vlan_in_pkt(adapter, skb, wrb_params);
#line 1104
      tmp___7 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                                 0L);
#line 1104
      if (tmp___7 != 0L) {
#line 1105
        goto err;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1108
  return (skb);
  tx_drop: 
#line 1110
  dev_kfree_skb_any(skb);
  err: ;
#line 1112
  return ((struct sk_buff *)0);
}
}
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                           struct be_wrb_params *wrb_params ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 1123
  tmp___0 = ldv__builtin_expect((long )((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && skb->len <= 32U),
                             0L);
#line 1123
  if (tmp___0 != 0L) {
#line 1124
    tmp = skb_put_padto(skb, 36U);
#line 1124
    if (tmp != 0) {
#line 1125
      return ((struct sk_buff *)0);
    } else {

    }
  } else {

  }
#line 1128
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 1129
    skb = be_lancer_xmit_workarounds(adapter, skb, wrb_params);
#line 1130
    if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1131
      return ((struct sk_buff *)0);
    } else {

    }
  } else {

  }
#line 1134
  return (skb);
}
}
#line 1137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_xmit_flush(struct be_adapter *adapter , struct be_tx_obj *txo ) 
{ 
  struct be_queue_info *txq ;
  struct be_eth_hdr_wrb *hdr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1139
  txq = & txo->q;
#line 1140
  tmp = queue_index_node(txq, (int )txo->last_req_hdr);
#line 1140
  hdr = (struct be_eth_hdr_wrb *)tmp;
#line 1143
  if ((hdr->dw[2] & 2U) == 0U) {
#line 1144
    hdr->dw[2] = hdr->dw[2] | 3U;
  } else {

  }
#line 1147
  if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (int )txo->pend_wrb_cnt & 1) {
#line 1148
    tmp___0 = queue_head_node(txq);
#line 1148
    wrb_fill_dummy((struct be_eth_wrb *)tmp___0);
#line 1149
    queue_head_inc(txq);
#line 1150
    atomic_inc(& txq->used);
#line 1151
    txo->pend_wrb_cnt = (u16 )((int )txo->pend_wrb_cnt + 1);
#line 1152
    hdr->dw[2] = hdr->dw[2] & 4294713343U;
#line 1154
    hdr->dw[2] = hdr->dw[2] | (__le32 )(((int )txo->last_req_wrb_cnt + 1) << 13);
  } else {

  }
#line 1157
  be_txq_notify(adapter, txo, (int )txo->pend_wrb_cnt);
#line 1158
  txo->pend_wrb_cnt = 0U;
#line 1159
  return;
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_send_pkt_to_bmc(struct be_adapter *adapter , struct sk_buff **skb ) 
{ 
  struct ethhdr *eh ;
  bool os2bmc ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  struct ipv6hdr *hdr ;
  struct ipv6hdr *tmp___5 ;
  u8 nexthdr ;
  struct icmp6hdr *icmp6 ;
  struct icmp6hdr *tmp___6 ;
  struct udphdr *udp ;
  struct udphdr *tmp___7 ;
  u8 tmp___8 ;

  {
#line 1218
  eh = (struct ethhdr *)(*skb)->data;
#line 1219
  os2bmc = 0;
#line 1221
  if (((unsigned long )adapter->flags & 4096UL) == 0UL) {
#line 1222
    goto done;
  } else {

  }
#line 1224
  tmp = is_multicast_ether_addr((u8 const   *)(& eh->h_dest));
#line 1224
  if (tmp) {
#line 1224
    tmp___0 = 0;
  } else {
#line 1224
    tmp___0 = 1;
  }
#line 1224
  if (tmp___0) {
#line 1225
    goto done;
  } else {

  }
#line 1227
  if (((unsigned long )adapter->bmc_filt_mask & 32768UL) == 0UL) {
#line 1227
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& eh->h_dest));
#line 1227
    if ((int )tmp___1) {
#line 1227
      tmp___2 = is_broadcast_ether_addr((u8 const   *)(& eh->h_dest));
#line 1227
      if (tmp___2) {
#line 1227
        tmp___3 = 0;
      } else {
#line 1227
        tmp___3 = 1;
      }
#line 1227
      if (tmp___3) {
#line 1230
        os2bmc = 1;
#line 1231
        goto done;
      } else {
#line 1227
        goto _L___1;
      }
    } else {
#line 1227
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1227
  if (((unsigned long )adapter->bmc_filt_mask & 128UL) == 0UL) {
#line 1227
    tmp___4 = is_broadcast_ether_addr((u8 const   *)(& eh->h_dest));
#line 1227
    if ((int )tmp___4) {
#line 1230
      os2bmc = 1;
#line 1231
      goto done;
    } else {
#line 1227
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1227
  if ((unsigned int )(*skb)->protocol == 1544U && (int )adapter->bmc_filt_mask & 1) {
#line 1230
    os2bmc = 1;
#line 1231
    goto done;
  } else {

  }
#line 1234
  if ((unsigned int )(*skb)->protocol == 56710U) {
#line 1235
    tmp___5 = ipv6_hdr((struct sk_buff  const  *)*skb);
#line 1235
    hdr = tmp___5;
#line 1236
    nexthdr = hdr->nexthdr;
#line 1238
    if ((unsigned int )nexthdr == 58U) {
#line 1239
      tmp___6 = icmp6_hdr((struct sk_buff  const  *)*skb);
#line 1239
      icmp6 = tmp___6;
#line 1241
      switch ((int )icmp6->icmp6_type) {
      case 134: 
#line 1243
      os2bmc = ((unsigned long )adapter->bmc_filt_mask & 512UL) != 0UL;
#line 1244
      goto done;
      case 136: 
#line 1246
      os2bmc = ((unsigned long )adapter->bmc_filt_mask & 256UL) != 0UL;
#line 1247
      goto done;
      default: ;
#line 1249
      goto ldv_57931;
      }
      ldv_57931: ;
    } else {

    }
  } else {

  }
#line 1254
  tmp___8 = is_udp_pkt(*skb);
#line 1254
  if ((unsigned int )tmp___8 != 0U) {
#line 1255
    tmp___7 = udp_hdr((struct sk_buff  const  *)*skb);
#line 1255
    udp = tmp___7;
#line 1257
    switch ((int )udp->dest) {
    case 68: 
#line 1259
    os2bmc = ((unsigned long )adapter->bmc_filt_mask & 2UL) != 0UL;
#line 1260
    goto done;
    case 67: 
#line 1262
    os2bmc = ((unsigned long )adapter->bmc_filt_mask & 4UL) != 0UL;
#line 1263
    goto done;
    case 137: ;
    case 138: 
#line 1266
    os2bmc = ((unsigned long )adapter->bmc_filt_mask & 8UL) != 0UL;
#line 1267
    goto done;
    case 547: 
#line 1269
    os2bmc = ((unsigned long )adapter->bmc_filt_mask & 1024UL) != 0UL;
#line 1270
    goto done;
    default: ;
#line 1272
    goto ldv_57939;
    }
    ldv_57939: ;
  } else {

  }
  done: ;
#line 1279
  if ((int )os2bmc) {
#line 1280
    *skb = be_insert_vlan_in_pkt(adapter, *skb, (struct be_wrb_params *)0);
  } else {

  }
#line 1282
  return (os2bmc);
}
}
#line 1285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static netdev_tx_t be_xmit(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 q_idx ;
  u16 tmp___0 ;
  struct be_tx_obj *txo ;
  struct be_wrb_params wrb_params ;
  bool flush ;
  u16 wrb_cnt ;
  long tmp___1 ;
  u32 tmp___2 ;
  long tmp___3 ;
  u32 tmp___4 ;
  long tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;

  {
#line 1287
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1287
  adapter = (struct be_adapter *)tmp;
#line 1288
  tmp___0 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 1288
  q_idx = tmp___0;
#line 1289
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )q_idx;
#line 1290
  wrb_params.features = 0U;
#line 1290
  wrb_params.vlan_tag = (unsigned short)0;
#line 1290
  wrb_params.lso_mss = (unsigned short)0;
#line 1291
  flush = (unsigned int )*((unsigned char *)skb + 142UL) == 0U;
#line 1294
  skb = be_xmit_workarounds(adapter, skb, & wrb_params);
#line 1295
  tmp___1 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                             0L);
#line 1295
  if (tmp___1 != 0L) {
#line 1296
    goto drop;
  } else {

  }
#line 1298
  be_get_wrb_params_from_skb(adapter, skb, & wrb_params);
#line 1300
  tmp___2 = be_xmit_enqueue(adapter, txo, skb, & wrb_params);
#line 1300
  wrb_cnt = (u16 )tmp___2;
#line 1301
  tmp___3 = ldv__builtin_expect((unsigned int )wrb_cnt == 0U, 0L);
#line 1301
  if (tmp___3 != 0L) {
#line 1302
    dev_kfree_skb_any(skb);
#line 1303
    goto drop;
  } else {

  }
#line 1309
  tmp___6 = be_send_pkt_to_bmc(adapter, & skb);
#line 1309
  if ((int )tmp___6) {
#line 1310
    wrb_params.features = wrb_params.features | 256U;
#line 1311
    tmp___4 = be_xmit_enqueue(adapter, txo, skb, & wrb_params);
#line 1311
    wrb_cnt = (u16 )tmp___4;
#line 1312
    tmp___5 = ldv__builtin_expect((unsigned int )wrb_cnt == 0U, 0L);
#line 1312
    if (tmp___5 != 0L) {
#line 1313
      goto drop;
    } else {
#line 1315
      skb_get(skb);
    }
  } else {

  }
#line 1318
  tmp___7 = be_is_txq_full(txo);
#line 1318
  if ((int )tmp___7) {
#line 1319
    netif_stop_subqueue(netdev, (int )q_idx);
#line 1320
    txo->stats.tx_stops = txo->stats.tx_stops + 1U;
  } else {

  }
#line 1323
  if ((int )flush) {
#line 1324
    be_xmit_flush(adapter, txo);
  } else {
#line 1323
    tmp___8 = __netif_subqueue_stopped((struct net_device  const  *)netdev, (int )q_idx);
#line 1323
    if ((int )tmp___8) {
#line 1324
      be_xmit_flush(adapter, txo);
    } else {

    }
  }
#line 1326
  return (0);
  drop: 
#line 1328
  txo->stats.tx_drv_drops = txo->stats.tx_drv_drops + 1U;
#line 1330
  if ((int )flush && (unsigned int )txo->pend_wrb_cnt != 0U) {
#line 1331
    be_xmit_flush(adapter, txo);
  } else {

  }
#line 1333
  return (0);
}
}
#line 1336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;

  {
#line 1338
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1338
  adapter = (struct be_adapter *)tmp;
#line 1339
  dev = & (adapter->pdev)->dev;
#line 1341
  if (new_mtu <= 255 || new_mtu > 9000) {
#line 1342
    _dev_info((struct device  const  *)dev, "MTU must be between %d and %d bytes\n",
              256, 9000);
#line 1344
    return (-22);
  } else {

  }
#line 1347
  _dev_info((struct device  const  *)dev, "MTU changed from %d to %d bytes\n", netdev->mtu,
            new_mtu);
#line 1349
  netdev->mtu = (unsigned int )new_mtu;
#line 1350
  return (0);
}
}
#line 1353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_in_all_promisc(struct be_adapter *adapter ) 
{ 


  {
#line 1355
  return ((adapter->if_flags & 648U) == 648U);
}
}
#line 1359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vlan_promisc(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;

  {
#line 1361
  dev = & (adapter->pdev)->dev;
#line 1364
  if ((adapter->if_flags & 128U) != 0U) {
#line 1365
    return (0);
  } else {

  }
#line 1367
  status = be_cmd_rx_filter(adapter, 128U, 1U);
#line 1368
  if (status == 0) {
#line 1369
    _dev_info((struct device  const  *)dev, "Enabled VLAN promiscuous mode\n");
#line 1370
    adapter->if_flags = adapter->if_flags | 128U;
  } else {
#line 1372
    dev_err((struct device  const  *)dev, "Failed to enable VLAN promiscuous mode\n");
  }
#line 1374
  return (status);
}
}
#line 1377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_clear_vlan_promisc(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;

  {
#line 1379
  dev = & (adapter->pdev)->dev;
#line 1382
  status = be_cmd_rx_filter(adapter, 128U, 0U);
#line 1383
  if (status == 0) {
#line 1384
    _dev_info((struct device  const  *)dev, "Disabling VLAN promiscuous mode\n");
#line 1385
    adapter->if_flags = adapter->if_flags & 4294967167U;
  } else {

  }
#line 1387
  return (status);
}
}
#line 1394 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vid_config(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  u16 vids[64U] ;
  u16 num ;
  u16 i ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  u16 tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
#line 1396
  dev = & (adapter->pdev)->dev;
#line 1398
  num = 0U;
#line 1398
  i = 0U;
#line 1399
  status = 0;
#line 1402
  tmp = be_in_all_promisc(adapter);
#line 1402
  if ((int )tmp) {
#line 1403
    return (0);
  } else {

  }
#line 1405
  if ((int )adapter->vlans_added > (int )adapter->res.max_vlans) {
#line 1406
    tmp___0 = be_set_vlan_promisc(adapter);
#line 1406
    return (tmp___0);
  } else {

  }
#line 1409
  tmp___1 = find_first_bit((unsigned long const   *)(& adapter->vids), 4096UL);
#line 1409
  i = (u16 )tmp___1;
#line 1409
  goto ldv_57979;
  ldv_57978: 
#line 1410
  tmp___2 = num;
#line 1410
  num = (u16 )((int )num + 1);
#line 1410
  vids[(int )tmp___2] = i;
#line 1409
  tmp___3 = find_next_bit((unsigned long const   *)(& adapter->vids), 4096UL, (unsigned long )((int )i + 1));
#line 1409
  i = (u16 )tmp___3;
  ldv_57979: ;
#line 1409
  if ((unsigned int )i <= 4095U) {
#line 1411
    goto ldv_57978;
  } else {

  }
#line 1412
  status = be_cmd_vlan_config(adapter, (u32 )adapter->if_handle, (u16 *)(& vids),
                              (u32 )num, 0U);
#line 1413
  if (status != 0) {
#line 1414
    dev_err((struct device  const  *)dev, "Setting HW VLAN filtering failed\n");
#line 1416
    if ((status > 0 && ((unsigned int )(status >> 16) & 255U) == 171U) || (status > 0 && ((unsigned int )(status >> 16) & 255U) == 22U)) {
#line 1419
      tmp___4 = be_set_vlan_promisc(adapter);
#line 1419
      return (tmp___4);
    } else {

    }
  } else
#line 1420
  if ((adapter->if_flags & 128U) != 0U) {
#line 1421
    status = be_clear_vlan_promisc(adapter);
  } else {

  }
#line 1423
  return (status);
}
}
#line 1426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  int tmp___0 ;

  {
#line 1428
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1428
  adapter = (struct be_adapter *)tmp;
#line 1429
  status = 0;
#line 1432
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1433
    return (status);
  } else {

  }
#line 1435
  tmp___0 = variable_test_bit((long )vid, (unsigned long const volatile   *)(& adapter->vids));
#line 1435
  if (tmp___0 != 0) {
#line 1436
    return (status);
  } else {

  }
#line 1438
  set_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
#line 1439
  adapter->vlans_added = (u16 )((int )adapter->vlans_added + 1);
#line 1441
  status = be_vid_config(adapter);
#line 1442
  if (status != 0) {
#line 1443
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
#line 1444
    clear_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
  } else {

  }
#line 1447
  return (status);
}
}
#line 1450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_rem_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1452
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1452
  adapter = (struct be_adapter *)tmp;
#line 1455
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1456
    return (0);
  } else {

  }
#line 1458
  clear_bit((long )vid, (unsigned long volatile   *)(& adapter->vids));
#line 1459
  adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
#line 1461
  tmp___0 = be_vid_config(adapter);
#line 1461
  return (tmp___0);
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_clear_all_promisc(struct be_adapter *adapter ) 
{ 


  {
#line 1466
  be_cmd_rx_filter(adapter, 648U, 0U);
#line 1467
  adapter->if_flags = adapter->if_flags & 4294966647U;
#line 1468
  return;
}
}
#line 1470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_all_promisc(struct be_adapter *adapter ) 
{ 


  {
#line 1472
  be_cmd_rx_filter(adapter, 648U, 1U);
#line 1473
  adapter->if_flags = adapter->if_flags | 648U;
#line 1474
  return;
}
}
#line 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_mc_promisc(struct be_adapter *adapter ) 
{ 
  int status ;

  {
#line 1480
  if ((adapter->if_flags & 512U) != 0U) {
#line 1481
    return;
  } else {

  }
#line 1483
  status = be_cmd_rx_filter(adapter, 512U, 1U);
#line 1484
  if (status == 0) {
#line 1485
    adapter->if_flags = adapter->if_flags | 512U;
  } else {

  }
#line 1486
  return;
}
}
#line 1488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_mc_list(struct be_adapter *adapter ) 
{ 
  int status ;

  {
#line 1492
  status = be_cmd_rx_filter(adapter, 4096U, 1U);
#line 1493
  if (status == 0) {
#line 1494
    adapter->if_flags = adapter->if_flags & 4294966783U;
  } else {
#line 1496
    be_set_mc_promisc(adapter);
  }
#line 1497
  return;
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_uc_list(struct be_adapter *adapter ) 
{ 
  struct netdev_hw_addr *ha ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1502
  i = 1;
#line 1504
  goto ldv_58014;
  ldv_58013: 
#line 1505
  be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                  0U);
#line 1504
  adapter->uc_macs = adapter->uc_macs - 1U;
#line 1504
  i = i + 1;
  ldv_58014: ;
#line 1504
  if (adapter->uc_macs != 0U) {
#line 1506
    goto ldv_58013;
  } else {

  }

#line 1508
  if ((adapter->netdev)->uc.count > (int )adapter->res.max_uc_mac) {
#line 1509
    be_set_all_promisc(adapter);
#line 1510
    return;
  } else {

  }
#line 1513
  __mptr = (struct list_head  const  *)(adapter->netdev)->uc.list.next;
#line 1513
  ha = (struct netdev_hw_addr *)__mptr;
#line 1513
  goto ldv_58021;
  ldv_58020: 
#line 1514
  adapter->uc_macs = adapter->uc_macs + 1U;
#line 1515
  be_cmd_pmac_add(adapter, (u8 *)(& ha->addr), (u32 )adapter->if_handle, adapter->pmac_id + (unsigned long )adapter->uc_macs,
                  0U);
#line 1513
  __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1513
  ha = (struct netdev_hw_addr *)__mptr___0;
  ldv_58021: ;
#line 1513
  if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->uc.list)) {
#line 1515
    goto ldv_58020;
  } else {

  }

#line 1520
  return;
}
}
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_clear_uc_list(struct be_adapter *adapter ) 
{ 
  int i ;

  {
#line 1524
  i = 1;
#line 1524
  goto ldv_58028;
  ldv_58027: 
#line 1525
  be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                  0U);
#line 1524
  i = i + 1;
  ldv_58028: ;
#line 1524
  if ((u32 )i < adapter->uc_macs + 1U) {
#line 1526
    goto ldv_58027;
  } else {

  }
#line 1527
  adapter->uc_macs = 0U;
#line 1528
  return;
}
}
#line 1530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_rx_mode(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 1532
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1532
  adapter = (struct be_adapter *)tmp;
#line 1534
  if ((netdev->flags & 256U) != 0U) {
#line 1535
    be_set_all_promisc(adapter);
#line 1536
    return;
  } else {

  }
#line 1540
  tmp___0 = be_in_all_promisc(adapter);
#line 1540
  if ((int )tmp___0) {
#line 1541
    be_clear_all_promisc(adapter);
#line 1542
    if ((unsigned int )adapter->vlans_added != 0U) {
#line 1543
      be_vid_config(adapter);
    } else {

    }
  } else {

  }
#line 1547
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )adapter->res.max_mcast_mac) {
#line 1549
    be_set_mc_promisc(adapter);
#line 1550
    return;
  } else {

  }
#line 1553
  if ((u32 )netdev->uc.count != adapter->uc_macs) {
#line 1554
    be_set_uc_list(adapter);
  } else {

  }
#line 1556
  be_set_mc_list(adapter);
#line 1557
  return;
}
}
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 1561
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1561
  adapter = (struct be_adapter *)tmp;
#line 1562
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1565
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1566
    return (-1);
  } else {

  }
#line 1568
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
#line 1568
  if (tmp___0) {
#line 1568
    tmp___1 = 0;
  } else {
#line 1568
    tmp___1 = 1;
  }
#line 1568
  if (tmp___1 || (int )adapter->num_vfs <= vf) {
#line 1569
    return (-22);
  } else {

  }
#line 1574
  tmp___2 = ether_addr_equal((u8 const   *)mac, (u8 const   *)(& vf_cfg->mac_addr));
#line 1574
  if ((int )tmp___2) {
#line 1575
    return (0);
  } else {

  }
#line 1577
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1578
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, (u32 )(vf + 1));
#line 1581
    status = be_cmd_pmac_add(adapter, mac, (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             (u32 )(vf + 1));
  } else {
#line 1584
    status = be_cmd_set_mac(adapter, mac, vf_cfg->if_handle, (u32 )(vf + 1));
  }
#line 1588
  if (status != 0) {
#line 1589
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "MAC %pM set on VF %d Failed: %#x",
            mac, vf, status);
#line 1591
    return (status <= 0 ? status : -5);
  } else {

  }
#line 1594
  ether_addr_copy((u8 *)(& vf_cfg->mac_addr), (u8 const   *)mac);
#line 1596
  return (0);
}
}
#line 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *vi ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;

  {
#line 1602
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1602
  adapter = (struct be_adapter *)tmp;
#line 1603
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1605
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1606
    return (-1);
  } else {

  }
#line 1608
  if ((int )adapter->num_vfs <= vf) {
#line 1609
    return (-22);
  } else {

  }
#line 1611
  vi->vf = (__u32 )vf;
#line 1612
  vi->max_tx_rate = vf_cfg->tx_rate;
#line 1613
  vi->min_tx_rate = 0U;
#line 1614
  vi->vlan = (__u32 )vf_cfg->vlan_tag & 4095U;
#line 1615
  vi->qos = (__u32 )((int )vf_cfg->vlan_tag >> 13);
#line 1616
  memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr), 6UL);
#line 1617
  vi->linkstate = (adapter->vf_cfg + (unsigned long )vf)->plink_tracking;
#line 1618
  vi->spoofchk = (__u32 )(adapter->vf_cfg + (unsigned long )vf)->spoofchk;
#line 1620
  return (0);
}
}
#line 1623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_tvt(struct be_adapter *adapter , int vf , u16 vlan ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u16 vids[64U] ;
  int vf_if_id ;
  int status ;

  {
#line 1625
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1627
  vf_if_id = vf_cfg->if_handle;
#line 1631
  status = be_cmd_set_hsw_config(adapter, (int )vlan, (u32 )(vf + 1), (int )((u16 )vf_if_id),
                                 0, 0);
#line 1632
  if (status != 0) {
#line 1633
    return (status);
  } else {

  }
#line 1636
  vids[0] = 0U;
#line 1637
  status = be_cmd_vlan_config(adapter, (u32 )vf_if_id, (u16 *)(& vids), 1U, (u32 )(vf + 1));
#line 1638
  if (status == 0) {
#line 1639
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Cleared guest VLANs on VF%d",
              vf);
  } else {

  }
#line 1643
  if ((vf_cfg->privileges & 64U) != 0U) {
#line 1644
    status = be_cmd_set_fn_privileges(adapter, vf_cfg->privileges & 4294967231U, (u32 )(vf + 1));
#line 1646
    if (status == 0) {
#line 1647
      vf_cfg->privileges = vf_cfg->privileges & 4294967231U;
    } else {

    }
  } else {

  }
#line 1649
  return (0);
}
}
#line 1652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_clear_vf_tvt(struct be_adapter *adapter , int vf ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  struct device *dev ;
  int status ;

  {
#line 1654
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1655
  dev = & (adapter->pdev)->dev;
#line 1659
  status = be_cmd_set_hsw_config(adapter, 65535, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                 0, 0);
#line 1661
  if (status != 0) {
#line 1662
    return (status);
  } else {

  }
#line 1665
  if ((vf_cfg->privileges & 64U) == 0U) {
#line 1666
    status = be_cmd_set_fn_privileges(adapter, vf_cfg->privileges | 64U, (u32 )(vf + 1));
#line 1668
    if (status == 0) {
#line 1669
      vf_cfg->privileges = vf_cfg->privileges | 64U;
#line 1670
      _dev_info((struct device  const  *)dev, "VF%d: FILTMGMT priv enabled", vf);
    } else {

    }
  } else {

  }
#line 1674
  _dev_info((struct device  const  *)dev, "Disable/re-enable i/f in VM to clear Transparent VLAN tag");
#line 1676
  return (0);
}
}
#line 1679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;

  {
#line 1681
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1681
  adapter = (struct be_adapter *)tmp;
#line 1682
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1685
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1686
    return (-1);
  } else {

  }
#line 1688
  if (((int )adapter->num_vfs <= vf || (unsigned int )vlan > 4095U) || (unsigned int )qos > 7U) {
#line 1689
    return (-22);
  } else {

  }
#line 1691
  if ((unsigned int )vlan != 0U || (unsigned int )qos != 0U) {
#line 1692
    vlan = (u16 )((int )((short )((int )qos << 13)) | (int )((short )vlan));
#line 1693
    status = be_set_vf_tvt(adapter, vf, (int )vlan);
  } else {
#line 1695
    status = be_clear_vf_tvt(adapter, vf);
  }
#line 1698
  if (status != 0) {
#line 1699
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "VLAN %d config on VF %d failed : %#x\n",
            (int )vlan, vf, status);
#line 1702
    return (status <= 0 ? status : -5);
  } else {

  }
#line 1705
  vf_cfg->vlan_tag = vlan;
#line 1706
  return (0);
}
}
#line 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_tx_rate(struct net_device *netdev , int vf , int min_tx_rate ,
                             int max_tx_rate ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int percent_rate ;
  int status ;
  u16 link_speed ;
  u8 link_status ;

  {
#line 1712
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1712
  adapter = (struct be_adapter *)tmp;
#line 1713
  dev = & (adapter->pdev)->dev;
#line 1714
  status = 0;
#line 1715
  link_speed = 0U;
#line 1718
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1719
    return (-1);
  } else {

  }
#line 1721
  if ((int )adapter->num_vfs <= vf) {
#line 1722
    return (-22);
  } else {

  }
#line 1724
  if (min_tx_rate != 0) {
#line 1725
    return (-22);
  } else {

  }
#line 1727
  if (max_tx_rate == 0) {
#line 1728
    goto config_qos;
  } else {

  }
#line 1730
  status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
#line 1732
  if (status != 0) {
#line 1733
    goto err;
  } else {

  }
#line 1735
  if ((unsigned int )link_status == 0U) {
#line 1736
    dev_err((struct device  const  *)dev, "TX-rate setting not allowed when link is down\n");
#line 1737
    status = -100;
#line 1738
    goto err;
  } else {

  }
#line 1741
  if (max_tx_rate <= 99 || (int )link_speed < max_tx_rate) {
#line 1742
    dev_err((struct device  const  *)dev, "TX-rate must be between 100 and %d Mbps\n",
            (int )link_speed);
#line 1744
    status = -22;
#line 1745
    goto err;
  } else {

  }
#line 1749
  percent_rate = (int )((unsigned int )link_speed / 100U);
#line 1750
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && max_tx_rate % percent_rate != 0) {
#line 1751
    dev_err((struct device  const  *)dev, "TX-rate must be a multiple of %d Mbps\n",
            percent_rate);
#line 1753
    status = -22;
#line 1754
    goto err;
  } else {

  }
  config_qos: 
#line 1758
  status = be_cmd_config_qos(adapter, (u32 )max_tx_rate, (int )link_speed, (int )((unsigned int )((u8 )vf) + 1U));
#line 1759
  if (status != 0) {
#line 1760
    goto err;
  } else {

  }
#line 1762
  (adapter->vf_cfg + (unsigned long )vf)->tx_rate = (u32 )max_tx_rate;
#line 1763
  return (0);
  err: 
#line 1766
  dev_err((struct device  const  *)dev, "TX-rate setting of %dMbps on VF%d failed\n",
          max_tx_rate, vf);
#line 1768
  return (status <= 0 ? status : -5);
}
}
#line 1771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_link_state(struct net_device *netdev , int vf , int link_state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1774
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1774
  adapter = (struct be_adapter *)tmp;
#line 1777
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1778
    return (-1);
  } else {

  }
#line 1780
  if ((int )adapter->num_vfs <= vf) {
#line 1781
    return (-22);
  } else {

  }
#line 1783
  status = be_cmd_set_logical_link_config(adapter, link_state, (int )((unsigned int )((u8 )vf) + 1U));
#line 1784
  if (status != 0) {
#line 1785
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Link state change on VF %d failed: %#x\n",
            vf, status);
#line 1787
    return (status <= 0 ? status : -5);
  } else {

  }
#line 1790
  (adapter->vf_cfg + (unsigned long )vf)->plink_tracking = (u32 )link_state;
#line 1792
  return (0);
}
}
#line 1795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_spoofchk(struct net_device *netdev , int vf , bool enable ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  u8 spoofchk ;
  int status ;

  {
#line 1797
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1797
  adapter = (struct be_adapter *)tmp;
#line 1798
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1802
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 1803
    return (-1);
  } else {

  }
#line 1805
  if ((int )adapter->num_vfs <= vf) {
#line 1806
    return (-22);
  } else {

  }
#line 1808
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1809
    return (-95);
  } else {

  }
#line 1811
  if ((int )vf_cfg->spoofchk == (int )enable) {
#line 1812
    return (0);
  } else {

  }
#line 1814
  spoofchk = (int )enable ? 2U : 3U;
#line 1816
  status = be_cmd_set_hsw_config(adapter, 0, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                 0, (int )spoofchk);
#line 1818
  if (status != 0) {
#line 1819
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Spoofchk change on VF %d failed: %#x\n",
            vf, status);
#line 1821
    return (status <= 0 ? status : -5);
  } else {

  }
#line 1824
  vf_cfg->spoofchk = enable;
#line 1825
  return (0);
}
}
#line 1828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_aic_update(struct be_aic_obj *aic , u64 rx_pkts , u64 tx_pkts , ulong now ) 
{ 


  {
#line 1831
  aic->rx_pkts_prev = rx_pkts;
#line 1832
  aic->tx_reqs_prev = tx_pkts;
#line 1833
  aic->jiffies = now;
#line 1834
  return;
}
}
#line 1836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_new_eqd(struct be_eq_obj *eqo ) 
{ 
  struct be_adapter *adapter ;
  int eqd ;
  int start ;
  struct be_aic_obj *aic ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 rx_pkts ;
  u64 tx_pkts ;
  ulong now ;
  u32 pps ;
  u32 delta ;
  int i ;
  unsigned int tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  bool tmp___2 ;
  u32 __min1 ;
  u32 __min2 ;
  u32 __max1 ;
  u32 __max2 ;

  {
#line 1838
  adapter = eqo->adapter;
#line 1843
  rx_pkts = 0ULL;
#line 1843
  tx_pkts = 0ULL;
#line 1848
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )eqo->idx;
#line 1849
  if (! aic->enable) {
#line 1850
    if (aic->jiffies != 0UL) {
#line 1851
      aic->jiffies = 0UL;
    } else {

    }
#line 1852
    eqd = (int )aic->et_eqd;
#line 1853
    return (eqd);
  } else {

  }
#line 1856
  i = (int )eqo->idx;
#line 1856
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 1856
  goto ldv_58128;
  ldv_58127: ;
  ldv_58125: 
#line 1858
  tmp = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& rxo->stats.sync));
#line 1858
  start = (int )tmp;
#line 1859
  rx_pkts = rxo->stats.rx_pkts + rx_pkts;
#line 1860
  tmp___0 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& rxo->stats.sync),
                                      (unsigned int )start);
#line 1860
  if ((int )tmp___0) {
#line 1862
    goto ldv_58125;
  } else {

  }
#line 1856
  i = (int )adapter->num_evt_qs + i;
#line 1856
  rxo = rxo + (unsigned long )adapter->num_evt_qs;
  ldv_58128: ;
#line 1856
  if ((int )adapter->num_rx_qs > i) {
#line 1858
    goto ldv_58127;
  } else {

  }
#line 1863
  i = (int )eqo->idx;
#line 1863
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 1863
  goto ldv_58133;
  ldv_58132: ;
  ldv_58130: 
#line 1865
  tmp___1 = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& txo->stats.sync));
#line 1865
  start = (int )tmp___1;
#line 1866
  tx_pkts = txo->stats.tx_reqs + tx_pkts;
#line 1867
  tmp___2 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& txo->stats.sync),
                                      (unsigned int )start);
#line 1867
  if ((int )tmp___2) {
#line 1869
    goto ldv_58130;
  } else {

  }
#line 1863
  i = (int )adapter->num_evt_qs + i;
#line 1863
  txo = txo + (unsigned long )adapter->num_evt_qs;
  ldv_58133: ;
#line 1863
  if ((int )adapter->num_tx_qs > i) {
#line 1865
    goto ldv_58132;
  } else {

  }
#line 1871
  now = jiffies;
#line 1872
  if (((aic->jiffies == 0UL || (long )(now - aic->jiffies) < 0L) || aic->rx_pkts_prev > rx_pkts) || aic->tx_reqs_prev > tx_pkts) {
#line 1875
    be_aic_update(aic, rx_pkts, tx_pkts, now);
#line 1876
    return ((int )aic->prev_eqd);
  } else {

  }
#line 1879
  delta = jiffies_to_msecs(now - aic->jiffies);
#line 1880
  if (delta == 0U) {
#line 1881
    return ((int )aic->prev_eqd);
  } else {

  }
#line 1883
  pps = (((unsigned int )rx_pkts - (unsigned int )aic->rx_pkts_prev) * 1000U) / delta + (((unsigned int )tx_pkts - (unsigned int )aic->tx_reqs_prev) * 1000U) / delta;
#line 1885
  eqd = (int )(pps / 15000U << 2);
#line 1887
  if (eqd <= 7) {
#line 1888
    eqd = 0;
  } else {

  }
#line 1889
  __min1 = (u32 )eqd;
#line 1889
  __min2 = aic->max_eqd;
#line 1889
  eqd = (int )(__min1 < __min2 ? __min1 : __min2);
#line 1890
  __max1 = (u32 )eqd;
#line 1890
  __max2 = aic->min_eqd;
#line 1890
  eqd = (int )(__max1 > __max2 ? __max1 : __max2);
#line 1892
  be_aic_update(aic, rx_pkts, tx_pkts, now);
#line 1894
  return (eqd);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u32 be_get_eq_delay_mult_enc(struct be_eq_obj *eqo ) 
{ 
  struct be_adapter *adapter ;
  struct be_aic_obj *aic ;
  ulong now ;
  int eqd ;
  u32 mult_enc ;
  unsigned int tmp ;

  {
#line 1900
  adapter = eqo->adapter;
#line 1901
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )eqo->idx;
#line 1902
  now = jiffies;
#line 1906
  if (! aic->enable) {
#line 1907
    return (0U);
  } else {

  }
#line 1909
  if ((long )(aic->jiffies - now) >= 0L) {
#line 1911
    eqd = (int )aic->prev_eqd;
  } else {
#line 1909
    tmp = jiffies_to_msecs(now - aic->jiffies);
#line 1909
    if (tmp == 0U) {
#line 1911
      eqd = (int )aic->prev_eqd;
    } else {
#line 1913
      eqd = be_get_new_eqd(eqo);
    }
  }
#line 1915
  if (eqd > 100) {
#line 1916
    mult_enc = 1U;
  } else
#line 1917
  if (eqd > 60) {
#line 1918
    mult_enc = 2U;
  } else
#line 1919
  if (eqd > 20) {
#line 1920
    mult_enc = 3U;
  } else {
#line 1922
    mult_enc = 0U;
  }
#line 1924
  aic->prev_eqd = (u32 )eqd;
#line 1926
  return (mult_enc);
}
}
#line 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
void be_eqd_update(struct be_adapter *adapter , bool force_update ) 
{ 
  struct be_set_eqd set_eqd[32U] ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  int i ;
  int num ;
  int eqd ;

  {
#line 1934
  num = 0;
#line 1936
  i = 0;
#line 1936
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 1936
  goto ldv_58172;
  ldv_58171: 
#line 1937
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )eqo->idx;
#line 1938
  eqd = be_get_new_eqd(eqo);
#line 1939
  if ((int )force_update || (u32 )eqd != aic->prev_eqd) {
#line 1940
    set_eqd[num].delay_multiplier = (u32 )((eqd * 65) / 100);
#line 1941
    set_eqd[num].eq_id = (u32 )eqo->q.id;
#line 1942
    aic->prev_eqd = (u32 )eqd;
#line 1943
    num = num + 1;
  } else {

  }
#line 1936
  i = i + 1;
#line 1936
  eqo = eqo + 1;
  ldv_58172: ;
#line 1936
  if ((int )adapter->num_evt_qs > i) {
#line 1938
    goto ldv_58171;
  } else {

  }

#line 1947
  if (num != 0) {
#line 1948
    be_cmd_modify_eqd(adapter, (struct be_set_eqd *)(& set_eqd), num);
  } else {

  }
#line 1949
  return;
}
}
#line 1951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_stats_update(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_stats *stats ;

  {
#line 1954
  stats = & rxo->stats;
#line 1956
  u64_stats_init(& stats->sync);
#line 1957
  stats->rx_compl = stats->rx_compl + 1U;
#line 1958
  stats->rx_bytes = stats->rx_bytes + (u64 )rxcp->pkt_size;
#line 1959
  stats->rx_pkts = stats->rx_pkts + 1ULL;
#line 1960
  if ((unsigned int )rxcp->pkt_type == 1U) {
#line 1961
    stats->rx_mcast_pkts = stats->rx_mcast_pkts + 1U;
  } else {

  }
#line 1962
  if ((unsigned int )rxcp->err != 0U) {
#line 1963
    stats->rx_compl_err = stats->rx_compl_err + 1U;
  } else {

  }
#line 1964
  u64_stats_init(& stats->sync);
#line 1965
  return;
}
}
#line 1967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool csum_passed(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 1972
  return ((bool )(((((unsigned int )rxcp->tcpf != 0U || (unsigned int )rxcp->udpf != 0U) && (unsigned int )rxcp->l4_csum != 0U) && ((unsigned int )rxcp->ip_csum != 0U || (unsigned int )rxcp->ipv6 != 0U)) && (unsigned int )rxcp->err == 0U));
}
}
#line 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_rx_page_info *get_rx_page_info(struct be_rx_obj *rxo ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *rx_page_info ;
  struct be_queue_info *rxq ;
  u16 frag_idx ;
  long tmp ;

  {
#line 1978
  adapter = rxo->adapter;
#line 1980
  rxq = & rxo->q;
#line 1981
  frag_idx = rxq->tail;
#line 1983
  rx_page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )frag_idx;
#line 1984
  tmp = ldv__builtin_expect((unsigned long )rx_page_info->page == (unsigned long )((struct page *)0),
                         0L);
#line 1984
  if (tmp != 0L) {
#line 1984
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1984), "i" (12UL));
    ldv_58189: ;
#line 1984
    goto ldv_58189;
  } else {

  }
#line 1986
  if ((int )rx_page_info->last_frag) {
#line 1987
    dma_unmap_page(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )adapter->big_page_size,
                   2);
#line 1990
    rx_page_info->last_frag = 0;
  } else {
#line 1992
    dma_sync_single_for_cpu(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )rx_frag_size,
                            2);
  }
#line 1997
  queue_tail_inc(rxq);
#line 1998
  atomic_dec(& rxq->used);
#line 1999
  return (rx_page_info);
}
}
#line 2003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_discard(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 num_rcvd ;

  {
#line 2007
  num_rcvd = (u16 )rxcp->num_rcvd;
#line 2009
  i = 0U;
#line 2009
  goto ldv_58198;
  ldv_58197: 
#line 2010
  page_info = get_rx_page_info(rxo);
#line 2011
  put_page(page_info->page);
#line 2012
  memset((void *)page_info, 0, 24UL);
#line 2009
  i = (u16 )((int )i + 1);
  ldv_58198: ;
#line 2009
  if ((int )i < (int )num_rcvd) {
#line 2011
    goto ldv_58197;
  } else {

  }

#line 2016
  return;
}
}
#line 2020 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void skb_fill_rx_data(struct be_rx_obj *rxo , struct sk_buff *skb , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 j ;
  u16 hdr_len ;
  u16 curr_frag_len ;
  u16 remaining ;
  u8 *start ;
  void *tmp ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 _min1___0 ;
  ushort _min2___0 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;

  {
#line 2028
  page_info = get_rx_page_info(rxo);
#line 2029
  tmp = lowmem_page_address((struct page  const  *)page_info->page);
#line 2029
  start = (u8 *)tmp + (unsigned long )page_info->page_offset;
#line 2030
  __builtin_prefetch((void const   *)start);
#line 2033
  _min1 = rxcp->pkt_size;
#line 2033
  _min2 = rx_frag_size;
#line 2033
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 2035
  skb->len = (unsigned int )curr_frag_len;
#line 2036
  if ((unsigned int )curr_frag_len <= 64U) {
#line 2037
    memcpy((void *)skb->data, (void const   *)start, (size_t )curr_frag_len);
#line 2039
    put_page(page_info->page);
#line 2040
    skb->data_len = 0U;
#line 2041
    skb->tail = skb->tail + (sk_buff_data_t )curr_frag_len;
  } else {
#line 2043
    hdr_len = 14U;
#line 2044
    memcpy((void *)skb->data, (void const   *)start, (size_t )hdr_len);
#line 2045
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2045
    ((struct skb_shared_info *)tmp___0)->nr_frags = 1U;
#line 2046
    skb_frag_set_page(skb, 0, page_info->page);
#line 2047
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2047
    ((struct skb_shared_info *)tmp___1)->frags[0].page_offset = (__u32 )((int )page_info->page_offset + (int )hdr_len);
#line 2049
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2049
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___2)->frags),
                      (unsigned int )((int )curr_frag_len - (int )hdr_len));
#line 2051
    skb->data_len = (unsigned int )((int )curr_frag_len - (int )hdr_len);
#line 2052
    skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 2053
    skb->tail = skb->tail + (sk_buff_data_t )hdr_len;
  }
#line 2055
  page_info->page = (struct page *)0;
#line 2057
  if ((int )rxcp->pkt_size <= (int )rx_frag_size) {
#line 2058
    tmp___3 = ldv__builtin_expect((unsigned int )rxcp->num_rcvd != 1U, 0L);
#line 2058
    if (tmp___3 != 0L) {
#line 2058
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                           "i" (2058), "i" (12UL));
      ldv_58215: ;
#line 2058
      goto ldv_58215;
    } else {

    }
#line 2059
    return;
  } else {

  }
#line 2063
  remaining = (int )rxcp->pkt_size - (int )curr_frag_len;
#line 2064
  i = 1U;
#line 2064
  j = 0U;
#line 2064
  goto ldv_58220;
  ldv_58219: 
#line 2065
  page_info = get_rx_page_info(rxo);
#line 2066
  _min1___0 = remaining;
#line 2066
  _min2___0 = rx_frag_size;
#line 2066
  curr_frag_len = (u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0);
#line 2069
  if ((unsigned int )page_info->page_offset == 0U) {
#line 2071
    j = (u16 )((int )j + 1);
#line 2072
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 2073
    tmp___4 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2073
    ((struct skb_shared_info *)tmp___4)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 2075
    tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2075
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___5)->frags) + (unsigned long )j,
                      0U);
#line 2076
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2076
    ((struct skb_shared_info *)tmp___6)->nr_frags = (unsigned char )((int )((struct skb_shared_info *)tmp___6)->nr_frags + 1);
  } else {
#line 2078
    put_page(page_info->page);
  }
#line 2081
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2081
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___7)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 2082
  skb->len = skb->len + (unsigned int )curr_frag_len;
#line 2083
  skb->data_len = skb->data_len + (unsigned int )curr_frag_len;
#line 2084
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 2085
  remaining = (int )remaining - (int )curr_frag_len;
#line 2086
  page_info->page = (struct page *)0;
#line 2064
  i = (u16 )((int )i + 1);
  ldv_58220: ;
#line 2064
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 2066
    goto ldv_58219;
  } else {

  }
#line 2088
  tmp___8 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 2088
  if (tmp___8 != 0L) {
#line 2088
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (2088), "i" (12UL));
    ldv_58222: ;
#line 2088
    goto ldv_58222;
  } else {

  }
#line 2090
  return;
}
}
#line 2092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_process(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  struct sk_buff *skb ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2095
  adapter = rxo->adapter;
#line 2096
  netdev = adapter->netdev;
#line 2099
  skb = netdev_alloc_skb_ip_align(netdev, 128U);
#line 2100
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 2100
  if (tmp != 0L) {
#line 2101
    rxo->stats.rx_drops_no_skbs = rxo->stats.rx_drops_no_skbs + 1U;
#line 2102
    be_rx_compl_discard(rxo, rxcp);
#line 2103
    return;
  } else {

  }
#line 2106
  skb_fill_rx_data(rxo, skb, rxcp);
#line 2108
  if ((netdev->features & 17179869184ULL) != 0ULL) {
#line 2108
    tmp___0 = csum_passed(rxcp);
#line 2108
    if ((int )tmp___0) {
#line 2108
      tmp___1 = 1;
    } else {
#line 2108
      tmp___1 = 0;
    }
  } else {
#line 2108
    tmp___1 = 0;
  }
#line 2108
  tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 2108
  if (tmp___2 != 0L) {
#line 2109
    skb->ip_summed = 1U;
  } else {
#line 2111
    skb_checksum_none_assert((struct sk_buff  const  *)skb);
  }
#line 2113
  skb->protocol = eth_type_trans(skb, netdev);
#line 2114
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 2115
  if ((netdev->features & 8589934592ULL) != 0ULL) {
#line 2116
    skb_set_hash(skb, rxcp->rss_hash, 2);
  } else {

  }
#line 2118
  skb->csum_level = rxcp->tunneled;
#line 2119
  skb_mark_napi_id(skb, napi);
#line 2121
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 2122
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 2124
  netif_receive_skb(skb);
#line 2125
  return;
}
}
#line 2128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_process_gro(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                    struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct sk_buff *skb ;
  u16 remaining ;
  u16 curr_frag_len ;
  u16 i ;
  u16 j ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 2132
  adapter = rxo->adapter;
#line 2134
  skb = (struct sk_buff *)0;
#line 2138
  skb = napi_get_frags(napi);
#line 2139
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 2140
    be_rx_compl_discard(rxo, rxcp);
#line 2141
    return;
  } else {

  }
#line 2144
  remaining = rxcp->pkt_size;
#line 2145
  i = 0U;
#line 2145
  j = 65535U;
#line 2145
  goto ldv_58247;
  ldv_58246: 
#line 2146
  page_info = get_rx_page_info(rxo);
#line 2148
  _min1 = remaining;
#line 2148
  _min2 = rx_frag_size;
#line 2148
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 2151
  if ((unsigned int )i == 0U || (unsigned int )page_info->page_offset == 0U) {
#line 2153
    j = (u16 )((int )j + 1);
#line 2154
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 2155
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2155
    ((struct skb_shared_info *)tmp)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 2157
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2157
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___0)->frags) + (unsigned long )j,
                      0U);
  } else {
#line 2159
    put_page(page_info->page);
  }
#line 2161
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2161
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___1)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 2162
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 2163
  remaining = (int )remaining - (int )curr_frag_len;
#line 2164
  memset((void *)page_info, 0, 24UL);
#line 2145
  i = (u16 )((int )i + 1);
  ldv_58247: ;
#line 2145
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 2147
    goto ldv_58246;
  } else {

  }
#line 2166
  tmp___2 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 2166
  if (tmp___2 != 0L) {
#line 2166
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (2166), "i" (12UL));
    ldv_58249: ;
#line 2166
    goto ldv_58249;
  } else {

  }
#line 2168
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2168
  ((struct skb_shared_info *)tmp___3)->nr_frags = (unsigned int )((unsigned char )j) + 1U;
#line 2169
  skb->len = (unsigned int )rxcp->pkt_size;
#line 2170
  skb->data_len = (unsigned int )rxcp->pkt_size;
#line 2171
  skb->ip_summed = 1U;
#line 2172
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 2173
  if (((adapter->netdev)->features & 8589934592ULL) != 0ULL) {
#line 2174
    skb_set_hash(skb, rxcp->rss_hash, 2);
  } else {

  }
#line 2176
  skb->csum_level = rxcp->tunneled;
#line 2177
  skb_mark_napi_id(skb, napi);
#line 2179
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 2180
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 2182
  napi_gro_frags(napi);
#line 2183
  return;
}
}
#line 2185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_parse_rx_compl_v1(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 2188
  tmp = amap_mask(14U);
#line 2188
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 2188
  rxcp->pkt_size = (u16 )tmp___0;
#line 2189
  tmp___1 = amap_mask(1U);
#line 2189
  tmp___2 = amap_get((void *)compl, 0U, tmp___1, 30U);
#line 2189
  rxcp->vlanf = (u8 )tmp___2;
#line 2190
  tmp___3 = amap_mask(1U);
#line 2190
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 2190
  rxcp->err = (u8 )tmp___4;
#line 2191
  tmp___5 = amap_mask(1U);
#line 2191
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 2191
  rxcp->tcpf = (u8 )tmp___6;
#line 2192
  tmp___7 = amap_mask(1U);
#line 2192
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 2192
  rxcp->udpf = (u8 )tmp___8;
#line 2193
  tmp___9 = amap_mask(1U);
#line 2193
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 2193
  rxcp->ip_csum = (u8 )tmp___10;
#line 2194
  tmp___11 = amap_mask(1U);
#line 2194
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 2194
  rxcp->l4_csum = (u8 )tmp___12;
#line 2195
  tmp___13 = amap_mask(1U);
#line 2195
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 2195
  rxcp->ipv6 = (u8 )tmp___14;
#line 2196
  tmp___15 = amap_mask(3U);
#line 2196
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 2196
  rxcp->num_rcvd = (u8 )tmp___16;
#line 2197
  tmp___17 = amap_mask(2U);
#line 2197
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 2197
  rxcp->pkt_type = (u8 )tmp___18;
#line 2198
  tmp___19 = amap_mask(32U);
#line 2198
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
#line 2199
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 2200
    tmp___20 = amap_mask(1U);
#line 2200
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 2200
    rxcp->qnq = (u8 )tmp___21;
#line 2201
    tmp___22 = amap_mask(16U);
#line 2201
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 2201
    rxcp->vlan_tag = (u16 )tmp___23;
  } else {

  }
#line 2203
  tmp___24 = amap_mask(2U);
#line 2203
  tmp___25 = amap_get((void *)compl, 2U, tmp___24, 5U);
#line 2203
  rxcp->port = (u16 )tmp___25;
#line 2204
  tmp___26 = amap_mask(1U);
#line 2204
  tmp___27 = amap_get((void *)compl, 2U, tmp___26, 30U);
#line 2204
  rxcp->tunneled = (u8 )tmp___27;
#line 2206
  return;
}
}
#line 2208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_parse_rx_compl_v0(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 2211
  tmp = amap_mask(14U);
#line 2211
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 2211
  rxcp->pkt_size = (u16 )tmp___0;
#line 2212
  tmp___1 = amap_mask(1U);
#line 2212
  tmp___2 = amap_get((void *)compl, 1U, tmp___1, 14U);
#line 2212
  rxcp->vlanf = (u8 )tmp___2;
#line 2213
  tmp___3 = amap_mask(1U);
#line 2213
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 2213
  rxcp->err = (u8 )tmp___4;
#line 2214
  tmp___5 = amap_mask(1U);
#line 2214
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 2214
  rxcp->tcpf = (u8 )tmp___6;
#line 2215
  tmp___7 = amap_mask(1U);
#line 2215
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 2215
  rxcp->udpf = (u8 )tmp___8;
#line 2216
  tmp___9 = amap_mask(1U);
#line 2216
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 2216
  rxcp->ip_csum = (u8 )tmp___10;
#line 2217
  tmp___11 = amap_mask(1U);
#line 2217
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 2217
  rxcp->l4_csum = (u8 )tmp___12;
#line 2218
  tmp___13 = amap_mask(1U);
#line 2218
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 2218
  rxcp->ipv6 = (u8 )tmp___14;
#line 2219
  tmp___15 = amap_mask(3U);
#line 2219
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 2219
  rxcp->num_rcvd = (u8 )tmp___16;
#line 2220
  tmp___17 = amap_mask(2U);
#line 2220
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 2220
  rxcp->pkt_type = (u8 )tmp___18;
#line 2221
  tmp___19 = amap_mask(32U);
#line 2221
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
#line 2222
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 2223
    tmp___20 = amap_mask(1U);
#line 2223
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 2223
    rxcp->qnq = (u8 )tmp___21;
#line 2224
    tmp___22 = amap_mask(16U);
#line 2224
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 2224
    rxcp->vlan_tag = (u16 )tmp___23;
  } else {

  }
#line 2226
  tmp___24 = amap_mask(1U);
#line 2226
  tmp___25 = amap_get((void *)compl, 0U, tmp___24, 30U);
#line 2226
  rxcp->port = (u16 )tmp___25;
#line 2227
  tmp___26 = amap_mask(1U);
#line 2227
  tmp___27 = amap_get((void *)compl, 1U, tmp___26, 15U);
#line 2227
  rxcp->ip_frag = (u8 )tmp___27;
#line 2228
  return;
}
}
#line 2230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_rx_compl_info *be_rx_compl_get(struct be_rx_obj *rxo ) 
{ 
  struct be_eth_rx_compl *compl ;
  void *tmp ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  __u16 tmp___0 ;
  int tmp___1 ;

  {
#line 2232
  tmp = queue_tail_node(& rxo->cq);
#line 2232
  compl = (struct be_eth_rx_compl *)tmp;
#line 2233
  rxcp = & rxo->rxcp;
#line 2234
  adapter = rxo->adapter;
#line 2238
  if (compl->dw[2UL] == 0U) {
#line 2239
    return ((struct be_rx_compl_info *)0);
  } else {

  }
#line 2241
  __asm__  volatile   ("lfence": : : "memory");
#line 2242
  swap_dws((void *)compl, 16);
#line 2244
  if ((int )adapter->be3_native) {
#line 2245
    be_parse_rx_compl_v1(compl, rxcp);
  } else {
#line 2247
    be_parse_rx_compl_v0(compl, rxcp);
  }
#line 2249
  if ((unsigned int )rxcp->ip_frag != 0U) {
#line 2250
    rxcp->l4_csum = 0U;
  } else {

  }
#line 2252
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 2257
    if ((adapter->function_mode & 1024U) != 0U && (unsigned int )rxcp->qnq == 0U) {
#line 2258
      rxcp->vlanf = 0U;
    } else {

    }
#line 2260
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 2261
      tmp___0 = __fswab16((int )rxcp->vlan_tag);
#line 2261
      rxcp->vlan_tag = tmp___0;
    } else {

    }
#line 2263
    if ((int )adapter->pvid == ((int )rxcp->vlan_tag & 4095)) {
#line 2263
      tmp___1 = variable_test_bit((long )rxcp->vlan_tag, (unsigned long const volatile   *)(& adapter->vids));
#line 2263
      if (tmp___1 == 0) {
#line 2265
        rxcp->vlanf = 0U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2269
  compl->dw[2UL] = 0U;
#line 2271
  queue_tail_inc(& rxo->cq);
#line 2272
  return (rxcp);
}
}
#line 2275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static struct page *be_alloc_pages(u32 size , gfp_t gfp ) 
{ 
  u32 order ;
  int tmp ;
  struct page *tmp___0 ;

  {
#line 2277
  tmp = __get_order((unsigned long )size);
#line 2277
  order = (u32 )tmp;
#line 2279
  if (order != 0U) {
#line 2280
    gfp = gfp | 16384U;
  } else {

  }
#line 2281
  tmp___0 = alloc_pages(gfp, order);
#line 2281
  return (tmp___0);
}
}
#line 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_post_rx_frags(struct be_rx_obj *rxo , gfp_t gfp , u32 frags_needed ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct be_rx_page_info *prev_page_info ;
  struct be_queue_info *rxq ;
  struct page *pagep ;
  struct device *dev ;
  struct be_eth_rx_d *rxd ;
  u64 page_dmaaddr ;
  u64 frag_dmaaddr ;
  u32 posted ;
  u32 page_offset ;
  u32 notify ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _min1 ;
  u32 _min2 ;
  int tmp___2 ;

  {
#line 2290
  adapter = rxo->adapter;
#line 2291
  page_info = (struct be_rx_page_info *)0;
#line 2291
  prev_page_info = (struct be_rx_page_info *)0;
#line 2292
  rxq = & rxo->q;
#line 2293
  pagep = (struct page *)0;
#line 2294
  dev = & (adapter->pdev)->dev;
#line 2296
  page_dmaaddr = 0ULL;
#line 2297
  page_offset = 0U;
#line 2297
  notify = 0U;
#line 2299
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 2300
  posted = 0U;
#line 2300
  goto ldv_58288;
  ldv_58287: ;
#line 2301
  if ((unsigned long )pagep == (unsigned long )((struct page *)0)) {
#line 2302
    pagep = be_alloc_pages(adapter->big_page_size, gfp);
#line 2303
    tmp = ldv__builtin_expect((unsigned long )pagep == (unsigned long )((struct page *)0),
                           0L);
#line 2303
    if (tmp != 0L) {
#line 2304
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
#line 2305
      goto ldv_58286;
    } else {

    }
#line 2307
    page_dmaaddr = dma_map_page(dev, pagep, 0UL, (size_t )adapter->big_page_size,
                                2);
#line 2310
    tmp___0 = dma_mapping_error(dev, page_dmaaddr);
#line 2310
    if (tmp___0 != 0) {
#line 2311
      put_page(pagep);
#line 2312
      pagep = (struct page *)0;
#line 2313
      adapter->drv_stats.dma_map_errors = adapter->drv_stats.dma_map_errors + 1U;
#line 2314
      goto ldv_58286;
    } else {

    }
#line 2316
    page_offset = 0U;
  } else {
#line 2318
    get_page(pagep);
#line 2319
    page_offset = (u32 )rx_frag_size + page_offset;
  }
#line 2321
  page_info->page_offset = (u16 )page_offset;
#line 2322
  page_info->page = pagep;
#line 2324
  tmp___1 = queue_head_node(rxq);
#line 2324
  rxd = (struct be_eth_rx_d *)tmp___1;
#line 2325
  frag_dmaaddr = (u64 )page_info->page_offset + page_dmaaddr;
#line 2326
  rxd->fragpa_lo = (unsigned int )frag_dmaaddr;
#line 2327
  rxd->fragpa_hi = (unsigned int )(frag_dmaaddr >> 32ULL);
#line 2330
  if (((u32 )rx_frag_size + page_offset) + (u32 )rx_frag_size > adapter->big_page_size) {
#line 2332
    pagep = (struct page *)0;
#line 2333
    page_info->last_frag = 1;
#line 2334
    page_info->bus = page_dmaaddr;
  } else {
#line 2336
    page_info->bus = frag_dmaaddr;
  }
#line 2339
  prev_page_info = page_info;
#line 2340
  queue_head_inc(rxq);
#line 2341
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 2300
  posted = posted + 1U;
  ldv_58288: ;
#line 2300
  if (posted < frags_needed && (unsigned long )page_info->page == (unsigned long )((struct page *)0)) {
#line 2302
    goto ldv_58287;
  } else {

  }
  ldv_58286: ;
#line 2347
  if ((unsigned long )pagep != (unsigned long )((struct page *)0)) {
#line 2348
    prev_page_info->last_frag = 1;
#line 2349
    prev_page_info->bus = page_dmaaddr;
  } else {

  }
#line 2352
  if (posted != 0U) {
#line 2353
    atomic_add((int )posted, & rxq->used);
#line 2354
    if ((int )rxo->rx_post_starved) {
#line 2355
      rxo->rx_post_starved = 0;
    } else {

    }
    ldv_58292: 
#line 2357
    _min1 = 255U;
#line 2357
    _min2 = posted;
#line 2357
    notify = _min1 < _min2 ? _min1 : _min2;
#line 2358
    be_rxq_notify(adapter, (int )rxq->id, (int )((u16 )notify));
#line 2359
    posted = posted - notify;
#line 2360
    if (posted != 0U) {
#line 2362
      goto ldv_58292;
    } else {

    }

  } else {
#line 2361
    tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2361
    if (tmp___2 == 0) {
#line 2363
      rxo->rx_post_starved = 1;
    } else {

    }
  }
#line 2364
  return;
}
}
#line 2367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_tx_compl_info *be_tx_compl_get(struct be_tx_obj *txo ) 
{ 
  struct be_queue_info *tx_cq ;
  struct be_tx_compl_info *txcp ;
  struct be_eth_tx_compl *compl ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
#line 2369
  tx_cq = & txo->cq;
#line 2370
  txcp = & txo->txcp;
#line 2371
  tmp = queue_tail_node(tx_cq);
#line 2371
  compl = (struct be_eth_tx_compl *)tmp;
#line 2373
  if (compl->dw[3UL] == 0U) {
#line 2374
    return ((struct be_tx_compl_info *)0);
  } else {

  }
#line 2377
  __asm__  volatile   ("lfence": : : "memory");
#line 2378
  swap_dws((void *)compl, 16);
#line 2380
  tmp___0 = amap_mask(4U);
#line 2380
  tmp___1 = amap_get((void *)compl, 0U, tmp___0, 28U);
#line 2380
  txcp->status = (u8 )tmp___1;
#line 2381
  tmp___2 = amap_mask(16U);
#line 2381
  tmp___3 = amap_get((void *)compl, 0U, tmp___2, 0U);
#line 2381
  txcp->end_index = (u16 )tmp___3;
#line 2383
  compl->dw[3UL] = 0U;
#line 2384
  queue_tail_inc(tx_cq);
#line 2385
  return (txcp);
}
}
#line 2388 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 be_tx_compl_process(struct be_adapter *adapter , struct be_tx_obj *txo ,
                               u16 last_index ) 
{ 
  struct sk_buff **sent_skbs ;
  struct be_queue_info *txq ;
  u16 frag_index ;
  u16 num_wrbs ;
  struct sk_buff *skb ;
  bool unmap_skb_hdr ;
  struct be_eth_wrb *wrb ;
  void *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 2391
  sent_skbs = (struct sk_buff **)(& txo->sent_skb_list);
#line 2392
  txq = & txo->q;
#line 2393
  num_wrbs = 0U;
#line 2394
  skb = (struct sk_buff *)0;
#line 2395
  unmap_skb_hdr = 0;
  ldv_58312: ;
#line 2399
  if ((unsigned long )*(sent_skbs + (unsigned long )txq->tail) != (unsigned long )((struct sk_buff *)0)) {
#line 2401
    if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 2402
      dev_consume_skb_any(skb);
    } else {

    }
#line 2403
    skb = *(sent_skbs + (unsigned long )txq->tail);
#line 2404
    *(sent_skbs + (unsigned long )txq->tail) = (struct sk_buff *)0;
#line 2405
    queue_tail_inc(txq);
#line 2406
    num_wrbs = (u16 )((int )num_wrbs + 1);
#line 2407
    unmap_skb_hdr = 1;
  } else {

  }
#line 2409
  tmp = queue_tail_node(txq);
#line 2409
  wrb = (struct be_eth_wrb *)tmp;
#line 2410
  frag_index = txq->tail;
#line 2411
  if ((int )unmap_skb_hdr) {
#line 2411
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 2411
    if (tmp___0 != 0U) {
#line 2411
      tmp___1 = 1;
    } else {
#line 2411
      tmp___1 = 0;
    }
  } else {
#line 2411
    tmp___1 = 0;
  }
#line 2411
  unmap_tx_frag(& (adapter->pdev)->dev, wrb, (int )((bool )tmp___1));
#line 2413
  unmap_skb_hdr = 0;
#line 2414
  queue_tail_inc(txq);
#line 2415
  num_wrbs = (u16 )((int )num_wrbs + 1);
#line 2416
  if ((int )frag_index != (int )last_index) {
#line 2418
    goto ldv_58312;
  } else {

  }
#line 2417
  dev_consume_skb_any(skb);
#line 2419
  return (num_wrbs);
}
}
#line 2423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int events_get(struct be_eq_obj *eqo ) 
{ 
  struct be_eq_entry *eqe ;
  int num ;
  void *tmp ;

  {
#line 2426
  num = 0;
  ldv_58320: 
#line 2429
  tmp = queue_tail_node(& eqo->q);
#line 2429
  eqe = (struct be_eq_entry *)tmp;
#line 2430
  if (eqe->evt == 0U) {
#line 2431
    goto ldv_58319;
  } else {

  }
#line 2433
  __asm__  volatile   ("lfence": : : "memory");
#line 2434
  eqe->evt = 0U;
#line 2435
  num = num + 1;
#line 2436
  queue_tail_inc(& eqo->q);
#line 2437
  goto ldv_58320;
  ldv_58319: ;
#line 2439
  return (num);
}
}
#line 2443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eq_clean(struct be_eq_obj *eqo ) 
{ 
  int num ;
  int tmp ;

  {
#line 2445
  tmp = events_get(eqo);
#line 2445
  num = tmp;
#line 2447
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num), 0U);
#line 2448
  return;
}
}
#line 2450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_cq_clean(struct be_rx_obj *rxo ) 
{ 
  struct be_rx_page_info *page_info ;
  struct be_queue_info *rxq ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  int flush_wait ;
  int tmp ;
  u8 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 2453
  rxq = & rxo->q;
#line 2454
  rx_cq = & rxo->cq;
#line 2456
  adapter = rxo->adapter;
#line 2457
  flush_wait = 0;
  ldv_58339: 
#line 2466
  rxcp = be_rx_compl_get(rxo);
#line 2467
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2468
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2469
      goto ldv_58334;
    } else {

    }
#line 2471
    tmp = flush_wait;
#line 2471
    flush_wait = flush_wait + 1;
#line 2471
    if (tmp > 50) {
#line 2474
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 2476
      goto ldv_58334;
    } else {
#line 2471
      tmp___0 = be_check_error(adapter, 3U);
#line 2471
      if ((unsigned int )tmp___0 != 0U) {
#line 2474
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 2476
        goto ldv_58334;
      } else {

      }
    }
#line 2478
    be_cq_notify(adapter, (int )rx_cq->id, 1, 0);
#line 2479
    if (1) {
#line 2479
      __const_udelay(4295000UL);
    } else {
#line 2479
      __ms = 1UL;
#line 2479
      goto ldv_58337;
      ldv_58336: 
#line 2479
      __const_udelay(4295000UL);
      ldv_58337: 
#line 2479
      tmp___1 = __ms;
#line 2479
      __ms = __ms - 1UL;
#line 2479
      if (tmp___1 != 0UL) {
#line 2481
        goto ldv_58336;
      } else {

      }

    }
  } else {
#line 2481
    be_rx_compl_discard(rxo, rxcp);
#line 2482
    be_cq_notify(adapter, (int )rx_cq->id, 0, 1);
#line 2483
    if ((unsigned int )rxcp->num_rcvd == 0U) {
#line 2484
      goto ldv_58334;
    } else {

    }
  }
#line 2486
  goto ldv_58339;
  ldv_58334: 
#line 2489
  be_cq_notify(adapter, (int )rx_cq->id, 0, 0);
#line 2492
  goto ldv_58341;
  ldv_58340: 
#line 2493
  page_info = get_rx_page_info(rxo);
#line 2494
  put_page(page_info->page);
#line 2495
  memset((void *)page_info, 0, 24UL);
  ldv_58341: 
#line 2492
  tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2492
  if (tmp___2 > 0) {
#line 2494
    goto ldv_58340;
  } else {

  }
#line 2497
  tmp___3 = atomic_read((atomic_t const   *)(& rxq->used));
#line 2497
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 0L);
#line 2497
  if (tmp___4 != 0L) {
#line 2497
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (2497), "i" (12UL));
    ldv_58343: ;
#line 2497
    goto ldv_58343;
  } else {

  }
#line 2498
  rxq->tail = 0U;
#line 2499
  rxq->head = 0U;
#line 2500
  return;
}
}
#line 2502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_compl_clean(struct be_adapter *adapter ) 
{ 
  u16 end_idx ;
  u16 notified_idx ;
  u16 cmpl ;
  u16 timeo ;
  u16 num_wrbs ;
  struct device *dev ;
  struct be_tx_compl_info *txcp ;
  struct be_queue_info *txq ;
  struct be_tx_obj *txo ;
  int i ;
  int pending_txqs ;
  u16 tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 2504
  cmpl = 0U;
#line 2504
  timeo = 0U;
#line 2504
  num_wrbs = 0U;
#line 2505
  dev = & (adapter->pdev)->dev;
  ldv_58369: 
#line 2513
  pending_txqs = (int )adapter->num_tx_qs;
#line 2515
  i = 0;
#line 2515
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2515
  goto ldv_58362;
  ldv_58361: 
#line 2516
  cmpl = 0U;
#line 2517
  num_wrbs = 0U;
#line 2518
  txq = & txo->q;
#line 2519
  goto ldv_58359;
  ldv_58358: 
#line 2520
  tmp = be_tx_compl_process(adapter, txo, (int )txcp->end_index);
#line 2520
  num_wrbs = (int )tmp + (int )num_wrbs;
#line 2523
  cmpl = (u16 )((int )cmpl + 1);
  ldv_58359: 
#line 2519
  txcp = be_tx_compl_get(txo);
#line 2519
  if ((unsigned long )txcp != (unsigned long )((struct be_tx_compl_info *)0)) {
#line 2521
    goto ldv_58358;
  } else {

  }

#line 2525
  if ((unsigned int )cmpl != 0U) {
#line 2526
    be_cq_notify(adapter, (int )txo->cq.id, 0, (int )cmpl);
#line 2527
    atomic_sub((int )num_wrbs, & txq->used);
#line 2528
    timeo = 0U;
  } else {

  }
#line 2530
  tmp___0 = be_is_tx_compl_pending(txo);
#line 2530
  if (tmp___0) {
#line 2530
    tmp___1 = 0;
  } else {
#line 2530
    tmp___1 = 1;
  }
#line 2530
  if (tmp___1) {
#line 2531
    pending_txqs = pending_txqs - 1;
  } else {

  }
#line 2515
  i = i + 1;
#line 2515
  txo = txo + 1;
  ldv_58362: ;
#line 2515
  if ((int )adapter->num_tx_qs > i) {
#line 2517
    goto ldv_58361;
  } else {

  }

#line 2534
  if (pending_txqs == 0) {
#line 2536
    goto ldv_58364;
  } else {
#line 2534
    timeo = (u16 )((int )timeo + 1);
#line 2534
    if ((unsigned int )timeo > 10U) {
#line 2536
      goto ldv_58364;
    } else {
#line 2534
      tmp___2 = be_check_error(adapter, 3U);
#line 2534
      if ((unsigned int )tmp___2 != 0U) {
#line 2536
        goto ldv_58364;
      } else {

      }
    }
  }
#line 2538
  if (1) {
#line 2538
    __const_udelay(4295000UL);
  } else {
#line 2538
    __ms = 1UL;
#line 2538
    goto ldv_58367;
    ldv_58366: 
#line 2538
    __const_udelay(4295000UL);
    ldv_58367: 
#line 2538
    tmp___3 = __ms;
#line 2538
    __ms = __ms - 1UL;
#line 2538
    if (tmp___3 != 0UL) {
#line 2540
      goto ldv_58366;
    } else {

    }

  }
#line 2539
  goto ldv_58369;
  ldv_58364: 
#line 2542
  i = 0;
#line 2542
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2542
  goto ldv_58372;
  ldv_58371: 
#line 2543
  txq = & txo->q;
#line 2545
  tmp___8 = atomic_read((atomic_t const   *)(& txq->used));
#line 2545
  if (tmp___8 != 0) {
#line 2546
    tmp___4 = atomic_read((atomic_t const   *)(& txq->used));
#line 2546
    _dev_info((struct device  const  *)dev, "txq%d: cleaning %d pending tx-wrbs\n",
              i, tmp___4);
#line 2548
    notified_idx = txq->tail;
#line 2549
    end_idx = txq->tail;
#line 2550
    tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
#line 2550
    index_adv(& end_idx, (int )((unsigned int )((u16 )tmp___5) + 65535U), (int )txq->len);
#line 2555
    num_wrbs = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 2556
    atomic_sub((int )num_wrbs, & txq->used);
#line 2557
    tmp___6 = atomic_read((atomic_t const   *)(& txq->used));
#line 2557
    tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 2557
    if (tmp___7 != 0L) {
#line 2557
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"),
                           "i" (2557), "i" (12UL));
      ldv_58370: ;
#line 2557
      goto ldv_58370;
    } else {

    }
#line 2558
    txo->pend_wrb_cnt = 0U;
#line 2562
    txq->head = notified_idx;
#line 2563
    txq->tail = notified_idx;
  } else {

  }
#line 2542
  i = i + 1;
#line 2542
  txo = txo + 1;
  ldv_58372: ;
#line 2542
  if ((int )adapter->num_tx_qs > i) {
#line 2544
    goto ldv_58371;
  } else {

  }

#line 2549
  return;
}
}
#line 2568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_evt_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 2573
  i = 0;
#line 2573
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2573
  goto ldv_58380;
  ldv_58379: ;
#line 2574
  if ((int )eqo->q.created) {
#line 2575
    be_eq_clean(eqo);
#line 2576
    be_cmd_q_destroy(adapter, & eqo->q, 1);
#line 2577
    napi_hash_del(& eqo->napi);
#line 2578
    netif_napi_del(& eqo->napi);
  } else {

  }
#line 2580
  free_cpumask_var(eqo->affinity_mask);
#line 2581
  be_queue_free(adapter, & eqo->q);
#line 2573
  i = i + 1;
#line 2573
  eqo = eqo + 1;
  ldv_58380: ;
#line 2573
  if ((int )adapter->num_evt_qs > i) {
#line 2575
    goto ldv_58379;
  } else {

  }

#line 2580
  return;
}
}
#line 2585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_evt_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_eq_obj *eqo ;
  struct be_aic_obj *aic ;
  int i ;
  int rc ;
  u16 __min1 ;
  u16 __min2 ;
  int numa_node___0 ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2592
  __min1 = (unsigned int )adapter->num_msix_vec != 0U ? adapter->num_msix_vec : 1U;
#line 2592
  __min2 = adapter->cfg_num_qs;
#line 2592
  adapter->num_evt_qs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 2595
  i = 0;
#line 2595
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2595
  goto ldv_58395;
  ldv_58394: 
#line 2596
  tmp = dev_to_node(& (adapter->pdev)->dev);
#line 2596
  numa_node___0 = tmp;
#line 2597
  tmp___0 = zalloc_cpumask_var(& eqo->affinity_mask, 208U);
#line 2597
  if (tmp___0) {
#line 2597
    tmp___1 = 0;
  } else {
#line 2597
    tmp___1 = 1;
  }
#line 2597
  if (tmp___1) {
#line 2598
    return (-12);
  } else {

  }
#line 2599
  tmp___2 = cpumask_local_spread((unsigned int )i, numa_node___0);
#line 2599
  cpumask_set_cpu(tmp___2, eqo->affinity_mask);
#line 2601
  netif_napi_add(adapter->netdev, & eqo->napi, & be_poll, 64);
#line 2603
  napi_hash_add(& eqo->napi);
#line 2604
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )i;
#line 2605
  eqo->adapter = adapter;
#line 2606
  eqo->idx = (u8 )i;
#line 2607
  aic->max_eqd = 128U;
#line 2608
  aic->enable = 1;
#line 2610
  eq = & eqo->q;
#line 2611
  rc = be_queue_alloc(adapter, eq, 1024, 4);
#line 2613
  if (rc != 0) {
#line 2614
    return (rc);
  } else {

  }
#line 2616
  rc = be_cmd_eq_create(adapter, eqo);
#line 2617
  if (rc != 0) {
#line 2618
    return (rc);
  } else {

  }
#line 2595
  i = i + 1;
#line 2595
  eqo = eqo + 1;
  ldv_58395: ;
#line 2595
  if ((int )adapter->num_evt_qs > i) {
#line 2597
    goto ldv_58394;
  } else {

  }

#line 2620
  return (0);
}
}
#line 2623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_mcc_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;

  {
#line 2627
  q = & adapter->mcc_obj.q;
#line 2628
  if ((int )q->created) {
#line 2629
    be_cmd_q_destroy(adapter, q, 5);
  } else {

  }
#line 2630
  be_queue_free(adapter, q);
#line 2632
  q = & adapter->mcc_obj.cq;
#line 2633
  if ((int )q->created) {
#line 2634
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2635
  be_queue_free(adapter, q);
#line 2636
  return;
}
}
#line 2639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mcc_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2643
  cq = & adapter->mcc_obj.cq;
#line 2644
  tmp = be_queue_alloc(adapter, cq, 256, 16);
#line 2644
  if (tmp != 0) {
#line 2646
    goto err;
  } else {

  }
#line 2649
  tmp___0 = be_cmd_cq_create(adapter, cq, & ((struct be_eq_obj *)(& adapter->eq_obj))->q,
                             1, 0);
#line 2649
  if (tmp___0 != 0) {
#line 2650
    goto mcc_cq_free;
  } else {

  }
#line 2652
  q = & adapter->mcc_obj.q;
#line 2653
  tmp___1 = be_queue_alloc(adapter, q, 128, 256);
#line 2653
  if (tmp___1 != 0) {
#line 2654
    goto mcc_cq_destroy;
  } else {

  }
#line 2656
  tmp___2 = be_cmd_mccq_create(adapter, q, cq);
#line 2656
  if (tmp___2 != 0) {
#line 2657
    goto mcc_q_free;
  } else {

  }
#line 2659
  return (0);
  mcc_q_free: 
#line 2662
  be_queue_free(adapter, q);
  mcc_cq_destroy: 
#line 2664
  be_cmd_q_destroy(adapter, cq, 2);
  mcc_cq_free: 
#line 2666
  be_queue_free(adapter, cq);
  err: ;
#line 2668
  return (-1);
}
}
#line 2671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_tx_obj *txo ;
  u8 i ;

  {
#line 2677
  i = 0U;
#line 2677
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2677
  goto ldv_58417;
  ldv_58416: 
#line 2678
  q = & txo->q;
#line 2679
  if ((int )q->created) {
#line 2680
    be_cmd_q_destroy(adapter, q, 3);
  } else {

  }
#line 2681
  be_queue_free(adapter, q);
#line 2683
  q = & txo->cq;
#line 2684
  if ((int )q->created) {
#line 2685
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2686
  be_queue_free(adapter, q);
#line 2677
  i = (u8 )((int )i + 1);
#line 2677
  txo = txo + 1;
  ldv_58417: ;
#line 2677
  if ((int )((unsigned short )i) < (int )adapter->num_tx_qs) {
#line 2679
    goto ldv_58416;
  } else {

  }

#line 2684
  return;
}
}
#line 2690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_tx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *cq ;
  struct be_tx_obj *txo ;
  struct be_eq_obj *eqo ;
  int status ;
  int i ;
  u16 _min1 ;
  u16 _min2 ;

  {
#line 2697
  _min1 = adapter->num_evt_qs;
#line 2697
  _min2 = adapter->res.max_tx_qs;
#line 2697
  adapter->num_tx_qs = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 2699
  i = 0;
#line 2699
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2699
  goto ldv_58431;
  ldv_58430: 
#line 2700
  cq = & txo->cq;
#line 2701
  status = be_queue_alloc(adapter, cq, 1024, 16);
#line 2703
  if (status != 0) {
#line 2704
    return (status);
  } else {

  }
#line 2706
  u64_stats_init(& txo->stats.sync);
#line 2707
  u64_stats_init(& txo->stats.sync_compl);
#line 2712
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )(i % (int )adapter->num_evt_qs);
#line 2713
  status = be_cmd_cq_create(adapter, cq, & eqo->q, 0, 3);
#line 2714
  if (status != 0) {
#line 2715
    return (status);
  } else {

  }
#line 2717
  status = be_queue_alloc(adapter, & txo->q, 2048, 16);
#line 2719
  if (status != 0) {
#line 2720
    return (status);
  } else {

  }
#line 2722
  status = be_cmd_txq_create(adapter, txo);
#line 2723
  if (status != 0) {
#line 2724
    return (status);
  } else {

  }
#line 2726
  netif_set_xps_queue(adapter->netdev, (struct cpumask  const  *)eqo->affinity_mask,
                      (int )eqo->idx);
#line 2699
  i = i + 1;
#line 2699
  txo = txo + 1;
  ldv_58431: ;
#line 2699
  if ((int )adapter->num_tx_qs > i) {
#line 2701
    goto ldv_58430;
  } else {

  }
#line 2730
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d TX queue(s)\n",
            (int )adapter->num_tx_qs);
#line 2732
  return (0);
}
}
#line 2735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_cqs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2741
  i = 0;
#line 2741
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2741
  goto ldv_58440;
  ldv_58439: 
#line 2742
  q = & rxo->cq;
#line 2743
  if ((int )q->created) {
#line 2744
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2745
  be_queue_free(adapter, q);
#line 2741
  i = i + 1;
#line 2741
  rxo = rxo + 1;
  ldv_58440: ;
#line 2741
  if ((int )adapter->num_rx_qs > i) {
#line 2743
    goto ldv_58439;
  } else {

  }

#line 2748
  return;
}
}
#line 2749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_rx_cqs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int tmp ;

  {
#line 2756
  adapter->num_rss_qs = adapter->num_evt_qs;
#line 2759
  if ((unsigned int )adapter->num_rss_qs <= 1U) {
#line 2760
    adapter->num_rss_qs = 0U;
  } else {

  }
#line 2762
  adapter->num_rx_qs = (int )adapter->num_rss_qs + (int )adapter->need_def_rxq;
#line 2767
  if ((unsigned int )adapter->num_rx_qs == 0U) {
#line 2768
    adapter->num_rx_qs = 1U;
  } else {

  }
#line 2770
  tmp = __get_order((unsigned long )rx_frag_size);
#line 2770
  adapter->big_page_size = (u32 )((unsigned long )(1 << tmp)) * 4096U;
#line 2771
  i = 0;
#line 2771
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2771
  goto ldv_58451;
  ldv_58450: 
#line 2772
  rxo->adapter = adapter;
#line 2773
  cq = & rxo->cq;
#line 2774
  rc = be_queue_alloc(adapter, cq, 1024, 16);
#line 2776
  if (rc != 0) {
#line 2777
    return (rc);
  } else {

  }
#line 2779
  u64_stats_init(& rxo->stats.sync);
#line 2780
  eq = & adapter->eq_obj[i % (int )adapter->num_evt_qs].q;
#line 2781
  rc = be_cmd_cq_create(adapter, cq, eq, 0, 3);
#line 2782
  if (rc != 0) {
#line 2783
    return (rc);
  } else {

  }
#line 2771
  i = i + 1;
#line 2771
  rxo = rxo + 1;
  ldv_58451: ;
#line 2771
  if ((int )adapter->num_rx_qs > i) {
#line 2773
    goto ldv_58450;
  } else {

  }
#line 2786
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d RX queue(s)\n",
            (int )adapter->num_rx_qs);
#line 2788
  return (0);
}
}
#line 2791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static irqreturn_t be_intx(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;
  struct be_adapter *adapter ;
  int num_evts ;
  bool tmp ;
  u16 tmp___0 ;

  {
#line 2793
  eqo = (struct be_eq_obj *)dev;
#line 2794
  adapter = eqo->adapter;
#line 2795
  num_evts = 0;
#line 2805
  tmp = napi_schedule_prep(& eqo->napi);
#line 2805
  if ((int )tmp) {
#line 2806
    num_evts = events_get(eqo);
#line 2807
    __napi_schedule(& eqo->napi);
#line 2808
    if (num_evts != 0) {
#line 2809
      eqo->spurious_intr = 0U;
    } else {

    }
  } else {

  }
#line 2811
  be_eq_notify(adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num_evts), 0U);
#line 2817
  if (num_evts != 0) {
#line 2818
    return (1);
  } else {
#line 2817
    tmp___0 = eqo->spurious_intr;
#line 2817
    eqo->spurious_intr = (u16 )((int )eqo->spurious_intr + 1);
#line 2817
    if ((unsigned int )tmp___0 == 0U) {
#line 2818
      return (1);
    } else {
#line 2820
      return (0);
    }
  }
}
}
#line 2823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static irqreturn_t be_msix(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;

  {
#line 2825
  eqo = (struct be_eq_obj *)dev;
#line 2827
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0, 0U);
#line 2828
  napi_schedule(& eqo->napi);
#line 2829
  return (1);
}
}
#line 2832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool do_gro(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 2834
  return ((bool )(((unsigned int )rxcp->tcpf != 0U && (unsigned int )rxcp->err == 0U) && (unsigned int )rxcp->l4_csum != 0U));
}
}
#line 2837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_process_rx(struct be_rx_obj *rxo , struct napi_struct *napi , int budget ,
                         int polling ) 
{ 
  struct be_adapter *adapter ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  u32 work_done ;
  u32 frags_consumed ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  u32 __max1 ;
  u32 __max2 ;
  int tmp___3 ;

  {
#line 2840
  adapter = rxo->adapter;
#line 2841
  rx_cq = & rxo->cq;
#line 2844
  frags_consumed = 0U;
#line 2846
  work_done = 0U;
#line 2846
  goto ldv_58482;
  ldv_58481: 
#line 2847
  rxcp = be_rx_compl_get(rxo);
#line 2848
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2849
    goto ldv_58479;
  } else {

  }
#line 2852
  tmp = ldv__builtin_expect((unsigned int )rxcp->num_rcvd == 0U, 0L);
#line 2852
  if (tmp != 0L) {
#line 2853
    goto loop_continue;
  } else {

  }
#line 2856
  tmp___0 = ldv__builtin_expect((unsigned int )rxcp->pkt_size == 0U, 0L);
#line 2856
  if (tmp___0 != 0L) {
#line 2857
    be_rx_compl_discard(rxo, rxcp);
#line 2858
    goto loop_continue;
  } else {

  }
#line 2864
  tmp___1 = ldv__builtin_expect((long )((u32 )rxcp->port != adapter->port_num && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)),
                             0L);
#line 2864
  if (tmp___1 != 0L) {
#line 2866
    be_rx_compl_discard(rxo, rxcp);
#line 2867
    goto loop_continue;
  } else {

  }
#line 2871
  tmp___2 = do_gro(rxcp);
#line 2871
  if ((int )tmp___2 && polling != 1) {
#line 2872
    be_rx_compl_process_gro(rxo, napi, rxcp);
  } else {
#line 2874
    be_rx_compl_process(rxo, napi, rxcp);
  }
  loop_continue: 
#line 2877
  frags_consumed = (u32 )rxcp->num_rcvd + frags_consumed;
#line 2878
  be_rx_stats_update(rxo, rxcp);
#line 2846
  work_done = work_done + 1U;
  ldv_58482: ;
#line 2846
  if ((u32 )budget > work_done) {
#line 2848
    goto ldv_58481;
  } else {

  }
  ldv_58479: ;
#line 2881
  if (work_done != 0U) {
#line 2882
    be_cq_notify(adapter, (int )rx_cq->id, 1, (int )((u16 )work_done));
#line 2887
    tmp___3 = atomic_read((atomic_t const   *)(& rxo->q.used));
#line 2887
    if (tmp___3 <= 959 && ! rxo->rx_post_starved) {
#line 2890
      __max1 = 64U;
#line 2890
      __max2 = frags_consumed;
#line 2890
      be_post_rx_frags(rxo, 32U, __max1 > __max2 ? __max1 : __max2);
    } else {

    }
  } else {

  }
#line 2894
  return ((int )work_done);
}
}
#line 2897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void be_update_tx_err(struct be_tx_obj *txo , u8 status ) 
{ 


  {
#line 2899
  switch ((int )status) {
  case 2: 
#line 2901
  txo->stats.tx_hdr_parse_err = txo->stats.tx_hdr_parse_err + 1U;
#line 2902
  goto ldv_58491;
  case 3: 
#line 2904
  txo->stats.tx_dma_err = txo->stats.tx_dma_err + 1U;
#line 2905
  goto ldv_58491;
  case 5: 
#line 2907
  txo->stats.tx_spoof_check_err = txo->stats.tx_spoof_check_err + 1U;
#line 2908
  goto ldv_58491;
  }
  ldv_58491: ;
#line 2911
  return;
}
}
#line 2912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void lancer_update_tx_err(struct be_tx_obj *txo , u8 status ) 
{ 


  {
#line 2914
  switch ((int )status) {
  case 1: 
#line 2916
  txo->stats.tx_tso_err = txo->stats.tx_tso_err + 1U;
#line 2917
  goto ldv_58499;
  case 3: ;
  case 5: 
#line 2920
  txo->stats.tx_spoof_check_err = txo->stats.tx_spoof_check_err + 1U;
#line 2921
  goto ldv_58499;
  case 7: 
#line 2923
  txo->stats.tx_qinq_err = txo->stats.tx_qinq_err + 1U;
#line 2924
  goto ldv_58499;
  case 11: 
#line 2926
  txo->stats.tx_internal_parity_err = txo->stats.tx_internal_parity_err + 1U;
#line 2927
  goto ldv_58499;
  case 13: 
#line 2929
  txo->stats.tx_dma_err = txo->stats.tx_dma_err + 1U;
#line 2930
  goto ldv_58499;
  }
  ldv_58499: ;
#line 2933
  return;
}
}
#line 2934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_process_tx(struct be_adapter *adapter , struct be_tx_obj *txo , int idx ) 
{ 
  int num_wrbs ;
  int work_done ;
  struct be_tx_compl_info *txcp ;
  u16 tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2937
  num_wrbs = 0;
#line 2937
  work_done = 0;
#line 2940
  goto ldv_58514;
  ldv_58513: 
#line 2941
  tmp = be_tx_compl_process(adapter, txo, (int )txcp->end_index);
#line 2941
  num_wrbs = (int )tmp + num_wrbs;
#line 2942
  work_done = work_done + 1;
#line 2944
  if ((unsigned int )txcp->status != 0U) {
#line 2945
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2946
      lancer_update_tx_err(txo, (int )txcp->status);
    } else {
#line 2948
      be_update_tx_err(txo, (int )txcp->status);
    }
  } else {

  }
  ldv_58514: 
#line 2940
  txcp = be_tx_compl_get(txo);
#line 2940
  if ((unsigned long )txcp != (unsigned long )((struct be_tx_compl_info *)0)) {
#line 2942
    goto ldv_58513;
  } else {

  }

#line 2952
  if (work_done != 0) {
#line 2953
    be_cq_notify(adapter, (int )txo->cq.id, 1, (int )((u16 )work_done));
#line 2954
    atomic_sub(num_wrbs, & txo->q.used);
#line 2958
    tmp___0 = __netif_subqueue_stopped((struct net_device  const  *)adapter->netdev,
                                       (int )((u16 )idx));
#line 2958
    if ((int )tmp___0) {
#line 2958
      tmp___1 = be_can_txq_wake(txo);
#line 2958
      if ((int )tmp___1) {
#line 2960
        netif_wake_subqueue(adapter->netdev, (int )((u16 )idx));
      } else {

      }
    } else {

    }
#line 2963
    u64_stats_init(& txo->stats.sync_compl);
#line 2964
    txo->stats.tx_compl = txo->stats.tx_compl + (u64 )work_done;
#line 2965
    u64_stats_init(& txo->stats.sync_compl);
  } else {

  }
#line 2967
  return;
}
}
#line 2970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_lock_napi(struct be_eq_obj *eqo ) 
{ 
  bool status ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 2972
  status = 1;
#line 2974
  spin_lock(& eqo->lock);
#line 2975
  if ((eqo->state & 3U) != 0U) {
#line 2976
    __ret_warn_on = (int )eqo->state & 1;
#line 2976
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2976
    if (tmp != 0L) {
#line 2976
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c",
                         2976);
    } else {

    }
#line 2976
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2977
    eqo->state = eqo->state | 4U;
#line 2978
    status = 0;
  } else {
#line 2980
    eqo->state = 1U;
  }
#line 2982
  spin_unlock(& eqo->lock);
#line 2983
  return (status);
}
}
#line 2986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void be_unlock_napi(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 2988
  spin_lock(& eqo->lock);
#line 2990
  __ret_warn_on = (eqo->state & 6U) != 0U;
#line 2990
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2990
  if (tmp != 0L) {
#line 2990
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c",
                       2990);
  } else {

  }
#line 2990
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2991
  eqo->state = 0U;
#line 2993
  spin_unlock(& eqo->lock);
#line 2994
  return;
}
}
#line 2996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool be_lock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  bool status ;

  {
#line 2998
  status = 1;
#line 3000
  spin_lock_bh(& eqo->lock);
#line 3001
  if ((eqo->state & 3U) != 0U) {
#line 3002
    eqo->state = eqo->state | 8U;
#line 3003
    status = 0;
  } else {
#line 3005
    eqo->state = eqo->state | 2U;
  }
#line 3007
  spin_unlock_bh(& eqo->lock);
#line 3008
  return (status);
}
}
#line 3011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void be_unlock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 3013
  spin_lock_bh(& eqo->lock);
#line 3015
  __ret_warn_on = (int )eqo->state & 1;
#line 3015
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 3015
  if (tmp != 0L) {
#line 3015
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c",
                       3015);
  } else {

  }
#line 3015
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 3016
  eqo->state = 0U;
#line 3018
  spin_unlock_bh(& eqo->lock);
#line 3019
  return;
}
}
#line 3021 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void be_enable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  struct lock_class_key __key ;

  {
#line 3023
  spinlock_check(& eqo->lock);
#line 3023
  __raw_spin_lock_init(& eqo->lock.__annonCompField18.rlock, "&(&eqo->lock)->rlock",
                       & __key);
#line 3024
  eqo->state = 0U;
#line 3025
  return;
}
}
#line 3027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void be_disable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 3029
  local_bh_disable();
#line 3034
  goto ldv_58548;
  ldv_58547: ;
#line 3035
  if (1) {
#line 3035
    __const_udelay(4295000UL);
  } else {
#line 3035
    __ms = 1UL;
#line 3035
    goto ldv_58545;
    ldv_58544: 
#line 3035
    __const_udelay(4295000UL);
    ldv_58545: 
#line 3035
    tmp = __ms;
#line 3035
    __ms = __ms - 1UL;
#line 3035
    if (tmp != 0UL) {
#line 3037
      goto ldv_58544;
    } else {

    }

  }
  ldv_58548: 
#line 3034
  tmp___0 = be_lock_napi(eqo);
#line 3034
  if (tmp___0) {
#line 3034
    tmp___1 = 0;
  } else {
#line 3034
    tmp___1 = 1;
  }
#line 3034
  if (tmp___1) {
#line 3036
    goto ldv_58547;
  } else {

  }
#line 3037
  local_bh_enable();
#line 3038
  return;
}
}
#line 3069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
int be_poll(struct napi_struct *napi , int budget ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  int max_work ;
  int work ;
  int i ;
  int num_evts ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u32 mult_enc ;
  int _max1 ;
  int _max2 ;
  bool tmp ;

  {
#line 3071
  __mptr = (struct napi_struct  const  *)napi;
#line 3071
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffffa0UL;
#line 3072
  adapter = eqo->adapter;
#line 3073
  max_work = 0;
#line 3076
  mult_enc = 0U;
#line 3078
  num_evts = events_get(eqo);
#line 3080
  i = (int )eqo->idx;
#line 3080
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 3080
  goto ldv_58566;
  ldv_58565: 
#line 3081
  be_process_tx(adapter, txo, i);
#line 3080
  i = (int )adapter->num_evt_qs + i;
#line 3080
  txo = txo + (unsigned long )adapter->num_evt_qs;
  ldv_58566: ;
#line 3080
  if ((int )adapter->num_tx_qs > i) {
#line 3082
    goto ldv_58565;
  } else {

  }
#line 3083
  tmp = be_lock_napi(eqo);
#line 3083
  if ((int )tmp) {
#line 3088
    i = (int )eqo->idx;
#line 3088
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3088
    goto ldv_58572;
    ldv_58571: 
#line 3089
    work = be_process_rx(rxo, napi, budget, 0);
#line 3090
    _max1 = work;
#line 3090
    _max2 = max_work;
#line 3090
    max_work = _max1 > _max2 ? _max1 : _max2;
#line 3088
    i = (int )adapter->num_evt_qs + i;
#line 3088
    rxo = rxo + (unsigned long )adapter->num_evt_qs;
    ldv_58572: ;
#line 3088
    if ((int )adapter->num_rx_qs > i) {
#line 3090
      goto ldv_58571;
    } else {

    }
#line 3092
    be_unlock_napi(eqo);
  } else {
#line 3094
    max_work = budget;
  }
#line 3097
  if ((unsigned int )eqo->idx == 0U) {
#line 3098
    be_process_mcc(adapter);
  } else {

  }
#line 3100
  if (max_work < budget) {
#line 3101
    napi_complete(napi);
#line 3106
    if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3107
      mult_enc = be_get_eq_delay_mult_enc(eqo);
    } else {

    }
#line 3109
    be_eq_notify(adapter, (int )eqo->q.id, 1, 0, (int )((u16 )num_evts), mult_enc);
  } else {
#line 3113
    be_eq_notify(adapter, (int )eqo->q.id, 0, 0, (int )((u16 )num_evts), 0U);
  }
#line 3115
  return (max_work);
}
}
#line 3119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_busy_poll(struct napi_struct *napi ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  struct be_rx_obj *rxo ;
  int i ;
  int work ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3121
  __mptr = (struct napi_struct  const  *)napi;
#line 3121
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffffa0UL;
#line 3122
  adapter = eqo->adapter;
#line 3124
  work = 0;
#line 3126
  tmp = be_lock_busy_poll(eqo);
#line 3126
  if (tmp) {
#line 3126
    tmp___0 = 0;
  } else {
#line 3126
    tmp___0 = 1;
  }
#line 3126
  if (tmp___0) {
#line 3127
    return (-2);
  } else {

  }
#line 3129
  i = (int )eqo->idx;
#line 3129
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3129
  goto ldv_58586;
  ldv_58585: 
#line 3130
  work = be_process_rx(rxo, napi, 4, 1);
#line 3131
  if (work != 0) {
#line 3132
    goto ldv_58584;
  } else {

  }
#line 3129
  i = (int )adapter->num_evt_qs + i;
#line 3129
  rxo = rxo + (unsigned long )adapter->num_evt_qs;
  ldv_58586: ;
#line 3129
  if ((int )adapter->num_rx_qs > i) {
#line 3131
    goto ldv_58585;
  } else {

  }
  ldv_58584: 
#line 3135
  be_unlock_busy_poll(eqo);
#line 3136
  return (work);
}
}
#line 3140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
void be_detect_error(struct be_adapter *adapter ) 
{ 
  u32 ue_lo ;
  u32 ue_hi ;
  u32 ue_lo_mask ;
  u32 ue_hi_mask ;
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;
  u32 i ;
  struct device *dev ;
  u8 tmp ;

  {
#line 3142
  ue_lo = 0U;
#line 3142
  ue_hi = 0U;
#line 3142
  ue_lo_mask = 0U;
#line 3142
  ue_hi_mask = 0U;
#line 3143
  sliport_status = 0U;
#line 3143
  sliport_err1 = 0U;
#line 3143
  sliport_err2 = 0U;
#line 3145
  dev = & (adapter->pdev)->dev;
#line 3147
  tmp = be_check_error(adapter, 3U);
#line 3147
  if ((unsigned int )tmp != 0U) {
#line 3148
    return;
  } else {

  }
#line 3150
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 3151
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 3152
    if ((int )sliport_status < 0) {
#line 3153
      be_set_error(adapter, 2);
#line 3154
      sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 3156
      sliport_err2 = ioread32((void *)adapter->db + 1040U);
#line 3159
      if (sliport_err1 == 2U && sliport_err2 == 0U) {
#line 3161
        _dev_info((struct device  const  *)dev, "Firmware update in progress\n");
      } else {
#line 3163
        dev_err((struct device  const  *)dev, "Error detected in the card\n");
#line 3164
        dev_err((struct device  const  *)dev, "ERR: sliport status 0x%x\n", sliport_status);
#line 3166
        dev_err((struct device  const  *)dev, "ERR: sliport error1 0x%x\n", sliport_err1);
#line 3168
        dev_err((struct device  const  *)dev, "ERR: sliport error2 0x%x\n", sliport_err2);
      }
    } else {

    }
  } else {
#line 3173
    ue_lo = ioread32((void *)adapter->pcicfg + 160U);
#line 3174
    ue_hi = ioread32((void *)adapter->pcicfg + 164U);
#line 3175
    ue_lo_mask = ioread32((void *)adapter->pcicfg + 168U);
#line 3177
    ue_hi_mask = ioread32((void *)adapter->pcicfg + 172U);
#line 3180
    ue_lo = ~ ue_lo_mask & ue_lo;
#line 3181
    ue_hi = ~ ue_hi_mask & ue_hi;
#line 3188
    if (ue_lo != 0U || ue_hi != 0U) {
#line 3189
      dev_err((struct device  const  *)dev, "Unrecoverable Error detected in the adapter");
#line 3191
      dev_err((struct device  const  *)dev, "Please reboot server to recover");
#line 3192
      if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3193
        be_set_error(adapter, 2);
      } else {

      }
#line 3195
      i = 0U;
#line 3195
      goto ldv_58600;
      ldv_58599: ;
#line 3196
      if ((int )ue_lo & 1) {
#line 3197
        dev_err((struct device  const  *)dev, "UE: %s bit set\n", ue_status_low_desc[i]);
      } else {

      }
#line 3195
      ue_lo = ue_lo >> 1;
#line 3195
      i = i + 1U;
      ldv_58600: ;
#line 3195
      if (ue_lo != 0U) {
#line 3197
        goto ldv_58599;
      } else {

      }
#line 3200
      i = 0U;
#line 3200
      goto ldv_58603;
      ldv_58602: ;
#line 3201
      if ((int )ue_hi & 1) {
#line 3202
        dev_err((struct device  const  *)dev, "UE: %s bit set\n", ue_status_hi_desc[i]);
      } else {

      }
#line 3200
      ue_hi = ue_hi >> 1;
#line 3200
      i = i + 1U;
      ldv_58603: ;
#line 3200
      if (ue_hi != 0U) {
#line 3202
        goto ldv_58602;
      } else {

      }

    } else {

    }
  }
#line 3209
  return;
}
}
#line 3209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_msix_disable(struct be_adapter *adapter ) 
{ 


  {
#line 3211
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 3212
    pci_disable_msix(adapter->pdev);
#line 3213
    adapter->num_msix_vec = 0U;
#line 3214
    adapter->num_msix_roce_vec = 0U;
  } else {

  }
#line 3216
  return;
}
}
#line 3218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_msix_enable(struct be_adapter *adapter ) 
{ 
  int i ;
  int num_vec ;
  struct device *dev ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;

  {
#line 3221
  dev = & (adapter->pdev)->dev;
#line 3227
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 3228
    __min1 = (int )adapter->res.max_evt_qs * 2;
#line 3228
    tmp = cpumask_weight(cpu_online_mask);
#line 3228
    __min2 = (int )(tmp * 2U);
#line 3228
    num_vec = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 3231
    num_vec = (int )adapter->cfg_num_qs;
  }
#line 3233
  i = 0;
#line 3233
  goto ldv_58618;
  ldv_58617: 
#line 3234
  adapter->msix_entries[i].entry = (u16 )i;
#line 3233
  i = i + 1;
  ldv_58618: ;
#line 3233
  if (i < num_vec) {
#line 3235
    goto ldv_58617;
  } else {

  }
#line 3236
  num_vec = pci_enable_msix_range(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                                  1, num_vec);
#line 3238
  if (num_vec < 0) {
#line 3239
    goto fail;
  } else {

  }
#line 3241
  if ((((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) && num_vec > 1) {
#line 3242
    adapter->num_msix_roce_vec = (u32 )(num_vec / 2);
#line 3243
    _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for RoCE\n",
              adapter->num_msix_roce_vec);
  } else {

  }
#line 3247
  adapter->num_msix_vec = (int )((u16 )num_vec) - (int )((u16 )adapter->num_msix_roce_vec);
#line 3249
  _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for NIC\n",
            (int )adapter->num_msix_vec);
#line 3251
  return (0);
  fail: 
#line 3254
  dev_warn((struct device  const  *)dev, "MSIx enable failed\n");
#line 3257
  if ((unsigned int )adapter->virtfn != 0U) {
#line 3258
    return (num_vec);
  } else {

  }
#line 3259
  return (0);
}
}
#line 3262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int be_msix_vec_get(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 


  {
#line 3265
  return ((int )adapter->msix_entries[(int )eqo->msix_idx].vector);
}
}
#line 3268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_msix_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int status ;
  int i ;
  int vec ;
  int tmp ;

  {
#line 3270
  netdev = adapter->netdev;
#line 3274
  i = 0;
#line 3274
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3274
  goto ldv_58635;
  ldv_58634: 
#line 3275
  sprintf((char *)(& eqo->desc), "%s-q%d", (char *)(& netdev->name), i);
#line 3276
  vec = be_msix_vec_get(adapter, eqo);
#line 3277
  status = ldv_request_irq_10((unsigned int )vec, & be_msix, 0UL, (char const   *)(& eqo->desc),
                              (void *)eqo);
#line 3278
  if (status != 0) {
#line 3279
    goto err_msix;
  } else {

  }
#line 3281
  irq_set_affinity_hint((unsigned int )vec, (struct cpumask  const  *)eqo->affinity_mask);
#line 3274
  i = i + 1;
#line 3274
  eqo = eqo + 1;
  ldv_58635: ;
#line 3274
  if ((int )adapter->num_evt_qs > i) {
#line 3276
    goto ldv_58634;
  } else {

  }

#line 3284
  return (0);
  err_msix: 
#line 3286
  i = i - 1;
#line 3286
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3286
  goto ldv_58638;
  ldv_58637: 
#line 3287
  tmp = be_msix_vec_get(adapter, eqo);
#line 3287
  ldv_free_irq_11((unsigned int )tmp, (void *)eqo);
#line 3286
  i = i - 1;
#line 3286
  eqo = eqo - 1;
  ldv_58638: ;
#line 3286
  if (i >= 0) {
#line 3288
    goto ldv_58637;
  } else {

  }
#line 3288
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "MSIX Request IRQ failed - err %d\n",
           status);
#line 3290
  be_msix_disable(adapter);
#line 3291
  return (status);
}
}
#line 3294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_irq_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 3296
  netdev = adapter->netdev;
#line 3299
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 3300
    status = be_msix_register(adapter);
#line 3301
    if (status == 0) {
#line 3302
      goto done;
    } else {

    }
#line 3304
    if ((unsigned int )adapter->virtfn != 0U) {
#line 3305
      return (status);
    } else {

    }
  } else {

  }
#line 3309
  netdev->irq = (int )(adapter->pdev)->irq;
#line 3310
  status = ldv_request_irq_12((unsigned int )netdev->irq, & be_intx, 128UL, (char const   *)(& netdev->name),
                              (void *)(& adapter->eq_obj));
#line 3312
  if (status != 0) {
#line 3313
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "INTx request IRQ failed - err %d\n",
            status);
#line 3315
    return (status);
  } else {

  }
  done: 
#line 3318
  adapter->isr_registered = 1;
#line 3319
  return (0);
}
}
#line 3322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_irq_unregister(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int i ;
  int vec ;

  {
#line 3324
  netdev = adapter->netdev;
#line 3328
  if (! adapter->isr_registered) {
#line 3329
    return;
  } else {

  }
#line 3332
  if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 3333
    ldv_free_irq_13((unsigned int )netdev->irq, (void *)(& adapter->eq_obj));
#line 3334
    goto done;
  } else {

  }
#line 3338
  i = 0;
#line 3338
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3338
  goto ldv_58655;
  ldv_58654: 
#line 3339
  vec = be_msix_vec_get(adapter, eqo);
#line 3340
  irq_set_affinity_hint((unsigned int )vec, (struct cpumask  const  *)0);
#line 3341
  ldv_free_irq_14((unsigned int )vec, (void *)eqo);
#line 3338
  i = i + 1;
#line 3338
  eqo = eqo + 1;
  ldv_58655: ;
#line 3338
  if ((int )adapter->num_evt_qs > i) {
#line 3340
    goto ldv_58654;
  } else {

  }

  done: 
#line 3345
  adapter->isr_registered = 0;
#line 3346
  return;
}
}
#line 3348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_qs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 3354
  i = 0;
#line 3354
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3354
  goto ldv_58664;
  ldv_58663: 
#line 3355
  q = & rxo->q;
#line 3356
  if ((int )q->created) {
#line 3357
    be_cmd_rxq_destroy(adapter, q);
#line 3358
    be_rx_cq_clean(rxo);
  } else {

  }
#line 3360
  be_queue_free(adapter, q);
#line 3354
  i = i + 1;
#line 3354
  rxo = rxo + 1;
  ldv_58664: ;
#line 3354
  if ((int )adapter->num_rx_qs > i) {
#line 3356
    goto ldv_58663;
  } else {

  }

#line 3361
  return;
}
}
#line 3364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_close(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp___0 ;

  {
#line 3366
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3366
  adapter = (struct be_adapter *)tmp;
#line 3373
  if (((unsigned long )adapter->flags & 512UL) == 0UL) {
#line 3374
    return (0);
  } else {

  }
#line 3376
  be_roce_dev_close(adapter);
#line 3378
  if (((unsigned long )adapter->flags & 64UL) != 0UL) {
#line 3379
    i = 0;
#line 3379
    eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3379
    goto ldv_58673;
    ldv_58672: 
#line 3380
    napi_disable(& eqo->napi);
#line 3381
    be_disable_busy_poll(eqo);
#line 3379
    i = i + 1;
#line 3379
    eqo = eqo + 1;
    ldv_58673: ;
#line 3379
    if ((int )adapter->num_evt_qs > i) {
#line 3381
      goto ldv_58672;
    } else {

    }
#line 3383
    adapter->flags = adapter->flags & 4294967231U;
  } else {

  }
#line 3386
  be_async_mcc_disable(adapter);
#line 3391
  netif_tx_disable(netdev);
#line 3392
  be_tx_compl_clean(adapter);
#line 3394
  be_rx_qs_destroy(adapter);
#line 3395
  be_clear_uc_list(adapter);
#line 3397
  i = 0;
#line 3397
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3397
  goto ldv_58676;
  ldv_58675: ;
#line 3398
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 3399
    tmp___0 = be_msix_vec_get(adapter, eqo);
#line 3399
    synchronize_irq((unsigned int )tmp___0);
  } else {
#line 3401
    synchronize_irq((unsigned int )netdev->irq);
  }
#line 3402
  be_eq_clean(eqo);
#line 3397
  i = i + 1;
#line 3397
  eqo = eqo + 1;
  ldv_58676: ;
#line 3397
  if ((int )adapter->num_evt_qs > i) {
#line 3399
    goto ldv_58675;
  } else {

  }
#line 3405
  be_irq_unregister(adapter);
#line 3407
  return (0);
}
}
#line 3410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_rx_qs_create(struct be_adapter *adapter ) 
{ 
  struct rss_info *rss ;
  u8 rss_key[40U] ;
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int j ;
  bool tmp ;

  {
#line 3412
  rss = & adapter->rss_info;
#line 3417
  i = 0;
#line 3417
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3417
  goto ldv_58688;
  ldv_58687: 
#line 3418
  rc = be_queue_alloc(adapter, & rxo->q, 1024, 8);
#line 3420
  if (rc != 0) {
#line 3421
    return (rc);
  } else {

  }
#line 3417
  i = i + 1;
#line 3417
  rxo = rxo + 1;
  ldv_58688: ;
#line 3417
  if ((int )adapter->num_rx_qs > i) {
#line 3419
    goto ldv_58687;
  } else {

  }

#line 3424
  if ((unsigned int )adapter->need_def_rxq != 0U || (unsigned int )adapter->num_rss_qs == 0U) {
#line 3425
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + ((unsigned long )adapter->num_rx_qs + 0xffffffffffffffffUL);
#line 3426
    rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                           (u32 )adapter->if_handle, 0U, & rxo->rss_id);
#line 3429
    if (rc != 0) {
#line 3430
      return (rc);
    } else {

    }
  } else {

  }
#line 3433
  i = 0;
#line 3433
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3433
  goto ldv_58691;
  ldv_58690: 
#line 3434
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 1U, & rxo->rss_id);
#line 3437
  if (rc != 0) {
#line 3438
    return (rc);
  } else {

  }
#line 3433
  i = i + 1;
#line 3433
  rxo = rxo + 1;
  ldv_58691: ;
#line 3433
  if ((int )adapter->num_rss_qs > i) {
#line 3435
    goto ldv_58690;
  } else {

  }
#line 3441
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 3441
  if ((int )tmp) {
#line 3442
    j = 0;
#line 3442
    goto ldv_58697;
    ldv_58696: 
#line 3443
    i = 0;
#line 3443
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3443
    goto ldv_58695;
    ldv_58694: ;
#line 3444
    if (j + i > 127) {
#line 3445
      goto ldv_58693;
    } else {

    }
#line 3446
    rss->rsstable[j + i] = rxo->rss_id;
#line 3447
    rss->rss_queue[j + i] = (u8 )i;
#line 3443
    i = i + 1;
#line 3443
    rxo = rxo + 1;
    ldv_58695: ;
#line 3443
    if ((int )adapter->num_rss_qs > i) {
#line 3445
      goto ldv_58694;
    } else {

    }
    ldv_58693: 
#line 3442
    j = (int )adapter->num_rss_qs + j;
    ldv_58697: ;
#line 3442
    if (j <= 127) {
#line 3444
      goto ldv_58696;
    } else {

    }
#line 3450
    rss->rss_flags = 15ULL;
#line 3453
    if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 3454
      rss->rss_flags = rss->rss_flags | 48ULL;
    } else {

    }
  } else {
#line 3458
    rss->rss_flags = 0ULL;
  }
#line 3461
  netdev_rss_key_fill((void *)(& rss_key), 40UL);
#line 3462
  rc = be_cmd_rss_config(adapter, (u8 *)(& rss->rsstable), (u32 )rss->rss_flags, 128,
                         (u8 const   *)(& rss_key));
#line 3464
  if (rc != 0) {
#line 3465
    rss->rss_flags = 0ULL;
#line 3466
    return (rc);
  } else {

  }
#line 3469
  memcpy((void *)(& rss->rss_hkey), (void const   *)(& rss_key), 40UL);
#line 3474
  i = 0;
#line 3474
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3474
  goto ldv_58700;
  ldv_58699: 
#line 3475
  be_post_rx_frags(rxo, 208U, 1023U);
#line 3474
  i = i + 1;
#line 3474
  rxo = rxo + 1;
  ldv_58700: ;
#line 3474
  if ((int )adapter->num_rx_qs > i) {
#line 3476
    goto ldv_58699;
  } else {

  }

#line 3477
  return (0);
}
}
#line 3480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_open(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u8 link_status ;
  int status ;
  int i ;

  {
#line 3482
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3482
  adapter = (struct be_adapter *)tmp;
#line 3489
  status = be_rx_qs_create(adapter);
#line 3490
  if (status != 0) {
#line 3491
    goto err;
  } else {

  }
#line 3493
  status = be_irq_register(adapter);
#line 3494
  if (status != 0) {
#line 3495
    goto err;
  } else {

  }
#line 3497
  i = 0;
#line 3497
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 3497
  goto ldv_58714;
  ldv_58713: 
#line 3498
  be_cq_notify(adapter, (int )rxo->cq.id, 1, 0);
#line 3497
  i = i + 1;
#line 3497
  rxo = rxo + 1;
  ldv_58714: ;
#line 3497
  if ((int )adapter->num_rx_qs > i) {
#line 3499
    goto ldv_58713;
  } else {

  }
#line 3500
  i = 0;
#line 3500
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 3500
  goto ldv_58717;
  ldv_58716: 
#line 3501
  be_cq_notify(adapter, (int )txo->cq.id, 1, 0);
#line 3500
  i = i + 1;
#line 3500
  txo = txo + 1;
  ldv_58717: ;
#line 3500
  if ((int )adapter->num_tx_qs > i) {
#line 3502
    goto ldv_58716;
  } else {

  }
#line 3503
  be_async_mcc_enable(adapter);
#line 3505
  i = 0;
#line 3505
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3505
  goto ldv_58720;
  ldv_58719: 
#line 3506
  napi_enable(& eqo->napi);
#line 3507
  be_enable_busy_poll(eqo);
#line 3508
  be_eq_notify(adapter, (int )eqo->q.id, 1, 1, 0, 0U);
#line 3505
  i = i + 1;
#line 3505
  eqo = eqo + 1;
  ldv_58720: ;
#line 3505
  if ((int )adapter->num_evt_qs > i) {
#line 3507
    goto ldv_58719;
  } else {

  }
#line 3510
  adapter->flags = adapter->flags | 64U;
#line 3512
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
#line 3513
  if (status == 0) {
#line 3514
    be_link_status_update(adapter, (int )link_status);
  } else {

  }
#line 3516
  netif_tx_start_all_queues(netdev);
#line 3517
  be_roce_dev_open(adapter);
#line 3520
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3521
    vxlan_get_rx_port(netdev);
  } else {

  }
#line 3524
  return (0);
  err: 
#line 3526
  be_close(adapter->netdev);
#line 3527
  return (-5);
}
}
#line 3530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup_wol(struct be_adapter *adapter , bool enable ) 
{ 
  struct be_dma_mem cmd ;
  int status ;
  u8 mac[6U] ;

  {
#line 3533
  status = 0;
#line 3536
  eth_zero_addr((u8 *)(& mac));
#line 3538
  cmd.size = 604U;
#line 3539
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               208U);
#line 3541
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3542
    return (-12);
  } else {

  }
#line 3544
  if ((int )enable) {
#line 3545
    status = pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 68, 264U);
#line 3548
    if (status != 0) {
#line 3549
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Could not enable Wake-on-lan\n");
#line 3551
      dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3553
      return (status);
    } else {

    }
#line 3555
    status = be_cmd_enable_magic_wol(adapter, (adapter->netdev)->dev_addr, & cmd);
#line 3558
    pci_enable_wake(adapter->pdev, 3, 1);
#line 3559
    pci_enable_wake(adapter->pdev, 4, 1);
  } else {
#line 3561
    status = be_cmd_enable_magic_wol(adapter, (u8 *)(& mac), & cmd);
#line 3562
    pci_enable_wake(adapter->pdev, 3, 0);
#line 3563
    pci_enable_wake(adapter->pdev, 4, 0);
  }
#line 3566
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3567
  return (status);
}
}
#line 3570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_vf_eth_addr_generate(struct be_adapter *adapter , u8 *mac ) 
{ 
  u32 addr ;

  {
#line 3574
  addr = jhash((void const   *)(adapter->netdev)->dev_addr, 6U, 0U);
#line 3576
  *(mac + 5UL) = (unsigned char )addr;
#line 3577
  *(mac + 4UL) = (unsigned char )(addr >> 8);
#line 3578
  *(mac + 3UL) = (unsigned char )(addr >> 16);
#line 3580
  memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr, 3UL);
#line 3581
  return;
}
}
#line 3589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_eth_addr_config(struct be_adapter *adapter ) 
{ 
  u32 vf ;
  int status ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;

  {
#line 3592
  status = 0;
#line 3596
  be_vf_eth_addr_generate(adapter, (u8 *)(& mac));
#line 3598
  vf = 0U;
#line 3598
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3598
  goto ldv_58742;
  ldv_58741: ;
#line 3599
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3600
    status = be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             vf + 1U);
  } else {
#line 3604
    status = be_cmd_set_mac(adapter, (u8 *)(& mac), vf_cfg->if_handle, vf + 1U);
  }
#line 3607
  if (status != 0) {
#line 3608
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Mac address assignment failed for VF %d\n",
            vf);
  } else {
#line 3612
    memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), 6UL);
  }
#line 3614
  mac[5] = (unsigned int )mac[5] + 1U;
#line 3598
  vf = vf + 1U;
#line 3598
  vf_cfg = vf_cfg + 1;
  ldv_58742: ;
#line 3598
  if ((u32 )adapter->num_vfs > vf) {
#line 3600
    goto ldv_58741;
  } else {

  }

#line 3616
  return (status);
}
}
#line 3619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vfs_mac_query(struct be_adapter *adapter ) 
{ 
  int status ;
  int vf ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;

  {
#line 3625
  vf = 0;
#line 3625
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3625
  goto ldv_58752;
  ldv_58751: 
#line 3626
  status = be_cmd_get_active_mac(adapter, (u32 )vf_cfg->pmac_id, (u8 *)(& mac), (u32 )vf_cfg->if_handle,
                                 0, (u32 )(vf + 1));
#line 3629
  if (status != 0) {
#line 3630
    return (status);
  } else {

  }
#line 3631
  memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), 6UL);
#line 3625
  vf = vf + 1;
#line 3625
  vf_cfg = vf_cfg + 1;
  ldv_58752: ;
#line 3625
  if ((int )adapter->num_vfs > vf) {
#line 3627
    goto ldv_58751;
  } else {

  }

#line 3633
  return (0);
}
}
#line 3636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_vf_clear(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u32 vf ;
  int tmp ;

  {
#line 3641
  tmp = pci_vfs_assigned(adapter->pdev);
#line 3641
  if (tmp != 0) {
#line 3642
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VFs are assigned to VMs: not disabling VFs\n");
#line 3644
    goto done;
  } else {

  }
#line 3647
  pci_disable_sriov(adapter->pdev);
#line 3649
  vf = 0U;
#line 3649
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3649
  goto ldv_58761;
  ldv_58760: ;
#line 3650
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3651
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, vf + 1U);
  } else {
#line 3654
    be_cmd_set_mac(adapter, (u8 *)0U, vf_cfg->if_handle, vf + 1U);
  }
#line 3657
  be_cmd_if_destroy(adapter, vf_cfg->if_handle, vf + 1U);
#line 3649
  vf = vf + 1U;
#line 3649
  vf_cfg = vf_cfg + 1;
  ldv_58761: ;
#line 3649
  if ((u32 )adapter->num_vfs > vf) {
#line 3651
    goto ldv_58760;
  } else {

  }

  done: 
#line 3660
  kfree((void const   *)adapter->vf_cfg);
#line 3661
  adapter->num_vfs = 0U;
#line 3662
  adapter->flags = adapter->flags & 4294967291U;
#line 3663
  return;
}
}
#line 3665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_clear_queues(struct be_adapter *adapter ) 
{ 


  {
#line 3667
  be_mcc_queues_destroy(adapter);
#line 3668
  be_rx_cqs_destroy(adapter);
#line 3669
  be_tx_queues_destroy(adapter);
#line 3670
  be_evt_queues_destroy(adapter);
#line 3671
  return;
}
}
#line 3673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_cancel_worker(struct be_adapter *adapter ) 
{ 


  {
#line 3675
  if (((unsigned long )adapter->flags & 8UL) != 0UL) {
#line 3676
    ldv_cancel_delayed_work_sync_15(& adapter->work);
#line 3677
    adapter->flags = adapter->flags & 4294967287U;
  } else {

  }
#line 3679
  return;
}
}
#line 3681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_cancel_err_detection(struct be_adapter *adapter ) 
{ 


  {
#line 3683
  if (((unsigned long )adapter->flags & 2048UL) != 0UL) {
#line 3684
    ldv_cancel_delayed_work_sync_16(& adapter->be_err_detection_work);
#line 3685
    adapter->flags = adapter->flags & 4294965247U;
  } else {

  }
#line 3687
  return;
}
}
#line 3689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_mac_clear(struct be_adapter *adapter ) 
{ 


  {
#line 3691
  if ((unsigned long )adapter->pmac_id != (unsigned long )((u32 *)0U)) {
#line 3692
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id),
                    0U);
#line 3694
    kfree((void const   *)adapter->pmac_id);
#line 3695
    adapter->pmac_id = (u32 *)0U;
  } else {

  }
#line 3697
  return;
}
}
#line 3700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_disable_vxlan_offloads(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;

  {
#line 3702
  netdev = adapter->netdev;
#line 3704
  if (((unsigned long )adapter->flags & 256UL) != 0UL) {
#line 3705
    be_cmd_manage_iface(adapter, (u32 )adapter->if_handle, 1);
  } else {

  }
#line 3708
  if ((unsigned int )adapter->vxlan_port != 0U) {
#line 3709
    be_cmd_set_vxlan_port(adapter, 0);
  } else {

  }
#line 3711
  adapter->flags = adapter->flags & 4294967039U;
#line 3712
  adapter->vxlan_port = 0U;
#line 3714
  netdev->hw_enc_features = 0ULL;
#line 3715
  netdev->hw_features = netdev->hw_features & 0xfffffffffbffffffULL;
#line 3716
  netdev->features = netdev->features & 0xfffffffffbffffffULL;
#line 3717
  return;
}
}
#line 3720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 be_calculate_vf_qs(struct be_adapter *adapter , u16 num_vfs___0 ) 
{ 
  struct be_resources res ;
  u16 num_vf_qs ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3722
  res = adapter->pool_res;
#line 3723
  num_vf_qs = 1U;
#line 3728
  if ((unsigned int )num_vfs___0 != 0U) {
#line 3728
    tmp = be_is_mc(adapter);
#line 3728
    if (tmp) {
#line 3728
      tmp___0 = 0;
    } else {
#line 3728
      tmp___0 = 1;
    }
#line 3728
    if (tmp___0) {
#line 3733
      if ((int )num_vfs___0 < (int )adapter->pool_res.max_vfs + -8) {
#line 3734
        num_vf_qs = (u16 )(((int )res.max_rss_qs + -8) / (int )num_vfs___0);
      } else {
#line 3736
        num_vf_qs = (u16 )((int )res.max_rss_qs / (int )num_vfs___0);
      }
#line 3742
      if ((unsigned int )num_vfs___0 > 14U) {
#line 3743
        num_vf_qs = 1U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 3745
  return (num_vf_qs);
}
}
#line 3748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_clear(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;
  u16 num_vf_qs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3750
  pdev = adapter->pdev;
#line 3753
  be_cancel_worker(adapter);
#line 3755
  if (((unsigned long )adapter->flags & 4UL) != 0UL) {
#line 3756
    be_vf_clear(adapter);
  } else {

  }
#line 3761
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (unsigned int )adapter->virtfn == 0U) {
#line 3761
    tmp___1 = pci_vfs_assigned(pdev);
#line 3761
    if (tmp___1 == 0) {
#line 3763
      tmp = pci_sriov_get_totalvfs(pdev);
#line 3763
      num_vf_qs = be_calculate_vf_qs(adapter, (int )((u16 )tmp));
#line 3765
      tmp___0 = pci_sriov_get_totalvfs(pdev);
#line 3765
      be_cmd_set_sriov_config(adapter, adapter->pool_res, (int )((u16 )tmp___0), (int )num_vf_qs);
    } else {

    }
  } else {

  }
#line 3771
  be_disable_vxlan_offloads(adapter);
#line 3774
  be_mac_clear(adapter);
#line 3776
  be_cmd_if_destroy(adapter, adapter->if_handle, 0U);
#line 3778
  be_clear_queues(adapter);
#line 3780
  be_msix_disable(adapter);
#line 3781
  adapter->flags = adapter->flags & 4294966783U;
#line 3782
  return (0);
}
}
#line 3785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_if_create(struct be_adapter *adapter , u32 *if_handle , u32 cap_flags ,
                        u32 vf ) 
{ 
  u32 en_flags ;
  int tmp ;

  {
#line 3790
  en_flags = 16783412U;
#line 3794
  en_flags = en_flags & cap_flags;
#line 3796
  tmp = be_cmd_if_create(adapter, cap_flags, en_flags, if_handle, vf);
#line 3796
  return (tmp);
}
}
#line 3799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vfs_if_create(struct be_adapter *adapter ) 
{ 
  struct be_resources res ;
  struct be_vf_cfg *vf_cfg ;
  u32 cap_flags ;
  u32 vf ;
  int status ;

  {
#line 3801
  res.max_vfs = 0U;
#line 3801
  res.max_mcast_mac = (unsigned short)0;
#line 3801
  res.max_tx_qs = (unsigned short)0;
#line 3801
  res.max_rss_qs = (unsigned short)0;
#line 3801
  res.max_rx_qs = (unsigned short)0;
#line 3801
  res.max_cq_count = (unsigned short)0;
#line 3801
  res.max_uc_mac = (unsigned short)0;
#line 3801
  res.max_vlans = (unsigned short)0;
#line 3801
  res.max_iface_count = (unsigned short)0;
#line 3801
  res.max_mcc_count = (unsigned short)0;
#line 3801
  res.max_evt_qs = (unsigned short)0;
#line 3801
  res.if_cap_flags = 0U;
#line 3801
  res.vf_if_cap_flags = 0U;
#line 3807
  cap_flags = 6192U;
#line 3810
  vf = 0U;
#line 3810
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3810
  goto ldv_58806;
  ldv_58805: ;
#line 3811
  if ((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) {
#line 3812
    status = be_cmd_get_profile_config(adapter, & res, 0, (int )((unsigned int )((u8 )vf) + 1U));
#line 3815
    if (status == 0) {
#line 3816
      cap_flags = res.if_cap_flags;
#line 3820
      cap_flags = cap_flags & 4294967167U;
    } else {

    }
  } else {

  }
#line 3824
  status = be_if_create(adapter, (u32 *)(& vf_cfg->if_handle), cap_flags, vf + 1U);
#line 3826
  if (status != 0) {
#line 3827
    return (status);
  } else {

  }
#line 3810
  vf = vf + 1U;
#line 3810
  vf_cfg = vf_cfg + 1;
  ldv_58806: ;
#line 3810
  if ((u32 )adapter->num_vfs > vf) {
#line 3812
    goto ldv_58805;
  } else {

  }

#line 3830
  return (0);
}
}
#line 3833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_setup_init(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  int vf ;
  void *tmp ;

  {
#line 3838
  tmp = kcalloc((size_t )adapter->num_vfs, 36UL, 208U);
#line 3838
  adapter->vf_cfg = (struct be_vf_cfg *)tmp;
#line 3840
  if ((unsigned long )adapter->vf_cfg == (unsigned long )((struct be_vf_cfg *)0)) {
#line 3841
    return (-12);
  } else {

  }
#line 3843
  vf = 0;
#line 3843
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3843
  goto ldv_58814;
  ldv_58813: 
#line 3844
  vf_cfg->if_handle = -1;
#line 3845
  vf_cfg->pmac_id = -1;
#line 3843
  vf = vf + 1;
#line 3843
  vf_cfg = vf_cfg + 1;
  ldv_58814: ;
#line 3843
  if ((int )adapter->num_vfs > vf) {
#line 3845
    goto ldv_58813;
  } else {

  }

#line 3847
  return (0);
}
}
#line 3850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  int old_vfs ;
  int vf ;
  bool spoofchk ;

  {
#line 3852
  dev = & (adapter->pdev)->dev;
#line 3857
  old_vfs = pci_num_vf(adapter->pdev);
#line 3859
  status = be_vf_setup_init(adapter);
#line 3860
  if (status != 0) {
#line 3861
    goto err;
  } else {

  }
#line 3863
  if (old_vfs != 0) {
#line 3864
    vf = 0;
#line 3864
    vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3864
    goto ldv_58827;
    ldv_58826: 
#line 3865
    status = be_cmd_get_if_id(adapter, vf_cfg, vf);
#line 3866
    if (status != 0) {
#line 3867
      goto err;
    } else {

    }
#line 3864
    vf = vf + 1;
#line 3864
    vf_cfg = vf_cfg + 1;
    ldv_58827: ;
#line 3864
    if ((int )adapter->num_vfs > vf) {
#line 3866
      goto ldv_58826;
    } else {

    }
#line 3870
    status = be_vfs_mac_query(adapter);
#line 3871
    if (status != 0) {
#line 3872
      goto err;
    } else {

    }
  } else {
#line 3874
    status = be_vfs_if_create(adapter);
#line 3875
    if (status != 0) {
#line 3876
      goto err;
    } else {

    }
#line 3878
    status = be_vf_eth_addr_config(adapter);
#line 3879
    if (status != 0) {
#line 3880
      goto err;
    } else {

    }
  }
#line 3883
  vf = 0;
#line 3883
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3883
  goto ldv_58830;
  ldv_58829: 
#line 3885
  status = be_cmd_get_fn_privileges(adapter, & vf_cfg->privileges, (u32 )(vf + 1));
#line 3887
  if (status == 0 && (vf_cfg->privileges & 64U) == 0U) {
#line 3888
    status = be_cmd_set_fn_privileges(adapter, vf_cfg->privileges | 64U, (u32 )(vf + 1));
#line 3892
    if (status == 0) {
#line 3893
      vf_cfg->privileges = vf_cfg->privileges | 64U;
#line 3894
      _dev_info((struct device  const  *)dev, "VF%d has FILTMGMT privilege\n", vf);
    } else {

    }
  } else {

  }
#line 3900
  if (old_vfs == 0) {
#line 3901
    be_cmd_config_qos(adapter, 0U, 0, (int )((unsigned int )((u8 )vf) + 1U));
  } else {

  }
#line 3903
  status = be_cmd_get_hsw_config(adapter, (u16 *)0U, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                 (u8 *)0U, & spoofchk);
#line 3906
  if (status == 0) {
#line 3907
    vf_cfg->spoofchk = spoofchk;
  } else {

  }
#line 3909
  if (old_vfs == 0) {
#line 3910
    be_cmd_enable_vf(adapter, (int )((unsigned int )((u8 )vf) + 1U));
#line 3911
    be_cmd_set_logical_link_config(adapter, 0, (int )((unsigned int )((u8 )vf) + 1U));
  } else {

  }
#line 3883
  vf = vf + 1;
#line 3883
  vf_cfg = vf_cfg + 1;
  ldv_58830: ;
#line 3883
  if ((int )adapter->num_vfs > vf) {
#line 3885
    goto ldv_58829;
  } else {

  }

#line 3917
  if (old_vfs == 0) {
#line 3918
    status = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
#line 3919
    if (status != 0) {
#line 3920
      dev_err((struct device  const  *)dev, "SRIOV enable failed\n");
#line 3921
      adapter->num_vfs = 0U;
#line 3922
      goto err;
    } else {

    }
  } else {

  }
#line 3926
  adapter->flags = adapter->flags | 4U;
#line 3927
  return (0);
  err: 
#line 3929
  dev_err((struct device  const  *)dev, "VF setup failed\n");
#line 3930
  be_vf_clear(adapter);
#line 3931
  return (status);
}
}
#line 3936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u8 be_convert_mc_type(u32 function_mode ) 
{ 


  {
#line 3938
  if ((function_mode & 131072U) != 0U && (function_mode & 1024U) != 0U) {
#line 3939
    return (4U);
  } else
#line 3940
  if ((function_mode & 1024U) != 0U) {
#line 3941
    return (3U);
  } else
#line 3942
  if ((function_mode & 131072U) != 0U) {
#line 3943
    return (7U);
  } else
#line 3944
  if ((function_mode & 16777216U) != 0U) {
#line 3945
    return (2U);
  } else {
#line 3947
    return (1U);
  }
}
}
#line 3951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void BEx_get_resources(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  bool use_sriov ;
  bool tmp ;
  struct be_resources super_nic_res ;
  bool tmp___0 ;

  {
#line 3954
  use_sriov = (unsigned int )adapter->num_vfs != 0U;
#line 3956
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3957
    res->max_uc_mac = 30U;
  } else {
#line 3959
    res->max_uc_mac = 2U;
  }
#line 3961
  adapter->mc_type = be_convert_mc_type(adapter->function_mode);
#line 3963
  tmp = be_is_mc(adapter);
#line 3963
  if ((int )tmp) {
#line 3967
    if ((adapter->function_mode & 1024U) != 0U) {
#line 3968
      res->max_vlans = 8U;
    } else {
#line 3973
      res->max_vlans = 15U;
    }
  } else {
#line 3975
    res->max_vlans = 64U;
  }
#line 3978
  res->max_mcast_mac = 64U;
#line 3984
  if (((((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) || (int )use_sriov) || adapter->port_num > 1U) || (unsigned int )adapter->virtfn != 0U) {
#line 3988
    res->max_tx_qs = 1U;
  } else {
#line 3984
    tmp___0 = be_is_mc(adapter);
#line 3984
    if ((int )tmp___0 && (adapter->function_caps & 2U) == 0U) {
#line 3988
      res->max_tx_qs = 1U;
    } else
#line 3989
    if ((adapter->function_caps & 64U) != 0U) {
#line 3990
      super_nic_res.max_vfs = 0U;
#line 3990
      super_nic_res.max_mcast_mac = (unsigned short)0;
#line 3990
      super_nic_res.max_tx_qs = (unsigned short)0;
#line 3990
      super_nic_res.max_rss_qs = (unsigned short)0;
#line 3990
      super_nic_res.max_rx_qs = (unsigned short)0;
#line 3990
      super_nic_res.max_cq_count = (unsigned short)0;
#line 3990
      super_nic_res.max_uc_mac = (unsigned short)0;
#line 3990
      super_nic_res.max_vlans = (unsigned short)0;
#line 3990
      super_nic_res.max_iface_count = (unsigned short)0;
#line 3990
      super_nic_res.max_mcc_count = (unsigned short)0;
#line 3990
      super_nic_res.max_evt_qs = (unsigned short)0;
#line 3990
      super_nic_res.if_cap_flags = 0U;
#line 3990
      super_nic_res.vf_if_cap_flags = 0U;
#line 3995
      be_cmd_get_profile_config(adapter, & super_nic_res, 0, 0);
#line 3998
      res->max_tx_qs = (int )super_nic_res.max_tx_qs != 0 ? (u16 )((int )super_nic_res.max_tx_qs) : 16U;
    } else {
#line 4000
      res->max_tx_qs = 16U;
    }
  }
#line 4003
  if (((adapter->function_caps & 2U) != 0U && ! use_sriov) && (unsigned int )adapter->virtfn == 0U) {
#line 4005
    res->max_rss_qs = (int )adapter->be3_native ? 16U : 4U;
  } else {

  }
#line 4007
  res->max_rx_qs = (unsigned int )res->max_rss_qs + 1U;
#line 4009
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4010
    res->max_evt_qs = (unsigned int )adapter->pool_res.max_vfs != 0U ? 8U : 16U;
  } else {
#line 4013
    res->max_evt_qs = 1U;
  }
#line 4015
  res->if_cap_flags = 16784316U;
#line 4016
  res->if_cap_flags = res->if_cap_flags & 4278190079U;
#line 4017
  if ((adapter->function_caps & 2U) == 0U) {
#line 4018
    res->if_cap_flags = res->if_cap_flags & 4294967291U;
  } else {

  }
#line 4019
  return;
}
}
#line 4021 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_setup_init(struct be_adapter *adapter ) 
{ 


  {
#line 4023
  adapter->vlan_prio_bmap = 255U;
#line 4024
  adapter->phy.link_speed = -1;
#line 4025
  adapter->if_handle = -1;
#line 4026
  adapter->be3_native = 0;
#line 4027
  adapter->if_flags = 0U;
#line 4028
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4029
    adapter->cmd_privileges = 1792U;
  } else {
#line 4031
    adapter->cmd_privileges = 1U;
  }
#line 4032
  return;
}
}
#line 4034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_sriov_config(struct be_adapter *adapter ) 
{ 
  struct be_resources res ;
  int max_vfs ;
  int old_vfs ;
  int _min1 ;
  int _min2 ;
  int tmp ;

  {
#line 4036
  res.max_vfs = 0U;
#line 4036
  res.max_mcast_mac = (unsigned short)0;
#line 4036
  res.max_tx_qs = (unsigned short)0;
#line 4036
  res.max_rss_qs = (unsigned short)0;
#line 4036
  res.max_rx_qs = (unsigned short)0;
#line 4036
  res.max_cq_count = (unsigned short)0;
#line 4036
  res.max_uc_mac = (unsigned short)0;
#line 4036
  res.max_vlans = (unsigned short)0;
#line 4036
  res.max_iface_count = (unsigned short)0;
#line 4036
  res.max_mcc_count = (unsigned short)0;
#line 4036
  res.max_evt_qs = (unsigned short)0;
#line 4036
  res.if_cap_flags = 0U;
#line 4036
  res.vf_if_cap_flags = 0U;
#line 4039
  be_cmd_get_profile_config(adapter, & res, 0, 0);
#line 4042
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )res.max_vfs == 0U) {
#line 4043
    max_vfs = pci_sriov_get_totalvfs(adapter->pdev);
#line 4044
    if (max_vfs > 0) {
#line 4044
      _min1 = 30;
#line 4044
      _min2 = max_vfs;
#line 4044
      res.max_vfs = (u16 )(_min1 < _min2 ? _min1 : _min2);
    } else {
#line 4044
      res.max_vfs = 0U;
    }
  } else {

  }
#line 4047
  adapter->pool_res = res;
#line 4053
  old_vfs = pci_num_vf(adapter->pdev);
#line 4054
  if (old_vfs != 0) {
#line 4055
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%d VFs are already enabled\n",
              old_vfs);
#line 4058
    tmp = pci_sriov_get_totalvfs(adapter->pdev);
#line 4058
    adapter->pool_res.max_vfs = (u16 )tmp;
#line 4060
    adapter->num_vfs = (u16 )old_vfs;
  } else {

  }
#line 4063
  return (0);
}
}
#line 4066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_alloc_sriov_res(struct be_adapter *adapter ) 
{ 
  int old_vfs ;
  int tmp ;
  u16 num_vf_qs ;
  int status ;

  {
#line 4068
  tmp = pci_num_vf(adapter->pdev);
#line 4068
  old_vfs = tmp;
#line 4072
  be_get_sriov_config(adapter);
#line 4074
  if (old_vfs == 0) {
#line 4075
    pci_sriov_set_totalvfs(adapter->pdev, (int )adapter->pool_res.max_vfs);
  } else {

  }
#line 4082
  if ((((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (unsigned int )adapter->pool_res.max_vfs != 0U) && old_vfs == 0) {
#line 4083
    num_vf_qs = be_calculate_vf_qs(adapter, 0);
#line 4084
    status = be_cmd_set_sriov_config(adapter, adapter->pool_res, 0, (int )num_vf_qs);
#line 4086
    if (status != 0) {
#line 4087
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to optimize SRIOV resources\n");
    } else {

    }
  } else {

  }
#line 4090
  return;
}
}
#line 4092 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_resources(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_resources res ;
  int status ;
  u16 __min1 ;
  int tmp ;
  u16 __min2 ;
  u16 tmp___0 ;

  {
#line 4094
  dev = & (adapter->pdev)->dev;
#line 4095
  res.max_vfs = 0U;
#line 4095
  res.max_mcast_mac = (unsigned short)0;
#line 4095
  res.max_tx_qs = (unsigned short)0;
#line 4095
  res.max_rss_qs = (unsigned short)0;
#line 4095
  res.max_rx_qs = (unsigned short)0;
#line 4095
  res.max_cq_count = (unsigned short)0;
#line 4095
  res.max_uc_mac = (unsigned short)0;
#line 4095
  res.max_vlans = (unsigned short)0;
#line 4095
  res.max_iface_count = (unsigned short)0;
#line 4095
  res.max_mcc_count = (unsigned short)0;
#line 4095
  res.max_evt_qs = (unsigned short)0;
#line 4095
  res.if_cap_flags = 0U;
#line 4095
  res.vf_if_cap_flags = 0U;
#line 4098
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 4099
    BEx_get_resources(adapter, & res);
#line 4100
    adapter->res = res;
  } else {

  }
#line 4107
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 4108
    status = be_cmd_get_func_config(adapter, & res);
#line 4109
    if (status != 0) {
#line 4110
      return (status);
    } else {

    }
#line 4113
    if (((unsigned int )res.max_rss_qs != 0U && (int )res.max_rss_qs == (int )res.max_rx_qs) && (res.if_cap_flags & 16777216U) == 0U) {
#line 4115
      res.max_rss_qs = (unsigned int )res.max_rss_qs + 65535U;
    } else {

    }
#line 4118
    if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 4119
      res.max_evt_qs = (u16 )((unsigned int )res.max_evt_qs / 2U);
    } else {

    }
#line 4120
    adapter->res = res;
  } else {

  }
#line 4126
  adapter->need_def_rxq = (adapter->res.if_cap_flags & 16777216U) == 0U;
#line 4129
  _dev_info((struct device  const  *)dev, "Max: txqs %d, rxqs %d, rss %d, eqs %d, vfs %d\n",
            (int )adapter->res.max_tx_qs, (int )adapter->res.max_rx_qs, (int )adapter->res.max_rss_qs,
            (int )adapter->res.max_evt_qs, (int )adapter->pool_res.max_vfs);
#line 4133
  _dev_info((struct device  const  *)dev, "Max: uc-macs %d, mc-macs %d, vlans %d\n",
            (int )adapter->res.max_uc_mac, (int )adapter->res.max_mcast_mac, (int )adapter->res.max_vlans);
#line 4138
  tmp = netif_get_num_default_rss_queues();
#line 4138
  __min1 = (u16 )tmp;
#line 4138
  tmp___0 = be_max_qs(adapter);
#line 4138
  __min2 = tmp___0;
#line 4138
  adapter->cfg_num_qs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 4140
  return (0);
}
}
#line 4143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_config(struct be_adapter *adapter ) 
{ 
  int status ;
  int level ;
  u16 profile_id ;
  void *tmp ;

  {
#line 4148
  status = be_cmd_get_cntl_attributes(adapter);
#line 4149
  if (status != 0) {
#line 4150
    return (status);
  } else {

  }
#line 4152
  status = be_cmd_query_fw_cfg(adapter);
#line 4153
  if (status != 0) {
#line 4154
    return (status);
  } else {

  }
#line 4156
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 4157
    level = be_cmd_get_fw_log_level(adapter);
#line 4158
    adapter->msg_enable = level <= 48 ? 8192U : 0U;
  } else {

  }
#line 4162
  be_cmd_get_acpi_wol_cap(adapter);
#line 4164
  be_cmd_query_port_name(adapter);
#line 4166
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4167
    status = be_cmd_get_active_profile(adapter, & profile_id);
#line 4168
    if (status == 0) {
#line 4169
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Using profile 0x%x\n",
                (int )profile_id);
    } else {

    }
  } else {

  }
#line 4173
  status = be_get_resources(adapter);
#line 4174
  if (status != 0) {
#line 4175
    return (status);
  } else {

  }
#line 4177
  tmp = kcalloc((size_t )adapter->res.max_uc_mac, 4UL, 208U);
#line 4177
  adapter->pmac_id = (u32 *)tmp;
#line 4179
  if ((unsigned long )adapter->pmac_id == (unsigned long )((u32 *)0U)) {
#line 4180
    return (-12);
  } else {

  }
#line 4182
  return (0);
}
}
#line 4185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mac_setup(struct be_adapter *adapter ) 
{ 
  u8 mac[6U] ;
  int status ;
  bool tmp ;

  {
#line 4190
  tmp = is_zero_ether_addr((u8 const   *)(adapter->netdev)->dev_addr);
#line 4190
  if ((int )tmp) {
#line 4191
    status = be_cmd_get_perm_mac(adapter, (u8 *)(& mac));
#line 4192
    if (status != 0) {
#line 4193
      return (status);
    } else {

    }
#line 4195
    memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac), 6UL);
#line 4196
    memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac), 6UL);
  } else {
#line 4199
    memcpy((void *)(& mac), (void const   *)(adapter->netdev)->dev_addr, 6UL);
  }
#line 4203
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) || (unsigned int )adapter->virtfn == 0U) {
#line 4204
    be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )adapter->if_handle, adapter->pmac_id,
                    0U);
  } else {

  }
#line 4206
  return (0);
}
}
#line 4209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_schedule_worker(struct be_adapter *adapter ) 
{ 
  unsigned long tmp ;

  {
#line 4211
  tmp = msecs_to_jiffies(1000U);
#line 4211
  schedule_delayed_work(& adapter->work, tmp);
#line 4212
  adapter->flags = adapter->flags | 8U;
#line 4213
  return;
}
}
#line 4215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_schedule_err_detection(struct be_adapter *adapter ) 
{ 
  unsigned long tmp ;

  {
#line 4217
  tmp = msecs_to_jiffies(1000U);
#line 4217
  schedule_delayed_work(& adapter->be_err_detection_work, tmp);
#line 4219
  adapter->flags = adapter->flags | 2048U;
#line 4220
  return;
}
}
#line 4222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 4224
  netdev = adapter->netdev;
#line 4227
  status = be_evt_queues_create(adapter);
#line 4228
  if (status != 0) {
#line 4229
    goto err;
  } else {

  }
#line 4231
  status = be_tx_qs_create(adapter);
#line 4232
  if (status != 0) {
#line 4233
    goto err;
  } else {

  }
#line 4235
  status = be_rx_cqs_create(adapter);
#line 4236
  if (status != 0) {
#line 4237
    goto err;
  } else {

  }
#line 4239
  status = be_mcc_queues_create(adapter);
#line 4240
  if (status != 0) {
#line 4241
    goto err;
  } else {

  }
#line 4243
  status = netif_set_real_num_rx_queues(netdev, (unsigned int )adapter->num_rx_qs);
#line 4244
  if (status != 0) {
#line 4245
    goto err;
  } else {

  }
#line 4247
  status = netif_set_real_num_tx_queues(netdev, (unsigned int )adapter->num_tx_qs);
#line 4248
  if (status != 0) {
#line 4249
    goto err;
  } else {

  }
#line 4251
  return (0);
  err: 
#line 4253
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "queue_setup failed\n");
#line 4254
  return (status);
}
}
#line 4257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
int be_update_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 4259
  netdev = adapter->netdev;
#line 4262
  tmp = netif_running((struct net_device  const  *)netdev);
#line 4262
  if ((int )tmp) {
#line 4263
    be_close(netdev);
  } else {

  }
#line 4265
  be_cancel_worker(adapter);
#line 4270
  if (adapter->num_msix_roce_vec == 0U) {
#line 4271
    be_msix_disable(adapter);
  } else {

  }
#line 4273
  be_clear_queues(adapter);
#line 4275
  if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 4276
    status = be_msix_enable(adapter);
#line 4277
    if (status != 0) {
#line 4278
      return (status);
    } else {

    }
  } else {

  }
#line 4281
  status = be_setup_queues(adapter);
#line 4282
  if (status != 0) {
#line 4283
    return (status);
  } else {

  }
#line 4285
  be_schedule_worker(adapter);
#line 4287
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4287
  if ((int )tmp___0) {
#line 4288
    status = be_open(netdev);
  } else {

  }
#line 4290
  return (status);
}
}
#line 4293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int fw_major_num(char const   *fw_ver ) 
{ 
  int fw_major ;
  int i ;

  {
#line 4295
  fw_major = 0;
#line 4297
  i = sscanf(fw_ver, "%d.", & fw_major);
#line 4298
  if (i != 1) {
#line 4299
    return (0);
  } else {

  }
#line 4301
  return (fw_major);
}
}
#line 4305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_reset_required(struct be_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 4307
  tmp = pci_num_vf(adapter->pdev);
#line 4307
  return (tmp == 0);
}
}
#line 4311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_func_init(struct be_adapter *adapter ) 
{ 
  int status ;
  bool tmp ;

  {
#line 4315
  status = be_fw_wait_ready(adapter);
#line 4316
  if (status != 0) {
#line 4317
    return (status);
  } else {

  }
#line 4319
  tmp = be_reset_required(adapter);
#line 4319
  if ((int )tmp) {
#line 4320
    status = be_cmd_reset_function(adapter);
#line 4321
    if (status != 0) {
#line 4322
      return (status);
    } else {

    }
#line 4325
    msleep(100U);
#line 4328
    be_clear_error(adapter, 255);
  } else {

  }
#line 4332
  status = be_cmd_fw_init(adapter);
#line 4333
  if (status != 0) {
#line 4334
    return (status);
  } else {

  }
#line 4337
  be_intr_set(adapter, 1);
#line 4339
  return (0);
}
}
#line 4342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;
  int tmp ;
  bool tmp___0 ;

  {
#line 4344
  dev = & (adapter->pdev)->dev;
#line 4347
  status = be_func_init(adapter);
#line 4348
  if (status != 0) {
#line 4349
    return (status);
  } else {

  }
#line 4351
  be_setup_init(adapter);
#line 4353
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 4354
    be_cmd_req_native_mode(adapter);
  } else {

  }
#line 4356
  if (((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) && (unsigned int )adapter->virtfn == 0U) {
#line 4357
    be_alloc_sriov_res(adapter);
  } else {

  }
#line 4359
  status = be_get_config(adapter);
#line 4360
  if (status != 0) {
#line 4361
    goto err;
  } else {

  }
#line 4363
  status = be_msix_enable(adapter);
#line 4364
  if (status != 0) {
#line 4365
    goto err;
  } else {

  }
#line 4367
  status = be_if_create(adapter, (u32 *)(& adapter->if_handle), adapter->res.if_cap_flags,
                        0U);
#line 4369
  if (status != 0) {
#line 4370
    goto err;
  } else {

  }
#line 4373
  rtnl_lock();
#line 4374
  status = be_setup_queues(adapter);
#line 4375
  rtnl_unlock();
#line 4376
  if (status != 0) {
#line 4377
    goto err;
  } else {

  }
#line 4379
  be_cmd_get_fn_privileges(adapter, & adapter->cmd_privileges, 0U);
#line 4381
  status = be_mac_setup(adapter);
#line 4382
  if (status != 0) {
#line 4383
    goto err;
  } else {

  }
#line 4385
  be_cmd_get_fw_ver(adapter);
#line 4386
  _dev_info((struct device  const  *)dev, "FW version is %s\n", (char *)(& adapter->fw_ver));
#line 4388
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 4388
    tmp = fw_major_num((char const   *)(& adapter->fw_ver));
#line 4388
    if (tmp <= 3) {
#line 4389
      dev_err((struct device  const  *)dev, "Firmware on card is old(%s), IRQs may not work",
              (char *)(& adapter->fw_ver));
#line 4391
      dev_err((struct device  const  *)dev, "Please upgrade firmware to version >= 4.0\n");
    } else {

    }
  } else {

  }
#line 4394
  if ((unsigned int )adapter->vlans_added != 0U) {
#line 4395
    be_vid_config(adapter);
  } else {

  }
#line 4397
  be_set_rx_mode(adapter->netdev);
#line 4399
  status = be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
#line 4401
  if (status != 0) {
#line 4402
    be_cmd_get_flow_control(adapter, & adapter->tx_fc, & adapter->rx_fc);
  } else {

  }
#line 4405
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "HW Flow control - TX:%d RX:%d\n",
            adapter->tx_fc, adapter->rx_fc);
#line 4408
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4409
    be_cmd_set_logical_link_config(adapter, 0, 0);
  } else {

  }
#line 4412
  if ((unsigned int )adapter->num_vfs != 0U) {
#line 4413
    be_vf_setup(adapter);
  } else {

  }
#line 4415
  status = be_cmd_get_phy_info(adapter);
#line 4416
  if (status == 0) {
#line 4416
    tmp___0 = be_pause_supported(adapter);
#line 4416
    if ((int )tmp___0) {
#line 4417
      adapter->phy.fc_autoneg = 1U;
    } else {

    }
  } else {

  }
#line 4419
  be_schedule_worker(adapter);
#line 4420
  adapter->flags = adapter->flags | 512U;
#line 4421
  return (0);
  err: 
#line 4423
  be_clear(adapter);
#line 4424
  return (status);
}
}
#line 4428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_netpoll(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 4430
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4430
  adapter = (struct be_adapter *)tmp;
#line 4434
  i = 0;
#line 4434
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 4434
  goto ldv_58921;
  ldv_58920: 
#line 4435
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0, 0U);
#line 4436
  napi_schedule(& eqo->napi);
#line 4434
  i = i + 1;
#line 4434
  eqo = eqo + 1;
  ldv_58921: ;
#line 4434
  if ((int )adapter->num_evt_qs > i) {
#line 4436
    goto ldv_58920;
  } else {

  }

#line 4441
  return;
}
}
#line 4441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static char flash_cookie[2U][16U]  = { {        '*',        '*',        '*',        ' ', 
            'S',        'E',        ' ',        'F', 
            'L',        'A',        'S',        '\000'}, 
   {        'H',        ' ',        'D',        'I', 
            'R',        'E',        'C',        'T', 
            'O',        'R',        'Y',        ' ', 
            '*',        '*',        '*',        ' '}};
#line 4443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool phy_flashing_required(struct be_adapter *adapter ) 
{ 


  {
#line 4445
  return ((bool )((unsigned int )adapter->phy.phy_type == 13U && (unsigned int )adapter->phy.interface_type == 6U));
}
}
#line 4449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool is_comp_in_ufi(struct be_adapter *adapter , struct flash_section_info *fsec ,
                           int type ) 
{ 
  int i ;
  int img_type ;
  struct flash_section_info_g2 *fsec_g2 ;

  {
#line 4452
  i = 0;
#line 4452
  img_type = 0;
#line 4453
  fsec_g2 = (struct flash_section_info_g2 *)0;
#line 4455
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 4456
    fsec_g2 = (struct flash_section_info_g2 *)fsec;
  } else {

  }
#line 4458
  i = 0;
#line 4458
  goto ldv_58936;
  ldv_58935: ;
#line 4459
  if ((unsigned long )fsec_g2 != (unsigned long )((struct flash_section_info_g2 *)0)) {
#line 4460
    img_type = (int )fsec_g2->fsec_entry[i].type;
  } else {
#line 4462
    img_type = (int )fsec->fsec_entry[i].type;
  }
#line 4464
  if (img_type == type) {
#line 4465
    return (1);
  } else {

  }
#line 4458
  i = i + 1;
  ldv_58936: ;
#line 4458
  if (i <= 31) {
#line 4460
    goto ldv_58935;
  } else {

  }

#line 4467
  return (0);
}
}
#line 4471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct flash_section_info *get_fsec_info(struct be_adapter *adapter , int header_size ,
                                                struct firmware  const  *fw ) 
{ 
  struct flash_section_info *fsec ;
  u8 const   *p ;
  int tmp ;

  {
#line 4475
  fsec = (struct flash_section_info *)0;
#line 4476
  p = fw->data;
#line 4478
  p = p + (unsigned long )header_size;
#line 4479
  goto ldv_58946;
  ldv_58945: 
#line 4480
  fsec = (struct flash_section_info *)p;
#line 4481
  tmp = memcmp((void const   *)(& flash_cookie), (void const   *)(& fsec->cookie),
               32UL);
#line 4481
  if (tmp == 0) {
#line 4482
    return (fsec);
  } else {

  }
#line 4483
  p = p + 32UL;
  ldv_58946: ;
#line 4479
  if ((unsigned long )((unsigned char const   *)(fw->data + fw->size)) > (unsigned long )p) {
#line 4481
    goto ldv_58945;
  } else {

  }

#line 4485
  return ((struct flash_section_info *)0);
}
}
#line 4488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_check_flash_crc(struct be_adapter *adapter , u8 const   *p , u32 img_offset ,
                              u32 img_size , int hdr_size , u16 img_optype , bool *crc_match ) 
{ 
  u32 crc_offset ;
  int status ;
  u8 crc[4U] ;
  int tmp ;

  {
#line 4496
  status = be_cmd_get_flash_crc(adapter, (u8 *)(& crc), (int )img_optype, img_offset,
                                img_size - 4U);
#line 4498
  if (status != 0) {
#line 4499
    return (status);
  } else {

  }
#line 4501
  crc_offset = (((u32 )hdr_size + img_offset) + img_size) - 4U;
#line 4504
  tmp = memcmp((void const   *)(& crc), (void const   *)p + (unsigned long )crc_offset,
               4UL);
#line 4504
  if (tmp == 0) {
#line 4505
    *crc_match = 1;
  } else {
#line 4507
    *crc_match = 0;
  }
#line 4509
  return (status);
}
}
#line 4512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash(struct be_adapter *adapter , u8 const   *img , struct be_dma_mem *flash_cmd ,
                    int optype , int img_size , u32 img_offset ) 
{ 
  u32 flash_op ;
  u32 num_bytes ;
  u32 total_bytes ;
  u32 bytes_sent ;
  struct be_cmd_write_flashrom *req ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;

  {
#line 4516
  total_bytes = (u32 )img_size;
#line 4516
  bytes_sent = 0U;
#line 4517
  req = (struct be_cmd_write_flashrom *)flash_cmd->va;
#line 4520
  goto ldv_58979;
  ldv_58978: 
#line 4521
  __min1 = 32768U;
#line 4521
  __min2 = total_bytes;
#line 4521
  num_bytes = __min1 < __min2 ? __min1 : __min2;
#line 4523
  total_bytes = total_bytes - num_bytes;
#line 4525
  if (total_bytes == 0U) {
#line 4526
    if (optype == 99) {
#line 4527
      flash_op = 9U;
    } else {
#line 4529
      flash_op = 1U;
    }
  } else
#line 4531
  if (optype == 99) {
#line 4532
    flash_op = 10U;
  } else {
#line 4534
    flash_op = 2U;
  }
#line 4537
  memcpy((void *)(& req->data_buf), (void const   *)img, (size_t )num_bytes);
#line 4538
  img = img + (unsigned long )num_bytes;
#line 4539
  status = be_cmd_write_flashrom(adapter, flash_cmd, (u32 )optype, flash_op, img_offset + bytes_sent,
                                 num_bytes);
#line 4542
  if ((status > 0 && ((unsigned int )status & 65535U) == 2U) && optype == 99) {
#line 4544
    goto ldv_58977;
  } else
#line 4545
  if (status != 0) {
#line 4546
    return (status);
  } else {

  }
#line 4548
  bytes_sent = bytes_sent + num_bytes;
  ldv_58979: ;
#line 4520
  if (total_bytes != 0U) {
#line 4522
    goto ldv_58978;
  } else {

  }
  ldv_58977: ;
#line 4550
  return (0);
}
}
#line 4554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash_BEx(struct be_adapter *adapter , struct firmware  const  *fw ,
                        struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int img_hdrs_size ;
  struct device *dev ;
  struct flash_section_info *fsec ;
  int status ;
  int i ;
  int filehdr_size ;
  int num_comp ;
  struct flash_comp  const  *pflashcomp ;
  bool crc_match ;
  u8 const   *p ;
  struct flash_comp gen3_flash_types[10U] ;
  struct flash_comp gen2_flash_types[8U] ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 4558
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 4559
  dev = & (adapter->pdev)->dev;
#line 4560
  fsec = (struct flash_section_info *)0;
#line 4566
  gen3_flash_types[0].offset = 2097152UL;
#line 4566
  gen3_flash_types[0].optype = 0;
#line 4566
  gen3_flash_types[0].size = 2097152;
#line 4566
  gen3_flash_types[0].img_type = 160;
#line 4566
  gen3_flash_types[1].offset = 262144UL;
#line 4566
  gen3_flash_types[1].optype = 1;
#line 4566
  gen3_flash_types[1].size = 1048576;
#line 4566
  gen3_flash_types[1].img_type = 224;
#line 4566
  gen3_flash_types[2].offset = 12582912UL;
#line 4566
  gen3_flash_types[2].optype = 2;
#line 4566
  gen3_flash_types[2].size = 524288;
#line 4566
  gen3_flash_types[2].img_type = 34;
#line 4566
  gen3_flash_types[3].offset = 13107200UL;
#line 4566
  gen3_flash_types[3].optype = 3;
#line 4566
  gen3_flash_types[3].size = 524288;
#line 4566
  gen3_flash_types[3].img_type = 32;
#line 4566
  gen3_flash_types[4].offset = 13631488UL;
#line 4566
  gen3_flash_types[4].optype = 8;
#line 4566
  gen3_flash_types[4].size = 524288;
#line 4566
  gen3_flash_types[4].img_type = 33;
#line 4566
  gen3_flash_types[5].offset = 4194304UL;
#line 4566
  gen3_flash_types[5].optype = 9;
#line 4566
  gen3_flash_types[5].size = 2097152;
#line 4566
  gen3_flash_types[5].img_type = 176;
#line 4566
  gen3_flash_types[6].offset = 6291456UL;
#line 4566
  gen3_flash_types[6].optype = 10;
#line 4566
  gen3_flash_types[6].size = 2097152;
#line 4566
  gen3_flash_types[6].img_type = 162;
#line 4566
  gen3_flash_types[7].offset = 8388608UL;
#line 4566
  gen3_flash_types[7].optype = 11;
#line 4566
  gen3_flash_types[7].size = 2097152;
#line 4566
  gen3_flash_types[7].img_type = 178;
#line 4566
  gen3_flash_types[8].offset = 15990784UL;
#line 4566
  gen3_flash_types[8].optype = 13;
#line 4566
  gen3_flash_types[8].size = 262144;
#line 4566
  gen3_flash_types[8].img_type = 16;
#line 4566
  gen3_flash_types[9].offset = 1310720UL;
#line 4566
  gen3_flash_types[9].optype = 99;
#line 4566
  gen3_flash_types[9].size = 262144;
#line 4566
  gen3_flash_types[9].img_type = 192;
#line 4589
  gen2_flash_types[0].offset = 1048576UL;
#line 4589
  gen2_flash_types[0].optype = 0;
#line 4589
  gen2_flash_types[0].size = 1310720;
#line 4589
  gen2_flash_types[0].img_type = 160;
#line 4589
  gen2_flash_types[1].offset = 0UL;
#line 4589
  gen2_flash_types[1].optype = 1;
#line 4589
  gen2_flash_types[1].size = 262144;
#line 4589
  gen2_flash_types[1].img_type = 224;
#line 4589
  gen2_flash_types[2].offset = 7340032UL;
#line 4589
  gen2_flash_types[2].optype = 2;
#line 4589
  gen2_flash_types[2].size = 262144;
#line 4589
  gen2_flash_types[2].img_type = 34;
#line 4589
  gen2_flash_types[3].offset = 7864320UL;
#line 4589
  gen2_flash_types[3].optype = 3;
#line 4589
  gen2_flash_types[3].size = 262144;
#line 4589
  gen2_flash_types[3].img_type = 32;
#line 4589
  gen2_flash_types[4].offset = 524288UL;
#line 4589
  gen2_flash_types[4].optype = 8;
#line 4589
  gen2_flash_types[4].size = 262144;
#line 4589
  gen2_flash_types[4].img_type = 33;
#line 4589
  gen2_flash_types[5].offset = 2359296UL;
#line 4589
  gen2_flash_types[5].optype = 9;
#line 4589
  gen2_flash_types[5].size = 1310720;
#line 4589
  gen2_flash_types[5].img_type = 176;
#line 4589
  gen2_flash_types[6].offset = 3670016UL;
#line 4589
  gen2_flash_types[6].optype = 10;
#line 4589
  gen2_flash_types[6].size = 1310720;
#line 4589
  gen2_flash_types[6].img_type = 162;
#line 4589
  gen2_flash_types[7].offset = 4980736UL;
#line 4589
  gen2_flash_types[7].optype = 11;
#line 4589
  gen2_flash_types[7].size = 1310720;
#line 4589
  gen2_flash_types[7].img_type = 178;
#line 4608
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 4609
    pflashcomp = (struct flash_comp  const  *)(& gen3_flash_types);
#line 4610
    filehdr_size = 128;
#line 4611
    num_comp = 10;
  } else {
#line 4613
    pflashcomp = (struct flash_comp  const  *)(& gen2_flash_types);
#line 4614
    filehdr_size = 96;
#line 4615
    num_comp = 8;
#line 4616
    img_hdrs_size = 0;
  }
#line 4620
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 4621
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 4622
    dev_err((struct device  const  *)dev, "Invalid Cookie. FW image may be corrupted\n");
#line 4623
    return (-1);
  } else {

  }
#line 4625
  i = 0;
#line 4625
  goto ldv_59004;
  ldv_59003: 
#line 4626
  tmp = is_comp_in_ufi(adapter, fsec, (pflashcomp + (unsigned long )i)->img_type);
#line 4626
  if (tmp) {
#line 4626
    tmp___0 = 0;
  } else {
#line 4626
    tmp___0 = 1;
  }
#line 4626
  if (tmp___0) {
#line 4627
    goto ldv_59002;
  } else {

  }
#line 4629
  if ((int )(pflashcomp + (unsigned long )i)->optype == 13) {
#line 4629
    tmp___1 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)"3.102.148.0",
                     11UL);
#line 4629
    if (tmp___1 < 0) {
#line 4631
      goto ldv_59002;
    } else {

    }
  } else {

  }
#line 4633
  if ((int )(pflashcomp + (unsigned long )i)->optype == 99) {
#line 4633
    tmp___2 = phy_flashing_required(adapter);
#line 4633
    if (tmp___2) {
#line 4633
      tmp___3 = 0;
    } else {
#line 4633
      tmp___3 = 1;
    }
#line 4633
    if (tmp___3) {
#line 4635
      goto ldv_59002;
    } else {

    }
  } else {

  }
#line 4637
  if ((int )(pflashcomp + (unsigned long )i)->optype == 1) {
#line 4638
    status = be_check_flash_crc(adapter, fw->data, (u32 )(pflashcomp + (unsigned long )i)->offset,
                                (u32 )(pflashcomp + (unsigned long )i)->size, filehdr_size + img_hdrs_size,
                                1, & crc_match);
#line 4644
    if (status != 0) {
#line 4645
      dev_err((struct device  const  *)dev, "Could not get CRC for 0x%x region\n",
              (pflashcomp + (unsigned long )i)->optype);
#line 4648
      goto ldv_59002;
    } else {

    }
#line 4651
    if ((int )crc_match) {
#line 4652
      goto ldv_59002;
    } else {

    }
  } else {

  }
#line 4655
  p = fw->data + (((unsigned long )filehdr_size + (unsigned long )(pflashcomp + (unsigned long )i)->offset) + (unsigned long )img_hdrs_size);
#line 4657
  if ((unsigned long )(p + (unsigned long )(pflashcomp + (unsigned long )i)->size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 4658
    return (-1);
  } else {

  }
#line 4660
  status = be_flash(adapter, p, flash_cmd, (pflashcomp + (unsigned long )i)->optype,
                    (pflashcomp + (unsigned long )i)->size, 0U);
#line 4662
  if (status != 0) {
#line 4663
    dev_err((struct device  const  *)dev, "Flashing section type 0x%x failed\n", (pflashcomp + (unsigned long )i)->img_type);
#line 4665
    return (status);
  } else {

  }
  ldv_59002: 
#line 4625
  i = i + 1;
  ldv_59004: ;
#line 4625
  if (i < num_comp) {
#line 4627
    goto ldv_59003;
  } else {

  }

#line 4668
  return (0);
}
}
#line 4671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 be_get_img_optype(struct flash_section_entry fsec_entry ) 
{ 
  u32 img_type ;
  u16 img_optype ;

  {
#line 4673
  img_type = fsec_entry.type;
#line 4674
  img_optype = fsec_entry.optype;
#line 4676
  if ((unsigned int )img_optype != 65535U) {
#line 4677
    return (img_optype);
  } else {

  }
#line 4679
  switch (img_type) {
  case 160U: 
#line 4681
  img_optype = 0U;
#line 4682
  goto ldv_59012;
  case 224U: 
#line 4684
  img_optype = 1U;
#line 4685
  goto ldv_59012;
  case 34U: 
#line 4687
  img_optype = 2U;
#line 4688
  goto ldv_59012;
  case 32U: 
#line 4690
  img_optype = 3U;
#line 4691
  goto ldv_59012;
  case 33U: 
#line 4693
  img_optype = 8U;
#line 4694
  goto ldv_59012;
  case 176U: 
#line 4696
  img_optype = 9U;
#line 4697
  goto ldv_59012;
  case 16U: 
#line 4699
  img_optype = 13U;
#line 4700
  goto ldv_59012;
  case 48U: 
#line 4702
  img_optype = 22U;
#line 4703
  goto ldv_59012;
  case 192U: 
#line 4705
  img_optype = 21U;
#line 4706
  goto ldv_59012;
  case 208U: 
#line 4708
  img_optype = 18U;
#line 4709
  goto ldv_59012;
  case 209U: 
#line 4711
  img_optype = 19U;
#line 4712
  goto ldv_59012;
  case 210U: 
#line 4714
  img_optype = 23U;
#line 4715
  goto ldv_59012;
  default: ;
#line 4717
  goto ldv_59012;
  }
  ldv_59012: ;
#line 4720
  return (img_optype);
}
}
#line 4723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash_skyhawk(struct be_adapter *adapter , struct firmware  const  *fw ,
                            struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int img_hdrs_size ;
  bool crc_match ;
  bool old_fw_img ;
  bool flash_offset_support ;
  struct device *dev ;
  struct flash_section_info *fsec ;
  u32 img_offset ;
  u32 img_size ;
  u32 img_type ;
  u16 img_optype ;
  u16 flash_optype ;
  int status ;
  int i ;
  int filehdr_size ;
  u8 const   *p ;

  {
#line 4727
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 4728
  flash_offset_support = 1;
#line 4729
  dev = & (adapter->pdev)->dev;
#line 4730
  fsec = (struct flash_section_info *)0;
#line 4736
  filehdr_size = 128;
#line 4737
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 4738
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 4739
    dev_err((struct device  const  *)dev, "Invalid Cookie. FW image may be corrupted\n");
#line 4740
    return (-22);
  } else {

  }
  retry_flash: 
#line 4744
  i = 0;
#line 4744
  goto ldv_59050;
  ldv_59049: 
#line 4745
  img_offset = fsec->fsec_entry[i].offset;
#line 4746
  img_size = fsec->fsec_entry[i].pad_size;
#line 4747
  img_type = fsec->fsec_entry[i].type;
#line 4748
  img_optype = be_get_img_optype(fsec->fsec_entry[i]);
#line 4749
  old_fw_img = (unsigned int )fsec->fsec_entry[i].optype == 65535U;
#line 4751
  if ((unsigned int )img_optype == 65535U) {
#line 4752
    goto ldv_59047;
  } else {

  }
#line 4754
  if ((int )flash_offset_support) {
#line 4755
    flash_optype = 7U;
  } else {
#line 4757
    flash_optype = img_optype;
  }
#line 4762
  if ((int )old_fw_img) {
#line 4763
    goto flash;
  } else {

  }
#line 4765
  status = be_check_flash_crc(adapter, fw->data, img_offset, img_size, filehdr_size + img_hdrs_size,
                              (int )flash_optype, & crc_match);
#line 4769
  if ((status > 0 && ((unsigned int )status & 65535U) == 2U) || (status > 0 && ((unsigned int )status & 65535U) == 3U)) {
#line 4775
    if ((unsigned int )flash_optype == 7U) {
#line 4776
      flash_offset_support = 0;
#line 4777
      goto retry_flash;
    } else {

    }
#line 4787
    dev_err((struct device  const  *)dev, "Flash incomplete. Reset the server\n");
#line 4788
    dev_err((struct device  const  *)dev, "Download FW image again after reset\n");
#line 4789
    return (-11);
  } else
#line 4790
  if (status != 0) {
#line 4791
    dev_err((struct device  const  *)dev, "Could not get CRC for 0x%x region\n", (int )img_optype);
#line 4793
    return (-14);
  } else {

  }
#line 4796
  if ((int )crc_match) {
#line 4797
    goto ldv_59047;
  } else {

  }
  flash: 
#line 4800
  p = fw->data + (((unsigned long )filehdr_size + (unsigned long )img_offset) + (unsigned long )img_hdrs_size);
#line 4801
  if ((unsigned long )(p + (unsigned long )img_size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 4802
    return (-1);
  } else {

  }
#line 4804
  status = be_flash(adapter, p, flash_cmd, (int )flash_optype, (int )img_size, img_offset);
#line 4811
  if ((status > 0 && ((unsigned int )status & 65535U) == 3U) && (unsigned int )flash_optype == 7U) {
#line 4813
    flash_offset_support = 0;
#line 4814
    goto retry_flash;
  } else {

  }
#line 4820
  if ((int )old_fw_img && ((status > 0 && ((unsigned int )status & 65535U) == 3U) || ((unsigned int )img_optype == 23U && (status > 0 && ((unsigned int )status & 65535U) == 1U)))) {
#line 4824
    goto ldv_59047;
  } else
#line 4825
  if (status != 0) {
#line 4826
    dev_err((struct device  const  *)dev, "Flashing section type 0x%x failed\n", img_type);
#line 4828
    return (-14);
  } else {

  }
  ldv_59047: 
#line 4744
  i = i + 1;
  ldv_59050: ;
#line 4744
  if ((u32 )i < fsec->fsec_hdr.num_images) {
#line 4746
    goto ldv_59049;
  } else {

  }

#line 4831
  return (0);
}
}
#line 4834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int lancer_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct device *dev ;
  struct be_dma_mem flash_cmd ;
  u8 const   *data_ptr ;
  u8 *dest_image_ptr ;
  size_t image_size ;
  u32 chunk_size ;
  u32 data_written ;
  u32 offset ;
  int status ;
  u8 add_status ;
  u8 change_status ;
  u32 __min1 ;
  u32 __min2 ;

  {
#line 4839
  dev = & (adapter->pdev)->dev;
#line 4841
  data_ptr = (u8 const   *)0U;
#line 4842
  dest_image_ptr = (u8 *)0U;
#line 4843
  image_size = 0UL;
#line 4844
  chunk_size = 0U;
#line 4845
  data_written = 0U;
#line 4846
  offset = 0U;
#line 4847
  status = 0;
#line 4848
  add_status = 0U;
#line 4851
  if (((unsigned long )fw->size & 3UL) != 0UL) {
#line 4852
    dev_err((struct device  const  *)dev, "FW image size should be multiple of 4\n");
#line 4853
    return (-22);
  } else {

  }
#line 4856
  flash_cmd.size = 32912U;
#line 4858
  flash_cmd.va = dma_zalloc_coherent(dev, (size_t )flash_cmd.size, & flash_cmd.dma,
                                     208U);
#line 4860
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 4861
    return (-12);
  } else {

  }
#line 4863
  dest_image_ptr = (u8 *)flash_cmd.va + 144U;
#line 4865
  image_size = fw->size;
#line 4866
  data_ptr = fw->data;
#line 4868
  goto ldv_59072;
  ldv_59071: 
#line 4869
  __min1 = (u32 )image_size;
#line 4869
  __min2 = 32768U;
#line 4869
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 4872
  memcpy((void *)dest_image_ptr, (void const   *)data_ptr, (size_t )chunk_size);
#line 4874
  status = lancer_cmd_write_object(adapter, & flash_cmd, chunk_size, offset, "/prg",
                                   & data_written, & change_status, & add_status);
#line 4879
  if (status != 0) {
#line 4880
    goto ldv_59070;
  } else {

  }
#line 4882
  offset = offset + data_written;
#line 4883
  data_ptr = data_ptr + (unsigned long )data_written;
#line 4884
  image_size = image_size - (size_t )data_written;
  ldv_59072: ;
#line 4868
  if (image_size != 0UL) {
#line 4870
    goto ldv_59071;
  } else {

  }
  ldv_59070: ;
#line 4887
  if (status == 0) {
#line 4889
    status = lancer_cmd_write_object(adapter, & flash_cmd, 0U, offset, "/prg", & data_written,
                                     & change_status, & add_status);
  } else {

  }
#line 4896
  dma_free_attrs(dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma, (struct dma_attrs *)0);
#line 4897
  if (status != 0) {
#line 4898
    dev_err((struct device  const  *)dev, "Firmware load error\n");
#line 4899
    return (status <= 0 ? status : -5);
  } else {

  }
#line 4902
  _dev_info((struct device  const  *)dev, "Firmware flashed successfully\n");
#line 4904
  if ((unsigned int )change_status == 2U) {
#line 4905
    _dev_info((struct device  const  *)dev, "Resetting adapter to activate new FW\n");
#line 4906
    status = lancer_physdev_ctrl(adapter, 2U);
#line 4908
    if (status != 0) {
#line 4909
      dev_err((struct device  const  *)dev, "Adapter busy, could not reset FW\n");
#line 4910
      dev_err((struct device  const  *)dev, "Reboot server to activate new FW\n");
    } else {

    }
  } else
#line 4912
  if ((unsigned int )change_status != 0U) {
#line 4913
    _dev_info((struct device  const  *)dev, "Reboot server to activate new FW\n");
  } else {

  }
#line 4916
  return (0);
}
}
#line 4922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_check_ufi_compatibility(struct be_adapter *adapter , struct flash_file_hdr_g3 *fhdr ) 
{ 


  {
#line 4925
  if ((unsigned long )fhdr == (unsigned long )((struct flash_file_hdr_g3 *)0)) {
#line 4926
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Invalid FW UFI file");
#line 4927
    return (1);
  } else {

  }
#line 4933
  switch ((int )fhdr->build[0]) {
  case 52: ;
#line 4935
  if ((unsigned int )(adapter->pdev)->device != 1824U && (unsigned int )(adapter->pdev)->device != 1832U) {
#line 4936
    return (0);
  } else {

  }
#line 4937
  goto ldv_59078;
  case 51: ;
#line 4939
  if ((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) {
#line 4940
    return (0);
  } else {

  }
#line 4941
  goto ldv_59078;
  case 50: ;
#line 4943
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 4944
    return (0);
  } else {

  }
#line 4945
  goto ldv_59078;
  default: ;
#line 4947
  return (0);
  }
  ldv_59078: ;
#line 4950
  return ((int )((unsigned short )fhdr->asic_type_rev) >= (int )adapter->asic_rev);
}
}
#line 4953 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct device *dev ;
  struct flash_file_hdr_g3 *fhdr3 ;
  struct image_hdr *img_hdr_ptr ;
  int status ;
  int i ;
  int num_imgs ;
  struct be_dma_mem flash_cmd ;
  bool tmp ;
  int tmp___0 ;

  {
#line 4955
  dev = & (adapter->pdev)->dev;
#line 4958
  status = 0;
#line 4961
  fhdr3 = (struct flash_file_hdr_g3 *)fw->data;
#line 4962
  tmp = be_check_ufi_compatibility(adapter, fhdr3);
#line 4962
  if (tmp) {
#line 4962
    tmp___0 = 0;
  } else {
#line 4962
    tmp___0 = 1;
  }
#line 4962
  if (tmp___0) {
#line 4963
    dev_err((struct device  const  *)dev, "Flash image is not compatible with adapter\n");
#line 4964
    return (-22);
  } else {

  }
#line 4967
  flash_cmd.size = 32804U;
#line 4968
  flash_cmd.va = dma_zalloc_coherent(dev, (size_t )flash_cmd.size, & flash_cmd.dma,
                                     208U);
#line 4970
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 4971
    return (-12);
  } else {

  }
#line 4973
  num_imgs = (int )fhdr3->num_imgs;
#line 4974
  i = 0;
#line 4974
  goto ldv_59095;
  ldv_59094: 
#line 4975
  img_hdr_ptr = (struct image_hdr *)(fw->data + ((unsigned long )i * 48UL + 128UL));
#line 4978
  if (((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) && img_hdr_ptr->imageid != 1U) {
#line 4980
    goto ldv_59093;
  } else {

  }
#line 4982
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 4983
    status = be_flash_skyhawk(adapter, fw, & flash_cmd, num_imgs);
  } else {
#line 4986
    status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
  }
  ldv_59093: 
#line 4974
  i = i + 1;
  ldv_59095: ;
#line 4974
  if (i < num_imgs) {
#line 4976
    goto ldv_59094;
  } else {

  }
#line 4990
  dma_free_attrs(dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma, (struct dma_attrs *)0);
#line 4991
  if (status == 0) {
#line 4992
    _dev_info((struct device  const  *)dev, "Firmware flashed successfully\n");
  } else {

  }
#line 4994
  return (status);
}
}
#line 4997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) 
{ 
  struct firmware  const  *fw ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 5002
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 5002
  if (tmp) {
#line 5002
    tmp___0 = 0;
  } else {
#line 5002
    tmp___0 = 1;
  }
#line 5002
  if (tmp___0) {
#line 5003
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load not allowed (interface is down)\n");
#line 5005
    return (-100);
  } else {

  }
#line 5008
  status = request_firmware(& fw, (char const   *)fw_file, & (adapter->pdev)->dev);
#line 5009
  if (status != 0) {
#line 5010
    goto fw_exit;
  } else {

  }
#line 5012
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Flashing firmware file %s\n",
            fw_file);
#line 5014
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 5015
    status = lancer_fw_download(adapter, fw);
  } else {
#line 5017
    status = be_fw_download(adapter, fw);
  }
#line 5019
  if (status == 0) {
#line 5020
    be_cmd_get_fw_ver(adapter);
  } else {

  }
  fw_exit: 
#line 5023
  release_firmware(fw);
#line 5024
  return (status);
}
}
#line 5027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ndo_bridge_setlink(struct net_device *dev , struct nlmsghdr *nlh , u16 flags ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct nlattr *attr ;
  struct nlattr *br_spec ;
  int rem ;
  int status ;
  u16 mode ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 5030
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 5030
  adapter = (struct be_adapter *)tmp;
#line 5033
  status = 0;
#line 5034
  mode = 0U;
#line 5036
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 5037
    return (-95);
  } else {

  }
#line 5039
  br_spec = nlmsg_find_attr((struct nlmsghdr  const  *)nlh, 16, 26);
#line 5040
  if ((unsigned long )br_spec == (unsigned long )((struct nlattr *)0)) {
#line 5041
    return (-22);
  } else {

  }
#line 5043
  tmp___0 = nla_data((struct nlattr  const  *)br_spec);
#line 5043
  attr = (struct nlattr *)tmp___0;
#line 5043
  rem = nla_len((struct nlattr  const  *)br_spec);
#line 5043
  goto ldv_59118;
  ldv_59117: 
#line 5044
  tmp___1 = nla_type((struct nlattr  const  *)attr);
#line 5044
  if (tmp___1 != 1) {
#line 5045
    goto ldv_59115;
  } else {

  }
#line 5047
  tmp___2 = nla_len((struct nlattr  const  *)attr);
#line 5047
  if ((unsigned int )tmp___2 <= 1U) {
#line 5048
    return (-22);
  } else {

  }
#line 5050
  mode = nla_get_u16((struct nlattr  const  *)attr);
#line 5051
  if ((unsigned int )mode != 1U && (unsigned int )mode != 0U) {
#line 5052
    return (-22);
  } else {

  }
#line 5054
  status = be_cmd_set_hsw_config(adapter, 0, 0U, (int )((u16 )adapter->if_handle),
                                 (unsigned int )mode == 1U ? 3 : 2, 0);
#line 5059
  if (status != 0) {
#line 5060
    goto err;
  } else {

  }
#line 5062
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "enabled switch mode: %s\n",
            (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
#line 5065
  return (status);
  ldv_59115: 
#line 5043
  attr = nla_next((struct nlattr  const  *)attr, & rem);
  ldv_59118: 
#line 5043
  tmp___3 = nla_ok((struct nlattr  const  *)attr, rem);
#line 5043
  if (tmp___3 != 0) {
#line 5045
    goto ldv_59117;
  } else {

  }

  err: 
#line 5068
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to set switch mode %s\n",
          (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
#line 5071
  return (status);
}
}
#line 5074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ndo_bridge_getlink(struct sk_buff *skb , u32 pid , u32 seq , struct net_device *dev ,
                                 u32 filter_mask , int nlflags ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 hsw_mode ;
  int tmp___0 ;

  {
#line 5078
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 5078
  adapter = (struct be_adapter *)tmp;
#line 5079
  status = 0;
#line 5082
  if (((unsigned long )adapter->flags & 4UL) == 0UL) {
#line 5083
    return (0);
  } else {

  }
#line 5086
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 5087
    hsw_mode = 2U;
  } else {
#line 5089
    status = be_cmd_get_hsw_config(adapter, (u16 *)0U, 0U, (int )((u16 )adapter->if_handle),
                                   & hsw_mode, (bool *)0);
#line 5092
    if (status != 0) {
#line 5093
      return (0);
    } else {

    }
  }
#line 5096
  tmp___0 = ndo_dflt_bridge_getlink(skb, pid, seq, dev, (unsigned int )hsw_mode == 3U,
                                    0U, 0U, nlflags, filter_mask, (int (*)(struct sk_buff * ,
                                                                           struct net_device * ,
                                                                           u32  ))0);
#line 5096
  return (tmp___0);
}
}
#line 5117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_add_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                              __be16 port ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int status ;
  int tmp___0 ;
  __u16 tmp___1 ;

  {
#line 5120
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5120
  adapter = (struct be_adapter *)tmp;
#line 5121
  dev = & (adapter->pdev)->dev;
#line 5124
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 5125
    return;
  } else {

  }
#line 5127
  if (((unsigned long )adapter->flags & 256UL) != 0UL) {
#line 5128
    _dev_info((struct device  const  *)dev, "Only one UDP port supported for VxLAN offloads\n");
#line 5130
    _dev_info((struct device  const  *)dev, "Disabling VxLAN offloads\n");
#line 5131
    adapter->vxlan_port_count = adapter->vxlan_port_count + 1;
#line 5132
    goto err;
  } else {

  }
#line 5135
  tmp___0 = adapter->vxlan_port_count;
#line 5135
  adapter->vxlan_port_count = adapter->vxlan_port_count + 1;
#line 5135
  if (tmp___0 > 0) {
#line 5136
    return;
  } else {

  }
#line 5138
  status = be_cmd_manage_iface(adapter, (u32 )adapter->if_handle, 0);
#line 5140
  if (status != 0) {
#line 5141
    dev_warn((struct device  const  *)dev, "Failed to convert normal interface to tunnel\n");
#line 5142
    goto err;
  } else {

  }
#line 5145
  status = be_cmd_set_vxlan_port(adapter, (int )port);
#line 5146
  if (status != 0) {
#line 5147
    dev_warn((struct device  const  *)dev, "Failed to add VxLAN port\n");
#line 5148
    goto err;
  } else {

  }
#line 5150
  adapter->flags = adapter->flags | 256U;
#line 5151
  adapter->vxlan_port = port;
#line 5153
  netdev->hw_enc_features = netdev->hw_enc_features | 68222994ULL;
#line 5156
  netdev->hw_features = netdev->hw_features | 67108864ULL;
#line 5157
  netdev->features = netdev->features | 67108864ULL;
#line 5159
  tmp___1 = __fswab16((int )port);
#line 5159
  _dev_info((struct device  const  *)dev, "Enabled VxLAN offloads for UDP port %d\n",
            (int )tmp___1);
#line 5161
  return;
  err: 
#line 5163
  be_disable_vxlan_offloads(adapter);
#line 5164
  return;
}
}
#line 5166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_del_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                              __be16 port ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  __u16 tmp___0 ;

  {
#line 5169
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5169
  adapter = (struct be_adapter *)tmp;
#line 5171
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 5172
    return;
  } else {

  }
#line 5174
  if ((int )adapter->vxlan_port != (int )port) {
#line 5175
    goto done;
  } else {

  }
#line 5177
  be_disable_vxlan_offloads(adapter);
#line 5179
  tmp___0 = __fswab16((int )port);
#line 5179
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabled VxLAN offloads for UDP port %d\n",
            (int )tmp___0);
  done: 
#line 5183
  adapter->vxlan_port_count = adapter->vxlan_port_count - 1;
#line 5184
  return;
}
}
#line 5186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static netdev_features_t be_features_check(struct sk_buff *skb , struct net_device *dev ,
                                           netdev_features_t features ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 l4_hdr ;
  __be16 tmp___0 ;
  struct iphdr *tmp___1 ;
  struct ipv6hdr *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 5190
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 5190
  adapter = (struct be_adapter *)tmp;
#line 5191
  l4_hdr = 0U;
#line 5196
  if ((unsigned int )*((unsigned char *)skb + 146UL) == 0U || ((unsigned long )adapter->flags & 256UL) == 0UL) {
#line 5198
    return (features);
  } else {

  }
#line 5206
  tmp___0 = vlan_get_protocol(skb);
#line 5206
  switch ((int )tmp___0) {
  case 8: 
#line 5208
  tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
#line 5208
  l4_hdr = tmp___1->protocol;
#line 5209
  goto ldv_59155;
  case 56710: 
#line 5211
  tmp___2 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 5211
  l4_hdr = tmp___2->nexthdr;
#line 5212
  goto ldv_59155;
  default: ;
#line 5214
  return (features);
  }
  ldv_59155: ;
#line 5217
  if (((unsigned int )l4_hdr != 17U || (unsigned int )*((unsigned char *)skb + 147UL) != 0U) || (unsigned int )skb->__annonCompField74.inner_protocol != 22629U) {
#line 5222
    return (features & 0xffffffffe000ffe5ULL);
  } else {
#line 5217
    tmp___3 = skb_inner_mac_header((struct sk_buff  const  *)skb);
#line 5217
    tmp___4 = skb_transport_header((struct sk_buff  const  *)skb);
#line 5217
    if ((long )tmp___3 - (long )tmp___4 != 16L) {
#line 5222
      return (features & 0xffffffffe000ffe5ULL);
    } else {

    }
  }
#line 5224
  return (features);
}
}
#line 5228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct net_device_ops  const  be_netdev_ops  = 
#line 5228
     {0, 0, & be_open, & be_close, & be_xmit, 0, 0, & be_set_rx_mode, & be_mac_addr_set,
    & eth_validate_addr, 0, 0, & be_change_mtu, 0, 0, & be_get_stats64, 0, & be_vlan_add_vid,
    & be_vlan_rem_vid, & be_netpoll, 0, 0, & be_busy_poll, & be_set_vf_mac, & be_set_vf_vlan,
    & be_set_vf_tx_rate, & be_set_vf_spoofchk, & be_get_vf_config, & be_set_vf_link_state,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & be_ndo_bridge_setlink,
    & be_ndo_bridge_getlink, 0, 0, 0, 0, & be_add_vxlan_port, & be_del_vxlan_port,
    0, 0, 0, 0, & be_features_check, 0, 0};
#line 5260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_netdev_init(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 5262
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5262
  adapter = (struct be_adapter *)tmp;
#line 5264
  netdev->hw_features = netdev->hw_features | 17180983443ULL;
#line 5267
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 5267
  if ((int )tmp___0) {
#line 5268
    netdev->hw_features = netdev->hw_features | 8589934592ULL;
  } else {

  }
#line 5270
  netdev->features = (netdev->features | netdev->hw_features) | 768ULL;
#line 5273
  netdev->vlan_features = netdev->vlan_features | 1114131ULL;
#line 5276
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 5278
  netdev->flags = netdev->flags | 4096U;
#line 5280
  netif_set_gso_max_size(netdev, 65521U);
#line 5282
  netdev->netdev_ops = & be_netdev_ops;
#line 5284
  netdev->ethtool_ops = & be_ethtool_ops;
#line 5285
  return;
}
}
#line 5287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_cleanup(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  bool tmp ;

  {
#line 5289
  netdev = adapter->netdev;
#line 5291
  rtnl_lock();
#line 5292
  netif_device_detach(netdev);
#line 5293
  tmp = netif_running((struct net_device  const  *)netdev);
#line 5293
  if ((int )tmp) {
#line 5294
    be_close(netdev);
  } else {

  }
#line 5295
  rtnl_unlock();
#line 5297
  be_clear(adapter);
#line 5298
  return;
}
}
#line 5300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_resume(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;
  bool tmp ;

  {
#line 5302
  netdev = adapter->netdev;
#line 5305
  status = be_setup(adapter);
#line 5306
  if (status != 0) {
#line 5307
    return (status);
  } else {

  }
#line 5309
  tmp = netif_running((struct net_device  const  *)netdev);
#line 5309
  if ((int )tmp) {
#line 5310
    status = be_open(netdev);
#line 5311
    if (status != 0) {
#line 5312
      return (status);
    } else {

    }
  } else {

  }
#line 5315
  netif_device_attach(netdev);
#line 5317
  return (0);
}
}
#line 5320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_err_recover(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;

  {
#line 5322
  dev = & (adapter->pdev)->dev;
#line 5325
  status = be_resume(adapter);
#line 5326
  if (status != 0) {
#line 5327
    goto err;
  } else {

  }
#line 5329
  _dev_info((struct device  const  *)dev, "Adapter recovery successful\n");
#line 5330
  return (0);
  err: ;
#line 5332
  if ((unsigned int )adapter->virtfn == 0U) {
#line 5333
    dev_err((struct device  const  *)dev, "Adapter recovery failed\n");
  } else {
#line 5335
    dev_err((struct device  const  *)dev, "Re-trying adapter recovery\n");
  }
#line 5337
  return (status);
}
}
#line 5340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_err_detection_task(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int status ;
  u8 tmp ;

  {
#line 5343
  __mptr = (struct work_struct  const  *)work;
#line 5343
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb84c0UL;
#line 5345
  status = 0;
#line 5347
  be_detect_error(adapter);
#line 5349
  tmp = be_check_error(adapter, 3U);
#line 5349
  if ((unsigned int )tmp != 0U) {
#line 5350
    be_cleanup(adapter);
#line 5353
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 5354
      status = be_err_recover(adapter);
    } else {

    }
  } else {

  }
#line 5358
  if (status == 0 || (unsigned int )adapter->virtfn != 0U) {
#line 5359
    be_schedule_err_detection(adapter);
  } else {

  }
#line 5360
  return;
}
}
#line 5362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_log_sfp_info(struct be_adapter *adapter ) 
{ 
  int status ;

  {
#line 5366
  status = be_cmd_query_sfp_info(adapter);
#line 5367
  if (status == 0) {
#line 5368
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Unqualified SFP+ detected on %c from %s part no: %s",
            (int )adapter->port_name, (u8 *)(& adapter->phy.vendor_name), (u8 *)(& adapter->phy.vendor_pn));
  } else {

  }
#line 5373
  adapter->flags = adapter->flags & 4294966271U;
#line 5374
  return;
}
}
#line 5376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_worker(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct be_rx_obj *rxo ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 5379
  __mptr = (struct work_struct  const  *)work;
#line 5379
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb85a8UL;
#line 5386
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 5386
  if (tmp) {
#line 5386
    tmp___0 = 0;
  } else {
#line 5386
    tmp___0 = 1;
  }
#line 5386
  if (tmp___0) {
#line 5387
    local_bh_disable();
#line 5388
    be_process_mcc(adapter);
#line 5389
    local_bh_enable();
#line 5390
    goto reschedule;
  } else {

  }
#line 5393
  if (! adapter->stats_cmd_sent) {
#line 5394
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 5395
      lancer_cmd_get_pport_stats(adapter, & adapter->stats_cmd);
    } else {
#line 5398
      be_cmd_get_stats(adapter, & adapter->stats_cmd);
    }
  } else {

  }
#line 5401
  if ((unsigned int )adapter->virtfn == 0U) {
#line 5401
    tmp___1 = MODULO((int )adapter->work_counter, (int )((u16 )adapter->be_get_temp_freq));
#line 5401
    if (tmp___1 == 0U) {
#line 5403
      be_cmd_get_die_temperature(adapter);
    } else {

    }
  } else {

  }
#line 5405
  i = 0;
#line 5405
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 5405
  goto ldv_59199;
  ldv_59198: ;
#line 5409
  if ((int )rxo->rx_post_starved) {
#line 5410
    be_post_rx_frags(rxo, 208U, 64U);
  } else {

  }
#line 5405
  i = i + 1;
#line 5405
  rxo = rxo + 1;
  ldv_59199: ;
#line 5405
  if ((int )adapter->num_rx_qs > i) {
#line 5407
    goto ldv_59198;
  } else {

  }

#line 5414
  if ((unsigned int )(adapter->pdev)->device != 1824U && (unsigned int )(adapter->pdev)->device != 1832U) {
#line 5415
    be_eqd_update(adapter, 0);
  } else {

  }
#line 5417
  if (((unsigned long )adapter->flags & 1024UL) != 0UL) {
#line 5418
    be_log_sfp_info(adapter);
  } else {

  }
  reschedule: 
#line 5421
  adapter->work_counter = (u16 )((int )adapter->work_counter + 1);
#line 5422
  tmp___2 = msecs_to_jiffies(1000U);
#line 5422
  schedule_delayed_work(& adapter->work, tmp___2);
#line 5423
  return;
}
}
#line 5425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_unmap_pci_bars(struct be_adapter *adapter ) 
{ 


  {
#line 5427
  if ((unsigned long )adapter->csr != (unsigned long )((u8 *)0U)) {
#line 5428
    pci_iounmap(adapter->pdev, (void *)adapter->csr);
  } else {

  }
#line 5429
  if ((unsigned long )adapter->db != (unsigned long )((u8 *)0U)) {
#line 5430
    pci_iounmap(adapter->pdev, (void *)adapter->db);
  } else {

  }
#line 5431
  return;
}
}
#line 5433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int db_bar(struct be_adapter *adapter ) 
{ 


  {
#line 5435
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (unsigned int )adapter->virtfn != 0U) {
#line 5436
    return (0);
  } else {
#line 5438
    return (4);
  }
}
}
#line 5441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_roce_map_pci_bars(struct be_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 5443
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 5444
    adapter->roce_db.size = 4096U;
#line 5445
    tmp = db_bar(adapter);
#line 5445
    adapter->roce_db.io_addr = (adapter->pdev)->resource[tmp].start;
#line 5447
    tmp___5 = db_bar(adapter);
#line 5447
    if ((adapter->pdev)->resource[tmp___5].start != 0ULL) {
#line 5447
      tmp___3 = db_bar(adapter);
#line 5447
      tmp___4 = db_bar(adapter);
#line 5447
      adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
    } else {
#line 5447
      tmp___6 = db_bar(adapter);
#line 5447
      tmp___7 = db_bar(adapter);
#line 5447
      if ((adapter->pdev)->resource[tmp___6].end != (adapter->pdev)->resource[tmp___7].start) {
#line 5447
        tmp___3 = db_bar(adapter);
#line 5447
        tmp___4 = db_bar(adapter);
#line 5447
        adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
      } else {
#line 5447
        adapter->roce_db.total_size = 0U;
      }
    }
  } else {

  }
#line 5450
  return (0);
}
}
#line 5453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_map_pci_bars(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;
  u8 *addr ;
  u32 sli_intf ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 5455
  pdev = adapter->pdev;
#line 5459
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 88, & sli_intf);
#line 5460
  adapter->sli_family = (sli_intf & 3840U) >> 8;
#line 5462
  adapter->virtfn = (unsigned int )((u8 )sli_intf) & 1U;
#line 5464
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) && (unsigned int )adapter->virtfn == 0U) {
#line 5465
    tmp = pci_iomap(pdev, 2, 0UL);
#line 5465
    adapter->csr = (u8 *)tmp;
#line 5466
    if ((unsigned long )adapter->csr == (unsigned long )((u8 *)0U)) {
#line 5467
      return (-12);
    } else {

    }
  } else {

  }
#line 5470
  tmp___0 = db_bar(adapter);
#line 5470
  tmp___1 = pci_iomap(pdev, tmp___0, 0UL);
#line 5470
  addr = (u8 *)tmp___1;
#line 5471
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 5472
    goto pci_map_err;
  } else {

  }
#line 5473
  adapter->db = addr;
#line 5475
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) || (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 5476
    if ((unsigned int )adapter->virtfn == 0U) {
#line 5478
      tmp___2 = pci_iomap(pdev, (unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U,
                          0UL);
#line 5478
      addr = (u8 *)tmp___2;
#line 5479
      if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 5480
        goto pci_map_err;
      } else {

      }
#line 5481
      adapter->pcicfg = addr;
    } else {
#line 5483
      adapter->pcicfg = adapter->db + 4096UL;
    }
  } else {

  }
#line 5487
  be_roce_map_pci_bars(adapter);
#line 5488
  return (0);
  pci_map_err: 
#line 5491
  dev_err((struct device  const  *)(& pdev->dev), "Error in mapping PCI BARs\n");
#line 5492
  be_unmap_pci_bars(adapter);
#line 5493
  return (-12);
}
}
#line 5496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_drv_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mem ;
  struct device *dev ;

  {
#line 5498
  mem = & adapter->mbox_mem_alloced;
#line 5499
  dev = & (adapter->pdev)->dev;
#line 5501
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 5502
    dma_free_attrs(dev, (size_t )mem->size, mem->va, mem->dma, (struct dma_attrs *)0);
  } else {

  }
#line 5504
  mem = & adapter->rx_filter;
#line 5505
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 5506
    dma_free_attrs(dev, (size_t )mem->size, mem->va, mem->dma, (struct dma_attrs *)0);
  } else {

  }
#line 5508
  mem = & adapter->stats_cmd;
#line 5509
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 5510
    dma_free_attrs(dev, (size_t )mem->size, mem->va, mem->dma, (struct dma_attrs *)0);
  } else {

  }
#line 5511
  return;
}
}
#line 5514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_drv_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  struct be_dma_mem *rx_filter ;
  struct be_dma_mem *stats_cmd ;
  struct device *dev ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___5 ;

  {
#line 5516
  mbox_mem_alloc = & adapter->mbox_mem_alloced;
#line 5517
  mbox_mem_align = & adapter->mbox_mem;
#line 5518
  rx_filter = & adapter->rx_filter;
#line 5519
  stats_cmd = & adapter->stats_cmd;
#line 5520
  dev = & (adapter->pdev)->dev;
#line 5521
  status = 0;
#line 5523
  mbox_mem_alloc->size = 288U;
#line 5524
  mbox_mem_alloc->va = dma_zalloc_coherent(dev, (size_t )mbox_mem_alloc->size, & mbox_mem_alloc->dma,
                                           208U);
#line 5527
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
#line 5528
    return (-12);
  } else {

  }
#line 5530
  mbox_mem_align->size = 272U;
#line 5531
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 5532
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 5534
  rx_filter->size = 424U;
#line 5535
  rx_filter->va = dma_zalloc_coherent(dev, (size_t )rx_filter->size, & rx_filter->dma,
                                      208U);
#line 5537
  if ((unsigned long )rx_filter->va == (unsigned long )((void *)0)) {
#line 5538
    status = -12;
#line 5539
    goto free_mbox;
  } else {

  }
#line 5542
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 5543
    stats_cmd->size = 672U;
  } else
#line 5544
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 5545
    stats_cmd->size = 1076U;
  } else
#line 5546
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 5547
    stats_cmd->size = 1864U;
  } else {
#line 5549
    stats_cmd->size = 2696U;
  }
#line 5550
  stats_cmd->va = dma_zalloc_coherent(dev, (size_t )stats_cmd->size, & stats_cmd->dma,
                                      208U);
#line 5552
  if ((unsigned long )stats_cmd->va == (unsigned long )((void *)0)) {
#line 5553
    status = -12;
#line 5554
    goto free_rx_filter;
  } else {

  }
#line 5557
  __mutex_init(& adapter->mbox_lock, "&adapter->mbox_lock", & __key);
#line 5558
  spinlock_check(& adapter->mcc_lock);
#line 5558
  __raw_spin_lock_init(& adapter->mcc_lock.__annonCompField18.rlock, "&(&adapter->mcc_lock)->rlock",
                       & __key___0);
#line 5559
  spinlock_check(& adapter->mcc_cq_lock);
#line 5559
  __raw_spin_lock_init(& adapter->mcc_cq_lock.__annonCompField18.rlock, "&(&adapter->mcc_cq_lock)->rlock",
                       & __key___1);
#line 5560
  init_completion(& adapter->et_cmd_compl);
#line 5562
  pci_save_state(adapter->pdev);
#line 5564
  __init_work(& adapter->work.work, 0);
#line 5564
  __constr_expr_0.counter = 137438953408L;
#line 5564
  adapter->work.work.data = __constr_expr_0;
#line 5564
  lockdep_init_map(& adapter->work.work.lockdep_map, "(&(&adapter->work)->work)",
                   & __key___2, 0);
#line 5564
  INIT_LIST_HEAD(& adapter->work.work.entry);
#line 5564
  adapter->work.work.func = & be_worker;
#line 5564
  init_timer_key(& adapter->work.timer, 2097152U, "(&(&adapter->work)->timer)", & __key___3);
#line 5564
  adapter->work.timer.function = & delayed_work_timer_fn;
#line 5564
  adapter->work.timer.data = (unsigned long )(& adapter->work);
#line 5565
  __init_work(& adapter->be_err_detection_work.work, 0);
#line 5565
  __constr_expr_1.counter = 137438953408L;
#line 5565
  adapter->be_err_detection_work.work.data = __constr_expr_1;
#line 5565
  lockdep_init_map(& adapter->be_err_detection_work.work.lockdep_map, "(&(&adapter->be_err_detection_work)->work)",
                   & __key___4, 0);
#line 5565
  INIT_LIST_HEAD(& adapter->be_err_detection_work.work.entry);
#line 5565
  adapter->be_err_detection_work.work.func = & be_err_detection_task;
#line 5565
  init_timer_key(& adapter->be_err_detection_work.timer, 2097152U, "(&(&adapter->be_err_detection_work)->timer)",
                 & __key___5);
#line 5565
  adapter->be_err_detection_work.timer.function = & delayed_work_timer_fn;
#line 5565
  adapter->be_err_detection_work.timer.data = (unsigned long )(& adapter->be_err_detection_work);
#line 5568
  adapter->rx_fc = 1U;
#line 5569
  adapter->tx_fc = 1U;
#line 5572
  adapter->be_get_temp_freq = 64;
#line 5574
  return (0);
  free_rx_filter: 
#line 5577
  dma_free_attrs(dev, (size_t )rx_filter->size, rx_filter->va, rx_filter->dma, (struct dma_attrs *)0);
  free_mbox: 
#line 5579
  dma_free_attrs(dev, (size_t )mbox_mem_alloc->size, mbox_mem_alloc->va, mbox_mem_alloc->dma,
                 (struct dma_attrs *)0);
#line 5581
  return (status);
}
}
#line 5584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_remove(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 5586
  tmp = pci_get_drvdata(pdev);
#line 5586
  adapter = (struct be_adapter *)tmp;
#line 5588
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 5589
    return;
  } else {

  }
#line 5591
  be_roce_dev_remove(adapter);
#line 5592
  be_intr_set(adapter, 0);
#line 5594
  be_cancel_err_detection(adapter);
#line 5596
  ldv_unregister_netdev_17(adapter->netdev);
#line 5598
  be_clear(adapter);
#line 5601
  be_cmd_fw_clean(adapter);
#line 5603
  be_unmap_pci_bars(adapter);
#line 5604
  be_drv_cleanup(adapter);
#line 5606
  pci_disable_pcie_error_reporting(pdev);
#line 5608
  pci_release_regions(pdev);
#line 5609
  pci_disable_device(pdev);
#line 5611
  ldv_free_netdev_18(adapter->netdev);
#line 5612
  return;
}
}
#line 5614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static ssize_t be_hwmon_show_temp(struct device *dev , struct device_attribute *dev_attr ,
                                  char *buf ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 5618
  tmp = dev_get_drvdata((struct device  const  *)dev);
#line 5618
  adapter = (struct be_adapter *)tmp;
#line 5621
  if ((unsigned int )adapter->hwmon_info.be_on_die_temp == 255U) {
#line 5622
    return (-5L);
  } else {
#line 5624
    tmp___0 = sprintf(buf, "%u\n", (int )adapter->hwmon_info.be_on_die_temp * 1000);
#line 5624
    return ((ssize_t )tmp___0);
  }
}
}
#line 5629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sensor_device_attribute sensor_dev_attr_temp1_input  =    {{{"temp1_input", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
     & be_hwmon_show_temp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                        char const   * , size_t  ))0}, 1};
#line 5631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct attribute *be_hwmon_attrs[2U]  = {      & sensor_dev_attr_temp1_input.dev_attr.attr,      (struct attribute *)0};
#line 5636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct attribute_group  const  be_hwmon_group  =    {0, 0, (struct attribute **)(& be_hwmon_attrs), 0};
#line 5636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct attribute_group  const  *be_hwmon_groups[2U]  = {      & be_hwmon_group,      (struct attribute_group  const  *)0};
#line 5638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static char *mc_name(struct be_adapter *adapter ) 
{ 
  char *str ;

  {
#line 5640
  str = (char *)"";
#line 5642
  switch ((int )adapter->mc_type) {
  case 2: 
#line 5644
  str = (char *)"UMC";
#line 5645
  goto ldv_59273;
  case 3: 
#line 5647
  str = (char *)"FLEX10";
#line 5648
  goto ldv_59273;
  case 4: 
#line 5650
  str = (char *)"vNIC-1";
#line 5651
  goto ldv_59273;
  case 5: 
#line 5653
  str = (char *)"nPAR";
#line 5654
  goto ldv_59273;
  case 6: 
#line 5656
  str = (char *)"UFP";
#line 5657
  goto ldv_59273;
  case 7: 
#line 5659
  str = (char *)"vNIC-2";
#line 5660
  goto ldv_59273;
  default: 
#line 5662
  str = (char *)"";
  }
  ldv_59273: ;
#line 5665
  return (str);
}
}
#line 5668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static char *func_name(struct be_adapter *adapter ) 
{ 


  {
#line 5670
  return ((unsigned int )adapter->virtfn == 0U ? (char *)"PF" : (char *)"VF");
}
}
#line 5673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static char *nic_name(struct pci_dev *pdev ) 
{ 


  {
#line 5675
  switch ((int )pdev->device) {
  case 1792: ;
#line 5677
  return ((char *)"Emulex OneConnect");
  case 1808: ;
#line 5679
  return ((char *)"Emulex OneConnect(be3)");
  case 57888: ;
  case 57896: ;
#line 5682
  return ((char *)"Emulex OneConnect(Lancer)");
  case 545: ;
#line 5684
  return ((char *)"Emulex BladeEngine3");
  case 1824: ;
  case 1832: ;
#line 5687
  return ((char *)"Emulex OneConnect(Skyhawk)");
  default: ;
#line 5689
  return ((char *)"Emulex BladeEngine2");
  }
}
}
#line 5693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_probe(struct pci_dev *pdev , struct pci_device_id  const  *pdev_id ) 
{ 
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  int status ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 5697
  status = 0;
#line 5699
  _dev_info((struct device  const  *)(& pdev->dev), "%s version is %s\n", (char *)"be2net",
            (char *)"10.6.0.2");
#line 5701
  status = pci_enable_device(pdev);
#line 5702
  if (status != 0) {
#line 5703
    goto do_none;
  } else {

  }
#line 5705
  status = pci_request_regions(pdev, "be2net");
#line 5706
  if (status != 0) {
#line 5707
    goto disable_dev;
  } else {

  }
#line 5708
  pci_set_master(pdev);
#line 5710
  netdev = alloc_etherdev_mqs(1343872, 32U, 32U);
#line 5711
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 5712
    status = -12;
#line 5713
    goto rel_reg;
  } else {

  }
#line 5715
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5715
  adapter = (struct be_adapter *)tmp;
#line 5716
  adapter->pdev = pdev;
#line 5717
  pci_set_drvdata(pdev, (void *)adapter);
#line 5718
  adapter->netdev = netdev;
#line 5719
  netdev->dev.parent = & pdev->dev;
#line 5721
  status = dma_set_mask_and_coherent(& pdev->dev, 0xffffffffffffffffULL);
#line 5722
  if (status == 0) {
#line 5723
    netdev->features = netdev->features | 32ULL;
  } else {
#line 5725
    status = dma_set_mask_and_coherent(& pdev->dev, 4294967295ULL);
#line 5726
    if (status != 0) {
#line 5727
      dev_err((struct device  const  *)(& pdev->dev), "Could not set PCI DMA Mask\n");
#line 5728
      goto free_netdev;
    } else {

    }
  }
#line 5732
  status = pci_enable_pcie_error_reporting(pdev);
#line 5733
  if (status == 0) {
#line 5734
    _dev_info((struct device  const  *)(& pdev->dev), "PCIe error reporting enabled\n");
  } else {

  }
#line 5736
  status = be_map_pci_bars(adapter);
#line 5737
  if (status != 0) {
#line 5738
    goto free_netdev;
  } else {

  }
#line 5740
  status = be_drv_init(adapter);
#line 5741
  if (status != 0) {
#line 5742
    goto unmap_bars;
  } else {

  }
#line 5744
  status = be_setup(adapter);
#line 5745
  if (status != 0) {
#line 5746
    goto drv_cleanup;
  } else {

  }
#line 5748
  be_netdev_init(netdev);
#line 5749
  status = ldv_register_netdev_19(netdev);
#line 5750
  if (status != 0) {
#line 5751
    goto unsetup;
  } else {

  }
#line 5753
  be_roce_dev_add(adapter);
#line 5755
  be_schedule_err_detection(adapter);
#line 5758
  if ((unsigned int )adapter->virtfn == 0U) {
#line 5759
    adapter->hwmon_info.hwmon_dev = devm_hwmon_device_register_with_groups(& pdev->dev,
                                                                           "be2net",
                                                                           (void *)adapter,
                                                                           (struct attribute_group  const  **)(& be_hwmon_groups));
#line 5764
    adapter->hwmon_info.be_on_die_temp = 255U;
  } else {

  }
#line 5767
  tmp___0 = mc_name(adapter);
#line 5767
  tmp___1 = func_name(adapter);
#line 5767
  tmp___2 = nic_name(pdev);
#line 5767
  _dev_info((struct device  const  *)(& pdev->dev), "%s: %s %s port %c\n", tmp___2,
            tmp___1, tmp___0, (int )adapter->port_name);
#line 5770
  return (0);
  unsetup: 
#line 5773
  be_clear(adapter);
  drv_cleanup: 
#line 5775
  be_drv_cleanup(adapter);
  unmap_bars: 
#line 5777
  be_unmap_pci_bars(adapter);
  free_netdev: 
#line 5779
  ldv_free_netdev_20(netdev);
  rel_reg: 
#line 5781
  pci_release_regions(pdev);
  disable_dev: 
#line 5783
  pci_disable_device(pdev);
  do_none: 
#line 5785
  tmp___3 = nic_name(pdev);
#line 5785
  dev_err((struct device  const  *)(& pdev->dev), "%s initialization failed\n", tmp___3);
#line 5786
  return (status);
}
}
#line 5789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  pci_power_t tmp___0 ;

  {
#line 5791
  tmp = pci_get_drvdata(pdev);
#line 5791
  adapter = (struct be_adapter *)tmp;
#line 5793
  if ((int )adapter->wol_en) {
#line 5794
    be_setup_wol(adapter, 1);
  } else {

  }
#line 5796
  be_intr_set(adapter, 0);
#line 5797
  be_cancel_err_detection(adapter);
#line 5799
  be_cleanup(adapter);
#line 5801
  pci_save_state(pdev);
#line 5802
  pci_disable_device(pdev);
#line 5803
  tmp___0 = pci_choose_state(pdev, state);
#line 5803
  pci_set_power_state(pdev, tmp___0);
#line 5804
  return (0);
}
}
#line 5807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_pci_resume(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 5809
  tmp = pci_get_drvdata(pdev);
#line 5809
  adapter = (struct be_adapter *)tmp;
#line 5810
  status = 0;
#line 5812
  status = pci_enable_device(pdev);
#line 5813
  if (status != 0) {
#line 5814
    return (status);
  } else {

  }
#line 5816
  pci_set_power_state(pdev, 0);
#line 5817
  pci_restore_state(pdev);
#line 5819
  status = be_resume(adapter);
#line 5820
  if (status != 0) {
#line 5821
    return (status);
  } else {

  }
#line 5823
  be_schedule_err_detection(adapter);
#line 5825
  if ((int )adapter->wol_en) {
#line 5826
    be_setup_wol(adapter, 0);
  } else {

  }
#line 5828
  return (0);
}
}
#line 5834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_shutdown(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 5836
  tmp = pci_get_drvdata(pdev);
#line 5836
  adapter = (struct be_adapter *)tmp;
#line 5838
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 5839
    return;
  } else {

  }
#line 5841
  be_roce_dev_shutdown(adapter);
#line 5842
  ldv_cancel_delayed_work_sync_21(& adapter->work);
#line 5843
  be_cancel_err_detection(adapter);
#line 5845
  netif_device_detach(adapter->netdev);
#line 5847
  be_cmd_reset_function(adapter);
#line 5849
  pci_disable_device(pdev);
#line 5850
  return;
}
}
#line 5852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static pci_ers_result_t be_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 tmp___0 ;

  {
#line 5855
  tmp = pci_get_drvdata(pdev);
#line 5855
  adapter = (struct be_adapter *)tmp;
#line 5857
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH error detected\n");
#line 5859
  tmp___0 = be_check_error(adapter, 1U);
#line 5859
  if ((unsigned int )tmp___0 == 0U) {
#line 5860
    be_set_error(adapter, 1);
#line 5862
    be_cancel_err_detection(adapter);
#line 5864
    be_cleanup(adapter);
  } else {

  }
#line 5867
  if (state == 3U) {
#line 5868
    return (4U);
  } else {

  }
#line 5870
  pci_disable_device(pdev);
#line 5878
  if (pdev->devfn == 0U) {
#line 5879
    ssleep(30U);
  } else {

  }
#line 5881
  return (3U);
}
}
#line 5884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static pci_ers_result_t be_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 5886
  tmp = pci_get_drvdata(pdev);
#line 5886
  adapter = (struct be_adapter *)tmp;
#line 5889
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH reset\n");
#line 5891
  status = pci_enable_device(pdev);
#line 5892
  if (status != 0) {
#line 5893
    return (4U);
  } else {

  }
#line 5895
  pci_set_master(pdev);
#line 5896
  pci_set_power_state(pdev, 0);
#line 5897
  pci_restore_state(pdev);
#line 5900
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Waiting for FW to be ready after EEH reset\n");
#line 5902
  status = be_fw_wait_ready(adapter);
#line 5903
  if (status != 0) {
#line 5904
    return (4U);
  } else {

  }
#line 5906
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 5907
  be_clear_error(adapter, 255);
#line 5908
  return (5U);
}
}
#line 5911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eeh_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 5913
  status = 0;
#line 5914
  tmp = pci_get_drvdata(pdev);
#line 5914
  adapter = (struct be_adapter *)tmp;
#line 5916
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume\n");
#line 5918
  pci_save_state(pdev);
#line 5920
  status = be_resume(adapter);
#line 5921
  if (status != 0) {
#line 5922
    goto err;
  } else {

  }
#line 5924
  be_schedule_err_detection(adapter);
#line 5925
  return;
  err: 
#line 5927
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume failed\n");
#line 5928
  return;
}
}
#line 5930 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_pci_sriov_configure(struct pci_dev *pdev , int num_vfs___0 ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 num_vf_qs ;
  int status ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5932
  tmp = pci_get_drvdata(pdev);
#line 5932
  adapter = (struct be_adapter *)tmp;
#line 5936
  if (num_vfs___0 == 0) {
#line 5937
    be_vf_clear(adapter);
  } else {

  }
#line 5939
  adapter->num_vfs = (u16 )num_vfs___0;
#line 5941
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 5941
    tmp___0 = pci_vfs_assigned(pdev);
#line 5941
    if (tmp___0 != 0) {
#line 5942
      dev_warn((struct device  const  *)(& pdev->dev), "Cannot disable VFs while they are assigned\n");
#line 5944
      return (-16);
    } else {

    }
  } else {

  }
#line 5955
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 5955
    tmp___1 = pci_num_vf(pdev);
#line 5955
    if (tmp___1 == 0) {
#line 5956
      num_vf_qs = be_calculate_vf_qs(adapter, (int )adapter->num_vfs);
#line 5957
      status = be_cmd_set_sriov_config(adapter, adapter->pool_res, (int )adapter->num_vfs,
                                       (int )num_vf_qs);
#line 5959
      if (status != 0) {
#line 5960
        dev_err((struct device  const  *)(& pdev->dev), "Failed to optimize SR-IOV resources\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 5964
  status = be_get_resources(adapter);
#line 5965
  if (status != 0) {
#line 5966
    return (status <= 0 ? status : -5);
  } else {

  }
#line 5969
  rtnl_lock();
#line 5970
  status = be_update_queues(adapter);
#line 5971
  rtnl_unlock();
#line 5972
  if (status != 0) {
#line 5973
    return (status <= 0 ? status : -5);
  } else {

  }
#line 5975
  if ((unsigned int )adapter->num_vfs != 0U) {
#line 5976
    status = be_vf_setup(adapter);
  } else {

  }
#line 5978
  if (status == 0) {
#line 5979
    return ((int )adapter->num_vfs);
  } else {

  }
#line 5981
  return (0);
}
}
#line 5984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_error_handlers  const  be_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& be_eeh_err_detected),
    0, 0, & be_eeh_reset, 0, & be_eeh_resume};
#line 5990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_driver be_driver  = 
#line 5990
     {{0, 0}, "be2net", (struct pci_device_id  const  *)(& be_dev_ids), & be_probe,
    & be_remove, & be_suspend, 0, 0, & be_pci_resume, & be_shutdown, & be_pci_sriov_configure,
    & be_eeh_handlers, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0}}};
#line 6002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_init_module(void) 
{ 
  int tmp ;

  {
#line 6004
  if (((unsigned int )rx_frag_size != 8192U && (unsigned int )rx_frag_size != 4096U) && (unsigned int )rx_frag_size != 2048U) {
#line 6006
    printk("\fbe2net : Module param rx_frag_size must be 2048/4096/8192. Using 2048\n");
#line 6009
    rx_frag_size = 2048U;
  } else {

  }
#line 6012
  if (num_vfs != 0U) {
#line 6013
    printk("\016be2net : Module param num_vfs is obsolete.");
#line 6014
    printk("\016be2net : Use sysfs method to enable VFs\n");
  } else {

  }
#line 6017
  tmp = ldv___pci_register_driver_22(& be_driver, & __this_module, "be2net");
#line 6017
  return (tmp);
}
}
#line 6021 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_exit_module(void) 
{ 


  {
#line 6023
  ldv_pci_unregister_driver_23(& be_driver);
#line 6024
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
extern int ldv_suspend_7(void) ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_2  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_5  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_0  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_6  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_1  ;
#line 118
extern void ldv_initialize(void) ;
#line 119
extern int ldv_resume_early_6(void) ;
#line 120
extern int ldv_ndo_init_9(void) ;
#line 121
extern int ldv_ndo_uninit_9(void) ;
#line 122
extern int ldv_suspend_late_6(void) ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_4  ;
#line 124
extern int ldv_probe_7(void) ;
#line 125
void ldv_check_final_state(void) ;
#line 126
extern int ldv_release_7(void) ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_3  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_retval_7  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 132
  ldv_work_3_0 = 0;
#line 133
  ldv_work_3_1 = 0;
#line 134
  ldv_work_3_2 = 0;
#line 135
  ldv_work_3_3 = 0;
#line 136
  return;
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
#line 140
  tmp = __VERIFIER_nondet_int();
#line 140
  switch (tmp) {
  case 0: 
#line 142
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
#line 144
  goto ldv_59396;
  case 1: 
#line 146
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
#line 148
  goto ldv_59396;
  case 2: 
#line 150
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
#line 152
  goto ldv_59396;
  case 3: 
#line 154
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
#line 156
  goto ldv_59396;
  default: 
#line 157
  ldv_stop();
  }
  ldv_59396: ;
#line 159
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 164
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
#line 165
    ldv_irq_2_0 = 0;
#line 166
    return;
  } else {

  }
#line 168
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
#line 169
    ldv_irq_2_1 = 0;
#line 170
    return;
  } else {

  }
#line 172
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
#line 173
    ldv_irq_2_2 = 0;
#line 174
    return;
  } else {

  }
#line 176
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
#line 177
    ldv_irq_2_3 = 0;
#line 178
    return;
  } else {

  }
#line 180
  return;
}
}
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 185
  if (ldv_work_4_0 == 0) {
#line 186
    ldv_work_struct_4_0 = work;
#line 187
    ldv_work_4_0 = state;
#line 188
    return;
  } else {

  }
#line 191
  if (ldv_work_4_1 == 0) {
#line 192
    ldv_work_struct_4_1 = work;
#line 193
    ldv_work_4_1 = state;
#line 194
    return;
  } else {

  }
#line 197
  if (ldv_work_4_2 == 0) {
#line 198
    ldv_work_struct_4_2 = work;
#line 199
    ldv_work_4_2 = state;
#line 200
    return;
  } else {

  }
#line 203
  if (ldv_work_4_3 == 0) {
#line 204
    ldv_work_struct_4_3 = work;
#line 205
    ldv_work_4_3 = state;
#line 206
    return;
  } else {

  }
#line 208
  return;
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_initialize_pci_error_handlers_7(void) 
{ 
  void *tmp ;

  {
#line 212
  tmp = __VERIFIER_nondet_pointer();
#line 212
  be_eeh_handlers_group0 = (struct pci_dev *)tmp;
#line 213
  return;
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 216
  if (ldv_irq_2_0 == 0) {
#line 217
    ldv_irq_line_2_0 = line;
#line 218
    ldv_irq_data_2_0 = data;
#line 219
    ldv_irq_2_0 = 1;
#line 220
    return;
  } else {

  }
#line 222
  if (ldv_irq_2_1 == 0) {
#line 223
    ldv_irq_line_2_1 = line;
#line 224
    ldv_irq_data_2_1 = data;
#line 225
    ldv_irq_2_1 = 1;
#line 226
    return;
  } else {

  }
#line 228
  if (ldv_irq_2_2 == 0) {
#line 229
    ldv_irq_line_2_2 = line;
#line 230
    ldv_irq_data_2_2 = data;
#line 231
    ldv_irq_2_2 = 1;
#line 232
    return;
  } else {

  }
#line 234
  if (ldv_irq_2_3 == 0) {
#line 235
    ldv_irq_line_2_3 = line;
#line 236
    ldv_irq_data_2_3 = data;
#line 237
    ldv_irq_2_3 = 1;
#line 238
    return;
  } else {

  }
#line 240
  return;
}
}
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 245
  if ((unsigned long )handler == (unsigned long )(& be_msix)) {
#line 246
    return (1);
  } else {

  }
#line 248
  return (0);
}
}
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 253
  if (ldv_work_3_0 == 0) {
#line 254
    ldv_work_struct_3_0 = work;
#line 255
    ldv_work_3_0 = state;
#line 256
    return;
  } else {

  }
#line 259
  if (ldv_work_3_1 == 0) {
#line 260
    ldv_work_struct_3_1 = work;
#line 261
    ldv_work_3_1 = state;
#line 262
    return;
  } else {

  }
#line 265
  if (ldv_work_3_2 == 0) {
#line 266
    ldv_work_struct_3_2 = work;
#line 267
    ldv_work_3_2 = state;
#line 268
    return;
  } else {

  }
#line 271
  if (ldv_work_3_3 == 0) {
#line 272
    ldv_work_struct_3_3 = work;
#line 273
    ldv_work_3_3 = state;
#line 274
    return;
  } else {

  }
#line 276
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 281
  if (ldv_work_4_0 == state) {
#line 282
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 283
  if (ldv_work_4_1 == state) {
#line 284
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 285
  if (ldv_work_4_2 == state) {
#line 286
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 287
  if (ldv_work_4_3 == state) {
#line 288
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 289
  return;
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 293
  tmp = __VERIFIER_nondet_int();
#line 293
  switch (tmp) {
  case 0: 
#line 295
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 297
  goto ldv_59432;
  case 1: 
#line 299
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 301
  goto ldv_59432;
  case 2: 
#line 303
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 305
  goto ldv_59432;
  case 3: 
#line 307
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 309
  goto ldv_59432;
  default: 
#line 310
  ldv_stop();
  }
  ldv_59432: ;
#line 312
  return;
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 317
  if ((unsigned long )handler == (unsigned long )(& be_intx)) {
#line 318
    return (1);
  } else {

  }
#line 320
  return (0);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 327
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 329
    be_worker(work);
#line 330
    ldv_work_3_0 = 1;
#line 331
    return;
  } else {

  }
#line 333
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 335
    be_worker(work);
#line 336
    ldv_work_3_1 = 1;
#line 337
    return;
  } else {

  }
#line 339
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 341
    be_worker(work);
#line 342
    ldv_work_3_2 = 1;
#line 343
    return;
  } else {

  }
#line 345
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 347
    be_worker(work);
#line 348
    ldv_work_3_3 = 1;
#line 349
    return;
  } else {

  }
#line 351
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 356
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 358
    ldv_work_3_0 = 1;
  } else {

  }
#line 360
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 362
    ldv_work_3_1 = 1;
  } else {

  }
#line 364
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 366
    ldv_work_3_2 = 1;
  } else {

  }
#line 368
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 370
    ldv_work_3_3 = 1;
  } else {

  }
#line 371
  return;
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_net_device_ops_9(void) 
{ 
  void *tmp ;

  {
#line 376
  tmp = ldv_init_zalloc(3008UL);
#line 376
  be_netdev_ops_group1 = (struct net_device *)tmp;
#line 377
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 382
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 384
    ldv_work_4_0 = 1;
  } else {

  }
#line 386
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 388
    ldv_work_4_1 = 1;
  } else {

  }
#line 390
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 392
    ldv_work_4_2 = 1;
  } else {

  }
#line 394
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 396
    ldv_work_4_3 = 1;
  } else {

  }
#line 397
  return;
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 402
  ldv_work_4_0 = 0;
#line 403
  ldv_work_4_1 = 0;
#line 404
  ldv_work_4_2 = 0;
#line 405
  ldv_work_4_3 = 0;
#line 406
  return;
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 411
  tmp = __VERIFIER_nondet_int();
#line 411
  switch (tmp) {
  case 0: ;
#line 413
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 414
    ldv_work_3_0 = 4;
#line 415
    be_worker(ldv_work_struct_3_0);
#line 416
    ldv_work_3_0 = 1;
  } else {

  }
#line 419
  goto ldv_59465;
  case 1: ;
#line 421
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 422
    ldv_work_3_1 = 4;
#line 423
    be_worker(ldv_work_struct_3_0);
#line 424
    ldv_work_3_1 = 1;
  } else {

  }
#line 427
  goto ldv_59465;
  case 2: ;
#line 429
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 430
    ldv_work_3_2 = 4;
#line 431
    be_worker(ldv_work_struct_3_0);
#line 432
    ldv_work_3_2 = 1;
  } else {

  }
#line 435
  goto ldv_59465;
  case 3: ;
#line 437
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 438
    ldv_work_3_3 = 4;
#line 439
    be_worker(ldv_work_struct_3_0);
#line 440
    ldv_work_3_3 = 1;
  } else {

  }
#line 443
  goto ldv_59465;
  default: 
#line 444
  ldv_stop();
  }
  ldv_59465: ;
#line 446
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 451
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 452
    ldv_irq_1_0 = 0;
#line 453
    return;
  } else {

  }
#line 455
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 456
    ldv_irq_1_1 = 0;
#line 457
    return;
  } else {

  }
#line 459
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 460
    ldv_irq_1_2 = 0;
#line 461
    return;
  } else {

  }
#line 463
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 464
    ldv_irq_1_3 = 0;
#line 465
    return;
  } else {

  }
#line 467
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 473
  tmp = __VERIFIER_nondet_int();
#line 473
  irq_retval = (irqreturn_t )tmp;
#line 475
  if (state != 0) {
#line 476
    tmp___0 = __VERIFIER_nondet_int();
#line 476
    switch (tmp___0) {
    case 0: ;
#line 478
    if (state == 1) {
#line 479
      LDV_IN_INTERRUPT = 2;
#line 480
      irq_retval = be_msix(line, data);
#line 481
      LDV_IN_INTERRUPT = 1;
#line 482
      return (state);
    } else {

    }
#line 485
    goto ldv_59481;
    default: 
#line 486
    ldv_stop();
    }
    ldv_59481: ;
  } else {

  }
#line 489
  return (state);
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 494
  if (ldv_irq_1_0 == 0) {
#line 495
    ldv_irq_line_1_0 = line;
#line 496
    ldv_irq_data_1_0 = data;
#line 497
    ldv_irq_1_0 = 1;
#line 498
    return;
  } else {

  }
#line 500
  if (ldv_irq_1_1 == 0) {
#line 501
    ldv_irq_line_1_1 = line;
#line 502
    ldv_irq_data_1_1 = data;
#line 503
    ldv_irq_1_1 = 1;
#line 504
    return;
  } else {

  }
#line 506
  if (ldv_irq_1_2 == 0) {
#line 507
    ldv_irq_line_1_2 = line;
#line 508
    ldv_irq_data_1_2 = data;
#line 509
    ldv_irq_1_2 = 1;
#line 510
    return;
  } else {

  }
#line 512
  if (ldv_irq_1_3 == 0) {
#line 513
    ldv_irq_line_1_3 = line;
#line 514
    ldv_irq_data_1_3 = data;
#line 515
    ldv_irq_1_3 = 1;
#line 516
    return;
  } else {

  }
#line 518
  return;
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 525
  tmp = __VERIFIER_nondet_int();
#line 525
  switch (tmp) {
  case 0: ;
#line 527
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 528
    ldv_work_4_0 = 4;
#line 529
    be_err_detection_task(ldv_work_struct_4_0);
#line 530
    ldv_work_4_0 = 1;
  } else {

  }
#line 533
  goto ldv_59495;
  case 1: ;
#line 535
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 536
    ldv_work_4_1 = 4;
#line 537
    be_err_detection_task(ldv_work_struct_4_0);
#line 538
    ldv_work_4_1 = 1;
  } else {

  }
#line 541
  goto ldv_59495;
  case 2: ;
#line 543
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 544
    ldv_work_4_2 = 4;
#line 545
    be_err_detection_task(ldv_work_struct_4_0);
#line 546
    ldv_work_4_2 = 1;
  } else {

  }
#line 549
  goto ldv_59495;
  case 3: ;
#line 551
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 552
    ldv_work_4_3 = 4;
#line 553
    be_err_detection_task(ldv_work_struct_4_0);
#line 554
    ldv_work_4_3 = 1;
  } else {

  }
#line 557
  goto ldv_59495;
  default: 
#line 558
  ldv_stop();
  }
  ldv_59495: ;
#line 560
  return;
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 566
  if (ldv_work_3_0 == state) {
#line 567
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 568
  if (ldv_work_3_1 == state) {
#line 569
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 570
  if (ldv_work_3_2 == state) {
#line 571
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 572
  if (ldv_work_3_3 == state) {
#line 573
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 574
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 580
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 582
    be_err_detection_task(work);
#line 583
    ldv_work_4_0 = 1;
#line 584
    return;
  } else {

  }
#line 586
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 588
    be_err_detection_task(work);
#line 589
    ldv_work_4_1 = 1;
#line 590
    return;
  } else {

  }
#line 592
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 594
    be_err_detection_task(work);
#line 595
    ldv_work_4_2 = 1;
#line 596
    return;
  } else {

  }
#line 598
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 600
    be_err_detection_task(work);
#line 601
    ldv_work_4_3 = 1;
#line 602
    return;
  } else {

  }
#line 604
  return;
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 609
  tmp = __VERIFIER_nondet_int();
#line 609
  irq_retval = (irqreturn_t )tmp;
#line 611
  if (state != 0) {
#line 612
    tmp___0 = __VERIFIER_nondet_int();
#line 612
    switch (tmp___0) {
    case 0: ;
#line 614
    if (state == 1) {
#line 615
      LDV_IN_INTERRUPT = 2;
#line 616
      irq_retval = be_intx(line, data);
#line 617
      LDV_IN_INTERRUPT = 1;
#line 618
      return (state);
    } else {

    }
#line 621
    goto ldv_59515;
    default: 
#line 622
    ldv_stop();
    }
    ldv_59515: ;
  } else {

  }
#line 625
  return (state);
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_pci_driver_6(void) 
{ 
  void *tmp ;

  {
#line 630
  tmp = ldv_init_zalloc(2976UL);
#line 630
  be_driver_group1 = (struct pci_dev *)tmp;
#line 631
  return;
}
}
#line 640
void ldv_main_exported_5(void) ;
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void main(void) 
{ 
  pm_message_t ldvarg1 ;
  int ldvarg0 ;
  struct pci_device_id *ldvarg2 ;
  void *tmp ;
  enum pci_channel_state ldvarg3 ;
  struct napi_struct *ldvarg18 ;
  void *tmp___0 ;
  u8 ldvarg11 ;
  __be16 ldvarg32 ;
  void *ldvarg7 ;
  void *tmp___1 ;
  struct sk_buff *ldvarg23 ;
  void *tmp___2 ;
  u16 ldvarg12 ;
  int ldvarg37 ;
  struct ifla_vf_info *ldvarg29 ;
  void *tmp___3 ;
  u32 ldvarg24 ;
  u16 ldvarg35 ;
  int ldvarg38 ;
  u8 *ldvarg5 ;
  void *tmp___4 ;
  u16 ldvarg33 ;
  int ldvarg6 ;
  struct sk_buff *ldvarg16 ;
  void *tmp___5 ;
  struct rtnl_link_stats64 *ldvarg4 ;
  void *tmp___6 ;
  __be16 ldvarg14 ;
  struct nlmsghdr *ldvarg34 ;
  void *tmp___7 ;
  int ldvarg28 ;
  int ldvarg39 ;
  bool ldvarg20 ;
  u16 ldvarg31 ;
  int ldvarg8 ;
  int ldvarg13 ;
  __be16 ldvarg36 ;
  sa_family_t ldvarg10 ;
  __be16 ldvarg9 ;
  u32 ldvarg26 ;
  int ldvarg27 ;
  sa_family_t ldvarg15 ;
  int ldvarg30 ;
  int ldvarg21 ;
  netdev_features_t ldvarg17 ;
  u32 ldvarg25 ;
  int ldvarg22 ;
  struct sk_buff *ldvarg19 ;
  void *tmp___8 ;
  char *ldvarg41 ;
  void *tmp___9 ;
  struct device_attribute *ldvarg42 ;
  void *tmp___10 ;
  struct device *ldvarg40 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 649
  tmp = ldv_init_zalloc(32UL);
#line 649
  ldvarg2 = (struct pci_device_id *)tmp;
#line 651
  tmp___0 = ldv_init_zalloc(280UL);
#line 651
  ldvarg18 = (struct napi_struct *)tmp___0;
#line 654
  tmp___1 = ldv_init_zalloc(1UL);
#line 654
  ldvarg7 = tmp___1;
#line 655
  tmp___2 = ldv_init_zalloc(232UL);
#line 655
  ldvarg23 = (struct sk_buff *)tmp___2;
#line 658
  tmp___3 = ldv_init_zalloc(64UL);
#line 658
  ldvarg29 = (struct ifla_vf_info *)tmp___3;
#line 662
  tmp___4 = ldv_init_zalloc(1UL);
#line 662
  ldvarg5 = (u8 *)tmp___4;
#line 665
  tmp___5 = ldv_init_zalloc(232UL);
#line 665
  ldvarg16 = (struct sk_buff *)tmp___5;
#line 666
  tmp___6 = ldv_init_zalloc(184UL);
#line 666
  ldvarg4 = (struct rtnl_link_stats64 *)tmp___6;
#line 668
  tmp___7 = ldv_init_zalloc(16UL);
#line 668
  ldvarg34 = (struct nlmsghdr *)tmp___7;
#line 686
  tmp___8 = ldv_init_zalloc(232UL);
#line 686
  ldvarg19 = (struct sk_buff *)tmp___8;
#line 687
  tmp___9 = ldv_init_zalloc(1UL);
#line 687
  ldvarg41 = (char *)tmp___9;
#line 688
  tmp___10 = ldv_init_zalloc(48UL);
#line 688
  ldvarg42 = (struct device_attribute *)tmp___10;
#line 689
  tmp___11 = ldv_init_zalloc(1416UL);
#line 689
  ldvarg40 = (struct device *)tmp___11;
#line 645
  ldv_initialize();
#line 647
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 648
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 650
  ldv_memset((void *)(& ldvarg3), 0, 4UL);
#line 652
  ldv_memset((void *)(& ldvarg11), 0, 1UL);
#line 653
  ldv_memset((void *)(& ldvarg32), 0, 2UL);
#line 656
  ldv_memset((void *)(& ldvarg12), 0, 2UL);
#line 657
  ldv_memset((void *)(& ldvarg37), 0, 4UL);
#line 659
  ldv_memset((void *)(& ldvarg24), 0, 4UL);
#line 660
  ldv_memset((void *)(& ldvarg35), 0, 2UL);
#line 661
  ldv_memset((void *)(& ldvarg38), 0, 4UL);
#line 663
  ldv_memset((void *)(& ldvarg33), 0, 2UL);
#line 664
  ldv_memset((void *)(& ldvarg6), 0, 4UL);
#line 667
  ldv_memset((void *)(& ldvarg14), 0, 2UL);
#line 669
  ldv_memset((void *)(& ldvarg28), 0, 4UL);
#line 670
  ldv_memset((void *)(& ldvarg39), 0, 4UL);
#line 671
  ldv_memset((void *)(& ldvarg20), 0, 1UL);
#line 672
  ldv_memset((void *)(& ldvarg31), 0, 2UL);
#line 673
  ldv_memset((void *)(& ldvarg8), 0, 4UL);
#line 674
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 675
  ldv_memset((void *)(& ldvarg36), 0, 2UL);
#line 676
  ldv_memset((void *)(& ldvarg10), 0, 2UL);
#line 677
  ldv_memset((void *)(& ldvarg9), 0, 2UL);
#line 678
  ldv_memset((void *)(& ldvarg26), 0, 4UL);
#line 679
  ldv_memset((void *)(& ldvarg27), 0, 4UL);
#line 680
  ldv_memset((void *)(& ldvarg15), 0, 2UL);
#line 681
  ldv_memset((void *)(& ldvarg30), 0, 4UL);
#line 682
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
#line 683
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
#line 684
  ldv_memset((void *)(& ldvarg25), 0, 4UL);
#line 685
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
#line 691
  ldv_state_variable_6 = 0;
#line 693
  work_init_3();
#line 695
  ldv_state_variable_3 = 1;
#line 696
  ldv_state_variable_7 = 0;
#line 697
  ldv_state_variable_9 = 0;
#line 699
  ldv_state_variable_2 = 1;
#line 700
  ldv_state_variable_8 = 0;
#line 702
  ldv_state_variable_1 = 1;
#line 704
  work_init_4();
#line 706
  ldv_state_variable_4 = 1;
#line 707
  ref_cnt = 0;
#line 708
  ldv_state_variable_0 = 1;
#line 709
  ldv_state_variable_5 = 0;
  ldv_59643: 
#line 711
  tmp___12 = __VERIFIER_nondet_int();
#line 711
  switch (tmp___12) {
  case 0: ;
#line 715
  if (ldv_state_variable_6 != 0) {
#line 716
    tmp___13 = __VERIFIER_nondet_int();
#line 716
    switch (tmp___13) {
    case 0: ;
#line 719
    if (ldv_state_variable_6 == 1) {
#line 721
      ldv_retval_4 = be_probe(be_driver_group1, (struct pci_device_id  const  *)ldvarg2);
#line 722
      if (ldv_retval_4 == 0) {
#line 723
        ldv_state_variable_6 = 2;
#line 724
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 728
    goto ldv_59580;
    case 1: ;
#line 731
    if (ldv_state_variable_6 == 2 && pci_counter == 0) {
#line 733
      ldv_retval_3 = be_suspend(be_driver_group1, ldvarg1);
#line 734
      if (ldv_retval_3 == 0) {
#line 735
        ldv_state_variable_6 = 3;
      } else {

      }
    } else {

    }
#line 739
    goto ldv_59580;
    case 2: ;
#line 742
    if (ldv_state_variable_6 == 4) {
#line 744
      ldv_retval_2 = be_pci_resume(be_driver_group1);
#line 745
      if (ldv_retval_2 == 0) {
#line 746
        ldv_state_variable_6 = 2;
      } else {

      }
    } else {

    }
#line 750
    if (ldv_state_variable_6 == 3) {
#line 752
      ldv_retval_2 = be_pci_resume(be_driver_group1);
#line 753
      if (ldv_retval_2 == 0) {
#line 754
        ldv_state_variable_6 = 2;
      } else {

      }
    } else {

    }
#line 758
    if (ldv_state_variable_6 == 5) {
#line 760
      ldv_retval_2 = be_pci_resume(be_driver_group1);
#line 761
      if (ldv_retval_2 == 0) {
#line 762
        ldv_state_variable_6 = 2;
      } else {

      }
    } else {

    }
#line 766
    goto ldv_59580;
    case 3: ;
#line 769
    if (ldv_state_variable_6 == 4) {
#line 771
      be_shutdown(be_driver_group1);
#line 772
      ldv_state_variable_6 = 4;
    } else {

    }
#line 775
    if (ldv_state_variable_6 == 3) {
#line 777
      be_shutdown(be_driver_group1);
#line 778
      ldv_state_variable_6 = 3;
    } else {

    }
#line 781
    if (ldv_state_variable_6 == 2) {
#line 783
      be_shutdown(be_driver_group1);
#line 784
      ldv_state_variable_6 = 2;
    } else {

    }
#line 787
    if (ldv_state_variable_6 == 5) {
#line 789
      be_shutdown(be_driver_group1);
#line 790
      ldv_state_variable_6 = 5;
    } else {

    }
#line 793
    goto ldv_59580;
    case 4: ;
#line 796
    if (ldv_state_variable_6 == 4) {
#line 798
      be_pci_sriov_configure(be_driver_group1, ldvarg0);
#line 800
      ldv_state_variable_6 = 4;
    } else {

    }
#line 803
    if (ldv_state_variable_6 == 1) {
#line 805
      be_pci_sriov_configure(be_driver_group1, ldvarg0);
#line 807
      ldv_state_variable_6 = 1;
    } else {

    }
#line 810
    if (ldv_state_variable_6 == 3) {
#line 812
      be_pci_sriov_configure(be_driver_group1, ldvarg0);
#line 814
      ldv_state_variable_6 = 3;
    } else {

    }
#line 817
    if (ldv_state_variable_6 == 2) {
#line 819
      be_pci_sriov_configure(be_driver_group1, ldvarg0);
#line 821
      ldv_state_variable_6 = 2;
    } else {

    }
#line 824
    if (ldv_state_variable_6 == 5) {
#line 826
      be_pci_sriov_configure(be_driver_group1, ldvarg0);
#line 828
      ldv_state_variable_6 = 5;
    } else {

    }
#line 831
    goto ldv_59580;
    case 5: ;
#line 834
    if (ldv_state_variable_6 == 4) {
#line 836
      be_remove(be_driver_group1);
#line 837
      ldv_state_variable_6 = 1;
    } else {

    }
#line 840
    if (ldv_state_variable_6 == 3) {
#line 842
      be_remove(be_driver_group1);
#line 843
      ldv_state_variable_6 = 1;
    } else {

    }
#line 846
    if (ldv_state_variable_6 == 2) {
#line 848
      be_remove(be_driver_group1);
#line 849
      ldv_state_variable_6 = 1;
    } else {

    }
#line 852
    if (ldv_state_variable_6 == 5) {
#line 854
      be_remove(be_driver_group1);
#line 855
      ldv_state_variable_6 = 1;
    } else {

    }
#line 858
    goto ldv_59580;
    case 6: ;
#line 861
    if (ldv_state_variable_6 == 3) {
#line 863
      ldv_retval_1 = ldv_suspend_late_6();
#line 864
      if (ldv_retval_1 == 0) {
#line 865
        ldv_state_variable_6 = 4;
      } else {

      }
    } else {

    }
#line 869
    goto ldv_59580;
    case 7: ;
#line 872
    if (ldv_state_variable_6 == 4) {
#line 874
      ldv_retval_0 = ldv_resume_early_6();
#line 875
      if (ldv_retval_0 == 0) {
#line 876
        ldv_state_variable_6 = 5;
      } else {

      }
    } else {

    }
#line 880
    if (ldv_state_variable_6 == 3) {
#line 882
      ldv_retval_0 = ldv_resume_early_6();
#line 883
      if (ldv_retval_0 == 0) {
#line 884
        ldv_state_variable_6 = 5;
      } else {

      }
    } else {

    }
#line 888
    goto ldv_59580;
    default: 
#line 889
    ldv_stop();
    }
    ldv_59580: ;
  } else {

  }
#line 893
  goto ldv_59589;
  case 1: ;
#line 897
  if (ldv_state_variable_3 != 0) {
#line 898
    invoke_work_3();
  } else {

  }
#line 901
  goto ldv_59589;
  case 2: ;
#line 905
  if (ldv_state_variable_7 != 0) {
#line 906
    tmp___14 = __VERIFIER_nondet_int();
#line 906
    switch (tmp___14) {
    case 0: ;
#line 909
    if (ldv_state_variable_7 == 3) {
#line 911
      be_eeh_resume(be_eeh_handlers_group0);
#line 913
      ldv_state_variable_7 = 2;
    } else {

    }
#line 916
    goto ldv_59593;
    case 1: ;
#line 919
    if (ldv_state_variable_7 == 1) {
#line 921
      be_eeh_reset(be_eeh_handlers_group0);
#line 923
      ldv_state_variable_7 = 1;
    } else {

    }
#line 926
    if (ldv_state_variable_7 == 3) {
#line 928
      be_eeh_reset(be_eeh_handlers_group0);
#line 930
      ldv_state_variable_7 = 3;
    } else {

    }
#line 933
    if (ldv_state_variable_7 == 2) {
#line 935
      be_eeh_reset(be_eeh_handlers_group0);
#line 937
      ldv_state_variable_7 = 2;
    } else {

    }
#line 940
    goto ldv_59593;
    case 2: ;
#line 943
    if (ldv_state_variable_7 == 1) {
#line 945
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg3);
#line 947
      ldv_state_variable_7 = 1;
    } else {

    }
#line 950
    if (ldv_state_variable_7 == 3) {
#line 952
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg3);
#line 954
      ldv_state_variable_7 = 3;
    } else {

    }
#line 957
    if (ldv_state_variable_7 == 2) {
#line 959
      be_eeh_err_detected(be_eeh_handlers_group0, (pci_channel_state_t )ldvarg3);
#line 961
      ldv_state_variable_7 = 2;
    } else {

    }
#line 964
    goto ldv_59593;
    case 3: ;
#line 967
    if (ldv_state_variable_7 == 2) {
#line 969
      ldv_suspend_7();
#line 971
      ldv_state_variable_7 = 3;
    } else {

    }
#line 974
    goto ldv_59593;
    case 4: ;
#line 977
    if (ldv_state_variable_7 == 3) {
#line 979
      ldv_release_7();
#line 981
      ldv_state_variable_7 = 1;
#line 982
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 985
    if (ldv_state_variable_7 == 2) {
#line 987
      ldv_release_7();
#line 989
      ldv_state_variable_7 = 1;
#line 990
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 993
    goto ldv_59593;
    case 5: ;
#line 996
    if (ldv_state_variable_7 == 1) {
#line 998
      ldv_probe_7();
#line 1000
      ldv_state_variable_7 = 2;
#line 1001
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1004
    goto ldv_59593;
    default: 
#line 1005
    ldv_stop();
    }
    ldv_59593: ;
  } else {

  }
#line 1009
  goto ldv_59589;
  case 3: ;
#line 1013
  if (ldv_state_variable_9 != 0) {
#line 1014
    tmp___15 = __VERIFIER_nondet_int();
#line 1014
    switch (tmp___15) {
    case 0: ;
#line 1017
    if (ldv_state_variable_9 == 1) {
#line 1019
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg39, ldvarg38, ldvarg37);
#line 1021
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1024
    if (ldv_state_variable_9 == 3) {
#line 1026
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg39, ldvarg38, ldvarg37);
#line 1028
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1031
    if (ldv_state_variable_9 == 2) {
#line 1033
      be_set_vf_tx_rate(be_netdev_ops_group1, ldvarg39, ldvarg38, ldvarg37);
#line 1035
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1038
    goto ldv_59602;
    case 1: ;
#line 1041
    if (ldv_state_variable_9 == 1) {
#line 1043
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg36, (int )ldvarg35);
#line 1045
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1048
    if (ldv_state_variable_9 == 3) {
#line 1050
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg36, (int )ldvarg35);
#line 1052
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1055
    if (ldv_state_variable_9 == 2) {
#line 1057
      be_vlan_rem_vid(be_netdev_ops_group1, (int )ldvarg36, (int )ldvarg35);
#line 1059
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1062
    goto ldv_59602;
    case 2: ;
#line 1065
    if (ldv_state_variable_9 == 1) {
#line 1067
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg34, (int )ldvarg33);
#line 1069
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1072
    if (ldv_state_variable_9 == 3) {
#line 1074
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg34, (int )ldvarg33);
#line 1076
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1079
    if (ldv_state_variable_9 == 2) {
#line 1081
      be_ndo_bridge_setlink(be_netdev_ops_group1, ldvarg34, (int )ldvarg33);
#line 1083
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1086
    goto ldv_59602;
    case 3: ;
#line 1089
    if (ldv_state_variable_9 == 1) {
#line 1091
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg32, (int )ldvarg31);
#line 1093
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1096
    if (ldv_state_variable_9 == 3) {
#line 1098
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg32, (int )ldvarg31);
#line 1100
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1103
    if (ldv_state_variable_9 == 2) {
#line 1105
      be_vlan_add_vid(be_netdev_ops_group1, (int )ldvarg32, (int )ldvarg31);
#line 1107
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1110
    goto ldv_59602;
    case 4: ;
#line 1113
    if (ldv_state_variable_9 == 1) {
#line 1115
      be_get_vf_config(be_netdev_ops_group1, ldvarg30, ldvarg29);
#line 1117
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1120
    if (ldv_state_variable_9 == 3) {
#line 1122
      be_get_vf_config(be_netdev_ops_group1, ldvarg30, ldvarg29);
#line 1124
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1127
    if (ldv_state_variable_9 == 2) {
#line 1129
      be_get_vf_config(be_netdev_ops_group1, ldvarg30, ldvarg29);
#line 1131
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1134
    goto ldv_59602;
    case 5: ;
#line 1137
    if (ldv_state_variable_9 == 1) {
#line 1139
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg28, ldvarg27);
#line 1141
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1144
    if (ldv_state_variable_9 == 3) {
#line 1146
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg28, ldvarg27);
#line 1148
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1151
    if (ldv_state_variable_9 == 2) {
#line 1153
      be_set_vf_link_state(be_netdev_ops_group1, ldvarg28, ldvarg27);
#line 1155
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1158
    goto ldv_59602;
    case 6: ;
#line 1161
    if (ldv_state_variable_9 == 1) {
#line 1163
      be_ndo_bridge_getlink(ldvarg23, ldvarg25, ldvarg24, be_netdev_ops_group1, ldvarg26,
                            ldvarg22);
#line 1165
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1168
    if (ldv_state_variable_9 == 3) {
#line 1170
      be_ndo_bridge_getlink(ldvarg23, ldvarg25, ldvarg24, be_netdev_ops_group1, ldvarg26,
                            ldvarg22);
#line 1172
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1175
    if (ldv_state_variable_9 == 2) {
#line 1177
      be_ndo_bridge_getlink(ldvarg23, ldvarg25, ldvarg24, be_netdev_ops_group1, ldvarg26,
                            ldvarg22);
#line 1179
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1182
    goto ldv_59602;
    case 7: ;
#line 1185
    if (ldv_state_variable_9 == 2) {
#line 1187
      ldv_retval_6 = be_open(be_netdev_ops_group1);
#line 1188
      if (ldv_retval_6 == 0) {
#line 1189
        ldv_state_variable_9 = 3;
      } else {

      }
    } else {

    }
#line 1193
    goto ldv_59602;
    case 8: ;
#line 1196
    if (ldv_state_variable_9 == 1) {
#line 1198
      be_set_vf_spoofchk(be_netdev_ops_group1, ldvarg21, (int )ldvarg20);
#line 1200
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1203
    if (ldv_state_variable_9 == 3) {
#line 1205
      be_set_vf_spoofchk(be_netdev_ops_group1, ldvarg21, (int )ldvarg20);
#line 1207
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1210
    if (ldv_state_variable_9 == 2) {
#line 1212
      be_set_vf_spoofchk(be_netdev_ops_group1, ldvarg21, (int )ldvarg20);
#line 1214
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1217
    goto ldv_59602;
    case 9: ;
#line 1220
    if (ldv_state_variable_9 == 3) {
#line 1222
      be_xmit(ldvarg19, be_netdev_ops_group1);
#line 1224
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1227
    goto ldv_59602;
    case 10: ;
#line 1230
    if (ldv_state_variable_9 == 3) {
#line 1232
      be_close(be_netdev_ops_group1);
#line 1233
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1236
    goto ldv_59602;
    case 11: ;
#line 1239
    if (ldv_state_variable_9 == 1) {
#line 1241
      be_set_rx_mode(be_netdev_ops_group1);
#line 1243
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1246
    if (ldv_state_variable_9 == 3) {
#line 1248
      be_set_rx_mode(be_netdev_ops_group1);
#line 1250
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1253
    if (ldv_state_variable_9 == 2) {
#line 1255
      be_set_rx_mode(be_netdev_ops_group1);
#line 1257
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1260
    goto ldv_59602;
    case 12: ;
#line 1263
    if (ldv_state_variable_9 == 1) {
#line 1265
      eth_validate_addr(be_netdev_ops_group1);
#line 1267
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1270
    if (ldv_state_variable_9 == 3) {
#line 1272
      eth_validate_addr(be_netdev_ops_group1);
#line 1274
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1277
    if (ldv_state_variable_9 == 2) {
#line 1279
      eth_validate_addr(be_netdev_ops_group1);
#line 1281
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1284
    goto ldv_59602;
    case 13: ;
#line 1287
    if (ldv_state_variable_9 == 1) {
#line 1289
      be_busy_poll(ldvarg18);
#line 1291
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1294
    if (ldv_state_variable_9 == 3) {
#line 1296
      be_busy_poll(ldvarg18);
#line 1298
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1301
    if (ldv_state_variable_9 == 2) {
#line 1303
      be_busy_poll(ldvarg18);
#line 1305
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1308
    goto ldv_59602;
    case 14: ;
#line 1311
    if (ldv_state_variable_9 == 1) {
#line 1313
      be_features_check(ldvarg16, be_netdev_ops_group1, ldvarg17);
#line 1315
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1318
    if (ldv_state_variable_9 == 3) {
#line 1320
      be_features_check(ldvarg16, be_netdev_ops_group1, ldvarg17);
#line 1322
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1325
    if (ldv_state_variable_9 == 2) {
#line 1327
      be_features_check(ldvarg16, be_netdev_ops_group1, ldvarg17);
#line 1329
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1332
    goto ldv_59602;
    case 15: ;
#line 1335
    if (ldv_state_variable_9 == 1) {
#line 1337
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg15, (int )ldvarg14);
#line 1339
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1342
    if (ldv_state_variable_9 == 3) {
#line 1344
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg15, (int )ldvarg14);
#line 1346
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1349
    if (ldv_state_variable_9 == 2) {
#line 1351
      be_del_vxlan_port(be_netdev_ops_group1, (int )ldvarg15, (int )ldvarg14);
#line 1353
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1356
    goto ldv_59602;
    case 16: ;
#line 1359
    if (ldv_state_variable_9 == 1) {
#line 1361
      be_netpoll(be_netdev_ops_group1);
#line 1363
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1366
    if (ldv_state_variable_9 == 3) {
#line 1368
      be_netpoll(be_netdev_ops_group1);
#line 1370
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1373
    if (ldv_state_variable_9 == 2) {
#line 1375
      be_netpoll(be_netdev_ops_group1);
#line 1377
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1380
    goto ldv_59602;
    case 17: ;
#line 1383
    if (ldv_state_variable_9 == 1) {
#line 1385
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg13, (int )ldvarg12, (int )ldvarg11);
#line 1387
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1390
    if (ldv_state_variable_9 == 3) {
#line 1392
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg13, (int )ldvarg12, (int )ldvarg11);
#line 1394
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1397
    if (ldv_state_variable_9 == 2) {
#line 1399
      be_set_vf_vlan(be_netdev_ops_group1, ldvarg13, (int )ldvarg12, (int )ldvarg11);
#line 1401
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1404
    goto ldv_59602;
    case 18: ;
#line 1407
    if (ldv_state_variable_9 == 1) {
#line 1409
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg10, (int )ldvarg9);
#line 1411
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1414
    if (ldv_state_variable_9 == 3) {
#line 1416
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg10, (int )ldvarg9);
#line 1418
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1421
    if (ldv_state_variable_9 == 2) {
#line 1423
      be_add_vxlan_port(be_netdev_ops_group1, (int )ldvarg10, (int )ldvarg9);
#line 1425
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1428
    goto ldv_59602;
    case 19: ;
#line 1431
    if (ldv_state_variable_9 == 3) {
#line 1433
      be_change_mtu(be_netdev_ops_group1, ldvarg8);
#line 1435
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1438
    if (ldv_state_variable_9 == 2) {
#line 1440
      be_change_mtu(be_netdev_ops_group1, ldvarg8);
#line 1442
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1445
    goto ldv_59602;
    case 20: ;
#line 1448
    if (ldv_state_variable_9 == 1) {
#line 1450
      be_mac_addr_set(be_netdev_ops_group1, ldvarg7);
#line 1452
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1455
    if (ldv_state_variable_9 == 3) {
#line 1457
      be_mac_addr_set(be_netdev_ops_group1, ldvarg7);
#line 1459
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1462
    if (ldv_state_variable_9 == 2) {
#line 1464
      be_mac_addr_set(be_netdev_ops_group1, ldvarg7);
#line 1466
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1469
    goto ldv_59602;
    case 21: ;
#line 1472
    if (ldv_state_variable_9 == 1) {
#line 1474
      be_set_vf_mac(be_netdev_ops_group1, ldvarg6, ldvarg5);
#line 1476
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1479
    if (ldv_state_variable_9 == 3) {
#line 1481
      be_set_vf_mac(be_netdev_ops_group1, ldvarg6, ldvarg5);
#line 1483
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1486
    if (ldv_state_variable_9 == 2) {
#line 1488
      be_set_vf_mac(be_netdev_ops_group1, ldvarg6, ldvarg5);
#line 1490
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1493
    goto ldv_59602;
    case 22: ;
#line 1496
    if (ldv_state_variable_9 == 1) {
#line 1498
      be_get_stats64(be_netdev_ops_group1, ldvarg4);
#line 1500
      ldv_state_variable_9 = 1;
    } else {

    }
#line 1503
    if (ldv_state_variable_9 == 3) {
#line 1505
      be_get_stats64(be_netdev_ops_group1, ldvarg4);
#line 1507
      ldv_state_variable_9 = 3;
    } else {

    }
#line 1510
    if (ldv_state_variable_9 == 2) {
#line 1512
      be_get_stats64(be_netdev_ops_group1, ldvarg4);
#line 1514
      ldv_state_variable_9 = 2;
    } else {

    }
#line 1517
    goto ldv_59602;
    case 23: ;
#line 1520
    if (ldv_state_variable_9 == 1) {
#line 1522
      ldv_retval_5 = ldv_ndo_init_9();
#line 1523
      if (ldv_retval_5 == 0) {
#line 1524
        ldv_state_variable_9 = 2;
#line 1525
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1529
    goto ldv_59602;
    case 24: ;
#line 1532
    if (ldv_state_variable_9 == 2) {
#line 1534
      ldv_ndo_uninit_9();
#line 1535
      ldv_state_variable_9 = 1;
#line 1536
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1539
    goto ldv_59602;
    default: 
#line 1540
    ldv_stop();
    }
    ldv_59602: ;
  } else {

  }
#line 1544
  goto ldv_59589;
  case 4: ;
#line 1548
  if (ldv_state_variable_2 != 0) {
#line 1549
    choose_interrupt_2();
  } else {

  }
#line 1552
  goto ldv_59589;
  case 5: ;
#line 1556
  if (ldv_state_variable_8 != 0) {
#line 1557
    tmp___16 = __VERIFIER_nondet_int();
#line 1557
    switch (tmp___16) {
    case 0: ;
#line 1560
    if (ldv_state_variable_8 == 1) {
#line 1562
      be_hwmon_show_temp(ldvarg40, ldvarg42, ldvarg41);
#line 1564
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1567
    goto ldv_59631;
    default: 
#line 1568
    ldv_stop();
    }
    ldv_59631: ;
  } else {

  }
#line 1572
  goto ldv_59589;
  case 6: ;
#line 1576
  if (ldv_state_variable_1 != 0) {
#line 1577
    choose_interrupt_1();
  } else {

  }
#line 1580
  goto ldv_59589;
  case 7: ;
#line 1584
  if (ldv_state_variable_4 != 0) {
#line 1585
    invoke_work_4();
  } else {

  }
#line 1588
  goto ldv_59589;
  case 8: ;
#line 1592
  if (ldv_state_variable_0 != 0) {
#line 1593
    tmp___17 = __VERIFIER_nondet_int();
#line 1593
    switch (tmp___17) {
    case 0: ;
#line 1596
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 1598
      be_exit_module();
#line 1599
      ldv_state_variable_0 = 3;
#line 1600
      goto ldv_final;
    } else {

    }
#line 1603
    goto ldv_59638;
    case 1: ;
#line 1606
    if (ldv_state_variable_0 == 1) {
#line 1608
      ldv_retval_7 = be_init_module();
#line 1609
      if (ldv_retval_7 != 0) {
#line 1610
        ldv_state_variable_0 = 3;
#line 1611
        goto ldv_final;
      } else {

      }
#line 1614
      if (ldv_retval_7 == 0) {
#line 1615
        ldv_state_variable_0 = 2;
#line 1616
        ldv_state_variable_5 = 1;
#line 1617
        ldv_initialize_ethtool_ops_5();
#line 1618
        ldv_state_variable_7 = 1;
#line 1619
        ldv_initialize_pci_error_handlers_7();
#line 1620
        ldv_state_variable_8 = 1;
      } else {

      }
    } else {

    }
#line 1624
    goto ldv_59638;
    default: 
#line 1625
    ldv_stop();
    }
    ldv_59638: ;
  } else {

  }
#line 1629
  goto ldv_59589;
  case 9: ;
#line 1633
  if (ldv_state_variable_5 != 0) {
#line 1634
    ldv_main_exported_5();
  } else {

  }
#line 1637
  goto ldv_59589;
  default: 
#line 1638
  ldv_stop();
  }
  ldv_59589: ;
#line 1640
  goto ldv_59643;
  ldv_final: 
#line 1642
  ldv_check_final_state();
#line 1643
  return;
}
}
#line 1670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1674
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1674
  ldv_func_res = tmp;
#line 1676
  activate_work_3(ldv_func_arg3, 2);
#line 1678
  return (ldv_func_res);
}
}
#line 1681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1685
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1685
  ldv_func_res = tmp;
#line 1687
  activate_work_3(& ldv_func_arg3->work, 2);
#line 1689
  return (ldv_func_res);
}
}
#line 1692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1696
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1696
  ldv_func_res = tmp;
#line 1698
  activate_work_3(ldv_func_arg3, 2);
#line 1700
  return (ldv_func_res);
}
}
#line 1703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1706
  flush_workqueue(ldv_func_arg1);
#line 1708
  call_and_disable_all_3(2);
#line 1709
  return;
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1715
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1715
  ldv_func_res = tmp;
#line 1717
  activate_work_3(& ldv_func_arg3->work, 2);
#line 1719
  return (ldv_func_res);
}
}
#line 1722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int ldv_request_irq_10(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1726
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1726
  ldv_func_res = tmp;
#line 1728
  tmp___0 = reg_check_2(handler);
#line 1728
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 1729
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 1732
  return (ldv_func_res);
}
}
#line 1735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_11(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1738
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1740
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 1741
  return;
}
}
#line 1743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
__inline static int ldv_request_irq_12(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1747
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1747
  ldv_func_res = tmp;
#line 1749
  tmp___0 = reg_check_2(handler);
#line 1749
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 1750
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 1753
  return (ldv_func_res);
}
}
#line 1756 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_13(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1759
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1761
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 1762
  return;
}
}
#line 1764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_irq_14(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1767
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1769
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 1770
  return;
}
}
#line 1772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_cancel_delayed_work_sync_15(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 1776
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 1776
  ldv_func_res = tmp;
#line 1778
  disable_work_3(& ldv_func_arg1->work);
#line 1780
  return (ldv_func_res);
}
}
#line 1783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_cancel_delayed_work_sync_16(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 1787
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 1787
  ldv_func_res = tmp;
#line 1789
  disable_work_3(& ldv_func_arg1->work);
#line 1791
  return (ldv_func_res);
}
}
#line 1794 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_unregister_netdev_17(struct net_device *dev ) 
{ 


  {
#line 1797
  unregister_netdev(dev);
#line 1799
  ldv_state_variable_9 = 0;
#line 1800
  return;
}
}
#line 1802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_netdev_18(struct net_device *dev ) 
{ 


  {
#line 1805
  free_netdev(dev);
#line 1807
  ldv_state_variable_9 = 0;
#line 1808
  return;
}
}
#line 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv_register_netdev_19(struct net_device *dev ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 1814
  tmp = register_netdev(dev);
#line 1814
  ldv_func_res = tmp;
#line 1816
  ldv_state_variable_9 = 1;
#line 1817
  ldv_net_device_ops_9();
#line 1820
  return (ldv_func_res);
}
}
#line 1823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_free_netdev_20(struct net_device *dev ) 
{ 


  {
#line 1826
  free_netdev(dev);
#line 1828
  ldv_state_variable_9 = 0;
#line 1829
  return;
}
}
#line 1831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
bool ldv_cancel_delayed_work_sync_21(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 1835
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 1835
  ldv_func_res = tmp;
#line 1837
  disable_work_3(& ldv_func_arg1->work);
#line 1839
  return (ldv_func_res);
}
}
#line 1842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
int ldv___pci_register_driver_22(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 1846
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1846
  ldv_func_res = tmp;
#line 1848
  ldv_state_variable_6 = 1;
#line 1849
  ldv_pci_driver_6();
#line 1852
  return (ldv_func_res);
}
}
#line 1855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_main.o.c.prepared"
void ldv_pci_unregister_driver_23(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 1858
  pci_unregister_driver(ldv_func_arg1);
#line 1860
  ldv_state_variable_6 = 0;
#line 1861
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 65 "./arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 141 "include/linux/mutex.h"
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 91 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_48(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_50(struct workqueue_struct *ldv_func_arg1 ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) ;
#line 128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO___0(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 130
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 130
  if (tmp != 0L) {
#line 130
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (130), "i" (12UL));
    ldv_54975: ;
#line 130
    goto ldv_54975;
  } else {

  }
#line 131
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc___0(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 141
  tmp = MODULO___0((int )((unsigned int )*index + 1U), (int )limit);
#line 141
  *index = (u16 )tmp;
#line 142
  return;
}
}
#line 159 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 161
  index_inc___0(& q->head, (int )q->len);
#line 162
  return;
}
}
#line 164 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_dec(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 166
  tmp = MODULO___0((int )((unsigned int )*index + 65535U), (int )limit);
#line 166
  *index = (u16 )tmp;
#line 167
  return;
}
}
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 171
  index_inc___0(& q->tail, (int )q->len);
#line 172
  return;
}
}
#line 2261 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) ;
#line 2300
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) ;
#line 2302
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) ;
#line 2304
int be_cmd_read_port_transceiver_data(struct be_adapter *adapter , u8 page_num , u8 *data ) ;
#line 2306
int be_cmd_query_cable_type(struct be_adapter *adapter ) ;
#line 2315
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) ;
#line 2318
int lancer_cmd_delete_object(struct be_adapter *adapter , char const   *obj_name ) ;
#line 2327
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) ;
#line 2330
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) ;
#line 2332
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2334
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) ;
#line 2343
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) ;
#line 2344
int be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) ;
#line 2349
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) ;
#line 2355
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) ;
#line 2363
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) ;
#line 2365
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) ;
#line 2367
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) ;
#line 2371
int lancer_initiate_dump(struct be_adapter *adapter ) ;
#line 2372
int lancer_delete_dump(struct be_adapter *adapter ) ;
#line 2373
bool dump_present(struct be_adapter *adapter ) ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static char *be_port_misconfig_evt_desc[5U]  = {      (char *)"A valid SFP module detected",      (char *)"Optics faulted/ incorrectly installed/ not installed.",      (char *)"Optics of two types installed.",      (char *)"Incompatible optics.", 
        (char *)"Unknown port SFP status"};
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static char *be_port_misconfig_remedy_desc[5U]  = {      (char *)"",      (char *)"Reseat optics. If issue not resolved, replace",      (char *)"Remove one optic or install matching pair of optics",      (char *)"Replace with compatible optics for card to function", 
        (char *)""};
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_cmd_priv_map cmd_priv_map[5U]  = {      {12U, 3U, 1800U}, 
        {37U, 1U, 1794U}, 
        {36U, 1U, 1800U}, 
        {18U, 3U, 1800U}, 
        {102U, 1U, 1800U}};
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool be_cmd_allowed(struct be_adapter *adapter , u8 opcode , u8 subsystem ) 
{ 
  int i ;
  int num_entries ;
  u32 cmd_privileges ;

  {
#line 74
  num_entries = 5;
#line 75
  cmd_privileges = adapter->cmd_privileges;
#line 77
  i = 0;
#line 77
  goto ldv_57164;
  ldv_57163: ;
#line 78
  if ((int )cmd_priv_map[i].opcode == (int )opcode && (int )cmd_priv_map[i].subsystem == (int )subsystem) {
#line 80
    if ((cmd_priv_map[i].priv_mask & cmd_privileges) == 0U) {
#line 81
      return (0);
    } else {

    }
  } else {

  }
#line 77
  i = i + 1;
  ldv_57164: ;
#line 77
  if (i < num_entries) {
#line 79
    goto ldv_57163;
  } else {

  }

#line 83
  return (1);
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 88
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_mcc_notify(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;
  u8 tmp ;

  {
#line 93
  mccq = & adapter->mcc_obj.q;
#line 94
  val = 0U;
#line 96
  tmp = be_check_error(adapter, 7U);
#line 96
  if ((unsigned int )tmp != 0U) {
#line 97
    return;
  } else {

  }
#line 99
  val = ((u32 )mccq->id & 2047U) | val;
#line 100
  val = val | 65536U;
#line 102
  __asm__  volatile   ("sfence": : : "memory");
#line 103
  iowrite32(val, (void *)adapter->db + 320U);
#line 104
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  u32 flags ;

  {
#line 113
  if (compl->flags != 0U) {
#line 114
    flags = compl->flags;
#line 115
    if ((int )flags < 0) {
#line 116
      compl->flags = flags;
#line 117
      return (1);
    } else {

    }
  } else {

  }
#line 120
  return (0);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 126
  compl->flags = 0U;
#line 127
  return;
}
}
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0 , u32 tag1 ) 
{ 
  unsigned long addr ;

  {
#line 133
  addr = (unsigned long )tag1;
#line 134
  addr = (addr << 32UL) | (unsigned long )tag0;
#line 135
  return ((struct be_cmd_resp_hdr *)addr);
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool be_skip_err_log(u8 opcode , u16 base_status , u16 addl_status ) 
{ 


  {
#line 140
  if (((((unsigned int )base_status == 66U || (unsigned int )base_status == 2U) || (unsigned int )addl_status == 74U) || (unsigned int )addl_status == 171U) || ((unsigned int )opcode == 7U && ((unsigned int )base_status == 3U || (unsigned int )addl_status == 77U))) {
#line 147
    return (1);
  } else {
#line 149
    return (0);
  }
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_cmd_process(struct be_adapter *adapter , struct be_mcc_compl *compl ,
                                 struct be_cmd_resp_hdr *resp_hdr ) 
{ 
  enum mcc_base_status base_status ;
  u8 opcode ;
  u8 subsystem ;
  struct be_cmd_resp_get_cntl_addnl_attribs *resp ;

  {
#line 159
  base_status = compl->status != 0U ? (enum mcc_base_status )(compl->status & 65535U) : 0;
#line 160
  opcode = 0U;
#line 160
  subsystem = 0U;
#line 162
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 163
    opcode = resp_hdr->opcode;
#line 164
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 167
  if ((unsigned int )opcode == 18U && (unsigned int )subsystem == 11U) {
#line 169
    complete(& adapter->et_cmd_compl);
#line 170
    return;
  } else {

  }
#line 173
  if (((unsigned int )opcode == 7U || (unsigned int )opcode == 172U) && (unsigned int )subsystem == 1U) {
#line 176
    adapter->flash_status = compl->status;
#line 177
    complete(& adapter->et_cmd_compl);
#line 178
    return;
  } else {

  }
#line 181
  if ((((unsigned int )opcode == 4U || (unsigned int )opcode == 18U) && (unsigned int )subsystem == 3U) && (unsigned int )base_status == 0U) {
#line 185
    be_parse_stats(adapter);
#line 186
    adapter->stats_cmd_sent = 0;
#line 187
    return;
  } else {

  }
#line 190
  if ((unsigned int )opcode == 121U && (unsigned int )subsystem == 1U) {
#line 192
    if ((unsigned int )base_status == 0U) {
#line 193
      resp = (struct be_cmd_resp_get_cntl_addnl_attribs *)resp_hdr;
#line 195
      adapter->hwmon_info.be_on_die_temp = resp->on_die_temperature;
    } else {
#line 198
      adapter->be_get_temp_freq = 0;
#line 199
      adapter->hwmon_info.be_on_die_temp = 255U;
    }
#line 202
    return;
  } else {

  }
#line 204
  return;
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_compl_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  enum mcc_base_status base_status ;
  enum mcc_addl_status addl_status ;
  struct be_cmd_resp_hdr *resp_hdr ;
  u8 opcode ;
  u8 subsystem ;
  bool tmp ;
  int tmp___0 ;

  {
#line 212
  opcode = 0U;
#line 212
  subsystem = 0U;
#line 216
  swap_dws((void *)compl, 4);
#line 218
  base_status = compl->status != 0U ? (enum mcc_base_status )(compl->status & 65535U) : 0;
#line 219
  addl_status = compl->status != 0U ? (enum mcc_addl_status )((compl->status >> 16) & 255U) : 0;
#line 221
  resp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);
#line 222
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 223
    opcode = resp_hdr->opcode;
#line 224
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 227
  be_async_cmd_process(adapter, compl, resp_hdr);
#line 229
  if ((unsigned int )base_status != 0U) {
#line 229
    tmp = be_skip_err_log((int )opcode, (int )((u16 )base_status), (int )((u16 )addl_status));
#line 229
    if (tmp) {
#line 229
      tmp___0 = 0;
    } else {
#line 229
      tmp___0 = 1;
    }
#line 229
    if (tmp___0) {
#line 231
      if ((unsigned int )base_status == 5U) {
#line 232
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF is not privileged to issue opcode %d-%d\n",
                 (int )opcode, (int )subsystem);
      } else {
#line 236
        dev_err((struct device  const  *)(& (adapter->pdev)->dev), "opcode %d-%d failed:status %d-%d\n",
                (int )opcode, (int )subsystem, (unsigned int )base_status, (unsigned int )addl_status);
      }
    } else {

    }
  } else {

  }
#line 241
  return ((int )compl->status);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_link_state_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_link_state *evt ;

  {
#line 248
  evt = (struct be_async_event_link_state *)compl;
#line 252
  adapter->phy.link_speed = -1;
#line 259
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && ((int )evt->port_link_status & 2) == 0) {
#line 261
    return;
  } else {

  }
#line 266
  if (((unsigned long )adapter->flags & 2UL) != 0UL) {
#line 267
    be_link_status_update(adapter, (int )evt->port_link_status & 1);
  } else {

  }
#line 269
  return;
}
}
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_port_misconfig_event_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_misconfig_port *evt ;
  u32 sfp_mismatch_evt ;
  struct device *dev ;
  u8 port_misconfig_evt ;

  {
#line 274
  evt = (struct be_async_event_misconfig_port *)compl;
#line 276
  sfp_mismatch_evt = evt->event_data_word1;
#line 277
  dev = & (adapter->pdev)->dev;
#line 280
  port_misconfig_evt = (u8 )(sfp_mismatch_evt >> (int )adapter->hba_port_num * 8);
#line 286
  _dev_info((struct device  const  *)dev, "Port %c: %s %s", (int )adapter->port_name,
            be_port_misconfig_evt_desc[(int )port_misconfig_evt], be_port_misconfig_remedy_desc[(int )port_misconfig_evt]);
#line 290
  if ((unsigned int )port_misconfig_evt == 3U) {
#line 291
    adapter->flags = adapter->flags | 1024U;
  } else {

  }
#line 292
  return;
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_cos_priority_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_cos_priority *evt ;

  {
#line 298
  evt = (struct be_async_event_grp5_cos_priority *)compl;
#line 301
  if ((unsigned int )evt->valid != 0U) {
#line 302
    adapter->vlan_prio_bmap = evt->available_priority_bmap;
#line 303
    adapter->recommended_prio = (unsigned int )adapter->recommended_prio & 8191U;
#line 304
    adapter->recommended_prio = (int )((u16 )evt->reco_default_priority) << 13U;
  } else {

  }
#line 307
  return;
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_qos_speed_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_qos_link_speed *evt ;

  {
#line 313
  evt = (struct be_async_event_grp5_qos_link_speed *)compl;
#line 316
  if (adapter->phy.link_speed >= 0 && (u32 )evt->physical_port == adapter->port_num) {
#line 318
    adapter->phy.link_speed = (int )evt->qos_link_speed * 10;
  } else {

  }
#line 319
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_pvid_state_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_event_grp5_pvid_state *evt ;

  {
#line 325
  evt = (struct be_async_event_grp5_pvid_state *)compl;
#line 328
  if ((unsigned int )evt->enabled != 0U) {
#line 329
    adapter->pvid = (unsigned int )evt->tag & 4095U;
#line 330
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "LPVID: %d\n", (int )adapter->pvid);
  } else {
#line 332
    adapter->pvid = 0U;
  }
#line 333
  return;
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_fw_control_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  struct be_async_fw_control *evt ;
  u32 evt_dw1 ;

  {
#line 340
  evt = (struct be_async_fw_control *)compl;
#line 341
  evt_dw1 = evt->event_data_word1;
#line 343
  if ((evt_dw1 & 4U) != 0U) {
#line 344
    adapter->flags = adapter->flags | 4096U;
#line 345
    adapter->bmc_filt_mask = evt->event_data_word2;
  } else {
#line 347
    adapter->flags = adapter->flags & 4294963199U;
  }
#line 348
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_evt_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  u8 event_type ;

  {
#line 354
  event_type = (u8 )(compl->flags >> 16);
#line 357
  switch ((int )event_type) {
  case 2: 
#line 359
  be_async_grp5_cos_priority_process(adapter, compl);
#line 360
  goto ldv_57249;
  case 1: 
#line 362
  be_async_grp5_qos_speed_process(adapter, compl);
#line 363
  goto ldv_57249;
  case 3: 
#line 365
  be_async_grp5_pvid_state_process(adapter, compl);
#line 366
  goto ldv_57249;
  case 5: 
#line 369
  be_async_grp5_fw_control_process(adapter, compl);
#line 370
  goto ldv_57249;
  default: ;
#line 372
  goto ldv_57249;
  }
  ldv_57249: ;
#line 375
  return;
}
}
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_dbg_evt_process(struct be_adapter *adapter , struct be_mcc_compl *cmp ) 
{ 
  u8 event_type ;
  struct be_async_event_qnq *evt ;

  {
#line 379
  event_type = 0U;
#line 380
  evt = (struct be_async_event_qnq *)cmp;
#line 382
  event_type = (u8 )(cmp->flags >> 16);
#line 385
  switch ((int )event_type) {
  case 1: ;
#line 387
  if ((unsigned int )evt->valid != 0U) {
#line 388
    adapter->qnq_vid = evt->vlan_tag;
  } else {

  }
#line 389
  adapter->flags = adapter->flags | 128U;
#line 390
  goto ldv_57261;
  default: 
#line 392
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown debug event 0x%x!\n",
           (int )event_type);
#line 394
  goto ldv_57261;
  }
  ldv_57261: ;
#line 397
  return;
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_sliport_evt_process(struct be_adapter *adapter , struct be_mcc_compl *cmp ) 
{ 
  u8 event_type ;

  {
#line 401
  event_type = (u8 )(cmp->flags >> 16);
#line 404
  if ((unsigned int )event_type == 9U) {
#line 405
    be_async_port_misconfig_event_process(adapter, cmp);
  } else {

  }
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_link_state_evt(u32 flags ) 
{ 


  {
#line 410
  return (((flags >> 8) & 255U) == 1U);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_grp5_evt(u32 flags ) 
{ 


  {
#line 416
  return (((flags >> 8) & 255U) == 5U);
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_dbg_evt(u32 flags ) 
{ 


  {
#line 422
  return (((flags >> 8) & 255U) == 6U);
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_sliport_evt(u32 flags ) 
{ 


  {
#line 428
  return (((flags >> 8) & 255U) == 17U);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_mcc_event_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 435
  tmp___2 = is_link_state_evt(compl->flags);
#line 435
  if ((int )tmp___2) {
#line 436
    be_async_link_state_process(adapter, compl);
  } else {
#line 437
    tmp___1 = is_grp5_evt(compl->flags);
#line 437
    if ((int )tmp___1) {
#line 438
      be_async_grp5_evt_process(adapter, compl);
    } else {
#line 439
      tmp___0 = is_dbg_evt(compl->flags);
#line 439
      if ((int )tmp___0) {
#line 440
        be_async_dbg_evt_process(adapter, compl);
      } else {
#line 441
        tmp = is_sliport_evt(compl->flags);
#line 441
        if ((int )tmp) {
#line 442
          be_async_sliport_evt_process(adapter, compl);
        } else {

        }
      }
    }
  }
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 447
  mcc_cq = & adapter->mcc_obj.cq;
#line 448
  tmp = queue_tail_node(mcc_cq);
#line 448
  compl = (struct be_mcc_compl *)tmp;
#line 450
  tmp___0 = be_mcc_compl_is_new(compl);
#line 450
  if ((int )tmp___0) {
#line 451
    queue_tail_inc___0(mcc_cq);
#line 452
    return (compl);
  } else {

  }
#line 454
  return ((struct be_mcc_compl *)0);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
void be_async_mcc_enable(struct be_adapter *adapter ) 
{ 


  {
#line 459
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 461
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 1, 0);
#line 462
  adapter->mcc_obj.rearm_cq = 1;
#line 464
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
void be_async_mcc_disable(struct be_adapter *adapter ) 
{ 


  {
#line 469
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 471
  adapter->mcc_obj.rearm_cq = 0;
#line 472
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 0, 0);
#line 474
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_process_mcc(struct be_adapter *adapter ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_mcc_obj *mcc_obj ;

  {
#line 480
  num = 0;
#line 480
  status = 0;
#line 481
  mcc_obj = & adapter->mcc_obj;
#line 483
  spin_lock(& adapter->mcc_cq_lock);
#line 485
  goto ldv_57303;
  ldv_57302: ;
#line 486
  if (((unsigned long )compl->flags & 1073741824UL) != 0UL) {
#line 487
    be_mcc_event_process(adapter, compl);
  } else
#line 488
  if (((unsigned long )compl->flags & 268435456UL) != 0UL) {
#line 489
    status = be_mcc_compl_process(adapter, compl);
#line 490
    atomic_dec(& mcc_obj->q.used);
  } else {

  }
#line 492
  be_mcc_compl_use(compl);
#line 493
  num = num + 1;
  ldv_57303: 
#line 485
  compl = be_mcc_compl_get(adapter);
#line 485
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 487
    goto ldv_57302;
  } else {

  }

#line 496
  if (num != 0) {
#line 497
    be_cq_notify(adapter, (int )mcc_obj->cq.id, (int )mcc_obj->rearm_cq, (int )((u16 )num));
  } else {

  }
#line 499
  spin_unlock(& adapter->mcc_cq_lock);
#line 500
  return (status);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_wait_compl(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 507
  status = 0;
#line 508
  mcc_obj = & adapter->mcc_obj;
#line 510
  i = 0;
#line 510
  goto ldv_57313;
  ldv_57312: 
#line 511
  tmp = be_check_error(adapter, 7U);
#line 511
  if ((unsigned int )tmp != 0U) {
#line 512
    return (-5);
  } else {

  }
#line 514
  local_bh_disable();
#line 515
  status = be_process_mcc(adapter);
#line 516
  local_bh_enable();
#line 518
  tmp___0 = atomic_read((atomic_t const   *)(& mcc_obj->q.used));
#line 518
  if (tmp___0 == 0) {
#line 519
    goto ldv_57311;
  } else {

  }
#line 520
  __const_udelay(429500UL);
#line 510
  i = i + 1;
  ldv_57313: ;
#line 510
  if (i <= 119999) {
#line 512
    goto ldv_57312;
  } else {

  }
  ldv_57311: ;
#line 522
  if (i == 120000) {
#line 523
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 524
    be_set_error(adapter, 4);
#line 525
    return (-5);
  } else {

  }
#line 527
  return (status);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_obj *mcc_obj ;
  u16 index ;
  struct be_cmd_resp_hdr *resp ;
  void *tmp ;

  {
#line 535
  mcc_obj = & adapter->mcc_obj;
#line 536
  index = mcc_obj->q.head;
#line 539
  index_dec(& index, (int )mcc_obj->q.len);
#line 540
  tmp = queue_index_node(& mcc_obj->q, (int )index);
#line 540
  wrb = (struct be_mcc_wrb *)tmp;
#line 542
  resp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);
#line 544
  be_mcc_notify(adapter);
#line 546
  status = be_mcc_wait_compl(adapter);
#line 547
  if (status == -5) {
#line 548
    goto out;
  } else {

  }
#line 550
  status = (int )resp->base_status | ((int )resp->addl_status << 16);
  out: ;
#line 554
  return (status);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mbox_db_ready_wait(struct be_adapter *adapter , void *db ) 
{ 
  int msecs ;
  u32 ready ;
  u8 tmp ;

  {
#line 559
  msecs = 0;
  ldv_57330: 
#line 563
  tmp = be_check_error(adapter, 7U);
#line 563
  if ((unsigned int )tmp != 0U) {
#line 564
    return (-5);
  } else {

  }
#line 566
  ready = ioread32(db);
#line 567
  if (ready == 4294967295U) {
#line 568
    return (-1);
  } else {

  }
#line 570
  ready = ready & 1U;
#line 571
  if (ready != 0U) {
#line 572
    goto ldv_57329;
  } else {

  }
#line 574
  if (msecs > 4000) {
#line 575
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 576
    be_set_error(adapter, 4);
#line 577
    be_detect_error(adapter);
#line 578
    return (-1);
  } else {

  }
#line 581
  msleep(1U);
#line 582
  msecs = msecs + 1;
#line 583
  goto ldv_57330;
  ldv_57329: ;
#line 585
  return (0);
}
}
#line 592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mbox_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  bool tmp ;

  {
#line 595
  val = 0U;
#line 596
  db = (void *)adapter->db + 352U;
#line 597
  mbox_mem = & adapter->mbox_mem;
#line 598
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 599
  compl = & mbox->compl;
#line 602
  status = be_mbox_db_ready_wait(adapter, db);
#line 603
  if (status != 0) {
#line 604
    return (status);
  } else {

  }
#line 606
  val = val | 2U;
#line 608
  val = ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U) | val;
#line 609
  iowrite32(val, db);
#line 612
  status = be_mbox_db_ready_wait(adapter, db);
#line 613
  if (status != 0) {
#line 614
    return (status);
  } else {

  }
#line 616
  val = 0U;
#line 618
  val = ((unsigned int )(mbox_mem->dma >> 4) << 2) | val;
#line 619
  iowrite32(val, db);
#line 621
  status = be_mbox_db_ready_wait(adapter, db);
#line 622
  if (status != 0) {
#line 623
    return (status);
  } else {

  }
#line 626
  tmp = be_mcc_compl_is_new(compl);
#line 626
  if ((int )tmp) {
#line 627
    status = be_mcc_compl_process(adapter, & mbox->compl);
#line 628
    be_mcc_compl_use(compl);
#line 629
    if (status != 0) {
#line 630
      return (status);
    } else {

    }
  } else {
#line 632
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid mailbox completion\n");
#line 633
    return (-1);
  }
#line 635
  return (0);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static u16 be_POST_stage_get(struct be_adapter *adapter ) 
{ 
  u32 sem ;

  {
#line 642
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 643
    sem = ioread32((void *)adapter->csr + 172U);
  } else {
#line 645
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 148, & sem);
  }
#line 648
  return ((u16 )sem);
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int lancer_wait_ready(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  int i ;

  {
#line 657
  i = 0;
#line 657
  goto ldv_57350;
  ldv_57349: 
#line 658
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 659
  if ((sliport_status & 8388608U) != 0U) {
#line 660
    return (0);
  } else {

  }
#line 662
  if ((int )sliport_status < 0 && (sliport_status & 16777216U) == 0U) {
#line 664
    return (-5);
  } else {

  }
#line 666
  msleep(1000U);
#line 657
  i = i + 1;
  ldv_57350: ;
#line 657
  if (i <= 29) {
#line 659
    goto ldv_57349;
  } else {

  }

#line 669
  return (sliport_status != 0U ? (int )sliport_status : -1);
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_fw_wait_ready(struct be_adapter *adapter ) 
{ 
  u16 stage ;
  int status ;
  int timeout ;
  struct device *dev ;
  unsigned long tmp ;

  {
#line 675
  timeout = 0;
#line 676
  dev = & (adapter->pdev)->dev;
#line 678
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 679
    status = lancer_wait_ready(adapter);
#line 680
    if (status != 0) {
#line 681
      stage = (u16 )status;
#line 682
      goto err;
    } else {

    }
#line 684
    return (0);
  } else {

  }
  ldv_57360: ;
#line 689
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) && (unsigned int )adapter->virtfn != 0U) {
#line 690
    return (0);
  } else {

  }
#line 692
  stage = be_POST_stage_get(adapter);
#line 693
  if ((unsigned int )stage == 49152U) {
#line 694
    return (0);
  } else {

  }
#line 696
  _dev_info((struct device  const  *)dev, "Waiting for POST, %ds elapsed\n", timeout);
#line 697
  tmp = msleep_interruptible(2000U);
#line 697
  if (tmp != 0UL) {
#line 698
    dev_err((struct device  const  *)dev, "Waiting for POST aborted\n");
#line 699
    return (-4);
  } else {

  }
#line 701
  timeout = timeout + 2;
#line 702
  if (timeout <= 59) {
#line 704
    goto ldv_57360;
  } else {

  }

  err: 
#line 705
  dev_err((struct device  const  *)dev, "POST timeout; stage=%#x\n", (int )stage);
#line 706
  return (-110);
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 711
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void fill_wrb_tags(struct be_mcc_wrb *wrb , unsigned long addr ) 
{ 


  {
#line 716
  wrb->tag0 = (u32 )addr;
#line 717
  wrb->tag1 = (unsigned int )(addr >> 32UL);
#line 718
  return;
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem ,
                                   u8 opcode , int cmd_len , struct be_mcc_wrb *wrb ,
                                   struct be_dma_mem *mem ) 
{ 
  struct be_sge *sge ;

  {
#line 729
  req_hdr->opcode = opcode;
#line 730
  req_hdr->subsystem = subsystem;
#line 731
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 732
  req_hdr->version = 0U;
#line 733
  fill_wrb_tags(wrb, (unsigned long )req_hdr);
#line 734
  wrb->payload_length = (u32 )cmd_len;
#line 735
  if ((unsigned long )mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 736
    wrb->embedded = wrb->embedded | 8U;
#line 738
    sge = nonembedded_sgl(wrb);
#line 739
    sge->pa_hi = (unsigned int )(mem->dma >> 32ULL);
#line 740
    sge->pa_lo = (unsigned int )mem->dma;
#line 741
    sge->len = mem->size;
  } else {
#line 743
    wrb->embedded = wrb->embedded | 1U;
  }
#line 744
  swap_dws((void *)wrb, 8);
#line 745
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  unsigned int _min1 ;
  u32 _min2 ;
  u64 dma ;

  {
#line 750
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 750
  _min2 = max_pages;
#line 750
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 751
  dma = mem->dma;
#line 753
  i = 0;
#line 753
  goto ldv_57390;
  ldv_57389: 
#line 754
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 755
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 756
  dma = dma + 4096ULL;
#line 753
  i = i + 1;
  ldv_57390: ;
#line 753
  if (i < buf_pages) {
#line 755
    goto ldv_57389;
  } else {

  }

#line 760
  return;
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_wrb *wrb ;

  {
#line 762
  mbox_mem = & adapter->mbox_mem;
#line 763
  wrb = & ((struct be_mcc_mailbox *)mbox_mem->va)->wrb;
#line 765
  memset((void *)wrb, 0, 256UL);
#line 766
  return (wrb);
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int tmp ;
  void *tmp___0 ;

  {
#line 771
  mccq = & adapter->mcc_obj.q;
#line 774
  if (! mccq->created) {
#line 775
    return ((struct be_mcc_wrb *)0);
  } else {

  }
#line 777
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
#line 777
  if (tmp >= (int )mccq->len) {
#line 778
    return ((struct be_mcc_wrb *)0);
  } else {

  }
#line 780
  tmp___0 = queue_head_node(mccq);
#line 780
  wrb = (struct be_mcc_wrb *)tmp___0;
#line 781
  queue_head_inc___0(mccq);
#line 782
  atomic_inc(& mccq->used);
#line 783
  memset((void *)wrb, 0, 256UL);
#line 784
  return (wrb);
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool use_mcc(struct be_adapter *adapter ) 
{ 


  {
#line 789
  return (adapter->mcc_obj.q.created);
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_lock(struct be_adapter *adapter ) 
{ 
  int tmp ;
  bool tmp___0 ;

  {
#line 795
  tmp___0 = use_mcc(adapter);
#line 795
  if ((int )tmp___0) {
#line 796
    spin_lock_bh(& adapter->mcc_lock);
#line 797
    return (0);
  } else {
#line 799
    tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 799
    return (tmp);
  }
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_cmd_unlock(struct be_adapter *adapter ) 
{ 
  bool tmp ;

  {
#line 806
  tmp = use_mcc(adapter);
#line 806
  if ((int )tmp) {
#line 807
    spin_unlock_bh(& adapter->mcc_lock);
  } else {
#line 809
    return;
  }
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  bool tmp ;
  void *tmp___0 ;

  {
#line 817
  tmp = use_mcc(adapter);
#line 817
  if ((int )tmp) {
#line 818
    dest_wrb = wrb_from_mccq(adapter);
#line 819
    if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 820
      return ((struct be_mcc_wrb *)0);
    } else {

    }
  } else {
#line 822
    dest_wrb = wrb_from_mbox(adapter);
  }
#line 825
  memcpy((void *)dest_wrb, (void const   *)wrb, 256UL);
#line 826
  if ((int )wrb->embedded & 1) {
#line 827
    tmp___0 = embedded_payload(wrb);
#line 827
    fill_wrb_tags(dest_wrb, (unsigned long )tmp___0);
  } else {

  }
#line 829
  return (dest_wrb);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_notify_wait(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  int status ;
  bool tmp ;

  {
#line 839
  status = be_cmd_lock(adapter);
#line 840
  if (status != 0) {
#line 841
    return (status);
  } else {

  }
#line 843
  dest_wrb = be_cmd_copy(adapter, wrb);
#line 844
  if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 845
    return (-16);
  } else {

  }
#line 847
  tmp = use_mcc(adapter);
#line 847
  if ((int )tmp) {
#line 848
    status = be_mcc_notify_wait(adapter);
  } else {
#line 850
    status = be_mbox_notify_wait(adapter);
  }
#line 852
  if (status == 0) {
#line 853
    memcpy((void *)wrb, (void const   *)dest_wrb, 256UL);
  } else {

  }
#line 855
  be_cmd_unlock(adapter);
#line 856
  return (status);
}
}
#line 862 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_fw_init(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 867
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 868
    return (0);
  } else {

  }
#line 870
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 870
  if (tmp != 0) {
#line 871
    return (-1);
  } else {

  }
#line 873
  tmp___0 = wrb_from_mbox(adapter);
#line 873
  wrb = (u8 *)tmp___0;
#line 874
  tmp___1 = wrb;
#line 874
  wrb = wrb + 1;
#line 874
  *tmp___1 = 255U;
#line 875
  tmp___2 = wrb;
#line 875
  wrb = wrb + 1;
#line 875
  *tmp___2 = 18U;
#line 876
  tmp___3 = wrb;
#line 876
  wrb = wrb + 1;
#line 876
  *tmp___3 = 52U;
#line 877
  tmp___4 = wrb;
#line 877
  wrb = wrb + 1;
#line 877
  *tmp___4 = 255U;
#line 878
  tmp___5 = wrb;
#line 878
  wrb = wrb + 1;
#line 878
  *tmp___5 = 255U;
#line 879
  tmp___6 = wrb;
#line 879
  wrb = wrb + 1;
#line 879
  *tmp___6 = 86U;
#line 880
  tmp___7 = wrb;
#line 880
  wrb = wrb + 1;
#line 880
  *tmp___7 = 120U;
#line 881
  *wrb = 255U;
#line 883
  status = be_mbox_notify_wait(adapter);
#line 885
  mutex_unlock(& adapter->mbox_lock);
#line 886
  return (status);
}
}
#line 892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_fw_clean(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 897
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 898
    return (0);
  } else {

  }
#line 900
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 900
  if (tmp != 0) {
#line 901
    return (-1);
  } else {

  }
#line 903
  tmp___0 = wrb_from_mbox(adapter);
#line 903
  wrb = (u8 *)tmp___0;
#line 904
  tmp___1 = wrb;
#line 904
  wrb = wrb + 1;
#line 904
  *tmp___1 = 255U;
#line 905
  tmp___2 = wrb;
#line 905
  wrb = wrb + 1;
#line 905
  *tmp___2 = 170U;
#line 906
  tmp___3 = wrb;
#line 906
  wrb = wrb + 1;
#line 906
  *tmp___3 = 187U;
#line 907
  tmp___4 = wrb;
#line 907
  wrb = wrb + 1;
#line 907
  *tmp___4 = 255U;
#line 908
  tmp___5 = wrb;
#line 908
  wrb = wrb + 1;
#line 908
  *tmp___5 = 255U;
#line 909
  tmp___6 = wrb;
#line 909
  wrb = wrb + 1;
#line 909
  *tmp___6 = 204U;
#line 910
  tmp___7 = wrb;
#line 910
  wrb = wrb + 1;
#line 910
  *tmp___7 = 221U;
#line 911
  *wrb = 255U;
#line 913
  status = be_mbox_notify_wait(adapter);
#line 915
  mutex_unlock(& adapter->mbox_lock);
#line 916
  return (status);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eq_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___5 ;

  {
#line 923
  q_mem = & eqo->q.dma_mem;
#line 924
  ver = 0;
#line 926
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 926
  if (tmp != 0) {
#line 927
    return (-1);
  } else {

  }
#line 929
  wrb = wrb_from_mbox(adapter);
#line 930
  tmp___0 = embedded_payload(wrb);
#line 930
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 932
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 13, 100, wrb, (struct be_dma_mem *)0);
#line 937
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 938
    ver = 2;
  } else {

  }
#line 940
  req->hdr.version = (u8 )ver;
#line 941
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 943
  tmp___1 = amap_mask(1U);
#line 943
  amap_set((void *)(& req->context), 0U, tmp___1, 29U, 1U);
#line 945
  tmp___2 = amap_mask(1U);
#line 945
  amap_set((void *)(& req->context), 0U, tmp___2, 31U, 0U);
#line 946
  tmp___3 = __ilog2_u32((unsigned int )eqo->q.len / 256U);
#line 946
  tmp___4 = amap_mask(3U);
#line 946
  amap_set((void *)(& req->context), 1U, tmp___4, 26U, (u32 )tmp___3);
#line 948
  swap_dws((void *)(& req->context), 16);
#line 950
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 952
  status = be_mbox_notify_wait(adapter);
#line 953
  if (status == 0) {
#line 954
    tmp___5 = embedded_payload(wrb);
#line 954
    resp = (struct be_cmd_resp_eq_create *)tmp___5;
#line 956
    eqo->q.id = resp->eq_id;
#line 957
    eqo->msix_idx = ver == 2 ? (u8 )resp->msix_idx : eqo->idx;
#line 959
    eqo->q.created = 1;
  } else {

  }
#line 962
  mutex_unlock(& adapter->mbox_lock);
#line 963
  return (status);
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mac_query *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_mac_query *resp ;
  void *tmp___0 ;

  {
#line 974
  spin_lock_bh(& adapter->mcc_lock);
#line 976
  wrb = wrb_from_mccq(adapter);
#line 977
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 978
    status = -16;
#line 979
    goto err;
  } else {

  }
#line 981
  tmp = embedded_payload(wrb);
#line 981
  req = (struct be_cmd_req_mac_query *)tmp;
#line 983
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 1, 24, wrb, (struct be_dma_mem *)0);
#line 986
  req->type = 1U;
#line 987
  if ((int )permanent) {
#line 988
    req->permanent = 1U;
  } else {
#line 990
    req->if_id = (unsigned short )if_handle;
#line 991
    req->pmac_id = pmac_id;
#line 992
    req->permanent = 0U;
  }
#line 995
  status = be_mcc_notify_wait(adapter);
#line 996
  if (status == 0) {
#line 997
    tmp___0 = embedded_payload(wrb);
#line 997
    resp = (struct be_cmd_resp_mac_query *)tmp___0;
#line 999
    memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr), 6UL);
  } else {

  }
  err: 
#line 1003
  spin_unlock_bh(& adapter->mcc_lock);
#line 1004
  return (status);
}
}
#line 1008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_add *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_pmac_add *resp ;
  void *tmp___0 ;

  {
#line 1015
  spin_lock_bh(& adapter->mcc_lock);
#line 1017
  wrb = wrb_from_mccq(adapter);
#line 1018
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1019
    status = -16;
#line 1020
    goto err;
  } else {

  }
#line 1022
  tmp = embedded_payload(wrb);
#line 1022
  req = (struct be_cmd_req_pmac_add *)tmp;
#line 1024
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 59, 28, wrb, (struct be_dma_mem *)0);
#line 1028
  req->hdr.domain = (u8 )domain;
#line 1029
  req->if_id = if_id;
#line 1030
  memcpy((void *)(& req->mac_address), (void const   *)mac_addr, 6UL);
#line 1032
  status = be_mcc_notify_wait(adapter);
#line 1033
  if (status == 0) {
#line 1034
    tmp___0 = embedded_payload(wrb);
#line 1034
    resp = (struct be_cmd_resp_pmac_add *)tmp___0;
#line 1036
    *pmac_id = resp->pmac_id;
  } else {

  }
  err: 
#line 1040
  spin_unlock_bh(& adapter->mcc_lock);
#line 1042
  if (status == 5) {
#line 1043
    status = -1;
  } else {

  }
#line 1045
  return (status);
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_del *req ;
  int status ;
  void *tmp ;

  {
#line 1055
  if (pmac_id == -1) {
#line 1056
    return (0);
  } else {

  }
#line 1058
  spin_lock_bh(& adapter->mcc_lock);
#line 1060
  wrb = wrb_from_mccq(adapter);
#line 1061
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1062
    status = -16;
#line 1063
    goto err;
  } else {

  }
#line 1065
  tmp = embedded_payload(wrb);
#line 1065
  req = (struct be_cmd_req_pmac_del *)tmp;
#line 1067
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 60, 24, wrb, (struct be_dma_mem *)0);
#line 1071
  req->hdr.domain = (u8 )dom;
#line 1072
  req->if_id = if_id;
#line 1073
  req->pmac_id = (unsigned int )pmac_id;
#line 1075
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1078
  spin_unlock_bh(& adapter->mcc_lock);
#line 1079
  return (status);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cq_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  int tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___15 ;

  {
#line 1088
  q_mem = & cq->dma_mem;
#line 1092
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1092
  if (tmp != 0) {
#line 1093
    return (-1);
  } else {

  }
#line 1095
  wrb = wrb_from_mbox(adapter);
#line 1096
  tmp___0 = embedded_payload(wrb);
#line 1096
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 1097
  ctxt = (void *)(& req->context);
#line 1099
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 12, 100, wrb, (struct be_dma_mem *)0);
#line 1103
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1105
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1106
    tmp___1 = amap_mask(2U);
#line 1106
    amap_set(ctxt, 0U, tmp___1, 12U, (u32 )coalesce_wm);
#line 1108
    tmp___2 = amap_mask(1U);
#line 1108
    amap_set(ctxt, 0U, tmp___2, 14U, (u32 )no_delay);
#line 1110
    tmp___3 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1110
    tmp___4 = amap_mask(2U);
#line 1110
    amap_set(ctxt, 0U, tmp___4, 27U, (u32 )tmp___3);
#line 1112
    tmp___5 = amap_mask(1U);
#line 1112
    amap_set(ctxt, 0U, tmp___5, 29U, 1U);
#line 1113
    tmp___6 = amap_mask(1U);
#line 1113
    amap_set(ctxt, 0U, tmp___6, 31U, 1U);
#line 1114
    tmp___7 = amap_mask(8U);
#line 1114
    amap_set(ctxt, 1U, tmp___7, 22U, (u32 )eq->id);
  } else {
#line 1116
    req->hdr.version = 2U;
#line 1117
    req->page_size = 1U;
#line 1122
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 1123
      tmp___8 = amap_mask(2U);
#line 1123
      amap_set(ctxt, 0U, tmp___8, 12U, (u32 )coalesce_wm);
    } else {

    }
#line 1125
    tmp___9 = amap_mask(1U);
#line 1125
    amap_set(ctxt, 0U, tmp___9, 14U, (u32 )no_delay);
#line 1127
    tmp___10 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1127
    tmp___11 = amap_mask(2U);
#line 1127
    amap_set(ctxt, 0U, tmp___11, 27U, (u32 )tmp___10);
#line 1129
    tmp___12 = amap_mask(1U);
#line 1129
    amap_set(ctxt, 0U, tmp___12, 29U, 1U);
#line 1130
    tmp___13 = amap_mask(1U);
#line 1130
    amap_set(ctxt, 0U, tmp___13, 31U, 1U);
#line 1131
    tmp___14 = amap_mask(16U);
#line 1131
    amap_set(ctxt, 1U, tmp___14, 0U, (u32 )eq->id);
  }
#line 1134
  swap_dws(ctxt, 16);
#line 1136
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1138
  status = be_mbox_notify_wait(adapter);
#line 1139
  if (status == 0) {
#line 1140
    tmp___15 = embedded_payload(wrb);
#line 1140
    resp = (struct be_cmd_resp_cq_create *)tmp___15;
#line 1142
    cq->id = resp->cq_id;
#line 1143
    cq->created = 1;
  } else {

  }
#line 1146
  mutex_unlock(& adapter->mbox_lock);
#line 1148
  return (status);
}
}
#line 1151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
#line 1153
  tmp = fls(q_len);
#line 1153
  len_encoded = (u32 )tmp;
#line 1155
  if (len_encoded == 16U) {
#line 1156
    len_encoded = 0U;
  } else {

  }
#line 1157
  return (len_encoded);
}
}
#line 1160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_mccq_ext_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_ext_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___10 ;

  {
#line 1166
  q_mem = & mccq->dma_mem;
#line 1170
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1170
  if (tmp != 0) {
#line 1171
    return (-1);
  } else {

  }
#line 1173
  wrb = wrb_from_mbox(adapter);
#line 1174
  tmp___0 = embedded_payload(wrb);
#line 1174
  req = (struct be_cmd_req_mcc_ext_create *)tmp___0;
#line 1175
  ctxt = (void *)(& req->context);
#line 1177
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 90, 104, wrb, (struct be_dma_mem *)0);
#line 1181
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1182
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1183
    tmp___1 = amap_mask(1U);
#line 1183
    amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1184
    tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1184
    tmp___3 = amap_mask(4U);
#line 1184
    amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1186
    tmp___4 = amap_mask(10U);
#line 1186
    amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
  } else {
#line 1188
    req->hdr.version = 1U;
#line 1189
    req->cq_id = cq->id;
#line 1191
    tmp___5 = be_encoded_q_len((int )mccq->len);
#line 1191
    tmp___6 = amap_mask(4U);
#line 1191
    amap_set(ctxt, 0U, tmp___6, 16U, tmp___5);
#line 1193
    tmp___7 = amap_mask(1U);
#line 1193
    amap_set(ctxt, 1U, tmp___7, 31U, 1U);
#line 1194
    tmp___8 = amap_mask(16U);
#line 1194
    amap_set(ctxt, 0U, tmp___8, 0U, (u32 )cq->id);
#line 1196
    tmp___9 = amap_mask(1U);
#line 1196
    amap_set(ctxt, 2U, tmp___9, 0U, 1U);
  }
#line 1203
  req->async_event_bitmap[0] = 131170U;
#line 1209
  swap_dws(ctxt, 16);
#line 1211
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1213
  status = be_mbox_notify_wait(adapter);
#line 1214
  if (status == 0) {
#line 1215
    tmp___10 = embedded_payload(wrb);
#line 1215
    resp = (struct be_cmd_resp_mcc_create *)tmp___10;
#line 1217
    mccq->id = resp->id;
#line 1218
    mccq->created = 1;
  } else {

  }
#line 1220
  mutex_unlock(& adapter->mbox_lock);
#line 1222
  return (status);
}
}
#line 1225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_mccq_org_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
#line 1231
  q_mem = & mccq->dma_mem;
#line 1235
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1235
  if (tmp != 0) {
#line 1236
    return (-1);
  } else {

  }
#line 1238
  wrb = wrb_from_mbox(adapter);
#line 1239
  tmp___0 = embedded_payload(wrb);
#line 1239
  req = (struct be_cmd_req_mcc_create *)tmp___0;
#line 1240
  ctxt = (void *)(& req->context);
#line 1242
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 21, 100, wrb, (struct be_dma_mem *)0);
#line 1246
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1248
  tmp___1 = amap_mask(1U);
#line 1248
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1249
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1249
  tmp___3 = amap_mask(4U);
#line 1249
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1251
  tmp___4 = amap_mask(10U);
#line 1251
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1253
  swap_dws(ctxt, 16);
#line 1255
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1257
  status = be_mbox_notify_wait(adapter);
#line 1258
  if (status == 0) {
#line 1259
    tmp___5 = embedded_payload(wrb);
#line 1259
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1261
    mccq->id = resp->id;
#line 1262
    mccq->created = 1;
  } else {

  }
#line 1265
  mutex_unlock(& adapter->mbox_lock);
#line 1266
  return (status);
}
}
#line 1269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) 
{ 
  int status ;

  {
#line 1274
  status = be_cmd_mccq_ext_create(adapter, mccq, cq);
#line 1275
  if (status != 0 && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1276
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Upgrade to F/W ver 2.102.235.0 or newer to avoid conflicting priorities between NIC and FCoE traffic");
#line 1279
    status = be_cmd_mccq_org_create(adapter, mccq, cq);
  } else {

  }
#line 1281
  return (status);
}
}
#line 1284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_eth_tx_create *req ;
  struct be_queue_info *txq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  void *tmp ;
  u32 tmp___0 ;
  struct be_cmd_resp_eth_tx_create *resp ;
  void *tmp___1 ;

  {
#line 1286
  wrb.embedded = 0U;
#line 1286
  wrb.payload_length = 0U;
#line 1286
  wrb.tag0 = 0U;
#line 1286
  wrb.tag1 = 0U;
#line 1286
  wrb.rsvd = 0U;
#line 1286
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1286
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1288
  txq = & txo->q;
#line 1289
  cq = & txo->cq;
#line 1290
  q_mem = & txq->dma_mem;
#line 1291
  ver = 0;
#line 1293
  tmp = embedded_payload(& wrb);
#line 1293
  req = (struct be_cmd_req_eth_tx_create *)tmp;
#line 1294
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 7, 148, & wrb, (struct be_dma_mem *)0);
#line 1297
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1298
    req->hdr.version = 1U;
  } else
#line 1299
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1300
    if ((adapter->function_caps & 64U) != 0U) {
#line 1301
      req->hdr.version = 2U;
    } else {

    }
  } else {
#line 1303
    req->hdr.version = 2U;
  }
#line 1306
  if ((unsigned int )req->hdr.version != 0U) {
#line 1307
    req->if_id = (unsigned short )adapter->if_handle;
  } else {

  }
#line 1308
  req->num_pages = (u8 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1309
  req->ulp_num = 1U;
#line 1310
  req->type = 2U;
#line 1311
  req->cq_id = cq->id;
#line 1312
  tmp___0 = be_encoded_q_len((int )txq->len);
#line 1312
  req->queue_size = (u8 )tmp___0;
#line 1313
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1314
  ver = (int )req->hdr.version;
#line 1316
  status = be_cmd_notify_wait(adapter, & wrb);
#line 1317
  if (status == 0) {
#line 1318
    tmp___1 = embedded_payload(& wrb);
#line 1318
    resp = (struct be_cmd_resp_eth_tx_create *)tmp___1;
#line 1320
    txq->id = resp->cid;
#line 1321
    if (ver == 2) {
#line 1322
      txo->db_offset = resp->db_offset;
    } else {
#line 1324
      txo->db_offset = 96U;
    }
#line 1325
    txq->created = 1;
  } else {

  }
#line 1328
  return (status);
}
}
#line 1332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eth_rx_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  void *tmp ;
  int tmp___0 ;
  struct be_cmd_resp_eth_rx_create *resp ;
  void *tmp___1 ;

  {
#line 1338
  q_mem = & rxq->dma_mem;
#line 1341
  spin_lock_bh(& adapter->mcc_lock);
#line 1343
  wrb = wrb_from_mccq(adapter);
#line 1344
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1345
    status = -16;
#line 1346
    goto err;
  } else {

  }
#line 1348
  tmp = embedded_payload(wrb);
#line 1348
  req = (struct be_cmd_req_eth_rx_create *)tmp;
#line 1350
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 8, 48, wrb, (struct be_dma_mem *)0);
#line 1353
  req->cq_id = cq_id;
#line 1354
  tmp___0 = fls((int )frag_size);
#line 1354
  req->frag_size = (unsigned int )((u8 )tmp___0) + 255U;
#line 1355
  req->num_pages = 2U;
#line 1356
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 2U, q_mem);
#line 1357
  req->interface_id = if_id;
#line 1358
  req->max_frame_size = 9018U;
#line 1359
  req->rss_queue = rss;
#line 1361
  status = be_mcc_notify_wait(adapter);
#line 1362
  if (status == 0) {
#line 1363
    tmp___1 = embedded_payload(wrb);
#line 1363
    resp = (struct be_cmd_resp_eth_rx_create *)tmp___1;
#line 1365
    rxq->id = resp->id;
#line 1366
    rxq->created = 1;
#line 1367
    *rss_id = resp->rss_id;
  } else {

  }
  err: 
#line 1371
  spin_unlock_bh(& adapter->mcc_lock);
#line 1372
  return (status);
}
}
#line 1378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1383
  subsys = 0U;
#line 1383
  opcode = 0U;
#line 1386
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 1386
  if (tmp != 0) {
#line 1387
    return (-1);
  } else {

  }
#line 1389
  wrb = wrb_from_mbox(adapter);
#line 1390
  tmp___0 = embedded_payload(wrb);
#line 1390
  req = (struct be_cmd_req_q_destroy *)tmp___0;
#line 1392
  switch (queue_type) {
  case 1: 
#line 1394
  subsys = 1U;
#line 1395
  opcode = 55U;
#line 1396
  goto ldv_57571;
  case 2: 
#line 1398
  subsys = 1U;
#line 1399
  opcode = 54U;
#line 1400
  goto ldv_57571;
  case 3: 
#line 1402
  subsys = 3U;
#line 1403
  opcode = 9U;
#line 1404
  goto ldv_57571;
  case 4: 
#line 1406
  subsys = 3U;
#line 1407
  opcode = 10U;
#line 1408
  goto ldv_57571;
  case 5: 
#line 1410
  subsys = 1U;
#line 1411
  opcode = 53U;
#line 1412
  goto ldv_57571;
  default: 
#line 1414
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"),
                       "i" (1414), "i" (12UL));
  ldv_57577: ;
#line 1414
  goto ldv_57577;
  }
  ldv_57571: 
#line 1417
  be_wrb_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20, wrb, (struct be_dma_mem *)0);
#line 1419
  req->id = q->id;
#line 1421
  status = be_mbox_notify_wait(adapter);
#line 1422
  q->created = 0;
#line 1424
  mutex_unlock(& adapter->mbox_lock);
#line 1425
  return (status);
}
}
#line 1429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1435
  spin_lock_bh(& adapter->mcc_lock);
#line 1437
  wrb = wrb_from_mccq(adapter);
#line 1438
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1439
    status = -16;
#line 1440
    goto err;
  } else {

  }
#line 1442
  tmp = embedded_payload(wrb);
#line 1442
  req = (struct be_cmd_req_q_destroy *)tmp;
#line 1444
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 10, 20, wrb, (struct be_dma_mem *)0);
#line 1446
  req->id = q->id;
#line 1448
  status = be_mcc_notify_wait(adapter);
#line 1449
  q->created = 0;
  err: 
#line 1452
  spin_unlock_bh(& adapter->mcc_lock);
#line 1453
  return (status);
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_if_create *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_if_create *resp ;
  void *tmp___0 ;

  {
#line 1462
  wrb.embedded = 0U;
#line 1462
  wrb.payload_length = 0U;
#line 1462
  wrb.tag0 = 0U;
#line 1462
  wrb.tag1 = 0U;
#line 1462
  wrb.rsvd = 0U;
#line 1462
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1462
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1466
  tmp = embedded_payload(& wrb);
#line 1466
  req = (struct be_cmd_req_if_create *)tmp;
#line 1467
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 50, 40, & wrb, (struct be_dma_mem *)0);
#line 1470
  req->hdr.domain = (u8 )domain;
#line 1471
  req->capability_flags = cap_flags;
#line 1472
  req->enable_flags = en_flags;
#line 1473
  req->pmac_invalid = 1U;
#line 1475
  status = be_cmd_notify_wait(adapter, & wrb);
#line 1476
  if (status == 0) {
#line 1477
    tmp___0 = embedded_payload(& wrb);
#line 1477
    resp = (struct be_cmd_resp_if_create *)tmp___0;
#line 1479
    *if_handle = resp->interface_id;
#line 1482
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )adapter->virtfn != 0U) {
#line 1483
      *(adapter->pmac_id) = resp->pmac_id;
    } else {

    }
  } else {

  }
#line 1485
  return (status);
}
}
#line 1489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_if_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1495
  if (interface_id == -1) {
#line 1496
    return (0);
  } else {

  }
#line 1498
  spin_lock_bh(& adapter->mcc_lock);
#line 1500
  wrb = wrb_from_mccq(adapter);
#line 1501
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1502
    status = -16;
#line 1503
    goto err;
  } else {

  }
#line 1505
  tmp = embedded_payload(wrb);
#line 1505
  req = (struct be_cmd_req_if_destroy *)tmp;
#line 1507
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 51, 20, wrb, (struct be_dma_mem *)0);
#line 1510
  req->hdr.domain = (u8 )domain;
#line 1511
  req->interface_id = (unsigned int )interface_id;
#line 1513
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1515
  spin_unlock_bh(& adapter->mcc_lock);
#line 1516
  return (status);
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  int status ;

  {
#line 1527
  status = 0;
#line 1529
  spin_lock_bh(& adapter->mcc_lock);
#line 1531
  wrb = wrb_from_mccq(adapter);
#line 1532
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1533
    status = -16;
#line 1534
    goto err;
  } else {

  }
#line 1536
  hdr = (struct be_cmd_req_hdr *)nonemb_cmd->va;
#line 1538
  be_wrb_cmd_hdr_prepare(hdr, 3, 4, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1543
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 1544
    hdr->version = 0U;
  } else {

  }
#line 1545
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 1546
    hdr->version = 1U;
  } else {
#line 1548
    hdr->version = 2U;
  }
#line 1550
  be_mcc_notify(adapter);
#line 1551
  adapter->stats_cmd_sent = 1;
  err: 
#line 1554
  spin_unlock_bh(& adapter->mcc_lock);
#line 1555
  return (status);
}
}
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_pport_stats *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1564
  status = 0;
#line 1566
  tmp = be_cmd_allowed(adapter, 18, 3);
#line 1566
  if (tmp) {
#line 1566
    tmp___0 = 0;
  } else {
#line 1566
    tmp___0 = 1;
  }
#line 1566
  if (tmp___0) {
#line 1568
    return (-1);
  } else {

  }
#line 1570
  spin_lock_bh(& adapter->mcc_lock);
#line 1572
  wrb = wrb_from_mccq(adapter);
#line 1573
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1574
    status = -16;
#line 1575
    goto err;
  } else {

  }
#line 1577
  req = (struct lancer_cmd_req_pport_stats *)nonemb_cmd->va;
#line 1579
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 18, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1583
  req->cmd_params.params.pport_num = (unsigned short )adapter->hba_port_num;
#line 1584
  req->cmd_params.params.reset_stats = 0U;
#line 1586
  be_mcc_notify(adapter);
#line 1587
  adapter->stats_cmd_sent = 1;
  err: 
#line 1590
  spin_unlock_bh(& adapter->mcc_lock);
#line 1591
  return (status);
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mac_to_link_speed(int mac_speed ) 
{ 


  {
#line 1596
  switch (mac_speed) {
  case 0: ;
#line 1598
  return (0);
  case 1: ;
#line 1600
  return (10);
  case 2: ;
#line 1602
  return (100);
  case 3: ;
#line 1604
  return (1000);
  case 4: ;
#line 1606
  return (10000);
  case 5: ;
#line 1608
  return (20000);
  case 6: ;
#line 1610
  return (25000);
  case 7: ;
#line 1612
  return (40000);
  }
#line 1614
  return (0);
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_link_status *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_link_status *resp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1627
  spin_lock_bh(& adapter->mcc_lock);
#line 1629
  if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1630
    *link_status = 0U;
  } else {

  }
#line 1632
  wrb = wrb_from_mccq(adapter);
#line 1633
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1634
    status = -16;
#line 1635
    goto err;
  } else {

  }
#line 1637
  tmp = embedded_payload(wrb);
#line 1637
  req = (struct be_cmd_req_link_status *)tmp;
#line 1639
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 5, 20, wrb, (struct be_dma_mem *)0);
#line 1644
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 1645
    req->hdr.version = 1U;
  } else {

  }
#line 1647
  req->hdr.domain = (u8 )dom;
#line 1649
  status = be_mcc_notify_wait(adapter);
#line 1650
  if (status == 0) {
#line 1651
    tmp___0 = embedded_payload(wrb);
#line 1651
    resp = (struct be_cmd_resp_link_status *)tmp___0;
#line 1653
    if ((unsigned long )link_speed != (unsigned long )((u16 *)0U)) {
#line 1654
      if ((unsigned int )resp->link_speed != 0U) {
#line 1654
        *link_speed = (unsigned int )resp->link_speed * 10U;
      } else {
#line 1654
        tmp___1 = be_mac_to_link_speed((int )resp->mac_speed);
#line 1654
        *link_speed = (u16 )tmp___1;
      }
#line 1658
      if ((unsigned int )resp->logical_link_status == 0U) {
#line 1659
        *link_speed = 0U;
      } else {

      }
    } else {

    }
#line 1661
    if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1662
      *link_status = resp->logical_link_status;
    } else {

    }
  } else {

  }
  err: 
#line 1666
  spin_unlock_bh(& adapter->mcc_lock);
#line 1667
  return (status);
}
}
#line 1671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_die_temperature(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_cntl_addnl_attribs *req ;
  int status ;
  void *tmp ;

  {
#line 1675
  status = 0;
#line 1677
  spin_lock_bh(& adapter->mcc_lock);
#line 1679
  wrb = wrb_from_mccq(adapter);
#line 1680
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1681
    status = -16;
#line 1682
    goto err;
  } else {

  }
#line 1684
  tmp = embedded_payload(wrb);
#line 1684
  req = (struct be_cmd_req_get_cntl_addnl_attribs *)tmp;
#line 1686
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 121, 24, wrb, (struct be_dma_mem *)0);
#line 1690
  be_mcc_notify(adapter);
  err: 
#line 1693
  spin_unlock_bh(& adapter->mcc_lock);
#line 1694
  return (status);
}
}
#line 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fat *resp ;
  void *tmp___0 ;

  {
#line 1704
  spin_lock_bh(& adapter->mcc_lock);
#line 1706
  wrb = wrb_from_mccq(adapter);
#line 1707
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1708
    status = -16;
#line 1709
    goto err;
  } else {

  }
#line 1711
  tmp = embedded_payload(wrb);
#line 1711
  req = (struct be_cmd_req_get_fat *)tmp;
#line 1713
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, 36, wrb, (struct be_dma_mem *)0);
#line 1716
  req->fat_operation = 1U;
#line 1717
  status = be_mcc_notify_wait(adapter);
#line 1718
  if (status == 0) {
#line 1719
    tmp___0 = embedded_payload(wrb);
#line 1719
    resp = (struct be_cmd_resp_get_fat *)tmp___0;
#line 1721
    if ((unsigned long )log_size != (unsigned long )((u32 *)0U) && resp->log_size != 0U) {
#line 1722
      *log_size = resp->log_size - 4U;
    } else {

    }
  } else {

  }
  err: 
#line 1726
  spin_unlock_bh(& adapter->mcc_lock);
#line 1727
  return (status);
}
}
#line 1730 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) 
{ 
  struct be_dma_mem get_fat_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  u32 offset ;
  u32 total_size ;
  u32 buf_size ;
  u32 log_offset ;
  u32 payload_len ;
  int status ;
  u32 _min1 ;
  unsigned int _min2 ;
  struct be_cmd_resp_get_fat *resp ;

  {
#line 1735
  offset = 0U;
#line 1736
  log_offset = 4U;
#line 1737
  status = 0;
#line 1739
  if (buf_len == 0U) {
#line 1740
    return (-5);
  } else {

  }
#line 1742
  total_size = buf_len;
#line 1744
  get_fat_cmd.size = 61476U;
#line 1745
  get_fat_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )get_fat_cmd.size,
                                       & get_fat_cmd.dma, 32U);
#line 1748
  if ((unsigned long )get_fat_cmd.va == (unsigned long )((void *)0)) {
#line 1749
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while reading FAT data\n");
#line 1751
    return (-12);
  } else {

  }
#line 1754
  spin_lock_bh(& adapter->mcc_lock);
#line 1756
  goto ldv_57680;
  ldv_57679: 
#line 1757
  _min1 = total_size;
#line 1757
  _min2 = 61440U;
#line 1757
  buf_size = _min1 < _min2 ? _min1 : _min2;
#line 1758
  total_size = total_size - buf_size;
#line 1760
  wrb = wrb_from_mccq(adapter);
#line 1761
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1762
    status = -16;
#line 1763
    goto err;
  } else {

  }
#line 1765
  req = (struct be_cmd_req_get_fat *)get_fat_cmd.va;
#line 1767
  payload_len = buf_size + 36U;
#line 1768
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, (int )payload_len, wrb, & get_fat_cmd);
#line 1772
  req->fat_operation = 0U;
#line 1773
  req->read_log_offset = log_offset;
#line 1774
  req->read_log_length = buf_size;
#line 1775
  req->data_buffer_size = buf_size;
#line 1777
  status = be_mcc_notify_wait(adapter);
#line 1778
  if (status == 0) {
#line 1779
    resp = (struct be_cmd_resp_get_fat *)get_fat_cmd.va;
#line 1781
    memcpy(buf + (unsigned long )offset, (void const   *)(& resp->data_buffer),
             (size_t )resp->read_log_length);
  } else {
#line 1785
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FAT Table Retrieve error\n");
#line 1786
    goto err;
  }
#line 1788
  offset = offset + buf_size;
#line 1789
  log_offset = log_offset + buf_size;
  ldv_57680: ;
#line 1756
  if (total_size != 0U) {
#line 1758
    goto ldv_57679;
  } else {

  }

  err: 
#line 1792
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )get_fat_cmd.size, get_fat_cmd.va,
                 get_fat_cmd.dma, (struct dma_attrs *)0);
#line 1794
  spin_unlock_bh(& adapter->mcc_lock);
#line 1795
  return (status);
}
}
#line 1799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fw_ver(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fw_version *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fw_version *resp ;
  void *tmp___0 ;

  {
#line 1805
  spin_lock_bh(& adapter->mcc_lock);
#line 1807
  wrb = wrb_from_mccq(adapter);
#line 1808
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1809
    status = -16;
#line 1810
    goto err;
  } else {

  }
#line 1813
  tmp = embedded_payload(wrb);
#line 1813
  req = (struct be_cmd_req_get_fw_version *)tmp;
#line 1815
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 35, 80, wrb, (struct be_dma_mem *)0);
#line 1818
  status = be_mcc_notify_wait(adapter);
#line 1819
  if (status == 0) {
#line 1820
    tmp___0 = embedded_payload(wrb);
#line 1820
    resp = (struct be_cmd_resp_get_fw_version *)tmp___0;
#line 1822
    strlcpy((char *)(& adapter->fw_ver), (char const   *)(& resp->firmware_version_string),
            32UL);
#line 1824
    strlcpy((char *)(& adapter->fw_on_flash), (char const   *)(& resp->fw_on_flash_version_string),
            32UL);
  } else {

  }
  err: 
#line 1828
  spin_unlock_bh(& adapter->mcc_lock);
#line 1829
  return (status);
}
}
#line 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int __be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd ,
                               int num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  int status ;
  int i ;
  void *tmp ;

  {
#line 1840
  status = 0;
#line 1842
  spin_lock_bh(& adapter->mcc_lock);
#line 1844
  wrb = wrb_from_mccq(adapter);
#line 1845
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1846
    status = -16;
#line 1847
    goto err;
  } else {

  }
#line 1849
  tmp = embedded_payload(wrb);
#line 1849
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 1851
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 41, 404, wrb, (struct be_dma_mem *)0);
#line 1855
  req->num_eq = (unsigned int )num;
#line 1856
  i = 0;
#line 1856
  goto ldv_57701;
  ldv_57700: 
#line 1857
  req->set_eqd[i].eq_id = (set_eqd + (unsigned long )i)->eq_id;
#line 1858
  req->set_eqd[i].phase = 0U;
#line 1859
  req->set_eqd[i].delay_multiplier = (set_eqd + (unsigned long )i)->delay_multiplier;
#line 1856
  i = i + 1;
  ldv_57701: ;
#line 1856
  if (i < num) {
#line 1858
    goto ldv_57700;
  } else {

  }
#line 1863
  be_mcc_notify(adapter);
  err: 
#line 1865
  spin_unlock_bh(& adapter->mcc_lock);
#line 1866
  return (status);
}
}
#line 1869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) 
{ 
  int num_eqs ;
  int i ;
  int _min1 ;
  int _min2 ;

  {
#line 1872
  i = 0;
#line 1874
  goto ldv_57714;
  ldv_57713: 
#line 1875
  _min1 = num;
#line 1875
  _min2 = 8;
#line 1875
  num_eqs = _min1 < _min2 ? _min1 : _min2;
#line 1876
  __be_cmd_modify_eqd(adapter, set_eqd + (unsigned long )i, num_eqs);
#line 1877
  i = i + num_eqs;
#line 1878
  num = num - num_eqs;
  ldv_57714: ;
#line 1874
  if (num != 0) {
#line 1876
    goto ldv_57713;
  } else {

  }

#line 1881
  return (0);
}
}
#line 1885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_vlan_config *req ;
  int status ;
  void *tmp ;

  {
#line 1892
  spin_lock_bh(& adapter->mcc_lock);
#line 1894
  wrb = wrb_from_mccq(adapter);
#line 1895
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1896
    status = -16;
#line 1897
    goto err;
  } else {

  }
#line 1899
  tmp = embedded_payload(wrb);
#line 1899
  req = (struct be_cmd_req_vlan_config *)tmp;
#line 1901
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 4, 148, wrb, (struct be_dma_mem *)0);
#line 1904
  req->hdr.domain = (u8 )domain;
#line 1906
  req->interface_id = (u8 )if_id;
#line 1907
  req->untagged = (adapter->res.if_cap_flags & 32U) != 0U;
#line 1908
  req->num_vlan = (u8 )num;
#line 1909
  memcpy((void *)(& req->normal_vlan), (void const   *)vtag_array, (unsigned long )req->num_vlan * 2UL);
#line 1912
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1914
  spin_unlock_bh(& adapter->mcc_lock);
#line 1915
  return (status);
}
}
#line 1918 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int __be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_dma_mem *mem ;
  struct be_cmd_req_rx_filter *req ;
  int status ;
  struct netdev_hw_addr *ha ;
  int i ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1921
  mem = & adapter->rx_filter;
#line 1922
  req = (struct be_cmd_req_rx_filter *)mem->va;
#line 1925
  spin_lock_bh(& adapter->mcc_lock);
#line 1927
  wrb = wrb_from_mccq(adapter);
#line 1928
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1929
    status = -16;
#line 1930
    goto err;
  } else {

  }
#line 1932
  memset((void *)req, 0, 424UL);
#line 1933
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 34, 424, wrb, mem);
#line 1937
  req->if_id = (unsigned int )adapter->if_handle;
#line 1938
  req->if_flags_mask = flags;
#line 1939
  req->if_flags = value == 1U ? req->if_flags_mask : 0U;
#line 1941
  if ((flags & 4096U) != 0U) {
#line 1943
    i = 0;
#line 1948
    req->if_flags_mask = req->if_flags_mask | (adapter->res.if_cap_flags & 512U);
#line 1951
    req->mcast_num = (unsigned int )(adapter->netdev)->mc.count;
#line 1952
    __mptr = (struct list_head  const  *)(adapter->netdev)->mc.list.next;
#line 1952
    ha = (struct netdev_hw_addr *)__mptr;
#line 1952
    goto ldv_57744;
    ldv_57743: 
#line 1953
    tmp = i;
#line 1953
    i = i + 1;
#line 1953
    memcpy((void *)(& req->mcast_mac[tmp].byte), (void const   *)(& ha->addr), 6UL);
#line 1952
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1952
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_57744: ;
#line 1952
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->mc.list)) {
#line 1954
      goto ldv_57743;
    } else {

    }

  } else {

  }
#line 1956
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1958
  spin_unlock_bh(& adapter->mcc_lock);
#line 1959
  return (status);
}
}
#line 1962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) 
{ 
  struct device *dev ;
  int tmp ;

  {
#line 1964
  dev = & (adapter->pdev)->dev;
#line 1966
  if ((adapter->res.if_cap_flags & flags) != flags) {
#line 1967
    dev_warn((struct device  const  *)dev, "Cannot set rx filter flags 0x%x\n", flags);
#line 1968
    dev_warn((struct device  const  *)dev, "Interface is capable of 0x%x flags only\n",
             adapter->res.if_cap_flags);
  } else {

  }
#line 1971
  flags = adapter->res.if_cap_flags & flags;
#line 1973
  tmp = __be_cmd_rx_filter(adapter, flags, value);
#line 1973
  return (tmp);
}
}
#line 1977 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1983
  tmp = be_cmd_allowed(adapter, 36, 1);
#line 1983
  if (tmp) {
#line 1983
    tmp___0 = 0;
  } else {
#line 1983
    tmp___0 = 1;
  }
#line 1983
  if (tmp___0) {
#line 1985
    return (-1);
  } else {

  }
#line 1987
  spin_lock_bh(& adapter->mcc_lock);
#line 1989
  wrb = wrb_from_mccq(adapter);
#line 1990
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1991
    status = -16;
#line 1992
    goto err;
  } else {

  }
#line 1994
  tmp___1 = embedded_payload(wrb);
#line 1994
  req = (struct be_cmd_req_set_flow_control *)tmp___1;
#line 1996
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 36, 20, wrb, (struct be_dma_mem *)0);
#line 2000
  req->hdr.version = 1U;
#line 2001
  req->tx_flow_control = (unsigned short )tx_fc;
#line 2002
  req->rx_flow_control = (unsigned short )rx_fc;
#line 2004
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2007
  spin_unlock_bh(& adapter->mcc_lock);
#line 2009
  if (status > 0 && ((unsigned int )status & 65535U) == 68U) {
#line 2010
    return (-95);
  } else {

  }
#line 2012
  return (status);
}
}
#line 2016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct be_cmd_resp_get_flow_control *resp ;
  void *tmp___2 ;

  {
#line 2022
  tmp = be_cmd_allowed(adapter, 37, 1);
#line 2022
  if (tmp) {
#line 2022
    tmp___0 = 0;
  } else {
#line 2022
    tmp___0 = 1;
  }
#line 2022
  if (tmp___0) {
#line 2024
    return (-1);
  } else {

  }
#line 2026
  spin_lock_bh(& adapter->mcc_lock);
#line 2028
  wrb = wrb_from_mccq(adapter);
#line 2029
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2030
    status = -16;
#line 2031
    goto err;
  } else {

  }
#line 2033
  tmp___1 = embedded_payload(wrb);
#line 2033
  req = (struct be_cmd_req_get_flow_control *)tmp___1;
#line 2035
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 37, 20, wrb, (struct be_dma_mem *)0);
#line 2039
  status = be_mcc_notify_wait(adapter);
#line 2040
  if (status == 0) {
#line 2041
    tmp___2 = embedded_payload(wrb);
#line 2041
    resp = (struct be_cmd_resp_get_flow_control *)tmp___2;
#line 2044
    *tx_fc = (u32 )resp->tx_flow_control;
#line 2045
    *rx_fc = (u32 )resp->rx_flow_control;
  } else {

  }
  err: 
#line 2049
  spin_unlock_bh(& adapter->mcc_lock);
#line 2050
  return (status);
}
}
#line 2054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_fw_cfg(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_query_fw_cfg *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_query_fw_cfg *resp ;
  void *tmp___1 ;

  {
#line 2060
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2060
  if (tmp != 0) {
#line 2061
    return (-1);
  } else {

  }
#line 2063
  wrb = wrb_from_mbox(adapter);
#line 2064
  tmp___0 = embedded_payload(wrb);
#line 2064
  req = (struct be_cmd_req_query_fw_cfg *)tmp___0;
#line 2066
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 58, 140, wrb, (struct be_dma_mem *)0);
#line 2070
  status = be_mbox_notify_wait(adapter);
#line 2071
  if (status == 0) {
#line 2072
    tmp___1 = embedded_payload(wrb);
#line 2072
    resp = (struct be_cmd_resp_query_fw_cfg *)tmp___1;
#line 2074
    adapter->port_num = resp->phys_port;
#line 2075
    adapter->function_mode = resp->function_mode;
#line 2076
    adapter->function_caps = resp->function_caps;
#line 2077
    adapter->asic_rev = (unsigned int )((u16 )resp->asic_revision) & 255U;
#line 2078
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "FW config: function_mode=0x%x, function_caps=0x%x\n",
              adapter->function_mode, adapter->function_caps);
  } else {

  }
#line 2083
  mutex_unlock(& adapter->mbox_lock);
#line 2084
  return (status);
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_reset_function(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 2094
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2095
    iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 2097
    status = lancer_wait_ready(adapter);
#line 2098
    if (status != 0) {
#line 2099
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter in non recoverable error\n");
    } else {

    }
#line 2101
    return (status);
  } else {

  }
#line 2104
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2104
  if (tmp != 0) {
#line 2105
    return (-1);
  } else {

  }
#line 2107
  wrb = wrb_from_mbox(adapter);
#line 2108
  tmp___0 = embedded_payload(wrb);
#line 2108
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 2110
  be_wrb_cmd_hdr_prepare(req, 1, 61, 16, wrb, (struct be_dma_mem *)0);
#line 2114
  status = be_mbox_notify_wait(adapter);
#line 2116
  mutex_unlock(& adapter->mbox_lock);
#line 2117
  return (status);
}
}
#line 2120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size , u8 const   *rss_hkey ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_rss_config *req ;
  int status ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2127
  if ((adapter->res.if_cap_flags & 4U) == 0U) {
#line 2128
    return (0);
  } else {

  }
#line 2130
  spin_lock_bh(& adapter->mcc_lock);
#line 2132
  wrb = wrb_from_mccq(adapter);
#line 2133
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2134
    status = -16;
#line 2135
    goto err;
  } else {

  }
#line 2137
  tmp = embedded_payload(wrb);
#line 2137
  req = (struct be_cmd_req_rss_config *)tmp;
#line 2139
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 1, 196, wrb, (struct be_dma_mem *)0);
#line 2142
  req->if_id = (unsigned int )adapter->if_handle;
#line 2143
  req->enable_rss = (unsigned short )rss_hash_opts;
#line 2144
  tmp___0 = fls((int )table_size);
#line 2144
  req->cpu_table_size_log2 = (unsigned int )((unsigned short )tmp___0) - 1U;
#line 2146
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 2147
    req->hdr.version = 1U;
  } else {

  }
#line 2149
  memcpy((void *)(& req->cpu_table), (void const   *)rsstable, (size_t )table_size);
#line 2150
  memcpy((void *)(& req->hash), (void const   *)rss_hkey, 40UL);
#line 2151
  swap_dws((void *)(& req->hash), 40);
#line 2153
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2155
  spin_unlock_bh(& adapter->mcc_lock);
#line 2156
  return (status);
}
}
#line 2160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_enable_disable_beacon *req ;
  int status ;
  void *tmp ;

  {
#line 2167
  spin_lock_bh(& adapter->mcc_lock);
#line 2169
  wrb = wrb_from_mccq(adapter);
#line 2170
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2171
    status = -16;
#line 2172
    goto err;
  } else {

  }
#line 2174
  tmp = embedded_payload(wrb);
#line 2174
  req = (struct be_cmd_req_enable_disable_beacon *)tmp;
#line 2176
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 69, 20, wrb, (struct be_dma_mem *)0);
#line 2180
  req->port_num = port_num;
#line 2181
  req->beacon_state = state;
#line 2182
  req->beacon_duration = bcn;
#line 2183
  req->status_duration = sts;
#line 2185
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2188
  spin_unlock_bh(& adapter->mcc_lock);
#line 2189
  return (status);
}
}
#line 2193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_beacon_state *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_beacon_state *resp ;
  void *tmp___0 ;

  {
#line 2199
  spin_lock_bh(& adapter->mcc_lock);
#line 2201
  wrb = wrb_from_mccq(adapter);
#line 2202
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2203
    status = -16;
#line 2204
    goto err;
  } else {

  }
#line 2206
  tmp = embedded_payload(wrb);
#line 2206
  req = (struct be_cmd_req_get_beacon_state *)tmp;
#line 2208
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 70, 20, wrb, (struct be_dma_mem *)0);
#line 2212
  req->port_num = port_num;
#line 2214
  status = be_mcc_notify_wait(adapter);
#line 2215
  if (status == 0) {
#line 2216
    tmp___0 = embedded_payload(wrb);
#line 2216
    resp = (struct be_cmd_resp_get_beacon_state *)tmp___0;
#line 2219
    *state = (u32 )resp->beacon_state;
  } else {

  }
  err: 
#line 2223
  spin_unlock_bh(& adapter->mcc_lock);
#line 2224
  return (status);
}
}
#line 2228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_read_port_transceiver_data(struct be_adapter *adapter , u8 page_num , u8 *data ) 
{ 
  struct be_dma_mem cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_port_type *req ;
  int status ;
  struct be_cmd_resp_port_type *resp ;

  {
#line 2236
  if ((unsigned int )page_num > 162U) {
#line 2237
    return (-22);
  } else {

  }
#line 2239
  cmd.size = 280U;
#line 2240
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 2242
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2243
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failed\n");
#line 2244
    return (-12);
  } else {

  }
#line 2247
  spin_lock_bh(& adapter->mcc_lock);
#line 2249
  wrb = wrb_from_mccq(adapter);
#line 2250
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2251
    status = -16;
#line 2252
    goto err;
  } else {

  }
#line 2254
  req = (struct be_cmd_req_port_type *)cmd.va;
#line 2256
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 73, (int )cmd.size, wrb, & cmd);
#line 2260
  req->port = (unsigned int )adapter->hba_port_num;
#line 2261
  req->page_num = (unsigned int )page_num;
#line 2262
  status = be_mcc_notify_wait(adapter);
#line 2263
  if (status == 0) {
#line 2264
    resp = (struct be_cmd_resp_port_type *)cmd.va;
#line 2266
    memcpy((void *)data, (void const   *)(& resp->page_data), 256UL);
  } else {

  }
  err: 
#line 2269
  spin_unlock_bh(& adapter->mcc_lock);
#line 2270
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 2271
  return (status);
}
}
#line 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_write_object *req ;
  struct lancer_cmd_resp_write_object *resp ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;

  {
#line 2282
  ctxt = (void *)0;
#line 2285
  spin_lock_bh(& adapter->mcc_lock);
#line 2286
  adapter->flash_status = 0U;
#line 2288
  wrb = wrb_from_mccq(adapter);
#line 2289
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2290
    status = -16;
#line 2291
    goto err_unlock;
  } else {

  }
#line 2294
  tmp = embedded_payload(wrb);
#line 2294
  req = (struct lancer_cmd_req_write_object *)tmp;
#line 2296
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 172, 144, wrb, (struct be_dma_mem *)0);
#line 2301
  ctxt = (void *)(& req->context);
#line 2302
  tmp___0 = amap_mask(24U);
#line 2302
  amap_set(ctxt, 0U, tmp___0, 0U, data_size);
#line 2305
  if (data_size == 0U) {
#line 2306
    tmp___1 = amap_mask(1U);
#line 2306
    amap_set(ctxt, 0U, tmp___1, 31U, 1U);
  } else {
#line 2309
    tmp___2 = amap_mask(1U);
#line 2309
    amap_set(ctxt, 0U, tmp___2, 31U, 0U);
  }
#line 2312
  swap_dws(ctxt, 4);
#line 2313
  req->write_offset = data_offset;
#line 2314
  strlcpy((char *)(& req->object_name), obj_name, 104UL);
#line 2315
  req->descriptor_count = 1U;
#line 2316
  req->buf_len = data_size;
#line 2317
  req->addr_low = (unsigned int )cmd->dma + 144U;
#line 2320
  req->addr_high = (unsigned int )((cmd->dma + 144ULL) >> 32ULL);
#line 2323
  be_mcc_notify(adapter);
#line 2324
  spin_unlock_bh(& adapter->mcc_lock);
#line 2326
  tmp___3 = msecs_to_jiffies(60000U);
#line 2326
  tmp___4 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp___3);
#line 2326
  if (tmp___4 == 0UL) {
#line 2328
    status = -110;
  } else {
#line 2330
    status = (int )adapter->flash_status;
  }
#line 2332
  tmp___5 = embedded_payload(wrb);
#line 2332
  resp = (struct lancer_cmd_resp_write_object *)tmp___5;
#line 2333
  if (status == 0) {
#line 2334
    *data_written = resp->actual_write_len;
#line 2335
    *change_status = resp->change_status;
  } else {
#line 2337
    *addn_status = resp->additional_status;
  }
#line 2340
  return (status);
  err_unlock: 
#line 2343
  spin_unlock_bh(& adapter->mcc_lock);
#line 2344
  return (status);
}
}
#line 2347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_cable_type(struct be_adapter *adapter ) 
{ 
  u8 page_data[256U] ;
  int status ;

  {
#line 2352
  status = be_cmd_read_port_transceiver_data(adapter, 160, (u8 *)(& page_data));
#line 2354
  if (status == 0) {
#line 2355
    switch ((int )adapter->phy.interface_type) {
    case 10: 
#line 2357
    adapter->phy.cable_type = page_data[131];
#line 2359
    goto ldv_57849;
    case 3: 
#line 2361
    adapter->phy.cable_type = page_data[8];
#line 2363
    goto ldv_57849;
    default: 
#line 2365
    adapter->phy.cable_type = 0U;
#line 2366
    goto ldv_57849;
    }
    ldv_57849: ;
  } else {

  }
#line 2369
  return (status);
}
}
#line 2372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_sfp_info(struct be_adapter *adapter ) 
{ 
  u8 page_data[256U] ;
  int status ;

  {
#line 2377
  status = be_cmd_read_port_transceiver_data(adapter, 160, (u8 *)(& page_data));
#line 2379
  if (status == 0) {
#line 2380
    strlcpy((char *)(& adapter->phy.vendor_name), (char const   *)(& page_data) + 20U,
            16UL);
#line 2382
    strlcpy((char *)(& adapter->phy.vendor_pn), (char const   *)(& page_data) + 40U,
            16UL);
  } else {

  }
#line 2387
  return (status);
}
}
#line 2390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_delete_object(struct be_adapter *adapter , char const   *obj_name ) 
{ 
  struct lancer_cmd_req_delete_object *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  void *tmp ;

  {
#line 2396
  spin_lock_bh(& adapter->mcc_lock);
#line 2398
  wrb = wrb_from_mccq(adapter);
#line 2399
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2400
    status = -16;
#line 2401
    goto err;
  } else {

  }
#line 2404
  tmp = embedded_payload(wrb);
#line 2404
  req = (struct lancer_cmd_req_delete_object *)tmp;
#line 2406
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 174, 128, wrb, (struct be_dma_mem *)0);
#line 2410
  strlcpy((char *)(& req->object_name), obj_name, 104UL);
#line 2412
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2414
  spin_unlock_bh(& adapter->mcc_lock);
#line 2415
  return (status);
}
}
#line 2418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_read_object *req ;
  struct lancer_cmd_resp_read_object *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2427
  spin_lock_bh(& adapter->mcc_lock);
#line 2429
  wrb = wrb_from_mccq(adapter);
#line 2430
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2431
    status = -16;
#line 2432
    goto err_unlock;
  } else {

  }
#line 2435
  tmp = embedded_payload(wrb);
#line 2435
  req = (struct lancer_cmd_req_read_object *)tmp;
#line 2437
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 171, 144, wrb, (struct be_dma_mem *)0);
#line 2442
  req->desired_read_len = data_size;
#line 2443
  req->read_offset = data_offset;
#line 2444
  strcpy((char *)(& req->object_name), obj_name);
#line 2445
  req->descriptor_count = 1U;
#line 2446
  req->buf_len = data_size;
#line 2447
  req->addr_low = (unsigned int )cmd->dma;
#line 2448
  req->addr_high = (unsigned int )(cmd->dma >> 32ULL);
#line 2450
  status = be_mcc_notify_wait(adapter);
#line 2452
  tmp___0 = embedded_payload(wrb);
#line 2452
  resp = (struct lancer_cmd_resp_read_object *)tmp___0;
#line 2453
  if (status == 0) {
#line 2454
    *data_read = resp->actual_read_len;
#line 2455
    *eof = resp->eof;
  } else {
#line 2457
    *addn_status = resp->additional_status;
  }
  err_unlock: 
#line 2461
  spin_unlock_bh(& adapter->mcc_lock);
#line 2462
  return (status);
}
}
#line 2465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 img_offset , u32 buf_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_write_flashrom *req ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 2473
  spin_lock_bh(& adapter->mcc_lock);
#line 2474
  adapter->flash_status = 0U;
#line 2476
  wrb = wrb_from_mccq(adapter);
#line 2477
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2478
    status = -16;
#line 2479
    goto err_unlock;
  } else {

  }
#line 2481
  req = (struct be_cmd_write_flashrom *)cmd->va;
#line 2483
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 7, (int )cmd->size, wrb, cmd);
#line 2487
  req->params.op_type = flash_type;
#line 2488
  if (flash_type == 7U) {
#line 2489
    req->params.offset = img_offset;
  } else {

  }
#line 2491
  req->params.op_code = flash_opcode;
#line 2492
  req->params.data_buf_size = buf_size;
#line 2494
  be_mcc_notify(adapter);
#line 2495
  spin_unlock_bh(& adapter->mcc_lock);
#line 2497
  tmp = msecs_to_jiffies(40000U);
#line 2497
  tmp___0 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp);
#line 2497
  if (tmp___0 == 0UL) {
#line 2499
    status = -110;
  } else {
#line 2501
    status = (int )adapter->flash_status;
  }
#line 2503
  return (status);
  err_unlock: 
#line 2506
  spin_unlock_bh(& adapter->mcc_lock);
#line 2507
  return (status);
}
}
#line 2510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , u16 img_optype ,
                         u32 img_offset , u32 crc_offset ) 
{ 
  struct be_cmd_read_flash_crc *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  void *tmp ;

  {
#line 2517
  spin_lock_bh(& adapter->mcc_lock);
#line 2519
  wrb = wrb_from_mccq(adapter);
#line 2520
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2521
    status = -16;
#line 2522
    goto err;
  } else {

  }
#line 2524
  tmp = embedded_payload(wrb);
#line 2524
  req = (struct be_cmd_read_flash_crc *)tmp;
#line 2526
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 6, 40, wrb, (struct be_dma_mem *)0);
#line 2530
  req->params.op_type = (unsigned int )img_optype;
#line 2531
  if ((unsigned int )img_optype == 7U) {
#line 2532
    req->params.offset = img_offset + crc_offset;
  } else {
#line 2534
    req->params.offset = crc_offset;
  }
#line 2536
  req->params.op_code = 4U;
#line 2537
  req->params.data_buf_size = 4U;
#line 2539
  status = be_mcc_notify_wait(adapter);
#line 2540
  if (status == 0) {
#line 2541
    memcpy((void *)flashed_crc, (void const   *)(& req->crc), 4UL);
  } else {

  }
  err: 
#line 2544
  spin_unlock_bh(& adapter->mcc_lock);
#line 2545
  return (status);
}
}
#line 2548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config *req ;
  int status ;

  {
#line 2555
  spin_lock_bh(& adapter->mcc_lock);
#line 2557
  wrb = wrb_from_mccq(adapter);
#line 2558
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2559
    status = -16;
#line 2560
    goto err;
  } else {

  }
#line 2562
  req = (struct be_cmd_req_acpi_wol_magic_config *)nonemb_cmd->va;
#line 2564
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 604, wrb, nonemb_cmd);
#line 2567
  memcpy((void *)(& req->magic_mac), (void const   *)mac, 6UL);
#line 2569
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2572
  spin_unlock_bh(& adapter->mcc_lock);
#line 2573
  return (status);
}
}
#line 2576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_lmode *req ;
  int status ;
  void *tmp ;

  {
#line 2583
  spin_lock_bh(& adapter->mcc_lock);
#line 2585
  wrb = wrb_from_mccq(adapter);
#line 2586
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2587
    status = -16;
#line 2588
    goto err;
  } else {

  }
#line 2591
  tmp = embedded_payload(wrb);
#line 2591
  req = (struct be_cmd_req_set_lmode *)tmp;
#line 2593
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 19, 20, wrb, (struct be_dma_mem *)0);
#line 2597
  req->src_port = port_num;
#line 2598
  req->dest_port = port_num;
#line 2599
  req->loopback_type = loopback_type;
#line 2600
  req->loopback_state = enable;
#line 2602
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2604
  spin_unlock_bh(& adapter->mcc_lock);
#line 2605
  return (status);
}
}
#line 2608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_loopback_test *req ;
  struct be_cmd_resp_loopback_test *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2617
  spin_lock_bh(& adapter->mcc_lock);
#line 2619
  wrb = wrb_from_mccq(adapter);
#line 2620
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2621
    status = -16;
#line 2622
    goto err;
  } else {

  }
#line 2625
  tmp = embedded_payload(wrb);
#line 2625
  req = (struct be_cmd_req_loopback_test *)tmp;
#line 2627
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 18, 48, wrb, (struct be_dma_mem *)0);
#line 2631
  req->hdr.timeout = 15U;
#line 2632
  req->pattern = pattern;
#line 2633
  req->src_port = port_num;
#line 2634
  req->dest_port = port_num;
#line 2635
  req->pkt_size = pkt_size;
#line 2636
  req->num_pkts = num_pkts;
#line 2637
  req->loopback_type = loopback_type;
#line 2639
  be_mcc_notify(adapter);
#line 2641
  spin_unlock_bh(& adapter->mcc_lock);
#line 2643
  wait_for_completion(& adapter->et_cmd_compl);
#line 2644
  tmp___0 = embedded_payload(wrb);
#line 2644
  resp = (struct be_cmd_resp_loopback_test *)tmp___0;
#line 2645
  status = (int )resp->status;
#line 2647
  return (status);
  err: 
#line 2649
  spin_unlock_bh(& adapter->mcc_lock);
#line 2650
  return (status);
}
}
#line 2653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_ddrdma_test *req ;
  int status ;
  int i ;
  int j ;
  struct be_cmd_resp_ddrdma_test *resp ;
  int tmp ;

  {
#line 2659
  j = 0;
#line 2661
  spin_lock_bh(& adapter->mcc_lock);
#line 2663
  wrb = wrb_from_mccq(adapter);
#line 2664
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2665
    status = -16;
#line 2666
    goto err;
  } else {

  }
#line 2668
  req = (struct be_cmd_req_ddrdma_test *)cmd->va;
#line 2669
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 17, (int )cmd->size, wrb, cmd);
#line 2673
  req->pattern = pattern;
#line 2674
  req->byte_count = byte_cnt;
#line 2675
  i = 0;
#line 2675
  goto ldv_57948;
  ldv_57947: 
#line 2676
  req->snd_buff[i] = (unsigned char )(pattern >> j * 8);
#line 2677
  j = j + 1;
#line 2678
  if (j > 7) {
#line 2679
    j = 0;
  } else {

  }
#line 2675
  i = i + 1;
  ldv_57948: ;
#line 2675
  if ((u32 )i < byte_cnt) {
#line 2677
    goto ldv_57947;
  } else {

  }
#line 2682
  status = be_mcc_notify_wait(adapter);
#line 2684
  if (status == 0) {
#line 2687
    resp = (struct be_cmd_resp_ddrdma_test *)cmd->va;
#line 2688
    tmp = memcmp((void const   *)(& resp->rcv_buff), (void const   *)(& req->snd_buff),
                 (size_t )byte_cnt);
#line 2688
    if (tmp != 0 || resp->snd_err != 0U) {
#line 2690
      status = -1;
    } else {

    }
  } else {

  }
  err: 
#line 2695
  spin_unlock_bh(& adapter->mcc_lock);
#line 2696
  return (status);
}
}
#line 2699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_seeprom_read *req ;
  int status ;

  {
#line 2706
  spin_lock_bh(& adapter->mcc_lock);
#line 2708
  wrb = wrb_from_mccq(adapter);
#line 2709
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2710
    status = -16;
#line 2711
    goto err;
  } else {

  }
#line 2713
  req = (struct be_cmd_req_seeprom_read *)nonemb_cmd->va;
#line 2715
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 30, 1040, wrb, nonemb_cmd);
#line 2719
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2722
  spin_unlock_bh(& adapter->mcc_lock);
#line 2723
  return (status);
}
}
#line 2726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_phy_info(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_phy_info *req ;
  struct be_dma_mem cmd ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  struct be_phy_info *resp_phy_info ;

  {
#line 2733
  tmp = be_cmd_allowed(adapter, 102, 1);
#line 2733
  if (tmp) {
#line 2733
    tmp___0 = 0;
  } else {
#line 2733
    tmp___0 = 1;
  }
#line 2733
  if (tmp___0) {
#line 2735
    return (-1);
  } else {

  }
#line 2737
  spin_lock_bh(& adapter->mcc_lock);
#line 2739
  wrb = wrb_from_mccq(adapter);
#line 2740
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2741
    status = -16;
#line 2742
    goto err;
  } else {

  }
#line 2744
  cmd.size = 40U;
#line 2745
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 2747
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2748
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 2749
    status = -12;
#line 2750
    goto err;
  } else {

  }
#line 2753
  req = (struct be_cmd_req_get_phy_info *)cmd.va;
#line 2755
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 102, 40, wrb, & cmd);
#line 2759
  status = be_mcc_notify_wait(adapter);
#line 2760
  if (status == 0) {
#line 2761
    resp_phy_info = (struct be_phy_info *)cmd.va + 16U;
#line 2764
    adapter->phy.phy_type = resp_phy_info->phy_type;
#line 2765
    adapter->phy.interface_type = resp_phy_info->interface_type;
#line 2767
    adapter->phy.auto_speeds_supported = resp_phy_info->auto_speeds_supported;
#line 2769
    adapter->phy.fixed_speeds_supported = resp_phy_info->fixed_speeds_supported;
#line 2771
    adapter->phy.misc_params = resp_phy_info->misc_params;
#line 2774
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 2775
      adapter->phy.fixed_speeds_supported = 12U;
    } else {

    }
  } else {

  }
#line 2780
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  err: 
#line 2782
  spin_unlock_bh(& adapter->mcc_lock);
#line 2783
  return (status);
}
}
#line 2786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_qos *req ;
  int status ;
  void *tmp ;

  {
#line 2792
  spin_lock_bh(& adapter->mcc_lock);
#line 2794
  wrb = wrb_from_mccq(adapter);
#line 2795
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2796
    status = -16;
#line 2797
    goto err;
  } else {

  }
#line 2800
  tmp = embedded_payload(wrb);
#line 2800
  req = (struct be_cmd_req_set_qos *)tmp;
#line 2802
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 28, 52, wrb, (struct be_dma_mem *)0);
#line 2805
  req->hdr.domain = (u8 )domain;
#line 2806
  req->valid_bits = 1U;
#line 2807
  req->max_bps_nic = bps;
#line 2809
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2812
  spin_unlock_bh(& adapter->mcc_lock);
#line 2813
  return (status);
}
}
#line 2816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cntl_attribs *req ;
  int status ;
  int payload_len ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct mgmt_controller_attrib *attribs ;
  struct be_dma_mem attribs_cmd ;
  int tmp ;

  {
#line 2822
  _max1 = 16UL;
#line 2822
  _max2 = 556UL;
#line 2822
  payload_len = (int )(_max1 > _max2 ? _max1 : _max2);
#line 2826
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2826
  if (tmp != 0) {
#line 2827
    return (-1);
  } else {

  }
#line 2829
  memset((void *)(& attribs_cmd), 0, 24UL);
#line 2830
  attribs_cmd.size = 556U;
#line 2831
  attribs_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )attribs_cmd.size,
                                       & attribs_cmd.dma, 32U);
#line 2834
  if ((unsigned long )attribs_cmd.va == (unsigned long )((void *)0)) {
#line 2835
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 2836
    status = -12;
#line 2837
    goto err;
  } else {

  }
#line 2840
  wrb = wrb_from_mbox(adapter);
#line 2841
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2842
    status = -16;
#line 2843
    goto err;
  } else {

  }
#line 2845
  req = (struct be_cmd_req_cntl_attribs *)attribs_cmd.va;
#line 2847
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 32, payload_len, wrb, & attribs_cmd);
#line 2851
  status = be_mbox_notify_wait(adapter);
#line 2852
  if (status == 0) {
#line 2853
    attribs = (struct mgmt_controller_attrib *)attribs_cmd.va + 16U;
#line 2854
    adapter->hba_port_num = attribs->hba_attribs.phy_port;
  } else {

  }
  err: 
#line 2858
  mutex_unlock(& adapter->mbox_lock);
#line 2859
  if ((unsigned long )attribs_cmd.va != (unsigned long )((void *)0)) {
#line 2860
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )attribs_cmd.size, attribs_cmd.va,
                   attribs_cmd.dma, (struct dma_attrs *)0);
  } else {

  }
#line 2862
  return (status);
}
}
#line 2866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_req_native_mode(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_func_cap *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_set_func_cap *resp ;
  void *tmp___1 ;

  {
#line 2872
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 2872
  if (tmp != 0) {
#line 2873
    return (-1);
  } else {

  }
#line 2875
  wrb = wrb_from_mbox(adapter);
#line 2876
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2877
    status = -16;
#line 2878
    goto err;
  } else {

  }
#line 2881
  tmp___0 = embedded_payload(wrb);
#line 2881
  req = (struct be_cmd_req_set_func_cap *)tmp___0;
#line 2883
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 103, 236, wrb, (struct be_dma_mem *)0);
#line 2887
  req->valid_cap_flags = 6U;
#line 2889
  req->cap_flags = 4U;
#line 2891
  status = be_mbox_notify_wait(adapter);
#line 2892
  if (status == 0) {
#line 2893
    tmp___1 = embedded_payload(wrb);
#line 2893
    resp = (struct be_cmd_resp_set_func_cap *)tmp___1;
#line 2895
    adapter->be3_native = (resp->cap_flags & 4U) != 0U;
#line 2897
    if (! adapter->be3_native) {
#line 2898
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "adapter not in advanced mode\n");
    } else {

    }
  } else {

  }
  err: 
#line 2902
  mutex_unlock(& adapter->mbox_lock);
#line 2903
  return (status);
}
}
#line 2907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fn_privileges *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fn_privileges *resp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 2914
  spin_lock_bh(& adapter->mcc_lock);
#line 2916
  wrb = wrb_from_mccq(adapter);
#line 2917
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2918
    status = -16;
#line 2919
    goto err;
  } else {

  }
#line 2922
  tmp = embedded_payload(wrb);
#line 2922
  req = (struct be_cmd_req_get_fn_privileges *)tmp;
#line 2924
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 170, 20, wrb, (struct be_dma_mem *)0);
#line 2928
  req->hdr.domain = (u8 )domain;
#line 2930
  status = be_mcc_notify_wait(adapter);
#line 2931
  if (status == 0) {
#line 2932
    tmp___0 = embedded_payload(wrb);
#line 2932
    resp = (struct be_cmd_resp_get_fn_privileges *)tmp___0;
#line 2935
    *privilege = resp->privilege_mask;
#line 2940
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 2940
      tmp___1 = be_is_mc(adapter);
#line 2940
      if ((int )tmp___1) {
#line 2940
        if ((unsigned int )adapter->virtfn == 0U) {
#line 2942
          *privilege = 1792U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  err: 
#line 2946
  spin_unlock_bh(& adapter->mcc_lock);
#line 2947
  return (status);
}
}
#line 2951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_fn_privileges *req ;
  int status ;
  void *tmp ;

  {
#line 2958
  spin_lock_bh(& adapter->mcc_lock);
#line 2960
  wrb = wrb_from_mccq(adapter);
#line 2961
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2962
    status = -16;
#line 2963
    goto err;
  } else {

  }
#line 2966
  tmp = embedded_payload(wrb);
#line 2966
  req = (struct be_cmd_req_set_fn_privileges *)tmp;
#line 2967
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 100, 24, wrb, (struct be_dma_mem *)0);
#line 2970
  req->hdr.domain = (u8 )domain;
#line 2971
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2972
    req->privileges_lancer = privileges;
  } else {
#line 2974
    req->privileges = privileges;
  }
#line 2976
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2978
  spin_unlock_bh(& adapter->mcc_lock);
#line 2979
  return (status);
}
}
#line 2986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_mac_list *req ;
  int status ;
  int mac_count ;
  struct be_dma_mem get_mac_list_cmd ;
  int i ;
  struct be_cmd_resp_get_mac_list *resp ;
  struct get_list_macaddr *mac_entry ;
  u16 mac_addr_size ;
  u32 mac_id ;

  {
#line 2997
  memset((void *)(& get_mac_list_cmd), 0, 24UL);
#line 2998
  get_mac_list_cmd.size = 548U;
#line 2999
  get_mac_list_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )get_mac_list_cmd.size,
                                            & get_mac_list_cmd.dma, 32U);
#line 3004
  if ((unsigned long )get_mac_list_cmd.va == (unsigned long )((void *)0)) {
#line 3005
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure during GET_MAC_LIST\n");
#line 3007
    return (-12);
  } else {

  }
#line 3010
  spin_lock_bh(& adapter->mcc_lock);
#line 3012
  wrb = wrb_from_mccq(adapter);
#line 3013
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3014
    status = -16;
#line 3015
    goto out;
  } else {

  }
#line 3018
  req = (struct be_cmd_req_get_mac_list *)get_mac_list_cmd.va;
#line 3020
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 147, (int )get_mac_list_cmd.size, wrb, & get_mac_list_cmd);
#line 3023
  req->hdr.domain = domain;
#line 3024
  req->mac_type = 1U;
#line 3025
  if ((int )*pmac_id_valid) {
#line 3026
    req->mac_id = *pmac_id;
#line 3027
    req->iface_id = (unsigned short )if_handle;
#line 3028
    req->perm_override = 0U;
  } else {
#line 3030
    req->perm_override = 1U;
  }
#line 3033
  status = be_mcc_notify_wait(adapter);
#line 3034
  if (status == 0) {
#line 3035
    resp = (struct be_cmd_resp_get_mac_list *)get_mac_list_cmd.va;
#line 3038
    if ((int )*pmac_id_valid) {
#line 3039
      memcpy((void *)mac, (void const   *)(& resp->macid_macaddr.mac_addr_id.macaddr),
               6UL);
#line 3041
      goto out;
    } else {

    }
#line 3044
    mac_count = (int )resp->true_mac_count + (int )resp->pseudo_mac_count;
#line 3050
    i = 0;
#line 3050
    goto ldv_58038;
    ldv_58037: 
#line 3055
    mac_entry = (struct get_list_macaddr *)(& resp->macaddr_list) + (unsigned long )i;
#line 3056
    mac_addr_size = mac_entry->mac_addr_size;
#line 3060
    if ((unsigned int )mac_addr_size == 4U) {
#line 3061
      *pmac_id_valid = 1;
#line 3062
      mac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;
#line 3063
      *pmac_id = mac_id;
#line 3064
      goto out;
    } else {

    }
#line 3050
    i = i + 1;
    ldv_58038: ;
#line 3050
    if (i < mac_count) {
#line 3052
      goto ldv_58037;
    } else {

    }
#line 3068
    *pmac_id_valid = 0;
#line 3069
    memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
             6UL);
  } else {

  }
  out: 
#line 3074
  spin_unlock_bh(& adapter->mcc_lock);
#line 3075
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )get_mac_list_cmd.size, get_mac_list_cmd.va,
                 get_mac_list_cmd.dma, (struct dma_attrs *)0);
#line 3077
  return (status);
}
}
#line 3080 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3083
  if (! active) {
#line 3084
    be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle, (int )((u8 )domain));
  } else {

  }
#line 3086
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3087
    tmp = be_cmd_mac_addr_query(adapter, mac, 0, if_handle, curr_pmac_id);
#line 3087
    return (tmp);
  } else {
#line 3091
    tmp___0 = be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle,
                                       (int )((u8 )domain));
#line 3091
    return (tmp___0);
  }
}
}
#line 3096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) 
{ 
  int status ;
  bool pmac_valid ;

  {
#line 3099
  pmac_valid = 0;
#line 3101
  eth_zero_addr(mac);
#line 3103
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3104
    if ((unsigned int )adapter->virtfn == 0U) {
#line 3105
      status = be_cmd_mac_addr_query(adapter, mac, 1, 0U, 0U);
    } else {
#line 3108
      status = be_cmd_mac_addr_query(adapter, mac, 0, (u32 )adapter->if_handle, 0U);
    }
  } else {
#line 3111
    status = be_cmd_get_mac_from_list(adapter, mac, & pmac_valid, (u32 *)0U, (u32 )adapter->if_handle,
                                      0);
  }
#line 3115
  return (status);
}
}
#line 3119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_mac_list *req ;
  int status ;
  struct be_dma_mem cmd ;

  {
#line 3127
  memset((void *)(& cmd), 0, 24UL);
#line 3128
  cmd.size = 404U;
#line 3129
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               208U);
#line 3131
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3132
    return (-12);
  } else {

  }
#line 3134
  spin_lock_bh(& adapter->mcc_lock);
#line 3136
  wrb = wrb_from_mccq(adapter);
#line 3137
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3138
    status = -16;
#line 3139
    goto err;
  } else {

  }
#line 3142
  req = (struct be_cmd_req_set_mac_list *)cmd.va;
#line 3143
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 148, 404, wrb, & cmd);
#line 3147
  req->hdr.domain = (u8 )domain;
#line 3148
  req->mac_count = mac_count;
#line 3149
  if ((unsigned int )mac_count != 0U) {
#line 3150
    memcpy((void *)(& req->mac), (void const   *)mac_array, (size_t )((int )mac_count * 6));
  } else {

  }
#line 3152
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3155
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 3156
  spin_unlock_bh(& adapter->mcc_lock);
#line 3157
  return (status);
}
}
#line 3164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) 
{ 
  bool active_mac ;
  u8 old_mac[6U] ;
  u32 pmac_id ;
  int status ;
  int tmp ;

  {
#line 3166
  active_mac = 0;
#line 3171
  status = be_cmd_get_mac_from_list(adapter, (u8 *)(& old_mac), & active_mac, & pmac_id,
                                    (u32 )if_id, (int )((u8 )dom));
#line 3174
  if (status == 0 && (int )active_mac) {
#line 3175
    be_cmd_pmac_del(adapter, (u32 )if_id, (int )pmac_id, dom);
  } else {

  }
#line 3177
  tmp = be_cmd_set_mac_list(adapter, mac, (unsigned long )mac != (unsigned long )((u8 *)0U),
                            dom);
#line 3177
  return (tmp);
}
}
#line 3180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode , u8 spoofchk ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_hsw_config *req ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;

  {
#line 3188
  spin_lock_bh(& adapter->mcc_lock);
#line 3190
  wrb = wrb_from_mccq(adapter);
#line 3191
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3192
    status = -16;
#line 3193
    goto err;
  } else {

  }
#line 3196
  tmp = embedded_payload(wrb);
#line 3196
  req = (struct be_cmd_req_set_hsw_config *)tmp;
#line 3197
  ctxt = (void *)(& req->context);
#line 3199
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 153, 36, wrb, (struct be_dma_mem *)0);
#line 3203
  req->hdr.domain = (u8 )domain;
#line 3204
  tmp___0 = amap_mask(16U);
#line 3204
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 3205
  if ((unsigned int )pvid != 0U) {
#line 3206
    tmp___1 = amap_mask(1U);
#line 3206
    amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 3207
    tmp___2 = amap_mask(16U);
#line 3207
    amap_set(ctxt, 1U, tmp___2, 16U, (u32 )pvid);
  } else {

  }
#line 3209
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned int )hsw_mode != 0U) {
#line 3210
    tmp___3 = amap_mask(16U);
#line 3210
    amap_set(ctxt, 0U, tmp___3, 0U, (u32 )adapter->hba_port_num);
#line 3212
    tmp___4 = amap_mask(1U);
#line 3212
    amap_set(ctxt, 0U, tmp___4, 31U, 1U);
#line 3213
    tmp___5 = amap_mask(3U);
#line 3213
    amap_set(ctxt, 1U, tmp___5, 6U, (u32 )hsw_mode);
  } else {

  }
#line 3218
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned int )spoofchk != 0U) {
#line 3219
    tmp___6 = amap_mask(2U);
#line 3219
    amap_set(ctxt, 0U, tmp___6, 24U, (u32 )spoofchk);
#line 3221
    tmp___7 = amap_mask(2U);
#line 3221
    amap_set(ctxt, 1U, tmp___7, 14U, (u32 )spoofchk);
  } else {

  }
#line 3225
  swap_dws((void *)(& req->context), 20);
#line 3226
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3229
  spin_unlock_bh(& adapter->mcc_lock);
#line 3230
  return (status);
}
}
#line 3234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode , bool *spoofchk ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_hsw_config *req ;
  void *ctxt ;
  int status ;
  u16 vid ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  struct be_cmd_resp_get_hsw_config *resp ;
  void *tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;

  {
#line 3243
  spin_lock_bh(& adapter->mcc_lock);
#line 3245
  wrb = wrb_from_mccq(adapter);
#line 3246
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3247
    status = -16;
#line 3248
    goto err;
  } else {

  }
#line 3251
  tmp = embedded_payload(wrb);
#line 3251
  req = (struct be_cmd_req_get_hsw_config *)tmp;
#line 3252
  ctxt = (void *)(& req->context);
#line 3254
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 152, 20, wrb, (struct be_dma_mem *)0);
#line 3258
  req->hdr.domain = (u8 )domain;
#line 3259
  tmp___0 = amap_mask(16U);
#line 3259
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 3261
  tmp___1 = amap_mask(1U);
#line 3261
  amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 3263
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned long )mode != (unsigned long )((u8 *)0U)) {
#line 3264
    tmp___2 = amap_mask(16U);
#line 3264
    amap_set(ctxt, 0U, tmp___2, 0U, (u32 )adapter->hba_port_num);
#line 3266
    tmp___3 = amap_mask(1U);
#line 3266
    amap_set(ctxt, 0U, tmp___3, 31U, 1U);
  } else {

  }
#line 3268
  swap_dws((void *)(& req->context), 4);
#line 3270
  status = be_mcc_notify_wait(adapter);
#line 3271
  if (status == 0) {
#line 3272
    tmp___4 = embedded_payload(wrb);
#line 3272
    resp = (struct be_cmd_resp_get_hsw_config *)tmp___4;
#line 3275
    swap_dws((void *)(& resp->context), 16);
#line 3276
    tmp___5 = amap_mask(16U);
#line 3276
    tmp___6 = amap_get((void *)(& resp->context), 0U, tmp___5, 16U);
#line 3276
    vid = (u16 )tmp___6;
#line 3278
    if ((unsigned long )pvid != (unsigned long )((u16 *)0U)) {
#line 3279
      *pvid = vid;
    } else {

    }
#line 3280
    if ((unsigned long )mode != (unsigned long )((u8 *)0U)) {
#line 3281
      tmp___7 = amap_mask(3U);
#line 3281
      tmp___8 = amap_get((void *)(& resp->context), 0U, tmp___7, 6U);
#line 3281
      *mode = (u8 )tmp___8;
    } else {

    }
#line 3283
    if ((unsigned long )spoofchk != (unsigned long )((bool *)0)) {
#line 3284
      tmp___9 = amap_mask(1U);
#line 3284
      tmp___10 = amap_get((void *)(& resp->context), 0U, tmp___9, 14U);
#line 3284
      *spoofchk = tmp___10 != 0U;
    } else {

    }
  } else {

  }
  err: 
#line 3290
  spin_unlock_bh(& adapter->mcc_lock);
#line 3291
  return (status);
}
}
#line 3294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool be_is_wol_excluded(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;

  {
#line 3296
  pdev = adapter->pdev;
#line 3298
  if ((unsigned int )adapter->virtfn != 0U) {
#line 3299
    return (1);
  } else {

  }
#line 3301
  switch ((int )pdev->subsystem_device) {
  case 58882: ;
  case 58946: ;
  case 58898: ;
  case 58962: ;
#line 3306
  return (1);
  default: ;
#line 3308
  return (0);
  }
}
}
#line 3312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config_v1 *req ;
  int status ;
  struct be_dma_mem cmd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct be_cmd_resp_acpi_wol_magic_config_v1 *resp ;

  {
#line 3316
  status = 0;
#line 3319
  tmp = be_cmd_allowed(adapter, 12, 3);
#line 3319
  if (tmp) {
#line 3319
    tmp___0 = 0;
  } else {
#line 3319
    tmp___0 = 1;
  }
#line 3319
  if (tmp___0) {
#line 3321
    return (-1);
  } else {

  }
#line 3323
  tmp___1 = be_is_wol_excluded(adapter);
#line 3323
  if ((int )tmp___1) {
#line 3324
    return (status);
  } else {

  }
#line 3326
  tmp___2 = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3326
  if (tmp___2 != 0) {
#line 3327
    return (-1);
  } else {

  }
#line 3329
  memset((void *)(& cmd), 0, 24UL);
#line 3330
  cmd.size = 1204U;
#line 3331
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 3333
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3334
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 3335
    status = -12;
#line 3336
    goto err;
  } else {

  }
#line 3339
  wrb = wrb_from_mbox(adapter);
#line 3340
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3341
    status = -16;
#line 3342
    goto err;
  } else {

  }
#line 3345
  req = (struct be_cmd_req_acpi_wol_magic_config_v1 *)cmd.va;
#line 3347
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 1204, wrb, & cmd);
#line 3351
  req->hdr.version = 1U;
#line 3352
  req->query_options = 2U;
#line 3354
  status = be_mbox_notify_wait(adapter);
#line 3355
  if (status == 0) {
#line 3358
    resp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;
#line 3360
    adapter->wol_cap = resp->wol_settings;
#line 3361
    if ((int )adapter->wol_cap & 1) {
#line 3362
      adapter->wol_en = 1;
    } else {

    }
  } else {

  }
  err: 
#line 3365
  mutex_unlock(& adapter->mbox_lock);
#line 3366
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3367
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  } else {

  }
#line 3369
  return (status);
}
}
#line 3373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int i ;
  int j ;
  u32 num_modes ;

  {
#line 3380
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3381
  extfat_cmd.size = 2844U;
#line 3382
  extfat_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )extfat_cmd.size,
                                      & extfat_cmd.dma, 32U);
#line 3385
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 3386
    return (-12);
  } else {

  }
#line 3388
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 3389
  if (status != 0) {
#line 3390
    goto err;
  } else {

  }
#line 3392
  cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3394
  i = 0;
#line 3394
  goto ldv_58136;
  ldv_58135: 
#line 3395
  num_modes = cfgs->module[i].num_modes;
#line 3397
  j = 0;
#line 3397
  goto ldv_58133;
  ldv_58132: ;
#line 3398
  if ((unsigned int )cfgs->module[i].trace_lvl[j].mode == 0U) {
#line 3399
    cfgs->module[i].trace_lvl[j].dbg_lvl = level;
  } else {

  }
#line 3397
  j = j + 1;
  ldv_58133: ;
#line 3397
  if ((u32 )j < num_modes) {
#line 3399
    goto ldv_58132;
  } else {

  }
#line 3394
  i = i + 1;
  ldv_58136: ;
#line 3394
  if ((u32 )i < cfgs->num_modules) {
#line 3396
    goto ldv_58135;
  } else {

  }
#line 3404
  status = be_cmd_set_ext_fat_capabilites(adapter, & extfat_cmd, cfgs);
  err: 
#line 3406
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )extfat_cmd.size, extfat_cmd.va,
                 extfat_cmd.dma, (struct dma_attrs *)0);
#line 3408
  return (status);
}
}
#line 3411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int j ;
  int level ;

  {
#line 3416
  level = 0;
#line 3418
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3419
  extfat_cmd.size = 2844U;
#line 3420
  extfat_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )extfat_cmd.size,
                                      & extfat_cmd.dma, 32U);
#line 3424
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 3425
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%s: Memory allocation failure\n",
            "be_cmd_get_fw_log_level");
#line 3427
    goto err;
  } else {

  }
#line 3430
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 3431
  if (status == 0) {
#line 3432
    cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3435
    j = 0;
#line 3435
    goto ldv_58149;
    ldv_58148: ;
#line 3436
    if ((unsigned int )cfgs->module[0].trace_lvl[j].mode == 0U) {
#line 3437
      level = (int )cfgs->module[0].trace_lvl[j].dbg_lvl;
    } else {

    }
#line 3435
    j = j + 1;
    ldv_58149: ;
#line 3435
    if ((u32 )j < cfgs->module[0].num_modes) {
#line 3437
      goto ldv_58148;
    } else {

    }

  } else {

  }
#line 3440
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )extfat_cmd.size, extfat_cmd.va,
                 extfat_cmd.dma, (struct dma_attrs *)0);
  err: ;
#line 3443
  return (level);
}
}
#line 3446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_ext_fat_caps *req ;
  int status ;
  int tmp ;

  {
#line 3453
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3453
  if (tmp != 0) {
#line 3454
    return (-1);
  } else {

  }
#line 3456
  wrb = wrb_from_mbox(adapter);
#line 3457
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3458
    status = -16;
#line 3459
    goto err;
  } else {

  }
#line 3462
  req = (struct be_cmd_req_get_ext_fat_caps *)cmd->va;
#line 3463
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 125, (int )cmd->size, wrb, cmd);
#line 3466
  req->parameter_type = 1U;
#line 3468
  status = be_mbox_notify_wait(adapter);
  err: 
#line 3470
  mutex_unlock(& adapter->mbox_lock);
#line 3471
  return (status);
}
}
#line 3474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ext_fat_caps *req ;
  int status ;

  {
#line 3482
  spin_lock_bh(& adapter->mcc_lock);
#line 3484
  wrb = wrb_from_mccq(adapter);
#line 3485
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3486
    status = -16;
#line 3487
    goto err;
  } else {

  }
#line 3490
  req = (struct be_cmd_req_set_ext_fat_caps *)cmd->va;
#line 3491
  memcpy((void *)(& req->set_params), (void const   *)configs, 2828UL);
#line 3492
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 126, (int )cmd->size, wrb, cmd);
#line 3496
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3498
  spin_unlock_bh(& adapter->mcc_lock);
#line 3499
  return (status);
}
}
#line 3502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_port_name(struct be_adapter *adapter ) 
{ 
  struct be_cmd_req_get_port_name *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_get_port_name *resp ;
  void *tmp___1 ;

  {
#line 3508
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3508
  if (tmp != 0) {
#line 3509
    return (-1);
  } else {

  }
#line 3511
  wrb = wrb_from_mbox(adapter);
#line 3512
  tmp___0 = embedded_payload(wrb);
#line 3512
  req = (struct be_cmd_req_get_port_name *)tmp___0;
#line 3514
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 77, 20, wrb, (struct be_dma_mem *)0);
#line 3517
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 3518
    req->hdr.version = 1U;
  } else {

  }
#line 3520
  status = be_mbox_notify_wait(adapter);
#line 3521
  if (status == 0) {
#line 3522
    tmp___1 = embedded_payload(wrb);
#line 3522
    resp = (struct be_cmd_resp_get_port_name *)tmp___1;
#line 3524
    adapter->port_name = (char )resp->port_name[(int )adapter->hba_port_num];
  } else {
#line 3526
    adapter->port_name = (char )((unsigned int )adapter->hba_port_num + 48U);
  }
#line 3529
  mutex_unlock(& adapter->mbox_lock);
#line 3530
  return (status);
}
}
#line 3539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_nic_res_desc *be_get_nic_desc(u8 *buf , u32 desc_count , int desc_type ) 
{ 
  struct be_res_desc_hdr *hdr ;
  struct be_nic_res_desc *nic ;
  int i ;

  {
#line 3542
  hdr = (struct be_res_desc_hdr *)buf;
#line 3546
  i = 0;
#line 3546
  goto ldv_58187;
  ldv_58186: ;
#line 3547
  if ((unsigned int )hdr->desc_type == 65U || (unsigned int )hdr->desc_type == 81U) {
#line 3549
    nic = (struct be_nic_res_desc *)hdr;
#line 3550
    if (desc_type == 1 || (desc_type == 2 && ((int )nic->flags & 8) != 0)) {
#line 3553
      return (nic);
    } else {

    }
  } else {

  }
#line 3556
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3557
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3546
  i = i + 1;
  ldv_58187: ;
#line 3546
  if ((u32 )i < desc_count) {
#line 3548
    goto ldv_58186;
  } else {

  }

#line 3559
  return ((struct be_nic_res_desc *)0);
}
}
#line 3562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_nic_res_desc *be_get_vft_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_nic_res_desc *tmp ;

  {
#line 3564
  tmp = be_get_nic_desc(buf, desc_count, 2);
#line 3564
  return (tmp);
}
}
#line 3567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_nic_res_desc *be_get_func_nic_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_nic_res_desc *tmp ;

  {
#line 3569
  tmp = be_get_nic_desc(buf, desc_count, 1);
#line 3569
  return (tmp);
}
}
#line 3572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_pcie_res_desc *be_get_pcie_desc(u8 devfn , u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  struct be_pcie_res_desc *pcie ;
  int i ;

  {
#line 3575
  hdr = (struct be_res_desc_hdr *)buf;
#line 3579
  i = 0;
#line 3579
  goto ldv_58206;
  ldv_58205: ;
#line 3580
  if ((unsigned int )hdr->desc_type == 64U || (unsigned int )hdr->desc_type == 80U) {
#line 3582
    pcie = (struct be_pcie_res_desc *)hdr;
#line 3583
    if ((int )pcie->pf_num == (int )devfn) {
#line 3584
      return (pcie);
    } else {

    }
  } else {

  }
#line 3587
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3588
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3579
  i = i + 1;
  ldv_58206: ;
#line 3579
  if ((u32 )i < desc_count) {
#line 3581
    goto ldv_58205;
  } else {

  }

#line 3590
  return ((struct be_pcie_res_desc *)0);
}
}
#line 3593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_port_res_desc *be_get_port_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  int i ;

  {
#line 3595
  hdr = (struct be_res_desc_hdr *)buf;
#line 3598
  i = 0;
#line 3598
  goto ldv_58215;
  ldv_58214: ;
#line 3599
  if ((unsigned int )hdr->desc_type == 85U) {
#line 3600
    return ((struct be_port_res_desc *)hdr);
  } else {

  }
#line 3602
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3603
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3598
  i = i + 1;
  ldv_58215: ;
#line 3598
  if ((u32 )i < desc_count) {
#line 3600
    goto ldv_58214;
  } else {

  }

#line 3605
  return ((struct be_port_res_desc *)0);
}
}
#line 3608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_copy_nic_desc(struct be_resources *res , struct be_nic_res_desc *desc ) 
{ 


  {
#line 3611
  res->max_uc_mac = desc->unicast_mac_count;
#line 3612
  res->max_vlans = desc->vlan_count;
#line 3613
  res->max_mcast_mac = desc->mcast_mac_count;
#line 3614
  res->max_tx_qs = desc->txq_count;
#line 3615
  res->max_rss_qs = desc->rssq_count;
#line 3616
  res->max_rx_qs = desc->rq_count;
#line 3617
  res->max_evt_qs = desc->eq_count;
#line 3618
  res->max_cq_count = desc->cq_count;
#line 3619
  res->max_iface_count = desc->iface_count;
#line 3620
  res->max_mcc_count = desc->mcc_count;
#line 3622
  res->if_cap_flags = desc->cap_flags & 16784316U;
#line 3623
  return;
}
}
#line 3627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_func_config *req ;
  int status ;
  struct be_dma_mem cmd ;
  int tmp ;
  struct be_cmd_resp_get_func_config *resp ;
  u32 desc_count ;
  struct be_nic_res_desc *desc ;

  {
#line 3634
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 3634
  if (tmp != 0) {
#line 3635
    return (-1);
  } else {

  }
#line 3637
  memset((void *)(& cmd), 0, 24UL);
#line 3638
  cmd.size = 23252U;
#line 3639
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 3641
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3642
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 3643
    status = -12;
#line 3644
    goto err;
  } else {

  }
#line 3647
  wrb = wrb_from_mbox(adapter);
#line 3648
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3649
    status = -16;
#line 3650
    goto err;
  } else {

  }
#line 3653
  req = (struct be_cmd_req_get_func_config *)cmd.va;
#line 3655
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 160, (int )cmd.size, wrb, & cmd);
#line 3659
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3660
    req->hdr.version = 1U;
  } else {

  }
#line 3662
  status = be_mbox_notify_wait(adapter);
#line 3663
  if (status == 0) {
#line 3664
    resp = (struct be_cmd_resp_get_func_config *)cmd.va;
#line 3665
    desc_count = resp->desc_count;
#line 3668
    desc = be_get_func_nic_desc((u8 *)(& resp->func_param), desc_count);
#line 3669
    if ((unsigned long )desc == (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3670
      status = -22;
#line 3671
      goto err;
    } else {

    }
#line 3674
    adapter->pf_number = desc->pf_num;
#line 3675
    be_copy_nic_desc(res, desc);
  } else {

  }
  err: 
#line 3678
  mutex_unlock(& adapter->mbox_lock);
#line 3679
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3680
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  } else {

  }
#line 3682
  return (status);
}
}
#line 3686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 query , u8 domain ) 
{ 
  struct be_cmd_resp_get_profile_config *resp ;
  struct be_cmd_req_get_profile_config *req ;
  struct be_nic_res_desc *vf_res ;
  struct be_pcie_res_desc *pcie ;
  struct be_port_res_desc *port ;
  struct be_nic_res_desc *nic ;
  struct be_mcc_wrb wrb ;
  struct be_dma_mem cmd ;
  u16 desc_count ;
  int status ;

  {
#line 3695
  wrb.embedded = 0U;
#line 3695
  wrb.payload_length = 0U;
#line 3695
  wrb.tag0 = 0U;
#line 3695
  wrb.tag1 = 0U;
#line 3695
  wrb.rsvd = 0U;
#line 3695
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 3695
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 3700
  memset((void *)(& cmd), 0, 24UL);
#line 3701
  cmd.size = 23252U;
#line 3702
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 3704
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3705
    return (-12);
  } else {

  }
#line 3707
  req = (struct be_cmd_req_get_profile_config *)cmd.va;
#line 3708
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd.size, & wrb, & cmd);
#line 3712
  req->hdr.domain = domain;
#line 3713
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3714
    req->hdr.version = 1U;
  } else {

  }
#line 3715
  req->type = 2U;
#line 3721
  if ((unsigned int )query == 1U) {
#line 3722
    req->type = (u8 )((unsigned int )req->type | 8U);
  } else {

  }
#line 3724
  status = be_cmd_notify_wait(adapter, & wrb);
#line 3725
  if (status != 0) {
#line 3726
    goto err;
  } else {

  }
#line 3728
  resp = (struct be_cmd_resp_get_profile_config *)cmd.va;
#line 3729
  desc_count = resp->desc_count;
#line 3731
  pcie = be_get_pcie_desc((int )((u8 )(adapter->pdev)->devfn), (u8 *)(& resp->func_param),
                          (u32 )desc_count);
#line 3733
  if ((unsigned long )pcie != (unsigned long )((struct be_pcie_res_desc *)0)) {
#line 3734
    res->max_vfs = pcie->num_vfs;
  } else {

  }
#line 3736
  port = be_get_port_desc((u8 *)(& resp->func_param), (u32 )desc_count);
#line 3737
  if ((unsigned long )port != (unsigned long )((struct be_port_res_desc *)0)) {
#line 3738
    adapter->mc_type = port->mc_type;
  } else {

  }
#line 3740
  nic = be_get_func_nic_desc((u8 *)(& resp->func_param), (u32 )desc_count);
#line 3741
  if ((unsigned long )nic != (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3742
    be_copy_nic_desc(res, nic);
  } else {

  }
#line 3744
  vf_res = be_get_vft_desc((u8 *)(& resp->func_param), (u32 )desc_count);
#line 3745
  if ((unsigned long )vf_res != (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3746
    res->vf_if_cap_flags = vf_res->cap_flags;
  } else {

  }
  err: ;
#line 3748
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3749
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  } else {

  }
#line 3751
  return (status);
}
}
#line 3755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_set_profile_config(struct be_adapter *adapter , void *desc , int size ,
                                     int count , u8 version , u8 domain ) 
{ 
  struct be_cmd_req_set_profile_config *req ;
  struct be_mcc_wrb wrb ;
  struct be_dma_mem cmd ;
  int status ;

  {
#line 3759
  wrb.embedded = 0U;
#line 3759
  wrb.payload_length = 0U;
#line 3759
  wrb.tag0 = 0U;
#line 3759
  wrb.tag1 = 0U;
#line 3759
  wrb.rsvd = 0U;
#line 3759
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 3759
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 3763
  memset((void *)(& cmd), 0, 24UL);
#line 3764
  cmd.size = 200U;
#line 3765
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               32U);
#line 3767
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3768
    return (-12);
  } else {

  }
#line 3770
  req = (struct be_cmd_req_set_profile_config *)cmd.va;
#line 3771
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 165, (int )cmd.size, & wrb, & cmd);
#line 3774
  req->hdr.version = version;
#line 3775
  req->hdr.domain = domain;
#line 3776
  req->desc_count = (unsigned int )count;
#line 3777
  memcpy((void *)(& req->desc), (void const   *)desc, (size_t )size);
#line 3779
  status = be_cmd_notify_wait(adapter, & wrb);
#line 3781
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3782
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  } else {

  }
#line 3784
  return (status);
}
}
#line 3788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_reset_nic_desc(struct be_nic_res_desc *nic ) 
{ 


  {
#line 3790
  memset((void *)nic, 0, 88UL);
#line 3791
  nic->unicast_mac_count = 65535U;
#line 3792
  nic->mcc_count = 65535U;
#line 3793
  nic->vlan_count = 65535U;
#line 3794
  nic->mcast_mac_count = 65535U;
#line 3795
  nic->txq_count = 65535U;
#line 3796
  nic->rq_count = 65535U;
#line 3797
  nic->rssq_count = 65535U;
#line 3798
  nic->lro_count = 65535U;
#line 3799
  nic->cq_count = 65535U;
#line 3800
  nic->toe_conn_count = 65535U;
#line 3801
  nic->eq_count = 65535U;
#line 3802
  nic->iface_count = 65535U;
#line 3803
  nic->link_param = 255U;
#line 3804
  nic->channel_id_param = 61440U;
#line 3805
  nic->acpi_params = 255U;
#line 3806
  nic->wol_param = 15U;
#line 3807
  nic->tunnel_iface_count = 65535U;
#line 3808
  nic->direct_tenant_iface_count = 65535U;
#line 3809
  nic->bw_min = 4294967295U;
#line 3810
  nic->bw_max = 4294967295U;
#line 3811
  return;
}
}
#line 3814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_reset_pcie_desc(struct be_pcie_res_desc *pcie ) 
{ 


  {
#line 3816
  memset((void *)pcie, 0, 88UL);
#line 3817
  pcie->sriov_state = 255U;
#line 3818
  pcie->pf_state = 255U;
#line 3819
  pcie->pf_type = 255U;
#line 3820
  pcie->num_vfs = 65535U;
#line 3821
  return;
}
}
#line 3823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_config_qos(struct be_adapter *adapter , u32 max_rate , u16 link_speed ,
                      u8 domain ) 
{ 
  struct be_nic_res_desc nic_desc ;
  u32 bw_percent ;
  u16 version ;
  int tmp ;
  int tmp___0 ;

  {
#line 3828
  version = 0U;
#line 3830
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3831
    tmp = be_cmd_set_qos(adapter, max_rate / 10U, (u32 )domain);
#line 3831
    return (tmp);
  } else {

  }
#line 3833
  be_reset_nic_desc(& nic_desc);
#line 3834
  nic_desc.pf_num = adapter->pf_number;
#line 3835
  nic_desc.vf_num = domain;
#line 3836
  nic_desc.bw_min = 0U;
#line 3837
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 3838
    nic_desc.hdr.desc_type = 65U;
#line 3839
    nic_desc.hdr.desc_len = 72U;
#line 3840
    nic_desc.flags = 208U;
#line 3842
    nic_desc.bw_max = max_rate / 10U;
  } else {
#line 3844
    version = 1U;
#line 3845
    nic_desc.hdr.desc_type = 81U;
#line 3846
    nic_desc.hdr.desc_len = 88U;
#line 3847
    nic_desc.flags = 192U;
#line 3848
    bw_percent = max_rate != 0U ? (max_rate * 100U) / (u32 )link_speed : 100U;
#line 3849
    nic_desc.bw_max = bw_percent;
  }
#line 3852
  tmp___0 = be_cmd_set_profile_config(adapter, (void *)(& nic_desc), (int )nic_desc.hdr.desc_len,
                                      1, (int )((u8 )version), (int )domain);
#line 3852
  return (tmp___0);
}
}
#line 3857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_fill_vf_res_template(struct be_adapter *adapter , struct be_resources pool_res ,
                                    u16 num_vfs___0 , u16 num_vf_qs , struct be_nic_res_desc *nic_vft ) 
{ 
  u32 vf_if_cap_flags ;
  struct be_resources res_mod ;

  {
#line 3862
  vf_if_cap_flags = pool_res.vf_if_cap_flags;
#line 3863
  res_mod.max_vfs = 0U;
#line 3863
  res_mod.max_mcast_mac = (unsigned short)0;
#line 3863
  res_mod.max_tx_qs = (unsigned short)0;
#line 3863
  res_mod.max_rss_qs = (unsigned short)0;
#line 3863
  res_mod.max_rx_qs = (unsigned short)0;
#line 3863
  res_mod.max_cq_count = (unsigned short)0;
#line 3863
  res_mod.max_uc_mac = (unsigned short)0;
#line 3863
  res_mod.max_vlans = (unsigned short)0;
#line 3863
  res_mod.max_iface_count = (unsigned short)0;
#line 3863
  res_mod.max_mcc_count = (unsigned short)0;
#line 3863
  res_mod.max_evt_qs = (unsigned short)0;
#line 3863
  res_mod.if_cap_flags = 0U;
#line 3863
  res_mod.vf_if_cap_flags = 0U;
#line 3868
  be_cmd_get_profile_config(adapter, & res_mod, 1, 0);
#line 3875
  if ((res_mod.vf_if_cap_flags & 4U) != 0U) {
#line 3876
    nic_vft->flags = (u8 )((unsigned int )nic_vft->flags | 1U);
#line 3877
    if ((unsigned int )num_vf_qs > 1U) {
#line 3878
      vf_if_cap_flags = vf_if_cap_flags | 4U;
#line 3879
      if ((pool_res.if_cap_flags & 16777216U) != 0U) {
#line 3880
        vf_if_cap_flags = vf_if_cap_flags | 16777216U;
      } else {

      }
    } else {
#line 3882
      vf_if_cap_flags = vf_if_cap_flags & 4278190075U;
    }
#line 3886
    nic_vft->cap_flags = vf_if_cap_flags;
  } else {
#line 3888
    num_vf_qs = 1U;
  }
#line 3891
  nic_vft->rq_count = num_vf_qs;
#line 3892
  nic_vft->txq_count = num_vf_qs;
#line 3893
  nic_vft->rssq_count = num_vf_qs;
#line 3894
  nic_vft->cq_count = (unsigned short )((int )pool_res.max_cq_count / ((int )num_vfs___0 + 1));
#line 3900
  if ((unsigned int )res_mod.max_uc_mac == 65535U) {
#line 3901
    nic_vft->unicast_mac_count = (unsigned short )((int )pool_res.max_uc_mac / ((int )num_vfs___0 + 1));
  } else {

  }
#line 3904
  if ((unsigned int )res_mod.max_vlans == 65535U) {
#line 3905
    nic_vft->vlan_count = (unsigned short )((int )pool_res.max_vlans / ((int )num_vfs___0 + 1));
  } else {

  }
#line 3908
  if ((unsigned int )res_mod.max_iface_count == 65535U) {
#line 3909
    nic_vft->iface_count = (unsigned short )((int )pool_res.max_iface_count / ((int )num_vfs___0 + 1));
  } else {

  }
#line 3912
  if ((unsigned int )res_mod.max_mcc_count == 65535U) {
#line 3913
    nic_vft->mcc_count = (unsigned short )((int )pool_res.max_mcc_count / ((int )num_vfs___0 + 1));
  } else {

  }
#line 3914
  return;
}
}
#line 3917 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_sriov_config(struct be_adapter *adapter , struct be_resources pool_res ,
                            u16 num_vfs___0 , u16 num_vf_qs ) 
{ 
  struct __anonstruct_desc_400 desc ;
  int tmp ;

  {
#line 3927
  be_reset_pcie_desc(& desc.pcie);
#line 3928
  desc.pcie.hdr.desc_type = 80U;
#line 3929
  desc.pcie.hdr.desc_len = 88U;
#line 3930
  desc.pcie.flags = 192U;
#line 3931
  desc.pcie.pf_num = (u8 )(adapter->pdev)->devfn;
#line 3932
  desc.pcie.sriov_state = (unsigned int )num_vfs___0 != 0U;
#line 3933
  desc.pcie.num_vfs = num_vfs___0;
#line 3936
  be_reset_nic_desc(& desc.nic_vft);
#line 3937
  desc.nic_vft.hdr.desc_type = 81U;
#line 3938
  desc.nic_vft.hdr.desc_len = 88U;
#line 3939
  desc.nic_vft.flags = 200U;
#line 3940
  desc.nic_vft.pf_num = (u8 )(adapter->pdev)->devfn;
#line 3941
  desc.nic_vft.vf_num = 0U;
#line 3943
  be_fill_vf_res_template(adapter, pool_res, (int )num_vfs___0, (int )num_vf_qs, & desc.nic_vft);
#line 3946
  tmp = be_cmd_set_profile_config(adapter, (void *)(& desc), 176, 2, 1, 0);
#line 3946
  return (tmp);
}
}
#line 3950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_manage_iface(struct be_adapter *adapter , u32 iface , u8 op ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_manage_iface_filters *req ;
  int status ;
  void *tmp ;

  {
#line 3956
  if (iface == 4294967295U) {
#line 3957
    return (-1);
  } else {

  }
#line 3959
  spin_lock_bh(& adapter->mcc_lock);
#line 3961
  wrb = wrb_from_mccq(adapter);
#line 3962
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3963
    status = -16;
#line 3964
    goto err;
  } else {

  }
#line 3966
  tmp = embedded_payload(wrb);
#line 3966
  req = (struct be_cmd_req_manage_iface_filters *)tmp;
#line 3968
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 193, 52, wrb, (struct be_dma_mem *)0);
#line 3971
  req->op = op;
#line 3972
  req->target_iface_id = iface;
#line 3974
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3976
  spin_unlock_bh(& adapter->mcc_lock);
#line 3977
  return (status);
}
}
#line 3980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_vxlan_port(struct be_adapter *adapter , __be16 port ) 
{ 
  struct be_port_res_desc port_desc ;
  __u16 tmp ;
  int tmp___0 ;

  {
#line 3984
  memset((void *)(& port_desc), 0, 88UL);
#line 3985
  port_desc.hdr.desc_type = 85U;
#line 3986
  port_desc.hdr.desc_len = 88U;
#line 3987
  port_desc.flags = 192U;
#line 3988
  port_desc.link_num = adapter->hba_port_num;
#line 3989
  if ((unsigned int )port != 0U) {
#line 3990
    port_desc.nv_flags = 23U;
#line 3992
    tmp = __fswab16((int )port);
#line 3992
    port_desc.nv_port = tmp;
  } else {
#line 3994
    port_desc.nv_flags = 1U;
#line 3995
    port_desc.nv_port = 0U;
  }
#line 3998
  tmp___0 = be_cmd_set_profile_config(adapter, (void *)(& port_desc), 88, 1, 1, 0);
#line 3998
  return (tmp___0);
}
}
#line 4002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_iface_list *req ;
  struct be_cmd_resp_get_iface_list *resp ;
  int status ;
  void *tmp ;

  {
#line 4010
  spin_lock_bh(& adapter->mcc_lock);
#line 4012
  wrb = wrb_from_mccq(adapter);
#line 4013
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4014
    status = -16;
#line 4015
    goto err;
  } else {

  }
#line 4017
  tmp = embedded_payload(wrb);
#line 4017
  req = (struct be_cmd_req_get_iface_list *)tmp;
#line 4019
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 194, 32, wrb, (struct be_dma_mem *)0);
#line 4022
  req->hdr.domain = (unsigned int )((u8 )vf_num) + 1U;
#line 4024
  status = be_mcc_notify_wait(adapter);
#line 4025
  if (status == 0) {
#line 4026
    resp = (struct be_cmd_resp_get_iface_list *)req;
#line 4027
    vf_cfg->if_handle = (int )resp->if_desc.if_id;
  } else {

  }
  err: 
#line 4031
  spin_unlock_bh(& adapter->mcc_lock);
#line 4032
  return (status);
}
}
#line 4035 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int lancer_wait_idle(struct be_adapter *adapter ) 
{ 
  u32 reg_val ;
  int status ;
  int i ;

  {
#line 4039
  status = 0;
#line 4041
  i = 0;
#line 4041
  goto ldv_58328;
  ldv_58327: 
#line 4042
  reg_val = ioread32((void *)adapter->db + 1044U);
#line 4043
  if ((reg_val & 1073741824U) == 0U) {
#line 4044
    goto ldv_58326;
  } else {

  }
#line 4046
  ssleep(1U);
#line 4041
  i = i + 1;
  ldv_58328: ;
#line 4041
  if (i <= 29) {
#line 4043
    goto ldv_58327;
  } else {

  }
  ldv_58326: ;
#line 4049
  if (i == 30) {
#line 4050
    status = -1;
  } else {

  }
#line 4052
  return (status);
}
}
#line 4055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) 
{ 
  int status ;

  {
#line 4057
  status = 0;
#line 4059
  status = lancer_wait_idle(adapter);
#line 4060
  if (status != 0) {
#line 4061
    return (status);
  } else {

  }
#line 4063
  iowrite32(mask, (void *)adapter->db + 1044U);
#line 4065
  return (status);
}
}
#line 4069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
bool dump_present(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;

  {
#line 4071
  sliport_status = 0U;
#line 4073
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 4074
  return ((sliport_status & 33554432U) != 0U);
}
}
#line 4077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_initiate_dump(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 4079
  dev = & (adapter->pdev)->dev;
#line 4082
  tmp = dump_present(adapter);
#line 4082
  if ((int )tmp) {
#line 4083
    _dev_info((struct device  const  *)dev, "Previous dump not cleared, not forcing dump\n");
#line 4084
    return (-17);
  } else {

  }
#line 4088
  status = lancer_physdev_ctrl(adapter, 6U);
#line 4090
  if (status < 0) {
#line 4091
    dev_err((struct device  const  *)dev, "FW reset failed\n");
#line 4092
    return (status);
  } else {

  }
#line 4095
  status = lancer_wait_idle(adapter);
#line 4096
  if (status != 0) {
#line 4097
    return (status);
  } else {

  }
#line 4099
  tmp___0 = dump_present(adapter);
#line 4099
  if (tmp___0) {
#line 4099
    tmp___1 = 0;
  } else {
#line 4099
    tmp___1 = 1;
  }
#line 4099
  if (tmp___1) {
#line 4100
    dev_err((struct device  const  *)dev, "FW dump not generated\n");
#line 4101
    return (-5);
  } else {

  }
#line 4104
  return (0);
}
}
#line 4107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_delete_dump(struct be_adapter *adapter ) 
{ 
  int status ;

  {
#line 4111
  status = lancer_cmd_delete_object(adapter, "/dbg/dump.bin");
#line 4112
  return (status <= 0 ? status : -5);
}
}
#line 4116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_enable_disable_vf *req ;
  int status ;
  void *tmp ;

  {
#line 4122
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 4123
    return (0);
  } else {

  }
#line 4125
  spin_lock_bh(& adapter->mcc_lock);
#line 4127
  wrb = wrb_from_mccq(adapter);
#line 4128
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4129
    status = -16;
#line 4130
    goto err;
  } else {

  }
#line 4133
  tmp = embedded_payload(wrb);
#line 4133
  req = (struct be_cmd_enable_disable_vf *)tmp;
#line 4135
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 196, 20, wrb, (struct be_dma_mem *)0);
#line 4139
  req->hdr.domain = domain;
#line 4140
  req->enable = 1U;
#line 4141
  status = be_mcc_notify_wait(adapter);
  err: 
#line 4143
  spin_unlock_bh(& adapter->mcc_lock);
#line 4144
  return (status);
}
}
#line 4147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_intr_set *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 4153
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 4153
  if (tmp != 0) {
#line 4154
    return (-1);
  } else {

  }
#line 4156
  wrb = wrb_from_mbox(adapter);
#line 4158
  tmp___0 = embedded_payload(wrb);
#line 4158
  req = (struct be_cmd_req_intr_set *)tmp___0;
#line 4160
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 89, 20, wrb, (struct be_dma_mem *)0);
#line 4164
  req->intr_enabled = (u8 )intr_enable;
#line 4166
  status = be_mbox_notify_wait(adapter);
#line 4168
  mutex_unlock(& adapter->mbox_lock);
#line 4169
  return (status);
}
}
#line 4173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) 
{ 
  struct be_cmd_req_get_active_profile *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_get_active_profile *resp ;
  void *tmp___1 ;

  {
#line 4179
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
#line 4179
  if (tmp != 0) {
#line 4180
    return (-1);
  } else {

  }
#line 4182
  wrb = wrb_from_mbox(adapter);
#line 4183
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4184
    status = -16;
#line 4185
    goto err;
  } else {

  }
#line 4188
  tmp___0 = embedded_payload(wrb);
#line 4188
  req = (struct be_cmd_req_get_active_profile *)tmp___0;
#line 4190
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 167, 20, wrb, (struct be_dma_mem *)0);
#line 4194
  status = be_mbox_notify_wait(adapter);
#line 4195
  if (status == 0) {
#line 4196
    tmp___1 = embedded_payload(wrb);
#line 4196
    resp = (struct be_cmd_resp_get_active_profile *)tmp___1;
#line 4199
    *profile_id = resp->active_profile_id;
  } else {

  }
  err: 
#line 4203
  mutex_unlock(& adapter->mbox_lock);
#line 4204
  return (status);
}
}
#line 4207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_logical_link_config(struct be_adapter *adapter , int link_state , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ll_link *req ;
  int status ;
  void *tmp ;

  {
#line 4214
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 4215
    return (-95);
  } else {

  }
#line 4217
  spin_lock_bh(& adapter->mcc_lock);
#line 4219
  wrb = wrb_from_mccq(adapter);
#line 4220
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4221
    status = -16;
#line 4222
    goto err;
  } else {

  }
#line 4225
  tmp = embedded_payload(wrb);
#line 4225
  req = (struct be_cmd_req_set_ll_link *)tmp;
#line 4227
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 80, 20, wrb, (struct be_dma_mem *)0);
#line 4231
  req->hdr.version = 1U;
#line 4232
  req->hdr.domain = domain;
#line 4234
  if (link_state == 1) {
#line 4235
    req->link_config = req->link_config | 1U;
  } else {

  }
#line 4237
  if (link_state == 0) {
#line 4238
    req->link_config = req->link_config | 256U;
  } else {

  }
#line 4240
  status = be_mcc_notify_wait(adapter);
  err: 
#line 4242
  spin_unlock_bh(& adapter->mcc_lock);
#line 4243
  return (status);
}
}
#line 4246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  struct be_cmd_req_hdr *req ;
  struct be_cmd_resp_hdr *resp ;
  int status ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4249
  tmp = netdev_priv((struct net_device  const  *)netdev_handle);
#line 4249
  adapter = (struct be_adapter *)tmp;
#line 4251
  hdr = (struct be_cmd_req_hdr *)wrb_payload;
#line 4256
  spin_lock_bh(& adapter->mcc_lock);
#line 4258
  wrb = wrb_from_mccq(adapter);
#line 4259
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 4260
    status = -16;
#line 4261
    goto err;
  } else {

  }
#line 4263
  tmp___0 = embedded_payload(wrb);
#line 4263
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 4264
  tmp___1 = embedded_payload(wrb);
#line 4264
  resp = (struct be_cmd_resp_hdr *)tmp___1;
#line 4266
  be_wrb_cmd_hdr_prepare(req, (int )hdr->subsystem, (int )hdr->opcode, wrb_payload_size,
                         wrb, (struct be_dma_mem *)0);
#line 4268
  memcpy((void *)req, (void const   *)wrb_payload, (size_t )wrb_payload_size);
#line 4269
  swap_dws((void *)req, wrb_payload_size);
#line 4271
  status = be_mcc_notify_wait(adapter);
#line 4272
  if ((unsigned long )cmd_status != (unsigned long )((u16 *)0U)) {
#line 4273
    *cmd_status = (u16 )status;
  } else {

  }
#line 4274
  if ((unsigned long )ext_status != (unsigned long )((u16 *)0U)) {
#line 4275
    *ext_status = 0U;
  } else {

  }
#line 4276
  memcpy(wrb_payload, (void const   *)resp, (unsigned long )resp->response_length + 16UL);
#line 4277
  swap_dws(wrb_payload, (int )(resp->response_length + 16U));
  err: 
#line 4279
  spin_unlock_bh(& adapter->mcc_lock);
#line 4280
  return (status);
}
}
#line 4282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
static char const   __kstrtab_be_roce_mcc_cmd[16U]  = 
#line 4282
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'm',      'c',      'c',      '_', 
        'c',      'm',      'd',      '\000'};
#line 4282
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd ;
#line 4282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.c"
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd  =    {(unsigned long )(& be_roce_mcc_cmd), (char const   *)(& __kstrtab_be_roce_mcc_cmd)};
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 139
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 139
  ldv_func_res = tmp;
#line 141
  activate_work_3(ldv_func_arg3, 2);
#line 143
  return (ldv_func_res);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
bool ldv_queue_delayed_work_on_48(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 150
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 150
  ldv_func_res = tmp;
#line 152
  activate_work_3(& ldv_func_arg3->work, 2);
#line 154
  return (ldv_func_res);
}
}
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 161
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 161
  ldv_func_res = tmp;
#line 163
  activate_work_3(ldv_func_arg3, 2);
#line 165
  return (ldv_func_res);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
void ldv_flush_workqueue_50(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 171
  flush_workqueue(ldv_func_arg1);
#line 173
  call_and_disable_all_3(2);
#line 174
  return;
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_cmds.o.c.prepared"
bool ldv_queue_delayed_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 180
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 180
  ldv_func_res = tmp;
#line 182
  activate_work_3(& ldv_func_arg3->work, 2);
#line 184
  return (ldv_func_res);
}
}
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 113 "include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 117
  ep->speed = (unsigned short )speed;
#line 118
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 119
  return;
}
}
#line 121 "include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 123
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 85 "include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 3038 "include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 3040
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
#line 3040
  return (tmp == 0);
}
}
#line 2210 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool check_privilege(struct be_adapter *adapter , u32 flags ) 
{ 


  {
#line 2212
  return ((adapter->cmd_privileges & flags) != 0U);
}
}
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_stats[37U]  = 
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
  {      {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2,
      4, 36}, 
        {{'r', 'x', '_', 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', '_', 's', 'y',
       'm', 'b', 'o', 'l', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2, 4, 40}, 
        {{'r', 'x', '_', 'p', 'a', 'u', 's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's',
       '\000'}, 2, 4, 44}, 
        {{'r', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', '_', 'f', 'r', 'a', 'm',
       'e', 's', '\000'}, 2, 4, 52}, 
        {{'r', 'x', '_', 'i', 'n', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r', 'r',
       'o', 'r', 's', '\000'}, 2, 4, 56}, 
        {{'r', 'x', '_', 'o', 'u', 't', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 2, 4, 60}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 't', 'o', 'o', '_', 'l', 'o',
       'n', 'g', '\000'}, 2, 4, 64}, 
        {{'r', 'x', '_', 'a', 'd', 'd', 'r', 'e', 's', 's', '_', 'f', 'i', 'l', 't',
       'e', 'r', 'e', 'd', '\000'}, 2, 4, 68}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'm', 'a', 'l', 'l', '\000'}, 2, 4, 72}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'h', 'o', 'r', 't', '\000'}, 2, 4, 76}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'h', 'e', 'a', 'd',
       'e', 'r', '_', 't', 'o', 'o', '_', 's', 'm', 'a', 'l', 'l', '\000'}, 2, 4,
      80}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'c', 'p', '_',
       'l', 'e', 'n', 'g', 't', 'h', '\000'}, 2, 4, 84}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'r', 'u', 'n', 't',
       '\000'}, 2, 4, 88}, 
        {{'r', 'x', 'p', 'p', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 116}, 
        {{'r', 'x', '_', 'i', 'n', 'p', 'u', 't', '_', 'f', 'i', 'f', 'o', '_', 'o',
       'v', 'e', 'r', 'f', 'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4,
      120}, 
        {{'r', 'x', '_', 'i', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm', '_',
       'e', 'r', 'r', 's', '\000'}, 2, 4, 92}, 
        {{'r', 'x', '_', 't', 'c', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 96}, 
        {{'r', 'x', '_', 'u', 'd', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 100}, 
        {{'t', 'x', '_', 'p', 'a', 'u', 's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 104}, 
        {{'t', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', 'f', 'r', 'a', 'm', 'e',
       's', '\000'}, 2, 4, 112}, 
        {{'r', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 48}, 
        {{'t', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 108}, 
        {{'p', 'm', 'e', 'm', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 124}, 
        {{'j', 'a', 'b', 'b', 'e', 'r', '_', 'e', 'v', 'e', 'n', 't', 's', '\000'}, 2,
      4, 128}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'p', 'b', 'u',
       'f', '\000'}, 2, 4, 8}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'e', 'r', 'x',
       '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 't', 'p', 'r',
       'e', '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 20}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 't', 'o', 'o', '_', 'm', 'a',
       'n', 'y', '_', 'f', 'r', 'a', 'g', 's', '\000'}, 2, 4, 24}, 
        {{'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'd', '_', 'p', 'a', 'c', 'k', 'e',
       't', 's', '\000'}, 2, 4, 28}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'm', 't', 'u', '\000'}, 2, 4,
      32}, 
        {{'d', 'm', 'a', '_', 'm', 'a', 'p', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      2, 4, 4}, 
        {{'e', 't', 'h', '_', 'r', 'e', 'd', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 2,
      4, 0}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'l',
       's', 'd', '\000'}, 2, 4, 132}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'm',
       's', 'd', '\000'}, 2, 4, 136}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 140}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'p', 'a', 'y', 'l',
       'o', 'a', 'd', '_', 'l', 'e', 'n', '\000'}, 2, 4, 144}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'c', 'r', 'c', '\000'},
      2, 4, 148}};
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_rx_stats[8U]  = 
#line 138
  {      {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 1, 8, 0}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '\000'}, 1, 8, 8}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 1, 4, 28}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '_', 'e', 'r', 'r', '\000'}, 1, 4,
      36}, 
        {{'r', 'x', '_', 'm', 'c', 'a', 's', 't', '_', 'p', 'k', 't', 's', '\000'}, 1,
      4, 32}, 
        {{'r', 'x', '_', 'p', 'o', 's', 't', '_', 'f', 'a', 'i', 'l', '\000'}, 1, 4,
      24}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 's', 'k', 'b',
       's', '\000'}, 1, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'f', 'r', 'a',
       'g', 's', '\000'}, 1, 4, 20}};
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_tx_stats[12U]  = 
#line 161
  {      {{'t', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 0, 8, 24}, 
        {{'t', 'x', '_', 'h', 'd', 'r', '_', 'p', 'a', 'r', 's', 'e', '_', 'e', 'r',
       'r', '\000'}, 0, 4, 48}, 
        {{'t', 'x', '_', 'd', 'm', 'a', '_', 'e', 'r', 'r', '\000'}, 0, 4, 52}, 
        {{'t', 'x', '_', 's', 'p', 'o', 'o', 'f', '_', 'c', 'h', 'e', 'c', 'k', '_',
       'e', 'r', 'r', '\000'}, 0, 4, 60}, 
        {{'t', 'x', '_', 't', 's', 'o', '_', 'e', 'r', 'r', '\000'}, 0, 4, 56}, 
        {{'t', 'x', '_', 'q', 'i', 'n', 'q', '_', 'e', 'r', 'r', '\000'}, 0, 4, 64}, 
        {{'t', 'x', '_', 'i', 'n', 't', 'e', 'r', 'n', 'a', 'l', '_', 'p', 'a', 'r',
       'i', 't', 'y', '_', 'e', 'r', 'r', '\000'}, 0, 4, 68}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'k', 't', 's', '\000'}, 0, 8, 8}, 
        {{'t', 'x', '_', 'r', 'e', 'q', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 's', 't', 'o', 'p', 's', '\000'}, 0, 4, 40}, 
        {{'t', 'x', '_', 'd', 'r', 'v', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 0, 4,
      44}};
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static char const   et_self_tests[5U][32U]  = { {        'M',        'A',        'C',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'P',        'H',        'Y',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'E',        'x',        't',        'e', 
            'r',        'n',        'a',        'l', 
            ' ',        'L',        'o',        'o', 
            'p',        'b',        'a',        'c', 
            'k',        ' ',        't',        'e', 
            's',        't',        '\000'}, 
   {        'D',        'D',        'R',        ' ', 
            'D',        'M',        'A',        ' ', 
            't',        'e',        's',        't', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}};
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 222
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 222
  adapter = (struct be_adapter *)tmp;
#line 224
  strlcpy((char *)(& drvinfo->driver), "be2net", 32UL);
#line 225
  strlcpy((char *)(& drvinfo->version), "10.6.0.2", 32UL);
#line 226
  tmp___0 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)(& adapter->fw_on_flash),
                   32UL);
#line 226
  if (tmp___0 == 0) {
#line 227
    strlcpy((char *)(& drvinfo->fw_version), (char const   *)(& adapter->fw_ver),
            32UL);
  } else {
#line 230
    snprintf((char *)(& drvinfo->fw_version), 32UL, "%s [%s]", (char *)(& adapter->fw_ver),
             (char *)(& adapter->fw_on_flash));
  }
#line 233
  tmp___1 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 233
  strlcpy((char *)(& drvinfo->bus_info), tmp___1, 32UL);
#line 235
  drvinfo->testinfo_len = 0U;
#line 236
  drvinfo->regdump_len = 0U;
#line 237
  drvinfo->eedump_len = 0U;
#line 238
  return;
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 lancer_cmd_get_file_len(struct be_adapter *adapter , u8 *file_name ) 
{ 
  u32 data_read ;
  u32 eof ;
  u8 addn_status ;
  struct be_dma_mem data_len_cmd ;
  int status ;

  {
#line 242
  data_read = 0U;
#line 247
  memset((void *)(& data_len_cmd), 0, 24UL);
#line 249
  status = lancer_cmd_read_object(adapter, & data_len_cmd, 0U, 0U, (char const   *)file_name,
                                  & data_read, & eof, & addn_status);
#line 253
  return (data_read);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int lancer_cmd_read_file(struct be_adapter *adapter , u8 *file_name , u32 buf_len ,
                                void *buf ) 
{ 
  struct be_dma_mem read_cmd ;
  u32 read_len ;
  u32 total_read_len ;
  u32 chunk_size ;
  u32 eof ;
  u8 addn_status ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;

  {
#line 260
  read_len = 0U;
#line 260
  total_read_len = 0U;
#line 261
  eof = 0U;
#line 263
  status = 0;
#line 265
  read_cmd.size = 32768U;
#line 266
  read_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )read_cmd.size,
                                    & read_cmd.dma, 32U);
#line 269
  if ((unsigned long )read_cmd.va == (unsigned long )((void *)0)) {
#line 270
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while reading dump\n");
#line 272
    return (-12);
  } else {

  }
#line 275
  goto ldv_57197;
  ldv_57196: 
#line 276
  __min1 = buf_len - total_read_len;
#line 276
  __min2 = 32768U;
#line 276
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 278
  chunk_size = (chunk_size + 3U) & 4294967292U;
#line 279
  status = lancer_cmd_read_object(adapter, & read_cmd, chunk_size, total_read_len,
                                  (char const   *)file_name, & read_len, & eof, & addn_status);
#line 282
  if (status == 0) {
#line 283
    memcpy(buf + (unsigned long )total_read_len, (void const   *)read_cmd.va, (size_t )read_len);
#line 284
    total_read_len = total_read_len + read_len;
#line 285
    eof = eof & 2147483648U;
  } else {
#line 287
    status = -5;
#line 288
    goto ldv_57195;
  }
  ldv_57197: ;
#line 275
  if (total_read_len < buf_len && eof == 0U) {
#line 277
    goto ldv_57196;
  } else {

  }
  ldv_57195: 
#line 291
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )read_cmd.size, read_cmd.va, read_cmd.dma,
                 (struct dma_attrs *)0);
#line 294
  return (status);
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_reg_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u32 log_size ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 299
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 299
  adapter = (struct be_adapter *)tmp;
#line 300
  log_size = 0U;
#line 302
  tmp___0 = check_privilege(adapter, 1792U);
#line 302
  if (tmp___0) {
#line 302
    tmp___1 = 0;
  } else {
#line 302
    tmp___1 = 1;
  }
#line 302
  if (tmp___1) {
#line 303
    return (0);
  } else {

  }
#line 305
  if ((unsigned int )adapter->virtfn == 0U) {
#line 306
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 307
      log_size = lancer_cmd_get_file_len(adapter, (u8 *)"/dbg/dump.bin");
    } else {
#line 310
      be_cmd_get_reg_len(adapter, & log_size);
    }
  } else {

  }
#line 312
  return ((int )log_size);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_regs(struct net_device *netdev , struct ethtool_regs *regs , void *buf ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 318
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 318
  adapter = (struct be_adapter *)tmp;
#line 320
  if ((unsigned int )adapter->virtfn == 0U) {
#line 321
    memset(buf, 0, (size_t )regs->len);
#line 322
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 323
      lancer_cmd_read_file(adapter, (u8 *)"/dbg/dump.bin", regs->len, buf);
    } else {
#line 326
      be_cmd_get_regs(adapter, regs->len, buf);
    }
  } else {

  }
#line 328
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;

  {
#line 333
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 333
  adapter = (struct be_adapter *)tmp;
#line 334
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 336
  et->rx_coalesce_usecs = aic->prev_eqd;
#line 337
  et->rx_coalesce_usecs_high = aic->max_eqd;
#line 338
  et->rx_coalesce_usecs_low = aic->min_eqd;
#line 340
  et->tx_coalesce_usecs = aic->prev_eqd;
#line 341
  et->tx_coalesce_usecs_high = aic->max_eqd;
#line 342
  et->tx_coalesce_usecs_low = aic->min_eqd;
#line 344
  et->use_adaptive_rx_coalesce = (__u32 )aic->enable;
#line 345
  et->use_adaptive_tx_coalesce = (__u32 )aic->enable;
#line 347
  return (0);
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  int i ;
  __u32 _min1 ;
  unsigned int _min2 ;
  __u32 _min1___0 ;
  u32 _min2___0 ;
  __u32 _min1___1 ;
  u32 _min2___1 ;
  u32 _max1 ;
  u32 _max2 ;

  {
#line 356
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 356
  adapter = (struct be_adapter *)tmp;
#line 357
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 361
  i = 0;
#line 361
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 361
  goto ldv_57236;
  ldv_57235: 
#line 362
  aic->enable = et->use_adaptive_rx_coalesce != 0U;
#line 363
  _min1 = et->rx_coalesce_usecs_high;
#line 363
  _min2 = 128U;
#line 363
  aic->max_eqd = _min1 < _min2 ? _min1 : _min2;
#line 364
  _min1___0 = et->rx_coalesce_usecs_low;
#line 364
  _min2___0 = aic->max_eqd;
#line 364
  aic->min_eqd = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 365
  _min1___1 = et->rx_coalesce_usecs;
#line 365
  _min2___1 = aic->max_eqd;
#line 365
  aic->et_eqd = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 366
  _max1 = aic->et_eqd;
#line 366
  _max2 = aic->min_eqd;
#line 366
  aic->et_eqd = _max1 > _max2 ? _max1 : _max2;
#line 367
  aic = aic + 1;
#line 361
  i = i + 1;
#line 361
  eqo = eqo + 1;
  ldv_57236: ;
#line 361
  if ((int )adapter->num_evt_qs > i) {
#line 363
    goto ldv_57235;
  } else {

  }

#line 375
  if (et->use_adaptive_rx_coalesce == 0U && ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U)) {
#line 376
    be_eqd_update(adapter, 1);
  } else {

  }
#line 378
  return (0);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                 uint64_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  void *p ;
  unsigned int i ;
  unsigned int j ;
  unsigned int base ;
  unsigned int start ;
  struct be_rx_stats *stats___0 ;
  bool tmp___0 ;
  struct be_tx_stats *stats___1 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 384
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 384
  adapter = (struct be_adapter *)tmp;
#line 388
  base = 0U;
#line 390
  i = 0U;
#line 390
  goto ldv_57254;
  ldv_57253: 
#line 391
  p = (void *)(& adapter->drv_stats) + (unsigned long )et_stats[i].offset;
#line 392
  *(data + (unsigned long )i) = (uint64_t )*((u32 *)p);
#line 390
  i = i + 1U;
  ldv_57254: ;
#line 390
  if (i <= 36U) {
#line 392
    goto ldv_57253;
  } else {

  }
#line 394
  base = base + 37U;
#line 396
  j = 0U;
#line 396
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 396
  goto ldv_57269;
  ldv_57268: 
#line 397
  stats___0 = & rxo->stats;
  ldv_57259: 
#line 400
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___0->sync));
#line 401
  *(data + (unsigned long )base) = stats___0->rx_bytes;
#line 402
  *(data + (unsigned long )(base + 1U)) = stats___0->rx_pkts;
#line 403
  tmp___0 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___0->sync),
                                      start);
#line 403
  if ((int )tmp___0) {
#line 405
    goto ldv_57259;
  } else {

  }
#line 405
  i = 2U;
#line 405
  goto ldv_57264;
  ldv_57263: 
#line 406
  p = (void *)stats___0 + (unsigned long )et_rx_stats[i].offset;
#line 407
  *(data + (unsigned long )(base + i)) = (uint64_t )*((u32 *)p);
#line 405
  i = i + 1U;
  ldv_57264: ;
#line 405
  if (i <= 7U) {
#line 407
    goto ldv_57263;
  } else {

  }
#line 409
  base = base + 8U;
#line 396
  j = j + 1U;
#line 396
  rxo = rxo + 1;
  ldv_57269: ;
#line 396
  if ((unsigned int )adapter->num_rx_qs > j) {
#line 398
    goto ldv_57268;
  } else {

  }
#line 412
  j = 0U;
#line 412
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )j;
#line 412
  goto ldv_57284;
  ldv_57283: 
#line 413
  stats___1 = & txo->stats;
  ldv_57272: 
#line 416
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___1->sync_compl));
#line 417
  *(data + (unsigned long )base) = stats___1->tx_compl;
#line 418
  tmp___1 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___1->sync_compl),
                                      start);
#line 418
  if ((int )tmp___1) {
#line 420
    goto ldv_57272;
  } else {

  }

  ldv_57279: 
#line 421
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync  const  *)(& stats___1->sync));
#line 422
  i = 1U;
#line 422
  goto ldv_57277;
  ldv_57276: 
#line 423
  p = (void *)stats___1 + (unsigned long )et_tx_stats[i].offset;
#line 424
  *(data + (unsigned long )(base + i)) = et_tx_stats[i].size == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
#line 422
  i = i + 1U;
  ldv_57277: ;
#line 422
  if (i <= 11U) {
#line 424
    goto ldv_57276;
  } else {

  }
#line 428
  tmp___2 = u64_stats_fetch_retry_irq((struct u64_stats_sync  const  *)(& stats___1->sync),
                                      start);
#line 428
  if ((int )tmp___2) {
#line 430
    goto ldv_57279;
  } else {

  }
#line 429
  base = base + 12U;
#line 412
  j = j + 1U;
#line 412
  txo = txo + 1;
  ldv_57284: ;
#line 412
  if ((unsigned int )adapter->num_tx_qs > j) {
#line 414
    goto ldv_57283;
  } else {

  }

#line 419
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_stat_strings(struct net_device *netdev , uint32_t stringset , uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;

  {
#line 436
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 436
  adapter = (struct be_adapter *)tmp;
#line 439
  switch (stringset) {
  case 1U: 
#line 441
  i = 0;
#line 441
  goto ldv_57298;
  ldv_57297: 
#line 442
  memcpy((void *)data, (void const   *)(& et_stats[i].desc), 32UL);
#line 443
  data = data + 32UL;
#line 441
  i = i + 1;
  ldv_57298: ;
#line 441
  if ((unsigned int )i <= 36U) {
#line 443
    goto ldv_57297;
  } else {

  }
#line 445
  i = 0;
#line 445
  goto ldv_57306;
  ldv_57305: 
#line 446
  j = 0;
#line 446
  goto ldv_57303;
  ldv_57302: 
#line 447
  sprintf((char *)data, "rxq%d: %s", i, (char const   *)(& et_rx_stats[j].desc));
#line 449
  data = data + 32UL;
#line 446
  j = j + 1;
  ldv_57303: ;
#line 446
  if ((unsigned int )j <= 7U) {
#line 448
    goto ldv_57302;
  } else {

  }
#line 445
  i = i + 1;
  ldv_57306: ;
#line 445
  if ((int )adapter->num_rx_qs > i) {
#line 447
    goto ldv_57305;
  } else {

  }
#line 452
  i = 0;
#line 452
  goto ldv_57314;
  ldv_57313: 
#line 453
  j = 0;
#line 453
  goto ldv_57311;
  ldv_57310: 
#line 454
  sprintf((char *)data, "txq%d: %s", i, (char const   *)(& et_tx_stats[j].desc));
#line 456
  data = data + 32UL;
#line 453
  j = j + 1;
  ldv_57311: ;
#line 453
  if ((unsigned int )j <= 11U) {
#line 455
    goto ldv_57310;
  } else {

  }
#line 452
  i = i + 1;
  ldv_57314: ;
#line 452
  if ((int )adapter->num_tx_qs > i) {
#line 454
    goto ldv_57313;
  } else {

  }

#line 459
  goto ldv_57316;
  case 0U: 
#line 461
  i = 0;
#line 461
  goto ldv_57321;
  ldv_57320: 
#line 462
  memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i, 32UL);
#line 463
  data = data + 32UL;
#line 461
  i = i + 1;
  ldv_57321: ;
#line 461
  if ((unsigned int )i <= 4U) {
#line 463
    goto ldv_57320;
  } else {

  }

#line 465
  goto ldv_57316;
  }
  ldv_57316: ;
#line 468
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_sset_count(struct net_device *netdev , int stringset ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 471
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 471
  adapter = (struct be_adapter *)tmp;
#line 473
  switch (stringset) {
  case 0: ;
#line 475
  return (5);
  case 1: ;
#line 477
  return ((int )(((unsigned int )adapter->num_rx_qs * 8U + (unsigned int )adapter->num_tx_qs * 12U) + 37U));
  default: ;
#line 481
  return (-22);
  }
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_port_type(struct be_adapter *adapter ) 
{ 
  u32 port ;

  {
#line 489
  switch ((int )adapter->phy.interface_type) {
  case 7: ;
  case 8: ;
  case 9: 
#line 493
  port = 0U;
#line 494
  goto ldv_57346;
  case 3: ;
#line 496
  if (((int )adapter->phy.cable_type & 4) != 0) {
#line 497
    port = 5U;
  } else {
#line 499
    port = 3U;
  }
#line 500
  goto ldv_57346;
  case 10: ;
#line 502
  if (((int )adapter->phy.cable_type & 8) != 0) {
#line 503
    port = 5U;
  } else {
#line 505
    port = 3U;
  }
#line 506
  goto ldv_57346;
  case 1: ;
  case 2: 
#line 509
  port = 3U;
#line 510
  goto ldv_57346;
  case 6: 
#line 512
  port = 0U;
#line 513
  goto ldv_57346;
  default: 
#line 515
  port = 255U;
  }
  ldv_57346: ;
#line 518
  return (port);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 convert_to_et_setting(struct be_adapter *adapter , u32 if_speeds ) 
{ 
  u32 val ;

  {
#line 523
  val = 0U;
#line 525
  switch ((int )adapter->phy.interface_type) {
  case 7: ;
  case 8: ;
  case 9: 
#line 529
  val = val | 128U;
#line 530
  if ((if_speeds & 4U) != 0U) {
#line 531
    val = val | 32U;
  } else {

  }
#line 532
  if ((if_speeds & 2U) != 0U) {
#line 533
    val = val | 8U;
  } else {

  }
#line 534
  if ((int )if_speeds & 1) {
#line 535
    val = val | 2U;
  } else {

  }
#line 536
  goto ldv_57361;
  case 5: 
#line 538
  val = val | 65536U;
#line 539
  if ((if_speeds & 4U) != 0U) {
#line 540
    val = val | 131072U;
  } else {

  }
#line 541
  if ((if_speeds & 8U) != 0U) {
#line 542
    val = val | 262144U;
  } else {

  }
#line 543
  goto ldv_57361;
  case 12: 
#line 545
  val = val | 65536U;
#line 546
  if ((if_speeds & 8U) != 0U) {
#line 547
    val = val | 524288U;
  } else {

  }
#line 548
  if ((if_speeds & 16U) != 0U) {
#line 549
    val = val | 4194304U;
  } else {

  }
#line 550
  goto ldv_57361;
  case 4: 
#line 552
  val = val | 589824U;
#line 554
  goto ldv_57361;
  case 11: 
#line 556
  val = val | 65536U;
#line 557
  if ((if_speeds & 8U) != 0U) {
#line 558
    val = val | 524288U;
  } else {

  }
#line 559
  if ((if_speeds & 32U) != 0U) {
#line 560
    val = val | 8388608U;
  } else {

  }
#line 561
  goto ldv_57361;
  case 10: ;
#line 563
  if ((if_speeds & 32U) != 0U) {
#line 564
    switch ((int )adapter->phy.cable_type) {
    case 8: 
#line 566
    val = val | 16777216U;
#line 567
    goto ldv_57368;
    case 2: 
#line 569
    val = val | 67108864U;
#line 570
    goto ldv_57368;
    default: 
#line 572
    val = val | 33554432U;
#line 573
    goto ldv_57368;
    }
    ldv_57368: ;
  } else {

  }
  case 3: ;
  case 1: ;
  case 2: 
#line 579
  val = val | 1024U;
#line 580
  if ((if_speeds & 8U) != 0U) {
#line 581
    val = val | 4096U;
  } else {

  }
#line 582
  if ((if_speeds & 4U) != 0U) {
#line 583
    val = val | 32U;
  } else {

  }
#line 584
  goto ldv_57361;
  case 6: 
#line 586
  val = val | 128U;
#line 587
  if ((if_speeds & 8U) != 0U) {
#line 588
    val = val | 4096U;
  } else {

  }
#line 589
  if ((if_speeds & 4U) != 0U) {
#line 590
    val = val | 32U;
  } else {

  }
#line 591
  if ((if_speeds & 2U) != 0U) {
#line 592
    val = val | 8U;
  } else {

  }
#line 593
  goto ldv_57361;
  default: 
#line 595
  val = val | 128U;
  }
  ldv_57361: ;
#line 598
  return (val);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
bool be_pause_supported(struct be_adapter *adapter ) 
{ 


  {
#line 603
  return ((bool )((unsigned int )adapter->phy.interface_type != 3U && (unsigned int )adapter->phy.interface_type != 1U));
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 link_status ;
  u16 link_speed ;
  int status ;
  u32 auto_speeds ;
  u32 fixed_speeds ;
  u32 tmp___0 ;
  bool tmp___1 ;
  __u32 tmp___2 ;
  bool tmp___3 ;

  {
#line 610
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 610
  adapter = (struct be_adapter *)tmp;
#line 612
  link_speed = 0U;
#line 617
  if (adapter->phy.link_speed < 0) {
#line 618
    status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
#line 620
    if (status == 0) {
#line 621
      be_link_status_update(adapter, (int )link_status);
    } else {

    }
#line 622
    ethtool_cmd_speed_set(ecmd, (__u32 )link_speed);
#line 624
    status = be_cmd_get_phy_info(adapter);
#line 625
    if (status == 0) {
#line 626
      auto_speeds = (u32 )adapter->phy.auto_speeds_supported;
#line 627
      fixed_speeds = (u32 )adapter->phy.fixed_speeds_supported;
#line 629
      be_cmd_query_cable_type(adapter);
#line 631
      ecmd->supported = convert_to_et_setting(adapter, auto_speeds | fixed_speeds);
#line 635
      ecmd->advertising = convert_to_et_setting(adapter, auto_speeds);
#line 638
      tmp___0 = be_get_port_type(adapter);
#line 638
      ecmd->port = (__u8 )tmp___0;
#line 640
      if ((unsigned int )adapter->phy.auto_speeds_supported != 0U) {
#line 641
        ecmd->supported = ecmd->supported | 64U;
#line 642
        ecmd->autoneg = 1U;
#line 643
        ecmd->advertising = ecmd->advertising | 64U;
      } else {

      }
#line 646
      ecmd->supported = ecmd->supported | 8192U;
#line 647
      tmp___1 = be_pause_supported(adapter);
#line 647
      if ((int )tmp___1) {
#line 648
        ecmd->advertising = ecmd->advertising | 8192U;
      } else {

      }
#line 650
      switch ((int )adapter->phy.interface_type) {
      case 4: ;
      case 5: 
#line 653
      ecmd->transceiver = 0U;
#line 654
      goto ldv_57391;
      default: 
#line 656
      ecmd->transceiver = 1U;
#line 657
      goto ldv_57391;
      }
      ldv_57391: ;
    } else {
#line 660
      ecmd->port = 255U;
#line 661
      ecmd->autoneg = 0U;
#line 662
      ecmd->transceiver = 2U;
    }
#line 666
    tmp___2 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 666
    adapter->phy.link_speed = (int )tmp___2;
#line 667
    adapter->phy.port_type = ecmd->port;
#line 668
    adapter->phy.transceiver = ecmd->transceiver;
#line 669
    adapter->phy.autoneg = ecmd->autoneg;
#line 670
    adapter->phy.advertising = ecmd->advertising;
#line 671
    adapter->phy.supported = ecmd->supported;
  } else {
#line 673
    ethtool_cmd_speed_set(ecmd, (__u32 )adapter->phy.link_speed);
#line 674
    ecmd->port = adapter->phy.port_type;
#line 675
    ecmd->transceiver = adapter->phy.transceiver;
#line 676
    ecmd->autoneg = adapter->phy.autoneg;
#line 677
    ecmd->advertising = adapter->phy.advertising;
#line 678
    ecmd->supported = adapter->phy.supported;
  }
#line 681
  tmp___3 = netif_carrier_ok((struct net_device  const  *)netdev);
#line 681
  ecmd->duplex = (int )tmp___3 ? 1U : 255U;
#line 682
  ecmd->phy_address = (__u8 )adapter->port_num;
#line 684
  return (0);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 690
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 690
  adapter = (struct be_adapter *)tmp;
#line 692
  ring->rx_max_pending = (__u32 )adapter->rx_obj[0].q.len;
#line 693
  ring->rx_pending = (__u32 )adapter->rx_obj[0].q.len;
#line 694
  ring->tx_max_pending = (__u32 )adapter->tx_obj[0].q.len;
#line 695
  ring->tx_pending = (__u32 )adapter->tx_obj[0].q.len;
#line 696
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 701
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 701
  adapter = (struct be_adapter *)tmp;
#line 703
  be_cmd_get_flow_control(adapter, & ecmd->tx_pause, & ecmd->rx_pause);
#line 704
  ecmd->autoneg = (__u32 )adapter->phy.fc_autoneg;
#line 705
  return;
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 710
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 710
  adapter = (struct be_adapter *)tmp;
#line 713
  if (ecmd->autoneg != (__u32 )adapter->phy.fc_autoneg) {
#line 714
    return (-22);
  } else {

  }
#line 716
  status = be_cmd_set_flow_control(adapter, ecmd->tx_pause, ecmd->rx_pause);
#line 718
  if (status != 0) {
#line 719
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Pause param set failed\n");
#line 720
    return (status <= 0 ? status : -5);
  } else {

  }
#line 723
  adapter->tx_fc = ecmd->tx_pause;
#line 724
  adapter->rx_fc = ecmd->rx_pause;
#line 725
  return (0);
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 731
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 731
  adapter = (struct be_adapter *)tmp;
#line 733
  switch ((unsigned int )state) {
  case 1U: 
#line 735
  be_cmd_get_beacon_state(adapter, (int )adapter->hba_port_num, & adapter->beacon_state);
#line 737
  return (1);
  case 2U: 
#line 740
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 1);
#line 742
  goto ldv_57416;
  case 3U: 
#line 745
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 0);
#line 747
  goto ldv_57416;
  case 0U: 
#line 750
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, (int )((u8 )adapter->beacon_state));
  }
  ldv_57416: ;
#line 754
  return (0);
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_dump(struct net_device *netdev , struct ethtool_dump *dump ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 759
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 759
  adapter = (struct be_adapter *)tmp;
#line 760
  dev = & (adapter->pdev)->dev;
#line 763
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 765
    return (-95);
  } else {
#line 763
    tmp___0 = check_privilege(adapter, 1792U);
#line 763
    if (tmp___0) {
#line 763
      tmp___1 = 0;
    } else {
#line 763
      tmp___1 = 1;
    }
#line 763
    if (tmp___1) {
#line 765
      return (-95);
    } else {

    }
  }
#line 767
  switch (dump->flag) {
  case 1U: 
#line 769
  status = lancer_initiate_dump(adapter);
#line 770
  if (status == 0) {
#line 771
    _dev_info((struct device  const  *)dev, "FW dump initiated successfully\n");
  } else {

  }
#line 772
  goto ldv_57427;
  case 2U: 
#line 774
  status = lancer_delete_dump(adapter);
#line 775
  if (status == 0) {
#line 776
    _dev_info((struct device  const  *)dev, "FW dump deleted successfully\n");
  } else {

  }
#line 777
  goto ldv_57427;
  default: 
#line 779
  dev_err((struct device  const  *)dev, "Invalid dump level: 0x%x\n", dump->flag);
#line 780
  return (-22);
  }
  ldv_57427: ;
#line 782
  return (status);
}
}
#line 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 787
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 787
  adapter = (struct be_adapter *)tmp;
#line 789
  if ((int )adapter->wol_cap & 1) {
#line 790
    wol->supported = wol->supported | 32U;
#line 791
    if ((int )adapter->wol_en) {
#line 792
      wol->wolopts = wol->wolopts | 32U;
    } else {

    }
  } else {
#line 794
    wol->wolopts = 0U;
  }
#line 796
  memset((void *)(& wol->sopass), 0, 6UL);
#line 797
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 801
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 801
  adapter = (struct be_adapter *)tmp;
#line 803
  if ((wol->wolopts & 4294967263U) != 0U) {
#line 804
    return (-95);
  } else {

  }
#line 806
  if (((int )adapter->wol_cap & 1) == 0) {
#line 807
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "WOL not supported\n");
#line 808
    return (-95);
  } else {

  }
#line 811
  if ((wol->wolopts & 32U) != 0U) {
#line 812
    adapter->wol_en = 1;
  } else {
#line 814
    adapter->wol_en = 0;
  }
#line 816
  return (0);
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_test_ddr_dma(struct be_adapter *adapter ) 
{ 
  int ret ;
  int i ;
  struct be_dma_mem ddrdma_cmd ;
  u64 pattern[2U] ;

  {
#line 823
  pattern[0] = 6510615555426900570ULL;
#line 823
  pattern[1] = 0xa5a5a5a5a5a5a5a5ULL;
#line 827
  ddrdma_cmd.size = 8224U;
#line 828
  ddrdma_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size,
                                      & ddrdma_cmd.dma, 208U);
#line 831
  if ((unsigned long )ddrdma_cmd.va == (unsigned long )((void *)0)) {
#line 832
    return (-12);
  } else {

  }
#line 834
  i = 0;
#line 834
  goto ldv_57449;
  ldv_57448: 
#line 835
  ret = be_cmd_ddr_dma_test(adapter, pattern[i], 4096U, & ddrdma_cmd);
#line 837
  if (ret != 0) {
#line 838
    goto err;
  } else {

  }
#line 834
  i = i + 1;
  ldv_57449: ;
#line 834
  if (i <= 1) {
#line 836
    goto ldv_57448;
  } else {

  }

  err: 
#line 842
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size, ddrdma_cmd.va,
                 ddrdma_cmd.dma, (struct dma_attrs *)0);
#line 844
  return (ret <= 0 ? ret : -5);
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u64 be_loopback_test(struct be_adapter *adapter , u8 loopback_type , u64 *status ) 
{ 
  int tmp ;

  {
#line 850
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, (int )loopback_type, 1);
#line 851
  tmp = be_cmd_loopback_test(adapter, (u32 )adapter->hba_port_num, (u32 )loopback_type,
                             1500U, 2U, 2748ULL);
#line 851
  *status = (u64 )tmp;
#line 853
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, 255, 1);
#line 854
  return (*status);
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_self_test(struct net_device *netdev , struct ethtool_test *test , u64 *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 link_status ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  int tmp___3 ;

  {
#line 860
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 860
  adapter = (struct be_adapter *)tmp;
#line 862
  link_status = 0U;
#line 864
  if ((adapter->function_caps & 64U) != 0U) {
#line 865
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Self test not supported\n");
#line 866
    test->flags = test->flags | 2U;
#line 867
    return;
  } else {

  }
#line 870
  memset((void *)data, 0, 40UL);
#line 872
  if ((int )test->flags & 1) {
#line 873
    tmp___0 = be_loopback_test(adapter, 0, data);
#line 873
    if (tmp___0 != 0ULL) {
#line 874
      test->flags = test->flags | 2U;
    } else {

    }
#line 876
    tmp___1 = be_loopback_test(adapter, 1, data + 1UL);
#line 876
    if (tmp___1 != 0ULL) {
#line 877
      test->flags = test->flags | 2U;
    } else {

    }
#line 879
    if ((test->flags & 4U) != 0U) {
#line 880
      tmp___2 = be_loopback_test(adapter, 2, data + 2UL);
#line 880
      if (tmp___2 != 0ULL) {
#line 882
        test->flags = test->flags | 2U;
      } else {

      }
#line 883
      test->flags = test->flags | 8U;
    } else {

    }
  } else {

  }
#line 887
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 887
    tmp___3 = be_test_ddr_dma(adapter);
#line 887
    if (tmp___3 != 0) {
#line 888
      *(data + 3UL) = 1ULL;
#line 889
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
#line 892
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
#line 893
  if (status != 0) {
#line 894
    test->flags = test->flags | 2U;
#line 895
    *(data + 4UL) = 0xffffffffffffffffULL;
  } else
#line 896
  if ((unsigned int )link_status == 0U) {
#line 897
    test->flags = test->flags | 2U;
#line 898
    *(data + 4UL) = 1ULL;
  } else {

  }
#line 900
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_do_flash(struct net_device *netdev , struct ethtool_flash *efl ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 904
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 904
  adapter = (struct be_adapter *)tmp;
#line 906
  tmp___0 = be_load_fw(adapter, (u8 *)(& efl->data));
#line 906
  return (tmp___0);
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
#line 911
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 911
  adapter = (struct be_adapter *)tmp;
#line 913
  tmp___0 = check_privilege(adapter, 1792U);
#line 913
  if (tmp___0) {
#line 913
    tmp___1 = 0;
  } else {
#line 913
    tmp___1 = 1;
  }
#line 913
  if (tmp___1) {
#line 914
    return (0);
  } else {

  }
#line 916
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 917
    if ((unsigned int )adapter->virtfn == 0U) {
#line 918
      tmp___2 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_pf.vpd");
#line 918
      return ((int )tmp___2);
    } else {
#line 921
      tmp___3 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_vf.vpd");
#line 921
      return ((int )tmp___3);
    }
  } else {
#line 924
    return (1024);
  }
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_read_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                          uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_dma_mem eeprom_cmd ;
  struct be_cmd_resp_seeprom_read *resp ;
  int status ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 931
  adapter = (struct be_adapter *)tmp;
#line 936
  if (eeprom->len == 0U) {
#line 937
    return (-22);
  } else {

  }
#line 939
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 940
    if ((unsigned int )adapter->virtfn == 0U) {
#line 941
      tmp___0 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_pf.vpd", eeprom->len,
                                     (void *)data);
#line 941
      return (tmp___0);
    } else {
#line 944
      tmp___1 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_vf.vpd", eeprom->len,
                                     (void *)data);
#line 944
      return (tmp___1);
    }
  } else {

  }
#line 948
  eeprom->magic = (__u32 )(((int )(adapter->pdev)->device << 16) | 6562);
#line 950
  memset((void *)(& eeprom_cmd), 0, 24UL);
#line 951
  eeprom_cmd.size = 1040U;
#line 952
  eeprom_cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size,
                                      & eeprom_cmd.dma, 208U);
#line 956
  if ((unsigned long )eeprom_cmd.va == (unsigned long )((void *)0)) {
#line 957
    return (-12);
  } else {

  }
#line 959
  status = be_cmd_get_seeprom_data(adapter, & eeprom_cmd);
#line 961
  if (status == 0) {
#line 962
    resp = (struct be_cmd_resp_seeprom_read *)eeprom_cmd.va;
#line 963
    memcpy((void *)data, (void const   *)(& resp->seeprom_data) + (unsigned long )eeprom->offset,
             (size_t )eeprom->len);
  } else {

  }
#line 965
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size, eeprom_cmd.va,
                 eeprom_cmd.dma, (struct dma_attrs *)0);
#line 968
  return (status <= 0 ? status : -5);
}
}
#line 971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_msg_level(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 973
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 973
  adapter = (struct be_adapter *)tmp;
#line 975
  return (adapter->msg_enable);
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_set_msg_level(struct net_device *netdev , u32 level ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 980
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 980
  adapter = (struct be_adapter *)tmp;
#line 982
  if (adapter->msg_enable == level) {
#line 983
    return;
  } else {

  }
#line 985
  if (((adapter->msg_enable ^ level) & 8192U) != 0U) {
#line 986
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 987
      be_cmd_set_fw_log_level(adapter, (level & 8192U) != 0U ? 48U : 64U);
    } else {

    }
  } else {

  }
#line 990
  adapter->msg_enable = level;
#line 991
  return;
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u64 be_get_rss_hash_opts(struct be_adapter *adapter , u64 flow_type ) 
{ 
  u64 data ;

  {
#line 995
  data = 0ULL;
#line 997
  switch (flow_type) {
  case 1ULL: ;
#line 999
  if ((int )adapter->rss_info.rss_flags & 1) {
#line 1000
    data = data | 48ULL;
  } else {

  }
#line 1001
  if ((adapter->rss_info.rss_flags & 2ULL) != 0ULL) {
#line 1002
    data = data | 192ULL;
  } else {

  }
#line 1003
  goto ldv_57499;
  case 2ULL: ;
#line 1005
  if ((int )adapter->rss_info.rss_flags & 1) {
#line 1006
    data = data | 48ULL;
  } else {

  }
#line 1007
  if ((adapter->rss_info.rss_flags & 16ULL) != 0ULL) {
#line 1008
    data = data | 192ULL;
  } else {

  }
#line 1009
  goto ldv_57499;
  case 5ULL: ;
#line 1011
  if ((adapter->rss_info.rss_flags & 4ULL) != 0ULL) {
#line 1012
    data = data | 48ULL;
  } else {

  }
#line 1013
  if ((adapter->rss_info.rss_flags & 8ULL) != 0ULL) {
#line 1014
    data = data | 192ULL;
  } else {

  }
#line 1015
  goto ldv_57499;
  case 6ULL: ;
#line 1017
  if ((adapter->rss_info.rss_flags & 4ULL) != 0ULL) {
#line 1018
    data = data | 48ULL;
  } else {

  }
#line 1019
  if ((adapter->rss_info.rss_flags & 32ULL) != 0ULL) {
#line 1020
    data = data | 192ULL;
  } else {

  }
#line 1021
  goto ldv_57499;
  }
  ldv_57499: ;
#line 1024
  return (data);
}
}
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1030
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1030
  adapter = (struct be_adapter *)tmp;
#line 1032
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1032
  if (tmp___0) {
#line 1032
    tmp___1 = 0;
  } else {
#line 1032
    tmp___1 = 1;
  }
#line 1032
  if (tmp___1) {
#line 1033
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::get_rxnfc: RX flow hashing is disabled\n");
#line 1035
    return (-22);
  } else {

  }
#line 1038
  switch (cmd->cmd) {
  case 41U: 
#line 1040
  cmd->data = be_get_rss_hash_opts(adapter, (u64 )cmd->flow_type);
#line 1041
  goto ldv_57510;
  case 45U: 
#line 1043
  cmd->data = (__u64 )((int )adapter->num_rx_qs + -1);
#line 1044
  goto ldv_57510;
  default: ;
#line 1046
  return (-22);
  }
  ldv_57510: ;
#line 1049
  return (0);
}
}
#line 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_rss_hash_opts(struct be_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_rx_obj *rxo ;
  int status ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  u32 rss_flags ;
  bool tmp ;

  {
#line 1056
  status = 0;
#line 1058
  rss_flags = (u32 )adapter->rss_info.rss_flags;
#line 1060
  if (cmd->data != 48ULL && cmd->data != 240ULL) {
#line 1062
    return (-22);
  } else {

  }
#line 1064
  switch (cmd->flow_type) {
  case 1U: ;
#line 1066
  if (cmd->data == 48ULL) {
#line 1067
    rss_flags = rss_flags & 4294967293U;
  } else
#line 1068
  if (cmd->data == 240ULL) {
#line 1069
    rss_flags = rss_flags | 3U;
  } else {

  }
#line 1071
  goto ldv_57524;
  case 5U: ;
#line 1073
  if (cmd->data == 48ULL) {
#line 1074
    rss_flags = rss_flags & 4294967287U;
  } else
#line 1075
  if (cmd->data == 240ULL) {
#line 1076
    rss_flags = rss_flags | 12U;
  } else {

  }
#line 1078
  goto ldv_57524;
  case 2U: ;
#line 1080
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1082
    return (-22);
  } else {

  }
#line 1084
  if (cmd->data == 48ULL) {
#line 1085
    rss_flags = rss_flags & 4294967279U;
  } else
#line 1086
  if (cmd->data == 240ULL) {
#line 1087
    rss_flags = rss_flags | 17U;
  } else {

  }
#line 1089
  goto ldv_57524;
  case 6U: ;
#line 1091
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1093
    return (-22);
  } else {

  }
#line 1095
  if (cmd->data == 48ULL) {
#line 1096
    rss_flags = rss_flags & 4294967263U;
  } else
#line 1097
  if (cmd->data == 240ULL) {
#line 1098
    rss_flags = rss_flags | 36U;
  } else {

  }
#line 1100
  goto ldv_57524;
  default: ;
#line 1102
  return (-22);
  }
  ldv_57524: ;
#line 1105
  if ((u64 )rss_flags == adapter->rss_info.rss_flags) {
#line 1106
    return (status);
  } else {

  }
#line 1108
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1108
  if ((int )tmp) {
#line 1109
    j = 0;
#line 1109
    goto ldv_57533;
    ldv_57532: 
#line 1110
    i = 0;
#line 1110
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 1110
    goto ldv_57531;
    ldv_57530: ;
#line 1111
    if (j + i > 127) {
#line 1112
      goto ldv_57529;
    } else {

    }
#line 1113
    rsstable[j + i] = rxo->rss_id;
#line 1110
    i = i + 1;
#line 1110
    rxo = rxo + 1;
    ldv_57531: ;
#line 1110
    if ((int )adapter->num_rss_qs > i) {
#line 1112
      goto ldv_57530;
    } else {

    }
    ldv_57529: 
#line 1109
    j = (int )adapter->num_rss_qs + j;
    ldv_57533: ;
#line 1109
    if (j <= 127) {
#line 1111
      goto ldv_57532;
    } else {

    }

  } else {

  }
#line 1118
  status = be_cmd_rss_config(adapter, (u8 *)(& adapter->rss_info.rsstable), rss_flags,
                             128, (u8 const   *)(& adapter->rss_info.rss_hkey));
#line 1120
  if (status == 0) {
#line 1121
    adapter->rss_info.rss_flags = (u64 )rss_flags;
  } else {

  }
#line 1123
  return (status <= 0 ? status : -5);
}
}
#line 1126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1128
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1128
  adapter = (struct be_adapter *)tmp;
#line 1129
  status = 0;
#line 1131
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1131
  if (tmp___0) {
#line 1131
    tmp___1 = 0;
  } else {
#line 1131
    tmp___1 = 1;
  }
#line 1131
  if (tmp___1) {
#line 1132
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::set_rxnfc: RX flow hashing is disabled\n");
#line 1134
    return (-22);
  } else {

  }
#line 1137
  switch (cmd->cmd) {
  case 42U: 
#line 1139
  status = be_set_rss_hash_opts(adapter, cmd);
#line 1140
  goto ldv_57542;
  default: ;
#line 1142
  return (-22);
  }
  ldv_57542: ;
#line 1145
  return (status);
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 tmp___0 ;

  {
#line 1151
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1151
  adapter = (struct be_adapter *)tmp;
#line 1153
  ch->combined_count = (__u32 )adapter->num_evt_qs;
#line 1154
  tmp___0 = be_max_qs(adapter);
#line 1154
  ch->max_combined = (__u32 )tmp___0;
#line 1155
  return;
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u16 tmp___0 ;

  {
#line 1160
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1160
  adapter = (struct be_adapter *)tmp;
#line 1163
  if (((ch->rx_count != 0U || ch->tx_count != 0U) || ch->other_count != 0U) || ch->combined_count == 0U) {
#line 1165
    return (-22);
  } else {
#line 1163
    tmp___0 = be_max_qs(adapter);
#line 1163
    if (ch->combined_count > (__u32 )tmp___0) {
#line 1165
      return (-22);
    } else {

    }
  }
#line 1167
  adapter->cfg_num_qs = (u16 )ch->combined_count;
#line 1169
  status = be_update_queues(adapter);
#line 1170
  return (status <= 0 ? status : -5);
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_rxfh_indir_size(struct net_device *netdev ) 
{ 


  {
#line 1175
  return (128U);
}
}
#line 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_rxfh_key_size(struct net_device *netdev ) 
{ 


  {
#line 1180
  return (40U);
}
}
#line 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_rxfh(struct net_device *netdev , u32 *indir , u8 *hkey , u8 *hfunc ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  struct rss_info *rss ;

  {
#line 1186
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1186
  adapter = (struct be_adapter *)tmp;
#line 1188
  rss = & adapter->rss_info;
#line 1190
  if ((unsigned long )indir != (unsigned long )((u32 *)0U)) {
#line 1191
    i = 0;
#line 1191
    goto ldv_57571;
    ldv_57570: 
#line 1192
    *(indir + (unsigned long )i) = (u32 )rss->rss_queue[i];
#line 1191
    i = i + 1;
    ldv_57571: ;
#line 1191
    if (i <= 127) {
#line 1193
      goto ldv_57570;
    } else {

    }

  } else {

  }
#line 1195
  if ((unsigned long )hkey != (unsigned long )((u8 *)0U)) {
#line 1196
    memcpy((void *)hkey, (void const   *)(& rss->rss_hkey), 40UL);
  } else {

  }
#line 1198
  if ((unsigned long )hfunc != (unsigned long )((u8 *)0U)) {
#line 1199
    *hfunc = 1U;
  } else {

  }
#line 1201
  return (0);
}
}
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_rxfh(struct net_device *netdev , u32 const   *indir , u8 const   *hkey ,
                       u8 const   hfunc ) 
{ 
  int rc ;
  int i ;
  int j ;
  struct be_adapter *adapter ;
  void *tmp ;
  u8 rsstable[128U] ;
  struct be_rx_obj *rxo ;

  {
#line 1207
  rc = 0;
#line 1208
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1208
  adapter = (struct be_adapter *)tmp;
#line 1212
  if ((unsigned int )((unsigned char )hfunc) != 0U && (unsigned int )((unsigned char )hfunc) != 1U) {
#line 1213
    return (-95);
  } else {

  }
#line 1215
  if ((unsigned long )indir != (unsigned long )((u32 const   *)0U)) {
#line 1218
    i = 0;
#line 1218
    goto ldv_57586;
    ldv_57585: 
#line 1219
    j = (int )*(indir + (unsigned long )i);
#line 1220
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 1221
    rsstable[i] = rxo->rss_id;
#line 1222
    adapter->rss_info.rss_queue[i] = (u8 )j;
#line 1218
    i = i + 1;
    ldv_57586: ;
#line 1218
    if (i <= 127) {
#line 1220
      goto ldv_57585;
    } else {

    }

  } else {
#line 1225
    memcpy((void *)(& rsstable), (void const   *)(& adapter->rss_info.rsstable),
             128UL);
  }
#line 1229
  if ((unsigned long )hkey == (unsigned long )((u8 const   *)0U)) {
#line 1230
    hkey = (u8 const   *)(& adapter->rss_info.rss_hkey);
  } else {

  }
#line 1232
  rc = be_cmd_rss_config(adapter, (u8 *)(& rsstable), (u32 )adapter->rss_info.rss_flags,
                         128, hkey);
#line 1235
  if (rc != 0) {
#line 1236
    adapter->rss_info.rss_flags = 0ULL;
#line 1237
    return (-5);
  } else {

  }
#line 1239
  memcpy((void *)(& adapter->rss_info.rss_hkey), (void const   *)hkey, 40UL);
#line 1240
  memcpy((void *)(& adapter->rss_info.rsstable), (void const   *)(& rsstable), 128UL);
#line 1242
  return (0);
}
}
#line 1245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_module_info(struct net_device *netdev , struct ethtool_modinfo *modinfo ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 page_data[256U] ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1248
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1248
  adapter = (struct be_adapter *)tmp;
#line 1252
  tmp___0 = check_privilege(adapter, 1792U);
#line 1252
  if (tmp___0) {
#line 1252
    tmp___1 = 0;
  } else {
#line 1252
    tmp___1 = 1;
  }
#line 1252
  if (tmp___1) {
#line 1253
    return (-95);
  } else {

  }
#line 1255
  status = be_cmd_read_port_transceiver_data(adapter, 160, (u8 *)(& page_data));
#line 1257
  if (status == 0) {
#line 1258
    if ((unsigned int )page_data[94] == 0U) {
#line 1259
      modinfo->type = 1U;
#line 1260
      modinfo->eeprom_len = 256U;
    } else {
#line 1262
      modinfo->type = 2U;
#line 1263
      modinfo->eeprom_len = 512U;
    }
  } else {

  }
#line 1266
  return (status <= 0 ? status : -5);
}
}
#line 1269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_module_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                                u8 *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1272
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1272
  adapter = (struct be_adapter *)tmp;
#line 1275
  tmp___0 = check_privilege(adapter, 1792U);
#line 1275
  if (tmp___0) {
#line 1275
    tmp___1 = 0;
  } else {
#line 1275
    tmp___1 = 1;
  }
#line 1275
  if (tmp___1) {
#line 1276
    return (-95);
  } else {

  }
#line 1278
  status = be_cmd_read_port_transceiver_data(adapter, 160, data);
#line 1280
  if (status != 0) {
#line 1281
    goto err;
  } else {

  }
#line 1283
  if (eeprom->offset + eeprom->len > 256U) {
#line 1284
    status = be_cmd_read_port_transceiver_data(adapter, 162, data + 256UL);
#line 1288
    if (status != 0) {
#line 1289
      goto err;
    } else {

    }
  } else {

  }
#line 1291
  if (eeprom->offset != 0U) {
#line 1292
    memcpy((void *)data, (void const   *)data + (unsigned long )eeprom->offset,
             (size_t )eeprom->len);
  } else {

  }
  err: ;
#line 1294
  return (status <= 0 ? status : -5);
}
}
#line 1297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.c"
struct ethtool_ops  const  be_ethtool_ops  = 
#line 1297
     {& be_get_settings, 0, & be_get_drvinfo, & be_get_reg_len, & be_get_regs, & be_get_wol,
    & be_set_wol, & be_get_msg_level, & be_set_msg_level, 0, & ethtool_op_get_link,
    & be_get_eeprom_len, & be_read_eeprom, 0, & be_get_coalesce, & be_set_coalesce,
    & be_get_ringparam, 0, & be_get_pauseparam, & be_set_pauseparam, & be_self_test,
    & be_get_stat_strings, & be_set_phys_id, & be_get_ethtool_stats, 0, 0, 0, 0, & be_get_sset_count,
    & be_get_rxnfc, & be_set_rxnfc, & be_do_flash, 0, & be_get_rxfh_key_size, & be_get_rxfh_indir_size,
    & be_get_rxfh, & be_set_rxfh, & be_get_channels, & be_set_channels, 0, 0, & be_set_dump,
    0, & be_get_module_info, & be_get_module_eeprom, 0, 0, 0, 0};
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void ldv_initialize_ethtool_ops_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 113
  tmp = ldv_init_zalloc(36UL);
#line 113
  be_ethtool_ops_group2 = (struct ethtool_channels *)tmp;
#line 114
  tmp___0 = ldv_init_zalloc(92UL);
#line 114
  be_ethtool_ops_group3 = (struct ethtool_coalesce *)tmp___0;
#line 115
  tmp___1 = ldv_init_zalloc(3008UL);
#line 115
  be_ethtool_ops_group6 = (struct net_device *)tmp___1;
#line 116
  tmp___2 = ldv_init_zalloc(16UL);
#line 116
  be_ethtool_ops_group0 = (struct ethtool_eeprom *)tmp___2;
#line 117
  tmp___3 = ldv_init_zalloc(192UL);
#line 117
  be_ethtool_ops_group4 = (struct ethtool_rxnfc *)tmp___3;
#line 118
  tmp___4 = ldv_init_zalloc(20UL);
#line 118
  be_ethtool_ops_group5 = (struct ethtool_wolinfo *)tmp___4;
#line 119
  tmp___5 = ldv_init_zalloc(16UL);
#line 119
  be_ethtool_ops_group1 = (struct ethtool_pauseparam *)tmp___5;
#line 120
  return;
}
}
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void ldv_main_exported_5(void) 
{ 
  u64 *ldvarg47 ;
  void *tmp ;
  u32 ldvarg52 ;
  u32 *ldvarg61 ;
  void *tmp___0 ;
  struct ethtool_test *ldvarg54 ;
  void *tmp___1 ;
  struct ethtool_stats *ldvarg48 ;
  void *tmp___2 ;
  struct ethtool_dump *ldvarg68 ;
  void *tmp___3 ;
  u8 ldvarg63 ;
  void *ldvarg45 ;
  void *tmp___4 ;
  struct ethtool_flash *ldvarg44 ;
  void *tmp___5 ;
  u32 ldvarg55 ;
  u8 *ldvarg64 ;
  void *tmp___6 ;
  struct ethtool_ringparam *ldvarg66 ;
  void *tmp___7 ;
  u64 *ldvarg53 ;
  void *tmp___8 ;
  int ldvarg58 ;
  struct ethtool_cmd *ldvarg57 ;
  void *tmp___9 ;
  u32 *ldvarg65 ;
  void *tmp___10 ;
  struct ethtool_regs *ldvarg46 ;
  void *tmp___11 ;
  struct ethtool_modinfo *ldvarg50 ;
  void *tmp___12 ;
  enum ethtool_phys_id_state ldvarg62 ;
  struct ethtool_drvinfo *ldvarg49 ;
  void *tmp___13 ;
  u8 *ldvarg56 ;
  void *tmp___14 ;
  u8 *ldvarg59 ;
  void *tmp___15 ;
  u8 *ldvarg43 ;
  void *tmp___16 ;
  u8 *ldvarg60 ;
  void *tmp___17 ;
  u32 *ldvarg67 ;
  void *tmp___18 ;
  u8 *ldvarg51 ;
  void *tmp___19 ;
  int tmp___20 ;

  {
#line 123
  tmp = ldv_init_zalloc(8UL);
#line 123
  ldvarg47 = (u64 *)tmp;
#line 125
  tmp___0 = ldv_init_zalloc(4UL);
#line 125
  ldvarg61 = (u32 *)tmp___0;
#line 126
  tmp___1 = ldv_init_zalloc(16UL);
#line 126
  ldvarg54 = (struct ethtool_test *)tmp___1;
#line 127
  tmp___2 = ldv_init_zalloc(8UL);
#line 127
  ldvarg48 = (struct ethtool_stats *)tmp___2;
#line 128
  tmp___3 = ldv_init_zalloc(16UL);
#line 128
  ldvarg68 = (struct ethtool_dump *)tmp___3;
#line 130
  tmp___4 = ldv_init_zalloc(1UL);
#line 130
  ldvarg45 = tmp___4;
#line 131
  tmp___5 = ldv_init_zalloc(136UL);
#line 131
  ldvarg44 = (struct ethtool_flash *)tmp___5;
#line 133
  tmp___6 = ldv_init_zalloc(1UL);
#line 133
  ldvarg64 = (u8 *)tmp___6;
#line 134
  tmp___7 = ldv_init_zalloc(36UL);
#line 134
  ldvarg66 = (struct ethtool_ringparam *)tmp___7;
#line 135
  tmp___8 = ldv_init_zalloc(8UL);
#line 135
  ldvarg53 = (u64 *)tmp___8;
#line 137
  tmp___9 = ldv_init_zalloc(44UL);
#line 137
  ldvarg57 = (struct ethtool_cmd *)tmp___9;
#line 138
  tmp___10 = ldv_init_zalloc(4UL);
#line 138
  ldvarg65 = (u32 *)tmp___10;
#line 139
  tmp___11 = ldv_init_zalloc(12UL);
#line 139
  ldvarg46 = (struct ethtool_regs *)tmp___11;
#line 140
  tmp___12 = ldv_init_zalloc(44UL);
#line 140
  ldvarg50 = (struct ethtool_modinfo *)tmp___12;
#line 142
  tmp___13 = ldv_init_zalloc(196UL);
#line 142
  ldvarg49 = (struct ethtool_drvinfo *)tmp___13;
#line 143
  tmp___14 = ldv_init_zalloc(1UL);
#line 143
  ldvarg56 = (u8 *)tmp___14;
#line 144
  tmp___15 = ldv_init_zalloc(1UL);
#line 144
  ldvarg59 = (u8 *)tmp___15;
#line 145
  tmp___16 = ldv_init_zalloc(1UL);
#line 145
  ldvarg43 = (u8 *)tmp___16;
#line 146
  tmp___17 = ldv_init_zalloc(1UL);
#line 146
  ldvarg60 = (u8 *)tmp___17;
#line 147
  tmp___18 = ldv_init_zalloc(4UL);
#line 147
  ldvarg67 = (u32 *)tmp___18;
#line 148
  tmp___19 = ldv_init_zalloc(1UL);
#line 148
  ldvarg51 = (u8 *)tmp___19;
#line 124
  ldv_memset((void *)(& ldvarg52), 0, 4UL);
#line 129
  ldv_memset((void *)(& ldvarg63), 0, 1UL);
#line 132
  ldv_memset((void *)(& ldvarg55), 0, 4UL);
#line 136
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 141
  ldv_memset((void *)(& ldvarg62), 0, 4UL);
#line 150
  tmp___20 = __VERIFIER_nondet_int();
#line 150
  switch (tmp___20) {
  case 0: ;
#line 153
  if (ldv_state_variable_5 == 1) {
#line 155
    be_set_dump(be_ethtool_ops_group6, ldvarg68);
#line 157
    ldv_state_variable_5 = 1;
  } else {

  }
#line 160
  goto ldv_57637;
  case 1: ;
#line 163
  if (ldv_state_variable_5 == 1) {
#line 165
    be_set_rxnfc(be_ethtool_ops_group6, be_ethtool_ops_group4);
#line 167
    ldv_state_variable_5 = 1;
  } else {

  }
#line 170
  goto ldv_57637;
  case 2: ;
#line 173
  if (ldv_state_variable_5 == 1) {
#line 175
    be_get_rxnfc(be_ethtool_ops_group6, be_ethtool_ops_group4, ldvarg67);
#line 177
    ldv_state_variable_5 = 1;
  } else {

  }
#line 180
  goto ldv_57637;
  case 3: ;
#line 183
  if (ldv_state_variable_5 == 1) {
#line 185
    be_get_ringparam(be_ethtool_ops_group6, ldvarg66);
#line 187
    ldv_state_variable_5 = 1;
  } else {

  }
#line 190
  goto ldv_57637;
  case 4: ;
#line 193
  if (ldv_state_variable_5 == 1) {
#line 195
    be_set_rxfh(be_ethtool_ops_group6, (u32 const   *)ldvarg65, (u8 const   *)ldvarg64,
                (int )ldvarg63);
#line 197
    ldv_state_variable_5 = 1;
  } else {

  }
#line 200
  goto ldv_57637;
  case 5: ;
#line 203
  if (ldv_state_variable_5 == 1) {
#line 205
    be_set_phys_id(be_ethtool_ops_group6, ldvarg62);
#line 207
    ldv_state_variable_5 = 1;
  } else {

  }
#line 210
  goto ldv_57637;
  case 6: ;
#line 213
  if (ldv_state_variable_5 == 1) {
#line 215
    be_get_pauseparam(be_ethtool_ops_group6, be_ethtool_ops_group1);
#line 217
    ldv_state_variable_5 = 1;
  } else {

  }
#line 220
  goto ldv_57637;
  case 7: ;
#line 223
  if (ldv_state_variable_5 == 1) {
#line 225
    be_set_channels(be_ethtool_ops_group6, be_ethtool_ops_group2);
#line 227
    ldv_state_variable_5 = 1;
  } else {

  }
#line 230
  goto ldv_57637;
  case 8: ;
#line 233
  if (ldv_state_variable_5 == 1) {
#line 235
    be_get_rxfh(be_ethtool_ops_group6, ldvarg61, ldvarg60, ldvarg59);
#line 237
    ldv_state_variable_5 = 1;
  } else {

  }
#line 240
  goto ldv_57637;
  case 9: ;
#line 243
  if (ldv_state_variable_5 == 1) {
#line 245
    be_get_sset_count(be_ethtool_ops_group6, ldvarg58);
#line 247
    ldv_state_variable_5 = 1;
  } else {

  }
#line 250
  goto ldv_57637;
  case 10: ;
#line 253
  if (ldv_state_variable_5 == 1) {
#line 255
    be_get_settings(be_ethtool_ops_group6, ldvarg57);
#line 257
    ldv_state_variable_5 = 1;
  } else {

  }
#line 260
  goto ldv_57637;
  case 11: ;
#line 263
  if (ldv_state_variable_5 == 1) {
#line 265
    be_set_coalesce(be_ethtool_ops_group6, be_ethtool_ops_group3);
#line 267
    ldv_state_variable_5 = 1;
  } else {

  }
#line 270
  goto ldv_57637;
  case 12: ;
#line 273
  if (ldv_state_variable_5 == 1) {
#line 275
    be_get_module_eeprom(be_ethtool_ops_group6, be_ethtool_ops_group0, ldvarg56);
#line 277
    ldv_state_variable_5 = 1;
  } else {

  }
#line 280
  goto ldv_57637;
  case 13: ;
#line 283
  if (ldv_state_variable_5 == 1) {
#line 285
    be_set_msg_level(be_ethtool_ops_group6, ldvarg55);
#line 287
    ldv_state_variable_5 = 1;
  } else {

  }
#line 290
  goto ldv_57637;
  case 14: ;
#line 293
  if (ldv_state_variable_5 == 1) {
#line 295
    be_get_eeprom_len(be_ethtool_ops_group6);
#line 297
    ldv_state_variable_5 = 1;
  } else {

  }
#line 300
  goto ldv_57637;
  case 15: ;
#line 303
  if (ldv_state_variable_5 == 1) {
#line 305
    be_self_test(be_ethtool_ops_group6, ldvarg54, ldvarg53);
#line 307
    ldv_state_variable_5 = 1;
  } else {

  }
#line 310
  goto ldv_57637;
  case 16: ;
#line 313
  if (ldv_state_variable_5 == 1) {
#line 315
    be_get_stat_strings(be_ethtool_ops_group6, ldvarg52, ldvarg51);
#line 317
    ldv_state_variable_5 = 1;
  } else {

  }
#line 320
  goto ldv_57637;
  case 17: ;
#line 323
  if (ldv_state_variable_5 == 1) {
#line 325
    be_get_module_info(be_ethtool_ops_group6, ldvarg50);
#line 327
    ldv_state_variable_5 = 1;
  } else {

  }
#line 330
  goto ldv_57637;
  case 18: ;
#line 333
  if (ldv_state_variable_5 == 1) {
#line 335
    be_get_rxfh_key_size(be_ethtool_ops_group6);
#line 337
    ldv_state_variable_5 = 1;
  } else {

  }
#line 340
  goto ldv_57637;
  case 19: ;
#line 343
  if (ldv_state_variable_5 == 1) {
#line 345
    be_get_channels(be_ethtool_ops_group6, be_ethtool_ops_group2);
#line 347
    ldv_state_variable_5 = 1;
  } else {

  }
#line 350
  goto ldv_57637;
  case 20: ;
#line 353
  if (ldv_state_variable_5 == 1) {
#line 355
    ethtool_op_get_link(be_ethtool_ops_group6);
#line 357
    ldv_state_variable_5 = 1;
  } else {

  }
#line 360
  goto ldv_57637;
  case 21: ;
#line 363
  if (ldv_state_variable_5 == 1) {
#line 365
    be_get_drvinfo(be_ethtool_ops_group6, ldvarg49);
#line 367
    ldv_state_variable_5 = 1;
  } else {

  }
#line 370
  goto ldv_57637;
  case 22: ;
#line 373
  if (ldv_state_variable_5 == 1) {
#line 375
    be_set_pauseparam(be_ethtool_ops_group6, be_ethtool_ops_group1);
#line 377
    ldv_state_variable_5 = 1;
  } else {

  }
#line 380
  goto ldv_57637;
  case 23: ;
#line 383
  if (ldv_state_variable_5 == 1) {
#line 385
    be_get_ethtool_stats(be_ethtool_ops_group6, ldvarg48, ldvarg47);
#line 387
    ldv_state_variable_5 = 1;
  } else {

  }
#line 390
  goto ldv_57637;
  case 24: ;
#line 393
  if (ldv_state_variable_5 == 1) {
#line 395
    be_get_coalesce(be_ethtool_ops_group6, be_ethtool_ops_group3);
#line 397
    ldv_state_variable_5 = 1;
  } else {

  }
#line 400
  goto ldv_57637;
  case 25: ;
#line 403
  if (ldv_state_variable_5 == 1) {
#line 405
    be_get_regs(be_ethtool_ops_group6, ldvarg46, ldvarg45);
#line 407
    ldv_state_variable_5 = 1;
  } else {

  }
#line 410
  goto ldv_57637;
  case 26: ;
#line 413
  if (ldv_state_variable_5 == 1) {
#line 415
    be_get_rxfh_indir_size(be_ethtool_ops_group6);
#line 417
    ldv_state_variable_5 = 1;
  } else {

  }
#line 420
  goto ldv_57637;
  case 27: ;
#line 423
  if (ldv_state_variable_5 == 1) {
#line 425
    be_set_wol(be_ethtool_ops_group6, be_ethtool_ops_group5);
#line 427
    ldv_state_variable_5 = 1;
  } else {

  }
#line 430
  goto ldv_57637;
  case 28: ;
#line 433
  if (ldv_state_variable_5 == 1) {
#line 435
    be_do_flash(be_ethtool_ops_group6, ldvarg44);
#line 437
    ldv_state_variable_5 = 1;
  } else {

  }
#line 440
  goto ldv_57637;
  case 29: ;
#line 443
  if (ldv_state_variable_5 == 1) {
#line 445
    be_read_eeprom(be_ethtool_ops_group6, be_ethtool_ops_group0, ldvarg43);
#line 447
    ldv_state_variable_5 = 1;
  } else {

  }
#line 450
  goto ldv_57637;
  case 30: ;
#line 453
  if (ldv_state_variable_5 == 1) {
#line 455
    be_get_wol(be_ethtool_ops_group6, be_ethtool_ops_group5);
#line 457
    ldv_state_variable_5 = 1;
  } else {

  }
#line 460
  goto ldv_57637;
  case 31: ;
#line 463
  if (ldv_state_variable_5 == 1) {
#line 465
    be_get_msg_level(be_ethtool_ops_group6);
#line 467
    ldv_state_variable_5 = 1;
  } else {

  }
#line 470
  goto ldv_57637;
  case 32: ;
#line 473
  if (ldv_state_variable_5 == 1) {
#line 475
    be_get_reg_len(be_ethtool_ops_group6);
#line 477
    ldv_state_variable_5 = 1;
  } else {

  }
#line 480
  goto ldv_57637;
  default: 
#line 481
  ldv_stop();
  }
  ldv_57637: ;
#line 485
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 514
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 514
  ldv_func_res = tmp;
#line 516
  activate_work_3(ldv_func_arg3, 2);
#line 518
  return (ldv_func_res);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 525
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 525
  ldv_func_res = tmp;
#line 527
  activate_work_3(& ldv_func_arg3->work, 2);
#line 529
  return (ldv_func_res);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 536
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 536
  ldv_func_res = tmp;
#line 538
  activate_work_3(ldv_func_arg3, 2);
#line 540
  return (ldv_func_res);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 546
  flush_workqueue(ldv_func_arg1);
#line 548
  call_and_disable_all_3(2);
#line 549
  return;
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 555
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 555
  ldv_func_res = tmp;
#line 557
  activate_work_3(& ldv_func_arg3->work, 2);
#line 559
  return (ldv_func_res);
}
}
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 113
extern void list_del(struct list_head * ) ;
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) ;
#line 3100 "include/linux/netdevice.h"
__inline static bool netif_oper_up(struct net_device  const  *dev ) 
{ 


  {
#line 3102
  return ((bool )((unsigned int )((unsigned char )dev->operstate) == 6U || (unsigned int )((unsigned char )dev->operstate) == 0U));
}
}
#line 72 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_register_driver(struct ocrdma_driver *drv ) ;
#line 73
void be_roce_unregister_driver(struct ocrdma_driver *drv ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct ocrdma_driver *ocrdma_drv  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct list_head be_adapter_list  =    {& be_adapter_list, & be_adapter_list};
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct mutex be_adapter_list_lock  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "be_adapter_list_lock.wait_lock",
                                                          0, 0UL}}}}, {& be_adapter_list_lock.wait_list,
                                                                       & be_adapter_list_lock.wait_list},
    0, (void *)(& be_adapter_list_lock), {0, {0, 0}, "be_adapter_list_lock", 0, 0UL}};
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_add(struct be_adapter *adapter ) 
{ 
  struct be_dev_info dev_info ;
  int i ;
  int num_vec ;
  struct pci_dev *pdev ;
  int _min1 ;
  int _min2 ;

  {
#line 34
  pdev = adapter->pdev;
#line 36
  if ((unsigned long )ocrdma_drv == (unsigned long )((struct ocrdma_driver *)0)) {
#line 37
    return;
  } else {

  }
#line 39
  if (ocrdma_drv->be_abi_version != 1U) {
#line 40
    dev_warn((struct device  const  *)(& pdev->dev), "Cannot initialize RoCE due to ocrdma ABI mismatch\n");
#line 41
    return;
  } else {

  }
#line 44
  if ((unsigned int )pdev->device == 1824U) {
#line 46
    if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 47
      return;
    } else {

    }
#line 49
    dev_info.dpp_unmapped_addr = pdev->resource[2].start;
#line 50
    dev_info.dpp_unmapped_len = pdev->resource[2].start != 0ULL || pdev->resource[2].end != pdev->resource[2].start ? ((u32 )pdev->resource[2].end - (u32 )pdev->resource[2].start) + 1U : 0U;
  } else {
#line 52
    dev_info.dpp_unmapped_addr = 0ULL;
#line 53
    dev_info.dpp_unmapped_len = 0U;
  }
#line 55
  dev_info.pdev = adapter->pdev;
#line 56
  dev_info.db = adapter->db;
#line 57
  dev_info.unmapped_db = adapter->roce_db.io_addr;
#line 58
  dev_info.db_page_size = adapter->roce_db.size;
#line 59
  dev_info.db_total_size = adapter->roce_db.total_size;
#line 60
  dev_info.netdev = adapter->netdev;
#line 61
  memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
           6UL);
#line 62
  dev_info.dev_family = adapter->sli_family;
#line 63
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 67
    num_vec = (int )((u32 )adapter->num_msix_vec + adapter->num_msix_roce_vec);
#line 68
    dev_info.intr_mode = 0;
#line 69
    _min1 = num_vec;
#line 69
    _min2 = 32;
#line 69
    dev_info.msix.num_vectors = _min1 < _min2 ? _min1 : _min2;
#line 74
    dev_info.msix.start_vector = (int )adapter->num_evt_qs;
#line 75
    i = 0;
#line 75
    goto ldv_57167;
    ldv_57166: 
#line 76
    dev_info.msix.vector_list[i] = adapter->msix_entries[i].vector;
#line 75
    i = i + 1;
    ldv_57167: ;
#line 75
    if (dev_info.msix.num_vectors > i) {
#line 77
      goto ldv_57166;
    } else {

    }

  } else {
#line 80
    dev_info.msix.num_vectors = 0;
#line 81
    dev_info.intr_mode = 1;
  }
#line 83
  adapter->ocrdma_dev = (*(ocrdma_drv->add))(& dev_info);
#line 84
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_add(struct be_adapter *adapter ) 
{ 


  {
#line 88
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 89
    INIT_LIST_HEAD(& adapter->entry);
#line 90
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 91
    list_add_tail(& adapter->entry, & be_adapter_list);
#line 97
    _be_roce_dev_add(adapter);
#line 98
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 100
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 104
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )ocrdma_drv->remove != (unsigned long )((void (*)(struct ocrdma_dev * ))0)) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 105
    (*(ocrdma_drv->remove))(adapter->ocrdma_dev);
  } else {

  }
#line 106
  adapter->ocrdma_dev = (struct ocrdma_dev *)0;
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 111
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 112
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 113
    _be_roce_dev_remove(adapter);
#line 114
    list_del(& adapter->entry);
#line 115
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 117
  return;
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 121
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 123
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 0U);
  } else {

  }
#line 124
  return;
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 129
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 130
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 131
    _be_roce_dev_open(adapter);
#line 132
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 134
  return;
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 138
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 140
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 1U);
  } else {

  }
#line 141
  return;
}
}
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 146
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 147
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 148
    _be_roce_dev_close(adapter);
#line 149
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 151
  return;
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_shutdown(struct be_adapter *adapter ) 
{ 


  {
#line 155
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 156
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 157
    if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                         u32  ))0)) {
#line 159
      (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 2U);
    } else {

    }
#line 161
    mutex_unlock(& be_adapter_list_lock);
  } else {

  }
#line 163
  return;
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
int be_roce_register_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct net_device *netdev ;
  bool tmp ;
  bool tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 169
  mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 170
  if ((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0)) {
#line 171
    mutex_unlock(& be_adapter_list_lock);
#line 172
    return (-22);
  } else {

  }
#line 174
  ocrdma_drv = drv;
#line 175
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 175
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb8130UL;
#line 175
  goto ldv_57203;
  ldv_57202: 
#line 178
  _be_roce_dev_add(dev);
#line 179
  netdev = dev->netdev;
#line 180
  tmp = netif_running((struct net_device  const  *)netdev);
#line 180
  if ((int )tmp) {
#line 180
    tmp___0 = netif_oper_up((struct net_device  const  *)netdev);
#line 180
    if ((int )tmp___0) {
#line 181
      _be_roce_dev_open(dev);
    } else {

    }
  } else {

  }
#line 175
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 175
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb8130UL;
  ldv_57203: ;
#line 175
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 177
    goto ldv_57202;
  } else {

  }
#line 183
  mutex_unlock(& be_adapter_list_lock);
#line 184
  return (0);
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static char const   __kstrtab_be_roce_register_driver[24U]  = 
#line 186
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'r',      'e',      'g',      'i', 
        's',      't',      'e',      'r', 
        '_',      'd',      'r',      'i', 
        'v',      'e',      'r',      '\000'};
#line 186
struct kernel_symbol  const  __ksymtab_be_roce_register_driver ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
struct kernel_symbol  const  __ksymtab_be_roce_register_driver  =    {(unsigned long )(& be_roce_register_driver), (char const   *)(& __kstrtab_be_roce_register_driver)};
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_unregister_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 192
  mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 193
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 193
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb8130UL;
#line 193
  goto ldv_57221;
  ldv_57220: ;
#line 194
  if ((unsigned long )dev->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 195
    _be_roce_dev_remove(dev);
  } else {

  }
#line 193
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 193
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb8130UL;
  ldv_57221: ;
#line 193
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 195
    goto ldv_57220;
  } else {

  }
#line 197
  ocrdma_drv = (struct ocrdma_driver *)0;
#line 198
  mutex_unlock(& be_adapter_list_lock);
#line 199
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
static char const   __kstrtab_be_roce_unregister_driver[26U]  = 
#line 200
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'u',      'n',      'r',      'e', 
        'g',      'i',      's',      't', 
        'e',      'r',      '_',      'd', 
        'r',      'i',      'v',      'e', 
        'r',      '\000'};
#line 200
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.c"
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver  =    {(unsigned long )(& be_roce_unregister_driver), (char const   *)(& __kstrtab_be_roce_unregister_driver)};
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 139
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 139
  ldv_func_res = tmp;
#line 141
  activate_work_3(ldv_func_arg3, 2);
#line 143
  return (ldv_func_res);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 150
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 150
  ldv_func_res = tmp;
#line 152
  activate_work_3(& ldv_func_arg3->work, 2);
#line 154
  return (ldv_func_res);
}
}
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 161
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 161
  ldv_func_res = tmp;
#line 163
  activate_work_3(ldv_func_arg3, 2);
#line 165
  return (ldv_func_res);
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 171
  flush_workqueue(ldv_func_arg1);
#line 173
  call_and_disable_all_3(2);
#line 174
  return;
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/dscv/ri/08_1a/drivers/net/ethernet/emulex/benet/be_roce.o.c.prepared"
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 180
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 180
  ldv_func_res = tmp;
#line 182
  activate_work_3(& ldv_func_arg3->work, 2);
#line 184
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/11140/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
